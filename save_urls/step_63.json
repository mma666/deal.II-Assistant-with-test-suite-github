"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_63.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-63 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-63 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-63 tutorial program\\n\\n\\nThis tutorial depends on step-16.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nEquation\\n\\nStreamline diffusion\\n\\nSmoothers\\nTest problem\\n\\n The commented program\\n\\nInclude files\\nMeshWorker data\\nProblem parameters\\nCell permutations\\nRight-hand side and boundary values\\nStreamline diffusion implementation\\nAdvectionProblem class\\n\\nAdvectionProblem::setup_system()\\nAdvectionProblem::assemble_cell()\\nAdvectionProblem::assemble_system_and_multigrid()\\nAdvectionProblem::setup_smoother()\\nAdvectionProblem::solve()\\nAdvectionProblem::output_results()\\nAdvectionProblem::run()\\n\\nThe main function\\n\\n\\n Results\\n\\n GMRES Iteration Numbers \\n\\n DoF/Cell Renumbering \\n Point vs. block smoothers \\n\\n Cost \\n Additional points \\n Possibilities for extensions \\n\\n Constant iterations for Q5 \\n Effectiveness of renumbering for changing epsilon \\n Mesh adaptivity \\n\\n\\n The plain program\\n   \\n\\n\\nThis program was contributed by Thomas C. Clevenger and Timo Heister.\\nThe creation of this tutorial was partially supported by NSF Award DMS-1522191, DMS-1901529, OAC-1835452, by the Computational Infrastructure in Geodynamics initiative (CIG), through the NSF under Award EAR-0949446 and EAR-1550901 and The University of California - Davis. \\nNoteIf you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation:   \\n Introduction\\nThis program solves an advection-diffusion problem using a geometric multigrid (GMG) preconditioner. The basics of this preconditioner are discussed in step-16; here we discuss the necessary changes needed for a non-symmetric PDE. Additionally, we introduce the idea of block smoothing (as compared to point smoothing in step-16), and examine the effects of DoF renumbering for additive and multiplicative smoothers.\\nEquation\\nThe advection-diffusion equation is given by     \\n\\\\begin{align*}\\n-\\\\varepsilon \\\\Delta u + \\\\boldsymbol{\\\\beta}\\\\cdot \\\\nabla u & = f &\\n\\\\text{ in } \\\\Omega\\\\\\\\\\nu &= g & \\\\text{ on } \\\\partial\\\\Omega\\n\\\\end{align*}\\n\\n where \\\\(\\\\varepsilon>0\\\\), \\\\(\\\\boldsymbol{\\\\beta}\\\\) is the advection direction, and \\\\(f\\\\) is a source. A few notes:\\n\\nIf \\\\(\\\\boldsymbol{\\\\beta}=\\\\boldsymbol{0}\\\\), this is the Laplace equation solved in step-16 (and many other places).\\nIf \\\\(\\\\varepsilon=0\\\\) then this is the stationary advection equation solved in step-9.\\nOne can define a dimensionless number for this problem, called the Peclet number:  \\\\(\\\\mathcal{P} \\\\dealcoloneq \\\\frac{\\\\|\\\\boldsymbol{\\\\beta}\\\\|\\nL}{\\\\varepsilon}\\\\), where \\\\(L\\\\) is the length scale of the domain. It characterizes the kind of equation we are considering: If \\\\(\\\\mathcal{P}>1\\\\), we say the problem is advection-dominated, else if \\\\(\\\\mathcal{P}<1\\\\) we will say the problem is diffusion-dominated.\\n\\nFor the discussion in this tutorial we will be concerned with advection-dominated flow. This is the complicated case: We know that for diffusion-dominated problems, the standard Galerkin method works just fine, and we also know that simple multigrid methods such as those defined in step-16 are very efficient. On the other hand, for advection-dominated problems, the standard Galerkin approach leads to oscillatory and unstable discretizations, and simple solvers are often not very efficient. This tutorial program is therefore intended to address both of these issues.\\nStreamline diffusion\\nUsing the standard Galerkin finite element method, for suitable test functions \\\\(v_h\\\\), a discrete weak form of the PDE would read   \\n\\\\begin{align*}\\na(u_h,v_h) = F(v_h)\\n\\\\end{align*}\\n\\n where     \\n\\\\begin{align*}\\na(u_h,v_h) &= (\\\\varepsilon \\\\nabla v_h,\\\\, \\\\nabla u_h) +\\n(v_h,\\\\,\\\\boldsymbol{\\\\beta}\\\\cdot \\\\nabla u_h),\\\\\\\\\\nF(v_h) &= (v_h,\\\\,f).\\n\\\\end{align*}\\n\\nUnfortunately, one typically gets oscillatory solutions with this approach. Indeed, the following error estimate can be shown for this formulation:   \\n\\\\begin{align*}\\n\\\\|\\\\nabla (u-u_h)\\\\| \\\\leq (1+\\\\mathcal{P}) \\\\inf_{v_h} \\\\|\\\\nabla (u-v_h)\\\\|.\\n\\\\end{align*}\\n\\n The infimum on the right can be estimated as follows if the exact solution is sufficiently smooth:         \\n\\\\begin{align*}\\n  \\\\inf_{v_h} \\\\|\\\\nabla (u-v_h)\\\\|.\\n  \\\\le\\n  \\\\|\\\\nabla (u-I_h u)\\\\|\\n  \\\\le\\n  h^k\\n  C\\n  \\\\|\\\\nabla^k u)\\\\|\\n\\\\end{align*}\\n\\n where \\\\(k\\\\) is the polynomial degree of the finite elements used. As a consequence, we obtain the estimate     \\n\\\\begin{align*}\\n\\\\|\\\\nabla (u-u_h)\\\\|\\n\\\\leq (1+\\\\mathcal{P}) C h^k\\n  \\\\|\\\\nabla^k u)\\\\|.\\n\\\\end{align*}\\n\\n In other words, the numerical solution will converge. On the other hand, given the definition of \\\\(\\\\mathcal{P}\\\\) above, we have to expect poor numerical solutions with a large error when  \\\\(\\\\varepsilon \\\\ll\\n\\\\|\\\\boldsymbol{\\\\beta}\\\\| L\\\\), i.e., if the problem has only a small amount of diffusion.\\nTo combat this, we will consider the new weak form     \\n\\\\begin{align*}\\na(u_h,\\\\,v_h) + \\\\sum_K (-\\\\varepsilon \\\\Delta u_h +\\n\\\\boldsymbol{\\\\beta}\\\\cdot \\\\nabla u_h-f,\\\\,\\\\delta_K\\n\\\\boldsymbol{\\\\beta}\\\\cdot \\\\nabla v_h)_K = F(v_h)\\n\\\\end{align*}\\n\\n where the sum is done over all cells \\\\(K\\\\) with the inner product taken for each cell, and \\\\(\\\\delta_K\\\\) is a cell-wise constant stabilization parameter defined in [122].\\nEssentially, adding in the discrete strong form residual enhances the coercivity of the bilinear form \\\\(a(\\\\cdot,\\\\cdot)\\\\) which increases the stability of the discrete solution. This method is commonly referred to as streamline diffusion or SUPG (streamline upwind/Petrov-Galerkin).\\nSmoothers\\nOne of the goals of this tutorial is to expand from using a simple (point-wise) Gauss-Seidel (SOR) smoother that is used in step-16 (class PreconditionSOR) on each level of the multigrid hierarchy. The term \\\"point-wise\\\" is traditionally used in solvers to indicate that one solves at one \\\"grid point\\\" at a time; for scalar problems, this means to use a solver that updates one unknown of the linear system at a time, keeping all of the others fixed; one would then iterate over all unknowns in the problem and, once done, start over again from the first unknown until these \\\"sweeps\\\" converge. Jacobi, Gauss-Seidel, and SOR iterations can all be interpreted in this way. In the context of multigrid, one does not think of these methods as \\\"solvers\\\", but as \\\"smoothers\\\". As such, one is not interested in actually solving the linear system. It is enough to remove the high-frequency part of the residual for the multigrid method to work, because that allows restricting the solution to a coarser mesh. Therefore, one only does a few, fixed number of \\\"sweeps\\\" over all unknowns. In the code in this tutorial this is controlled by the \\\"Smoothing steps\\\" parameter.\\nBut these methods are known to converge rather slowly when used as solvers. While as multigrid smoothers, they are surprisingly good, they can also be improved upon. In particular, we consider \\\"cell-based\\\" smoothers here as well. These methods solve for all unknowns on a cell at once, keeping all other unknowns fixed; they then move on to the next cell, and so on and so forth. One can think of them as \\\"block\\\" versions of Jacobi, Gauss-Seidel, or SOR, but because degrees of freedom are shared among multiple cells, these blocks overlap and the methods are in fact best be explained within the framework of additive and multiplicative Schwarz methods.\\nIn contrast to step-16, our test problem contains an advective term. Especially with a small diffusion constant \\\\(\\\\varepsilon\\\\), information is transported along streamlines in the given advection direction. This means that smoothers are likely to be more effective if they allow information to travel in downstream direction within a single smoother application. If we want to solve one unknown (or block of unknowns) at a time in the order in which these unknowns (or blocks) are enumerated, then this information propagation property requires reordering degrees of freedom or cells (for the cell-based smoothers) accordingly so that the ones further upstream are treated earlier (have lower indices) and those further downstream are treated later (have larger indices). The influence of the ordering will be visible in the results section.\\nLet us now briefly define the smoothers used in this tutorial. For a more detailed introduction, we refer to [125] and the books [195] and [200]. A Schwarz preconditioner requires a decomposition   \\n\\\\begin{align*}\\nV = \\\\sum_{j=1}^J V_j\\n\\\\end{align*}\\n\\n of our finite element space \\\\(V\\\\). Each subproblem \\\\(V_j\\\\) also has a Ritz projection \\\\(P_j: V \\\\rightarrow V_j\\\\) based on the bilinear form \\\\(a(\\\\cdot,\\\\cdot)\\\\). This projection induces a local operator \\\\(A_j\\\\) for each subproblem \\\\(V_j\\\\). If \\\\(\\\\Pi_j:V\\\\rightarrow V_j\\\\) is the orthogonal projector onto \\\\(V_j\\\\), one can show \\\\(A_jP_j=\\\\Pi_j^TA\\\\).\\nWith this we can define an additive Schwarz preconditioner for the operator \\\\(A\\\\) as   \\n\\\\begin{align*}\\n B^{-1} = \\\\sum_{j=1}^J P_j A^{-1} = \\\\sum_{j=1}^J A_j^{-1} \\\\Pi_j^T.\\n\\\\end{align*}\\n\\n In other words, we project our solution into each subproblem, apply the inverse of the subproblem \\\\(A_j\\\\), and sum the contributions up over all \\\\(j\\\\).\\nNote that one can interpret the point-wise (one unknown at a time) Jacobi method as an additive Schwarz method by defining a subproblem \\\\(V_j\\\\) for each degree of freedom. Then, \\\\(A_j^{-1}\\\\) becomes a multiplication with the inverse of a diagonal entry of \\\\(A\\\\).\\nFor the \\\"Block Jacobi\\\" method used in this tutorial, we define a subproblem \\\\(V_j\\\\) for each cell of the mesh on the current level. Note that we use a continuous finite element, so these blocks are overlapping, as degrees of freedom on an interface between two cells belong to both subproblems. The logic for the Schwarz operator operating on the subproblems (in deal.II they are called \\\"blocks\\\") is implemented in the class RelaxationBlock. The \\\"Block\\nJacobi\\\" method is implemented in the class RelaxationBlockJacobi. Many aspects of the class (for example how the blocks are defined and how to invert the local subproblems \\\\(A_j\\\\)) can be configured in the smoother data, see RelaxationBlock::AdditionalData and DoFTools::make_cell_patches() for details.\\nSo far, we discussed additive smoothers where the updates can be applied independently and there is no information flowing within a single smoother application. A multiplicative Schwarz preconditioner addresses this and is defined by   \\n\\\\begin{align*}\\n B^{-1} = \\\\left( I- \\\\prod_{j=1}^J \\\\left(I-P_j\\\\right) \\\\right) A^{-1}.\\n\\\\end{align*}\\n\\n In contrast to above, the updates on the subproblems \\\\(V_j\\\\) are applied sequentially. This means that the update obtained when inverting the subproblem \\\\(A_j\\\\) is immediately used in \\\\(A_{j+1}\\\\). This becomes visible when writing out the project:                \\n\\\\begin{align*}\\n B^{-1}\\n =\\n \\\\left(\\n   I\\n   -\\n   \\\\left(I-P_1\\\\right)\\\\left(I-P_2\\\\right)\\\\cdots\\\\left(I-P_J\\\\right)\\n \\\\right)\\n A^{-1}\\n =\\n   A^{-1}\\n   -\\n   \\\\left[ \\\\left(I-P_1\\\\right)\\n   \\\\left[ \\\\left(I-P_2\\\\right)\\\\cdots\\n     \\\\left[\\\\left(I-P_J\\\\right) A^{-1}\\\\right] \\\\cdots \\\\right] \\\\right]\\n\\\\end{align*}\\n\\nWhen defining the sub-spaces \\\\(V_j\\\\) as whole blocks of degrees of freedom, this method is implemented in the class RelaxationBlockSOR and used when you select \\\"Block SOR\\\" in this tutorial. The class RelaxationBlockSOR is also derived from RelaxationBlock. As such, both additive and multiplicative Schwarz methods are implemented in a unified framework.\\nFinally, let us note that the standard Gauss-Seidel (or SOR) method can be seen as a multiplicative Schwarz method with a subproblem for each DoF.\\nTest problem\\nWe will be considering the following test problem:  \\\\(\\\\Omega =\\n[-1,\\\\,1]\\\\times[-1,\\\\,1]\\\\backslash B_{0.3}(0)\\\\), i.e., a square with a circle of radius 0.3 centered at the origin removed. In addition, we use \\\\(\\\\varepsilon=0.005\\\\),  \\\\(\\\\boldsymbol{\\\\beta} =\\n[-\\\\sin(\\\\pi/6),\\\\,\\\\cos(\\\\pi/6)]\\\\), \\\\(f=0\\\\), and Dirichlet boundary values    \\n\\\\begin{align*}\\ng = \\\\left\\\\{\\\\begin{array}{ll} 1 & \\\\text{if } x=-1 \\\\text{ or } y=-1,\\\\,x\\\\geq 0.5 \\\\\\\\\\n0 & \\\\text{otherwise} \\\\end{array}\\\\right.\\n\\\\end{align*}\\n\\nThe following figures depict the solutions with (left) and without (right) streamline diffusion. Without streamline diffusion we see large oscillations around the boundary layer, demonstrating the instability of the standard Galerkin finite element method for this problem.\\n\\n\\n  \\n\\n The commented program\\n Include files\\nTypical files needed for standard deal.II:\\n\\u00a0 #include <deal.II/base/tensor_function.h>\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/base/timer.h>\\n\\u00a0 #include <deal.II/base/parameter_handler.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/solver_gmres.h>\\n\\u00a0 #include <deal.II/lac/precondition.h>\\n\\u00a0 #include <deal.II/lac/relaxation_block.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_refinement.h>\\n\\u00a0 #include <deal.II/grid/manifold_lib.h>\\n\\u00a0 #include <deal.II/grid/grid_out.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_renumbering.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/mapping_q.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 \\nInclude all relevant multilevel files:\\n\\u00a0 #include <deal.II/multigrid/mg_constrained_dofs.h>\\n\\u00a0 #include <deal.II/multigrid/multigrid.h>\\n\\u00a0 #include <deal.II/multigrid/mg_transfer.h>\\n\\u00a0 #include <deal.II/multigrid/mg_tools.h>\\n\\u00a0 #include <deal.II/multigrid/mg_coarse.h>\\n\\u00a0 #include <deal.II/multigrid/mg_smoother.h>\\n\\u00a0 #include <deal.II/multigrid/mg_matrix.h>\\n\\u00a0 \\nC++:\\n\\u00a0 #include <algorithm>\\n\\u00a0 #include <fstream>\\n\\u00a0 #include <iostream>\\n\\u00a0 #include <random>\\n\\u00a0 \\nWe will be using MeshWorker::mesh_loop functionality for assembling matrices:\\n\\u00a0 #include <deal.II/meshworker/mesh_loop.h>\\n\\u00a0 \\n\\u00a0 \\n MeshWorker data\\nAs always, we will be putting everything related to this program into a namespace of its own.\\nSince we will be using the MeshWorker framework, the first step is to define the following structures needed by the assemble_cell() function used by MeshWorker::mesh_loop(): ScratchData contains an FEValues object which is needed for assembling a cell's local contribution, while CopyData contains the output from a cell's local contribution and necessary information to copy that to the global system. (Their purpose is also explained in the documentation of the WorkStream class.)\\n\\u00a0 namespace Step63\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   struct ScratchData\\n\\u00a0   {\\n\\u00a0     ScratchData(const FiniteElement<dim> &fe,\\n\\u00a0                 const unsigned int        quadrature_degree)\\n\\u00a0       : fe_values(fe,\\n\\u00a0                   QGauss<dim>(quadrature_degree),\\n\\u00a0                   update_values | update_gradients | update_hessians |\\n\\u00a0                     update_quadrature_points | update_JxW_values)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     ScratchData(const ScratchData<dim> &scratch_data)\\n\\u00a0       : fe_values(scratch_data.fe_values.get_fe(),\\n\\u00a0                   scratch_data.fe_values.get_quadrature(),\\n\\u00a0                   update_values | update_gradients | update_hessians |\\n\\u00a0                     update_quadrature_points | update_JxW_values)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     FEValues<dim> fe_values;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   struct CopyData\\n\\u00a0   {\\n\\u00a0     CopyData() = default;\\n\\u00a0 \\n\\u00a0     unsigned int level;\\n\\u00a0     unsigned int dofs_per_cell;\\n\\u00a0 \\n\\u00a0     FullMatrix<double>                   cell_matrix;\\n\\u00a0     Vector<double>                       cell_rhs;\\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFEValuesDefinition fe_values.h:63\\nFiniteElementDefinition fe.h:655\\nFullMatrixDefinition full_matrix.h:79\\nQGaussDefinition quadrature_lib.h:40\\nVectorDefinition vector.h:120\\nlevelunsigned int levelDefinition grid_out.cc:4626\\nupdate_hessians@ update_hessiansSecond derivatives of shape functions.Definition fe_update_flags.h:87\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\ndealiiDefinition namespace_dealii.h:25\\n Problem parameters\\nThe second step is to define the classes that deal with run-time parameters to be read from an input file.\\nWe will use ParameterHandler to pass in parameters at runtime. The structure Settings parses and stores the parameters to be queried throughout the program.\\n\\u00a0   struct Settings\\n\\u00a0   {\\n\\u00a0     enum DoFRenumberingStrategy\\n\\u00a0     {\\n\\u00a0       none,\\n\\u00a0       downstream,\\n\\u00a0       upstream,\\n\\u00a0       random\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     void get_parameters(const std::string &prm_filename);\\n\\u00a0 \\n\\u00a0     double                 epsilon;\\n\\u00a0     unsigned int           fe_degree;\\n\\u00a0     std::string            smoother_type;\\n\\u00a0     unsigned int           smoothing_steps;\\n\\u00a0     DoFRenumberingStrategy dof_renumbering;\\n\\u00a0     bool                   with_streamline_diffusion;\\n\\u00a0     bool                   output;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   void Settings::get_parameters(const std::string &prm_filename)\\n\\u00a0   {\\n\\u00a0     /* First declare the parameters... */\\n\\u00a0     ParameterHandler prm;\\n\\u00a0 \\n\\u00a0     prm.declare_entry(\\\"Epsilon\\\",\\n\\u00a0                       \\\"0.005\\\",\\n\\u00a0                       Patterns::Double(0),\\n\\u00a0                       \\\"Diffusion parameter\\\");\\n\\u00a0 \\n\\u00a0     prm.declare_entry(\\\"Fe degree\\\",\\n\\u00a0                       \\\"1\\\",\\n\\u00a0                       Patterns::Integer(1),\\n\\u00a0                       \\\"Finite Element degree\\\");\\n\\u00a0     prm.declare_entry(\\\"Smoother type\\\",\\n\\u00a0                       \\\"block SOR\\\",\\n\\u00a0                       Patterns::Selection(\\\"SOR|Jacobi|block SOR|block Jacobi\\\"),\\n\\u00a0                       \\\"Select smoother: SOR|Jacobi|block SOR|block Jacobi\\\");\\n\\u00a0     prm.declare_entry(\\\"Smoothing steps\\\",\\n\\u00a0                       \\\"2\\\",\\n\\u00a0                       Patterns::Integer(1),\\n\\u00a0                       \\\"Number of smoothing steps\\\");\\n\\u00a0     prm.declare_entry(\\n\\u00a0       \\\"DoF renumbering\\\",\\n\\u00a0       \\\"downstream\\\",\\n\\u00a0       Patterns::Selection(\\\"none|downstream|upstream|random\\\"),\\n\\u00a0       \\\"Select DoF renumbering: none|downstream|upstream|random\\\");\\n\\u00a0     prm.declare_entry(\\\"With streamline diffusion\\\",\\n\\u00a0                       \\\"true\\\",\\n\\u00a0                       Patterns::Bool(),\\n\\u00a0                       \\\"Enable streamline diffusion stabilization: true|false\\\");\\n\\u00a0     prm.declare_entry(\\\"Output\\\",\\n\\u00a0                       \\\"true\\\",\\n\\u00a0                       Patterns::Bool(),\\n\\u00a0                       \\\"Generate graphical output: true|false\\\");\\n\\u00a0 \\n\\u00a0     /* ...and then try to read their values from the input file: */\\n\\u00a0     if (prm_filename.empty())\\n\\u00a0       {\\n\\u00a0         prm.print_parameters(std::cout, ParameterHandler::Text);\\n\\u00a0         AssertThrow(\\n\\u00a0           false, ExcMessage(\\\"Please pass a .prm file as the first argument!\\\"));\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     prm.parse_input(prm_filename);\\n\\u00a0 \\n\\u00a0     epsilon         = prm.get_double(\\\"Epsilon\\\");\\n\\u00a0     fe_degree       = prm.get_integer(\\\"Fe degree\\\");\\n\\u00a0     smoother_type   = prm.get(\\\"Smoother type\\\");\\n\\u00a0     smoothing_steps = prm.get_integer(\\\"Smoothing steps\\\");\\n\\u00a0 \\n\\u00a0     const std::string renumbering = prm.get(\\\"DoF renumbering\\\");\\n\\u00a0     if (renumbering == \\\"none\\\")\\n\\u00a0       dof_renumbering = DoFRenumberingStrategy::none;\\n\\u00a0     else if (renumbering == \\\"downstream\\\")\\n\\u00a0       dof_renumbering = DoFRenumberingStrategy::downstream;\\n\\u00a0     else if (renumbering == \\\"upstream\\\")\\n\\u00a0       dof_renumbering = DoFRenumberingStrategy::upstream;\\n\\u00a0     else if (renumbering == \\\"random\\\")\\n\\u00a0       dof_renumbering = DoFRenumberingStrategy::random;\\n\\u00a0     else\\n\\u00a0       AssertThrow(false,\\n\\u00a0                   ExcMessage(\\\"The <DoF renumbering> parameter has \\\"\\n\\u00a0                              \\\"an invalid value.\\\"));\\n\\u00a0 \\n\\u00a0     with_streamline_diffusion = prm.get_bool(\\\"With streamline diffusion\\\");\\n\\u00a0     output                    = prm.get_bool(\\\"Output\\\");\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nParameterHandlerDefinition parameter_handler.h:855\\nParameterHandler::declare_entryvoid declare_entry(const std::string &entry, const std::string &default_value, const Patterns::PatternBase &pattern=Patterns::Anything(), const std::string &documentation=\\\"\\\", const bool has_to_be_set=false)Definition parameter_handler.cc:846\\nParameterHandler::Text@ TextDefinition parameter_handler.h:903\\nPatterns::BoolDefinition patterns.h:980\\nPatterns::DoubleDefinition patterns.h:291\\nPatterns::IntegerDefinition patterns.h:188\\nPatterns::SelectionDefinition patterns.h:381\\nAssertThrow#define AssertThrow(cond, exc)Definition exceptions.h:1739\\nPhysics::Elasticity::Kinematics::epsilonSymmetricTensor< 2, dim, Number > epsilon(const Tensor< 2, dim, Number > &Grad_u)\\n Cell permutations\\nThe ordering in which cells and degrees of freedom are traversed will play a role in the speed of convergence for multiplicative methods. Here we define functions which return a specific ordering of cells to be used by the block smoothers.\\nFor each type of cell ordering, we define a function for the active mesh and one for a level mesh (i.e., for the cells at one level of a multigrid hierarchy). While the only reordering necessary for solving the system will be on the level meshes, we include the active reordering for visualization purposes in output_results().\\nFor the two downstream ordering functions, we first create an array with all of the relevant cells that we then sort in downstream direction using a \\\"comparator\\\" object. The output of the functions is then simply an array of the indices of the cells in the just computed order.\\n\\u00a0   template <int dim>\\n\\u00a0   std::vector<unsigned int>\\n\\u00a0   create_downstream_cell_ordering(const DoFHandler<dim> &dof_handler,\\n\\u00a0                                   const Tensor<1, dim>   direction,\\n\\u00a0                                   const unsigned int level)\\n\\u00a0   {\\n\\u00a0     std::vector<typename DoFHandler<dim>::level_cell_iterator> ordered_cells;\\n\\u00a0     ordered_cells.reserve(dof_handler.get_triangulation().n_cells(level));\\n\\u00a0     for (const auto &cell : dof_handler.cell_iterators_on_level(level))\\n\\u00a0       ordered_cells.push_back(cell);\\n\\u00a0 \\n\\u00a0     const DoFRenumbering::\\n\\u00a0       CompareDownstream<typename DoFHandler<dim>::level_cell_iterator, dim>\\n\\u00a0         comparator(direction);\\n\\u00a0     std::sort(ordered_cells.begin(), ordered_cells.end(), comparator);\\n\\u00a0 \\n\\u00a0     std::vector<unsigned> ordered_indices;\\n\\u00a0     ordered_indices.reserve(dof_handler.get_triangulation().n_cells(level));\\n\\u00a0 \\n\\u00a0     for (const auto &cell : ordered_cells)\\n\\u00a0       ordered_indices.push_back(cell->index());\\n\\u00a0 \\n\\u00a0     return ordered_indices;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   std::vector<unsigned int>\\n\\u00a0   create_downstream_cell_ordering(const DoFHandler<dim> &dof_handler,\\n\\u00a0                                   const Tensor<1, dim>   direction)\\n\\u00a0   {\\n\\u00a0     std::vector<typename DoFHandler<dim>::active_cell_iterator> ordered_cells;\\n\\u00a0     ordered_cells.reserve(dof_handler.get_triangulation().n_active_cells());\\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       ordered_cells.push_back(cell);\\n\\u00a0 \\n\\u00a0     const DoFRenumbering::\\n\\u00a0       CompareDownstream<typename DoFHandler<dim>::active_cell_iterator, dim>\\n\\u00a0         comparator(direction);\\n\\u00a0     std::sort(ordered_cells.begin(), ordered_cells.end(), comparator);\\n\\u00a0 \\n\\u00a0     std::vector<unsigned int> ordered_indices;\\n\\u00a0     ordered_indices.reserve(dof_handler.get_triangulation().n_active_cells());\\n\\u00a0 \\n\\u00a0     for (const auto &cell : ordered_cells)\\n\\u00a0       ordered_indices.push_back(cell->index());\\n\\u00a0 \\n\\u00a0     return ordered_indices;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nDoFHandlerDefinition dof_handler.h:317\\nDoFHandler::get_triangulationconst Triangulation< dim, spacedim > & get_triangulation() const\\nTensorDefinition tensor.h:471\\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nTriangulation::n_cellsunsigned int n_cells() const\\nThe functions that produce a random ordering are similar in spirit in that they first put information about all cells into an array. But then, instead of sorting them, they shuffle the elements randomly using the facilities C++ offers to generate random numbers. The way this is done is by iterating over all elements of the array, drawing a random number for another element before that, and then exchanging these elements. The result is a random shuffle of the elements of the array.\\n\\u00a0   template <int dim>\\n\\u00a0   std::vector<unsigned int>\\n\\u00a0   create_random_cell_ordering(const DoFHandler<dim> &dof_handler,\\n\\u00a0                               const unsigned int level)\\n\\u00a0   {\\n\\u00a0     std::vector<unsigned int> ordered_cells;\\n\\u00a0     ordered_cells.reserve(dof_handler.get_triangulation().n_cells(level));\\n\\u00a0     for (const auto &cell : dof_handler.cell_iterators_on_level(level))\\n\\u00a0       ordered_cells.push_back(cell->index());\\n\\u00a0 \\n\\u00a0     std::mt19937 random_number_generator;\\n\\u00a0     std::shuffle(ordered_cells.begin(),\\n\\u00a0                  ordered_cells.end(),\\n\\u00a0                  random_number_generator);\\n\\u00a0 \\n\\u00a0     return ordered_cells;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   std::vector<unsigned int>\\n\\u00a0   create_random_cell_ordering(const DoFHandler<dim> &dof_handler)\\n\\u00a0   {\\n\\u00a0     std::vector<unsigned int> ordered_cells;\\n\\u00a0     ordered_cells.reserve(dof_handler.get_triangulation().n_active_cells());\\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       ordered_cells.push_back(cell->index());\\n\\u00a0 \\n\\u00a0     std::mt19937 random_number_generator;\\n\\u00a0     std::shuffle(ordered_cells.begin(),\\n\\u00a0                  ordered_cells.end(),\\n\\u00a0                  random_number_generator);\\n\\u00a0 \\n\\u00a0     return ordered_cells;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n Right-hand side and boundary values\\nThe problem solved in this tutorial is an adaptation of Ex. 3.1.3 found on pg. 118 of Finite Elements and Fast Iterative Solvers: with Applications in Incompressible Fluid Dynamics by Elman, Silvester, and Wathen. The main difference being that we add a hole in the center of our domain with zero Dirichlet boundary conditions.\\nFor a complete description, we need classes that implement the zero right-hand side first (we could of course have just used Functions::ZeroFunction):\\n\\u00a0   template <int dim>\\n\\u00a0   class RightHandSide : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component = 0) const override;\\n\\u00a0 \\n\\u00a0     virtual void value_list(const std::vector<Point<dim>> &points,\\n\\u00a0                             std::vector<double>           &values,\\n\\u00a0                             const unsigned int component = 0) const override;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double RightHandSide<dim>::value(const Point<dim> &,\\n\\u00a0                                    const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     Assert(component == 0, ExcIndexRange(component, 0, 1));\\n\\u00a0     (void)component;\\n\\u00a0 \\n\\u00a0     return 0.0;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void RightHandSide<dim>::value_list(const std::vector<Point<dim>> &points,\\n\\u00a0                                       std::vector<double>           &values,\\n\\u00a0                                       const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     AssertDimension(values.size(), points.size());\\n\\u00a0 \\n\\u00a0     for (unsigned int i = 0; i < points.size(); ++i)\\n\\u00a0       values[i] = RightHandSide<dim>::value(points[i], component);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nFunctionDefinition function.h:152\\nFunction::value_listvirtual void value_list(const std::vector< Point< dim > > &points, std::vector< RangeNumberType > &values, const unsigned int component=0) const\\nFunction::valuevirtual RangeNumberType value(const Point< dim > &p, const unsigned int component=0) const\\nPointDefinition point.h:111\\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\nAssertDimension#define AssertDimension(dim1, dim2)Definition exceptions.h:1985\\nWe also have Dirichlet boundary conditions. On a connected portion of the outer, square boundary we set the value to 1, and we set the value to 0 everywhere else (including the inner, circular boundary):\\n\\u00a0   template <int dim>\\n\\u00a0   class BoundaryValues : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component = 0) const override;\\n\\u00a0 \\n\\u00a0     virtual void value_list(const std::vector<Point<dim>> &points,\\n\\u00a0                             std::vector<double>           &values,\\n\\u00a0                             const unsigned int component = 0) const override;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double BoundaryValues<dim>::value(const Point<dim>  &p,\\n\\u00a0                                     const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     Assert(component == 0, ExcIndexRange(component, 0, 1));\\n\\u00a0     (void)component;\\n\\u00a0 \\nSet boundary to 1 if \\\\(x=1\\\\), or if \\\\(x>0.5\\\\) and \\\\(y=-1\\\\).\\n\\u00a0     if (std::fabs(p[0] - 1) < 1e-8 ||\\n\\u00a0         (std::fabs(p[1] + 1) < 1e-8 && p[0] >= 0.5))\\n\\u00a0       {\\n\\u00a0         return 1.0;\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       {\\n\\u00a0         return 0.0;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void BoundaryValues<dim>::value_list(const std::vector<Point<dim>> &points,\\n\\u00a0                                        std::vector<double>           &values,\\n\\u00a0                                        const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     AssertDimension(values.size(), points.size());\\n\\u00a0 \\n\\u00a0     for (unsigned int i = 0; i < points.size(); ++i)\\n\\u00a0       values[i] = BoundaryValues<dim>::value(points[i], component);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n Streamline diffusion implementation\\nThe streamline diffusion method has a stabilization constant that we need to be able to compute. The choice of how this parameter is computed is taken from On Discontinuity-Capturing Methods for Convection-Diffusion Equations by Volker John and Petr Knobloch.\\n\\u00a0   template <int dim>\\n\\u00a0   double compute_stabilization_delta(const double         hk,\\n\\u00a0                                      const double         eps,\\n\\u00a0                                      const Tensor<1, dim> dir,\\n\\u00a0                                      const double         pk)\\n\\u00a0   {\\n\\u00a0     const double Peclet = dir.norm() * hk / (2.0 * eps * pk);\\n\\u00a0     const double coth =\\n\\u00a0       (1.0 + std::exp(-2.0 * Peclet)) / (1.0 - std::exp(-2.0 * Peclet));\\n\\u00a0 \\n\\u00a0     return hk / (2.0 * dir.norm() * pk) * (coth - 1.0 / Peclet);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nstd::exp::VectorizedArray< Number, width > exp(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6829\\n AdvectionProblem class\\nThis is the main class of the program, and should look very similar to step-16. The major difference is that, since we are defining our multigrid smoother at runtime, we choose to define a function create_smoother() and a class object mg_smoother which is a std::unique_ptr to a smoother that is derived from MGSmoother. Note that for smoothers derived from RelaxationBlock, we must include a smoother_data object for each level. This will contain information about the cell ordering and the method of inverting cell matrices.\\n\\u00a0   template <int dim>\\n\\u00a0   class AdvectionProblem\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     AdvectionProblem(const Settings &settings);\\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void setup_system();\\n\\u00a0 \\n\\u00a0     template <class IteratorType>\\n\\u00a0     void assemble_cell(const IteratorType &cell,\\n\\u00a0                        ScratchData<dim>   &scratch_data,\\n\\u00a0                        CopyData           &copy_data);\\n\\u00a0     void assemble_system_and_multigrid();\\n\\u00a0 \\n\\u00a0     void setup_smoother();\\n\\u00a0 \\n\\u00a0     void solve();\\n\\u00a0     void refine_grid();\\n\\u00a0     void output_results(const unsigned int cycle) const;\\n\\u00a0 \\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0     DoFHandler<dim>    dof_handler;\\n\\u00a0 \\n\\u00a0     const FE_Q<dim>     fe;\\n\\u00a0     const MappingQ<dim> mapping;\\n\\u00a0 \\n\\u00a0     AffineConstraints<double> constraints;\\n\\u00a0 \\n\\u00a0     SparsityPattern      sparsity_pattern;\\n\\u00a0     SparseMatrix<double> system_matrix;\\n\\u00a0 \\n\\u00a0     Vector<double> solution;\\n\\u00a0     Vector<double> system_rhs;\\n\\u00a0 \\n\\u00a0     MGLevelObject<SparsityPattern> mg_sparsity_patterns;\\n\\u00a0     MGLevelObject<SparsityPattern> mg_interface_sparsity_patterns;\\n\\u00a0 \\n\\u00a0     MGLevelObject<SparseMatrix<double>> mg_matrices;\\n\\u00a0     MGLevelObject<SparseMatrix<double>> mg_interface_in;\\n\\u00a0     MGLevelObject<SparseMatrix<double>> mg_interface_out;\\n\\u00a0 \\n\\u00a0     mg::Matrix<Vector<double>> mg_matrix;\\n\\u00a0     mg::Matrix<Vector<double>> mg_interface_matrix_in;\\n\\u00a0     mg::Matrix<Vector<double>> mg_interface_matrix_out;\\n\\u00a0 \\n\\u00a0     std::unique_ptr<MGSmoother<Vector<double>>> mg_smoother;\\n\\u00a0 \\n\\u00a0     using SmootherType =\\n\\u00a0       RelaxationBlock<SparseMatrix<double>, double, Vector<double>>;\\n\\u00a0     using SmootherAdditionalDataType = SmootherType::AdditionalData;\\n\\u00a0     MGLevelObject<SmootherAdditionalDataType> smoother_data;\\n\\u00a0 \\n\\u00a0     MGConstrainedDoFs mg_constrained_dofs;\\n\\u00a0 \\n\\u00a0     Tensor<1, dim> advection_direction;\\n\\u00a0 \\n\\u00a0     const Settings settings;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   AdvectionProblem<dim>::AdvectionProblem(const Settings &settings)\\n\\u00a0     : triangulation(Triangulation<dim>::limit_level_difference_at_vertices)\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0     , fe(settings.fe_degree)\\n\\u00a0     , mapping(settings.fe_degree)\\n\\u00a0     , settings(settings)\\n\\u00a0   {\\n\\u00a0     advection_direction[0] = -std::sin(numbers::PI / 6.0);\\n\\u00a0     if (dim >= 2)\\n\\u00a0       advection_direction[1] = std::cos(numbers::PI / 6.0);\\n\\u00a0     if (dim >= 3)\\n\\u00a0       AssertThrow(false, ExcNotImplemented());\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nFE_QDefinition fe_q.h:554\\nMGConstrainedDoFsDefinition mg_constrained_dofs.h:45\\nMGLevelObjectDefinition mg_level_object.h:49\\nMappingQDefinition mapping_q.h:110\\nRelaxationBlockDefinition relaxation_block.h:56\\nSparseMatrixDefinition sparse_matrix.h:520\\nSparsityPatternDefinition sparsity_pattern.h:343\\nTriangulationDefinition tria.h:1323\\nmg::MatrixDefinition mg_matrix.h:46\\nnumbersDefinition numbers.h:230\\nnumbers::PIstatic constexpr double PIDefinition numbers.h:259\\nstdSTL namespace.\\nstd::cos::VectorizedArray< Number, width > cos(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6609\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\n AdvectionProblem::setup_system()\\nHere we first set up the DoFHandler, AffineConstraints, and SparsityPattern objects for both active and multigrid level meshes.\\nWe could renumber the active DoFs with the DoFRenumbering class, but the smoothers only act on multigrid levels and as such, this would not matter for the computations. Instead, we will renumber the DoFs on each multigrid level below.\\n\\u00a0   template <int dim>\\n\\u00a0   void AdvectionProblem<dim>::setup_system()\\n\\u00a0   {\\n\\u00a0     const unsigned int n_levels = triangulation.n_levels();\\n\\u00a0 \\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0 \\n\\u00a0     solution.reinit(dof_handler.n_dofs());\\n\\u00a0     system_rhs.reinit(dof_handler.n_dofs());\\n\\u00a0 \\n\\u00a0     constraints.clear();\\n\\u00a0     DoFTools::make_hanging_node_constraints(dof_handler, constraints);\\n\\u00a0 \\n\\u00a0     VectorTools::interpolate_boundary_values(\\n\\u00a0       mapping, dof_handler, 0, BoundaryValues<dim>(), constraints);\\n\\u00a0     VectorTools::interpolate_boundary_values(\\n\\u00a0       mapping, dof_handler, 1, BoundaryValues<dim>(), constraints);\\n\\u00a0     constraints.close();\\n\\u00a0 \\n\\u00a0     DynamicSparsityPattern dsp(dof_handler.n_dofs());\\n\\u00a0     DoFTools::make_sparsity_pattern(dof_handler,\\n\\u00a0                                     dsp,\\n\\u00a0                                     constraints,\\n\\u00a0                                     /*keep_constrained_dofs = */ false);\\n\\u00a0 \\n\\u00a0     sparsity_pattern.copy_from(dsp);\\n\\u00a0     system_matrix.reinit(sparsity_pattern);\\n\\u00a0 \\n\\u00a0     dof_handler.distribute_mg_dofs();\\n\\u00a0 \\nDoFHandler::distribute_dofsvoid distribute_dofs(const FiniteElement< dim, spacedim > &fe)\\nDoFHandler::distribute_mg_dofsvoid distribute_mg_dofs()\\nDoFHandler::n_dofstypes::global_dof_index n_dofs() const\\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nTriangulation::n_levelsunsigned int n_levels() const\\nDoFTools::make_hanging_node_constraintsvoid make_hanging_node_constraints(const DoFHandler< dim, spacedim > &dof_handler, AffineConstraints< number > &constraints)Definition dof_tools_constraints.cc:3073\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nVectorTools::interpolate_boundary_valuesvoid interpolate_boundary_values(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const std::map< types::boundary_id, const Function< spacedim, number > * > &function_map, std::map< types::global_dof_index, number > &boundary_values, const ComponentMask &component_mask={})\\nHaving enumerated the global degrees of freedom as well as (in the last line above) the level degrees of freedom, let us renumber the level degrees of freedom to get a better smoother as explained in the introduction. The first block below renumbers DoFs on each level in downstream or upstream direction if needed. This is only necessary for point smoothers (SOR and Jacobi) as the block smoothers operate on cells (see create_smoother()). The blocks below then also implement random numbering.\\n\\u00a0     if (settings.smoother_type == \\\"SOR\\\" || settings.smoother_type == \\\"Jacobi\\\")\\n\\u00a0       {\\n\\u00a0         if (settings.dof_renumbering ==\\n\\u00a0               Settings::DoFRenumberingStrategy::downstream ||\\n\\u00a0             settings.dof_renumbering ==\\n\\u00a0               Settings::DoFRenumberingStrategy::upstream)\\n\\u00a0           {\\n\\u00a0             const Tensor<1, dim> direction =\\n\\u00a0               (settings.dof_renumbering ==\\n\\u00a0                    Settings::DoFRenumberingStrategy::upstream ?\\n\\u00a0                  -1.0 :\\n\\u00a0                  1.0) *\\n\\u00a0               advection_direction;\\n\\u00a0 \\n\\u00a0             for (unsigned int level = 0; level < n_levels; ++level)\\n\\u00a0               DoFRenumbering::downstream(dof_handler,\\n\\u00a0                                          level,\\n\\u00a0                                          direction,\\n\\u00a0                                          /*dof_wise_renumbering = */ true);\\n\\u00a0           }\\n\\u00a0         else if (settings.dof_renumbering ==\\n\\u00a0                  Settings::DoFRenumberingStrategy::random)\\n\\u00a0           {\\n\\u00a0             for (unsigned int level = 0; level < n_levels; ++level)\\n\\u00a0               DoFRenumbering::random(dof_handler, level);\\n\\u00a0           }\\n\\u00a0         else\\n\\u00a0           DEAL_II_NOT_IMPLEMENTED();\\n\\u00a0       }\\n\\u00a0 \\nDEAL_II_NOT_IMPLEMENTED#define DEAL_II_NOT_IMPLEMENTED()Definition exceptions.h:1814\\nDoFRenumbering::downstreamvoid downstream(DoFHandler< dim, spacedim > &dof_handler, const Tensor< 1, spacedim > &direction, const bool dof_wise_renumbering=false)Definition dof_renumbering.cc:1741\\nDoFRenumbering::randomvoid random(DoFHandler< dim, spacedim > &dof_handler)Definition dof_renumbering.cc:2088\\nThe rest of the function just sets up data structures. The last lines of the code below is unlike the other GMG tutorials, as it sets up both the interface in and out matrices. We need this since our problem is non-symmetric.\\n\\u00a0     mg_constrained_dofs.clear();\\n\\u00a0     mg_constrained_dofs.initialize(dof_handler);\\n\\u00a0 \\n\\u00a0     mg_constrained_dofs.make_zero_boundary_constraints(dof_handler, {0, 1});\\n\\u00a0 \\n\\u00a0     mg_matrices.resize(0, n_levels - 1);\\n\\u00a0     mg_matrices.clear_elements();\\n\\u00a0     mg_interface_in.resize(0, n_levels - 1);\\n\\u00a0     mg_interface_in.clear_elements();\\n\\u00a0     mg_interface_out.resize(0, n_levels - 1);\\n\\u00a0     mg_interface_out.clear_elements();\\n\\u00a0     mg_sparsity_patterns.resize(0, n_levels - 1);\\n\\u00a0     mg_interface_sparsity_patterns.resize(0, n_levels - 1);\\n\\u00a0 \\n\\u00a0     for (unsigned int level = 0; level < n_levels; ++level)\\n\\u00a0       {\\n\\u00a0         {\\n\\u00a0           DynamicSparsityPattern dsp(dof_handler.n_dofs(level),\\n\\u00a0                                      dof_handler.n_dofs(level));\\n\\u00a0           MGTools::make_sparsity_pattern(dof_handler, dsp, level);\\n\\u00a0           mg_sparsity_patterns[level].copy_from(dsp);\\n\\u00a0           mg_matrices[level].reinit(mg_sparsity_patterns[level]);\\n\\u00a0         }\\n\\u00a0         {\\n\\u00a0           DynamicSparsityPattern dsp(dof_handler.n_dofs(level),\\n\\u00a0                                      dof_handler.n_dofs(level));\\n\\u00a0           MGTools::make_interface_sparsity_pattern(dof_handler,\\n\\u00a0                                                    mg_constrained_dofs,\\n\\u00a0                                                    dsp,\\n\\u00a0                                                    level);\\n\\u00a0           mg_interface_sparsity_patterns[level].copy_from(dsp);\\n\\u00a0 \\n\\u00a0           mg_interface_in[level].reinit(mg_interface_sparsity_patterns[level]);\\n\\u00a0           mg_interface_out[level].reinit(mg_interface_sparsity_patterns[level]);\\n\\u00a0         }\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nMGTools::make_interface_sparsity_patternvoid make_interface_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, const MGConstrainedDoFs &mg_constrained_dofs, SparsityPatternBase &sparsity, const unsigned int level)Definition mg_tools.cc:1013\\nMGTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity, const unsigned int level, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true)Definition mg_tools.cc:575\\n AdvectionProblem::assemble_cell()\\nHere we define the assembly of the linear system on each cell to be used by the mesh_loop() function below. This one function assembles the cell matrix for either an active or a level cell (whatever it is passed as its first argument), and only assembles a right-hand side if called with an active cell.\\n\\u00a0   template <int dim>\\n\\u00a0   template <class IteratorType>\\n\\u00a0   void AdvectionProblem<dim>::assemble_cell(const IteratorType &cell,\\n\\u00a0                                             ScratchData<dim>   &scratch_data,\\n\\u00a0                                             CopyData           &copy_data)\\n\\u00a0   {\\n\\u00a0     copy_data.level = cell->level();\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell =\\n\\u00a0       scratch_data.fe_values.get_fe().n_dofs_per_cell();\\n\\u00a0     copy_data.dofs_per_cell = dofs_per_cell;\\n\\u00a0     copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);\\n\\u00a0 \\n\\u00a0     const unsigned int n_q_points =\\n\\u00a0       scratch_data.fe_values.get_quadrature().size();\\n\\u00a0 \\n\\u00a0     if (cell->is_level_cell() == false)\\n\\u00a0       copy_data.cell_rhs.reinit(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     copy_data.local_dof_indices.resize(dofs_per_cell);\\n\\u00a0     cell->get_active_or_mg_dof_indices(copy_data.local_dof_indices);\\n\\u00a0 \\n\\u00a0     scratch_data.fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0     RightHandSide<dim>  right_hand_side;\\n\\u00a0     std::vector<double> rhs_values(n_q_points);\\n\\u00a0 \\n\\u00a0     right_hand_side.value_list(scratch_data.fe_values.get_quadrature_points(),\\n\\u00a0                                rhs_values);\\n\\u00a0 \\nIf we are using streamline diffusion we must add its contribution to both the cell matrix and the cell right-hand side. If we are not using streamline diffusion, setting \\\\(\\\\delta=0\\\\) negates this contribution below and we are left with the standard, Galerkin finite element assembly.\\n\\u00a0     const double delta = (settings.with_streamline_diffusion ?\\n\\u00a0                             compute_stabilization_delta(cell->diameter(),\\n\\u00a0                                                         settings.epsilon,\\n\\u00a0                                                         advection_direction,\\n\\u00a0                                                         settings.fe_degree) :\\n\\u00a0                             0.0);\\n\\u00a0 \\n\\u00a0     for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n\\u00a0       for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0         {\\n\\u00a0           for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0             {\\nThe assembly of the local matrix has two parts. First the Galerkin contribution:\\n\\u00a0               copy_data.cell_matrix(i, j) +=\\n\\u00a0                 (settings.epsilon *\\n\\u00a0                  scratch_data.fe_values.shape_grad(i, q_point) *\\n\\u00a0                  scratch_data.fe_values.shape_grad(j, q_point) *\\n\\u00a0                  scratch_data.fe_values.JxW(q_point)) +\\n\\u00a0                 (scratch_data.fe_values.shape_value(i, q_point) *\\n\\u00a0                  (advection_direction *\\n\\u00a0                   scratch_data.fe_values.shape_grad(j, q_point)) *\\n\\u00a0                  scratch_data.fe_values.JxW(q_point))\\nand then the streamline diffusion contribution:\\n\\u00a0                 + delta *\\n\\u00a0                     (advection_direction *\\n\\u00a0                      scratch_data.fe_values.shape_grad(j, q_point)) *\\n\\u00a0                     (advection_direction *\\n\\u00a0                      scratch_data.fe_values.shape_grad(i, q_point)) *\\n\\u00a0                     scratch_data.fe_values.JxW(q_point) -\\n\\u00a0                 delta * settings.epsilon *\\n\\u00a0                   trace(scratch_data.fe_values.shape_hessian(j, q_point)) *\\n\\u00a0                   (advection_direction *\\n\\u00a0                    scratch_data.fe_values.shape_grad(i, q_point)) *\\n\\u00a0                   scratch_data.fe_values.JxW(q_point);\\n\\u00a0             }\\n\\u00a0           if (cell->is_level_cell() == false)\\n\\u00a0             {\\ntraceDEAL_II_HOST constexpr Number trace(const SymmetricTensor< 2, dim2, Number > &)\\nThe same applies to the right hand side. First the Galerkin contribution:\\n\\u00a0               copy_data.cell_rhs(i) +=\\n\\u00a0                 scratch_data.fe_values.shape_value(i, q_point) *\\n\\u00a0                   rhs_values[q_point] * scratch_data.fe_values.JxW(q_point)\\nand then the streamline diffusion contribution:\\n\\u00a0                 + delta * rhs_values[q_point] * advection_direction *\\n\\u00a0                     scratch_data.fe_values.shape_grad(i, q_point) *\\n\\u00a0                     scratch_data.fe_values.JxW(q_point);\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n AdvectionProblem::assemble_system_and_multigrid()\\nHere we employ MeshWorker::mesh_loop() to go over cells and assemble the system_matrix, system_rhs, and all mg_matrices for us.\\n\\u00a0   template <int dim>\\n\\u00a0   void AdvectionProblem<dim>::assemble_system_and_multigrid()\\n\\u00a0   {\\n\\u00a0     const auto cell_worker_active =\\n\\u00a0       [&](const decltype(dof_handler.begin_active()) &cell,\\n\\u00a0           ScratchData<dim>                           &scratch_data,\\n\\u00a0           CopyData                                   &copy_data) {\\n\\u00a0         this->assemble_cell(cell, scratch_data, copy_data);\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0     const auto copier_active = [&](const CopyData &copy_data) {\\n\\u00a0       constraints.distribute_local_to_global(copy_data.cell_matrix,\\n\\u00a0                                              copy_data.cell_rhs,\\n\\u00a0                                              copy_data.local_dof_indices,\\n\\u00a0                                              system_matrix,\\n\\u00a0                                              system_rhs);\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     MeshWorker::mesh_loop(dof_handler.begin_active(),\\n\\u00a0                           dof_handler.end(),\\n\\u00a0                           cell_worker_active,\\n\\u00a0                           copier_active,\\n\\u00a0                           ScratchData<dim>(fe, fe.degree + 1),\\n\\u00a0                           CopyData(),\\n\\u00a0                           MeshWorker::assemble_own_cells);\\n\\u00a0 \\nDoFHandler::endcell_iterator end() const\\nDoFHandler::begin_activeactive_cell_iterator begin_active(const unsigned int level=0) const\\nMeshWorker::mesh_loopvoid mesh_loop(const CellIteratorType &begin, const CellIteratorType &end, const CellWorkerFunctionType &cell_worker, const CopierType &copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const AssembleFlags flags=assemble_own_cells, const BoundaryWorkerFunctionType &boundary_worker=BoundaryWorkerFunctionType(), const FaceWorkerFunctionType &face_worker=FaceWorkerFunctionType(), const unsigned int queue_length=2 *MultithreadInfo::n_threads(), const unsigned int chunk_size=8)Definition mesh_loop.h:281\\nMeshWorker::assemble_own_cells@ assemble_own_cellsDefinition assemble_flags.h:49\\nUnlike the constraints for the active level, we choose to create constraint objects for each multigrid level local to this function since they are never needed elsewhere in the program.\\n\\u00a0     std::vector<AffineConstraints<double>> boundary_constraints(\\n\\u00a0       triangulation.n_global_levels());\\n\\u00a0     for (unsigned int level = 0; level < triangulation.n_global_levels();\\n\\u00a0          ++level)\\n\\u00a0       {\\n\\u00a0         boundary_constraints[level].reinit(\\n\\u00a0           dof_handler.locally_owned_mg_dofs(level),\\n\\u00a0           DoFTools::extract_locally_relevant_level_dofs(dof_handler, level));\\n\\u00a0 \\n\\u00a0         for (const types::global_dof_index dof_index :\\n\\u00a0              mg_constrained_dofs.get_refinement_edge_indices(level))\\n\\u00a0           boundary_constraints[level].constrain_dof_to_zero(dof_index);\\n\\u00a0         for (const types::global_dof_index dof_index :\\n\\u00a0              mg_constrained_dofs.get_boundary_indices(level))\\n\\u00a0           boundary_constraints[level].constrain_dof_to_zero(dof_index);\\n\\u00a0         boundary_constraints[level].close();\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     const auto cell_worker_mg =\\n\\u00a0       [&](const decltype(dof_handler.begin_mg()) &cell,\\n\\u00a0           ScratchData<dim>                       &scratch_data,\\n\\u00a0           CopyData                               &copy_data) {\\n\\u00a0         this->assemble_cell(cell, scratch_data, copy_data);\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0     const auto copier_mg = [&](const CopyData &copy_data) {\\n\\u00a0       boundary_constraints[copy_data.level].distribute_local_to_global(\\n\\u00a0         copy_data.cell_matrix,\\n\\u00a0         copy_data.local_dof_indices,\\n\\u00a0         mg_matrices[copy_data.level]);\\n\\u00a0 \\nDoFHandler::locally_owned_mg_dofsconst IndexSet & locally_owned_mg_dofs(const unsigned int level) const\\nDoFHandler::begin_mglevel_cell_iterator begin_mg(const unsigned int level=0) const\\nparallel::TriangulationBase::n_global_levelsvirtual unsigned int n_global_levels() const overrideDefinition tria_base.cc:141\\nunsigned int\\nDoFTools::extract_locally_relevant_level_dofsIndexSet extract_locally_relevant_level_dofs(const DoFHandler< dim, spacedim > &dof_handler, const unsigned int level)Definition dof_tools.cc:1212\\nIf \\\\((i,j)\\\\) is an interface_out dof pair, then \\\\((j,i)\\\\) is an interface_in dof pair. Note: For interface_in, we load the transpose of the interface entries, i.e., the entry for dof pair \\\\((j,i)\\\\) is stored in interface_in(i,j). This is an optimization for the symmetric case which allows only one matrix to be used when setting the edge_matrices in solve(). Here, however, since our problem is non-symmetric, we must store both interface_in and interface_out matrices.\\n\\u00a0       for (unsigned int i = 0; i < copy_data.dofs_per_cell; ++i)\\n\\u00a0         for (unsigned int j = 0; j < copy_data.dofs_per_cell; ++j)\\n\\u00a0           if (mg_constrained_dofs.is_interface_matrix_entry(\\n\\u00a0                 copy_data.level,\\n\\u00a0                 copy_data.local_dof_indices[i],\\n\\u00a0                 copy_data.local_dof_indices[j]))\\n\\u00a0             {\\n\\u00a0               mg_interface_out[copy_data.level].add(\\n\\u00a0                 copy_data.local_dof_indices[i],\\n\\u00a0                 copy_data.local_dof_indices[j],\\n\\u00a0                 copy_data.cell_matrix(i, j));\\n\\u00a0               mg_interface_in[copy_data.level].add(\\n\\u00a0                 copy_data.local_dof_indices[i],\\n\\u00a0                 copy_data.local_dof_indices[j],\\n\\u00a0                 copy_data.cell_matrix(j, i));\\n\\u00a0             }\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     MeshWorker::mesh_loop(dof_handler.begin_mg(),\\n\\u00a0                           dof_handler.end_mg(),\\n\\u00a0                           cell_worker_mg,\\n\\u00a0                           copier_mg,\\n\\u00a0                           ScratchData<dim>(fe, fe.degree + 1),\\n\\u00a0                           CopyData(),\\n\\u00a0                           MeshWorker::assemble_own_cells);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nDoFHandler::end_mglevel_cell_iterator end_mg(const unsigned int level) const\\n AdvectionProblem::setup_smoother()\\nNext, we set up the smoother based on the settings in the .prm file. The two options that are of significance is the number of pre- and post-smoothing steps on each level of the multigrid v-cycle and the relaxation parameter.\\nSince multiplicative methods tend to be more powerful than additive method, fewer smoothing steps are required to see convergence independent of mesh size. The same holds for block smoothers over point smoothers. This is reflected in the choice for the number of smoothing steps for each type of smoother below.\\nThe relaxation parameter for point smoothers is chosen based on trial and error, and reflects values necessary to keep the iteration counts in the GMRES solve constant (or as close as possible) as we refine the mesh. The two values given for both \\\"Jacobi\\\" and \\\"SOR\\\" in the .prm files are for degree 1 and degree 3 finite elements. If the user wants to change to another degree, they may need to adjust these numbers. For block smoothers, this parameter has a more straightforward interpretation, namely that for additive methods in 2d, a DoF can have a repeated contribution from up to 4 cells, therefore we must relax these methods by 0.25 to compensate. This is not an issue for multiplicative methods as each cell's inverse application carries new information to all its DoFs.\\nFinally, as mentioned above, the point smoothers only operate on DoFs, and the block smoothers on cells, so only the block smoothers need to be given information regarding cell orderings. DoF ordering for point smoothers has already been taken care of in setup_system().\\n\\u00a0   template <int dim>\\n\\u00a0   void AdvectionProblem<dim>::setup_smoother()\\n\\u00a0   {\\n\\u00a0     if (settings.smoother_type == \\\"SOR\\\")\\n\\u00a0       {\\n\\u00a0         using Smoother = PreconditionSOR<SparseMatrix<double>>;\\n\\u00a0 \\n\\u00a0         auto smoother =\\n\\u00a0           std::make_unique<MGSmootherPrecondition<SparseMatrix<double>,\\n\\u00a0                                                   Smoother,\\n\\u00a0                                                   Vector<double>>>();\\n\\u00a0         smoother->initialize(mg_matrices,\\n\\u00a0                              Smoother::AdditionalData(fe.degree == 1 ? 1.0 :\\n\\u00a0                                                                        0.62));\\n\\u00a0         smoother->set_steps(settings.smoothing_steps);\\n\\u00a0         mg_smoother = std::move(smoother);\\n\\u00a0       }\\n\\u00a0     else if (settings.smoother_type == \\\"Jacobi\\\")\\n\\u00a0       {\\n\\u00a0         using Smoother = PreconditionJacobi<SparseMatrix<double>>;\\n\\u00a0         auto smoother =\\n\\u00a0           std::make_unique<MGSmootherPrecondition<SparseMatrix<double>,\\n\\u00a0                                                   Smoother,\\n\\u00a0                                                   Vector<double>>>();\\n\\u00a0         smoother->initialize(mg_matrices,\\n\\u00a0                              Smoother::AdditionalData(fe.degree == 1 ? 0.6667 :\\n\\u00a0                                                                        0.47));\\n\\u00a0         smoother->set_steps(settings.smoothing_steps);\\n\\u00a0         mg_smoother = std::move(smoother);\\n\\u00a0       }\\n\\u00a0     else if (settings.smoother_type == \\\"block SOR\\\" ||\\n\\u00a0              settings.smoother_type == \\\"block Jacobi\\\")\\n\\u00a0       {\\n\\u00a0         smoother_data.resize(0, triangulation.n_levels() - 1);\\n\\u00a0 \\n\\u00a0         for (unsigned int level = 0; level < triangulation.n_levels(); ++level)\\n\\u00a0           {\\n\\u00a0             DoFTools::make_cell_patches(smoother_data[level].block_list,\\n\\u00a0                                         dof_handler,\\n\\u00a0                                         level);\\n\\u00a0 \\n\\u00a0             smoother_data[level].relaxation =\\n\\u00a0               (settings.smoother_type == \\\"block SOR\\\" ? 1.0 : 0.25);\\n\\u00a0             smoother_data[level].inversion = PreconditionBlockBase<double>::svd;\\n\\u00a0 \\n\\u00a0             std::vector<unsigned int> ordered_indices;\\n\\u00a0             switch (settings.dof_renumbering)\\n\\u00a0               {\\n\\u00a0                 case Settings::DoFRenumberingStrategy::downstream:\\n\\u00a0                   ordered_indices =\\n\\u00a0                     create_downstream_cell_ordering(dof_handler,\\n\\u00a0                                                     advection_direction,\\n\\u00a0                                                     level);\\n\\u00a0                   break;\\n\\u00a0 \\n\\u00a0                 case Settings::DoFRenumberingStrategy::upstream:\\n\\u00a0                   ordered_indices =\\n\\u00a0                     create_downstream_cell_ordering(dof_handler,\\n\\u00a0                                                     -1.0 * advection_direction,\\n\\u00a0                                                     level);\\n\\u00a0                   break;\\n\\u00a0 \\n\\u00a0                 case Settings::DoFRenumberingStrategy::random:\\n\\u00a0                   ordered_indices =\\n\\u00a0                     create_random_cell_ordering(dof_handler, level);\\n\\u00a0                   break;\\n\\u00a0 \\n\\u00a0                 case Settings::DoFRenumberingStrategy::none:\\n\\u00a0                   break;\\n\\u00a0 \\n\\u00a0                 default:\\n\\u00a0                   AssertThrow(false, ExcNotImplemented());\\n\\u00a0                   break;\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0             smoother_data[level].order =\\n\\u00a0               std::vector<std::vector<unsigned int>>(1, ordered_indices);\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         if (settings.smoother_type == \\\"block SOR\\\")\\n\\u00a0           {\\n\\u00a0             auto smoother = std::make_unique<MGSmootherPrecondition<\\n\\u00a0               SparseMatrix<double>,\\n\\u00a0               RelaxationBlockSOR<SparseMatrix<double>, double, Vector<double>>,\\n\\u00a0               Vector<double>>>();\\n\\u00a0             smoother->initialize(mg_matrices, smoother_data);\\n\\u00a0             smoother->set_steps(settings.smoothing_steps);\\n\\u00a0             mg_smoother = std::move(smoother);\\n\\u00a0           }\\n\\u00a0         else if (settings.smoother_type == \\\"block Jacobi\\\")\\n\\u00a0           {\\n\\u00a0             auto smoother = std::make_unique<\\n\\u00a0               MGSmootherPrecondition<SparseMatrix<double>,\\n\\u00a0                                      RelaxationBlockJacobi<SparseMatrix<double>,\\n\\u00a0                                                            double,\\n\\u00a0                                                            Vector<double>>,\\n\\u00a0                                      Vector<double>>>();\\n\\u00a0             smoother->initialize(mg_matrices, smoother_data);\\n\\u00a0             smoother->set_steps(settings.smoothing_steps);\\n\\u00a0             mg_smoother = std::move(smoother);\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       AssertThrow(false, ExcNotImplemented());\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nMGSmootherPreconditionDefinition mg_smoother.h:446\\nPreconditionBlockBaseDefinition precondition_block_base.h:59\\nPreconditionJacobiDefinition precondition.h:1656\\nPreconditionSORDefinition precondition.h:1726\\nRelaxationBlockJacobiDefinition relaxation_block.h:288\\nRelaxationBlockSORDefinition relaxation_block.h:384\\nDoFTools::make_cell_patchesvoid make_cell_patches(SparsityPattern &block_list, const DoFHandler< dim, spacedim > &dof_handler, const unsigned int level, const std::vector< bool > &selected_dofs={}, const types::global_dof_index offset=0)Definition dof_tools.cc:2587\\n AdvectionProblem::solve()\\nBefore we can solve the system, we must first set up the multigrid preconditioner. This requires the setup of the transfer between levels, the coarse matrix solver, and the smoother. This setup follows almost identically to step-16, the main difference being the various smoothers defined above and the fact that we need different interface edge matrices for in and out since our problem is non-symmetric. (In reality, for this tutorial these interface matrices are empty since we are only using global refinement, and thus have no refinement edges. However, we have still included both here since if one made the simple switch to an adaptively refined method, the program would still run correctly.)\\nThe last thing to note is that since our problem is non-symmetric, we must use an appropriate Krylov subspace method. We choose here to use GMRES since it offers the guarantee of residual reduction in each iteration. The major disadvantage of GMRES is that, for each iteration, the number of stored temporary vectors increases by one, and one also needs to compute a scalar product with all previously stored vectors. This is rather expensive. This requirement is relaxed by using the restarted GMRES method which puts a cap on the number of vectors we are required to store at any one time (here we restart after 50 temporary vectors, or 48 iterations). This then has the disadvantage that we lose information we have gathered throughout the iteration and therefore we could see slower convergence. As a consequence, where to restart is a question of balancing memory consumption, CPU effort, and convergence speed. However, the goal of this tutorial is to have very low iteration counts by using a powerful GMG preconditioner, so we have picked the restart length such that all of the results shown below converge prior to restart happening, and thus we have a standard GMRES method. If the user is interested, another suitable method offered in deal.II would be BiCGStab.\\n\\u00a0   template <int dim>\\n\\u00a0   void AdvectionProblem<dim>::solve()\\n\\u00a0   {\\n\\u00a0     const unsigned int max_iters       = 200;\\n\\u00a0     const double       solve_tolerance = 1e-8 * system_rhs.l2_norm();\\n\\u00a0     SolverControl      solver_control(max_iters, solve_tolerance, true, true);\\n\\u00a0     solver_control.enable_history_data();\\n\\u00a0 \\n\\u00a0     using Transfer = MGTransferPrebuilt<Vector<double>>;\\n\\u00a0     Transfer mg_transfer(mg_constrained_dofs);\\n\\u00a0     mg_transfer.build(dof_handler);\\n\\u00a0 \\n\\u00a0     FullMatrix<double> coarse_matrix;\\n\\u00a0     coarse_matrix.copy_from(mg_matrices[0]);\\n\\u00a0     MGCoarseGridHouseholder<double, Vector<double>> coarse_grid_solver;\\n\\u00a0     coarse_grid_solver.initialize(coarse_matrix);\\n\\u00a0 \\n\\u00a0     setup_smoother();\\n\\u00a0 \\n\\u00a0     mg_matrix.initialize(mg_matrices);\\n\\u00a0     mg_interface_matrix_in.initialize(mg_interface_in);\\n\\u00a0     mg_interface_matrix_out.initialize(mg_interface_out);\\n\\u00a0 \\n\\u00a0     Multigrid<Vector<double>> mg(\\n\\u00a0       mg_matrix, coarse_grid_solver, mg_transfer, *mg_smoother, *mg_smoother);\\n\\u00a0     mg.set_edge_matrices(mg_interface_matrix_out, mg_interface_matrix_in);\\n\\u00a0 \\n\\u00a0     PreconditionMG<dim, Vector<double>, Transfer> preconditioner(dof_handler,\\n\\u00a0                                                                  mg,\\n\\u00a0                                                                  mg_transfer);\\n\\u00a0 \\n\\u00a0     std::cout << \\\"     Solving with GMRES to tol \\\" << solve_tolerance << \\\"...\\\"\\n\\u00a0               << std::endl;\\n\\u00a0     SolverGMRES<Vector<double>> solver(\\n\\u00a0       solver_control, SolverGMRES<Vector<double>>::AdditionalData(50, true));\\n\\u00a0 \\n\\u00a0     Timer time;\\n\\u00a0     time.start();\\n\\u00a0     solver.solve(system_matrix, solution, system_rhs, preconditioner);\\n\\u00a0     time.stop();\\n\\u00a0 \\n\\u00a0     std::cout << \\\"          converged in \\\" << solver_control.last_step()\\n\\u00a0               << \\\" iterations\\\"\\n\\u00a0               << \\\" in \\\" << time.last_wall_time() << \\\" seconds \\\" << std::endl;\\n\\u00a0 \\n\\u00a0     constraints.distribute(solution);\\n\\u00a0 \\n\\u00a0     mg_smoother.release();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nFullMatrix::copy_fromvoid copy_from(const MatrixType &)\\nMGCoarseGridHouseholderDefinition mg_coarse.h:177\\nMGCoarseGridHouseholder::initializevoid initialize(const FullMatrix< number > &A)\\nMGTransferPrebuiltDefinition mg_transfer.h:628\\nMultigridDefinition multigrid.h:163\\nPreconditionMGDefinition multigrid.h:501\\nSolverControlDefinition solver_control.h:67\\nSolverGMRESDefinition solver_gmres.h:353\\nTimerDefinition timer.h:117\\nTimer::startvoid start()Definition timer.cc:176\\nmgDefinition mg.h:81\\n AdvectionProblem::output_results()\\nThe final function of interest generates graphical output. Here we output the solution and cell ordering in a .vtu format.\\nAt the top of the function, we generate an index for each cell to visualize the ordering used by the smoothers. Note that we do this only for the active cells instead of the levels, where the smoothers are actually used. For the point smoothers we renumber DoFs instead of cells, so this is only an approximation of what happens in reality. Finally, the random ordering is not the random ordering we actually use (see create_smoother() for that).\\nThe (integer) ordering of cells is then copied into a (floating point) vector for graphical output.\\n\\u00a0   template <int dim>\\n\\u00a0   void AdvectionProblem<dim>::output_results(const unsigned int cycle) const\\n\\u00a0   {\\n\\u00a0     const unsigned int n_active_cells = triangulation.n_active_cells();\\n\\u00a0     Vector<double>     cell_indices(n_active_cells);\\n\\u00a0     {\\n\\u00a0       std::vector<unsigned int> ordered_indices;\\n\\u00a0       switch (settings.dof_renumbering)\\n\\u00a0         {\\n\\u00a0           case Settings::DoFRenumberingStrategy::downstream:\\n\\u00a0             ordered_indices =\\n\\u00a0               create_downstream_cell_ordering(dof_handler, advection_direction);\\n\\u00a0             break;\\n\\u00a0 \\n\\u00a0           case Settings::DoFRenumberingStrategy::upstream:\\n\\u00a0             ordered_indices =\\n\\u00a0               create_downstream_cell_ordering(dof_handler,\\n\\u00a0                                               -1.0 * advection_direction);\\n\\u00a0             break;\\n\\u00a0 \\n\\u00a0           case Settings::DoFRenumberingStrategy::random:\\n\\u00a0             ordered_indices = create_random_cell_ordering(dof_handler);\\n\\u00a0             break;\\n\\u00a0 \\n\\u00a0           case Settings::DoFRenumberingStrategy::none:\\n\\u00a0             ordered_indices.resize(n_active_cells);\\n\\u00a0             for (unsigned int i = 0; i < n_active_cells; ++i)\\n\\u00a0               ordered_indices[i] = i;\\n\\u00a0             break;\\n\\u00a0 \\n\\u00a0           default:\\n\\u00a0             AssertThrow(false, ExcNotImplemented());\\n\\u00a0             break;\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0       for (unsigned int i = 0; i < n_active_cells; ++i)\\n\\u00a0         cell_indices(ordered_indices[i]) = static_cast<double>(i);\\n\\u00a0     }\\n\\u00a0 \\nThe remainder of the function is then straightforward, given previous tutorial programs:\\n\\u00a0     DataOut<dim> data_out;\\n\\u00a0     data_out.attach_dof_handler(dof_handler);\\n\\u00a0     data_out.add_data_vector(solution, \\\"solution\\\");\\n\\u00a0     data_out.add_data_vector(cell_indices, \\\"cell_index\\\");\\n\\u00a0     data_out.build_patches();\\n\\u00a0 \\n\\u00a0     const std::string filename =\\n\\u00a0       \\\"solution-\\\" + Utilities::int_to_string(cycle) + \\\".vtu\\\";\\n\\u00a0     std::ofstream output(filename);\\n\\u00a0     data_out.write_vtu(output);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nUtilities::int_to_stringstd::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)Definition utilities.cc:470\\n AdvectionProblem::run()\\nAs in most tutorials, this function creates/refines the mesh and calls the various functions defined above to set up, assemble, solve, and output the results.\\nIn cycle zero, we generate the mesh for the on the square [-1,1]^dim with a hole of radius 3/10 units centered at the origin. For objects with manifold_id equal to one (namely, the faces adjacent to the hole), we assign a spherical manifold.\\n\\u00a0   template <int dim>\\n\\u00a0   void AdvectionProblem<dim>::run()\\n\\u00a0   {\\n\\u00a0     for (unsigned int cycle = 0; cycle < (settings.fe_degree == 1 ? 7u : 5u);\\n\\u00a0          ++cycle)\\n\\u00a0       {\\n\\u00a0         std::cout << \\\"  Cycle \\\" << cycle << ':' << std::endl;\\n\\u00a0 \\n\\u00a0         if (cycle == 0)\\n\\u00a0           {\\n\\u00a0             GridGenerator::hyper_cube_with_cylindrical_hole(triangulation,\\n\\u00a0                                                             0.3,\\n\\u00a0                                                             1.0);\\n\\u00a0 \\n\\u00a0             const SphericalManifold<dim> manifold_description(Point<dim>(0, 0));\\n\\u00a0             triangulation.set_manifold(1, manifold_description);\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         triangulation.refine_global();\\n\\u00a0 \\n\\u00a0         setup_system();\\n\\u00a0 \\n\\u00a0         std::cout << \\\"     Number of active cells:       \\\"\\n\\u00a0                   << triangulation.n_active_cells() << \\\" (\\\"\\n\\u00a0                   << triangulation.n_levels() << \\\" levels)\\\" << std::endl;\\n\\u00a0         std::cout << \\\"     Number of degrees of freedom: \\\"\\n\\u00a0                   << dof_handler.n_dofs() << std::endl;\\n\\u00a0 \\n\\u00a0         assemble_system_and_multigrid();\\n\\u00a0 \\n\\u00a0         solve();\\n\\u00a0 \\n\\u00a0         if (settings.output)\\n\\u00a0           output_results(cycle);\\n\\u00a0 \\n\\u00a0         std::cout << std::endl;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 } // namespace Step63\\n\\u00a0 \\n\\u00a0 \\nSphericalManifoldDefinition manifold_lib.h:263\\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nTriangulation::set_manifoldvoid set_manifold(const types::manifold_id number, const Manifold< dim, spacedim > &manifold_object)\\nGridGenerator::hyper_cube_with_cylindrical_holevoid hyper_cube_with_cylindrical_hole(Triangulation< dim, spacedim > &triangulation, const double inner_radius=.25, const double outer_radius=.5, const double L=.5, const unsigned int repetitions=1, const bool colorize=false)\\n The main function\\nFinally, the main function is like most tutorials. The only interesting bit is that we require the user to pass a .prm file as a sole command line argument. If no parameter file is given, the program will output the contents of a sample parameter file with all default values to the screen that the user can then copy and paste into their own .prm file.\\n\\u00a0 int main(int argc, char *argv[])\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       Step63::Settings settings;\\n\\u00a0       settings.get_parameters((argc > 1) ? (argv[1]) : \\\"\\\");\\n\\u00a0 \\n\\u00a0       Step63::AdvectionProblem<2> advection_problem_2d(settings);\\n\\u00a0       advection_problem_2d.run();\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nGMRES Iteration Numbers \\nThe major advantage for GMG is that it is an \\\\(\\\\mathcal{O}(n)\\\\) method, that is, the complexity of the problem increases linearly with the problem size. To show then that the linear solver presented in this tutorial is in fact \\\\(\\\\mathcal{O}(n)\\\\), all one needs to do is show that the iteration counts for the GMRES solve stay roughly constant as we refine the mesh.\\nEach of the following tables gives the GMRES iteration counts to reduce the initial residual by a factor of \\\\(10^8\\\\). We selected a sufficient number of smoothing steps (based on the method) to get iteration numbers independent of mesh size. As can be seen from the tables below, the method is indeed \\\\(\\\\mathcal{O}(n)\\\\).\\nDoF/Cell Renumbering \\nThe point-wise smoothers (\\\"Jacobi\\\" and \\\"SOR\\\") get applied in the order the DoFs are numbered on each level. We can influence this using the DoFRenumbering namespace. The block smoothers are applied based on the ordering we set in setup_smoother(). We can visualize this numbering. The following pictures show the cell numbering of the active cells in downstream, random, and upstream numbering (left to right):\\n\\nLet us start with the additive smoothers. The following table shows the number of iterations necessary to obtain convergence from GMRES:\\n\\n\\n\\\\(Q_1\\\\) Smoother (smoothing steps)  \\n\\nJacobi (6) Block Jacobi (3)  \\n\\nRenumbering Strategy Renumbering Strategy  \\n\\nCells DoFs Downstream Random Upstream Downstream Random Upstream  \\n\\n32 48 3 3 3 3 3 3  \\n\\n128 160 6 6 6 6 6 6  \\n\\n512 576 11 11 11 9 9 9  \\n\\n2048 2176 15 15 15 13 13 13  \\n\\n8192 8448 18 18 18 15 15 15  \\n\\n32768 33280 20 20 20 16 16 16  \\n\\n131072 132096 20 20 20 16 16 16  \\n\\nWe see that renumbering the DoFs/cells has no effect on convergence speed. This is because these smoothers compute operations on each DoF (point-smoother) or cell (block-smoother) independently and add up the results. Since we can define these smoothers as an application of a sum of matrices, and matrix addition is commutative, the order at which we sum the different components will not affect the end result.\\nOn the other hand, the situation is different for multiplicative smoothers:\\n\\n\\n\\\\(Q_1\\\\) Smoother (smoothing steps)  \\n\\nSOR (3) Block SOR (1)  \\n\\nRenumbering Strategy Renumbering Strategy  \\n\\nCells DoFs Downstream Random Upstream Downstream Random Upstream  \\n\\n32 48 2 2 3 2 2 3  \\n\\n128 160 5 5 7 5 5 7  \\n\\n512 576 7 9 11 7 7 12  \\n\\n2048 2176 10 12 15 8 10 17  \\n\\n8192 8448 11 15 19 10 11 20  \\n\\n32768 33280 12 16 20 10 12 21  \\n\\n131072 132096 12 16 19 11 12 21  \\n\\nHere, we can speed up convergence by renumbering the DoFs/cells in the advection direction, and similarly, we can slow down convergence if we do the renumbering in the opposite direction. This is because advection-dominated problems have a directional flow of information (in the advection direction) which, given the right renumbering of DoFs/cells, multiplicative methods are able to capture.\\nThis feature of multiplicative methods is, however, dependent on the value of \\\\(\\\\varepsilon\\\\). As we increase \\\\(\\\\varepsilon\\\\) and the problem becomes more diffusion-dominated, we have a more uniform propagation of information over the mesh and there is a diminished advantage for renumbering in the advection direction. On the opposite end, in the extreme case of \\\\(\\\\varepsilon=0\\\\) (advection-only), we have a 1st-order PDE and multiplicative methods with the right renumbering become effective solvers: A correct downstream numbering may lead to methods that require only a single iteration because information can be propagated from the inflow boundary downstream, with no information transport in the opposite direction. (Note, however, that in the case of \\\\(\\\\varepsilon=0\\\\), special care must be taken for the boundary conditions in this case).\\nPoint vs. block smoothers \\nWe will limit the results to runs using the downstream renumbering. Here is a cross comparison of all four smoothers for both \\\\(Q_1\\\\) and \\\\(Q_3\\\\) elements:\\n\\n\\n\\\\(Q_1\\\\) Smoother (smoothing steps) \\\\(Q_3\\\\) Smoother (smoothing steps)  \\n\\nCells DoFs Jacobi (6) Block Jacobi (3) SOR (3) Block SOR (1) DoFs Jacobi (6) Block Jacobi (3) SOR (3) Block SOR (1)  \\n\\n32 48 3 3 2 2 336 15 14 15 6  \\n\\n128 160 6 6 5 5 1248 23 18 21 9  \\n\\n512 576 11 9 7 7 4800 29 21 28 9  \\n\\n2048 2176 15 13 10 8 18816 33 22 32 9  \\n\\n8192 8448 18 15 11 10 74496 35 22 34 10  \\n\\n32768 33280 20 16 12 10 \\n\\n131072 132096 20 16 12 11 \\n\\nWe see that for \\\\(Q_1\\\\), both multiplicative smoothers require a smaller combination of smoothing steps and iteration counts than either additive smoother. However, when we increase the degree to a \\\\(Q_3\\\\) element, there is a clear advantage for the block smoothers in terms of the number of smoothing steps and iterations required to solve. Specifically, the block SOR smoother gives constant iteration counts over the degree, and the block Jacobi smoother only sees about a 38% increase in iterations compared to 75% and 183% for Jacobi and SOR respectively.\\nCost \\nIteration counts do not tell the full story in the optimality of a one smoother over another. Obviously we must examine the cost of an iteration. Block smoothers here are at a disadvantage as they are having to construct and invert a cell matrix for each cell. Here is a comparison of solve times for a \\\\(Q_3\\\\) element with 74,496 DoFs:\\n\\n\\n\\\\(Q_3\\\\) Smoother (smoothing steps)  \\n\\nDoFs Jacobi (6) Block Jacobi (3) SOR (3) Block SOR (1)  \\n\\n74496 0.68s 5.82s 1.18s 1.02s  \\n\\nThe smoother that requires the most iterations (Jacobi) actually takes the shortest time (roughly 2/3 the time of the next fastest method). This is because all that is required to apply a Jacobi smoothing step is multiplication by a diagonal matrix which is very cheap. On the other hand, while SOR requires over 3x more iterations (each with 3x more smoothing steps) than block SOR, the times are roughly equivalent, implying that a smoothing step of block SOR is roughly 9x slower than a smoothing step of SOR. Lastly, block Jacobi is almost 6x more expensive than block SOR, which intuitively makes sense from the fact that 1 step of each method has the same cost (inverting the cell matrices and either adding or multiply them together), and block Jacobi has 3 times the number of smoothing steps per iteration with 2 times the iterations.\\nAdditional points \\nThere are a few more important points to mention:\\n\\n\\nFor a mesh distributed in parallel, multiplicative methods cannot be executed over the entire domain. This is because they operate one cell at a time, and downstream cells can only be handled once upstream cells have already been done. This is fine on a single processor: The processor just goes through the list of cells one after the other. However, in parallel, it would imply that some processors are idle because upstream processors have not finished doing the work on cells upstream from the ones owned by the current processor. Once the upstream processors are done, the downstream ones can start, but by that time the upstream processors have no work left. In other words, most of the time during these smoother steps, most processors are in fact idle. This is not how one obtains good parallel scalability!\\nOne can use a hybrid method where a multiplicative smoother is applied on each subdomain, but as you increase the number of subdomains, the method approaches the behavior of an additive method. This is a major disadvantage to these methods. \\n\\n\\n\\nCurrent research into block smoothers suggest that soon we will be able to compute the inverse of the cell matrices much cheaper than what is currently being done inside deal.II. This research is based on the fast diagonalization method (dating back to the 1960s) and has been used in the spectral community for around 20 years (see, e.g., Hybrid Multigrid/Schwarz Algorithms for the Spectral Element Method by Lottes and Fischer). There are currently efforts to generalize these methods to DG and make them more robust. Also, it seems that one should be able to take advantage of matrix-free implementations and the fact that, in the interior of the domain, cell matrices tend to look very similar, allowing fewer matrix inverse computations.  \\n\\nCombining 1. and 2. gives a good reason for expecting that a method like block Jacobi could become very powerful in the future, even though currently for these examples it is quite slow.\\nPossibilities for extensions \\nConstant iterations for Q5 \\nChange the number of smoothing steps and the smoother relaxation parameter (set in Smoother::AdditionalData() inside create_smoother(), only necessary for point smoothers) so that we maintain a constant number of iterations for a \\\\(Q_5\\\\) element.\\nEffectiveness of renumbering for changing epsilon \\nIncrease/decrease the parameter \\\"Epsilon\\\" in the .prm files of the multiplicative methods and observe for which values renumbering no longer influences convergence speed.\\nMesh adaptivity \\nThe code is set up to work correctly with an adaptively refined mesh (the interface matrices are created and set). Devise a suitable refinement criterium or try the KellyErrorEstimator class.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2018 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Authors: Thomas C. Clevenger, Clemson University\\n *          Timo Heister, Clemson University and University of Utah\\n */\\n \\n \\n#include <deal.II/base/tensor_function.h>\\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/function.h>\\n#include <deal.II/base/timer.h>\\n#include <deal.II/base/parameter_handler.h>\\n \\n#include <deal.II/lac/affine_constraints.h>\\n#include <deal.II/lac/vector.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/solver_gmres.h>\\n#include <deal.II/lac/precondition.h>\\n#include <deal.II/lac/relaxation_block.h>\\n \\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_refinement.h>\\n#include <deal.II/grid/manifold_lib.h>\\n#include <deal.II/grid/grid_out.h>\\n \\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_renumbering.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/mapping_q.h>\\n#include <deal.II/fe/fe_values.h>\\n \\n#include <deal.II/numerics/vector_tools.h>\\n#include <deal.II/numerics/data_out.h>\\n \\n#include <deal.II/multigrid/mg_constrained_dofs.h>\\n#include <deal.II/multigrid/multigrid.h>\\n#include <deal.II/multigrid/mg_transfer.h>\\n#include <deal.II/multigrid/mg_tools.h>\\n#include <deal.II/multigrid/mg_coarse.h>\\n#include <deal.II/multigrid/mg_smoother.h>\\n#include <deal.II/multigrid/mg_matrix.h>\\n \\n#include <algorithm>\\n#include <fstream>\\n#include <iostream>\\n#include <random>\\n \\n#include <deal.II/meshworker/mesh_loop.h>\\n \\n \\n \\nnamespace Step63\\n{\\n using namespace dealii;\\n \\n template <int dim>\\n struct ScratchData\\n  {\\n    ScratchData(const FiniteElement<dim> &fe,\\n const unsigned int        quadrature_degree)\\n      : fe_values(fe,\\n QGauss<dim>(quadrature_degree),\\n update_values | update_gradients | update_hessians |\\n update_quadrature_points | update_JxW_values)\\n    {}\\n \\n    ScratchData(const ScratchData<dim> &scratch_data)\\n      : fe_values(scratch_data.fe_values.get_fe(),\\n                  scratch_data.fe_values.get_quadrature(),\\n update_values | update_gradients | update_hessians |\\n update_quadrature_points | update_JxW_values)\\n    {}\\n \\n FEValues<dim> fe_values;\\n  };\\n \\n \\n \\n struct CopyData\\n  {\\n    CopyData() = default;\\n \\n unsigned int level;\\n unsigned int dofs_per_cell;\\n \\n FullMatrix<double> cell_matrix;\\n Vector<double>                       cell_rhs;\\n    std::vector<types::global_dof_index> local_dof_indices;\\n  };\\n \\n \\n \\n \\n struct Settings\\n  {\\n enum DoFRenumberingStrategy\\n    {\\n none,\\n downstream,\\n      upstream,\\n random\\n    };\\n \\n void get_parameters(const std::string &prm_filename);\\n \\n double epsilon;\\n unsigned int           fe_degree;\\n    std::string            smoother_type;\\n unsigned int           smoothing_steps;\\n    DoFRenumberingStrategy dof_renumbering;\\n bool                   with_streamline_diffusion;\\n bool                   output;\\n  };\\n \\n \\n \\n void Settings::get_parameters(const std::string &prm_filename)\\n  {\\n /* First declare the parameters... */\\n ParameterHandler prm;\\n \\n    prm.declare_entry(\\\"Epsilon\\\",\\n \\\"0.005\\\",\\n Patterns::Double(0),\\n \\\"Diffusion parameter\\\");\\n \\n    prm.declare_entry(\\\"Fe degree\\\",\\n \\\"1\\\",\\n Patterns::Integer(1),\\n \\\"Finite Element degree\\\");\\n    prm.declare_entry(\\\"Smoother type\\\",\\n \\\"block SOR\\\",\\n Patterns::Selection(\\\"SOR|Jacobi|block SOR|block Jacobi\\\"),\\n \\\"Select smoother: SOR|Jacobi|block SOR|block Jacobi\\\");\\n    prm.declare_entry(\\\"Smoothing steps\\\",\\n \\\"2\\\",\\n Patterns::Integer(1),\\n \\\"Number of smoothing steps\\\");\\n    prm.declare_entry(\\n \\\"DoF renumbering\\\",\\n \\\"downstream\\\",\\n Patterns::Selection(\\\"none|downstream|upstream|random\\\"),\\n \\\"Select DoF renumbering: none|downstream|upstream|random\\\");\\n    prm.declare_entry(\\\"With streamline diffusion\\\",\\n \\\"true\\\",\\n Patterns::Bool(),\\n \\\"Enable streamline diffusion stabilization: true|false\\\");\\n    prm.declare_entry(\\\"Output\\\",\\n \\\"true\\\",\\n Patterns::Bool(),\\n \\\"Generate graphical output: true|false\\\");\\n \\n /* ...and then try to read their values from the input file: */\\n if (prm_filename.empty())\\n      {\\n        prm.print_parameters(std::cout, ParameterHandler::Text);\\n AssertThrow(\\n false, ExcMessage(\\\"Please pass a .prm file as the first argument!\\\"));\\n      }\\n \\n    prm.parse_input(prm_filename);\\n \\n epsilon         = prm.get_double(\\\"Epsilon\\\");\\n    fe_degree       = prm.get_integer(\\\"Fe degree\\\");\\n    smoother_type   = prm.get(\\\"Smoother type\\\");\\n    smoothing_steps = prm.get_integer(\\\"Smoothing steps\\\");\\n \\n const std::string renumbering = prm.get(\\\"DoF renumbering\\\");\\n if (renumbering == \\\"none\\\")\\n      dof_renumbering = DoFRenumberingStrategy::none;\\n else if (renumbering == \\\"downstream\\\")\\n      dof_renumbering = DoFRenumberingStrategy::downstream;\\n else if (renumbering == \\\"upstream\\\")\\n      dof_renumbering = DoFRenumberingStrategy::upstream;\\n else if (renumbering == \\\"random\\\")\\n      dof_renumbering = DoFRenumberingStrategy::random;\\n else\\n AssertThrow(false,\\n                  ExcMessage(\\\"The <DoF renumbering> parameter has \\\"\\n \\\"an invalid value.\\\"));\\n \\n    with_streamline_diffusion = prm.get_bool(\\\"With streamline diffusion\\\");\\n    output                    = prm.get_bool(\\\"Output\\\");\\n  }\\n \\n \\n template <int dim>\\n  std::vector<unsigned int>\\n  create_downstream_cell_ordering(const DoFHandler<dim> &dof_handler,\\n const Tensor<1, dim>   direction,\\n const unsigned int level)\\n  {\\n    std::vector<typename DoFHandler<dim>::level_cell_iterator> ordered_cells;\\n    ordered_cells.reserve(dof_handler.get_triangulation().n_cells(level));\\n for (const auto &cell : dof_handler.cell_iterators_on_level(level))\\n      ordered_cells.push_back(cell);\\n \\n const DoFRenumbering::\\n      CompareDownstream<typename DoFHandler<dim>::level_cell_iterator, dim>\\n        comparator(direction);\\n    std::sort(ordered_cells.begin(), ordered_cells.end(), comparator);\\n \\n    std::vector<unsigned> ordered_indices;\\n    ordered_indices.reserve(dof_handler.get_triangulation().n_cells(level));\\n \\n for (const auto &cell : ordered_cells)\\n      ordered_indices.push_back(cell->index());\\n \\n return ordered_indices;\\n  }\\n \\n \\n \\n template <int dim>\\n  std::vector<unsigned int>\\n  create_downstream_cell_ordering(const DoFHandler<dim> &dof_handler,\\n const Tensor<1, dim>   direction)\\n  {\\n    std::vector<typename DoFHandler<dim>::active_cell_iterator> ordered_cells;\\n    ordered_cells.reserve(dof_handler.get_triangulation().n_active_cells());\\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      ordered_cells.push_back(cell);\\n \\n const DoFRenumbering::\\n      CompareDownstream<typename DoFHandler<dim>::active_cell_iterator, dim>\\n        comparator(direction);\\n    std::sort(ordered_cells.begin(), ordered_cells.end(), comparator);\\n \\n    std::vector<unsigned int> ordered_indices;\\n    ordered_indices.reserve(dof_handler.get_triangulation().n_active_cells());\\n \\n for (const auto &cell : ordered_cells)\\n      ordered_indices.push_back(cell->index());\\n \\n return ordered_indices;\\n  }\\n \\n \\n template <int dim>\\n  std::vector<unsigned int>\\n  create_random_cell_ordering(const DoFHandler<dim> &dof_handler,\\n const unsigned int level)\\n  {\\n    std::vector<unsigned int> ordered_cells;\\n    ordered_cells.reserve(dof_handler.get_triangulation().n_cells(level));\\n for (const auto &cell : dof_handler.cell_iterators_on_level(level))\\n      ordered_cells.push_back(cell->index());\\n \\n    std::mt19937 random_number_generator;\\n    std::shuffle(ordered_cells.begin(),\\n                 ordered_cells.end(),\\n                 random_number_generator);\\n \\n return ordered_cells;\\n  }\\n \\n \\n \\n template <int dim>\\n  std::vector<unsigned int>\\n  create_random_cell_ordering(const DoFHandler<dim> &dof_handler)\\n  {\\n    std::vector<unsigned int> ordered_cells;\\n    ordered_cells.reserve(dof_handler.get_triangulation().n_active_cells());\\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      ordered_cells.push_back(cell->index());\\n \\n    std::mt19937 random_number_generator;\\n    std::shuffle(ordered_cells.begin(),\\n                 ordered_cells.end(),\\n                 random_number_generator);\\n \\n return ordered_cells;\\n  }\\n \\n \\n \\n template <int dim>\\n class RightHandSide : public Function<dim>\\n  {\\n public:\\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n \\n virtual void value_list(const std::vector<Point<dim>> &points,\\n                            std::vector<double>           &values,\\n const unsigned int component = 0) const override;\\n  };\\n \\n \\n \\n template <int dim>\\n double RightHandSide<dim>::value(const Point<dim> &,\\n const unsigned int component) const\\n {\\n Assert(component == 0, ExcIndexRange(component, 0, 1));\\n    (void)component;\\n \\n return 0.0;\\n  }\\n \\n \\n \\n template <int dim>\\n void RightHandSide<dim>::value_list(const std::vector<Point<dim>> &points,\\n                                      std::vector<double>           &values,\\n const unsigned int component) const\\n {\\n AssertDimension(values.size(), points.size());\\n \\n for (unsigned int i = 0; i < points.size(); ++i)\\n      values[i] = RightHandSide<dim>::value(points[i], component);\\n  }\\n \\n \\n template <int dim>\\n class BoundaryValues : public Function<dim>\\n  {\\n public:\\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n \\n virtual void value_list(const std::vector<Point<dim>> &points,\\n                            std::vector<double>           &values,\\n const unsigned int component = 0) const override;\\n  };\\n \\n \\n \\n template <int dim>\\n double BoundaryValues<dim>::value(const Point<dim>  &p,\\n const unsigned int component) const\\n {\\n Assert(component == 0, ExcIndexRange(component, 0, 1));\\n    (void)component;\\n \\n if (std::fabs(p[0] - 1) < 1e-8 ||\\n        (std::fabs(p[1] + 1) < 1e-8 && p[0] >= 0.5))\\n      {\\n return 1.0;\\n      }\\n else\\n      {\\n return 0.0;\\n      }\\n  }\\n \\n \\n \\n template <int dim>\\n void BoundaryValues<dim>::value_list(const std::vector<Point<dim>> &points,\\n                                       std::vector<double>           &values,\\n const unsigned int component) const\\n {\\n AssertDimension(values.size(), points.size());\\n \\n for (unsigned int i = 0; i < points.size(); ++i)\\n      values[i] = BoundaryValues<dim>::value(points[i], component);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n double compute_stabilization_delta(const double         hk,\\n const double         eps,\\n const Tensor<1, dim> dir,\\n const double         pk)\\n  {\\n const double Peclet = dir.norm() * hk / (2.0 * eps * pk);\\n const double coth =\\n      (1.0 + std::exp(-2.0 * Peclet)) / (1.0 - std::exp(-2.0 * Peclet));\\n \\n return hk / (2.0 * dir.norm() * pk) * (coth - 1.0 / Peclet);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n class AdvectionProblem\\n  {\\n public:\\n    AdvectionProblem(const Settings &settings);\\n void run();\\n \\n private:\\n void setup_system();\\n \\n template <class IteratorType>\\n void assemble_cell(const IteratorType &cell,\\n                       ScratchData<dim>   &scratch_data,\\n                       CopyData           &copy_data);\\n void assemble_system_and_multigrid();\\n \\n void setup_smoother();\\n \\n void solve();\\n void refine_grid();\\n void output_results(const unsigned int cycle) const;\\n \\n Triangulation<dim> triangulation;\\n DoFHandler<dim>    dof_handler;\\n \\n const FE_Q<dim>     fe;\\n const MappingQ<dim> mapping;\\n \\n AffineConstraints<double> constraints;\\n \\n SparsityPattern      sparsity_pattern;\\n SparseMatrix<double> system_matrix;\\n \\n Vector<double> solution;\\n Vector<double> system_rhs;\\n \\n MGLevelObject<SparsityPattern> mg_sparsity_patterns;\\n MGLevelObject<SparsityPattern> mg_interface_sparsity_patterns;\\n \\n MGLevelObject<SparseMatrix<double>> mg_matrices;\\n MGLevelObject<SparseMatrix<double>> mg_interface_in;\\n MGLevelObject<SparseMatrix<double>> mg_interface_out;\\n \\n mg::Matrix<Vector<double>> mg_matrix;\\n mg::Matrix<Vector<double>> mg_interface_matrix_in;\\n mg::Matrix<Vector<double>> mg_interface_matrix_out;\\n \\n    std::unique_ptr<MGSmoother<Vector<double>>> mg_smoother;\\n \\n using SmootherType =\\n RelaxationBlock<SparseMatrix<double>, double, Vector<double>>;\\n using SmootherAdditionalDataType = SmootherType::AdditionalData;\\n MGLevelObject<SmootherAdditionalDataType> smoother_data;\\n \\n MGConstrainedDoFs mg_constrained_dofs;\\n \\n Tensor<1, dim> advection_direction;\\n \\n const Settings settings;\\n  };\\n \\n \\n \\n template <int dim>\\n  AdvectionProblem<dim>::AdvectionProblem(const Settings &settings)\\n    : triangulation(Triangulation<dim>::limit_level_difference_at_vertices)\\n    , dof_handler(triangulation)\\n    , fe(settings.fe_degree)\\n    , mapping(settings.fe_degree)\\n    , settings(settings)\\n  {\\n    advection_direction[0] = -std::sin(numbers::PI / 6.0);\\n if (dim >= 2)\\n      advection_direction[1] = std::cos(numbers::PI / 6.0);\\n if (dim >= 3)\\n AssertThrow(false, ExcNotImplemented());\\n  }\\n \\n \\n \\n template <int dim>\\n void AdvectionProblem<dim>::setup_system()\\n  {\\n const unsigned int n_levels = triangulation.n_levels();\\n \\n    dof_handler.distribute_dofs(fe);\\n \\n    solution.reinit(dof_handler.n_dofs());\\n    system_rhs.reinit(dof_handler.n_dofs());\\n \\n    constraints.clear();\\n DoFTools::make_hanging_node_constraints(dof_handler, constraints);\\n \\n VectorTools::interpolate_boundary_values(\\n      mapping, dof_handler, 0, BoundaryValues<dim>(), constraints);\\n VectorTools::interpolate_boundary_values(\\n      mapping, dof_handler, 1, BoundaryValues<dim>(), constraints);\\n    constraints.close();\\n \\n DynamicSparsityPattern dsp(dof_handler.n_dofs());\\n DoFTools::make_sparsity_pattern(dof_handler,\\n                                    dsp,\\n                                    constraints,\\n /*keep_constrained_dofs = */ false);\\n \\n    sparsity_pattern.copy_from(dsp);\\n    system_matrix.reinit(sparsity_pattern);\\n \\n    dof_handler.distribute_mg_dofs();\\n \\n if (settings.smoother_type == \\\"SOR\\\" || settings.smoother_type == \\\"Jacobi\\\")\\n      {\\n if (settings.dof_renumbering ==\\n              Settings::DoFRenumberingStrategy::downstream ||\\n            settings.dof_renumbering ==\\n              Settings::DoFRenumberingStrategy::upstream)\\n          {\\n const Tensor<1, dim> direction =\\n              (settings.dof_renumbering ==\\n                   Settings::DoFRenumberingStrategy::upstream ?\\n                 -1.0 :\\n                 1.0) *\\n              advection_direction;\\n \\n for (unsigned int level = 0; level < n_levels; ++level)\\n DoFRenumbering::downstream(dof_handler,\\n level,\\n                                         direction,\\n /*dof_wise_renumbering = */ true);\\n          }\\n else if (settings.dof_renumbering ==\\n                 Settings::DoFRenumberingStrategy::random)\\n          {\\n for (unsigned int level = 0; level < n_levels; ++level)\\n DoFRenumbering::random(dof_handler, level);\\n          }\\n else\\n DEAL_II_NOT_IMPLEMENTED();\\n      }\\n \\n    mg_constrained_dofs.clear();\\n    mg_constrained_dofs.initialize(dof_handler);\\n \\n    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler, {0, 1});\\n \\n    mg_matrices.resize(0, n_levels - 1);\\n    mg_matrices.clear_elements();\\n    mg_interface_in.resize(0, n_levels - 1);\\n    mg_interface_in.clear_elements();\\n    mg_interface_out.resize(0, n_levels - 1);\\n    mg_interface_out.clear_elements();\\n    mg_sparsity_patterns.resize(0, n_levels - 1);\\n    mg_interface_sparsity_patterns.resize(0, n_levels - 1);\\n \\n for (unsigned int level = 0; level < n_levels; ++level)\\n      {\\n        {\\n DynamicSparsityPattern dsp(dof_handler.n_dofs(level),\\n                                     dof_handler.n_dofs(level));\\n MGTools::make_sparsity_pattern(dof_handler, dsp, level);\\n          mg_sparsity_patterns[level].copy_from(dsp);\\n          mg_matrices[level].reinit(mg_sparsity_patterns[level]);\\n        }\\n        {\\n DynamicSparsityPattern dsp(dof_handler.n_dofs(level),\\n                                     dof_handler.n_dofs(level));\\n MGTools::make_interface_sparsity_pattern(dof_handler,\\n                                                   mg_constrained_dofs,\\n                                                   dsp,\\n level);\\n          mg_interface_sparsity_patterns[level].copy_from(dsp);\\n \\n          mg_interface_in[level].reinit(mg_interface_sparsity_patterns[level]);\\n          mg_interface_out[level].reinit(mg_interface_sparsity_patterns[level]);\\n        }\\n      }\\n  }\\n \\n \\n \\n \\n template <int dim>\\n template <class IteratorType>\\n void AdvectionProblem<dim>::assemble_cell(const IteratorType &cell,\\n                                            ScratchData<dim>   &scratch_data,\\n                                            CopyData           &copy_data)\\n  {\\n    copy_data.level = cell->level();\\n \\n const unsigned int dofs_per_cell =\\n      scratch_data.fe_values.get_fe().n_dofs_per_cell();\\n    copy_data.dofs_per_cell = dofs_per_cell;\\n    copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);\\n \\n const unsigned int n_q_points =\\n      scratch_data.fe_values.get_quadrature().size();\\n \\n if (cell->is_level_cell() == false)\\n      copy_data.cell_rhs.reinit(dofs_per_cell);\\n \\n    copy_data.local_dof_indices.resize(dofs_per_cell);\\n    cell->get_active_or_mg_dof_indices(copy_data.local_dof_indices);\\n \\n    scratch_data.fe_values.reinit(cell);\\n \\n    RightHandSide<dim>  right_hand_side;\\n    std::vector<double> rhs_values(n_q_points);\\n \\n    right_hand_side.value_list(scratch_data.fe_values.get_quadrature_points(),\\n                               rhs_values);\\n \\n const double delta = (settings.with_streamline_diffusion ?\\n                            compute_stabilization_delta(cell->diameter(),\\n                                                        settings.epsilon,\\n                                                        advection_direction,\\n                                                        settings.fe_degree) :\\n                            0.0);\\n \\n for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n        {\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n            {\\n              copy_data.cell_matrix(i, j) +=\\n                (settings.epsilon *\\n                 scratch_data.fe_values.shape_grad(i, q_point) *\\n                 scratch_data.fe_values.shape_grad(j, q_point) *\\n                 scratch_data.fe_values.JxW(q_point)) +\\n                (scratch_data.fe_values.shape_value(i, q_point) *\\n                 (advection_direction *\\n                  scratch_data.fe_values.shape_grad(j, q_point)) *\\n                 scratch_data.fe_values.JxW(q_point))\\n                + delta *\\n                    (advection_direction *\\n                     scratch_data.fe_values.shape_grad(j, q_point)) *\\n                    (advection_direction *\\n                     scratch_data.fe_values.shape_grad(i, q_point)) *\\n                    scratch_data.fe_values.JxW(q_point) -\\n                delta * settings.epsilon *\\n trace(scratch_data.fe_values.shape_hessian(j, q_point)) *\\n                  (advection_direction *\\n                   scratch_data.fe_values.shape_grad(i, q_point)) *\\n                  scratch_data.fe_values.JxW(q_point);\\n            }\\n if (cell->is_level_cell() == false)\\n            {\\n              copy_data.cell_rhs(i) +=\\n                scratch_data.fe_values.shape_value(i, q_point) *\\n                  rhs_values[q_point] * scratch_data.fe_values.JxW(q_point)\\n                + delta * rhs_values[q_point] * advection_direction *\\n                    scratch_data.fe_values.shape_grad(i, q_point) *\\n                    scratch_data.fe_values.JxW(q_point);\\n            }\\n        }\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void AdvectionProblem<dim>::assemble_system_and_multigrid()\\n  {\\n const auto cell_worker_active =\\n      [&](const decltype(dof_handler.begin_active()) &cell,\\n          ScratchData<dim>                           &scratch_data,\\n          CopyData                                   &copy_data) {\\n        this->assemble_cell(cell, scratch_data, copy_data);\\n      };\\n \\n const auto copier_active = [&](const CopyData &copy_data) {\\n      constraints.distribute_local_to_global(copy_data.cell_matrix,\\n                                             copy_data.cell_rhs,\\n                                             copy_data.local_dof_indices,\\n                                             system_matrix,\\n                                             system_rhs);\\n    };\\n \\n \\n MeshWorker::mesh_loop(dof_handler.begin_active(),\\n                          dof_handler.end(),\\n                          cell_worker_active,\\n                          copier_active,\\n                          ScratchData<dim>(fe, fe.degree + 1),\\n                          CopyData(),\\n MeshWorker::assemble_own_cells);\\n \\n    std::vector<AffineConstraints<double>> boundary_constraints(\\n triangulation.n_global_levels());\\n for (unsigned int level = 0; level < triangulation.n_global_levels();\\n         ++level)\\n      {\\n        boundary_constraints[level].reinit(\\n          dof_handler.locally_owned_mg_dofs(level),\\n DoFTools::extract_locally_relevant_level_dofs(dof_handler, level));\\n \\n for (const types::global_dof_index dof_index :\\n             mg_constrained_dofs.get_refinement_edge_indices(level))\\n          boundary_constraints[level].constrain_dof_to_zero(dof_index);\\n for (const types::global_dof_index dof_index :\\n             mg_constrained_dofs.get_boundary_indices(level))\\n          boundary_constraints[level].constrain_dof_to_zero(dof_index);\\n        boundary_constraints[level].close();\\n      }\\n \\n const auto cell_worker_mg =\\n      [&](const decltype(dof_handler.begin_mg()) &cell,\\n          ScratchData<dim>                       &scratch_data,\\n          CopyData                               &copy_data) {\\n        this->assemble_cell(cell, scratch_data, copy_data);\\n      };\\n \\n const auto copier_mg = [&](const CopyData &copy_data) {\\n      boundary_constraints[copy_data.level].distribute_local_to_global(\\n        copy_data.cell_matrix,\\n        copy_data.local_dof_indices,\\n        mg_matrices[copy_data.level]);\\n \\n for (unsigned int i = 0; i < copy_data.dofs_per_cell; ++i)\\n for (unsigned int j = 0; j < copy_data.dofs_per_cell; ++j)\\n if (mg_constrained_dofs.is_interface_matrix_entry(\\n                copy_data.level,\\n                copy_data.local_dof_indices[i],\\n                copy_data.local_dof_indices[j]))\\n            {\\n              mg_interface_out[copy_data.level].add(\\n                copy_data.local_dof_indices[i],\\n                copy_data.local_dof_indices[j],\\n                copy_data.cell_matrix(i, j));\\n              mg_interface_in[copy_data.level].add(\\n                copy_data.local_dof_indices[i],\\n                copy_data.local_dof_indices[j],\\n                copy_data.cell_matrix(j, i));\\n            }\\n    };\\n \\n MeshWorker::mesh_loop(dof_handler.begin_mg(),\\n                          dof_handler.end_mg(),\\n                          cell_worker_mg,\\n                          copier_mg,\\n                          ScratchData<dim>(fe, fe.degree + 1),\\n                          CopyData(),\\n MeshWorker::assemble_own_cells);\\n  }\\n \\n \\n \\n \\n \\n \\n \\n template <int dim>\\n void AdvectionProblem<dim>::setup_smoother()\\n  {\\n if (settings.smoother_type == \\\"SOR\\\")\\n      {\\n using Smoother = PreconditionSOR<SparseMatrix<double>>;\\n \\n auto smoother =\\n          std::make_unique<MGSmootherPrecondition<SparseMatrix<double>,\\n                                                  Smoother,\\n Vector<double>>>();\\n        smoother->initialize(mg_matrices,\\n                             Smoother::AdditionalData(fe.degree == 1 ? 1.0 :\\n                                                                       0.62));\\n        smoother->set_steps(settings.smoothing_steps);\\n        mg_smoother = std::move(smoother);\\n      }\\n else if (settings.smoother_type == \\\"Jacobi\\\")\\n      {\\n using Smoother = PreconditionJacobi<SparseMatrix<double>>;\\n auto smoother =\\n          std::make_unique<MGSmootherPrecondition<SparseMatrix<double>,\\n                                                  Smoother,\\n Vector<double>>>();\\n        smoother->initialize(mg_matrices,\\n                             Smoother::AdditionalData(fe.degree == 1 ? 0.6667 :\\n                                                                       0.47));\\n        smoother->set_steps(settings.smoothing_steps);\\n        mg_smoother = std::move(smoother);\\n      }\\n else if (settings.smoother_type == \\\"block SOR\\\" ||\\n             settings.smoother_type == \\\"block Jacobi\\\")\\n      {\\n        smoother_data.resize(0, triangulation.n_levels() - 1);\\n \\n for (unsigned int level = 0; level < triangulation.n_levels(); ++level)\\n          {\\n DoFTools::make_cell_patches(smoother_data[level].block_list,\\n                                        dof_handler,\\n level);\\n \\n            smoother_data[level].relaxation =\\n              (settings.smoother_type == \\\"block SOR\\\" ? 1.0 : 0.25);\\n            smoother_data[level].inversion = PreconditionBlockBase<double>::svd;\\n \\n            std::vector<unsigned int> ordered_indices;\\n switch (settings.dof_renumbering)\\n              {\\n case Settings::DoFRenumberingStrategy::downstream:\\n                  ordered_indices =\\n                    create_downstream_cell_ordering(dof_handler,\\n                                                    advection_direction,\\n level);\\n break;\\n \\n case Settings::DoFRenumberingStrategy::upstream:\\n                  ordered_indices =\\n                    create_downstream_cell_ordering(dof_handler,\\n                                                    -1.0 * advection_direction,\\n level);\\n break;\\n \\n case Settings::DoFRenumberingStrategy::random:\\n                  ordered_indices =\\n                    create_random_cell_ordering(dof_handler, level);\\n break;\\n \\n case Settings::DoFRenumberingStrategy::none:\\n break;\\n \\n default:\\n AssertThrow(false, ExcNotImplemented());\\n break;\\n              }\\n \\n            smoother_data[level].order =\\n              std::vector<std::vector<unsigned int>>(1, ordered_indices);\\n          }\\n \\n if (settings.smoother_type == \\\"block SOR\\\")\\n          {\\n auto smoother = std::make_unique<MGSmootherPrecondition<\\n SparseMatrix<double>,\\n RelaxationBlockSOR<SparseMatrix<double>, double, Vector<double>>,\\n Vector<double>>>();\\n            smoother->initialize(mg_matrices, smoother_data);\\n            smoother->set_steps(settings.smoothing_steps);\\n            mg_smoother = std::move(smoother);\\n          }\\n else if (settings.smoother_type == \\\"block Jacobi\\\")\\n          {\\n auto smoother = std::make_unique<\\n MGSmootherPrecondition<SparseMatrix<double>,\\n RelaxationBlockJacobi<SparseMatrix<double>,\\n                                                           double,\\n Vector<double>>,\\n Vector<double>>>();\\n            smoother->initialize(mg_matrices, smoother_data);\\n            smoother->set_steps(settings.smoothing_steps);\\n            mg_smoother = std::move(smoother);\\n          }\\n      }\\n else\\n AssertThrow(false, ExcNotImplemented());\\n  }\\n \\n \\n \\n \\n \\n template <int dim>\\n void AdvectionProblem<dim>::solve()\\n  {\\n const unsigned int max_iters       = 200;\\n const double       solve_tolerance = 1e-8 * system_rhs.l2_norm();\\n SolverControl      solver_control(max_iters, solve_tolerance, true, true);\\n    solver_control.enable_history_data();\\n \\n using Transfer = MGTransferPrebuilt<Vector<double>>;\\n    Transfer mg_transfer(mg_constrained_dofs);\\n    mg_transfer.build(dof_handler);\\n \\n FullMatrix<double> coarse_matrix;\\n    coarse_matrix.copy_from(mg_matrices[0]);\\n MGCoarseGridHouseholder<double, Vector<double>> coarse_grid_solver;\\n    coarse_grid_solver.initialize(coarse_matrix);\\n \\n    setup_smoother();\\n \\n    mg_matrix.initialize(mg_matrices);\\n    mg_interface_matrix_in.initialize(mg_interface_in);\\n    mg_interface_matrix_out.initialize(mg_interface_out);\\n \\n Multigrid<Vector<double>> mg(\\n      mg_matrix, coarse_grid_solver, mg_transfer, *mg_smoother, *mg_smoother);\\n mg.set_edge_matrices(mg_interface_matrix_out, mg_interface_matrix_in);\\n \\n PreconditionMG<dim, Vector<double>, Transfer> preconditioner(dof_handler,\\n mg,\\n                                                                 mg_transfer);\\n \\n    std::cout << \\\"     Solving with GMRES to tol \\\" << solve_tolerance << \\\"...\\\"\\n              << std::endl;\\n SolverGMRES<Vector<double>> solver(\\n      solver_control, SolverGMRES<Vector<double>>::AdditionalData(50, true));\\n \\n Timer time;\\n    time.start();\\n    solver.solve(system_matrix, solution, system_rhs, preconditioner);\\n    time.stop();\\n \\n    std::cout << \\\"          converged in \\\" << solver_control.last_step()\\n              << \\\" iterations\\\"\\n              << \\\" in \\\" << time.last_wall_time() << \\\" seconds \\\" << std::endl;\\n \\n    constraints.distribute(solution);\\n \\n    mg_smoother.release();\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void AdvectionProblem<dim>::output_results(const unsigned int cycle) const\\n {\\n const unsigned int n_active_cells = triangulation.n_active_cells();\\n Vector<double>     cell_indices(n_active_cells);\\n    {\\n      std::vector<unsigned int> ordered_indices;\\n switch (settings.dof_renumbering)\\n        {\\n case Settings::DoFRenumberingStrategy::downstream:\\n            ordered_indices =\\n              create_downstream_cell_ordering(dof_handler, advection_direction);\\n break;\\n \\n case Settings::DoFRenumberingStrategy::upstream:\\n            ordered_indices =\\n              create_downstream_cell_ordering(dof_handler,\\n                                              -1.0 * advection_direction);\\n break;\\n \\n case Settings::DoFRenumberingStrategy::random:\\n            ordered_indices = create_random_cell_ordering(dof_handler);\\n break;\\n \\n case Settings::DoFRenumberingStrategy::none:\\n            ordered_indices.resize(n_active_cells);\\n for (unsigned int i = 0; i < n_active_cells; ++i)\\n              ordered_indices[i] = i;\\n break;\\n \\n default:\\n AssertThrow(false, ExcNotImplemented());\\n break;\\n        }\\n \\n for (unsigned int i = 0; i < n_active_cells; ++i)\\n        cell_indices(ordered_indices[i]) = static_cast<double>(i);\\n    }\\n \\n DataOut<dim> data_out;\\n    data_out.attach_dof_handler(dof_handler);\\n    data_out.add_data_vector(solution, \\\"solution\\\");\\n    data_out.add_data_vector(cell_indices, \\\"cell_index\\\");\\n    data_out.build_patches();\\n \\n const std::string filename =\\n \\\"solution-\\\" + Utilities::int_to_string(cycle) + \\\".vtu\\\";\\n    std::ofstream output(filename);\\n    data_out.write_vtu(output);\\n  }\\n \\n \\n \\n \\n \\n template <int dim>\\n void AdvectionProblem<dim>::run()\\n  {\\n for (unsigned int cycle = 0; cycle < (settings.fe_degree == 1 ? 7u : 5u);\\n         ++cycle)\\n      {\\n        std::cout << \\\"  Cycle \\\" << cycle << ':' << std::endl;\\n \\n if (cycle == 0)\\n          {\\n GridGenerator::hyper_cube_with_cylindrical_hole(triangulation,\\n                                                            0.3,\\n                                                            1.0);\\n \\n const SphericalManifold<dim> manifold_description(Point<dim>(0, 0));\\n triangulation.set_manifold(1, manifold_description);\\n          }\\n \\n triangulation.refine_global();\\n \\n        setup_system();\\n \\n        std::cout << \\\"     Number of active cells:       \\\"\\n                  << triangulation.n_active_cells() << \\\" (\\\"\\n                  << triangulation.n_levels() << \\\" levels)\\\" << std::endl;\\n        std::cout << \\\"     Number of degrees of freedom: \\\"\\n                  << dof_handler.n_dofs() << std::endl;\\n \\n        assemble_system_and_multigrid();\\n \\n        solve();\\n \\n if (settings.output)\\n          output_results(cycle);\\n \\n        std::cout << std::endl;\\n      }\\n  }\\n} // namespace Step63\\n \\n \\n \\n \\nint main(int argc, char *argv[])\\n{\\n try\\n    {\\n      Step63::Settings settings;\\n      settings.get_parameters((argc > 1) ? (argv[1]) : \\\"\\\");\\n \\n      Step63::AdvectionProblem<2> advection_problem_2d(settings);\\n      advection_problem_2d.run();\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n \\n return 0;\\n}\\naffine_constraints.h\\nDataOutInterface::write_vtuvoid write_vtu(std::ostream &out) constDefinition data_out_base.cc:7692\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nParameterHandler::parse_inputvirtual void parse_input(std::istream &input, const std::string &filename=\\\"input file\\\", const std::string &last_line=\\\"\\\", const bool skip_undefined=false)Definition parameter_handler.cc:433\\nParameterHandler::print_parametersstd::ostream & print_parameters(std::ostream &out, const OutputStyle style) constDefinition parameter_handler.cc:1312\\nParameterHandler::get_integerlong int get_integer(const std::string &entry_string) constDefinition parameter_handler.cc:1087\\nParameterHandler::get_boolbool get_bool(const std::string &entry_name) constDefinition parameter_handler.cc:1175\\nParameterHandler::getstd::string get(const std::string &entry_string) constDefinition parameter_handler.cc:1049\\nParameterHandler::get_doubledouble get_double(const std::string &entry_name) constDefinition parameter_handler.cc:1130\\nTensor::normnumbers::NumberTraits< Number >::real_type norm() const\\nTimer::stopdouble stop()Definition timer.cc:193\\nTimer::last_wall_timedouble last_wall_time() constDefinition timer.cc:278\\ndof_handler.h\\ndof_renumbering.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nfe_values.h\\nfe_q.h\\nfull_matrix.h\\nfunction.h\\ngrid_refinement.h\\nmanifold_lib.h\\ntria.h\\ngrid_generator.h\\ngrid_out.h\\nmapping_q.h\\nmesh_loop.h\\nmg_coarse.h\\nmg_constrained_dofs.h\\nmg_matrix.h\\nmg_smoother.h\\nmg_tools.h\\nmg_transfer.h\\nmultigrid.h\\nDataOutBase::none@ noneDefinition data_out_base.h:1622\\nDataOutBase::eps@ epsDefinition data_out_base.h:1647\\nDifferentiation::SD::cothExpression coth(const Expression &x)Definition symengine_math.cc:213\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\nPhysics::Elasticity::Kinematics::eSymmetricTensor< 2, dim, Number > e(const Tensor< 2, dim, Number > &F)\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\ninternal::TriangulationImplementation::n_active_cellsunsigned int n_active_cells(const internal::TriangulationImplementation::NumberCache< 1 > &c)Definition tria.cc:14890\\ninternal::VectorizationTypes::index@ index\\ninternal::EvaluatorQuantity::value@ value\\nstd::sin::VectorizedArray< Number, width > sin(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6589\\ndata_out.h\\nparameter_handler.h\\nprecondition.h\\nquadrature_lib.h\\nrelaxation_block.h\\nsolver_gmres.h\\nsparse_matrix.h\\ntensor_function.h\\ntimer.h\\nvector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"