"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_33.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-33 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-33 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-33 tutorial program\\n\\n\\nThis tutorial depends on step-12, step-71.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nEuler flow\\nDiscretization\\n Automatic differentiation \\n Trilinos solvers \\n Adaptivity \\nInput deck, initial and boundary conditions\\nImplementation\\n\\n The commented program\\n\\nInclude files\\nEuler equation specifics\\n\\nComponent description\\nTransformations between variables\\nEulerEquations::compute_flux_matrix\\nEulerEquations::compute_normal_flux\\nEulerEquations::compute_forcing_vector\\nDealing with boundary conditions\\nEulerEquations::compute_refinement_indicators\\nEulerEquations::Postprocessor\\n\\nRun time parameter handling\\n\\nParameters::Solver\\nParameters::Refinement\\nParameters::Flux\\nParameters::Output\\nParameters::AllParameters\\n\\nConservation law class\\n\\nConservationLaw::ConservationLaw\\nConservationLaw::setup_system\\nConservationLaw::assemble_system\\nConservationLaw::assemble_cell_term\\nConservationLaw::assemble_face_term\\nConservationLaw::solve\\nConservationLaw::compute_refinement_indicators\\nConservationLaw::refine_grid\\nConservationLaw::output_results\\nConservationLaw::run\\n\\nmain()\\n\\n\\n Results\\n\\nPossibilities for extensions\\n\\nStabilization\\nBetter linear solvers\\nCache the explicit part of residual\\nOther conservation laws\\n\\n\\n The plain program\\n   \\n\\n\\n This program was written for fun by David Neckels (NCAR) while working at Sandia (on the Wyoming Express bus to and from Corrales each day). The main purpose was to better understand Euler flow. The code solves the basic Euler equations of gas dynamics, by using a fully implicit Newton iteration (inspired by Sandia's Aria code). The code may be configured by an input file to run different simulations on different meshes, with differing boundary conditions. \\n The original code and documentation was later slightly modified by Wolfgang Bangerth to make it more modular and allow replacing the parts that are specific to the Euler equations by other hyperbolic conservation laws without too much trouble. \\nNoteThe program uses the Trilinos linear solvers (these can be found in Trilinos in the Aztec/Amesos packages) and an automatic differentiation package, Sacado, also part of Trilinos. deal.II must be configured to use Trilinos. Refer to the ReadMe file for instructions how to do this.\\n\\nWhile this program demonstrates the use of automatic differentiation well, it does not express the state of the art in Euler equation solvers. There are much faster and more accurate method for this equation, and you should take a look at step-67 and step-69 to see how this equation can be solved more efficiently.\\n Introduction\\nEuler flow\\nThe equations that describe the movement of a compressible, inviscid gas (the so-called Euler equations of gas dynamics) are a basic system of conservation laws. In spatial dimension \\\\(d\\\\) they read    \\n\\\\[\\n\\\\partial_t \\\\mathbf{w} + \\\\nabla \\\\cdot \\\\mathbf{F}(\\\\mathbf{w}) =\\n\\\\mathbf{G}(\\\\mathbf w),\\n\\\\]\\n\\n with the solution  \\\\(\\\\mathbf{w}=(\\\\rho v_1,\\\\ldots,\\\\rho v_d,\\\\rho,\\nE)^{\\\\top}\\\\) consisting of \\\\(\\\\rho\\\\) the fluid density, \\\\({\\\\mathbf v}=(v_1,\\\\ldots v_d)^T\\\\) the flow velocity (and thus \\\\(\\\\rho\\\\mathbf v\\\\) being the linear momentum density), and \\\\(E\\\\) the energy density of the gas. We interpret the equations above as  \\\\(\\\\partial_t \\\\mathbf{w}_i + \\\\nabla \\\\cdot \\\\mathbf{F}_i(\\\\mathbf{w}) = \\\\mathbf\\nG_i(\\\\mathbf w)\\\\), \\\\(i=1,\\\\ldots,dim+2\\\\).\\nFor the Euler equations, the flux matrix \\\\(\\\\mathbf F\\\\) (or system of flux functions) is defined as (shown here for the case \\\\(d=3\\\\))             \\n\\\\begin{eqnarray*}\\n  \\\\mathbf F(\\\\mathbf w)\\n  =\\n  \\\\left(\\n  \\\\begin{array}{ccc}\\n    \\\\rho v_1^2+p & \\\\rho v_2v_1  & \\\\rho v_3v_1 \\\\\\\\\\n    \\\\rho v_1v_2  & \\\\rho v_2^2+p & \\\\rho v_3v_2 \\\\\\\\\\n    \\\\rho v_1v_3  & \\\\rho v_2v_3  & \\\\rho v_3^2+p \\\\\\\\\\n    \\\\rho v_1 & \\\\rho v_2 & \\\\rho v_3 \\\\\\\\\\n    (E+p) v_1 & (E+p) v_2 & (E+p) v_3\\n  \\\\end{array}\\n  \\\\right),\\n\\\\end{eqnarray*}\\n\\n and we will choose as particular right hand side forcing only the effects of gravity, described by             \\n\\\\begin{eqnarray*}\\n  \\\\mathbf G(\\\\mathbf w)\\n  =\\n  \\\\left(\\n  \\\\begin{array}{c}\\n    g_1\\\\rho \\\\\\\\\\n    g_2\\\\rho \\\\\\\\\\n    g_3\\\\rho \\\\\\\\\\n    0 \\\\\\\\\\n    \\\\rho \\\\mathbf g \\\\cdot \\\\mathbf v\\n  \\\\end{array}\\n  \\\\right),\\n\\\\end{eqnarray*}\\n\\n where \\\\(\\\\mathbf g=(g_1,g_2,g_3)^T\\\\) denotes the gravity vector. With this, the entire system of equations reads:       \\n\\\\begin{eqnarray*}\\n  \\\\partial_t (\\\\rho v_i) + \\\\sum_{s=1}^d \\\\frac{\\\\partial(\\\\rho v_i v_s +\\n  \\\\delta_{is} p)}{\\\\partial x_s} &=& g_i \\\\rho, \\\\qquad i=1,\\\\dots,d, \\\\\\\\\\n  \\\\partial_t \\\\rho + \\\\sum_{s=1}^d \\\\frac{\\\\partial(\\\\rho v_s)}{\\\\partial x_s} &=& 0,  \\\\\\\\\\n  \\\\partial_t E + \\\\sum_{s=1}^d \\\\frac{\\\\partial((E+p)v_s)}{\\\\partial x_s} &=&\\n  \\\\rho \\\\mathbf g \\\\cdot \\\\mathbf v.\\n\\\\end{eqnarray*}\\n\\n These equations describe, respectively, the conservation of momentum, mass, and energy. The system is closed by a relation that defines the pressure:  \\\\(p =\\n(\\\\gamma -1)(E-\\\\frac{1}{2} \\\\rho |\\\\mathbf v|^2)\\\\). For the constituents of air (mainly nitrogen and oxygen) and other diatomic gases, the ratio of specific heats is \\\\(\\\\gamma=1.4\\\\).\\nThis problem obviously falls into the class of vector-valued problems. A general overview of how to deal with these problems in deal.II can be found in the Handling vector valued problems topic.\\nDiscretization\\nDiscretization happens in the usual way, taking into account that this is a hyperbolic problem in the same style as the simple one discussed in step-12: We choose a finite element space \\\\(V_h\\\\), and integrate our conservation law against our (vector-valued) test function \\\\(\\\\mathbf{z} \\\\in V_h\\\\). We then integrate by parts and approximate the boundary flux with a  numerical  flux \\\\(\\\\mathbf{H}\\\\),    \\n\\\\begin{eqnarray*}\\n&&\\\\int_{\\\\Omega} (\\\\partial_t \\\\mathbf{w}, \\\\mathbf{z}) + (\\\\nabla \\\\cdot \\\\mathbf{F}(\\\\mathbf{w}), \\\\mathbf{z}) \\\\\\\\\\n&\\\\approx &\\\\int_{\\\\Omega} (\\\\partial_t \\\\mathbf{w}, \\\\mathbf{z}) - (\\\\mathbf{F}(\\\\mathbf{w}), \\\\nabla \\\\mathbf{z}) + h^{\\\\eta}(\\\\nabla \\\\mathbf{w} , \\\\nabla \\\\mathbf{z}) + \\\\int_{\\\\partial \\\\Omega} (\\\\mathbf{H}(\\\\mathbf{w}^+, \\\\mathbf{w}^-, \\\\mathbf{n}), \\\\mathbf{z}^+),\\n\\\\end{eqnarray*}\\n\\n where a superscript \\\\(+\\\\) denotes the interior trace of a function, and \\\\(-\\\\) represents the outer trace. The diffusion term \\\\(h^{\\\\eta}(\\\\nabla \\\\mathbf{w} , \\\\nabla \\\\mathbf{z})\\\\) is introduced strictly for stability, where \\\\(h\\\\) is the mesh size and \\\\(\\\\eta\\\\) is a parameter prescribing how much diffusion to add.\\nOn the boundary, we have to say what the outer trace \\\\(\\\\mathbf{w}^-\\\\) is. Depending on the boundary condition, we prescribe either of the following: \\n\\nInflow boundary: \\\\(\\\\mathbf{w}^-\\\\) is prescribed to be the desired value. \\n\\nSupersonic outflow boundary: \\\\(\\\\mathbf{w}^- = \\\\mathbf{w}^+\\\\) \\n\\nSubsonic outflow boundary: \\\\(\\\\mathbf{w}^- = \\\\mathbf{w}^+\\\\) except that the energy variable is modified to support a prescribed pressure \\\\(p_o\\\\), i.e. \\\\(\\\\mathbf{w}^- =(\\\\rho^+, \\\\rho v_1^+, \\\\dots, \\\\rho v_d^+, p_o/(\\\\gamma -1) + 0.5 \\\\rho |\\\\mathbf{v}^+|^2)\\\\) \\n\\nReflective boundary: we set \\\\(\\\\mathbf{w}^-\\\\) so that \\\\((\\\\mathbf{v}^+ + \\\\mathbf{v}^-) \\\\cdot \\\\mathbf{n} = 0\\\\) and \\\\(\\\\rho^- = \\\\rho^+,E^-=E^+\\\\). \\n\\nMore information on these issues can be found, for example, in Ralf Hartmann's PhD thesis (\\\"Adaptive Finite Element Methods for the\\nCompressible Euler Equations\\\", PhD thesis, University of Heidelberg, 2002).\\nWe use a time stepping scheme to substitute the time derivative in the above equations. For simplicity, we define \\\\( \\\\mathbf{B}({\\\\mathbf{w}_{n}})(\\\\mathbf z) \\\\) as the spatial residual at time step \\\\(n\\\\) :\\n\\n\\\\begin{eqnarray*}\\n \\\\mathbf{B}(\\\\mathbf{w}_{n})(\\\\mathbf z)  &=&\\n- \\\\int_{\\\\Omega} \\\\left(\\\\mathbf{F}(\\\\mathbf{w}_n),\\n\\\\nabla\\\\mathbf{z}\\\\right) +  h^{\\\\eta}(\\\\nabla \\\\mathbf{w}_n , \\\\nabla \\\\mathbf{z}) \\\\\\\\\\n&& +\\n\\\\int_{\\\\partial \\\\Omega} \\\\left(\\\\mathbf{H}(\\\\mathbf{w}_n^+,\\n\\\\mathbf{w}^-(\\\\mathbf{w}_n^+), \\\\mathbf{n}), \\\\mathbf{z}\\\\right)\\n-\\n\\\\int_{\\\\Omega} \\\\left(\\\\mathbf{G}(\\\\mathbf{w}_n),\\n\\\\mathbf{z}\\\\right) .\\n\\\\end{eqnarray*}\\n\\nAt each time step, our full discretization is thus that the residual applied to any test function \\\\(\\\\mathbf z\\\\) equals zero:       \\n\\\\begin{eqnarray*}\\nR(\\\\mathbf{W}_{n+1})(\\\\mathbf z) &=&\\n\\\\int_{\\\\Omega} \\\\left(\\\\frac{{\\\\mathbf w}_{n+1} - \\\\mathbf{w}_n}{\\\\delta t},\\n\\\\mathbf{z}\\\\right)+\\n\\\\theta \\\\mathbf{B}({\\\\mathbf{w}}_{n+1}) +  (1-\\\\theta) \\\\mathbf{B}({\\\\mathbf w}_{n}) \\\\\\\\\\n&=& 0\\n\\\\end{eqnarray*}\\n\\n where \\\\( \\\\theta \\\\in [0,1] \\\\) and \\\\(\\\\mathbf{w}_i = \\\\sum_k \\\\mathbf{W}_i^k \\\\mathbf{\\\\phi}_k\\\\). Choosing \\\\(\\\\theta=0\\\\) results in the explicit (forward) Euler scheme, \\\\(\\\\theta=1\\\\) in the stable implicit (backward) Euler scheme, and \\\\(\\\\theta=\\\\frac 12\\\\) in the Crank-Nicolson scheme.\\nIn the implementation below, we choose the Lax-Friedrichs flux for the function \\\\(\\\\mathbf H\\\\), i.e.   \\\\(\\\\mathbf{H}(\\\\mathbf{a},\\\\mathbf{b},\\\\mathbf{n}) =\\n\\\\frac{1}{2}(\\\\mathbf{F}(\\\\mathbf{a})\\\\cdot \\\\mathbf{n} +\\n\\\\mathbf{F}(\\\\mathbf{b})\\\\cdot \\\\mathbf{n} + \\\\alpha (\\\\mathbf{a} - \\\\mathbf{b}))\\\\), where \\\\(\\\\alpha\\\\) is either a fixed number specified in the input file, or where \\\\(\\\\alpha\\\\) is a mesh dependent value. In the latter case, it is chosen as \\\\(\\\\frac{h}{2\\\\delta T}\\\\) with \\\\(h\\\\) the diameter of the face to which the flux is applied, and \\\\(\\\\delta T\\\\) the current time step.\\nWith these choices, equating the residual to zero results in a nonlinear system of equations \\\\(R(\\\\mathbf{W}_{n+1})=0\\\\). We solve this nonlinear system by a Newton iteration (in the same way as explained in step-15), i.e. by iterating     \\n\\\\begin{eqnarray*}\\nR'(\\\\mathbf{W}^k_{n+1},\\\\delta \\\\mathbf{W}_{n+1}^k)(\\\\mathbf z) & = & -\\nR(\\\\mathbf{W}^{k}_{n+1})(\\\\mathbf z) \\\\qquad \\\\qquad \\\\forall \\\\mathbf z\\\\in V_h \\\\\\\\\\n\\\\mathbf{W}^{k+1}_{n+1} &=& \\\\mathbf{W}^k_{n+1} + \\\\delta \\\\mathbf{W}^k_{n+1},\\n\\\\end{eqnarray*}\\n\\n until \\\\(|R(\\\\mathbf{W}^k_{n+1})|\\\\) (the residual) is sufficiently small. By testing with the nodal basis of a finite element space instead of all \\\\(\\\\mathbf z\\\\), we arrive at a linear system for \\\\(\\\\delta \\\\mathbf W\\\\):    \\n\\\\begin{eqnarray*}\\n\\\\mathbf R'(\\\\mathbf{W}^k_{n+1})\\\\delta \\\\mathbf{W}^k_{n+1} & = & -\\n\\\\mathbf R(\\\\mathbf{W}^{k}_{n+1}).\\n\\\\end{eqnarray*}\\n\\n This linear system is, in general, neither symmetric nor has any particular definiteness properties. We will either use a direct solver or Trilinos' GMRES implementation to solve it. As will become apparent from the results shown below, this fully implicit iteration converges very rapidly (typically in 3 steps) and with the quadratic convergence order expected from a Newton method.\\nAutomatic differentiation \\nSince computing the Jacobian matrix \\\\(\\\\mathbf R'(\\\\mathbf W^k)\\\\) is a terrible beast, we use an automatic differentiation package, Sacado, to do this. Sacado is a package within the Trilinos framework and offers a C++ template class Sacado::Fad::DFad (Fad standing for \\\"forward automatic\\ndifferentiation\\\") that supports basic arithmetic operators and functions such as  sqrt, sin, cos, pow,  etc. In order to use this feature, one declares a collection of variables of this type and then denotes some of this collection as degrees of freedom, the rest of the variables being functions of the independent variables. These variables are used in an algorithm, and as the variables are used, their sensitivities with respect to the degrees of freedom are continuously updated.\\nOne can imagine that for the full Jacobian matrix as a whole, this could be prohibitively expensive: the number of independent variables are the \\\\(\\\\mathbf W^k\\\\), the dependent variables the elements of the vector  \\\\(\\\\mathbf\\nR(\\\\mathbf W^k)\\\\). Both of these vectors can easily have tens of thousands of elements or more. However, it is important to note that not all elements of \\\\(\\\\mathbf R\\\\) depend on all elements of \\\\(\\\\mathbf W^k\\\\): in fact, an entry in \\\\(\\\\mathbf R\\\\) only depends on an element of \\\\(\\\\mathbf W^k\\\\) if the two corresponding shape functions overlap and couple in the weak form.\\nSpecifically, it is wise to define a minimum set of independent AD variables that the residual on the current cell may possibly depend on: on every element, we define those variables as independent that correspond to the degrees of freedom defined on this cell (or, if we have to compute jump terms between cells, that correspond to degrees of freedom defined on either of the two adjacent cells), and the dependent variables are the elements of the local residual vector. Not doing this, i.e. defining all elements of \\\\(\\\\mathbf W^k\\\\) as independent, will result a very expensive computation of a lot of zeros: the elements of the local residual vector are independent of almost all elements of the solution vector, and consequently their derivatives are zero; however, trying to compute these zeros can easily take 90% or more of the compute time of the entire program, as shown in an experiment inadvertently made by a student a few years after this program was first written.\\nComing back to the question of computing the Jacobian automatically: The author has used this approach side by side with a hand coded Jacobian for the incompressible Navier-Stokes problem and found the Sacado approach to be just as fast as using a hand coded Jacobian, but infinitely simpler and less error prone: Since using the auto-differentiation requires only that one code the residual \\\\(R(\\\\mathbf{W})\\\\), ensuring code correctness and maintaining code becomes tremendously more simple \\u2013 the Jacobian matrix \\\\(\\\\mathbf R'\\\\) is computed by essentially the same code that also computes the residual  \\\\(\\\\mathbf\\nR\\\\).\\nAll this said, here's a very simple example showing how Sacado can be used:\\n#include <Sacado.hpp>\\n#include <iostream>\\n \\nusing fad_double = Sacado::Fad::DFad<double>;\\n \\nmain() {\\n \\n  fad_double a,b,c;\\n \\n  a = 1; b = 2;\\n \\n  a.diff(0,2);  // Set a to be dof 0, in a 2-dof system.\\n \\n  b.diff(1,2);  // Set b to be dof 1, in a 2-dof system.\\n \\n  c = 2*a+cos(a*b);\\n \\n double *derivs = &c.fastAccessDx(0); // Access derivatives\\n \\n  std::cout << \\\"dc/da = \\\" << derivs[0] << \\\", dc/db=\\\" << derivs[1] << std::endl;\\n \\n}\\nThe output are the derivatives  \\\\(\\\\frac{\\\\partial c(a,b)}{\\\\partial a},\\n\\\\frac{\\\\partial c(a,b)}{\\\\partial b}\\\\) of \\\\(c(a,b)=2a+\\\\cos(ab)\\\\) at \\\\(a=1,b=2\\\\).\\nIt should be noted that Sacado provides more auto-differentiation capabilities than the small subset used in this program. However, understanding the example above is enough to understand the use of Sacado in this Euler flow program.\\nTrilinos solvers \\nThe program uses either the Aztec iterative solvers, or the Amesos sparse direct solver, both provided by the Trilinos package. This package is inherently designed to be used in a parallel program, however, it may be used in serial just as easily, as is done here. The Epetra package is the basic vector/matrix library upon which the solvers are built. This very powerful package can be used to describe the parallel distribution of a vector, and to define sparse matrices that operate on these vectors. Please view the commented code for more details on how these solvers are used within the example.\\nAdaptivity \\nThe example uses an ad hoc refinement indicator that shows some usefulness in shock-type problems, and in the downhill flow example included. We refine according to the squared gradient of the density. Hanging nodes are handled by computing the numerical flux across cells that are of differing refinement levels, rather than using the AffineConstraints class as in all other tutorial programs so far. In this way, the example combines the continuous and DG methodologies. It also simplifies the generation of the Jacobian because we do not have to track constrained degrees of freedom through the automatic differentiation used to compute it.\\nNoteWhen this program was written in 2008, we were unaware of any publication that would actually have used this approach. However, a more recent paper by A. Dedner, R. Kl\\u00f6fkorn, and M. Kr\\u00e4nkel (\\\"Continuous Finite-Elements on Non-Conforming Grids Using\\nDiscontinuous Galerkin Stabilization\\\", Proceedings of Finite Volumes for Complex Applications VII - Methods and Theoretical Aspects, Springer, 2014) comes close.\\n\\nIn hindsight, dealing with hanging nodes in this way is perhaps not the best choice. deal.II contains many places that assume that an element that has degrees of freedom on vertices, edges, and faces (like the FE_Q element used here) represents finite element functions on a triangulation that have certain continuity properties. Calling DoFTools::make_hanging_node_constraints() and putting the corresponding output into an AffineConstraints object allows one to enforce these assumptions when one calls AffineConstraints::distribute() at the end of the function that solves linear systems \\u2013 this call can be found in all other tutorial programs that use meshes with hanging nodes, and ensures that the resulting function's value at hanging nodes is correct with regard to the values of the nodes on the adjacent parent cell. On the other hand, this program does not do this, and this runs afoul of an assertion that was later added to the library and that tested that the function is indeed continuous. To address the resulting failure due to the assertion not being satisfied, we do after all enforce continuity at hanging nodes just before we transfer the solution from one mesh to another, in the ConservationLaw::refine_grid() function.\\nFurther, we enforce a maximum number of refinement levels to keep refinement under check. It is the author's experience that for adaptivity for a time dependent problem, refinement can easily lead the simulation to a screeching halt, because of time step restrictions if the mesh becomes too fine in any part of the domain, if care is not taken. The amount of refinement is limited in the example by letting the user specify the maximum level of refinement that will be present anywhere in the mesh. In this way, refinement tends not to slow the simulation to a halt. This, of course, is purely a heuristic strategy, and if the author's advisor heard about it, the author would likely be exiled forever from the finite element error estimation community.\\nInput deck, initial and boundary conditions\\nWe use an input file deck to drive the simulation. In this way, we can alter the boundary conditions and other important properties of the simulation without having to recompile. For more information on the format, look at the results section, where we describe an example input file in more detail.\\nIn previous example programs, we have usually hard-coded the initial and boundary conditions. In this program, we instead use the expression parser class FunctionParser so that we can specify a generic expression in the input file and have it parsed at run time \\u2014 this way, we can change initial conditions without the need to recompile the program. Consequently, no classes named InitialConditions or BoundaryConditions will be declared in the program below.\\nImplementation\\nThe implementation of this program is split into three essential parts: \\n\\nThe EulerEquations class that encapsulates everything that completely describes the specifics of the Euler equations. This includes the flux matrix \\\\(\\\\mathbf F(\\\\mathbf W)\\\\), the numerical flux  \\\\(\\\\mathbf F(\\\\mathbf\\n  W^+,\\\\mathbf W^-,\\\\mathbf n)\\\\), the right hand side \\\\(\\\\mathbf G(\\\\mathbf W)\\\\), boundary conditions, refinement indicators, postprocessing the output, and similar things that require knowledge of the meaning of the individual components of the solution vectors and the equations.\\n\\n\\n\\nA namespace that deals with everything that has to do with run-time parameters.\\n\\n\\n\\nThe ConservationLaw class that deals with time stepping, outer nonlinear and inner linear solves, assembling the linear systems, and the top-level logic that drives all this. \\n\\nThe reason for this approach is that it separates the various concerns in a program: the ConservationLaw is written in such a way that it would be relatively straightforward to adapt it to a different set of equations: One would simply re-implement the members of the EulerEquations class for some other hyperbolic equation, or augment the existing equations by additional ones (for example by advecting additional variables, or by adding chemistry, etc). Such modifications, however, would not affect the time stepping, or the nonlinear solvers if correctly done, and consequently nothing in the ConservationLaw would have to be modified.\\nSimilarly, if we wanted to improve on the linear or nonlinear solvers, or on the time stepping scheme (as hinted at the end of the results section), then this would not require changes in the EulerEquations at all.\\n The commented program\\n Include files\\nFirst a standard set of deal.II includes. Nothing special to comment on here:\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/base/parameter_handler.h>\\n\\u00a0 #include <deal.II/base/function_parser.h>\\n\\u00a0 #include <deal.II/base/utilities.h>\\n\\u00a0 #include <deal.II/base/conditional_ostream.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_out.h>\\n\\u00a0 #include <deal.II/grid/grid_refinement.h>\\n\\u00a0 #include <deal.II/grid/grid_in.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 #include <deal.II/fe/fe_system.h>\\n\\u00a0 #include <deal.II/fe/mapping_q1.h>\\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 #include <deal.II/numerics/solution_transfer.h>\\n\\u00a0 \\nThen, as mentioned in the introduction, we use various Trilinos packages as linear solvers as well as for automatic differentiation. These are in the following include files.\\nSince deal.II provides interfaces to the basic Trilinos matrices, preconditioners and solvers, we include them similarly as deal.II linear algebra structures.\\n\\u00a0 #include <deal.II/lac/trilinos_sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/trilinos_precondition.h>\\n\\u00a0 #include <deal.II/lac/trilinos_solver.h>\\n\\u00a0 \\n\\u00a0 \\nSacado is the automatic differentiation package within Trilinos, which is used to find the Jacobian for a fully implicit Newton iteration:\\n\\u00a0 #include <Sacado.hpp>\\n\\u00a0 \\nAnd this again is C++:\\n\\u00a0 #include <iostream>\\n\\u00a0 #include <fstream>\\n\\u00a0 #include <vector>\\n\\u00a0 #include <memory>\\n\\u00a0 #include <array>\\n\\u00a0 \\nTo end this section, introduce everything in the dealii library into the namespace into which the contents of this program will go:\\n\\u00a0 namespace Step33\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n Euler equation specifics\\nHere we define the flux function for this particular system of conservation laws, as well as pretty much everything else that's specific to the Euler equations for gas dynamics, for reasons discussed in the introduction. We group all this into a structure that defines everything that has to do with the flux. All members of this structure are static, i.e. the structure has no actual state specified by instance member variables. The better way to do this, rather than a structure with all static members would be to use a namespace \\u2013 but namespaces can't be templatized and we want some of the member variables of the structure to depend on the space dimension, which we in our usual way introduce using a template parameter.\\n\\u00a0   template <int dim>\\n\\u00a0   struct EulerEquations\\n\\u00a0   {\\n Component description\\nFirst a few variables that describe the various components of our solution vector in a generic way. This includes the number of components in the system (Euler's equations have one entry for momenta in each spatial direction, plus the energy and density components, for a total of dim+2 components), as well as functions that describe the index within the solution vector of the first momentum component, the density component, and the energy density component. Note that all these numbers depend on the space dimension; defining them in a generic way (rather than by implicit convention) makes our code more flexible and makes it easier to later extend it, for example by adding more components to the equations.\\n\\u00a0     static const unsigned int n_components             = dim + 2;\\n\\u00a0     static const unsigned int first_momentum_component = 0;\\n\\u00a0     static const unsigned int density_component        = dim;\\n\\u00a0     static const unsigned int energy_component         = dim + 1;\\n\\u00a0 \\nWhen generating graphical output way down in this program, we need to specify the names of the solution variables as well as how the various components group into vector and scalar fields. We could describe this there, but in order to keep things that have to do with the Euler equation localized here and the rest of the program as generic as possible, we provide this sort of information in the following two functions:\\n\\u00a0     static std::vector<std::string> component_names()\\n\\u00a0     {\\n\\u00a0       std::vector<std::string> names(dim, \\\"momentum\\\");\\n\\u00a0       names.emplace_back(\\\"density\\\");\\n\\u00a0       names.emplace_back(\\\"energy_density\\\");\\n\\u00a0 \\n\\u00a0       return names;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     static std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n\\u00a0     component_interpretation()\\n\\u00a0     {\\n\\u00a0       std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n\\u00a0         data_component_interpretation(\\n\\u00a0           dim, DataComponentInterpretation::component_is_part_of_vector);\\n\\u00a0       data_component_interpretation.push_back(\\n\\u00a0         DataComponentInterpretation::component_is_scalar);\\n\\u00a0       data_component_interpretation.push_back(\\n\\u00a0         DataComponentInterpretation::component_is_scalar);\\n\\u00a0 \\n\\u00a0       return data_component_interpretation;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\nDataComponentInterpretation::component_is_scalar@ component_is_scalarDefinition data_component_interpretation.h:52\\nDataComponentInterpretation::component_is_part_of_vector@ component_is_part_of_vectorDefinition data_component_interpretation.h:58\\n Transformations between variables\\nNext, we define the gas constant. We will set it to 1.4 in its definition immediately following the declaration of this class (unlike integer variables, like the ones above, static const floating point member variables cannot be initialized within the class declaration in C++). This value of 1.4 is representative of a gas that consists of molecules composed of two atoms, such as air which consists up to small traces almost entirely of \\\\(N_2\\\\) and \\\\(O_2\\\\).\\n\\u00a0     static const double gas_gamma;\\n\\u00a0 \\n\\u00a0 \\nIn the following, we will need to compute the kinetic energy and the pressure from a vector of conserved variables. This we can do based on the energy density and the kinetic energy  \\\\(\\\\frac 12 \\\\rho |\\\\mathbf v|^2\\n   = \\\\frac{|\\\\rho \\\\mathbf v|^2}{2\\\\rho}\\\\) (note that the independent variables contain the momentum components \\\\(\\\\rho v_i\\\\), not the velocities \\\\(v_i\\\\)).\\n\\u00a0     template <typename InputVector>\\n\\u00a0     static typename InputVector::value_type\\n\\u00a0     compute_kinetic_energy(const InputVector &W)\\n\\u00a0     {\\n\\u00a0       typename InputVector::value_type kinetic_energy = 0;\\n\\u00a0       for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0         kinetic_energy +=\\n\\u00a0           W[first_momentum_component + d] * W[first_momentum_component + d];\\n\\u00a0       kinetic_energy *= 1. / (2 * W[density_component]);\\n\\u00a0 \\n\\u00a0       return kinetic_energy;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <typename InputVector>\\n\\u00a0     static typename InputVector::value_type\\n\\u00a0     compute_pressure(const InputVector &W)\\n\\u00a0     {\\n\\u00a0       return ((gas_gamma - 1.0) *\\n\\u00a0               (W[energy_component] - compute_kinetic_energy(W)));\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n EulerEquations::compute_flux_matrix\\nWe define the flux function \\\\(F(W)\\\\) as one large matrix. Each row of this matrix represents a scalar conservation law for the component in that row. The exact form of this matrix is given in the introduction. Note that we know the size of the matrix: it has as many rows as the system has components, and dim columns; rather than using a FullMatrix object for such a matrix (which has a variable number of rows and columns and must therefore allocate memory on the heap each time such a matrix is created), we use a rectangular array of numbers right away.\\nWe templatize the numerical type of the flux function so that we may use the automatic differentiation type here. Similarly, we will call the function with different input vector data types, so we templatize on it as well:\\n\\u00a0     template <typename InputVector>\\n\\u00a0     static void compute_flux_matrix(const InputVector &W,\\n\\u00a0                                     ndarray<typename InputVector::value_type,\\n\\u00a0                                             EulerEquations<dim>::n_components,\\n\\u00a0                                             dim>      &flux)\\n\\u00a0     {\\nndarraytypename internal::ndarray::HelperArray< T, Ns... >::type ndarrayDefinition ndarray.h:107\\nFirst compute the pressure that appears in the flux matrix, and then compute the first dim columns of the matrix that correspond to the momentum terms:\\n\\u00a0       const typename InputVector::value_type pressure = compute_pressure(W);\\n\\u00a0 \\n\\u00a0       for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0         {\\n\\u00a0           for (unsigned int e = 0; e < dim; ++e)\\n\\u00a0             flux[first_momentum_component + d][e] =\\n\\u00a0               W[first_momentum_component + d] *\\n\\u00a0               W[first_momentum_component + e] / W[density_component];\\n\\u00a0 \\n\\u00a0           flux[first_momentum_component + d][d] += pressure;\\n\\u00a0         }\\n\\u00a0 \\nThen the terms for the density (i.e. mass conservation), and, lastly, conservation of energy:\\n\\u00a0       for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0         flux[density_component][d] = W[first_momentum_component + d];\\n\\u00a0 \\n\\u00a0       for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0         flux[energy_component][d] = W[first_momentum_component + d] /\\n\\u00a0                                     W[density_component] *\\n\\u00a0                                     (W[energy_component] + pressure);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n EulerEquations::compute_normal_flux\\nOn the boundaries of the domain and across hanging nodes we use a numerical flux function to enforce boundary conditions. This routine is the basic Lax-Friedrich's flux with a stabilization parameter \\\\(\\\\alpha\\\\). It's form has also been given already in the introduction:\\n\\u00a0     template <typename InputVector>\\n\\u00a0     static void numerical_normal_flux(\\n\\u00a0       const Tensor<1, dim>                                       &normal,\\n\\u00a0       const InputVector                                          &Wplus,\\n\\u00a0       const InputVector                                          &Wminus,\\n\\u00a0       const double                                                alpha,\\n\\u00a0       std::array<typename InputVector::value_type, n_components> &normal_flux)\\n\\u00a0     {\\n\\u00a0       ndarray<typename InputVector::value_type,\\n\\u00a0               EulerEquations<dim>::n_components,\\n\\u00a0               dim>\\n\\u00a0         iflux, oflux;\\n\\u00a0 \\n\\u00a0       compute_flux_matrix(Wplus, iflux);\\n\\u00a0       compute_flux_matrix(Wminus, oflux);\\n\\u00a0 \\n\\u00a0       for (unsigned int di = 0; di < n_components; ++di)\\n\\u00a0         {\\n\\u00a0           normal_flux[di] = 0;\\n\\u00a0           for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0             normal_flux[di] += 0.5 * (iflux[di][d] + oflux[di][d]) * normal[d];\\n\\u00a0 \\n\\u00a0           normal_flux[di] += 0.5 * alpha * (Wplus[di] - Wminus[di]);\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\nTensorDefinition tensor.h:471\\n EulerEquations::compute_forcing_vector\\nIn the same way as describing the flux function \\\\(\\\\mathbf F(\\\\mathbf w)\\\\), we also need to have a way to describe the right hand side forcing term. As mentioned in the introduction, we consider only gravity here, which leads to the specific form   \\\\(\\\\mathbf G(\\\\mathbf w) = \\\\left(\\n   g_1\\\\rho, g_2\\\\rho, g_3\\\\rho, 0, \\\\rho \\\\mathbf g \\\\cdot \\\\mathbf v\\n   \\\\right)^T\\\\), shown here for the 3d case. More specifically, we will consider only \\\\(\\\\mathbf g=(0,0,-1)^T\\\\) in 3d, or \\\\(\\\\mathbf g=(0,-1)^T\\\\) in 2d. This naturally leads to the following function:\\n\\u00a0     template <typename InputVector>\\n\\u00a0     static void compute_forcing_vector(\\n\\u00a0       const InputVector                                          &W,\\n\\u00a0       std::array<typename InputVector::value_type, n_components> &forcing)\\n\\u00a0     {\\n\\u00a0       const double gravity = -1.0;\\n\\u00a0 \\n\\u00a0       for (unsigned int c = 0; c < n_components; ++c)\\n\\u00a0         switch (c)\\n\\u00a0           {\\n\\u00a0             case first_momentum_component + dim - 1:\\n\\u00a0               forcing[c] = gravity * W[density_component];\\n\\u00a0               break;\\n\\u00a0             case energy_component:\\n\\u00a0               forcing[c] = gravity * W[first_momentum_component + dim - 1];\\n\\u00a0               break;\\n\\u00a0             default:\\n\\u00a0               forcing[c] = 0;\\n\\u00a0           }\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n Dealing with boundary conditions\\nAnother thing we have to deal with is boundary conditions. To this end, let us first define the kinds of boundary conditions we currently know how to deal with:\\n\\u00a0     enum BoundaryKind\\n\\u00a0     {\\n\\u00a0       inflow_boundary,\\n\\u00a0       outflow_boundary,\\n\\u00a0       no_penetration_boundary,\\n\\u00a0       pressure_boundary\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\nThe next part is to actually decide what to do at each kind of boundary. To this end, remember from the introduction that boundary conditions are specified by choosing a value \\\\(\\\\mathbf w^-\\\\) on the outside of a boundary given an inhomogeneity \\\\(\\\\mathbf j\\\\) and possibly the solution's value \\\\(\\\\mathbf w^+\\\\) on the inside. Both are then passed to the numerical flux  \\\\(\\\\mathbf H(\\\\mathbf{w}^+, \\\\mathbf{w}^-,\\n   \\\\mathbf{n})\\\\) to define boundary contributions to the bilinear form.\\nBoundary conditions can in some cases be specified for each component of the solution vector independently. For example, if component \\\\(c\\\\) is marked for inflow, then \\\\(w^-_c = j_c\\\\). If it is an outflow, then  \\\\(w^-_c\\n   = w^+_c\\\\). These two simple cases are handled first in the function below.\\nThere is a little snag that makes this function unpleasant from a C++ language viewpoint: The output vector Wminus will of course be modified, so it shouldn't be a const argument. Yet it is in the implementation below, and needs to be in order to allow the code to compile. The reason is that we call this function at a place where Wminus is of type Table<2,Sacado::Fad::DFad<double> >, this being 2d table with indices representing the quadrature point and the vector component, respectively. We call this function with Wminus[q] as last argument; subscripting a 2d table yields a temporary accessor object representing a 1d vector, just what we want here. The problem is that a temporary accessor object can't be bound to a non-const reference argument of a function, as we would like here, according to the C++ 1998 and 2003 standards (something that will be fixed with the next standard in the form of rvalue references). We get away with making the output argument here a constant because it is the accessor object that's constant, not the table it points to: that one can still be written to. The hack is unpleasant nevertheless because it restricts the kind of data types that may be used as template argument to this function: a regular vector isn't going to do because that one can not be written to when marked const. With no good solution around at the moment, we'll go with the pragmatic, even if not pretty, solution shown here:\\n\\u00a0     template <typename DataVector>\\n\\u00a0     static void\\n\\u00a0     compute_Wminus(const std::array<BoundaryKind, n_components> &boundary_kind,\\n\\u00a0                    const Tensor<1, dim>                         &normal_vector,\\n\\u00a0                    const DataVector                             &Wplus,\\n\\u00a0                    const Vector<double> &boundary_values,\\n\\u00a0                    const DataVector     &Wminus)\\n\\u00a0     {\\n\\u00a0       for (unsigned int c = 0; c < n_components; ++c)\\n\\u00a0         switch (boundary_kind[c])\\n\\u00a0           {\\n\\u00a0             case inflow_boundary:\\n\\u00a0               {\\n\\u00a0                 Wminus[c] = boundary_values(c);\\n\\u00a0                 break;\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0             case outflow_boundary:\\n\\u00a0               {\\n\\u00a0                 Wminus[c] = Wplus[c];\\n\\u00a0                 break;\\n\\u00a0               }\\n\\u00a0 \\nVectorDefinition vector.h:120\\nPrescribed pressure boundary conditions are a bit more complicated by the fact that even though the pressure is prescribed, we really are setting the energy component here, which will depend on velocity and pressure. So even though this seems like a Dirichlet type boundary condition, we get sensitivities of energy to velocity and density (unless these are also prescribed):\\n\\u00a0             case pressure_boundary:\\n\\u00a0               {\\n\\u00a0                 const typename DataVector::value_type density =\\n\\u00a0                   (boundary_kind[density_component] == inflow_boundary ?\\n\\u00a0                      boundary_values(density_component) :\\n\\u00a0                      Wplus[density_component]);\\n\\u00a0 \\n\\u00a0                 typename DataVector::value_type kinetic_energy = 0;\\n\\u00a0                 for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0                   if (boundary_kind[d] == inflow_boundary)\\n\\u00a0                     kinetic_energy += boundary_values(d) * boundary_values(d);\\n\\u00a0                   else\\n\\u00a0                     kinetic_energy += Wplus[d] * Wplus[d];\\n\\u00a0                 kinetic_energy *= 1. / 2. / density;\\n\\u00a0 \\n\\u00a0                 Wminus[c] =\\n\\u00a0                   boundary_values(c) / (gas_gamma - 1.0) + kinetic_energy;\\n\\u00a0 \\n\\u00a0                 break;\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0             case no_penetration_boundary:\\n\\u00a0               {\\nWe prescribe the velocity (we are dealing with a particular component here so that the average of the velocities is orthogonal to the surface normal. This creates sensitivities of across the velocity components.\\n\\u00a0                 typename DataVector::value_type vdotn = 0;\\n\\u00a0                 for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0                   {\\n\\u00a0                     vdotn += Wplus[d] * normal_vector[d];\\n\\u00a0                   }\\n\\u00a0 \\n\\u00a0                 Wminus[c] = Wplus[c] - 2.0 * vdotn * normal_vector[c];\\n\\u00a0                 break;\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0             default:\\n\\u00a0               DEAL_II_NOT_IMPLEMENTED();\\n\\u00a0           }\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\nDEAL_II_NOT_IMPLEMENTED#define DEAL_II_NOT_IMPLEMENTED()Definition exceptions.h:1814\\n EulerEquations::compute_refinement_indicators\\nIn this class, we also want to specify how to refine the mesh. The class ConservationLaw that will use all the information we provide here in the EulerEquation class is pretty agnostic about the particular conservation law it solves: as doesn't even really care how many components a solution vector has. Consequently, it can't know what a reasonable refinement indicator would be. On the other hand, here we do, or at least we can come up with a reasonable choice: we simply look at the gradient of the density, and compute \\\\(\\\\eta_K=\\\\log\\\\left(1+|\\\\nabla\\\\rho(x_K)|\\\\right)\\\\), where \\\\(x_K\\\\) is the center of cell \\\\(K\\\\).\\nThere are certainly a number of equally reasonable refinement indicators, but this one does, and it is easy to compute:\\n\\u00a0     static void\\n\\u00a0     compute_refinement_indicators(const DoFHandler<dim> &dof_handler,\\n\\u00a0                                   const Mapping<dim>    &mapping,\\n\\u00a0                                   const Vector<double>  &solution,\\n\\u00a0                                   Vector<double>        &refinement_indicators)\\n\\u00a0     {\\n\\u00a0       const unsigned int dofs_per_cell = dof_handler.get_fe().n_dofs_per_cell();\\n\\u00a0       std::vector<unsigned int> dofs(dofs_per_cell);\\n\\u00a0 \\n\\u00a0       const QMidpoint<dim> quadrature_formula;\\n\\u00a0       const UpdateFlags    update_flags = update_gradients;\\n\\u00a0       FEValues<dim>        fe_v(mapping,\\n\\u00a0                          dof_handler.get_fe(),\\n\\u00a0                          quadrature_formula,\\n\\u00a0                          update_flags);\\n\\u00a0 \\n\\u00a0       std::vector<std::vector<Tensor<1, dim>>> dU(\\n\\u00a0         1, std::vector<Tensor<1, dim>>(n_components));\\n\\u00a0 \\n\\u00a0       for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0         {\\n\\u00a0           const unsigned int cell_no = cell->active_cell_index();\\n\\u00a0           fe_v.reinit(cell);\\n\\u00a0           fe_v.get_function_gradients(solution, dU);\\n\\u00a0 \\n\\u00a0           refinement_indicators(cell_no) = std::log(\\n\\u00a0             1 + std::sqrt(dU[0][density_component] * dU[0][density_component]));\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nDoFHandlerDefinition dof_handler.h:317\\nDoFHandler::get_feconst FiniteElement< dim, spacedim > & get_fe(const types::fe_index index=0) const\\nFEValuesDefinition fe_values.h:63\\nFiniteElementData::n_dofs_per_cellunsigned int n_dofs_per_cell() const\\nMappingAbstract base class for mapping classes.Definition mapping.h:318\\nQMidpointDefinition quadrature_lib.h:162\\nint\\nUpdateFlagsUpdateFlagsDefinition fe_update_flags.h:64\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nstd::log::VectorizedArray< Number, width > log(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6849\\nstd::sqrt::VectorizedArray< Number, width > sqrt(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6869\\n EulerEquations::Postprocessor\\nFinally, we declare a class that implements a postprocessing of data components. The problem this class solves is that the variables in the formulation of the Euler equations we use are in conservative rather than physical form: they are momentum densities  \\\\(\\\\mathbf m=\\\\rho\\\\mathbf\\n   v\\\\), density \\\\(\\\\rho\\\\), and energy density \\\\(E\\\\). What we would like to also put into our output file are velocities  \\\\(\\\\mathbf v=\\\\frac{\\\\mathbf\\n   m}{\\\\rho}\\\\) and pressure  \\\\(p=(\\\\gamma-1)(E-\\\\frac{1}{2} \\\\rho |\\\\mathbf\\n   v|^2)\\\\).\\nIn addition, we would like to add the possibility to generate schlieren plots. Schlieren plots are a way to visualize shocks and other sharp interfaces. The word \\\"schlieren\\\" is a German word that may be translated as \\\"striae\\\" \\u2013 it may be simpler to explain it by an example, however: schlieren is what you see when you, for example, pour highly concentrated alcohol, or a transparent saline solution, into water; the two have the same color, but they have different refractive indices and so before they are fully mixed light goes through the mixture along bent rays that lead to brightness variations if you look at it. That's \\\"schlieren\\\". A similar effect happens in compressible flow because the refractive index depends on the pressure (and therefore the density) of the gas.\\nThe origin of the word refers to two-dimensional projections of a three-dimensional volume (we see a 2d picture of the 3d fluid). In computational fluid dynamics, we can get an idea of this effect by considering what causes it: density variations. Schlieren plots are therefore produced by plotting \\\\(s=|\\\\nabla \\\\rho|^2\\\\); obviously, \\\\(s\\\\) is large in shocks and at other highly dynamic places. If so desired by the user (by specifying this in the input file), we would like to generate these schlieren plots in addition to the other derived quantities listed above.\\nThe implementation of the algorithms to compute derived quantities from the ones that solve our problem, and to output them into data file, rests on the DataPostprocessor class. It has extensive documentation, and other uses of the class can also be found in step-29. We therefore refrain from extensive comments.\\n\\u00a0     class Postprocessor : public DataPostprocessor<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       Postprocessor(const bool do_schlieren_plot);\\n\\u00a0 \\n\\u00a0       virtual void evaluate_vector_field(\\n\\u00a0         const DataPostprocessorInputs::Vector<dim> &inputs,\\n\\u00a0         std::vector<Vector<double>> &computed_quantities) const override;\\n\\u00a0 \\n\\u00a0       virtual std::vector<std::string> get_names() const override;\\n\\u00a0 \\n\\u00a0       virtual std::vector<\\n\\u00a0         DataComponentInterpretation::DataComponentInterpretation>\\n\\u00a0       get_data_component_interpretation() const override;\\n\\u00a0 \\n\\u00a0       virtual UpdateFlags get_needed_update_flags() const override;\\n\\u00a0 \\n\\u00a0     private:\\n\\u00a0       const bool do_schlieren_plot;\\n\\u00a0     };\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   const double EulerEquations<dim>::gas_gamma = 1.4;\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   EulerEquations<dim>::Postprocessor::Postprocessor(\\n\\u00a0     const bool do_schlieren_plot)\\n\\u00a0     : do_schlieren_plot(do_schlieren_plot)\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\nDataPostprocessorDefinition data_postprocessor.h:583\\nDataPostprocessor::get_needed_update_flagsvirtual UpdateFlags get_needed_update_flags() const =0\\nDataPostprocessor::evaluate_vector_fieldvirtual void evaluate_vector_field(const DataPostprocessorInputs::Vector< dim > &input_data, std::vector< Vector< double > > &computed_quantities) constDefinition data_postprocessor.cc:59\\nDataPostprocessor::get_namesvirtual std::vector< std::string > get_names() const =0\\nDataPostprocessor::get_data_component_interpretationvirtual std::vector< DataComponentInterpretation::DataComponentInterpretation > get_data_component_interpretation() constDefinition data_postprocessor.cc:70\\nDataComponentInterpretation::DataComponentInterpretationDataComponentInterpretationDefinition data_component_interpretation.h:47\\nDataPostprocessorInputs::VectorDefinition data_postprocessor.h:400\\nThis is the only function worth commenting on. When generating graphical output, the DataOut and related classes will call this function on each cell, with access to values, gradients, Hessians, and normal vectors (in case we're working on faces) at each quadrature point. Note that the data at each quadrature point is itself vector-valued, namely the conserved variables. What we're going to do here is to compute the quantities we're interested in at each quadrature point. Note that for this we can ignore the Hessians (\\\"inputs.solution_hessians\\\") and normal vectors (\\\"inputs.normals\\\").\\n\\u00a0   template <int dim>\\n\\u00a0   void EulerEquations<dim>::Postprocessor::evaluate_vector_field(\\n\\u00a0     const DataPostprocessorInputs::Vector<dim> &inputs,\\n\\u00a0     std::vector<Vector<double>>                &computed_quantities) const\\n\\u00a0   {\\nAt the beginning of the function, let us make sure that all variables have the correct sizes, so that we can access individual vector elements without having to wonder whether we might read or write invalid elements; we also check that the solution_gradients vector only contains data if we really need it (the system knows about this because we say so in the get_needed_update_flags() function below). For the inner vectors, we check that at least the first element of the outer vector has the correct inner size:\\n\\u00a0     const unsigned int n_evaluation_points = inputs.solution_values.size();\\n\\u00a0 \\n\\u00a0     if (do_schlieren_plot == true)\\n\\u00a0       Assert(inputs.solution_gradients.size() == n_evaluation_points,\\n\\u00a0              ExcInternalError());\\n\\u00a0 \\n\\u00a0     Assert(computed_quantities.size() == n_evaluation_points,\\n\\u00a0            ExcInternalError());\\n\\u00a0 \\n\\u00a0     Assert(inputs.solution_values[0].size() == n_components,\\n\\u00a0            ExcInternalError());\\n\\u00a0 \\n\\u00a0     if (do_schlieren_plot == true)\\n\\u00a0       {\\n\\u00a0         Assert(computed_quantities[0].size() == dim + 2, ExcInternalError());\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       {\\n\\u00a0         Assert(computed_quantities[0].size() == dim + 1, ExcInternalError());\\n\\u00a0       }\\n\\u00a0 \\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\nThen loop over all quadrature points and do our work there. The code should be pretty self-explanatory. The order of output variables is first dim velocities, then the pressure, and if so desired the schlieren plot. Note that we try to be generic about the order of variables in the input vector, using the first_momentum_component and density_component information:\\n\\u00a0     for (unsigned int p = 0; p < n_evaluation_points; ++p)\\n\\u00a0       {\\n\\u00a0         const double density = inputs.solution_values[p](density_component);\\n\\u00a0 \\n\\u00a0         for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0           computed_quantities[p](d) =\\n\\u00a0             inputs.solution_values[p](first_momentum_component + d) / density;\\n\\u00a0 \\n\\u00a0         computed_quantities[p](dim) =\\n\\u00a0           compute_pressure(inputs.solution_values[p]);\\n\\u00a0 \\n\\u00a0         if (do_schlieren_plot == true)\\n\\u00a0           computed_quantities[p](dim + 1) =\\n\\u00a0             inputs.solution_gradients[p][density_component] *\\n\\u00a0             inputs.solution_gradients[p][density_component];\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   std::vector<std::string> EulerEquations<dim>::Postprocessor::get_names() const\\n\\u00a0   {\\n\\u00a0     std::vector<std::string> names;\\n\\u00a0     for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0       names.emplace_back(\\\"velocity\\\");\\n\\u00a0     names.emplace_back(\\\"pressure\\\");\\n\\u00a0 \\n\\u00a0     if (do_schlieren_plot == true)\\n\\u00a0       names.emplace_back(\\\"schlieren_plot\\\");\\n\\u00a0 \\n\\u00a0     return names;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n\\u00a0   EulerEquations<dim>::Postprocessor::get_data_component_interpretation() const\\n\\u00a0   {\\n\\u00a0     std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n\\u00a0       interpretation(dim,\\n\\u00a0                      DataComponentInterpretation::component_is_part_of_vector);\\n\\u00a0 \\n\\u00a0     interpretation.push_back(DataComponentInterpretation::component_is_scalar);\\n\\u00a0 \\n\\u00a0     if (do_schlieren_plot == true)\\n\\u00a0       interpretation.push_back(\\n\\u00a0         DataComponentInterpretation::component_is_scalar);\\n\\u00a0 \\n\\u00a0     return interpretation;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   UpdateFlags\\n\\u00a0   EulerEquations<dim>::Postprocessor::get_needed_update_flags() const\\n\\u00a0   {\\n\\u00a0     if (do_schlieren_plot == true)\\n\\u00a0       return update_values | update_gradients;\\n\\u00a0     else\\n\\u00a0       return update_values;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nPhysics::Elasticity::Kinematics::dSymmetricTensor< 2, dim, Number > d(const Tensor< 2, dim, Number > &F, const Tensor< 2, dim, Number > &dF_dt)\\n Run time parameter handling\\nOur next job is to define a few classes that will contain run-time parameters (for example solver tolerances, number of iterations, stabilization parameter, and the like). One could do this in the main class, but we separate it from that one to make the program more modular and easier to read: Everything that has to do with run-time parameters will be in the following namespace, whereas the program logic is in the main class.\\nWe will split the run-time parameters into a few separate structures, which we will all put into a namespace Parameters. Of these classes, there are a few that group the parameters for individual groups, such as for solvers, mesh refinement, or output. Each of these classes have functions declare_parameters() and parse_parameters() that declare parameter subsections and entries in a ParameterHandler object, and retrieve actual parameter values from such an object, respectively. These classes declare all their parameters in subsections of the ParameterHandler.\\nThe final class of the following namespace combines all the previous classes by deriving from them and taking care of a few more entries at the top level of the input file, as well as a few odd other entries in subsections that are too short to warrant a structure by themselves.\\nIt is worth pointing out one thing here: None of the classes below have a constructor that would initialize the various member variables. This isn't a problem, however, since we will read all variables declared in these classes from the input file (or indirectly: a ParameterHandler object will read it from there, and we will get the values from this object), and they will be initialized this way. In case a certain variable is not specified at all in the input file, this isn't a problem either: The ParameterHandler class will in this case simply take the default value that was specified when declaring an entry in the declare_parameters() functions of the classes below.\\n\\u00a0   namespace Parameters\\n\\u00a0   {\\n Parameters::Solver\\nThe first of these classes deals with parameters for the linear inner solver. It offers parameters that indicate which solver to use (GMRES as a solver for general non-symmetric indefinite systems, or a sparse direct solver), the amount of output to be produced, as well as various parameters that tweak the thresholded incomplete LU decomposition (ILUT) that we use as a preconditioner for GMRES.\\nIn particular, the ILUT takes the following parameters:\\nilut_fill: the number of extra entries to add when forming the ILU decomposition\\nilut_atol, ilut_rtol: When forming the preconditioner, for certain problems bad conditioning (or just bad luck) can cause the preconditioner to be very poorly conditioned. Hence it can help to add diagonal perturbations to the original matrix and form the preconditioner for this slightly better matrix. ATOL is an absolute perturbation that is added to the diagonal before forming the prec, and RTOL is a scaling factor \\\\(rtol \\\\geq 1\\\\).\\nilut_drop: The ILUT will drop any values that have magnitude less than this value. This is a way to manage the amount of memory used by this preconditioner.\\n\\nThe meaning of each parameter is also briefly described in the third argument of the ParameterHandler::declare_entry call in declare_parameters().\\n\\u00a0     struct Solver\\n\\u00a0     {\\n\\u00a0       enum SolverType\\n\\u00a0       {\\n\\u00a0         gmres,\\n\\u00a0         direct\\n\\u00a0       };\\n\\u00a0       SolverType solver;\\n\\u00a0 \\n\\u00a0       enum OutputType\\n\\u00a0       {\\n\\u00a0         quiet,\\n\\u00a0         verbose\\n\\u00a0       };\\n\\u00a0       OutputType output;\\n\\u00a0 \\n\\u00a0       double linear_residual;\\n\\u00a0       int    max_iterations;\\n\\u00a0 \\n\\u00a0       double ilut_fill;\\n\\u00a0       double ilut_atol;\\n\\u00a0       double ilut_rtol;\\n\\u00a0       double ilut_drop;\\n\\u00a0 \\n\\u00a0       static void declare_parameters(ParameterHandler &prm);\\n\\u00a0       void        parse_parameters(ParameterHandler &prm);\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     void Solver::declare_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       prm.enter_subsection(\\\"linear solver\\\");\\n\\u00a0       {\\n\\u00a0         prm.declare_entry(\\n\\u00a0           \\\"output\\\",\\n\\u00a0           \\\"quiet\\\",\\n\\u00a0           Patterns::Selection(\\\"quiet|verbose\\\"),\\n\\u00a0           \\\"State whether output from solver runs should be printed. \\\"\\n\\u00a0           \\\"Choices are <quiet|verbose>.\\\");\\n\\u00a0         prm.declare_entry(\\\"method\\\",\\n\\u00a0                           \\\"gmres\\\",\\n\\u00a0                           Patterns::Selection(\\\"gmres|direct\\\"),\\n\\u00a0                           \\\"The kind of solver for the linear system. \\\"\\n\\u00a0                           \\\"Choices are <gmres|direct>.\\\");\\n\\u00a0         prm.declare_entry(\\\"residual\\\",\\n\\u00a0                           \\\"1e-10\\\",\\n\\u00a0                           Patterns::Double(),\\n\\u00a0                           \\\"Linear solver residual\\\");\\n\\u00a0         prm.declare_entry(\\\"max iters\\\",\\n\\u00a0                           \\\"300\\\",\\n\\u00a0                           Patterns::Integer(),\\n\\u00a0                           \\\"Maximum solver iterations\\\");\\n\\u00a0         prm.declare_entry(\\\"ilut fill\\\",\\n\\u00a0                           \\\"2\\\",\\n\\u00a0                           Patterns::Double(),\\n\\u00a0                           \\\"Ilut preconditioner fill\\\");\\n\\u00a0         prm.declare_entry(\\\"ilut absolute tolerance\\\",\\n\\u00a0                           \\\"1e-9\\\",\\n\\u00a0                           Patterns::Double(),\\n\\u00a0                           \\\"Ilut preconditioner tolerance\\\");\\n\\u00a0         prm.declare_entry(\\\"ilut relative tolerance\\\",\\n\\u00a0                           \\\"1.1\\\",\\n\\u00a0                           Patterns::Double(),\\n\\u00a0                           \\\"Ilut relative tolerance\\\");\\n\\u00a0         prm.declare_entry(\\\"ilut drop tolerance\\\",\\n\\u00a0                           \\\"1e-10\\\",\\n\\u00a0                           Patterns::Double(),\\n\\u00a0                           \\\"Ilut drop tolerance\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     void Solver::parse_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       prm.enter_subsection(\\\"linear solver\\\");\\n\\u00a0       {\\n\\u00a0         const std::string op = prm.get(\\\"output\\\");\\n\\u00a0         if (op == \\\"verbose\\\")\\n\\u00a0           output = verbose;\\n\\u00a0         if (op == \\\"quiet\\\")\\n\\u00a0           output = quiet;\\n\\u00a0 \\n\\u00a0         const std::string sv = prm.get(\\\"method\\\");\\n\\u00a0         if (sv == \\\"direct\\\")\\n\\u00a0           solver = direct;\\n\\u00a0         else if (sv == \\\"gmres\\\")\\n\\u00a0           solver = gmres;\\n\\u00a0 \\n\\u00a0         linear_residual = prm.get_double(\\\"residual\\\");\\n\\u00a0         max_iterations  = prm.get_integer(\\\"max iters\\\");\\n\\u00a0         ilut_fill       = prm.get_double(\\\"ilut fill\\\");\\n\\u00a0         ilut_atol       = prm.get_double(\\\"ilut absolute tolerance\\\");\\n\\u00a0         ilut_rtol       = prm.get_double(\\\"ilut relative tolerance\\\");\\n\\u00a0         ilut_drop       = prm.get_double(\\\"ilut drop tolerance\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nParameterHandlerDefinition parameter_handler.h:855\\nParameterHandler::enter_subsectionvoid enter_subsection(const std::string &subsection, const bool create_path_if_needed=true)Definition parameter_handler.cc:991\\nParameterHandler::leave_subsectionvoid leave_subsection()Definition parameter_handler.cc:1015\\nParameterHandler::get_integerlong int get_integer(const std::string &entry_string) constDefinition parameter_handler.cc:1087\\nParameterHandler::declare_entryvoid declare_entry(const std::string &entry, const std::string &default_value, const Patterns::PatternBase &pattern=Patterns::Anything(), const std::string &documentation=\\\"\\\", const bool has_to_be_set=false)Definition parameter_handler.cc:846\\nParameterHandler::getstd::string get(const std::string &entry_string) constDefinition parameter_handler.cc:1049\\nParameterHandler::get_doubledouble get_double(const std::string &entry_name) constDefinition parameter_handler.cc:1130\\nPatterns::DoubleDefinition patterns.h:291\\nPatterns::IntegerDefinition patterns.h:188\\nPatterns::SelectionDefinition patterns.h:381\\n Parameters::Refinement\\nSimilarly, here are a few parameters that determine how the mesh is to be refined (and if it is to be refined at all). For what exactly the shock parameters do, see the mesh refinement functions further down.\\n\\u00a0     struct Refinement\\n\\u00a0     {\\n\\u00a0       bool   do_refine;\\n\\u00a0       double shock_val;\\n\\u00a0       double shock_levels;\\n\\u00a0 \\n\\u00a0       static void declare_parameters(ParameterHandler &prm);\\n\\u00a0       void        parse_parameters(ParameterHandler &prm);\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     void Refinement::declare_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       prm.enter_subsection(\\\"refinement\\\");\\n\\u00a0       {\\n\\u00a0         prm.declare_entry(\\\"refinement\\\",\\n\\u00a0                           \\\"true\\\",\\n\\u00a0                           Patterns::Bool(),\\n\\u00a0                           \\\"Whether to perform mesh refinement or not\\\");\\n\\u00a0         prm.declare_entry(\\\"refinement fraction\\\",\\n\\u00a0                           \\\"0.1\\\",\\n\\u00a0                           Patterns::Double(),\\n\\u00a0                           \\\"Fraction of high refinement\\\");\\n\\u00a0         prm.declare_entry(\\\"unrefinement fraction\\\",\\n\\u00a0                           \\\"0.1\\\",\\n\\u00a0                           Patterns::Double(),\\n\\u00a0                           \\\"Fraction of low unrefinement\\\");\\n\\u00a0         prm.declare_entry(\\\"max elements\\\",\\n\\u00a0                           \\\"1000000\\\",\\n\\u00a0                           Patterns::Double(),\\n\\u00a0                           \\\"maximum number of elements\\\");\\n\\u00a0         prm.declare_entry(\\\"shock value\\\",\\n\\u00a0                           \\\"4.0\\\",\\n\\u00a0                           Patterns::Double(),\\n\\u00a0                           \\\"value for shock indicator\\\");\\n\\u00a0         prm.declare_entry(\\\"shock levels\\\",\\n\\u00a0                           \\\"3.0\\\",\\n\\u00a0                           Patterns::Double(),\\n\\u00a0                           \\\"number of shock refinement levels\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     void Refinement::parse_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       prm.enter_subsection(\\\"refinement\\\");\\n\\u00a0       {\\n\\u00a0         do_refine    = prm.get_bool(\\\"refinement\\\");\\n\\u00a0         shock_val    = prm.get_double(\\\"shock value\\\");\\n\\u00a0         shock_levels = prm.get_double(\\\"shock levels\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nParameterHandler::get_boolbool get_bool(const std::string &entry_name) constDefinition parameter_handler.cc:1175\\nPatterns::BoolDefinition patterns.h:980\\n Parameters::Flux\\nNext a section on flux modifications to make it more stable. In particular, two options are offered to stabilize the Lax-Friedrichs flux: either choose    \\\\(\\\\mathbf{H}(\\\\mathbf{a},\\\\mathbf{b},\\\\mathbf{n}) =\\n   \\\\frac{1}{2}(\\\\mathbf{F}(\\\\mathbf{a})\\\\cdot \\\\mathbf{n} +\\n   \\\\mathbf{F}(\\\\mathbf{b})\\\\cdot \\\\mathbf{n} + \\\\alpha (\\\\mathbf{a} -\\n   \\\\mathbf{b}))\\\\) where \\\\(\\\\alpha\\\\) is either a fixed number specified in the input file, or where \\\\(\\\\alpha\\\\) is a mesh dependent value. In the latter case, it is chosen as \\\\(\\\\frac{h}{2\\\\delta T}\\\\) with \\\\(h\\\\) the diameter of the face to which the flux is applied, and \\\\(\\\\delta T\\\\) the current time step.\\n\\u00a0     struct Flux\\n\\u00a0     {\\n\\u00a0       enum StabilizationKind\\n\\u00a0       {\\n\\u00a0         constant,\\n\\u00a0         mesh_dependent\\n\\u00a0       };\\n\\u00a0       StabilizationKind stabilization_kind;\\n\\u00a0 \\n\\u00a0       double stabilization_value;\\n\\u00a0 \\n\\u00a0       static void declare_parameters(ParameterHandler &prm);\\n\\u00a0       void        parse_parameters(ParameterHandler &prm);\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     void Flux::declare_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       prm.enter_subsection(\\\"flux\\\");\\n\\u00a0       {\\n\\u00a0         prm.declare_entry(\\n\\u00a0           \\\"stab\\\",\\n\\u00a0           \\\"mesh\\\",\\n\\u00a0           Patterns::Selection(\\\"constant|mesh\\\"),\\n\\u00a0           \\\"Whether to use a constant stabilization parameter or \\\"\\n\\u00a0           \\\"a mesh-dependent one\\\");\\n\\u00a0         prm.declare_entry(\\\"stab value\\\",\\n\\u00a0                           \\\"1\\\",\\n\\u00a0                           Patterns::Double(),\\n\\u00a0                           \\\"alpha stabilization\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     void Flux::parse_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       prm.enter_subsection(\\\"flux\\\");\\n\\u00a0       {\\n\\u00a0         const std::string stab = prm.get(\\\"stab\\\");\\n\\u00a0         if (stab == \\\"constant\\\")\\n\\u00a0           stabilization_kind = constant;\\n\\u00a0         else if (stab == \\\"mesh\\\")\\n\\u00a0           stabilization_kind = mesh_dependent;\\n\\u00a0         else\\n\\u00a0           AssertThrow(false, ExcNotImplemented());\\n\\u00a0 \\n\\u00a0         stabilization_value = prm.get_double(\\\"stab value\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nAssertThrow#define AssertThrow(cond, exc)Definition exceptions.h:1739\\ninternal::HelperType::constant@ constant\\n Parameters::Output\\nThen a section on output parameters. We offer to produce Schlieren plots (the squared gradient of the density, a tool to visualize shock fronts), and a time interval between graphical output in case we don't want an output file every time step.\\n\\u00a0     struct Output\\n\\u00a0     {\\n\\u00a0       bool   schlieren_plot;\\n\\u00a0       double output_step;\\n\\u00a0 \\n\\u00a0       static void declare_parameters(ParameterHandler &prm);\\n\\u00a0       void        parse_parameters(ParameterHandler &prm);\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     void Output::declare_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       prm.enter_subsection(\\\"output\\\");\\n\\u00a0       {\\n\\u00a0         prm.declare_entry(\\\"schlieren plot\\\",\\n\\u00a0                           \\\"true\\\",\\n\\u00a0                           Patterns::Bool(),\\n\\u00a0                           \\\"Whether or not to produce schlieren plots\\\");\\n\\u00a0         prm.declare_entry(\\\"step\\\",\\n\\u00a0                           \\\"-1\\\",\\n\\u00a0                           Patterns::Double(),\\n\\u00a0                           \\\"Output once per this period\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     void Output::parse_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       prm.enter_subsection(\\\"output\\\");\\n\\u00a0       {\\n\\u00a0         schlieren_plot = prm.get_bool(\\\"schlieren plot\\\");\\n\\u00a0         output_step    = prm.get_double(\\\"step\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n Parameters::AllParameters\\nFinally the class that brings it all together. It declares a number of parameters itself, mostly ones at the top level of the parameter file as well as several in section too small to warrant their own classes. It also contains everything that is actually space dimension dependent, like initial or boundary conditions.\\nSince this class is derived from all the ones above, the declare_parameters() and parse_parameters() functions call the respective functions of the base classes as well.\\nNote that this class also handles the declaration of initial and boundary conditions specified in the input file. To this end, in both cases, there are entries like \\\"w_0 value\\\" which represent an expression in terms of \\\\(x,y,z\\\\) that describe the initial or boundary condition as a formula that will later be parsed by the FunctionParser class. Similar expressions exist for \\\"w_1\\\", \\\"w_2\\\", etc, denoting the dim+2 conserved variables of the Euler system. Similarly, we allow up to max_n_boundaries boundary indicators to be used in the input file, and each of these boundary indicators can be associated with an inflow, outflow, or pressure boundary condition, with homogeneous boundary conditions being specified for each component and each boundary indicator separately.\\nThe data structure used to store the boundary indicators is a bit complicated. It is an array of max_n_boundaries elements indicating the range of boundary indicators that will be accepted. For each entry in this array, we store a pair of data in the BoundaryCondition structure: first, an array of size n_components that for each component of the solution vector indicates whether it is an inflow, outflow, or other kind of boundary, and second a FunctionParser object that describes all components of the solution vector for this boundary id at once.\\nThe BoundaryCondition structure requires a constructor since we need to tell the function parser object at construction time how many vector components it is to describe. This initialization can therefore not wait till we actually set the formulas the FunctionParser object represents later in AllParameters::parse_parameters()\\nFor the same reason of having to tell Function objects their vector size at construction time, we have to have a constructor of the AllParameters class that at least initializes the other FunctionParser object, i.e. the one describing initial conditions.\\n\\u00a0     template <int dim>\\n\\u00a0     struct AllParameters : public Solver,\\n\\u00a0                            public Refinement,\\n\\u00a0                            public Flux,\\n\\u00a0                            public Output\\n\\u00a0     {\\n\\u00a0       static const unsigned int max_n_boundaries = 10;\\n\\u00a0 \\n\\u00a0       struct BoundaryConditions\\n\\u00a0       {\\n\\u00a0         std::array<typename EulerEquations<dim>::BoundaryKind,\\n\\u00a0                    EulerEquations<dim>::n_components>\\n\\u00a0           kind;\\n\\u00a0 \\n\\u00a0         FunctionParser<dim> values;\\n\\u00a0 \\n\\u00a0         BoundaryConditions();\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0       AllParameters();\\n\\u00a0 \\n\\u00a0       double diffusion_power;\\n\\u00a0 \\n\\u00a0       double time_step, final_time;\\n\\u00a0       double theta;\\n\\u00a0       bool   is_stationary;\\n\\u00a0 \\n\\u00a0       std::string mesh_filename;\\n\\u00a0 \\n\\u00a0       FunctionParser<dim> initial_conditions;\\n\\u00a0       BoundaryConditions  boundary_conditions[max_n_boundaries];\\n\\u00a0 \\n\\u00a0       static void declare_parameters(ParameterHandler &prm);\\n\\u00a0       void        parse_parameters(ParameterHandler &prm);\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     AllParameters<dim>::BoundaryConditions::BoundaryConditions()\\n\\u00a0       : values(EulerEquations<dim>::n_components)\\n\\u00a0     {\\n\\u00a0       std::fill(kind.begin(),\\n\\u00a0                 kind.end(),\\n\\u00a0                 EulerEquations<dim>::no_penetration_boundary);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     AllParameters<dim>::AllParameters()\\n\\u00a0       : diffusion_power(0.)\\n\\u00a0       , time_step(1.)\\n\\u00a0       , final_time(1.)\\n\\u00a0       , theta(.5)\\n\\u00a0       , is_stationary(true)\\n\\u00a0       , initial_conditions(EulerEquations<dim>::n_components)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void AllParameters<dim>::declare_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       prm.declare_entry(\\\"mesh\\\",\\n\\u00a0                         \\\"grid.inp\\\",\\n\\u00a0                         Patterns::Anything(),\\n\\u00a0                         \\\"input file name\\\");\\n\\u00a0 \\n\\u00a0       prm.declare_entry(\\\"diffusion power\\\",\\n\\u00a0                         \\\"2.0\\\",\\n\\u00a0                         Patterns::Double(),\\n\\u00a0                         \\\"power of mesh size for diffusion\\\");\\n\\u00a0 \\n\\u00a0       prm.enter_subsection(\\\"time stepping\\\");\\n\\u00a0       {\\n\\u00a0         prm.declare_entry(\\\"time step\\\",\\n\\u00a0                           \\\"0.1\\\",\\n\\u00a0                           Patterns::Double(0),\\n\\u00a0                           \\\"simulation time step\\\");\\n\\u00a0         prm.declare_entry(\\\"final time\\\",\\n\\u00a0                           \\\"10.0\\\",\\n\\u00a0                           Patterns::Double(0),\\n\\u00a0                           \\\"simulation end time\\\");\\n\\u00a0         prm.declare_entry(\\\"theta scheme value\\\",\\n\\u00a0                           \\\"0.5\\\",\\n\\u00a0                           Patterns::Double(0, 1),\\n\\u00a0                           \\\"value for theta that interpolated between explicit \\\"\\n\\u00a0                           \\\"Euler (theta=0), Crank-Nicolson (theta=0.5), and \\\"\\n\\u00a0                           \\\"implicit Euler (theta=1).\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0 \\n\\u00a0 \\n\\u00a0       for (unsigned int b = 0; b < max_n_boundaries; ++b)\\n\\u00a0         {\\n\\u00a0           prm.enter_subsection(\\\"boundary_\\\" + Utilities::int_to_string(b));\\n\\u00a0           {\\n\\u00a0             prm.declare_entry(\\\"no penetration\\\",\\n\\u00a0                               \\\"false\\\",\\n\\u00a0                               Patterns::Bool(),\\n\\u00a0                               \\\"whether the named boundary allows gas to \\\"\\n\\u00a0                               \\\"penetrate or is a rigid wall\\\");\\n\\u00a0 \\n\\u00a0             for (unsigned int di = 0; di < EulerEquations<dim>::n_components;\\n\\u00a0                  ++di)\\n\\u00a0               {\\n\\u00a0                 prm.declare_entry(\\\"w_\\\" + Utilities::int_to_string(di),\\n\\u00a0                                   \\\"outflow\\\",\\n\\u00a0                                   Patterns::Selection(\\n\\u00a0                                     \\\"inflow|outflow|pressure\\\"),\\n\\u00a0                                   \\\"<inflow|outflow|pressure>\\\");\\n\\u00a0 \\n\\u00a0                 prm.declare_entry(\\\"w_\\\" + Utilities::int_to_string(di) +\\n\\u00a0                                     \\\" value\\\",\\n\\u00a0                                   \\\"0.0\\\",\\n\\u00a0                                   Patterns::Anything(),\\n\\u00a0                                   \\\"expression in x,y,z\\\");\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0           prm.leave_subsection();\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0       prm.enter_subsection(\\\"initial condition\\\");\\n\\u00a0       {\\n\\u00a0         for (unsigned int di = 0; di < EulerEquations<dim>::n_components; ++di)\\n\\u00a0           prm.declare_entry(\\\"w_\\\" + Utilities::int_to_string(di) + \\\" value\\\",\\n\\u00a0                             \\\"0.0\\\",\\n\\u00a0                             Patterns::Anything(),\\n\\u00a0                             \\\"expression in x,y,z\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0 \\n\\u00a0       Parameters::Solver::declare_parameters(prm);\\n\\u00a0       Parameters::Refinement::declare_parameters(prm);\\n\\u00a0       Parameters::Flux::declare_parameters(prm);\\n\\u00a0       Parameters::Output::declare_parameters(prm);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void AllParameters<dim>::parse_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       mesh_filename   = prm.get(\\\"mesh\\\");\\n\\u00a0       diffusion_power = prm.get_double(\\\"diffusion power\\\");\\n\\u00a0 \\n\\u00a0       prm.enter_subsection(\\\"time stepping\\\");\\n\\u00a0       {\\n\\u00a0         time_step = prm.get_double(\\\"time step\\\");\\n\\u00a0         if (time_step == 0)\\n\\u00a0           {\\n\\u00a0             is_stationary = true;\\n\\u00a0             time_step     = 1.0;\\n\\u00a0             final_time    = 1.0;\\n\\u00a0           }\\n\\u00a0         else\\n\\u00a0           is_stationary = false;\\n\\u00a0 \\n\\u00a0         final_time = prm.get_double(\\\"final time\\\");\\n\\u00a0         theta      = prm.get_double(\\\"theta scheme value\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0 \\n\\u00a0       for (unsigned int boundary_id = 0; boundary_id < max_n_boundaries;\\n\\u00a0            ++boundary_id)\\n\\u00a0         {\\n\\u00a0           prm.enter_subsection(\\\"boundary_\\\" +\\n\\u00a0                                Utilities::int_to_string(boundary_id));\\n\\u00a0           {\\n\\u00a0             std::vector<std::string> expressions(\\n\\u00a0               EulerEquations<dim>::n_components, \\\"0.0\\\");\\n\\u00a0 \\n\\u00a0             const bool no_penetration = prm.get_bool(\\\"no penetration\\\");\\n\\u00a0 \\n\\u00a0             for (unsigned int di = 0; di < EulerEquations<dim>::n_components;\\n\\u00a0                  ++di)\\n\\u00a0               {\\n\\u00a0                 const std::string boundary_type =\\n\\u00a0                   prm.get(\\\"w_\\\" + Utilities::int_to_string(di));\\n\\u00a0 \\n\\u00a0                 if ((di < dim) && (no_penetration == true))\\n\\u00a0                   boundary_conditions[boundary_id].kind[di] =\\n\\u00a0                     EulerEquations<dim>::no_penetration_boundary;\\n\\u00a0                 else if (boundary_type == \\\"inflow\\\")\\n\\u00a0                   boundary_conditions[boundary_id].kind[di] =\\n\\u00a0                     EulerEquations<dim>::inflow_boundary;\\n\\u00a0                 else if (boundary_type == \\\"pressure\\\")\\n\\u00a0                   boundary_conditions[boundary_id].kind[di] =\\n\\u00a0                     EulerEquations<dim>::pressure_boundary;\\n\\u00a0                 else if (boundary_type == \\\"outflow\\\")\\n\\u00a0                   boundary_conditions[boundary_id].kind[di] =\\n\\u00a0                     EulerEquations<dim>::outflow_boundary;\\n\\u00a0                 else\\n\\u00a0                   AssertThrow(false, ExcNotImplemented());\\n\\u00a0 \\n\\u00a0                 expressions[di] =\\n\\u00a0                   prm.get(\\\"w_\\\" + Utilities::int_to_string(di) + \\\" value\\\");\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0             boundary_conditions[boundary_id].values.initialize(\\n\\u00a0               FunctionParser<dim>::default_variable_names(),\\n\\u00a0               expressions,\\n\\u00a0               std::map<std::string, double>());\\n\\u00a0           }\\n\\u00a0           prm.leave_subsection();\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0       prm.enter_subsection(\\\"initial condition\\\");\\n\\u00a0       {\\n\\u00a0         std::vector<std::string> expressions(EulerEquations<dim>::n_components,\\n\\u00a0                                              \\\"0.0\\\");\\n\\u00a0         for (unsigned int di = 0; di < EulerEquations<dim>::n_components; ++di)\\n\\u00a0           expressions[di] =\\n\\u00a0             prm.get(\\\"w_\\\" + Utilities::int_to_string(di) + \\\" value\\\");\\n\\u00a0         initial_conditions.initialize(\\n\\u00a0           FunctionParser<dim>::default_variable_names(),\\n\\u00a0           expressions,\\n\\u00a0           std::map<std::string, double>());\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0 \\n\\u00a0       Parameters::Solver::parse_parameters(prm);\\n\\u00a0       Parameters::Refinement::parse_parameters(prm);\\n\\u00a0       Parameters::Flux::parse_parameters(prm);\\n\\u00a0       Parameters::Output::parse_parameters(prm);\\n\\u00a0     }\\n\\u00a0   } // namespace Parameters\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFunctionParserDefinition function_parser.h:227\\nPatterns::AnythingDefinition patterns.h:1021\\nPhysics::Elasticity::Kinematics::bSymmetricTensor< 2, dim, Number > b(const Tensor< 2, dim, Number > &F)\\nUtilities::int_to_stringstd::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)Definition utilities.cc:470\\ntypes::boundary_idunsigned int boundary_idDefinition types.h:144\\n Conservation law class\\nHere finally comes the class that actually does something with all the Euler equation and parameter specifics we've defined above. The public interface is pretty much the same as always (the constructor now takes the name of a file from which to read parameters, which is passed on the command line). The private function interface is also pretty similar to the usual arrangement, with the assemble_system function split into three parts: one that contains the main loop over all cells and that then calls the other two for integrals over cells and faces, respectively.\\n\\u00a0   template <int dim>\\n\\u00a0   class ConservationLaw\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     ConservationLaw(const char *input_filename);\\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void setup_system();\\n\\u00a0 \\n\\u00a0     void assemble_system();\\n\\u00a0     void assemble_cell_term(const FEValues<dim>                        &fe_v,\\n\\u00a0                             const std::vector<types::global_dof_index> &dofs);\\n\\u00a0     void assemble_face_term(\\n\\u00a0       const unsigned int                          face_no,\\n\\u00a0       const FEFaceValuesBase<dim>                &fe_v,\\n\\u00a0       const FEFaceValuesBase<dim>                &fe_v_neighbor,\\n\\u00a0       const std::vector<types::global_dof_index> &dofs,\\n\\u00a0       const std::vector<types::global_dof_index> &dofs_neighbor,\\n\\u00a0       const bool                                  external_face,\\n\\u00a0       const unsigned int                          boundary_id,\\n\\u00a0       const double                                face_diameter);\\n\\u00a0 \\n\\u00a0     std::pair<unsigned int, double> solve(Vector<double> &solution);\\n\\u00a0 \\n\\u00a0     void compute_refinement_indicators(Vector<double> &indicator) const;\\n\\u00a0     void refine_grid(const Vector<double> &indicator);\\n\\u00a0 \\n\\u00a0     void output_results() const;\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFEFaceValuesBaseDefinition fe_values.h:202\\nThe first few member variables are also rather standard. Note that we define a mapping object to be used throughout the program when assembling terms (we will hand it to every FEValues and FEFaceValues object); the mapping we use is just the standard \\\\(Q_1\\\\) mapping \\u2013 nothing fancy, in other words \\u2013 but declaring one here and using it throughout the program will make it simpler later on to change it if that should become necessary. This is, in fact, rather pertinent: it is known that for transsonic simulations with the Euler equations, computations do not converge even as \\\\(h\\\\rightarrow 0\\\\) if the boundary approximation is not of sufficiently high order.\\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0     const MappingQ1<dim> mapping;\\n\\u00a0 \\n\\u00a0     const FESystem<dim> fe;\\n\\u00a0     DoFHandler<dim>     dof_handler;\\n\\u00a0 \\n\\u00a0     const QGauss<dim>     quadrature;\\n\\u00a0     const QGauss<dim - 1> face_quadrature;\\n\\u00a0 \\nFESystemDefinition fe_system.h:208\\nMappingQ1Definition mapping_q1.h:55\\nQGaussDefinition quadrature_lib.h:40\\nTriangulationDefinition tria.h:1323\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\nNext come a number of data vectors that correspond to the solution of the previous time step (old_solution), the best guess of the current solution (current_solution; we say guess because the Newton iteration to compute it may not have converged yet, whereas old_solution refers to the fully converged final result of the previous time step), and a predictor for the solution at the next time step, computed by extrapolating the current and previous solution one time step into the future:\\n\\u00a0     Vector<double> old_solution;\\n\\u00a0     Vector<double> current_solution;\\n\\u00a0     Vector<double> predictor;\\n\\u00a0 \\n\\u00a0     Vector<double> right_hand_side;\\n\\u00a0 \\nThis final set of member variables (except for the object holding all run-time parameters at the very bottom and a screen output stream that only prints something if verbose output has been requested) deals with the interface we have in this program to the Trilinos library that provides us with linear solvers. Similarly to including PETSc matrices in step-17 and step-18, all we need to do is to create a Trilinos sparse matrix instead of the standard deal.II class. The system matrix is used for the Jacobian in each Newton step. Since we do not intend to run this program in parallel (which wouldn't be too hard with Trilinos data structures, though), we don't have to think about anything else like distributing the degrees of freedom.\\n\\u00a0     TrilinosWrappers::SparseMatrix system_matrix;\\n\\u00a0 \\n\\u00a0     Parameters::AllParameters<dim> parameters;\\n\\u00a0     ConditionalOStream             verbose_cout;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\nConditionalOStreamDefinition conditional_ostream.h:80\\nTrilinosWrappers::SparseMatrixDefinition trilinos_sparse_matrix.h:550\\n ConservationLaw::ConservationLaw\\nThere is nothing much to say about the constructor. Essentially, it reads the input file and fills the parameter object with the parsed values:\\n\\u00a0   template <int dim>\\n\\u00a0   ConservationLaw<dim>::ConservationLaw(const char *input_filename)\\n\\u00a0     : mapping()\\n\\u00a0     , fe(FE_Q<dim>(1) ^ EulerEquations<dim>::n_components)\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0     , quadrature(fe.degree + 1)\\n\\u00a0     , face_quadrature(fe.degree + 1)\\n\\u00a0     , verbose_cout(std::cout, false)\\n\\u00a0   {\\n\\u00a0     ParameterHandler prm;\\n\\u00a0     Parameters::AllParameters<dim>::declare_parameters(prm);\\n\\u00a0 \\n\\u00a0     prm.parse_input(input_filename);\\n\\u00a0     parameters.parse_parameters(prm);\\n\\u00a0 \\n\\u00a0     verbose_cout.set_condition(parameters.output ==\\n\\u00a0                                Parameters::Solver::verbose);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFE_QDefinition fe_q.h:554\\nParameterHandler::parse_inputvirtual void parse_input(std::istream &input, const std::string &filename=\\\"input file\\\", const std::string &last_line=\\\"\\\", const bool skip_undefined=false)Definition parameter_handler.cc:433\\nstdSTL namespace.\\n ConservationLaw::setup_system\\nThe following (easy) function is called each time the mesh is changed. All it does is to resize the Trilinos matrix according to a sparsity pattern that we generate as in all the previous tutorial programs.\\n\\u00a0   template <int dim>\\n\\u00a0   void ConservationLaw<dim>::setup_system()\\n\\u00a0   {\\n\\u00a0     DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());\\n\\u00a0     DoFTools::make_sparsity_pattern(dof_handler, dsp);\\n\\u00a0 \\n\\u00a0     system_matrix.reinit(dsp);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nDoFHandler::n_dofstypes::global_dof_index n_dofs() const\\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\n ConservationLaw::assemble_system\\nThis and the following two functions are the meat of this program: They assemble the linear system that results from applying Newton's method to the nonlinear system of conservation equations.\\nThis first function puts all of the assembly pieces together in a routine that dispatches the correct piece for each cell/face. The actual implementation of the assembly on these objects is done in the following functions.\\nAt the top of the function we do the usual housekeeping: allocate FEValues, FEFaceValues, and FESubfaceValues objects necessary to do the integrations on cells, faces, and subfaces (in case of adjoining cells on different refinement levels). Note that we don't need all information (like values, gradients, or real locations of quadrature points) for all of these objects, so we only let the FEValues classes whatever is actually necessary by specifying the minimal set of UpdateFlags. For example, when using a FEFaceValues object for the neighboring cell we only need the shape values: Given a specific face, the quadrature points and JxW values are the same as for the current cells, and the normal vectors are known to be the negative of the normal vectors of the current cell.\\n\\u00a0   template <int dim>\\n\\u00a0   void ConservationLaw<dim>::assemble_system()\\n\\u00a0   {\\n\\u00a0     const unsigned int dofs_per_cell = dof_handler.get_fe().n_dofs_per_cell();\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> dof_indices(dofs_per_cell);\\n\\u00a0     std::vector<types::global_dof_index> dof_indices_neighbor(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     const UpdateFlags update_flags = update_values | update_gradients |\\n\\u00a0                                      update_quadrature_points |\\n\\u00a0                                      update_JxW_values,\\n\\u00a0                       face_update_flags =\\n\\u00a0                         update_values | update_quadrature_points |\\n\\u00a0                         update_JxW_values | update_normal_vectors,\\n\\u00a0                       neighbor_face_update_flags = update_values;\\n\\u00a0 \\n\\u00a0     FEValues<dim>        fe_v(mapping, fe, quadrature, update_flags);\\n\\u00a0     FEFaceValues<dim>    fe_v_face(mapping,\\n\\u00a0                                 fe,\\n\\u00a0                                 face_quadrature,\\n\\u00a0                                 face_update_flags);\\n\\u00a0     FESubfaceValues<dim> fe_v_subface(mapping,\\n\\u00a0                                       fe,\\n\\u00a0                                       face_quadrature,\\n\\u00a0                                       face_update_flags);\\n\\u00a0     FEFaceValues<dim>    fe_v_face_neighbor(mapping,\\n\\u00a0                                          fe,\\n\\u00a0                                          face_quadrature,\\n\\u00a0                                          neighbor_face_update_flags);\\n\\u00a0     FESubfaceValues<dim> fe_v_subface_neighbor(mapping,\\n\\u00a0                                                fe,\\n\\u00a0                                                face_quadrature,\\n\\u00a0                                                neighbor_face_update_flags);\\n\\u00a0 \\nFEFaceValuesDefinition fe_values.h:322\\nFESubfaceValuesDefinition fe_values.h:488\\nupdate_normal_vectors@ update_normal_vectorsNormal vectors.Definition fe_update_flags.h:141\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nThen loop over all cells, initialize the FEValues object for the current cell and call the function that assembles the problem on this cell.\\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         fe_v.reinit(cell);\\n\\u00a0         cell->get_dof_indices(dof_indices);\\n\\u00a0 \\n\\u00a0         assemble_cell_term(fe_v, dof_indices);\\n\\u00a0 \\nThen loop over all the faces of this cell. If a face is part of the external boundary, then assemble boundary conditions there (the fifth argument to assemble_face_terms indicates whether we are working on an external or internal face; if it is an external face, the fourth argument denoting the degrees of freedom indices of the neighbor is ignored, so we pass an empty vector):\\n\\u00a0         for (const auto face_no : cell->face_indices())\\n\\u00a0           if (cell->at_boundary(face_no))\\n\\u00a0             {\\n\\u00a0               fe_v_face.reinit(cell, face_no);\\n\\u00a0               assemble_face_term(face_no,\\n\\u00a0                                  fe_v_face,\\n\\u00a0                                  fe_v_face,\\n\\u00a0                                  dof_indices,\\n\\u00a0                                  std::vector<types::global_dof_index>(),\\n\\u00a0                                  true,\\n\\u00a0                                  cell->face(face_no)->boundary_id(),\\n\\u00a0                                  cell->face(face_no)->diameter());\\n\\u00a0             }\\n\\u00a0 \\nThe alternative is that we are dealing with an internal face. There are two cases that we need to distinguish: that this is a normal face between two cells at the same refinement level, and that it is a face between two cells of the different refinement levels.\\nIn the first case, there is nothing we need to do: we are using a continuous finite element, and face terms do not appear in the bilinear form in this case. The second case usually does not lead to face terms either if we enforce hanging node constraints strongly (as in all previous tutorial programs so far whenever we used continuous finite elements \\u2013 this enforcement is done by the AffineConstraints class together with DoFTools::make_hanging_node_constraints). In the current program, however, we opt to enforce continuity weakly at faces between cells of different refinement level, for two reasons: (i) because we can, and more importantly (ii) because we would have to thread the automatic differentiation we use to compute the elements of the Newton matrix from the residual through the operations of the AffineConstraints class. This would be possible, but is not trivial, and so we choose this alternative approach.\\nWhat needs to be decided is which side of an interface between two cells of different refinement level we are sitting on.\\nLet's take the case where the neighbor is more refined first. We then have to loop over the children of the face of the current cell and integrate on each of them. We sprinkle a couple of assertions into the code to ensure that our reasoning trying to figure out which of the neighbor's children's faces coincides with a given subface of the current cell's faces is correct \\u2013 a bit of defensive programming never hurts.\\nWe then call the function that integrates over faces; since this is an internal face, the fifth argument is false, and the sixth one is ignored so we pass an invalid value again:\\n\\u00a0           else\\n\\u00a0             {\\n\\u00a0               if (cell->neighbor(face_no)->has_children())\\n\\u00a0                 {\\n\\u00a0                   const unsigned int neighbor2 =\\n\\u00a0                     cell->neighbor_of_neighbor(face_no);\\n\\u00a0 \\n\\u00a0                   for (unsigned int subface_no = 0;\\n\\u00a0                        subface_no < cell->face(face_no)->n_children();\\n\\u00a0                        ++subface_no)\\n\\u00a0                     {\\n\\u00a0                       const typename DoFHandler<dim>::active_cell_iterator\\n\\u00a0                         neighbor_child =\\n\\u00a0                           cell->neighbor_child_on_subface(face_no, subface_no);\\n\\u00a0 \\n\\u00a0                       Assert(neighbor_child->face(neighbor2) ==\\n\\u00a0                                cell->face(face_no)->child(subface_no),\\n\\u00a0                              ExcInternalError());\\n\\u00a0                       Assert(neighbor_child->is_active(), ExcInternalError());\\n\\u00a0 \\n\\u00a0                       fe_v_subface.reinit(cell, face_no, subface_no);\\n\\u00a0                       fe_v_face_neighbor.reinit(neighbor_child, neighbor2);\\n\\u00a0 \\n\\u00a0                       neighbor_child->get_dof_indices(dof_indices_neighbor);\\n\\u00a0 \\n\\u00a0                       assemble_face_term(\\n\\u00a0                         face_no,\\n\\u00a0                         fe_v_subface,\\n\\u00a0                         fe_v_face_neighbor,\\n\\u00a0                         dof_indices,\\n\\u00a0                         dof_indices_neighbor,\\n\\u00a0                         false,\\n\\u00a0                         numbers::invalid_unsigned_int,\\n\\u00a0                         neighbor_child->face(neighbor2)->diameter());\\n\\u00a0                     }\\n\\u00a0                 }\\n\\u00a0 \\nDoFHandler::active_cell_iteratortypename ActiveSelector::active_cell_iterator active_cell_iteratorDefinition dof_handler.h:440\\nnumbers::invalid_unsigned_intstatic const unsigned int invalid_unsigned_intDefinition types.h:220\\nThe other possibility we have to care for is if the neighbor is coarser than the current cell (in particular, because of the usual restriction of only one hanging node per face, the neighbor must be exactly one level coarser than the current cell, something that we check with an assertion). Again, we then integrate over this interface:\\n\\u00a0               else if (cell->neighbor(face_no)->level() != cell->level())\\n\\u00a0                 {\\n\\u00a0                   const typename DoFHandler<dim>::cell_iterator neighbor =\\n\\u00a0                     cell->neighbor(face_no);\\n\\u00a0                   Assert(neighbor->level() == cell->level() - 1,\\n\\u00a0                          ExcInternalError());\\n\\u00a0 \\n\\u00a0                   neighbor->get_dof_indices(dof_indices_neighbor);\\n\\u00a0 \\n\\u00a0                   const std::pair<unsigned int, unsigned int> faceno_subfaceno =\\n\\u00a0                     cell->neighbor_of_coarser_neighbor(face_no);\\n\\u00a0                   const unsigned int neighbor_face_no = faceno_subfaceno.first,\\n\\u00a0                                      neighbor_subface_no =\\n\\u00a0                                        faceno_subfaceno.second;\\n\\u00a0 \\n\\u00a0                   Assert(neighbor->neighbor_child_on_subface(\\n\\u00a0                            neighbor_face_no, neighbor_subface_no) == cell,\\n\\u00a0                          ExcInternalError());\\n\\u00a0 \\n\\u00a0                   fe_v_face.reinit(cell, face_no);\\n\\u00a0                   fe_v_subface_neighbor.reinit(neighbor,\\n\\u00a0                                                neighbor_face_no,\\n\\u00a0                                                neighbor_subface_no);\\n\\u00a0 \\n\\u00a0                   assemble_face_term(face_no,\\n\\u00a0                                      fe_v_face,\\n\\u00a0                                      fe_v_subface_neighbor,\\n\\u00a0                                      dof_indices,\\n\\u00a0                                      dof_indices_neighbor,\\n\\u00a0                                      false,\\n\\u00a0                                      numbers::invalid_unsigned_int,\\n\\u00a0                                      cell->face(face_no)->diameter());\\n\\u00a0                 }\\n\\u00a0             }\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nDoFHandler::cell_iteratortypename ActiveSelector::cell_iterator cell_iteratorDefinition dof_handler.h:468\\n ConservationLaw::assemble_cell_term\\nThis function assembles the cell term by computing the cell part of the residual, adding its negative to the right hand side vector, and adding its derivative with respect to the local variables to the Jacobian (i.e. the Newton matrix). Recall that the cell contributions to the residual read  \\\\(R_i = \\\\left(\\\\frac{\\\\mathbf{w}^{k}_{n+1} - \\\\mathbf{w}_n}{\\\\delta t} ,\\n   \\\\mathbf{z}_i \\\\right)_K \\\\)  \\\\( +\\n   \\\\theta \\\\mathbf{B}(\\\\mathbf{w}^{k}_{n+1})(\\\\mathbf{z}_i)_K \\\\)  \\\\( +\\n   (1-\\\\theta) \\\\mathbf{B}(\\\\mathbf{w}_{n}) (\\\\mathbf{z}_i)_K \\\\) where  \\\\(\\\\mathbf{B}(\\\\mathbf{w})(\\\\mathbf{z}_i)_K =\\n   - \\\\left(\\\\mathbf{F}(\\\\mathbf{w}),\\\\nabla\\\\mathbf{z}_i\\\\right)_K \\\\)  \\\\(\\n   + h^{\\\\eta}(\\\\nabla \\\\mathbf{w} , \\\\nabla \\\\mathbf{z}_i)_K \\\\)  \\\\(\\n   - (\\\\mathbf{G}(\\\\mathbf {w}), \\\\mathbf{z}_i)_K \\\\) for both \\\\(\\\\mathbf{w} = \\\\mathbf{w}^k_{n+1}\\\\) and \\\\(\\\\mathbf{w} = \\\\mathbf{w}_{n}\\\\) , \\\\(\\\\mathbf{z}_i\\\\) is the \\\\(i\\\\)th vector valued test function. Furthermore, the scalar product \\\\(\\\\left(\\\\mathbf{F}(\\\\mathbf{w}), \\\\nabla\\\\mathbf{z}_i\\\\right)_K\\\\) is understood as   \\\\(\\\\int_K \\\\sum_{c=1}^{\\\\text{n\\\\_components}}\\n   \\\\sum_{d=1}^{\\\\text{dim}} \\\\mathbf{F}(\\\\mathbf{w})_{cd}\\n   \\\\frac{\\\\partial z^c_i}{x_d}\\\\) where \\\\(z^c_i\\\\) is the \\\\(c\\\\)th component of the \\\\(i\\\\)th test function.\\nAt the top of this function, we do the usual housekeeping in terms of allocating some local variables that we will need later. In particular, we will allocate variables that will hold the values of the current solution \\\\(W_{n+1}^k\\\\) after the \\\\(k\\\\)th Newton iteration (variable W) and the previous time step's solution \\\\(W_{n}\\\\) (variable W_old).\\nIn addition to these, we need the gradients of the current variables. It is a bit of a shame that we have to compute these; we almost don't. The nice thing about a simple conservation law is that the flux doesn't generally involve any gradients. We do need these, however, for the diffusion stabilization.\\nThe actual format in which we store these variables requires some explanation. First, we need values at each quadrature point for each of the EulerEquations::n_components components of the solution vector. This makes for a two-dimensional table for which we use deal.II's Table class (this is more efficient than std::vector<std::vector<T> > because it only needs to allocate memory once, rather than once for each element of the outer vector). Similarly, the gradient is a three-dimensional table, which the Table class also supports.\\nSecondly, we want to use automatic differentiation. To this end, we use the Sacado::Fad::DFad template for everything that is computed from the variables with respect to which we would like to compute derivatives. This includes the current solution and gradient at the quadrature points (which are linear combinations of the degrees of freedom) as well as everything that is computed from them such as the residual, but not the previous time step's solution. These variables are all found in the first part of the function, along with a variable that we will use to store the derivatives of a single component of the residual:\\n\\u00a0   template <int dim>\\n\\u00a0   void ConservationLaw<dim>::assemble_cell_term(\\n\\u00a0     const FEValues<dim>                        &fe_v,\\n\\u00a0     const std::vector<types::global_dof_index> &dof_indices)\\n\\u00a0   {\\n\\u00a0     const unsigned int dofs_per_cell = fe_v.dofs_per_cell;\\n\\u00a0     const unsigned int n_q_points    = fe_v.n_quadrature_points;\\n\\u00a0 \\n\\u00a0     Table<2, Sacado::Fad::DFad<double>> W(n_q_points,\\n\\u00a0                                           EulerEquations<dim>::n_components);\\n\\u00a0 \\n\\u00a0     Table<2, double> W_old(n_q_points, EulerEquations<dim>::n_components);\\n\\u00a0 \\n\\u00a0     Table<3, Sacado::Fad::DFad<double>> grad_W(\\n\\u00a0       n_q_points, EulerEquations<dim>::n_components, dim);\\n\\u00a0 \\n\\u00a0     Table<3, double> grad_W_old(n_q_points,\\n\\u00a0                                 EulerEquations<dim>::n_components,\\n\\u00a0                                 dim);\\n\\u00a0 \\n\\u00a0     std::vector<double> residual_derivatives(dofs_per_cell);\\n\\u00a0 \\nTableDefinition array_view.h:39\\nNext, we have to define the independent variables that we will try to determine by solving a Newton step. These independent variables are the values of the local degrees of freedom which we extract here:\\n\\u00a0     std::vector<Sacado::Fad::DFad<double>> independent_local_dof_values(\\n\\u00a0       dofs_per_cell);\\n\\u00a0     for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0       independent_local_dof_values[i] = current_solution(dof_indices[i]);\\n\\u00a0 \\nThe next step incorporates all the magic: we declare a subset of the autodifferentiation variables as independent degrees of freedom, whereas all the other ones remain dependent functions. These are precisely the local degrees of freedom just extracted. All calculations that reference them (either directly or indirectly) will accumulate sensitivities with respect to these variables.\\nIn order to mark the variables as independent, the following does the trick, marking independent_local_dof_values[i] as the \\\\(i\\\\)th independent variable out of a total of dofs_per_cell:\\n\\u00a0     for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0       independent_local_dof_values[i].diff(i, dofs_per_cell);\\n\\u00a0 \\nAfter all these declarations, let us actually compute something. First, the values of W, W_old, grad_W and grad_W_old, which we can compute from the local DoF values by using the formula \\\\(W(x_q)=\\\\sum_i \\\\mathbf W_i \\\\Phi_i(x_q)\\\\), where \\\\(\\\\mathbf W_i\\\\) is the \\\\(i\\\\)th entry of the (local part of the) solution vector, and \\\\(\\\\Phi_i(x_q)\\\\) the value of the \\\\(i\\\\)th vector-valued shape function evaluated at quadrature point \\\\(x_q\\\\). The gradient can be computed in a similar way.\\nIdeally, we could compute this information using a call into something like FEValues::get_function_values and FEValues::get_function_gradients, but since (i) we would have to extend the FEValues class for this, and (ii) we don't want to make the entire old_solution vector fad types, only the local cell variables, we explicitly code the loop above. Before this, we add another loop that initializes all the fad variables to zero:\\n\\u00a0     for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0       for (unsigned int c = 0; c < EulerEquations<dim>::n_components; ++c)\\n\\u00a0         {\\n\\u00a0           W[q][c]     = 0;\\n\\u00a0           W_old[q][c] = 0;\\n\\u00a0           for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0             {\\n\\u00a0               grad_W[q][c][d]     = 0;\\n\\u00a0               grad_W_old[q][c][d] = 0;\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0     for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0       for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0         {\\n\\u00a0           const unsigned int c =\\n\\u00a0             fe_v.get_fe().system_to_component_index(i).first;\\n\\u00a0 \\n\\u00a0           W[q][c] += independent_local_dof_values[i] *\\n\\u00a0                      fe_v.shape_value_component(i, q, c);\\n\\u00a0           W_old[q][c] +=\\n\\u00a0             old_solution(dof_indices[i]) * fe_v.shape_value_component(i, q, c);\\n\\u00a0 \\n\\u00a0           for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0             {\\n\\u00a0               grad_W[q][c][d] += independent_local_dof_values[i] *\\n\\u00a0                                  fe_v.shape_grad_component(i, q, c)[d];\\n\\u00a0               grad_W_old[q][c][d] += old_solution(dof_indices[i]) *\\n\\u00a0                                      fe_v.shape_grad_component(i, q, c)[d];\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0 \\nNext, in order to compute the cell contributions, we need to evaluate \\\\(\\\\mathbf{F}({\\\\mathbf w}^k_{n+1})\\\\), \\\\(\\\\mathbf{G}({\\\\mathbf w}^k_{n+1})\\\\) and \\\\(\\\\mathbf{F}({\\\\mathbf w}_n)\\\\), \\\\(\\\\mathbf{G}({\\\\mathbf w}_n)\\\\) at all quadrature points. To store these, we also need to allocate a bit of memory. Note that we compute the flux matrices and right hand sides in terms of autodifferentiation variables, so that the Jacobian contributions can later easily be computed from it:\\n\\u00a0     std::vector<ndarray<Sacado::Fad::DFad<double>,\\n\\u00a0                         EulerEquations<dim>::n_components,\\n\\u00a0                         dim>>\\n\\u00a0       flux(n_q_points);\\n\\u00a0 \\n\\u00a0     std::vector<ndarray<double, EulerEquations<dim>::n_components, dim>>\\n\\u00a0       flux_old(n_q_points);\\n\\u00a0 \\n\\u00a0     std::vector<\\n\\u00a0       std::array<Sacado::Fad::DFad<double>, EulerEquations<dim>::n_components>>\\n\\u00a0       forcing(n_q_points);\\n\\u00a0 \\n\\u00a0     std::vector<std::array<double, EulerEquations<dim>::n_components>>\\n\\u00a0       forcing_old(n_q_points);\\n\\u00a0 \\n\\u00a0     for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0       {\\n\\u00a0         EulerEquations<dim>::compute_flux_matrix(W_old[q], flux_old[q]);\\n\\u00a0         EulerEquations<dim>::compute_forcing_vector(W_old[q], forcing_old[q]);\\n\\u00a0         EulerEquations<dim>::compute_flux_matrix(W[q], flux[q]);\\n\\u00a0         EulerEquations<dim>::compute_forcing_vector(W[q], forcing[q]);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0 \\nWe now have all of the pieces in place, so perform the assembly. We have an outer loop through the components of the system, and an inner loop over the quadrature points, where we accumulate contributions to the \\\\(i\\\\)th residual \\\\(R_i\\\\). The general formula for this residual is given in the introduction and at the top of this function. We can, however, simplify it a bit taking into account that the \\\\(i\\\\)th (vector-valued) test function \\\\(\\\\mathbf{z}_i\\\\) has in reality only a single nonzero component (more on this topic can be found in the Handling vector valued problems topic). It will be represented by the variable component_i below. With this, the residual term can be re-written as                   \\n\\\\begin{eqnarray*}\\n   R_i &=&\\n   \\\\left(\\\\frac{(\\\\mathbf{w}_{n+1} -\\n   \\\\mathbf{w}_n)_{\\\\text{component\\\\_i}}}{\\\\delta\\n   t},(\\\\mathbf{z}_i)_{\\\\text{component\\\\_i}}\\\\right)_K\\n   \\\\\\\\ &-& \\\\sum_{d=1}^{\\\\text{dim}} \\\\left(  \\\\theta \\\\mathbf{F}\\n   ({\\\\mathbf{w}^k_{n+1}})_{\\\\text{component\\\\_i},d} + (1-\\\\theta)\\n   \\\\mathbf{F} ({\\\\mathbf{w}_{n}})_{\\\\text{component\\\\_i},d}  ,\\n   \\\\frac{\\\\partial(\\\\mathbf{z}_i)_{\\\\text{component\\\\_i}}} {\\\\partial\\n   x_d}\\\\right)_K\\n   \\\\\\\\ &+& \\\\sum_{d=1}^{\\\\text{dim}} h^{\\\\eta} \\\\left( \\\\theta \\\\frac{\\\\partial\\n   (\\\\mathbf{w}^k_{n+1})_{\\\\text{component\\\\_i}}}{\\\\partial x_d} + (1-\\\\theta)\\n   \\\\frac{\\\\partial (\\\\mathbf{w}_n)_{\\\\text{component\\\\_i}}}{\\\\partial x_d} ,\\n   \\\\frac{\\\\partial (\\\\mathbf{z}_i)_{\\\\text{component\\\\_i}}}{\\\\partial x_d}\\n   \\\\right)_K\\n   \\\\\\\\ &-& \\\\left( \\\\theta\\\\mathbf{G}({\\\\mathbf{w}^k_n+1} )_{\\\\text{component\\\\_i}}\\n   + (1-\\\\theta)\\\\mathbf{G}({\\\\mathbf{w}_n})_{\\\\text{component\\\\_i}} ,\\n   (\\\\mathbf{z}_i)_{\\\\text{component\\\\_i}} \\\\right)_K ,\\n   \\\\end{eqnarray*}\\n\\n where integrals are understood to be evaluated through summation over quadrature points.\\nWe initially sum all contributions of the residual in the positive sense, so that we don't need to negative the Jacobian entries. Then, when we sum into the right_hand_side vector, we negate this residual.\\n\\u00a0     for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)\\n\\u00a0       {\\n\\u00a0         Sacado::Fad::DFad<double> R_i = 0;\\n\\u00a0 \\n\\u00a0         const unsigned int component_i =\\n\\u00a0           fe_v.get_fe().system_to_component_index(i).first;\\n\\u00a0 \\nThe residual for each row (i) will be accumulating into this fad variable. At the end of the assembly for this row, we will query for the sensitivities to this variable and add them into the Jacobian.\\n\\u00a0         for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point)\\n\\u00a0           {\\n\\u00a0             if (parameters.is_stationary == false)\\n\\u00a0               R_i += 1.0 / parameters.time_step *\\n\\u00a0                      (W[point][component_i] - W_old[point][component_i]) *\\n\\u00a0                      fe_v.shape_value_component(i, point, component_i) *\\n\\u00a0                      fe_v.JxW(point);\\n\\u00a0 \\n\\u00a0             for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0               R_i -=\\n\\u00a0                 (parameters.theta * flux[point][component_i][d] +\\n\\u00a0                  (1.0 - parameters.theta) * flux_old[point][component_i][d]) *\\n\\u00a0                 fe_v.shape_grad_component(i, point, component_i)[d] *\\n\\u00a0                 fe_v.JxW(point);\\n\\u00a0 \\n\\u00a0             for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0               R_i +=\\n\\u00a0                 1.0 *\\n\\u00a0                 std::pow(fe_v.get_cell()->diameter(),\\n\\u00a0                          parameters.diffusion_power) *\\n\\u00a0                 (parameters.theta * grad_W[point][component_i][d] +\\n\\u00a0                  (1.0 - parameters.theta) * grad_W_old[point][component_i][d]) *\\n\\u00a0                 fe_v.shape_grad_component(i, point, component_i)[d] *\\n\\u00a0                 fe_v.JxW(point);\\n\\u00a0 \\n\\u00a0             R_i -=\\n\\u00a0               (parameters.theta * forcing[point][component_i] +\\n\\u00a0                (1.0 - parameters.theta) * forcing_old[point][component_i]) *\\n\\u00a0               fe_v.shape_value_component(i, point, component_i) *\\n\\u00a0               fe_v.JxW(point);\\n\\u00a0           }\\n\\u00a0 \\nstd::pow::VectorizedArray< Number, width > pow(const ::VectorizedArray< Number, width > &, const Number p)Definition vectorization.h:6885\\nAt the end of the loop, we have to add the sensitivities to the matrix and subtract the residual from the right hand side. Trilinos FAD data type gives us access to the derivatives using R_i.fastAccessDx(k), so we store the data in a temporary array. This information about the whole row of local dofs is then added to the Trilinos matrix at once (which supports the data types we have chosen).\\n\\u00a0         for (unsigned int k = 0; k < dofs_per_cell; ++k)\\n\\u00a0           residual_derivatives[k] = R_i.fastAccessDx(k);\\n\\u00a0         system_matrix.add(dof_indices[i], dof_indices, residual_derivatives);\\n\\u00a0         right_hand_side(dof_indices[i]) -= R_i.val();\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n ConservationLaw::assemble_face_term\\nHere, we do essentially the same as in the previous function. At the top, we introduce the independent variables. Because the current function is also used if we are working on an internal face between two cells, the independent variables are not only the degrees of freedom on the current cell but in the case of an interior face also the ones on the neighbor.\\n\\u00a0   template <int dim>\\n\\u00a0   void ConservationLaw<dim>::assemble_face_term(\\n\\u00a0     const unsigned int                          face_no,\\n\\u00a0     const FEFaceValuesBase<dim>                &fe_v,\\n\\u00a0     const FEFaceValuesBase<dim>                &fe_v_neighbor,\\n\\u00a0     const std::vector<types::global_dof_index> &dof_indices,\\n\\u00a0     const std::vector<types::global_dof_index> &dof_indices_neighbor,\\n\\u00a0     const bool                                  external_face,\\n\\u00a0     const unsigned int                          boundary_id,\\n\\u00a0     const double                                face_diameter)\\n\\u00a0   {\\n\\u00a0     const unsigned int n_q_points    = fe_v.n_quadrature_points;\\n\\u00a0     const unsigned int dofs_per_cell = fe_v.dofs_per_cell;\\n\\u00a0 \\n\\u00a0     std::vector<Sacado::Fad::DFad<double>> independent_local_dof_values(\\n\\u00a0       dofs_per_cell),\\n\\u00a0       independent_neighbor_dof_values(external_face == false ? dofs_per_cell :\\n\\u00a0                                                                0);\\n\\u00a0 \\n\\u00a0     const unsigned int n_independent_variables =\\n\\u00a0       (external_face == false ? 2 * dofs_per_cell : dofs_per_cell);\\n\\u00a0 \\n\\u00a0     for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0       {\\n\\u00a0         independent_local_dof_values[i] = current_solution(dof_indices[i]);\\n\\u00a0         independent_local_dof_values[i].diff(i, n_independent_variables);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     if (external_face == false)\\n\\u00a0       for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0         {\\n\\u00a0           independent_neighbor_dof_values[i] =\\n\\u00a0             current_solution(dof_indices_neighbor[i]);\\n\\u00a0           independent_neighbor_dof_values[i].diff(i + dofs_per_cell,\\n\\u00a0                                                   n_independent_variables);\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0 \\nNext, we need to define the values of the conservative variables \\\\({\\\\mathbf W}\\\\) on this side of the face ( \\\\( {\\\\mathbf W}^+\\\\)) and on the opposite side ( \\\\({\\\\mathbf W}^-\\\\)), for both  \\\\({\\\\mathbf W} =\\n   {\\\\mathbf W}^k_{n+1}\\\\) and \\\\({\\\\mathbf W} = {\\\\mathbf W}_n\\\\). The \\\"this side\\\" values can be computed in exactly the same way as in the previous function, but note that the fe_v variable now is of type FEFaceValues or FESubfaceValues:\\n\\u00a0     Table<2, Sacado::Fad::DFad<double>> Wplus(\\n\\u00a0       n_q_points, EulerEquations<dim>::n_components),\\n\\u00a0       Wminus(n_q_points, EulerEquations<dim>::n_components);\\n\\u00a0     Table<2, double> Wplus_old(n_q_points, EulerEquations<dim>::n_components),\\n\\u00a0       Wminus_old(n_q_points, EulerEquations<dim>::n_components);\\n\\u00a0 \\n\\u00a0     for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0       for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0         {\\n\\u00a0           const unsigned int component_i =\\n\\u00a0             fe_v.get_fe().system_to_component_index(i).first;\\n\\u00a0           Wplus[q][component_i] +=\\n\\u00a0             independent_local_dof_values[i] *\\n\\u00a0             fe_v.shape_value_component(i, q, component_i);\\n\\u00a0           Wplus_old[q][component_i] +=\\n\\u00a0             old_solution(dof_indices[i]) *\\n\\u00a0             fe_v.shape_value_component(i, q, component_i);\\n\\u00a0         }\\n\\u00a0 \\nComputing \\\"opposite side\\\" is a bit more complicated. If this is an internal face, we can compute it as above by simply using the independent variables from the neighbor:\\n\\u00a0     if (external_face == false)\\n\\u00a0       {\\n\\u00a0         for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0           for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0             {\\n\\u00a0               const unsigned int component_i =\\n\\u00a0                 fe_v_neighbor.get_fe().system_to_component_index(i).first;\\n\\u00a0               Wminus[q][component_i] +=\\n\\u00a0                 independent_neighbor_dof_values[i] *\\n\\u00a0                 fe_v_neighbor.shape_value_component(i, q, component_i);\\n\\u00a0               Wminus_old[q][component_i] +=\\n\\u00a0                 old_solution(dof_indices_neighbor[i]) *\\n\\u00a0                 fe_v_neighbor.shape_value_component(i, q, component_i);\\n\\u00a0             }\\n\\u00a0       }\\nOn the other hand, if this is an external boundary face, then the values of \\\\(\\\\mathbf{W}^-\\\\) will be either functions of \\\\(\\\\mathbf{W}^+\\\\), or they will be prescribed, depending on the kind of boundary condition imposed here.\\nTo start the evaluation, let us ensure that the boundary id specified for this boundary is one for which we actually have data in the parameters object. Next, we evaluate the function object for the inhomogeneity. This is a bit tricky: a given boundary might have both prescribed and implicit values. If a particular component is not prescribed, the values evaluate to zero and are ignored below.\\nThe rest is done by a function that actually knows the specifics of Euler equation boundary conditions. Note that since we are using fad variables here, sensitivities will be updated appropriately, a process that would otherwise be tremendously complicated.\\n\\u00a0     else\\n\\u00a0       {\\n\\u00a0         Assert(boundary_id < Parameters::AllParameters<dim>::max_n_boundaries,\\n\\u00a0                ExcIndexRange(boundary_id,\\n\\u00a0                              0,\\n\\u00a0                              Parameters::AllParameters<dim>::max_n_boundaries));\\n\\u00a0 \\n\\u00a0         std::vector<Vector<double>> boundary_values(\\n\\u00a0           n_q_points, Vector<double>(EulerEquations<dim>::n_components));\\n\\u00a0         parameters.boundary_conditions[boundary_id].values.vector_value_list(\\n\\u00a0           fe_v.get_quadrature_points(), boundary_values);\\n\\u00a0 \\n\\u00a0         for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0           {\\n\\u00a0             EulerEquations<dim>::compute_Wminus(\\n\\u00a0               parameters.boundary_conditions[boundary_id].kind,\\n\\u00a0               fe_v.normal_vector(q),\\n\\u00a0               Wplus[q],\\n\\u00a0               boundary_values[q],\\n\\u00a0               Wminus[q]);\\nHere we assume that boundary type, boundary normal vector and boundary data values maintain the same during time advancing.\\n\\u00a0             EulerEquations<dim>::compute_Wminus(\\n\\u00a0               parameters.boundary_conditions[boundary_id].kind,\\n\\u00a0               fe_v.normal_vector(q),\\n\\u00a0               Wplus_old[q],\\n\\u00a0               boundary_values[q],\\n\\u00a0               Wminus_old[q]);\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0 \\nNow that we have \\\\(\\\\mathbf w^+\\\\) and \\\\(\\\\mathbf w^-\\\\), we can go about computing the numerical flux function  \\\\(\\\\mathbf H(\\\\mathbf w^+,\\\\mathbf\\n   w^-, \\\\mathbf n)\\\\) for each quadrature point. Before calling the function that does so, we also need to determine the Lax-Friedrich's stability parameter:\\n\\u00a0     std::vector<\\n\\u00a0       std::array<Sacado::Fad::DFad<double>, EulerEquations<dim>::n_components>>\\n\\u00a0       normal_fluxes(n_q_points);\\n\\u00a0     std::vector<std::array<double, EulerEquations<dim>::n_components>>\\n\\u00a0       normal_fluxes_old(n_q_points);\\n\\u00a0 \\n\\u00a0     double alpha;\\n\\u00a0 \\n\\u00a0     switch (parameters.stabilization_kind)\\n\\u00a0       {\\n\\u00a0         case Parameters::Flux::constant:\\n\\u00a0           alpha = parameters.stabilization_value;\\n\\u00a0           break;\\n\\u00a0         case Parameters::Flux::mesh_dependent:\\n\\u00a0           alpha = face_diameter / (2.0 * parameters.time_step);\\n\\u00a0           break;\\n\\u00a0         default:\\n\\u00a0           DEAL_II_NOT_IMPLEMENTED();\\n\\u00a0           alpha = 1;\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0       {\\n\\u00a0         EulerEquations<dim>::numerical_normal_flux(\\n\\u00a0           fe_v.normal_vector(q), Wplus[q], Wminus[q], alpha, normal_fluxes[q]);\\n\\u00a0         EulerEquations<dim>::numerical_normal_flux(fe_v.normal_vector(q),\\n\\u00a0                                                    Wplus_old[q],\\n\\u00a0                                                    Wminus_old[q],\\n\\u00a0                                                    alpha,\\n\\u00a0                                                    normal_fluxes_old[q]);\\n\\u00a0       }\\n\\u00a0 \\nNow assemble the face term in exactly the same way as for the cell contributions in the previous function. The only difference is that if this is an internal face, we also have to take into account the sensitivities of the residual contributions to the degrees of freedom on the neighboring cell:\\n\\u00a0     std::vector<double> residual_derivatives(dofs_per_cell);\\n\\u00a0     for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)\\n\\u00a0       if (fe_v.get_fe().has_support_on_face(i, face_no) == true)\\n\\u00a0         {\\n\\u00a0           Sacado::Fad::DFad<double> R_i = 0;\\n\\u00a0 \\n\\u00a0           for (unsigned int point = 0; point < n_q_points; ++point)\\n\\u00a0             {\\n\\u00a0               const unsigned int component_i =\\n\\u00a0                 fe_v.get_fe().system_to_component_index(i).first;\\n\\u00a0 \\n\\u00a0               R_i += (parameters.theta * normal_fluxes[point][component_i] +\\n\\u00a0                       (1.0 - parameters.theta) *\\n\\u00a0                         normal_fluxes_old[point][component_i]) *\\n\\u00a0                      fe_v.shape_value_component(i, point, component_i) *\\n\\u00a0                      fe_v.JxW(point);\\n\\u00a0             }\\n\\u00a0 \\n\\u00a0           for (unsigned int k = 0; k < dofs_per_cell; ++k)\\n\\u00a0             residual_derivatives[k] = R_i.fastAccessDx(k);\\n\\u00a0           system_matrix.add(dof_indices[i], dof_indices, residual_derivatives);\\n\\u00a0 \\n\\u00a0           if (external_face == false)\\n\\u00a0             {\\n\\u00a0               for (unsigned int k = 0; k < dofs_per_cell; ++k)\\n\\u00a0                 residual_derivatives[k] = R_i.fastAccessDx(dofs_per_cell + k);\\n\\u00a0               system_matrix.add(dof_indices[i],\\n\\u00a0                                 dof_indices_neighbor,\\n\\u00a0                                 residual_derivatives);\\n\\u00a0             }\\n\\u00a0 \\n\\u00a0           right_hand_side(dof_indices[i]) -= R_i.val();\\n\\u00a0         }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n ConservationLaw::solve\\nHere, we actually solve the linear system, using either of Trilinos' Aztec or Amesos linear solvers. The result of the computation will be written into the argument vector passed to this function. The result is a pair of number of iterations and the final linear residual.\\n\\u00a0   template <int dim>\\n\\u00a0   std::pair<unsigned int, double>\\n\\u00a0   ConservationLaw<dim>::solve(Vector<double> &newton_update)\\n\\u00a0   {\\n\\u00a0     switch (parameters.solver)\\n\\u00a0       {\\nIf the parameter file specified that a direct solver shall be used, then we'll get here. The process is straightforward, since deal.II provides a wrapper class to the Amesos direct solver within Trilinos. All we have to do is to create a solver control object (which is just a dummy object here, since we won't perform any iterations), and then create the direct solver object. When actually doing the solve, note that we don't pass a preconditioner. That wouldn't make much sense for a direct solver anyway. At the end we return the solver control statistics \\u2014 which will tell that no iterations have been performed and that the final linear residual is zero, absent any better information that may be provided here:\\n\\u00a0         case Parameters::Solver::direct:\\n\\u00a0           {\\n\\u00a0             SolverControl                                  solver_control(1, 0);\\n\\u00a0             TrilinosWrappers::SolverDirect::AdditionalData data(\\n\\u00a0               parameters.output == Parameters::Solver::verbose);\\n\\u00a0             TrilinosWrappers::SolverDirect direct(solver_control, data);\\n\\u00a0 \\n\\u00a0             direct.solve(system_matrix, newton_update, right_hand_side);\\n\\u00a0 \\n\\u00a0             return {solver_control.last_step(), solver_control.last_value()};\\n\\u00a0           }\\n\\u00a0 \\nSolverControlDefinition solver_control.h:67\\nTrilinosWrappers::SolverDirectDefinition trilinos_solver.h:486\\nTrilinosWrappers::SolverDirect::AdditionalDataDefinition trilinos_solver.h:493\\nLikewise, if we are to use an iterative solver, we use Aztec's GMRES solver. We could use the Trilinos wrapper classes for iterative solvers and preconditioners here as well, but we choose to use an Aztec solver directly. For the given problem, Aztec's internal preconditioner implementations are superior over the ones deal.II has wrapper classes to, so we use ILU-T preconditioning within the AztecOO solver and set a bunch of options that can be changed from the parameter file.\\nThere are two more practicalities: Since we have built our right hand side and solution vector as deal.II Vector objects (as opposed to the matrix, which is a Trilinos object), we must hand the solvers Trilinos Epetra vectors. Luckily, they support the concept of a 'view', so we just send in a pointer to our deal.II vectors. We have to provide an Epetra_Map for the vector that sets the parallel distribution, which is just a dummy object in serial. The easiest way is to ask the matrix for its map, and we're going to be ready for matrix-vector products with it.\\nSecondly, the Aztec solver wants us to pass a Trilinos Epetra_CrsMatrix in, not the deal.II wrapper class itself. So we access to the actual Trilinos matrix in the Trilinos wrapper class by the command trilinos_matrix(). Trilinos wants the matrix to be non-constant, so we have to manually remove the constantness using a const_cast.\\n\\u00a0         case Parameters::Solver::gmres:\\n\\u00a0           {\\n\\u00a0             Epetra_Vector x(View,\\n\\u00a0                             system_matrix.trilinos_matrix().DomainMap(),\\n\\u00a0                             newton_update.begin());\\n\\u00a0             Epetra_Vector b(View,\\n\\u00a0                             system_matrix.trilinos_matrix().RangeMap(),\\n\\u00a0                             right_hand_side.begin());\\n\\u00a0 \\n\\u00a0             AztecOO solver;\\n\\u00a0             solver.SetAztecOption(\\n\\u00a0               AZ_output,\\n\\u00a0               (parameters.output == Parameters::Solver::quiet ? AZ_none :\\n\\u00a0                                                                 AZ_all));\\n\\u00a0             solver.SetAztecOption(AZ_solver, AZ_gmres);\\n\\u00a0             solver.SetRHS(&b);\\n\\u00a0             solver.SetLHS(&x);\\n\\u00a0 \\n\\u00a0             solver.SetAztecOption(AZ_precond, AZ_dom_decomp);\\n\\u00a0             solver.SetAztecOption(AZ_subdomain_solve, AZ_ilut);\\n\\u00a0             solver.SetAztecOption(AZ_overlap, 0);\\n\\u00a0             solver.SetAztecOption(AZ_reorder, 0);\\n\\u00a0 \\n\\u00a0             solver.SetAztecParam(AZ_drop, parameters.ilut_drop);\\n\\u00a0             solver.SetAztecParam(AZ_ilut_fill, parameters.ilut_fill);\\n\\u00a0             solver.SetAztecParam(AZ_athresh, parameters.ilut_atol);\\n\\u00a0             solver.SetAztecParam(AZ_rthresh, parameters.ilut_rtol);\\n\\u00a0 \\n\\u00a0             solver.SetUserMatrix(\\n\\u00a0               const_cast<Epetra_CrsMatrix *>(&system_matrix.trilinos_matrix()));\\n\\u00a0 \\n\\u00a0             solver.Iterate(parameters.max_iterations,\\n\\u00a0                            parameters.linear_residual);\\n\\u00a0 \\n\\u00a0             return {solver.NumIters(), solver.TrueResidual()};\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     DEAL_II_NOT_IMPLEMENTED();\\n\\u00a0     return {0, 0};\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nVector::beginiterator begin()\\n ConservationLaw::compute_refinement_indicators\\nThis function is real simple: We don't pretend that we know here what a good refinement indicator would be. Rather, we assume that the EulerEquation class would know about this, and so we simply defer to the respective function we've implemented there:\\n\\u00a0   template <int dim>\\n\\u00a0   void ConservationLaw<dim>::compute_refinement_indicators(\\n\\u00a0     Vector<double> &refinement_indicators) const\\n\\u00a0   {\\n\\u00a0     EulerEquations<dim>::compute_refinement_indicators(dof_handler,\\n\\u00a0                                                        mapping,\\n\\u00a0                                                        predictor,\\n\\u00a0                                                        refinement_indicators);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n ConservationLaw::refine_grid\\nHere, we use the refinement indicators computed before and refine the mesh. At the beginning, we loop over all cells and mark those that we think should be refined:\\n\\u00a0   template <int dim>\\n\\u00a0   void\\n\\u00a0   ConservationLaw<dim>::refine_grid(const Vector<double> &refinement_indicators)\\n\\u00a0   {\\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         const unsigned int cell_no = cell->active_cell_index();\\n\\u00a0         cell->clear_coarsen_flag();\\n\\u00a0         cell->clear_refine_flag();\\n\\u00a0 \\n\\u00a0         if ((cell->level() < parameters.shock_levels) &&\\n\\u00a0             (std::fabs(refinement_indicators(cell_no)) > parameters.shock_val))\\n\\u00a0           cell->set_refine_flag();\\n\\u00a0         else if ((cell->level() > 0) &&\\n\\u00a0                  (std::fabs(refinement_indicators(cell_no)) <\\n\\u00a0                   0.75 * parameters.shock_val))\\n\\u00a0           cell->set_coarsen_flag();\\n\\u00a0       }\\n\\u00a0 \\nThe next step addresses a problem mentioned in a remark in the introduction: The SolutionTransfer class we want to use later on tests the assumption that the solution function is continuous at hanging nodes. This is not actually the case in this program because we chose (perhaps unwisely) to enforce hanging node constraints in a weak way, as one would for example do with discontinuous elements. But the elements we use here are continuous (namely, multiple copies of FE_Q), and so the assertion would fail and the program abort. To avoid the issue (without having to rewrite the whole program), we simply ensure that the solution does satisfy the hanging node constraints, but creating an AffineConstraint object that contains the hanging node constraints and applying the constraints to the two solution vectors we want the SolutionTransfer class to transfer to the next mesh:\\n\\u00a0     {\\n\\u00a0       AffineConstraints<double> hanging_node_constraints;\\n\\u00a0       DoFTools::make_hanging_node_constraints(dof_handler,\\n\\u00a0                                               hanging_node_constraints);\\n\\u00a0       hanging_node_constraints.close();\\n\\u00a0 \\n\\u00a0       hanging_node_constraints.distribute(old_solution);\\n\\u00a0       hanging_node_constraints.distribute(predictor);\\n\\u00a0     }\\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nDoFTools::make_hanging_node_constraintsvoid make_hanging_node_constraints(const DoFHandler< dim, spacedim > &dof_handler, AffineConstraints< number > &constraints)Definition dof_tools_constraints.cc:3073\\nThen we need to transfer the various solution vectors from the old to the new grid while we do the refinement. The SolutionTransfer class is our friend here; it has a fairly extensive documentation, including examples, so we won't comment much on the following code. The last three lines simply re-set the sizes of some other vectors to the now correct size:\\n\\u00a0     const std::vector<Vector<double>> transfer_in = {old_solution, predictor};\\n\\u00a0 \\n\\u00a0     triangulation.prepare_coarsening_and_refinement();\\n\\u00a0 \\n\\u00a0     SolutionTransfer<dim> soltrans(dof_handler);\\n\\u00a0     soltrans.prepare_for_coarsening_and_refinement(transfer_in);\\n\\u00a0 \\n\\u00a0     triangulation.execute_coarsening_and_refinement();\\n\\u00a0 \\n\\u00a0     dof_handler.clear();\\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0 \\n\\u00a0     std::vector<Vector<double>> transfer_out = {\\n\\u00a0       Vector<double>(dof_handler.n_dofs()),\\n\\u00a0       Vector<double>(dof_handler.n_dofs())};\\n\\u00a0     soltrans.interpolate(transfer_in, transfer_out);\\n\\u00a0 \\n\\u00a0     old_solution = std::move(transfer_out[0]);\\n\\u00a0     predictor    = std::move(transfer_out[1]);\\n\\u00a0 \\n\\u00a0     current_solution.reinit(dof_handler.n_dofs());\\n\\u00a0     current_solution = old_solution;\\n\\u00a0 \\n\\u00a0     right_hand_side.reinit(dof_handler.n_dofs());\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nDoFHandler::distribute_dofsvoid distribute_dofs(const FiniteElement< dim, spacedim > &fe)\\nDoFHandler::clearvoid clear()\\nSolutionTransferDefinition solution_transfer.h:337\\nparallel::distributed::Triangulation::execute_coarsening_and_refinementvirtual void execute_coarsening_and_refinement() overrideDefinition tria.cc:3320\\nparallel::distributed::Triangulation::prepare_coarsening_and_refinementvirtual bool prepare_coarsening_and_refinement() overrideDefinition tria.cc:2805\\n ConservationLaw::output_results\\nThis function now is rather straightforward. All the magic, including transforming data from conservative variables to physical ones has been abstracted and moved into the EulerEquations class so that it can be replaced in case we want to solve some other hyperbolic conservation law.\\nNote that the number of the output file is determined by keeping a counter in the form of a static variable that is set to zero the first time we come to this function and is incremented by one at the end of each invocation.\\n\\u00a0   template <int dim>\\n\\u00a0   void ConservationLaw<dim>::output_results() const\\n\\u00a0   {\\n\\u00a0     typename EulerEquations<dim>::Postprocessor postprocessor(\\n\\u00a0       parameters.schlieren_plot);\\n\\u00a0 \\n\\u00a0     DataOut<dim> data_out;\\n\\u00a0     data_out.attach_dof_handler(dof_handler);\\n\\u00a0 \\n\\u00a0     data_out.add_data_vector(current_solution,\\n\\u00a0                              EulerEquations<dim>::component_names(),\\n\\u00a0                              DataOut<dim>::type_dof_data,\\n\\u00a0                              EulerEquations<dim>::component_interpretation());\\n\\u00a0 \\n\\u00a0     data_out.add_data_vector(current_solution, postprocessor);\\n\\u00a0 \\n\\u00a0     data_out.build_patches();\\n\\u00a0 \\n\\u00a0     static unsigned int output_file_number = 0;\\n\\u00a0     std::string         filename =\\n\\u00a0       \\\"solution-\\\" + Utilities::int_to_string(output_file_number, 3) + \\\".vtk\\\";\\n\\u00a0     std::ofstream output(filename);\\n\\u00a0     data_out.write_vtk(output);\\n\\u00a0 \\n\\u00a0     ++output_file_number;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\n ConservationLaw::run\\nThis function contains the top-level logic of this program: initialization, the time loop, and the inner Newton iteration.\\nAt the beginning, we read the mesh file specified by the parameter file, setup the DoFHandler and various vectors, and then interpolate the given initial conditions on this mesh. We then perform a number of mesh refinements, based on the initial conditions, to obtain a mesh that is already well adapted to the starting solution. At the end of this process, we output the initial solution.\\n\\u00a0   template <int dim>\\n\\u00a0   void ConservationLaw<dim>::run()\\n\\u00a0   {\\n\\u00a0     {\\n\\u00a0       GridIn<dim> grid_in;\\n\\u00a0       grid_in.attach_triangulation(triangulation);\\n\\u00a0 \\n\\u00a0       std::ifstream input_file(parameters.mesh_filename);\\n\\u00a0       Assert(input_file, ExcFileNotOpen(parameters.mesh_filename));\\n\\u00a0 \\n\\u00a0       grid_in.read_ucd(input_file);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0 \\nGridInDefinition grid_in.h:311\\nGridIn::attach_triangulationvoid attach_triangulation(Triangulation< dim, spacedim > &tria)Definition grid_in.cc:153\\nSize all of the fields.\\n\\u00a0     old_solution.reinit(dof_handler.n_dofs());\\n\\u00a0     current_solution.reinit(dof_handler.n_dofs());\\n\\u00a0     predictor.reinit(dof_handler.n_dofs());\\n\\u00a0     right_hand_side.reinit(dof_handler.n_dofs());\\n\\u00a0 \\n\\u00a0     setup_system();\\n\\u00a0 \\n\\u00a0     VectorTools::interpolate(dof_handler,\\n\\u00a0                              parameters.initial_conditions,\\n\\u00a0                              old_solution);\\n\\u00a0     current_solution = old_solution;\\n\\u00a0     predictor        = old_solution;\\n\\u00a0 \\n\\u00a0     if (parameters.do_refine == true)\\n\\u00a0       for (unsigned int i = 0; i < parameters.shock_levels; ++i)\\n\\u00a0         {\\n\\u00a0           Vector<double> refinement_indicators(triangulation.n_active_cells());\\n\\u00a0 \\n\\u00a0           compute_refinement_indicators(refinement_indicators);\\n\\u00a0           refine_grid(refinement_indicators);\\n\\u00a0 \\n\\u00a0           setup_system();\\n\\u00a0 \\n\\u00a0           VectorTools::interpolate(dof_handler,\\n\\u00a0                                    parameters.initial_conditions,\\n\\u00a0                                    old_solution);\\n\\u00a0           current_solution = old_solution;\\n\\u00a0           predictor        = old_solution;\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0     output_results();\\n\\u00a0 \\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nVectorTools::interpolatevoid interpolate(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const Function< spacedim, typename VectorType::value_type > &function, VectorType &vec, const ComponentMask &component_mask={})\\nWe then enter into the main time stepping loop. At the top we simply output some status information so one can keep track of where a computation is, as well as the header for a table that indicates progress of the nonlinear inner iteration:\\n\\u00a0     Vector<double> newton_update(dof_handler.n_dofs());\\n\\u00a0 \\n\\u00a0     double time        = 0;\\n\\u00a0     double next_output = time + parameters.output_step;\\n\\u00a0 \\n\\u00a0     predictor = old_solution;\\n\\u00a0     while (time < parameters.final_time)\\n\\u00a0       {\\n\\u00a0         std::cout << \\\"T=\\\" << time << std::endl\\n\\u00a0                   << \\\"   Number of active cells:       \\\"\\n\\u00a0                   << triangulation.n_active_cells() << std::endl\\n\\u00a0                   << \\\"   Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n\\u00a0                   << std::endl\\n\\u00a0                   << std::endl;\\n\\u00a0 \\n\\u00a0         std::cout << \\\"   NonLin Res     Lin Iter       Lin Res\\\" << std::endl\\n\\u00a0                   << \\\"   _____________________________________\\\" << std::endl;\\n\\u00a0 \\nThen comes the inner Newton iteration to solve the nonlinear problem in each time step. The way it works is to reset matrix and right hand side to zero, then assemble the linear system. If the norm of the right hand side is small enough, then we declare that the Newton iteration has converged. Otherwise, we solve the linear system, update the current solution with the Newton increment, and output convergence information. At the end, we check that the number of Newton iterations is not beyond a limit of 10 \\u2013 if it is, it appears likely that iterations are diverging and further iterations would do no good. If that happens, we throw an exception that will be caught in main() with status information being displayed before the program aborts.\\nNote that the way we write the AssertThrow macro below is by and large equivalent to writing something like if (!(nonlin_iter <= 10)) throw ExcMessage (\\\"No convergence in nonlinear\\n   solver\\\");. The only significant difference is that AssertThrow also makes sure that the exception being thrown carries with it information about the location (file name and line number) where it was generated. This is not overly critical here, because there is only a single place where this sort of exception can happen; however, it is generally a very useful tool when one wants to find out where an error occurred.\\n\\u00a0         unsigned int nonlin_iter = 0;\\n\\u00a0         current_solution         = predictor;\\n\\u00a0         while (true)\\n\\u00a0           {\\n\\u00a0             system_matrix = 0;\\n\\u00a0 \\n\\u00a0             right_hand_side = 0;\\n\\u00a0             assemble_system();\\n\\u00a0 \\n\\u00a0             const double res_norm = right_hand_side.l2_norm();\\n\\u00a0             if (std::fabs(res_norm) < 1e-10)\\n\\u00a0               {\\n\\u00a0                 std::printf(\\\"   %-16.3e (converged)\\\\n\\\\n\\\", res_norm);\\n\\u00a0                 break;\\n\\u00a0               }\\n\\u00a0             else\\n\\u00a0               {\\n\\u00a0                 newton_update = 0;\\n\\u00a0 \\n\\u00a0                 std::pair<unsigned int, double> convergence =\\n\\u00a0                   solve(newton_update);\\n\\u00a0 \\n\\u00a0                 current_solution += newton_update;\\n\\u00a0 \\n\\u00a0                 std::printf(\\\"   %-16.3e %04d        %-5.2e\\\\n\\\",\\n\\u00a0                             res_norm,\\n\\u00a0                             convergence.first,\\n\\u00a0                             convergence.second);\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0             ++nonlin_iter;\\n\\u00a0             AssertThrow(nonlin_iter <= 10,\\n\\u00a0                         ExcMessage(\\\"No convergence in nonlinear solver\\\"));\\n\\u00a0           }\\n\\u00a0 \\nWe only get to this point if the Newton iteration has converged, so do various post convergence tasks here:\\nFirst, we update the time and produce graphical output if so desired. Then we update a predictor for the solution at the next time step by approximating    \\\\(\\\\mathbf w^{n+1}\\\\approx \\\\mathbf w^n +\\n   \\\\delta t \\\\frac{\\\\partial \\\\mathbf w}{\\\\partial t} \\\\approx \\\\mathbf w^n\\n   + \\\\delta t \\\\; \\\\frac{\\\\mathbf w^n-\\\\mathbf w^{n-1}}{\\\\delta t} = 2\\n   \\\\mathbf w^n - \\\\mathbf w^{n-1}\\\\) to try and make adaptivity work better. The idea is to try and refine ahead of a front, rather than stepping into a coarse set of elements and smearing the old_solution. This simple time extrapolator does the job. With this, we then refine the mesh if so desired by the user, and finally continue on with the next time step:\\n\\u00a0         time += parameters.time_step;\\n\\u00a0 \\n\\u00a0         if (parameters.output_step < 0)\\n\\u00a0           output_results();\\n\\u00a0         else if (time >= next_output)\\n\\u00a0           {\\n\\u00a0             output_results();\\n\\u00a0             next_output += parameters.output_step;\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         predictor = current_solution;\\n\\u00a0         predictor.sadd(2.0, -1.0, old_solution);\\n\\u00a0 \\n\\u00a0         old_solution = current_solution;\\n\\u00a0 \\n\\u00a0         if (parameters.do_refine == true)\\n\\u00a0           {\\n\\u00a0             Vector<double> refinement_indicators(\\n\\u00a0               triangulation.n_active_cells());\\n\\u00a0             compute_refinement_indicators(refinement_indicators);\\n\\u00a0 \\n\\u00a0             refine_grid(refinement_indicators);\\n\\u00a0             setup_system();\\n\\u00a0 \\n\\u00a0             newton_update.reinit(dof_handler.n_dofs());\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 } // namespace Step33\\n\\u00a0 \\nVector::reinitvirtual void reinit(const size_type N, const bool omit_zeroing_entries=false)\\n main()\\nThe following `\\u2018main\\u2019' function is similar to previous examples and need not to be commented on. Note that the program aborts if no input file name is given on the command line.\\n\\u00a0 int main(int argc, char *argv[])\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       using namespace dealii;\\n\\u00a0       using namespace Step33;\\n\\u00a0 \\n\\u00a0       if (argc != 2)\\n\\u00a0         {\\n\\u00a0           std::cout << \\\"Usage:\\\" << argv[0] << \\\" input_file\\\" << std::endl;\\n\\u00a0           std::exit(1);\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0       Utilities::MPI::MPI_InitFinalize mpi_initialization(\\n\\u00a0         argc, argv, numbers::invalid_unsigned_int);\\n\\u00a0 \\n\\u00a0       AssertThrow(\\n\\u00a0         Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) == 1,\\n\\u00a0         ExcMessage(\\n\\u00a0           \\\"This program does not support parallel computing via MPI.\\\"));\\n\\u00a0 \\n\\u00a0       ConservationLaw<2> cons(argv[1]);\\n\\u00a0       cons.run();\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\nUtilities::MPI::MPI_InitFinalizeDefinition mpi.h:1081\\nUtilities::MPI::n_mpi_processesunsigned int n_mpi_processes(const MPI_Comm mpi_communicator)Definition mpi.cc:92\\n Results\\nWe run the problem with the mesh slide.inp (this file is in the same directory as the source code for this program) and the following input deck (available as input.prm in the same directory): # Listing of Parameters\\n# ---------------------\\n\\n# The input grid\\nset mesh = slide.inp\\n\\n# Stabilization parameter\\nset diffusion power = 2.0\\n\\n# --------------------------------------------------\\n# Boundary conditions\\n# We may specify boundary conditions for up to MAX_BD boundaries.\\n# Your .inp file should have these boundaries designated.\\nsubsection boundary_1\\n  set no penetration = true # reflective boundary condition\\nend\\n\\nsubsection boundary_2\\n  # outflow boundary\\n  # set w_2 = pressure\\n  # set w_2 value = 1.5 - y\\nend\\n\\nsubsection boundary_3\\n  set no penetration = true # reflective\\n  # set w_3 = pressure\\n  # set w_3 value = 1.0\\nend\\n\\nsubsection boundary_4\\n  set no penetration = true #reflective\\nend\\n\\n# --------------------------------------------------\\n# Initial Conditions\\n# We set the initial conditions of the conservative variables.  These lines\\n# are passed to the expression parsing function.  You should use x,y,z for\\n# the coordinate variables.\\n\\nsubsection initial condition\\n  set w_0 value = 0\\n  set w_1 value = 0\\n  set w_2 value = 10*(x<-0.7)*(y> 0.3)*(y< 0.45) + (1-(x<-0.7)*(y> 0.3)*(y< 0.45))*1.0\\n  set w_3 value = (1.5-(1.0*1.0*y))/0.4\\nend\\n\\n# --------------------------------------------------\\n# Time stepping control\\nsubsection time stepping\\n  set final time = 10.0 # simulation end time\\n  set time step  = 0.02 # simulation time step\\n  set theta scheme value = 0.5\\nend\\n\\nsubsection linear solver\\n  set output         = quiet\\n  set method         = gmres\\n  set ilut fill      = 1.5\\n  set ilut drop tolerance = 1e-6\\n  set ilut absolute tolerance = 1e-6\\n  set ilut relative tolerance = 1.0\\nend\\n\\n# --------------------------------------------------\\n# Output frequency and kind\\nsubsection output\\n  set step           = 0.01\\n  set schlieren plot = true\\nend\\n\\n# --------------------------------------------------\\n# Refinement control\\nsubsection refinement\\n  set refinement = true # none only other option\\n  set shock value = 1.5\\n  set shock levels = 1 # how many levels of refinement to allow\\nend\\n\\n# --------------------------------------------------\\n# Flux parameters\\nsubsection flux\\n set stab = constant\\n #set stab value = 1.0\\nend\\nWhen we run the program, we get the following kind of output: ...\\nT=0.14\\n   Number of active cells:       1807\\n   Number of degrees of freedom: 7696\\n\\n   NonLin Res     Lin Iter       Lin Res\\n   _____________________________________\\n   7.015e-03        0008        3.39e-13\\n   2.150e-05        0008        1.56e-15\\n   2.628e-09        0008        5.09e-20\\n   5.243e-16        (converged)\\n\\nT=0.16\\n   Number of active cells:       1807\\n   Number of degrees of freedom: 7696\\n\\n   NonLin Res     Lin Iter       Lin Res\\n   _____________________________________\\n   7.145e-03        0008        3.80e-13\\n   2.548e-05        0008        7.20e-16\\n   4.063e-09        0008        2.49e-19\\n   5.970e-16        (converged)\\n\\nT=0.18\\n   Number of active cells:       1807\\n   Number of degrees of freedom: 7696\\n\\n   NonLin Res     Lin Iter       Lin Res\\n   _____________________________________\\n   7.395e-03        0008        6.69e-13\\n   2.867e-05        0008        1.33e-15\\n   4.091e-09        0008        3.35e-19\\n   5.617e-16        (converged)\\n...\\nThis output reports the progress of the Newton iterations and the time stepping. Note that our implementation of the Newton iteration indeed shows the expected quadratic convergence order: the norm of the nonlinear residual in each step is roughly the norm of the previous step squared. This leads to the very rapid convergence we can see here. This holds until times up to \\\\(t=1.9\\\\) at which time the nonlinear iteration reports a lack of convergence: ...\\n\\nT=1.88\\n   Number of active cells:       2119\\n   Number of degrees of freedom: 9096\\n\\n   NonLin Res     Lin Iter       Lin Res\\n   _____________________________________\\n   2.251e-01        0012        9.78e-12\\n   5.698e-03        0012        2.04e-13\\n   3.896e-05        0012        1.48e-15\\n   3.915e-09        0012        1.94e-19\\n   8.800e-16        (converged)\\n\\nT=1.9\\n   Number of active cells:       2140\\n   Number of degrees of freedom: 9184\\n\\n   NonLin Res     Lin Iter       Lin Res\\n   _____________________________________\\n   2.320e-01        0013        3.94e-12\\n   1.235e-01        0016        6.62e-12\\n   8.494e-02        0016        6.05e-12\\n   1.199e+01        0026        5.72e-10\\n   1.198e+03        0002        1.20e+03\\n   7.030e+03        0001        nan\\n   7.030e+03        0001        nan\\n   7.030e+03        0001        nan\\n   7.030e+03        0001        nan\\n   7.030e+03        0001        nan\\n   7.030e+03        0001        nan\\n\\n\\n----------------------------------------------------\\nException on processing:\\n\\n--------------------------------------------------------\\nAn error occurred in line <2476> of file <step-33.cc> in function\\n    void Step33::ConservationLaw<dim>::run() [with int dim = 2]\\nThe violated condition was:\\n    nonlin_iter <= 10\\nThe name and call sequence of the exception was:\\n    ExcMessage (\\\"No convergence in nonlinear solver\\\")\\nAdditional Information:\\nNo convergence in nonlinear solver\\n--------------------------------------------------------\\n\\nAborting!\\n----------------------------------------------------\\nWe may find out the cause and possible remedies by looking at the animation of the solution.\\nThe result of running these computations is a bunch of output files that we can pass to our visualization program of choice. When we collate them into a movie, the results of last several time steps looks like this:\\n\\nAs we see, when the heavy mass of fluid hits the left bottom corner, some oscillation occurs and lead to the divergence of the iteration. A lazy solution to this issue is add more viscosity. If we set the diffusion power \\\\(\\\\eta = 1.5\\\\) instead of \\\\(2.0\\\\), the simulation would be able to survive this crisis. Then, the result looks like this:\\n\\nThe heavy mass of fluid is drawn down the slope by gravity, where it collides with the ski lodge and is flung into the air! Hopefully everyone escapes! And also, we can see the boundary between heavy mass and light mass blur quickly due to the artificial viscosity.\\nWe can also visualize the evolution of the adaptively refined grid:\\n\\nThe adaptivity follows and precedes the flow pattern, based on the heuristic refinement scheme discussed above.\\n Possibilities for extensions\\nStabilization\\nThe numerical scheme we have chosen is not particularly stable when the artificial viscosity is small while is too diffusive when the artificial viscosity is large. Furthermore, it is known there are more advanced techniques to stabilize the solution, for example streamline diffusion, least-squares stabilization terms, entropy viscosity.\\nBetter linear solvers\\nWhile the Newton method as a nonlinear solver appears to work very well if the time step is small enough, the linear solver can be improved. For example, in the current scheme whenever we use an iterative solver, an ILU is computed anew for each Newton step; likewise, for the direct solver, an LU decomposition of the Newton matrix is computed in each step. This is obviously wasteful: from one Newton step to another, and probably also between time steps, the Newton matrix does not radically change: an ILU or a sparse LU decomposition for one Newton step is probably still a very good preconditioner for the next Newton or time step. Avoiding the recomputation would therefore be a good way to reduce the amount of compute time.\\nOne could drive this a step further: since close to convergence the Newton matrix changes only a little bit, one may be able to define a quasi-Newton scheme where we only re-compute the residual (i.e. the right hand side vector) in each Newton iteration, and re-use the Newton matrix. The resulting scheme will likely not be of quadratic convergence order, and we have to expect to do a few more nonlinear iterations; however, given that we don't have to spend the time to build the Newton matrix each time, the resulting scheme may well be faster.\\nCache the explicit part of residual\\nThe residual calculated in ConservationLaw::assemble_cell_term function reads    \\\\(R_i = \\\\left(\\\\frac{\\\\mathbf{w}^{k}_{n+1} - \\\\mathbf{w}_n}{\\\\delta t}\\n    , \\\\mathbf{z}_i \\\\right)_K  +\\n      \\\\theta \\\\mathbf{B}({\\\\mathbf{w}^{k}_{n+1}})(\\\\mathbf{z}_i)_K +\\n      (1-\\\\theta) \\\\mathbf{B}({\\\\mathbf{w}_{n}}) (\\\\mathbf{z}_i)_K \\\\) This means that we calculate the spatial residual twice at one Newton iteration step: once respect to the current solution \\\\(\\\\mathbf{w}^{k}_{n+1}\\\\) and once more respect to the last time step solution \\\\(\\\\mathbf{w}_{n}\\\\) which remains the same during all Newton iterations through one timestep. Cache up the explicit part of residual \\\\( \\\\mathbf{B}({\\\\mathbf{w}_{n}}) (\\\\mathbf{z}_i)_K\\\\) during Newton iteration will save lots of labor.\\nOther conservation laws\\nFinally, as a direction beyond the immediate solution of the Euler equations, this program tries very hard to separate the implementation of everything that is specific to the Euler equations into one class (the EulerEquation class), and everything that is specific to assembling the matrices and vectors, nonlinear and linear solvers, and the general top-level logic into another (the ConservationLaw class).\\nBy replacing the definitions of flux matrices and numerical fluxes in this class, as well as the various other parts defined there, it should be possible to apply the ConservationLaw class to other hyperbolic conservation laws as well.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2008 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Author: David Neckels, Boulder, Colorado, 2007, 2008\\n */\\n \\n \\n \\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/function.h>\\n#include <deal.II/base/parameter_handler.h>\\n#include <deal.II/base/function_parser.h>\\n#include <deal.II/base/utilities.h>\\n#include <deal.II/base/conditional_ostream.h>\\n \\n#include <deal.II/lac/vector.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n \\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_out.h>\\n#include <deal.II/grid/grid_refinement.h>\\n#include <deal.II/grid/grid_in.h>\\n \\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/fe/fe_values.h>\\n#include <deal.II/fe/fe_system.h>\\n#include <deal.II/fe/mapping_q1.h>\\n#include <deal.II/fe/fe_q.h>\\n \\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/vector_tools.h>\\n#include <deal.II/numerics/solution_transfer.h>\\n \\n#include <deal.II/lac/trilinos_sparse_matrix.h>\\n#include <deal.II/lac/trilinos_precondition.h>\\n#include <deal.II/lac/trilinos_solver.h>\\n \\n \\n#include <Sacado.hpp>\\n \\n#include <iostream>\\n#include <fstream>\\n#include <vector>\\n#include <memory>\\n#include <array>\\n \\nnamespace Step33\\n{\\n using namespace dealii;\\n \\n \\n \\n template <int dim>\\n struct EulerEquations\\n  {\\n \\n static const unsigned int n_components             = dim + 2;\\n static const unsigned int first_momentum_component = 0;\\n static const unsigned int density_component        = dim;\\n static const unsigned int energy_component         = dim + 1;\\n \\n static std::vector<std::string> component_names()\\n    {\\n      std::vector<std::string> names(dim, \\\"momentum\\\");\\n      names.emplace_back(\\\"density\\\");\\n      names.emplace_back(\\\"energy_density\\\");\\n \\n return names;\\n    }\\n \\n \\n static std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n    component_interpretation()\\n    {\\n      std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n        data_component_interpretation(\\n          dim, DataComponentInterpretation::component_is_part_of_vector);\\n      data_component_interpretation.push_back(\\n DataComponentInterpretation::component_is_scalar);\\n      data_component_interpretation.push_back(\\n DataComponentInterpretation::component_is_scalar);\\n \\n return data_component_interpretation;\\n    }\\n \\n \\n \\n static const double gas_gamma;\\n \\n \\n template <typename InputVector>\\n static typename InputVector::value_type\\n    compute_kinetic_energy(const InputVector &W)\\n    {\\n typename InputVector::value_type kinetic_energy = 0;\\n for (unsigned int d = 0; d < dim; ++d)\\n        kinetic_energy +=\\n          W[first_momentum_component + d] * W[first_momentum_component + d];\\n      kinetic_energy *= 1. / (2 * W[density_component]);\\n \\n return kinetic_energy;\\n    }\\n \\n \\n template <typename InputVector>\\n static typename InputVector::value_type\\n    compute_pressure(const InputVector &W)\\n    {\\n return ((gas_gamma - 1.0) *\\n              (W[energy_component] - compute_kinetic_energy(W)));\\n    }\\n \\n \\n \\n template <typename InputVector>\\n static void compute_flux_matrix(const InputVector &W,\\n ndarray<typename InputVector::value_type,\\n                                            EulerEquations<dim>::n_components,\\n                                            dim>      &flux)\\n    {\\n const typename InputVector::value_type pressure = compute_pressure(W);\\n \\n for (unsigned int d = 0; d < dim; ++d)\\n        {\\n for (unsigned int e = 0; e < dim; ++e)\\n            flux[first_momentum_component + d][e] =\\n              W[first_momentum_component + d] *\\n              W[first_momentum_component + e] / W[density_component];\\n \\n          flux[first_momentum_component + d][d] += pressure;\\n        }\\n \\n for (unsigned int d = 0; d < dim; ++d)\\n        flux[density_component][d] = W[first_momentum_component + d];\\n \\n for (unsigned int d = 0; d < dim; ++d)\\n        flux[energy_component][d] = W[first_momentum_component + d] /\\n                                    W[density_component] *\\n                                    (W[energy_component] + pressure);\\n    }\\n \\n \\n \\n template <typename InputVector>\\n static void numerical_normal_flux(\\n const Tensor<1, dim>                                       &normal,\\n const InputVector                                          &Wplus,\\n const InputVector                                          &Wminus,\\n const double                                                alpha,\\n      std::array<typename InputVector::value_type, n_components> &normal_flux)\\n    {\\n ndarray<typename InputVector::value_type,\\n              EulerEquations<dim>::n_components,\\n              dim>\\n        iflux, oflux;\\n \\n      compute_flux_matrix(Wplus, iflux);\\n      compute_flux_matrix(Wminus, oflux);\\n \\n for (unsigned int di = 0; di < n_components; ++di)\\n        {\\n          normal_flux[di] = 0;\\n for (unsigned int d = 0; d < dim; ++d)\\n            normal_flux[di] += 0.5 * (iflux[di][d] + oflux[di][d]) * normal[d];\\n \\n          normal_flux[di] += 0.5 * alpha * (Wplus[di] - Wminus[di]);\\n        }\\n    }\\n \\n \\n template <typename InputVector>\\n static void compute_forcing_vector(\\n const InputVector                                          &W,\\n      std::array<typename InputVector::value_type, n_components> &forcing)\\n    {\\n const double gravity = -1.0;\\n \\n for (unsigned int c = 0; c < n_components; ++c)\\n switch (c)\\n          {\\n case first_momentum_component + dim - 1:\\n              forcing[c] = gravity * W[density_component];\\n break;\\n case energy_component:\\n              forcing[c] = gravity * W[first_momentum_component + dim - 1];\\n break;\\n default:\\n              forcing[c] = 0;\\n          }\\n    }\\n \\n \\n \\n enum BoundaryKind\\n    {\\n      inflow_boundary,\\n      outflow_boundary,\\n      no_penetration_boundary,\\n      pressure_boundary\\n    };\\n \\n \\n template <typename DataVector>\\n static void\\n    compute_Wminus(const std::array<BoundaryKind, n_components> &boundary_kind,\\n const Tensor<1, dim>                         &normal_vector,\\n const DataVector                             &Wplus,\\n const Vector<double> &boundary_values,\\n const DataVector     &Wminus)\\n    {\\n for (unsigned int c = 0; c < n_components; ++c)\\n switch (boundary_kind[c])\\n          {\\n case inflow_boundary:\\n              {\\n                Wminus[c] = boundary_values(c);\\n break;\\n              }\\n \\n case outflow_boundary:\\n              {\\n                Wminus[c] = Wplus[c];\\n break;\\n              }\\n \\n case pressure_boundary:\\n              {\\n const typename DataVector::value_type density =\\n                  (boundary_kind[density_component] == inflow_boundary ?\\n                     boundary_values(density_component) :\\n                     Wplus[density_component]);\\n \\n typename DataVector::value_type kinetic_energy = 0;\\n for (unsigned int d = 0; d < dim; ++d)\\n if (boundary_kind[d] == inflow_boundary)\\n                    kinetic_energy += boundary_values(d) * boundary_values(d);\\n else\\n                    kinetic_energy += Wplus[d] * Wplus[d];\\n                kinetic_energy *= 1. / 2. / density;\\n \\n                Wminus[c] =\\n                  boundary_values(c) / (gas_gamma - 1.0) + kinetic_energy;\\n \\n break;\\n              }\\n \\n case no_penetration_boundary:\\n              {\\n typename DataVector::value_type vdotn = 0;\\n for (unsigned int d = 0; d < dim; ++d)\\n                  {\\n                    vdotn += Wplus[d] * normal_vector[d];\\n                  }\\n \\n                Wminus[c] = Wplus[c] - 2.0 * vdotn * normal_vector[c];\\n break;\\n              }\\n \\n default:\\n DEAL_II_NOT_IMPLEMENTED();\\n          }\\n    }\\n \\n \\n \\n static void\\n    compute_refinement_indicators(const DoFHandler<dim> &dof_handler,\\n const Mapping<dim>    &mapping,\\n const Vector<double>  &solution,\\n Vector<double>        &refinement_indicators)\\n    {\\n const unsigned int dofs_per_cell = dof_handler.get_fe().n_dofs_per_cell();\\n      std::vector<unsigned int> dofs(dofs_per_cell);\\n \\n const QMidpoint<dim> quadrature_formula;\\n const UpdateFlags    update_flags = update_gradients;\\n FEValues<dim>        fe_v(mapping,\\n                         dof_handler.get_fe(),\\n                         quadrature_formula,\\n                         update_flags);\\n \\n      std::vector<std::vector<Tensor<1, dim>>> dU(\\n        1, std::vector<Tensor<1, dim>>(n_components));\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n        {\\n const unsigned int cell_no = cell->active_cell_index();\\n          fe_v.reinit(cell);\\n          fe_v.get_function_gradients(solution, dU);\\n \\n          refinement_indicators(cell_no) = std::log(\\n            1 + std::sqrt(dU[0][density_component] * dU[0][density_component]));\\n        }\\n    }\\n \\n \\n \\n \\n class Postprocessor : public DataPostprocessor<dim>\\n    {\\n public:\\n      Postprocessor(const bool do_schlieren_plot);\\n \\n virtual void evaluate_vector_field(\\n const DataPostprocessorInputs::Vector<dim> &inputs,\\n        std::vector<Vector<double>> &computed_quantities) const override;\\n \\n virtual std::vector<std::string> get_names() const override;\\n \\n virtual std::vector<\\n DataComponentInterpretation::DataComponentInterpretation>\\n      get_data_component_interpretation() const override;\\n \\n virtual UpdateFlags get_needed_update_flags() const override;\\n \\n private:\\n const bool do_schlieren_plot;\\n    };\\n  };\\n \\n \\n template <int dim>\\n const double EulerEquations<dim>::gas_gamma = 1.4;\\n \\n \\n \\n template <int dim>\\n  EulerEquations<dim>::Postprocessor::Postprocessor(\\n const bool do_schlieren_plot)\\n    : do_schlieren_plot(do_schlieren_plot)\\n  {}\\n \\n \\n template <int dim>\\n void EulerEquations<dim>::Postprocessor::evaluate_vector_field(\\n const DataPostprocessorInputs::Vector<dim> &inputs,\\n    std::vector<Vector<double>>                &computed_quantities) const\\n {\\n const unsigned int n_evaluation_points = inputs.solution_values.size();\\n \\n if (do_schlieren_plot == true)\\n Assert(inputs.solution_gradients.size() == n_evaluation_points,\\n             ExcInternalError());\\n \\n Assert(computed_quantities.size() == n_evaluation_points,\\n           ExcInternalError());\\n \\n Assert(inputs.solution_values[0].size() == n_components,\\n           ExcInternalError());\\n \\n if (do_schlieren_plot == true)\\n      {\\n Assert(computed_quantities[0].size() == dim + 2, ExcInternalError());\\n      }\\n else\\n      {\\n Assert(computed_quantities[0].size() == dim + 1, ExcInternalError());\\n      }\\n \\n for (unsigned int p = 0; p < n_evaluation_points; ++p)\\n      {\\n const double density = inputs.solution_values[p](density_component);\\n \\n for (unsigned int d = 0; d < dim; ++d)\\n          computed_quantities[p](d) =\\n            inputs.solution_values[p](first_momentum_component + d) / density;\\n \\n        computed_quantities[p](dim) =\\n          compute_pressure(inputs.solution_values[p]);\\n \\n if (do_schlieren_plot == true)\\n          computed_quantities[p](dim + 1) =\\n            inputs.solution_gradients[p][density_component] *\\n            inputs.solution_gradients[p][density_component];\\n      }\\n  }\\n \\n \\n template <int dim>\\n  std::vector<std::string> EulerEquations<dim>::Postprocessor::get_names() const\\n {\\n    std::vector<std::string> names;\\n for (unsigned int d = 0; d < dim; ++d)\\n      names.emplace_back(\\\"velocity\\\");\\n    names.emplace_back(\\\"pressure\\\");\\n \\n if (do_schlieren_plot == true)\\n      names.emplace_back(\\\"schlieren_plot\\\");\\n \\n return names;\\n  }\\n \\n \\n template <int dim>\\n  std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n  EulerEquations<dim>::Postprocessor::get_data_component_interpretation() const\\n {\\n    std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n      interpretation(dim,\\n DataComponentInterpretation::component_is_part_of_vector);\\n \\n    interpretation.push_back(DataComponentInterpretation::component_is_scalar);\\n \\n if (do_schlieren_plot == true)\\n      interpretation.push_back(\\n DataComponentInterpretation::component_is_scalar);\\n \\n return interpretation;\\n  }\\n \\n \\n \\n template <int dim>\\n UpdateFlags\\n  EulerEquations<dim>::Postprocessor::get_needed_update_flags() const\\n {\\n if (do_schlieren_plot == true)\\n return update_values | update_gradients;\\n else\\n return update_values;\\n  }\\n \\n \\n \\n namespace Parameters\\n  {\\n struct Solver\\n    {\\n enum SolverType\\n      {\\n        gmres,\\n        direct\\n      };\\n      SolverType solver;\\n \\n enum OutputType\\n      {\\n        quiet,\\n        verbose\\n      };\\n      OutputType output;\\n \\n double linear_residual;\\n int    max_iterations;\\n \\n double ilut_fill;\\n double ilut_atol;\\n double ilut_rtol;\\n double ilut_drop;\\n \\n static void declare_parameters(ParameterHandler &prm);\\n void        parse_parameters(ParameterHandler &prm);\\n    };\\n \\n \\n \\n void Solver::declare_parameters(ParameterHandler &prm)\\n    {\\n      prm.enter_subsection(\\\"linear solver\\\");\\n      {\\n        prm.declare_entry(\\n \\\"output\\\",\\n \\\"quiet\\\",\\n Patterns::Selection(\\\"quiet|verbose\\\"),\\n \\\"State whether output from solver runs should be printed. \\\"\\n \\\"Choices are <quiet|verbose>.\\\");\\n        prm.declare_entry(\\\"method\\\",\\n \\\"gmres\\\",\\n Patterns::Selection(\\\"gmres|direct\\\"),\\n \\\"The kind of solver for the linear system. \\\"\\n \\\"Choices are <gmres|direct>.\\\");\\n        prm.declare_entry(\\\"residual\\\",\\n \\\"1e-10\\\",\\n Patterns::Double(),\\n \\\"Linear solver residual\\\");\\n        prm.declare_entry(\\\"max iters\\\",\\n \\\"300\\\",\\n Patterns::Integer(),\\n \\\"Maximum solver iterations\\\");\\n        prm.declare_entry(\\\"ilut fill\\\",\\n \\\"2\\\",\\n Patterns::Double(),\\n \\\"Ilut preconditioner fill\\\");\\n        prm.declare_entry(\\\"ilut absolute tolerance\\\",\\n \\\"1e-9\\\",\\n Patterns::Double(),\\n \\\"Ilut preconditioner tolerance\\\");\\n        prm.declare_entry(\\\"ilut relative tolerance\\\",\\n \\\"1.1\\\",\\n Patterns::Double(),\\n \\\"Ilut relative tolerance\\\");\\n        prm.declare_entry(\\\"ilut drop tolerance\\\",\\n \\\"1e-10\\\",\\n Patterns::Double(),\\n \\\"Ilut drop tolerance\\\");\\n      }\\n      prm.leave_subsection();\\n    }\\n \\n \\n \\n void Solver::parse_parameters(ParameterHandler &prm)\\n    {\\n      prm.enter_subsection(\\\"linear solver\\\");\\n      {\\n const std::string op = prm.get(\\\"output\\\");\\n if (op == \\\"verbose\\\")\\n          output = verbose;\\n if (op == \\\"quiet\\\")\\n          output = quiet;\\n \\n const std::string sv = prm.get(\\\"method\\\");\\n if (sv == \\\"direct\\\")\\n          solver = direct;\\n else if (sv == \\\"gmres\\\")\\n          solver = gmres;\\n \\n        linear_residual = prm.get_double(\\\"residual\\\");\\n        max_iterations  = prm.get_integer(\\\"max iters\\\");\\n        ilut_fill       = prm.get_double(\\\"ilut fill\\\");\\n        ilut_atol       = prm.get_double(\\\"ilut absolute tolerance\\\");\\n        ilut_rtol       = prm.get_double(\\\"ilut relative tolerance\\\");\\n        ilut_drop       = prm.get_double(\\\"ilut drop tolerance\\\");\\n      }\\n      prm.leave_subsection();\\n    }\\n \\n \\n \\n struct Refinement\\n    {\\n bool   do_refine;\\n double shock_val;\\n double shock_levels;\\n \\n static void declare_parameters(ParameterHandler &prm);\\n void        parse_parameters(ParameterHandler &prm);\\n    };\\n \\n \\n \\n void Refinement::declare_parameters(ParameterHandler &prm)\\n    {\\n      prm.enter_subsection(\\\"refinement\\\");\\n      {\\n        prm.declare_entry(\\\"refinement\\\",\\n \\\"true\\\",\\n Patterns::Bool(),\\n \\\"Whether to perform mesh refinement or not\\\");\\n        prm.declare_entry(\\\"refinement fraction\\\",\\n \\\"0.1\\\",\\n Patterns::Double(),\\n \\\"Fraction of high refinement\\\");\\n        prm.declare_entry(\\\"unrefinement fraction\\\",\\n \\\"0.1\\\",\\n Patterns::Double(),\\n \\\"Fraction of low unrefinement\\\");\\n        prm.declare_entry(\\\"max elements\\\",\\n \\\"1000000\\\",\\n Patterns::Double(),\\n \\\"maximum number of elements\\\");\\n        prm.declare_entry(\\\"shock value\\\",\\n \\\"4.0\\\",\\n Patterns::Double(),\\n \\\"value for shock indicator\\\");\\n        prm.declare_entry(\\\"shock levels\\\",\\n \\\"3.0\\\",\\n Patterns::Double(),\\n \\\"number of shock refinement levels\\\");\\n      }\\n      prm.leave_subsection();\\n    }\\n \\n \\n void Refinement::parse_parameters(ParameterHandler &prm)\\n    {\\n      prm.enter_subsection(\\\"refinement\\\");\\n      {\\n        do_refine    = prm.get_bool(\\\"refinement\\\");\\n        shock_val    = prm.get_double(\\\"shock value\\\");\\n        shock_levels = prm.get_double(\\\"shock levels\\\");\\n      }\\n      prm.leave_subsection();\\n    }\\n \\n \\n \\n struct Flux\\n    {\\n enum StabilizationKind\\n      {\\n constant,\\n        mesh_dependent\\n      };\\n      StabilizationKind stabilization_kind;\\n \\n double stabilization_value;\\n \\n static void declare_parameters(ParameterHandler &prm);\\n void        parse_parameters(ParameterHandler &prm);\\n    };\\n \\n \\n void Flux::declare_parameters(ParameterHandler &prm)\\n    {\\n      prm.enter_subsection(\\\"flux\\\");\\n      {\\n        prm.declare_entry(\\n \\\"stab\\\",\\n \\\"mesh\\\",\\n Patterns::Selection(\\\"constant|mesh\\\"),\\n \\\"Whether to use a constant stabilization parameter or \\\"\\n \\\"a mesh-dependent one\\\");\\n        prm.declare_entry(\\\"stab value\\\",\\n \\\"1\\\",\\n Patterns::Double(),\\n \\\"alpha stabilization\\\");\\n      }\\n      prm.leave_subsection();\\n    }\\n \\n \\n void Flux::parse_parameters(ParameterHandler &prm)\\n    {\\n      prm.enter_subsection(\\\"flux\\\");\\n      {\\n const std::string stab = prm.get(\\\"stab\\\");\\n if (stab == \\\"constant\\\")\\n          stabilization_kind = constant;\\n else if (stab == \\\"mesh\\\")\\n          stabilization_kind = mesh_dependent;\\n else\\n AssertThrow(false, ExcNotImplemented());\\n \\n        stabilization_value = prm.get_double(\\\"stab value\\\");\\n      }\\n      prm.leave_subsection();\\n    }\\n \\n \\n \\n struct Output\\n    {\\n bool   schlieren_plot;\\n double output_step;\\n \\n static void declare_parameters(ParameterHandler &prm);\\n void        parse_parameters(ParameterHandler &prm);\\n    };\\n \\n \\n \\n void Output::declare_parameters(ParameterHandler &prm)\\n    {\\n      prm.enter_subsection(\\\"output\\\");\\n      {\\n        prm.declare_entry(\\\"schlieren plot\\\",\\n \\\"true\\\",\\n Patterns::Bool(),\\n \\\"Whether or not to produce schlieren plots\\\");\\n        prm.declare_entry(\\\"step\\\",\\n \\\"-1\\\",\\n Patterns::Double(),\\n \\\"Output once per this period\\\");\\n      }\\n      prm.leave_subsection();\\n    }\\n \\n \\n \\n void Output::parse_parameters(ParameterHandler &prm)\\n    {\\n      prm.enter_subsection(\\\"output\\\");\\n      {\\n        schlieren_plot = prm.get_bool(\\\"schlieren plot\\\");\\n        output_step    = prm.get_double(\\\"step\\\");\\n      }\\n      prm.leave_subsection();\\n    }\\n \\n \\n \\n template <int dim>\\n struct AllParameters : public Solver,\\n public Refinement,\\n public Flux,\\n public Output\\n    {\\n static const unsigned int max_n_boundaries = 10;\\n \\n struct BoundaryConditions\\n      {\\n        std::array<typename EulerEquations<dim>::BoundaryKind,\\n                   EulerEquations<dim>::n_components>\\n          kind;\\n \\n FunctionParser<dim> values;\\n \\n        BoundaryConditions();\\n      };\\n \\n \\n      AllParameters();\\n \\n double diffusion_power;\\n \\n double time_step, final_time;\\n double theta;\\n bool   is_stationary;\\n \\n      std::string mesh_filename;\\n \\n FunctionParser<dim> initial_conditions;\\n      BoundaryConditions  boundary_conditions[max_n_boundaries];\\n \\n static void declare_parameters(ParameterHandler &prm);\\n void        parse_parameters(ParameterHandler &prm);\\n    };\\n \\n \\n \\n template <int dim>\\n    AllParameters<dim>::BoundaryConditions::BoundaryConditions()\\n      : values(EulerEquations<dim>::n_components)\\n    {\\n      std::fill(kind.begin(),\\n                kind.end(),\\n                EulerEquations<dim>::no_penetration_boundary);\\n    }\\n \\n \\n template <int dim>\\n    AllParameters<dim>::AllParameters()\\n      : diffusion_power(0.)\\n      , time_step(1.)\\n      , final_time(1.)\\n      , theta(.5)\\n      , is_stationary(true)\\n      , initial_conditions(EulerEquations<dim>::n_components)\\n    {}\\n \\n \\n template <int dim>\\n void AllParameters<dim>::declare_parameters(ParameterHandler &prm)\\n    {\\n      prm.declare_entry(\\\"mesh\\\",\\n \\\"grid.inp\\\",\\n Patterns::Anything(),\\n \\\"input file name\\\");\\n \\n      prm.declare_entry(\\\"diffusion power\\\",\\n \\\"2.0\\\",\\n Patterns::Double(),\\n \\\"power of mesh size for diffusion\\\");\\n \\n      prm.enter_subsection(\\\"time stepping\\\");\\n      {\\n        prm.declare_entry(\\\"time step\\\",\\n \\\"0.1\\\",\\n Patterns::Double(0),\\n \\\"simulation time step\\\");\\n        prm.declare_entry(\\\"final time\\\",\\n \\\"10.0\\\",\\n Patterns::Double(0),\\n \\\"simulation end time\\\");\\n        prm.declare_entry(\\\"theta scheme value\\\",\\n \\\"0.5\\\",\\n Patterns::Double(0, 1),\\n \\\"value for theta that interpolated between explicit \\\"\\n \\\"Euler (theta=0), Crank-Nicolson (theta=0.5), and \\\"\\n \\\"implicit Euler (theta=1).\\\");\\n      }\\n      prm.leave_subsection();\\n \\n \\n for (unsigned int b = 0; b < max_n_boundaries; ++b)\\n        {\\n          prm.enter_subsection(\\\"boundary_\\\" + Utilities::int_to_string(b));\\n          {\\n            prm.declare_entry(\\\"no penetration\\\",\\n \\\"false\\\",\\n Patterns::Bool(),\\n \\\"whether the named boundary allows gas to \\\"\\n \\\"penetrate or is a rigid wall\\\");\\n \\n for (unsigned int di = 0; di < EulerEquations<dim>::n_components;\\n                 ++di)\\n              {\\n                prm.declare_entry(\\\"w_\\\" + Utilities::int_to_string(di),\\n \\\"outflow\\\",\\n Patterns::Selection(\\n \\\"inflow|outflow|pressure\\\"),\\n \\\"<inflow|outflow|pressure>\\\");\\n \\n                prm.declare_entry(\\\"w_\\\" + Utilities::int_to_string(di) +\\n \\\" value\\\",\\n \\\"0.0\\\",\\n Patterns::Anything(),\\n \\\"expression in x,y,z\\\");\\n              }\\n          }\\n          prm.leave_subsection();\\n        }\\n \\n      prm.enter_subsection(\\\"initial condition\\\");\\n      {\\n for (unsigned int di = 0; di < EulerEquations<dim>::n_components; ++di)\\n          prm.declare_entry(\\\"w_\\\" + Utilities::int_to_string(di) + \\\" value\\\",\\n \\\"0.0\\\",\\n Patterns::Anything(),\\n \\\"expression in x,y,z\\\");\\n      }\\n      prm.leave_subsection();\\n \\n      Parameters::Solver::declare_parameters(prm);\\n      Parameters::Refinement::declare_parameters(prm);\\n      Parameters::Flux::declare_parameters(prm);\\n      Parameters::Output::declare_parameters(prm);\\n    }\\n \\n \\n template <int dim>\\n void AllParameters<dim>::parse_parameters(ParameterHandler &prm)\\n    {\\n      mesh_filename   = prm.get(\\\"mesh\\\");\\n      diffusion_power = prm.get_double(\\\"diffusion power\\\");\\n \\n      prm.enter_subsection(\\\"time stepping\\\");\\n      {\\n        time_step = prm.get_double(\\\"time step\\\");\\n if (time_step == 0)\\n          {\\n            is_stationary = true;\\n            time_step     = 1.0;\\n            final_time    = 1.0;\\n          }\\n else\\n          is_stationary = false;\\n \\n        final_time = prm.get_double(\\\"final time\\\");\\n        theta      = prm.get_double(\\\"theta scheme value\\\");\\n      }\\n      prm.leave_subsection();\\n \\n for (unsigned int boundary_id = 0; boundary_id < max_n_boundaries;\\n           ++boundary_id)\\n        {\\n          prm.enter_subsection(\\\"boundary_\\\" +\\n Utilities::int_to_string(boundary_id));\\n          {\\n            std::vector<std::string> expressions(\\n              EulerEquations<dim>::n_components, \\\"0.0\\\");\\n \\n const bool no_penetration = prm.get_bool(\\\"no penetration\\\");\\n \\n for (unsigned int di = 0; di < EulerEquations<dim>::n_components;\\n                 ++di)\\n              {\\n const std::string boundary_type =\\n                  prm.get(\\\"w_\\\" + Utilities::int_to_string(di));\\n \\n if ((di < dim) && (no_penetration == true))\\n                  boundary_conditions[boundary_id].kind[di] =\\n                    EulerEquations<dim>::no_penetration_boundary;\\n else if (boundary_type == \\\"inflow\\\")\\n                  boundary_conditions[boundary_id].kind[di] =\\n                    EulerEquations<dim>::inflow_boundary;\\n else if (boundary_type == \\\"pressure\\\")\\n                  boundary_conditions[boundary_id].kind[di] =\\n                    EulerEquations<dim>::pressure_boundary;\\n else if (boundary_type == \\\"outflow\\\")\\n                  boundary_conditions[boundary_id].kind[di] =\\n                    EulerEquations<dim>::outflow_boundary;\\n else\\n AssertThrow(false, ExcNotImplemented());\\n \\n                expressions[di] =\\n                  prm.get(\\\"w_\\\" + Utilities::int_to_string(di) + \\\" value\\\");\\n              }\\n \\n            boundary_conditions[boundary_id].values.initialize(\\n FunctionParser<dim>::default_variable_names(),\\n              expressions,\\n              std::map<std::string, double>());\\n          }\\n          prm.leave_subsection();\\n        }\\n \\n      prm.enter_subsection(\\\"initial condition\\\");\\n      {\\n        std::vector<std::string> expressions(EulerEquations<dim>::n_components,\\n \\\"0.0\\\");\\n for (unsigned int di = 0; di < EulerEquations<dim>::n_components; ++di)\\n          expressions[di] =\\n            prm.get(\\\"w_\\\" + Utilities::int_to_string(di) + \\\" value\\\");\\n        initial_conditions.initialize(\\n FunctionParser<dim>::default_variable_names(),\\n          expressions,\\n          std::map<std::string, double>());\\n      }\\n      prm.leave_subsection();\\n \\n      Parameters::Solver::parse_parameters(prm);\\n      Parameters::Refinement::parse_parameters(prm);\\n      Parameters::Flux::parse_parameters(prm);\\n      Parameters::Output::parse_parameters(prm);\\n    }\\n  } // namespace Parameters\\n \\n \\n \\n \\n template <int dim>\\n class ConservationLaw\\n  {\\n public:\\n    ConservationLaw(const char *input_filename);\\n void run();\\n \\n private:\\n void setup_system();\\n \\n void assemble_system();\\n void assemble_cell_term(const FEValues<dim>                        &fe_v,\\n const std::vector<types::global_dof_index> &dofs);\\n void assemble_face_term(\\n const unsigned int                          face_no,\\n const FEFaceValuesBase<dim>                &fe_v,\\n const FEFaceValuesBase<dim>                &fe_v_neighbor,\\n const std::vector<types::global_dof_index> &dofs,\\n const std::vector<types::global_dof_index> &dofs_neighbor,\\n const bool                                  external_face,\\n const unsigned int                          boundary_id,\\n const double                                face_diameter);\\n \\n    std::pair<unsigned int, double> solve(Vector<double> &solution);\\n \\n void compute_refinement_indicators(Vector<double> &indicator) const;\\n void refine_grid(const Vector<double> &indicator);\\n \\n void output_results() const;\\n \\n \\n \\n Triangulation<dim> triangulation;\\n const MappingQ1<dim> mapping;\\n \\n const FESystem<dim> fe;\\n DoFHandler<dim>     dof_handler;\\n \\n const QGauss<dim>     quadrature;\\n const QGauss<dim - 1> face_quadrature;\\n \\n Vector<double> old_solution;\\n Vector<double> current_solution;\\n Vector<double> predictor;\\n \\n Vector<double> right_hand_side;\\n \\n TrilinosWrappers::SparseMatrix system_matrix;\\n \\n    Parameters::AllParameters<dim> parameters;\\n ConditionalOStream             verbose_cout;\\n  };\\n \\n \\n template <int dim>\\n  ConservationLaw<dim>::ConservationLaw(const char *input_filename)\\n    : mapping()\\n    , fe(FE_Q<dim>(1) ^ EulerEquations<dim>::n_components)\\n    , dof_handler(triangulation)\\n    , quadrature(fe.degree + 1)\\n    , face_quadrature(fe.degree + 1)\\n    , verbose_cout(std::cout, false)\\n  {\\n ParameterHandler prm;\\n    Parameters::AllParameters<dim>::declare_parameters(prm);\\n \\n    prm.parse_input(input_filename);\\n    parameters.parse_parameters(prm);\\n \\n    verbose_cout.set_condition(parameters.output ==\\n                               Parameters::Solver::verbose);\\n  }\\n \\n \\n \\n template <int dim>\\n void ConservationLaw<dim>::setup_system()\\n  {\\n DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());\\n DoFTools::make_sparsity_pattern(dof_handler, dsp);\\n \\n    system_matrix.reinit(dsp);\\n  }\\n \\n \\n template <int dim>\\n void ConservationLaw<dim>::assemble_system()\\n  {\\n const unsigned int dofs_per_cell = dof_handler.get_fe().n_dofs_per_cell();\\n \\n    std::vector<types::global_dof_index> dof_indices(dofs_per_cell);\\n    std::vector<types::global_dof_index> dof_indices_neighbor(dofs_per_cell);\\n \\n const UpdateFlags update_flags = update_values | update_gradients |\\n update_quadrature_points |\\n update_JxW_values,\\n                      face_update_flags =\\n update_values | update_quadrature_points |\\n update_JxW_values | update_normal_vectors,\\n                      neighbor_face_update_flags = update_values;\\n \\n FEValues<dim>        fe_v(mapping, fe, quadrature, update_flags);\\n FEFaceValues<dim>    fe_v_face(mapping,\\n                                fe,\\n                                face_quadrature,\\n                                face_update_flags);\\n FESubfaceValues<dim> fe_v_subface(mapping,\\n                                      fe,\\n                                      face_quadrature,\\n                                      face_update_flags);\\n FEFaceValues<dim>    fe_v_face_neighbor(mapping,\\n                                         fe,\\n                                         face_quadrature,\\n                                         neighbor_face_update_flags);\\n FESubfaceValues<dim> fe_v_subface_neighbor(mapping,\\n                                               fe,\\n                                               face_quadrature,\\n                                               neighbor_face_update_flags);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n        fe_v.reinit(cell);\\n        cell->get_dof_indices(dof_indices);\\n \\n        assemble_cell_term(fe_v, dof_indices);\\n \\n for (const auto face_no : cell->face_indices())\\n          if (cell->at_boundary(face_no))\\n            {\\n              fe_v_face.reinit(cell, face_no);\\n              assemble_face_term(face_no,\\n                                 fe_v_face,\\n                                 fe_v_face,\\n                                 dof_indices,\\n                                 std::vector<types::global_dof_index>(),\\n true,\\n                                 cell->face(face_no)->boundary_id(),\\n                                 cell->face(face_no)->diameter());\\n            }\\n \\n else\\n            {\\n if (cell->neighbor(face_no)->has_children())\\n                {\\n const unsigned int neighbor2 =\\n                    cell->neighbor_of_neighbor(face_no);\\n \\n for (unsigned int subface_no = 0;\\n                       subface_no < cell->face(face_no)->n_children();\\n                       ++subface_no)\\n                    {\\n const typename DoFHandler<dim>::active_cell_iterator\\n                        neighbor_child =\\n                          cell->neighbor_child_on_subface(face_no, subface_no);\\n \\n Assert(neighbor_child->face(neighbor2) ==\\n                               cell->face(face_no)->child(subface_no),\\n                             ExcInternalError());\\n Assert(neighbor_child->is_active(), ExcInternalError());\\n \\n                      fe_v_subface.reinit(cell, face_no, subface_no);\\n                      fe_v_face_neighbor.reinit(neighbor_child, neighbor2);\\n \\n                      neighbor_child->get_dof_indices(dof_indices_neighbor);\\n \\n                      assemble_face_term(\\n                        face_no,\\n                        fe_v_subface,\\n                        fe_v_face_neighbor,\\n                        dof_indices,\\n                        dof_indices_neighbor,\\n false,\\n numbers::invalid_unsigned_int,\\n                        neighbor_child->face(neighbor2)->diameter());\\n                    }\\n                }\\n \\n else if (cell->neighbor(face_no)->level() != cell->level())\\n                {\\n const typename DoFHandler<dim>::cell_iterator neighbor =\\n                    cell->neighbor(face_no);\\n Assert(neighbor->level() == cell->level() - 1,\\n                         ExcInternalError());\\n \\n                  neighbor->get_dof_indices(dof_indices_neighbor);\\n \\n const std::pair<unsigned int, unsigned int> faceno_subfaceno =\\n                    cell->neighbor_of_coarser_neighbor(face_no);\\n const unsigned int neighbor_face_no = faceno_subfaceno.first,\\n                                     neighbor_subface_no =\\n                                       faceno_subfaceno.second;\\n \\n Assert(neighbor->neighbor_child_on_subface(\\n                           neighbor_face_no, neighbor_subface_no) == cell,\\n                         ExcInternalError());\\n \\n                  fe_v_face.reinit(cell, face_no);\\n                  fe_v_subface_neighbor.reinit(neighbor,\\n                                               neighbor_face_no,\\n                                               neighbor_subface_no);\\n \\n                  assemble_face_term(face_no,\\n                                     fe_v_face,\\n                                     fe_v_subface_neighbor,\\n                                     dof_indices,\\n                                     dof_indices_neighbor,\\n false,\\n numbers::invalid_unsigned_int,\\n                                     cell->face(face_no)->diameter());\\n                }\\n            }\\n      }\\n  }\\n \\n \\n template <int dim>\\n void ConservationLaw<dim>::assemble_cell_term(\\n const FEValues<dim>                        &fe_v,\\n const std::vector<types::global_dof_index> &dof_indices)\\n  {\\n const unsigned int dofs_per_cell = fe_v.dofs_per_cell;\\n const unsigned int n_q_points    = fe_v.n_quadrature_points;\\n \\n Table<2, Sacado::Fad::DFad<double>> W(n_q_points,\\n                                          EulerEquations<dim>::n_components);\\n \\n Table<2, double> W_old(n_q_points, EulerEquations<dim>::n_components);\\n \\n Table<3, Sacado::Fad::DFad<double>> grad_W(\\n      n_q_points, EulerEquations<dim>::n_components, dim);\\n \\n Table<3, double> grad_W_old(n_q_points,\\n                                EulerEquations<dim>::n_components,\\n                                dim);\\n \\n    std::vector<double> residual_derivatives(dofs_per_cell);\\n \\n    std::vector<Sacado::Fad::DFad<double>> independent_local_dof_values(\\n      dofs_per_cell);\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n      independent_local_dof_values[i] = current_solution(dof_indices[i]);\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n      independent_local_dof_values[i].diff(i, dofs_per_cell);\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n for (unsigned int c = 0; c < EulerEquations<dim>::n_components; ++c)\\n        {\\n          W[q][c]     = 0;\\n          W_old[q][c] = 0;\\n for (unsigned int d = 0; d < dim; ++d)\\n            {\\n              grad_W[q][c][d]     = 0;\\n              grad_W_old[q][c][d] = 0;\\n            }\\n        }\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n        {\\n const unsigned int c =\\n            fe_v.get_fe().system_to_component_index(i).first;\\n \\n          W[q][c] += independent_local_dof_values[i] *\\n                     fe_v.shape_value_component(i, q, c);\\n          W_old[q][c] +=\\n            old_solution(dof_indices[i]) * fe_v.shape_value_component(i, q, c);\\n \\n for (unsigned int d = 0; d < dim; ++d)\\n            {\\n              grad_W[q][c][d] += independent_local_dof_values[i] *\\n                                 fe_v.shape_grad_component(i, q, c)[d];\\n              grad_W_old[q][c][d] += old_solution(dof_indices[i]) *\\n                                     fe_v.shape_grad_component(i, q, c)[d];\\n            }\\n        }\\n \\n \\n \\n    std::vector<ndarray<Sacado::Fad::DFad<double>,\\n                        EulerEquations<dim>::n_components,\\n                        dim>>\\n      flux(n_q_points);\\n \\n    std::vector<ndarray<double, EulerEquations<dim>::n_components, dim>>\\n      flux_old(n_q_points);\\n \\n    std::vector<\\n      std::array<Sacado::Fad::DFad<double>, EulerEquations<dim>::n_components>>\\n      forcing(n_q_points);\\n \\n    std::vector<std::array<double, EulerEquations<dim>::n_components>>\\n      forcing_old(n_q_points);\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n      {\\n        EulerEquations<dim>::compute_flux_matrix(W_old[q], flux_old[q]);\\n        EulerEquations<dim>::compute_forcing_vector(W_old[q], forcing_old[q]);\\n        EulerEquations<dim>::compute_flux_matrix(W[q], flux[q]);\\n        EulerEquations<dim>::compute_forcing_vector(W[q], forcing[q]);\\n      }\\n \\n \\n for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)\\n      {\\n        Sacado::Fad::DFad<double> R_i = 0;\\n \\n const unsigned int component_i =\\n          fe_v.get_fe().system_to_component_index(i).first;\\n \\n \\n for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point)\\n          {\\n if (parameters.is_stationary == false)\\n              R_i += 1.0 / parameters.time_step *\\n                     (W[point][component_i] - W_old[point][component_i]) *\\n                     fe_v.shape_value_component(i, point, component_i) *\\n                     fe_v.JxW(point);\\n \\n for (unsigned int d = 0; d < dim; ++d)\\n              R_i -=\\n                (parameters.theta * flux[point][component_i][d] +\\n                 (1.0 - parameters.theta) * flux_old[point][component_i][d]) *\\n                fe_v.shape_grad_component(i, point, component_i)[d] *\\n                fe_v.JxW(point);\\n \\n for (unsigned int d = 0; d < dim; ++d)\\n              R_i +=\\n                1.0 *\\n std::pow(fe_v.get_cell()->diameter(),\\n                         parameters.diffusion_power) *\\n                (parameters.theta * grad_W[point][component_i][d] +\\n                 (1.0 - parameters.theta) * grad_W_old[point][component_i][d]) *\\n                fe_v.shape_grad_component(i, point, component_i)[d] *\\n                fe_v.JxW(point);\\n \\n            R_i -=\\n              (parameters.theta * forcing[point][component_i] +\\n               (1.0 - parameters.theta) * forcing_old[point][component_i]) *\\n              fe_v.shape_value_component(i, point, component_i) *\\n              fe_v.JxW(point);\\n          }\\n \\n for (unsigned int k = 0; k < dofs_per_cell; ++k)\\n          residual_derivatives[k] = R_i.fastAccessDx(k);\\n        system_matrix.add(dof_indices[i], dof_indices, residual_derivatives);\\n        right_hand_side(dof_indices[i]) -= R_i.val();\\n      }\\n  }\\n \\n \\n template <int dim>\\n void ConservationLaw<dim>::assemble_face_term(\\n const unsigned int                          face_no,\\n const FEFaceValuesBase<dim>                &fe_v,\\n const FEFaceValuesBase<dim>                &fe_v_neighbor,\\n const std::vector<types::global_dof_index> &dof_indices,\\n const std::vector<types::global_dof_index> &dof_indices_neighbor,\\n const bool                                  external_face,\\n const unsigned int                          boundary_id,\\n const double                                face_diameter)\\n  {\\n const unsigned int n_q_points    = fe_v.n_quadrature_points;\\n const unsigned int dofs_per_cell = fe_v.dofs_per_cell;\\n \\n    std::vector<Sacado::Fad::DFad<double>> independent_local_dof_values(\\n      dofs_per_cell),\\n      independent_neighbor_dof_values(external_face == false ? dofs_per_cell :\\n                                                               0);\\n \\n const unsigned int n_independent_variables =\\n      (external_face == false ? 2 * dofs_per_cell : dofs_per_cell);\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n      {\\n        independent_local_dof_values[i] = current_solution(dof_indices[i]);\\n        independent_local_dof_values[i].diff(i, n_independent_variables);\\n      }\\n \\n if (external_face == false)\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n        {\\n          independent_neighbor_dof_values[i] =\\n            current_solution(dof_indices_neighbor[i]);\\n          independent_neighbor_dof_values[i].diff(i + dofs_per_cell,\\n                                                  n_independent_variables);\\n        }\\n \\n \\n Table<2, Sacado::Fad::DFad<double>> Wplus(\\n      n_q_points, EulerEquations<dim>::n_components),\\n      Wminus(n_q_points, EulerEquations<dim>::n_components);\\n Table<2, double> Wplus_old(n_q_points, EulerEquations<dim>::n_components),\\n      Wminus_old(n_q_points, EulerEquations<dim>::n_components);\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n        {\\n const unsigned int component_i =\\n            fe_v.get_fe().system_to_component_index(i).first;\\n          Wplus[q][component_i] +=\\n            independent_local_dof_values[i] *\\n            fe_v.shape_value_component(i, q, component_i);\\n          Wplus_old[q][component_i] +=\\n            old_solution(dof_indices[i]) *\\n            fe_v.shape_value_component(i, q, component_i);\\n        }\\n \\n if (external_face == false)\\n      {\\n for (unsigned int q = 0; q < n_q_points; ++q)\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n            {\\n const unsigned int component_i =\\n                fe_v_neighbor.get_fe().system_to_component_index(i).first;\\n              Wminus[q][component_i] +=\\n                independent_neighbor_dof_values[i] *\\n                fe_v_neighbor.shape_value_component(i, q, component_i);\\n              Wminus_old[q][component_i] +=\\n                old_solution(dof_indices_neighbor[i]) *\\n                fe_v_neighbor.shape_value_component(i, q, component_i);\\n            }\\n      }\\n else\\n      {\\n Assert(boundary_id < Parameters::AllParameters<dim>::max_n_boundaries,\\n               ExcIndexRange(boundary_id,\\n                             0,\\n                             Parameters::AllParameters<dim>::max_n_boundaries));\\n \\n        std::vector<Vector<double>> boundary_values(\\n          n_q_points, Vector<double>(EulerEquations<dim>::n_components));\\n        parameters.boundary_conditions[boundary_id].values.vector_value_list(\\n          fe_v.get_quadrature_points(), boundary_values);\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n          {\\n            EulerEquations<dim>::compute_Wminus(\\n              parameters.boundary_conditions[boundary_id].kind,\\n              fe_v.normal_vector(q),\\n              Wplus[q],\\n              boundary_values[q],\\n              Wminus[q]);\\n            EulerEquations<dim>::compute_Wminus(\\n              parameters.boundary_conditions[boundary_id].kind,\\n              fe_v.normal_vector(q),\\n              Wplus_old[q],\\n              boundary_values[q],\\n              Wminus_old[q]);\\n          }\\n      }\\n \\n \\n \\n    std::vector<\\n      std::array<Sacado::Fad::DFad<double>, EulerEquations<dim>::n_components>>\\n      normal_fluxes(n_q_points);\\n    std::vector<std::array<double, EulerEquations<dim>::n_components>>\\n      normal_fluxes_old(n_q_points);\\n \\n double alpha;\\n \\n switch (parameters.stabilization_kind)\\n      {\\n case Parameters::Flux::constant:\\n          alpha = parameters.stabilization_value;\\n break;\\n case Parameters::Flux::mesh_dependent:\\n          alpha = face_diameter / (2.0 * parameters.time_step);\\n break;\\n default:\\n DEAL_II_NOT_IMPLEMENTED();\\n          alpha = 1;\\n      }\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n      {\\n        EulerEquations<dim>::numerical_normal_flux(\\n          fe_v.normal_vector(q), Wplus[q], Wminus[q], alpha, normal_fluxes[q]);\\n        EulerEquations<dim>::numerical_normal_flux(fe_v.normal_vector(q),\\n                                                   Wplus_old[q],\\n                                                   Wminus_old[q],\\n                                                   alpha,\\n                                                   normal_fluxes_old[q]);\\n      }\\n \\n    std::vector<double> residual_derivatives(dofs_per_cell);\\n for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)\\n if (fe_v.get_fe().has_support_on_face(i, face_no) == true)\\n        {\\n          Sacado::Fad::DFad<double> R_i = 0;\\n \\n for (unsigned int point = 0; point < n_q_points; ++point)\\n            {\\n const unsigned int component_i =\\n                fe_v.get_fe().system_to_component_index(i).first;\\n \\n              R_i += (parameters.theta * normal_fluxes[point][component_i] +\\n                      (1.0 - parameters.theta) *\\n                        normal_fluxes_old[point][component_i]) *\\n                     fe_v.shape_value_component(i, point, component_i) *\\n                     fe_v.JxW(point);\\n            }\\n \\n for (unsigned int k = 0; k < dofs_per_cell; ++k)\\n            residual_derivatives[k] = R_i.fastAccessDx(k);\\n          system_matrix.add(dof_indices[i], dof_indices, residual_derivatives);\\n \\n if (external_face == false)\\n            {\\n for (unsigned int k = 0; k < dofs_per_cell; ++k)\\n                residual_derivatives[k] = R_i.fastAccessDx(dofs_per_cell + k);\\n              system_matrix.add(dof_indices[i],\\n                                dof_indices_neighbor,\\n                                residual_derivatives);\\n            }\\n \\n          right_hand_side(dof_indices[i]) -= R_i.val();\\n        }\\n  }\\n \\n \\n \\n template <int dim>\\n  std::pair<unsigned int, double>\\n  ConservationLaw<dim>::solve(Vector<double> &newton_update)\\n  {\\n switch (parameters.solver)\\n      {\\n case Parameters::Solver::direct:\\n          {\\n SolverControl                                  solver_control(1, 0);\\n TrilinosWrappers::SolverDirect::AdditionalData data(\\n              parameters.output == Parameters::Solver::verbose);\\n TrilinosWrappers::SolverDirect direct(solver_control, data);\\n \\n            direct.solve(system_matrix, newton_update, right_hand_side);\\n \\n return {solver_control.last_step(), solver_control.last_value()};\\n          }\\n \\n case Parameters::Solver::gmres:\\n          {\\n            Epetra_Vector x(View,\\n                            system_matrix.trilinos_matrix().DomainMap(),\\n                            newton_update.begin());\\n            Epetra_Vector b(View,\\n                            system_matrix.trilinos_matrix().RangeMap(),\\n                            right_hand_side.begin());\\n \\n            AztecOO solver;\\n            solver.SetAztecOption(\\n              AZ_output,\\n              (parameters.output == Parameters::Solver::quiet ? AZ_none :\\n                                                                AZ_all));\\n            solver.SetAztecOption(AZ_solver, AZ_gmres);\\n            solver.SetRHS(&b);\\n            solver.SetLHS(&x);\\n \\n            solver.SetAztecOption(AZ_precond, AZ_dom_decomp);\\n            solver.SetAztecOption(AZ_subdomain_solve, AZ_ilut);\\n            solver.SetAztecOption(AZ_overlap, 0);\\n            solver.SetAztecOption(AZ_reorder, 0);\\n \\n            solver.SetAztecParam(AZ_drop, parameters.ilut_drop);\\n            solver.SetAztecParam(AZ_ilut_fill, parameters.ilut_fill);\\n            solver.SetAztecParam(AZ_athresh, parameters.ilut_atol);\\n            solver.SetAztecParam(AZ_rthresh, parameters.ilut_rtol);\\n \\n            solver.SetUserMatrix(\\n const_cast<Epetra_CrsMatrix *>(&system_matrix.trilinos_matrix()));\\n \\n            solver.Iterate(parameters.max_iterations,\\n                           parameters.linear_residual);\\n \\n return {solver.NumIters(), solver.TrueResidual()};\\n          }\\n      }\\n \\n DEAL_II_NOT_IMPLEMENTED();\\n return {0, 0};\\n  }\\n \\n \\n \\n template <int dim>\\n void ConservationLaw<dim>::compute_refinement_indicators(\\n Vector<double> &refinement_indicators) const\\n {\\n    EulerEquations<dim>::compute_refinement_indicators(dof_handler,\\n                                                       mapping,\\n                                                       predictor,\\n                                                       refinement_indicators);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void\\n  ConservationLaw<dim>::refine_grid(const Vector<double> &refinement_indicators)\\n  {\\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n const unsigned int cell_no = cell->active_cell_index();\\n        cell->clear_coarsen_flag();\\n        cell->clear_refine_flag();\\n \\n if ((cell->level() < parameters.shock_levels) &&\\n            (std::fabs(refinement_indicators(cell_no)) > parameters.shock_val))\\n          cell->set_refine_flag();\\n else if ((cell->level() > 0) &&\\n                 (std::fabs(refinement_indicators(cell_no)) <\\n                  0.75 * parameters.shock_val))\\n          cell->set_coarsen_flag();\\n      }\\n \\n    {\\n AffineConstraints<double> hanging_node_constraints;\\n DoFTools::make_hanging_node_constraints(dof_handler,\\n                                              hanging_node_constraints);\\n      hanging_node_constraints.close();\\n \\n      hanging_node_constraints.distribute(old_solution);\\n      hanging_node_constraints.distribute(predictor);\\n    }\\n \\n const std::vector<Vector<double>> transfer_in = {old_solution, predictor};\\n \\n triangulation.prepare_coarsening_and_refinement();\\n \\n SolutionTransfer<dim> soltrans(dof_handler);\\n    soltrans.prepare_for_coarsening_and_refinement(transfer_in);\\n \\n triangulation.execute_coarsening_and_refinement();\\n \\n    dof_handler.clear();\\n    dof_handler.distribute_dofs(fe);\\n \\n    std::vector<Vector<double>> transfer_out = {\\n Vector<double>(dof_handler.n_dofs()),\\n Vector<double>(dof_handler.n_dofs())};\\n    soltrans.interpolate(transfer_in, transfer_out);\\n \\n    old_solution = std::move(transfer_out[0]);\\n    predictor    = std::move(transfer_out[1]);\\n \\n    current_solution.reinit(dof_handler.n_dofs());\\n    current_solution = old_solution;\\n \\n    right_hand_side.reinit(dof_handler.n_dofs());\\n  }\\n \\n \\n \\n template <int dim>\\n void ConservationLaw<dim>::output_results() const\\n {\\n typename EulerEquations<dim>::Postprocessor postprocessor(\\n      parameters.schlieren_plot);\\n \\n DataOut<dim> data_out;\\n    data_out.attach_dof_handler(dof_handler);\\n \\n    data_out.add_data_vector(current_solution,\\n                             EulerEquations<dim>::component_names(),\\n DataOut<dim>::type_dof_data,\\n                             EulerEquations<dim>::component_interpretation());\\n \\n    data_out.add_data_vector(current_solution, postprocessor);\\n \\n    data_out.build_patches();\\n \\n static unsigned int output_file_number = 0;\\n    std::string         filename =\\n \\\"solution-\\\" + Utilities::int_to_string(output_file_number, 3) + \\\".vtk\\\";\\n    std::ofstream output(filename);\\n    data_out.write_vtk(output);\\n \\n    ++output_file_number;\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void ConservationLaw<dim>::run()\\n  {\\n    {\\n GridIn<dim> grid_in;\\n      grid_in.attach_triangulation(triangulation);\\n \\n      std::ifstream input_file(parameters.mesh_filename);\\n Assert(input_file, ExcFileNotOpen(parameters.mesh_filename));\\n \\n      grid_in.read_ucd(input_file);\\n    }\\n \\n    dof_handler.distribute_dofs(fe);\\n \\n    old_solution.reinit(dof_handler.n_dofs());\\n    current_solution.reinit(dof_handler.n_dofs());\\n    predictor.reinit(dof_handler.n_dofs());\\n    right_hand_side.reinit(dof_handler.n_dofs());\\n \\n    setup_system();\\n \\n VectorTools::interpolate(dof_handler,\\n                             parameters.initial_conditions,\\n                             old_solution);\\n    current_solution = old_solution;\\n    predictor        = old_solution;\\n \\n if (parameters.do_refine == true)\\n for (unsigned int i = 0; i < parameters.shock_levels; ++i)\\n        {\\n Vector<double> refinement_indicators(triangulation.n_active_cells());\\n \\n          compute_refinement_indicators(refinement_indicators);\\n          refine_grid(refinement_indicators);\\n \\n          setup_system();\\n \\n VectorTools::interpolate(dof_handler,\\n                                   parameters.initial_conditions,\\n                                   old_solution);\\n          current_solution = old_solution;\\n          predictor        = old_solution;\\n        }\\n \\n    output_results();\\n \\n Vector<double> newton_update(dof_handler.n_dofs());\\n \\n double time        = 0;\\n double next_output = time + parameters.output_step;\\n \\n    predictor = old_solution;\\n while (time < parameters.final_time)\\n      {\\n        std::cout << \\\"T=\\\" << time << std::endl\\n                  << \\\"   Number of active cells:       \\\"\\n                  << triangulation.n_active_cells() << std::endl\\n                  << \\\"   Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n                  << std::endl\\n                  << std::endl;\\n \\n        std::cout << \\\"   NonLin Res     Lin Iter       Lin Res\\\" << std::endl\\n                  << \\\"   _____________________________________\\\" << std::endl;\\n \\n unsigned int nonlin_iter = 0;\\n        current_solution         = predictor;\\n while (true)\\n          {\\n            system_matrix = 0;\\n \\n            right_hand_side = 0;\\n            assemble_system();\\n \\n const double res_norm = right_hand_side.l2_norm();\\n if (std::fabs(res_norm) < 1e-10)\\n              {\\n                std::printf(\\\"   %-16.3e (converged)\\\\n\\\\n\\\", res_norm);\\n break;\\n              }\\n else\\n              {\\n                newton_update = 0;\\n \\n                std::pair<unsigned int, double> convergence =\\n                  solve(newton_update);\\n \\n                current_solution += newton_update;\\n \\n                std::printf(\\\"   %-16.3e %04d        %-5.2e\\\\n\\\",\\n                            res_norm,\\n                            convergence.first,\\n                            convergence.second);\\n              }\\n \\n            ++nonlin_iter;\\n AssertThrow(nonlin_iter <= 10,\\n                        ExcMessage(\\\"No convergence in nonlinear solver\\\"));\\n          }\\n \\n        time += parameters.time_step;\\n \\n if (parameters.output_step < 0)\\n          output_results();\\n else if (time >= next_output)\\n          {\\n            output_results();\\n            next_output += parameters.output_step;\\n          }\\n \\n        predictor = current_solution;\\n        predictor.sadd(2.0, -1.0, old_solution);\\n \\n        old_solution = current_solution;\\n \\n if (parameters.do_refine == true)\\n          {\\n Vector<double> refinement_indicators(\\n triangulation.n_active_cells());\\n            compute_refinement_indicators(refinement_indicators);\\n \\n            refine_grid(refinement_indicators);\\n            setup_system();\\n \\n            newton_update.reinit(dof_handler.n_dofs());\\n          }\\n      }\\n  }\\n} // namespace Step33\\n \\n \\nint main(int argc, char *argv[])\\n{\\n try\\n    {\\n using namespace dealii;\\n using namespace Step33;\\n \\n if (argc != 2)\\n        {\\n          std::cout << \\\"Usage:\\\" << argv[0] << \\\" input_file\\\" << std::endl;\\n          std::exit(1);\\n        }\\n \\n Utilities::MPI::MPI_InitFinalize mpi_initialization(\\n        argc, argv, numbers::invalid_unsigned_int);\\n \\n AssertThrow(\\n Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) == 1,\\n        ExcMessage(\\n \\\"This program does not support parallel computing via MPI.\\\"));\\n \\n      ConservationLaw<2> cons(argv[1]);\\n      cons.run();\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    };\\n \\n return 0;\\n}\\nAffineConstraints::closevoid close()\\nAffineConstraints::distributevoid distribute(VectorType &vec) const\\nDataOutInterface::write_vtkvoid write_vtk(std::ostream &out) constDefinition data_out_base.cc:7681\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nFEValuesBase::get_cellTriangulation< dim, spacedim >::cell_iterator get_cell() constDefinition fe_values_base.cc:1289\\nFEValuesBase::get_quadrature_pointsconst std::vector< Point< spacedim > > & get_quadrature_points() const\\nFEValuesBase::dofs_per_cellconst unsigned int dofs_per_cellDefinition fe_values_base.h:192\\nFEValuesBase::normal_vectorconst Tensor< 1, spacedim > & normal_vector(const unsigned int q_point) const\\nFEValuesBase::shape_value_componentdouble shape_value_component(const unsigned int i, const unsigned int q_point, const unsigned int component) const\\nFEValuesBase::n_quadrature_pointsconst unsigned int n_quadrature_pointsDefinition fe_values_base.h:174\\nFEValuesBase::shape_grad_componentTensor< 1, spacedim > shape_grad_component(const unsigned int i, const unsigned int q_point, const unsigned int component) const\\nFEValuesBase::get_feconst FiniteElement< dim, spacedim > & get_fe() const\\nFEValuesBase::JxWdouble JxW(const unsigned int q_point) const\\nFiniteElement::has_support_on_facevirtual bool has_support_on_face(const unsigned int shape_index, const unsigned int face_index) const\\nFiniteElement::system_to_component_indexstd::pair< unsigned int, unsigned int > system_to_component_index(const unsigned int index) const\\nGridIn::read_ucdvoid read_ucd(std::istream &in, const bool apply_all_indicators_to_manifolds=false)Definition grid_in.cc:914\\nconditional_ostream.h\\ndof_handler.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nfe_values.h\\nfe_q.h\\nfe_system.h\\nfunction.h\\nfunction_parser.h\\ngrid_refinement.h\\ntria.h\\ngrid_generator.h\\ngrid_in.h\\ngrid_out.h\\nutilities.h\\nmapping_q1.h\\nOpenCASCADE::pointPoint< spacedim > point(const gp_Pnt &p, const double tolerance=1e-10)Definition utilities.cc:191\\nPhysics::Elasticity::Kinematics::eSymmetricTensor< 2, dim, Number > e(const Tensor< 2, dim, Number > &F)\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\ndata_out.h\\nsolution_transfer.h\\nparameter_handler.h\\nquadrature_lib.h\\nDataPostprocessorInputs::Vector::solution_valuesstd::vector<::Vector< double > > solution_valuesDefinition data_postprocessor.h:410\\nDataPostprocessorInputs::Vector::solution_gradientsstd::vector< std::vector< Tensor< 1, spacedim > > > solution_gradientsDefinition data_postprocessor.h:429\\ntrilinos_precondition.h\\ntrilinos_solver.h\\ntrilinos_sparse_matrix.h\\nvector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"