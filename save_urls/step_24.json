"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_24.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-24 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-24 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-24 tutorial program\\n\\n\\nThis tutorial depends on step-23.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nThe problem\\nWeak form and discretization\\nWhat the program does\\nAppendix: PDEs with Dirac delta functions as right hand side and their transformation to an initial value problem\\n\\n The commented program\\n\\nInclude files\\nThe \\\"forward problem\\\" class template\\nEquation data\\nImplementation of the TATForwardProblem class\\n\\nTATForwardProblem::setup_system\\nTATForwardProblem::solve_p and TATForwardProblem::solve_v\\nTATForwardProblem::output_results\\nTATForwardProblem::run\\n\\nThe main function\\n\\n\\n Results\\n\\n One absorber \\nMultiple absorbers\\n\\n The plain program\\n   \\n Introduction\\nThis program grew out of a student project by Xing Jin at Texas A&M University. Most of the work for this program is by her. Some of the work on this tutorial program has been funded by NSF under grant DMS-0604778.\\nThe program is part of a project that aims to simulate thermoacoustic tomography imaging. In thermoacoustic tomography, pulsed electromagnetic energy is delivered into biological issues. Tissues absorb some of this energy and those parts of the tissue that absorb the most energy generate thermoacoustic waves through thermoelastic expansion. For imaging, one uses that different kinds of tissue, most importantly healthy and diseased tissue, absorb different amounts of energy and therefore expand at different rates. The experimental setup is to measure the amplitude of the pressure waves generated by these sources on the surface of the tissue and try to reconstruct the source distributions, which is indicative for the distribution of absorbers and therefore of different kinds of tissue. Part of this project is to compare simulated data with actual measurements, so one has to solve the \\\"forward problem\\\", i.e. the wave equation that describes the propagation of pressure waves in tissue. This program is therefore a continuation of step-23, where the wave equation was first introduced.\\nThe problem\\nThe temperature at a given location, neglecting thermal diffusion, can be stated as\\n\\n\\\\[\\n\\\\rho C_p \\\\frac{\\\\partial}{\\\\partial t}T(t,\\\\mathbf r) = H(t,\\\\mathbf r)\\n\\\\]\\n\\nHere \\\\(\\\\rho (\\\\mathbf r) \\\\) is the density; \\\\(C_p (\\\\mathbf r) \\\\) is the specific heat; \\\\(\\\\frac{\\\\partial T}{\\\\partial t}(t,\\\\mathbf r)\\\\) is the temperature rise due to the delivered microwave energy; and \\\\(H(t,\\\\mathbf r)\\\\) is the heating function defined as the thermal energy per time and volume transformed from deposited microwave energy.\\nLet us assume that tissues have heterogeneous dielectric properties but homogeneous acoustic properties. The basic acoustic generation equation in an acoustically homogeneous medium can be described as follows: if \\\\(u\\\\) is the vector-valued displacement, then tissue certainly reacts to changes in pressure by acceleration:    \\n\\\\[\\n\\\\rho \\\\frac{\\\\partial^2}{\\\\partial t^2}u(t,\\\\mathbf r) =\\n-\\\\nabla p(t,\\\\mathbf r).\\n\\\\]\\n\\n Furthermore, it contracts due to excess pressure and expands based on changes in temperature:   \\n\\\\[\\n\\\\nabla \\\\cdot u(t,\\\\mathbf r) = -\\\\frac{p(t,\\\\mathbf r)}{\\\\rho c_0^2}+\\\\beta T(t,\\\\mathbf r) .\\n\\\\]\\n\\n Here, \\\\(\\\\beta\\\\) is a thermoexpansion coefficient.\\nLet us now make the assumption that heating only happens on a time scale much shorter than wave propagation through tissue (i.e. the temporal length of the microwave pulse that heats the tissue is much shorter than the time it takes a wave to cross the domain). In that case, the heating rate \\\\(H(t,\\\\mathbf r)\\\\) can be written as  \\\\(H(t,\\\\mathbf r) = a(\\\\mathbf\\nr)\\\\delta(t)\\\\) (where \\\\(a(\\\\mathbf r)\\\\) is a map of absorption strengths for microwave energy and \\\\(\\\\delta(t)\\\\) is the Dirac delta function), which together with the first equation above will yield an instantaneous jump in the temperature \\\\(T(\\\\mathbf r)\\\\) at time \\\\(t=0\\\\). Using this assumption, and taking all equations together, we can rewrite and combine the above as follows:    \\n\\\\[\\n\\\\Delta p-\\\\frac{1}{c_0^2} \\\\frac{\\\\partial^2 p}{\\\\partial t^2} = \\\\lambda\\na(\\\\mathbf r)\\\\frac{d\\\\delta(t)}{dt}\\n\\\\]\\n\\n where \\\\(\\\\lambda = - \\\\frac{\\\\beta}{C_p}\\\\).\\nThis somewhat strange equation with the derivative of a Dirac delta function on the right hand side can be rewritten as an initial value problem as follows:      \\n\\\\begin{eqnarray*}\\n\\\\Delta \\\\bar{p}- \\\\frac{1}{c_0^2} \\\\frac{\\\\partial^2 \\\\bar{p}}{\\\\partial t^2} & = &\\n0 \\\\\\\\\\n\\\\bar{p}(0,\\\\mathbf r) &=& c_0^2 \\\\lambda a(\\\\mathbf r) = b(\\\\mathbf r)  \\\\\\\\\\n\\\\frac{\\\\partial\\\\bar{p}(0,\\\\mathbf r)}{\\\\partial t} &=& 0.\\n\\\\end{eqnarray*}\\n\\n (A derivation of this transformation into an initial value problem is given at the end of this introduction as an appendix.)\\nIn the inverse problem, it is the initial condition \\\\(b(\\\\mathbf r) = c_0^2 \\\\lambda a(\\\\mathbf r)\\\\) that one would like to recover, since it is a map of absorption strengths for microwave energy, and therefore presumably an indicator to discern healthy from diseased tissue.\\nIn real application, the thermoacoustic source is very small as compared to the medium. The propagation path of the thermoacoustic waves can then be approximated as from the source to the infinity. Furthermore, detectors are only a limited distance from the source. One only needs to evaluate the values when the thermoacoustic waves pass through the detectors, although they do continue beyond. This is therefore a problem where we are only interested in a small part of an infinite medium, and we do not want waves generated somewhere to be reflected at the boundary of the domain which we consider interesting. Rather, we would like to simulate only that part of the wave field that is contained inside the domain of interest, and waves that hit the boundary of that domain to simply pass undisturbed through the boundary. In other words, we would like the boundary to absorb any waves that hit it.\\nIn general, this is a hard problem: Good absorbing boundary conditions are nonlinear and/or numerically very expensive. We therefore opt for a simple first order approximation to absorbing boundary conditions that reads    \\n\\\\[\\n\\\\frac{\\\\partial\\\\bar{p}}{\\\\partial\\\\mathbf n} =\\n-\\\\frac{1}{c_0} \\\\frac{\\\\partial\\\\bar{p}}{\\\\partial t}\\n\\\\]\\n\\n Here, \\\\(\\\\frac{\\\\partial\\\\bar{p}}{\\\\partial\\\\mathbf n}\\\\) is the normal derivative at the boundary. It should be noted that this is not a particularly good boundary condition, but it is one of the very few that are reasonably simple to implement.\\nWeak form and discretization\\nAs in step-23, one first introduces a second variable, which is defined as the derivative of the pressure potential:   \\n\\\\[\\nv = \\\\frac{\\\\partial\\\\bar{p}}{\\\\partial t}\\n\\\\]\\n\\nWith the second variable, one then transforms the forward problem into two separate equations:    \\n\\\\begin{eqnarray*}\\n\\\\bar{p}_{t} - v & = & 0 \\\\\\\\\\n\\\\Delta\\\\bar{p} - \\\\frac{1}{c_0^2}\\\\,v_{t} & = & f\\n\\\\end{eqnarray*}\\n\\n with initial conditions:    \\n\\\\begin{eqnarray*}\\n\\\\bar{p}(0,\\\\mathbf r) & = & b(r) \\\\\\\\\\nv(0,\\\\mathbf r)=\\\\bar{p}_t(0,\\\\mathbf r) & = & 0.\\n\\\\end{eqnarray*}\\n\\n Note that we have introduced a right hand side \\\\(f(t,\\\\mathbf r)\\\\) here to show how to derive these formulas in the general case, although in the application to the thermoacoustic problem \\\\(f=0\\\\).\\nThe semi-discretized, weak version of this model, using the general \\\\(\\\\theta\\\\) scheme introduced in step-23 is then:        \\n\\\\begin{eqnarray*}\\n\\\\left(\\\\frac{\\\\bar{p}^n-\\\\bar{p}^{n-1}}{k},\\\\phi\\\\right)_\\\\Omega-\\n\\\\left(\\\\theta v^{n}+(1-\\\\theta)v^{n-1},\\\\phi\\\\right)_\\\\Omega & = & 0   \\\\\\\\\\n-\\\\left(\\\\nabla((\\\\theta\\\\bar{p}^n+(1-\\\\theta)\\\\bar{p}^{n-1})),\\\\nabla\\\\phi\\\\right)_\\\\Omega-\\n\\\\frac{1}{c_0}\\\\left(\\\\frac{\\\\bar{p}^n-\\\\bar{p}^{n-1}}{k},\\\\phi\\\\right)_{\\\\partial\\\\Omega} -\\n\\\\frac{1}{c_0^2}\\\\left(\\\\frac{v^n-v^{n-1}}{k},\\\\phi\\\\right)_\\\\Omega & =\\n& \\\\left(\\\\theta f^{n}+(1-\\\\theta)f^{n-1}, \\\\phi\\\\right)_\\\\Omega,\\n\\\\end{eqnarray*}\\n\\n where \\\\(\\\\phi\\\\) is an arbitrary test function, and where we have used the absorbing boundary condition to integrate by parts: absorbing boundary conditions are incorporated into the weak form by using     \\n\\\\[\\n\\\\int_\\\\Omega\\\\varphi \\\\, \\\\Delta p\\\\; dx =\\n-\\\\int_\\\\Omega\\\\nabla \\\\varphi \\\\cdot \\\\nabla p dx +\\n\\\\int_{\\\\partial\\\\Omega}\\\\varphi \\\\frac{\\\\partial p}{\\\\partial {\\\\mathbf n}}ds.\\n\\\\]\\n\\nFrom this we obtain the discrete model by introducing a finite number of shape functions, and get     \\n\\\\begin{eqnarray*}\\nM\\\\bar{p}^{n}-k \\\\theta M v^n & = & M\\\\bar{p}^{n-1}+k (1-\\\\theta)Mv^{n-1},\\\\\\\\\\n(-c_0^2k \\\\theta A-c_0 B)\\\\bar{p}^n-Mv^{n} & = &\\n(c_0^2k(1-\\\\theta)A-c_0B)\\\\bar{p}^{n-1}-Mv^{n-1}+c_0^2k(\\\\theta F^{n}+(1-\\\\theta)F^{n-1}).\\n\\\\end{eqnarray*}\\n\\n The matrices \\\\(M\\\\) and \\\\(A\\\\) are here as in step-23, and the boundary mass matrix   \\n\\\\[\\n        B_{ij} = \\\\left(\\\\varphi_i,\\\\varphi_j\\\\right)_{\\\\partial\\\\Omega}\\n\\\\]\\n\\n results from the use of absorbing boundary conditions.\\nAbove two equations can be rewritten in a matrix form with the pressure and its derivative as an unknown vector:              \\n\\\\[\\n\\\\left(\\\\begin{array}{cc}\\n M         &       -k\\\\theta M \\\\\\\\\\nc_0^2\\\\,k\\\\,\\\\theta\\\\,A+c_0\\\\,B  &  M   \\\\\\\\\\n               \\\\end{array} \\\\right)\\\\\\\\\\n\\\\left(\\\\begin{array}{c}\\n \\\\bar{p}^{n}    \\\\\\\\\\n \\\\bar{v}^{n}\\n              \\\\end{array}\\\\right)=\\\\\\\\\\n\\\\left(\\\\begin{array}{l}\\n G_1  \\\\\\\\\\n G_2 -(\\\\theta F^{n}+(1-\\\\theta)F ^{n-1})c_{0}^{2}k \\\\\\\\\\n                \\\\end{array}\\\\right)\\n\\\\]\\n\\nwhere          \\n\\\\[\\n\\\\left(\\\\begin{array}{c}\\nG_1 \\\\\\\\\\nG_2 \\\\\\\\\\n   \\\\end{array} \\\\right)=\\\\\\\\\\n\\\\left(\\\\begin{array}{l}\\n M\\\\bar{p}^{n-1}+k(1-\\\\theta)Mv^{n-1}\\\\\\\\\\n (-c_{0}^{2}k (1-\\\\theta)A+c_0 B)\\\\bar{p}^{n-1} +Mv^{n-1}\\n                \\\\end{array}\\\\right)\\n\\\\]\\n\\nBy simple transformations, one then obtains two equations for the pressure potential and its derivative, just as in the previous tutorial program:      \\n\\\\begin{eqnarray*}\\n(M+(k\\\\,\\\\theta\\\\,c_{0})^{2}A+c_0k\\\\theta B)\\\\bar{p}^{n} & = &\\nG_{1}+(k\\\\, \\\\theta)G_{2}-(c_0k)^2\\\\theta (\\\\theta F^{n}+(1-\\\\theta)F^{n-1}) \\\\\\\\\\nMv^n & = & -(c_0^2\\\\,k\\\\, \\\\theta\\\\, A+c_0B)\\\\bar{p}^{n}+ G_2 -\\nc_0^2k(\\\\theta F^{n}+(1-\\\\theta)F^{n-1})\\n\\\\end{eqnarray*}\\n\\nWhat the program does\\nCompared to step-23, this programs adds the treatment of a simple absorbing boundary conditions. In addition, it deals with data obtained from actual experimental measurements. To this end, we need to evaluate the solution at points at which the experiment also evaluates a real pressure field. We will see how to do that using the VectorTools::point_value function further down below.\\nAppendix: PDEs with Dirac delta functions as right hand side and their transformation to an initial value problem\\nIn the derivation of the initial value problem for the wave equation, we initially found that the equation had the derivative of a Dirac delta function as a right hand side:    \\n\\\\[\\n\\\\Delta p-\\\\frac{1}{c_0^2} \\\\frac{\\\\partial^2 p}{\\\\partial t^2} = \\\\lambda\\na(\\\\mathbf r)\\\\frac{d\\\\delta(t)}{dt}.\\n\\\\]\\n\\n In order to see how to transform this single equation into the usual statement of a PDE with initial conditions, let us make the assumption that the physically quite reasonable medium is at rest initially, i.e.  \\\\(p(t,\\\\mathbf\\nr)=\\\\frac{\\\\partial p(t,\\\\mathbf r)}{\\\\partial t}=0\\\\) for \\\\(t<0\\\\). Next, let us form the indefinite integral with respect to time of both sides:      \\n\\\\[\\n\\\\int^t \\\\Delta p\\\\; dt -\\\\int^t \\\\frac{1}{c_0^2} \\\\frac{\\\\partial^2 p}{\\\\partial t^2}\\n\\\\; dt\\n=\\n\\\\int^t \\\\lambda a(\\\\mathbf r)\\\\frac{d\\\\delta(t)}{dt} \\\\;dt.\\n\\\\]\\n\\n This immediately leads to the statement     \\n\\\\[\\nP(t,\\\\mathbf r) - \\\\frac{1}{c_0^2} \\\\frac{\\\\partial p}{\\\\partial t}\\n=\\n\\\\lambda a(\\\\mathbf r) \\\\delta(t),\\n\\\\]\\n\\n where \\\\(P(t,\\\\mathbf r)\\\\) is such that  \\\\(\\\\frac{dP(t,\\\\mathbf r)}{dt}=\\\\Delta\\np\\\\). Next, we form the (definite) integral over time from \\\\(t=-\\\\epsilon\\\\) to \\\\(t=+\\\\epsilon\\\\) to find      \\n\\\\[\\n\\\\int_{-\\\\epsilon}^{\\\\epsilon} P(t,\\\\mathbf r)\\\\; dt\\n- \\\\frac{1}{c_0^2} \\\\left[ p(\\\\epsilon,\\\\mathbf r) - p(-\\\\epsilon,\\\\mathbf r) \\\\right]\\n=\\n\\\\int_{-\\\\epsilon}^{\\\\epsilon} \\\\lambda a(\\\\mathbf r) \\\\delta(t) \\\\; dt.\\n\\\\]\\n\\n If we use the property of the delta function that  \\\\(\\\\int_{-\\\\epsilon}^{\\\\epsilon}\\n\\\\delta(t)\\\\; dt = 1\\\\), and assume that \\\\(P\\\\) is a continuous function in time, we find as we let \\\\(\\\\epsilon\\\\) go to zero that     \\n\\\\[\\n- \\\\lim_{\\\\epsilon\\\\rightarrow 0}\\\\frac{1}{c_0^2} \\\\left[ p(\\\\epsilon,\\\\mathbf r) - p(-\\\\epsilon,\\\\mathbf r) \\\\right]\\n=\\n\\\\lambda a(\\\\mathbf r).\\n\\\\]\\n\\n In other words, using that \\\\(p(-\\\\epsilon,\\\\mathbf r)=0\\\\), we retrieve the initial condition     \\n\\\\[\\n  \\\\frac{1}{c_0^2} p(0,\\\\mathbf r)\\n  =\\n  \\\\lambda a(\\\\mathbf r).\\n\\\\]\\n\\n At the same time, we know that for every \\\\(t>0\\\\) the delta function is zero, so for \\\\(0<t<T\\\\) we get the equation   \\n\\\\[\\n\\\\Delta p-\\\\frac{1}{c_0^2} \\\\frac{\\\\partial^2 p}{\\\\partial t^2} = 0.\\n\\\\]\\n\\n Consequently, we have obtained a representation of the wave equation and one initial condition from the original somewhat strange equation.\\nFinally, because we here have an equation with two time derivatives, we still need a second initial condition. To this end, let us go back to the equation    \\n\\\\[\\n\\\\Delta p-\\\\frac{1}{c_0^2} \\\\frac{\\\\partial^2 p}{\\\\partial t^2} = \\\\lambda\\na(\\\\mathbf r)\\\\frac{d\\\\delta(t)}{dt}.\\n\\\\]\\n\\n and integrate it in time from \\\\(t=-\\\\epsilon\\\\) to \\\\(t=+\\\\epsilon\\\\). This leads to      \\n\\\\[\\nP(\\\\epsilon)-P(-\\\\epsilon)\\n-\\\\frac{1}{c_0^2} \\\\left[\\\\frac{\\\\partial p(\\\\epsilon)}{\\\\partial t} -\\n                       \\\\frac{\\\\partial p(-\\\\epsilon)}{\\\\partial t}\\\\right]\\n = \\\\lambda a(\\\\mathbf r) \\\\int_{-\\\\epsilon}^{\\\\epsilon}\\\\frac{d\\\\delta(t)}{dt} \\\\; dt.\\n\\\\]\\n\\n Using integration by parts of the form     \\n\\\\[\\n  \\\\int_{-\\\\epsilon}^{\\\\epsilon}\\\\varphi(t)\\\\frac{d\\\\delta(t)}{dt} \\\\; dt\\n  =\\n  -\\\\int_{-\\\\epsilon}^{\\\\epsilon}\\\\frac{d\\\\varphi(t)}{dt} \\\\delta(t)\\\\; dt\\n\\\\]\\n\\n where we use that \\\\(\\\\delta(\\\\pm \\\\epsilon)=0\\\\) and inserting \\\\(\\\\varphi(t)=1\\\\), we see that in fact     \\n\\\\[\\n  \\\\int_{-\\\\epsilon}^{\\\\epsilon}\\\\frac{d\\\\delta(t)}{dt} \\\\; dt\\n  =\\n  0.\\n\\\\]\\n\\nNow, let \\\\(\\\\epsilon\\\\rightarrow 0\\\\). Assuming that \\\\(P\\\\) is a continuous function in time, we see that   \\n\\\\[\\n  P(\\\\epsilon)-P(-\\\\epsilon) \\\\rightarrow 0,\\n\\\\]\\n\\n and consequently     \\n\\\\[\\n  \\\\frac{\\\\partial p(\\\\epsilon)}{\\\\partial t} -\\n                       \\\\frac{\\\\partial p(-\\\\epsilon)}{\\\\partial t}\\n                       \\\\rightarrow 0.\\n\\\\]\\n\\n However, we have assumed that \\\\(\\\\frac{\\\\partial p(-\\\\epsilon)}{\\\\partial t}=0\\\\). Consequently, we obtain as the second initial condition that   \\n\\\\[\\n  \\\\frac{\\\\partial p(0)}{\\\\partial t} = 0,\\n\\\\]\\n\\n completing the system of equations.\\n The commented program\\n Include files\\nThe following have all been covered previously:\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/base/utilities.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/solver_cg.h>\\n\\u00a0 #include <deal.II/lac/precondition.h>\\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/matrix_creator.h>\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 \\n\\u00a0 #include <fstream>\\n\\u00a0 #include <iostream>\\n\\u00a0 \\nThis is the only new one: We will need a library function defined in the namespace GridTools that computes the minimal cell diameter.\\n\\u00a0 #include <deal.II/grid/grid_tools.h>\\n\\u00a0 \\nThe last step is as in all previous programs:\\n\\u00a0 namespace Step24\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n The \\\"forward problem\\\" class template\\nThe first part of the main class is exactly as in step-23 (except for the name):\\n\\u00a0   template <int dim>\\n\\u00a0   class TATForwardProblem\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     TATForwardProblem();\\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void setup_system();\\n\\u00a0     void solve_p();\\n\\u00a0     void solve_v();\\n\\u00a0     void output_results() const;\\n\\u00a0 \\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0     const FE_Q<dim>    fe;\\n\\u00a0     DoFHandler<dim>    dof_handler;\\n\\u00a0 \\n\\u00a0     AffineConstraints<double> constraints;\\n\\u00a0 \\n\\u00a0     SparsityPattern      sparsity_pattern;\\n\\u00a0     SparseMatrix<double> system_matrix;\\n\\u00a0     SparseMatrix<double> mass_matrix;\\n\\u00a0     SparseMatrix<double> laplace_matrix;\\n\\u00a0 \\n\\u00a0     Vector<double> solution_p, solution_v;\\n\\u00a0     Vector<double> old_solution_p, old_solution_v;\\n\\u00a0     Vector<double> system_rhs_p, system_rhs_v;\\n\\u00a0 \\n\\u00a0     double       time_step, time;\\n\\u00a0     unsigned int timestep_number;\\n\\u00a0     const double theta;\\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nDoFHandlerDefinition dof_handler.h:317\\nFE_QDefinition fe_q.h:554\\nSparseMatrixDefinition sparse_matrix.h:520\\nSparsityPatternDefinition sparsity_pattern.h:343\\nTriangulationDefinition tria.h:1323\\nVectorDefinition vector.h:120\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\nHere's what's new: first, we need that boundary mass matrix \\\\(B\\\\) that came out of the absorbing boundary condition. Likewise, since this time we consider a realistic medium, we must have a measure of the wave speed \\\\(c_0\\\\) that will enter all the formulas with the Laplace matrix (which we still define as \\\\((\\\\nabla \\\\phi_i,\\\\nabla \\\\phi_j)\\\\)):\\n\\u00a0     SparseMatrix<double> boundary_matrix;\\n\\u00a0     const double         wave_speed;\\n\\u00a0 \\nThe last thing we have to take care of is that we wanted to evaluate the solution at a certain number of detector locations. We need an array to hold these locations, declared here and filled in the constructor:\\n\\u00a0     std::vector<Point<dim>> detector_locations;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n Equation data\\nAs usual, we have to define our initial values, boundary conditions, and right hand side functions. Things are a bit simpler this time: we consider a problem that is driven by initial conditions, so there is no right hand side function (though you could look up in step-23 to see how this can be done). Secondly, there are no boundary conditions: the entire boundary of the domain consists of absorbing boundary conditions. That only leaves initial conditions, and there things are simple too since for this particular application only nonzero initial conditions for the pressure are prescribed, not for the velocity (which is zero at the initial time).\\nSo this is all we need: a class that specifies initial conditions for the pressure. In the physical setting considered in this program, these are small absorbers, which we model as a series of little circles where we assume that the pressure surplus is one, whereas no absorption and therefore no pressure surplus is everywhere else. This is how we do things (note that if we wanted to expand this program to not only compile but also to run, we would have to initialize the sources with three-dimensional source locations):\\n\\u00a0   template <int dim>\\n\\u00a0   class InitialValuesP : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     virtual double value(const Point<dim> &p,\\n\\u00a0                          const unsigned int /*component*/ = 0) const override\\n\\u00a0     {\\n\\u00a0       static const std::array<Source, 5> sources{\\n\\u00a0         {Source(Point<dim>(0, 0), 0.025),\\n\\u00a0          Source(Point<dim>(-0.135, 0), 0.05),\\n\\u00a0          Source(Point<dim>(0.17, 0), 0.03),\\n\\u00a0          Source(Point<dim>(-0.25, 0), 0.02),\\n\\u00a0          Source(Point<dim>(-0.05, -0.15), 0.015)}};\\n\\u00a0 \\n\\u00a0       for (const auto &source : sources)\\n\\u00a0         if (p.distance(source.location) < source.radius)\\n\\u00a0           return 1;\\n\\u00a0 \\n\\u00a0       return 0;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     struct Source\\n\\u00a0     {\\n\\u00a0       Source(const Point<dim> &l, const double r)\\n\\u00a0         : location(l)\\n\\u00a0         , radius(r)\\n\\u00a0       {}\\n\\u00a0 \\n\\u00a0       const Point<dim> location;\\n\\u00a0       const double     radius;\\n\\u00a0     };\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\nFunctionDefinition function.h:152\\nFunction::valuevirtual RangeNumberType value(const Point< dim > &p, const unsigned int component=0) const\\nPointDefinition point.h:111\\nPhysics::Elasticity::Kinematics::lTensor< 2, dim, Number > l(const Tensor< 2, dim, Number > &F, const Tensor< 2, dim, Number > &dF_dt)\\n Implementation of the TATForwardProblem class\\nLet's start again with the constructor. Setting the member variables is straightforward. We use the acoustic wave speed of mineral oil (in millimeters per microsecond, a common unit in experimental biomedical imaging) since this is where many of the experiments we want to compare the output with are made in. The Crank-Nicolson scheme is used again, i.e. theta is set to 0.5. The time step is later selected to satisfy  \\\\(k =\\n   \\\\frac hc\\\\): here we initialize it to an invalid number.\\n\\u00a0   template <int dim>\\n\\u00a0   TATForwardProblem<dim>::TATForwardProblem()\\n\\u00a0     : fe(1)\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0     , time_step(std::numeric_limits<double>::quiet_NaN())\\n\\u00a0     , time(time_step)\\n\\u00a0     , timestep_number(1)\\n\\u00a0     , theta(0.5)\\n\\u00a0     , wave_speed(1.437)\\n\\u00a0   {\\nstdSTL namespace.\\nThe second task in the constructor is to initialize the array that holds the detector locations. The results of this program were compared with experiments in which the step size of the detector spacing is 2.25 degree, corresponding to 160 detector locations. The radius of the scanning circle is selected to be half way between the center and the boundary to avoid that the remaining reflections from the imperfect boundary condition spoils our numerical results.\\nThe locations of the detectors are then calculated in clockwise order. Note that the following of course only works if we are computing in 2d, a condition that we guard with an assertion. If we later wanted to run the same program in 3d, we would have to add code here for the initialization of detector locations in 3d. Due to the assertion, there is no way we can forget to do this.\\n\\u00a0     Assert(dim == 2, ExcNotImplemented());\\n\\u00a0 \\n\\u00a0     const double detector_step_angle = 2.25;\\n\\u00a0     const double detector_radius     = 0.5;\\n\\u00a0 \\n\\u00a0     for (double detector_angle = 2 * numbers::PI; detector_angle >= 0;\\n\\u00a0          detector_angle -= detector_step_angle / 360 * 2 * numbers::PI)\\n\\u00a0       detector_locations.push_back(\\n\\u00a0         Point<dim>(std::cos(detector_angle), std::sin(detector_angle)) *\\n\\u00a0         detector_radius);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\nnumbers::PIstatic constexpr double PIDefinition numbers.h:259\\nstd::cos::VectorizedArray< Number, width > cos(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6609\\nstd::sin::VectorizedArray< Number, width > sin(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6589\\n TATForwardProblem::setup_system\\nThe following system is pretty much what we've already done in step-23, but with two important differences. First, we have to create a circular (or spherical) mesh around the origin, with a radius of 1. This nothing new: we've done so before in step-6 and step-10, where we also explain how the PolarManifold or SphericalManifold object places new points on concentric circles when a cell is refined, which we will use here as well.\\nOne thing we had to make sure is that the time step satisfies the CFL condition discussed in the introduction of step-23. Back in that program, we ensured this by hand by setting a timestep that matches the mesh width, but that was error prone because if we refined the mesh once more we would also have to make sure the time step is changed. Here, we do that automatically: we ask a library function for the minimal diameter of any cell. Then we set \\\\(k=\\\\frac h{c_0}\\\\). The only problem is: what exactly is \\\\(h\\\\)? The point is that there is really no good theory on this question for the wave equation. It is known that for uniformly refined meshes consisting of rectangles, \\\\(h\\\\) is the minimal edge length. But for meshes on general quadrilaterals, the exact relationship appears to be unknown, i.e. it is unknown what properties of cells are relevant for the CFL condition. The problem is that the CFL condition follows from knowledge of the smallest eigenvalue of the Laplace matrix, and that can only be computed analytically for simply structured meshes.\\nThe upshot of all this is that we're not quite sure what exactly we should take for \\\\(h\\\\). The function GridTools::minimal_cell_diameter computes the minimal diameter of all cells. If the cells were all squares or cubes, then the minimal edge length would be the minimal diameter divided by std::sqrt(dim). We simply generalize this, without theoretical justification, to the case of non-uniform meshes.\\nThe only other significant change is that we need to build the boundary mass matrix. We will comment on this further down below.\\n\\u00a0   template <int dim>\\n\\u00a0   void TATForwardProblem<dim>::setup_system()\\n\\u00a0   {\\n\\u00a0     const Point<dim> center;\\n\\u00a0     GridGenerator::hyper_ball(triangulation, center, 1.);\\n\\u00a0     triangulation.refine_global(7);\\n\\u00a0 \\n\\u00a0     time_step = GridTools::minimal_cell_diameter(triangulation) / wave_speed /\\n\\u00a0                 std::sqrt(1. * dim);\\n\\u00a0 \\n\\u00a0     std::cout << \\\"Number of active cells: \\\" << triangulation.n_active_cells()\\n\\u00a0               << std::endl;\\n\\u00a0 \\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0 \\n\\u00a0     std::cout << \\\"Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n\\u00a0               << std::endl\\n\\u00a0               << std::endl;\\n\\u00a0 \\n\\u00a0     DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());\\n\\u00a0     DoFTools::make_sparsity_pattern(dof_handler, dsp);\\n\\u00a0     sparsity_pattern.copy_from(dsp);\\n\\u00a0 \\n\\u00a0     system_matrix.reinit(sparsity_pattern);\\n\\u00a0     mass_matrix.reinit(sparsity_pattern);\\n\\u00a0     laplace_matrix.reinit(sparsity_pattern);\\n\\u00a0 \\n\\u00a0     MatrixCreator::create_mass_matrix(dof_handler,\\n\\u00a0                                       QGauss<dim>(fe.degree + 1),\\n\\u00a0                                       mass_matrix);\\n\\u00a0     MatrixCreator::create_laplace_matrix(dof_handler,\\n\\u00a0                                          QGauss<dim>(fe.degree + 1),\\n\\u00a0                                          laplace_matrix);\\n\\u00a0 \\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nQGaussDefinition quadrature_lib.h:40\\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\ncenterPoint< 3 > centerDefinition data_out_base.cc:267\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nGridGenerator::hyper_ballvoid hyper_ball(Triangulation< dim > &tria, const Point< dim > &center=Point< dim >(), const double radius=1., const bool attach_spherical_manifold_on_boundary_cells=false)\\nGridTools::minimal_cell_diameterdouble minimal_cell_diameter(const Triangulation< dim, spacedim > &triangulation, const Mapping< dim, spacedim > &mapping=(ReferenceCells::get_hypercube< dim >() .template get_default_linear_mapping< dim, spacedim >()))Definition grid_tools_geometry.cc:407\\nMatrixCreator::create_mass_matrixvoid create_mass_matrix(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const Quadrature< dim > &q, MatrixType &matrix, const Function< spacedim, typename MatrixType::value_type > *const a=nullptr, const AffineConstraints< typename MatrixType::value_type > &constraints=AffineConstraints< typename MatrixType::value_type >())\\nMatrixCreator::create_laplace_matrixvoid create_laplace_matrix(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const Quadrature< dim > &q, MatrixType &matrix, const Function< spacedim, typename MatrixType::value_type > *const a=nullptr, const AffineConstraints< typename MatrixType::value_type > &constraints=AffineConstraints< typename MatrixType::value_type >())\\nstd::sqrt::VectorizedArray< Number, width > sqrt(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6869\\nThe second difference, as mentioned, to step-23 is that we need to build the boundary mass matrix that grew out of the absorbing boundary conditions.\\nA first observation would be that this matrix is much sparser than the regular mass matrix, since none of the shape functions with purely interior support contribute to this matrix. We could therefore optimize the storage pattern to this situation and build up a second sparsity pattern that only contains the nonzero entries that we need. There is a trade-off to make here: first, we would have to have a second sparsity pattern object, so that costs memory. Secondly, the matrix attached to this sparsity pattern is going to be smaller and therefore requires less memory; it would also be faster to perform matrix-vector multiplications with it. The final argument, however, is the one that tips the scale: we are not primarily interested in performing matrix-vector with the boundary matrix alone (though we need to do that for the right hand side vector once per time step), but mostly wish to add it up to the other matrices used in the first of the two equations since this is the one that is going to be multiplied with once per iteration of the CG method, i.e. significantly more often. It is now the case that the SparseMatrix::add class allows to add one matrix to another, but only if they use the same sparsity pattern (the reason being that we can't add nonzero entries to a matrix after the sparsity pattern has been created, so we simply require that the two matrices have the same sparsity pattern).\\nSo let's go with that:\\n\\u00a0     boundary_matrix.reinit(sparsity_pattern);\\n\\u00a0 \\nThe second thing to do is to actually build the matrix. Here, we need to integrate over faces of cells, so first we need a quadrature object that works on dim-1 dimensional objects. Secondly, the FEFaceValues variant of FEValues that works on faces, as its name suggest. And finally, the other variables that are part of the assembly machinery. All of this we put between curly braces to limit the scope of these variables to where we actually need them.\\nThe actual act of assembling the matrix is then fairly straightforward: we loop over all cells, over all faces of each of these cells, and then do something only if that particular face is at the boundary of the domain. Like this:\\n\\u00a0     {\\n\\u00a0       const QGauss<dim - 1> quadrature_formula(fe.degree + 1);\\n\\u00a0       FEFaceValues<dim>     fe_values(fe,\\n\\u00a0                                   quadrature_formula,\\n\\u00a0                                   update_values | update_JxW_values);\\n\\u00a0 \\n\\u00a0       const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n\\u00a0       const unsigned int n_q_points    = quadrature_formula.size();\\n\\u00a0 \\n\\u00a0       FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0 \\n\\u00a0       std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0       for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0         for (const auto &face : cell->face_iterators())\\n\\u00a0           if (face->at_boundary())\\n\\u00a0             {\\n\\u00a0               cell_matrix = 0;\\n\\u00a0 \\n\\u00a0               fe_values.reinit(cell, face);\\n\\u00a0 \\n\\u00a0               for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n\\u00a0                 for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0                   for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0                     cell_matrix(i, j) += (fe_values.shape_value(i, q_point) *\\n\\u00a0                                           fe_values.shape_value(j, q_point) *\\n\\u00a0                                           fe_values.JxW(q_point));\\n\\u00a0 \\n\\u00a0               cell->get_dof_indices(local_dof_indices);\\n\\u00a0               for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0                 for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0                   boundary_matrix.add(local_dof_indices[i],\\n\\u00a0                                       local_dof_indices[j],\\n\\u00a0                                       cell_matrix(i, j));\\n\\u00a0             }\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     system_matrix.copy_from(mass_matrix);\\n\\u00a0     system_matrix.add(time_step * time_step * theta * theta * wave_speed *\\n\\u00a0                         wave_speed,\\n\\u00a0                       laplace_matrix);\\n\\u00a0     system_matrix.add(wave_speed * theta * time_step, boundary_matrix);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     solution_p.reinit(dof_handler.n_dofs());\\n\\u00a0     old_solution_p.reinit(dof_handler.n_dofs());\\n\\u00a0     system_rhs_p.reinit(dof_handler.n_dofs());\\n\\u00a0 \\n\\u00a0     solution_v.reinit(dof_handler.n_dofs());\\n\\u00a0     old_solution_v.reinit(dof_handler.n_dofs());\\n\\u00a0     system_rhs_v.reinit(dof_handler.n_dofs());\\n\\u00a0 \\n\\u00a0     constraints.close();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nFEFaceValuesDefinition fe_values.h:322\\nFullMatrixDefinition full_matrix.h:79\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\n TATForwardProblem::solve_p and TATForwardProblem::solve_v\\nThe following two functions, solving the linear systems for the pressure and the velocity variable, are taken pretty much verbatim (with the exception of the change of name from \\\\(u\\\\) to \\\\(p\\\\) of the primary variable) from step-23:\\n\\u00a0   template <int dim>\\n\\u00a0   void TATForwardProblem<dim>::solve_p()\\n\\u00a0   {\\n\\u00a0     SolverControl solver_control(1000, 1e-8 * system_rhs_p.l2_norm());\\n\\u00a0     SolverCG<Vector<double>> cg(solver_control);\\n\\u00a0 \\n\\u00a0     cg.solve(system_matrix, solution_p, system_rhs_p, PreconditionIdentity());\\n\\u00a0 \\n\\u00a0     std::cout << \\\"   p-equation: \\\" << solver_control.last_step()\\n\\u00a0               << \\\" CG iterations.\\\" << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void TATForwardProblem<dim>::solve_v()\\n\\u00a0   {\\n\\u00a0     SolverControl solver_control(1000, 1e-8 * system_rhs_v.l2_norm());\\n\\u00a0     SolverCG<Vector<double>> cg(solver_control);\\n\\u00a0 \\n\\u00a0     cg.solve(mass_matrix, solution_v, system_rhs_v, PreconditionIdentity());\\n\\u00a0 \\n\\u00a0     std::cout << \\\"   v-equation: \\\" << solver_control.last_step()\\n\\u00a0               << \\\" CG iterations.\\\" << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nPreconditionIdentityDefinition precondition.h:220\\nSolverCGDefinition solver_cg.h:179\\nSolverControlDefinition solver_control.h:67\\n TATForwardProblem::output_results\\nThe same holds here: the function is from step-23.\\n\\u00a0   template <int dim>\\n\\u00a0   void TATForwardProblem<dim>::output_results() const\\n\\u00a0   {\\n\\u00a0     DataOut<dim> data_out;\\n\\u00a0 \\n\\u00a0     data_out.attach_dof_handler(dof_handler);\\n\\u00a0     data_out.add_data_vector(solution_p, \\\"P\\\");\\n\\u00a0     data_out.add_data_vector(solution_v, \\\"V\\\");\\n\\u00a0 \\n\\u00a0     data_out.build_patches();\\n\\u00a0 \\n\\u00a0     const std::string filename =\\n\\u00a0       \\\"solution-\\\" + Utilities::int_to_string(timestep_number, 3) + \\\".vtu\\\";\\n\\u00a0     DataOutBase::VtkFlags vtk_flags;\\n\\u00a0     vtk_flags.compression_level = DataOutBase::CompressionLevel::best_speed;\\n\\u00a0     std::ofstream output(filename);\\n\\u00a0     data_out.write_vtu(output);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nDataOutBase::CompressionLevel::best_speed@ best_speed\\nUtilities::int_to_stringstd::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)Definition utilities.cc:470\\nDataOutBase::VtkFlagsDefinition data_out_base.h:1127\\nDataOutBase::VtkFlags::compression_levelDataOutBase::CompressionLevel compression_levelDefinition data_out_base.h:1182\\n TATForwardProblem::run\\nThis function that does most of the work is pretty much again like in step-23, though we make things a bit clearer by using the vectors G1 and G2 mentioned in the introduction. Compared to the overall memory consumption of the program, the introduction of a few temporary vectors isn't doing much harm.\\nThe only changes to this function are: first, that we do not have to project initial values for the velocity \\\\(v\\\\), since we know that it is zero. And second that we evaluate the solution at the detector locations computed in the constructor. This is done using the VectorTools::point_value function. These values are then written to a file that we open at the beginning of the function.\\n\\u00a0   template <int dim>\\n\\u00a0   void TATForwardProblem<dim>::run()\\n\\u00a0   {\\n\\u00a0     setup_system();\\n\\u00a0 \\n\\u00a0     VectorTools::project(dof_handler,\\n\\u00a0                          constraints,\\n\\u00a0                          QGauss<dim>(fe.degree + 1),\\n\\u00a0                          InitialValuesP<dim>(),\\n\\u00a0                          old_solution_p);\\n\\u00a0     old_solution_v = 0;\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     std::ofstream detector_data(\\\"detectors.dat\\\");\\n\\u00a0 \\n\\u00a0     Vector<double> tmp(solution_p.size());\\n\\u00a0     Vector<double> G1(solution_p.size());\\n\\u00a0     Vector<double> G2(solution_v.size());\\n\\u00a0 \\n\\u00a0     const double end_time = 0.7;\\n\\u00a0     for (time = time_step; time <= end_time;\\n\\u00a0          time += time_step, ++timestep_number)\\n\\u00a0       {\\n\\u00a0         std::cout << std::endl;\\n\\u00a0         std::cout << \\\"time_step \\\" << timestep_number << \\\" @ t=\\\" << time\\n\\u00a0                   << std::endl;\\n\\u00a0 \\n\\u00a0         mass_matrix.vmult(G1, old_solution_p);\\n\\u00a0         mass_matrix.vmult(tmp, old_solution_v);\\n\\u00a0         G1.add(time_step * (1 - theta), tmp);\\n\\u00a0 \\n\\u00a0         mass_matrix.vmult(G2, old_solution_v);\\n\\u00a0         laplace_matrix.vmult(tmp, old_solution_p);\\n\\u00a0         G2.add(-wave_speed * wave_speed * time_step * (1 - theta), tmp);\\n\\u00a0 \\n\\u00a0         boundary_matrix.vmult(tmp, old_solution_p);\\n\\u00a0         G2.add(wave_speed, tmp);\\n\\u00a0 \\n\\u00a0         system_rhs_p = G1;\\n\\u00a0         system_rhs_p.add(time_step * theta, G2);\\n\\u00a0 \\n\\u00a0         solve_p();\\n\\u00a0 \\n\\u00a0         system_rhs_v = G2;\\n\\u00a0         laplace_matrix.vmult(tmp, solution_p);\\n\\u00a0         system_rhs_v.add(-time_step * theta * wave_speed * wave_speed, tmp);\\n\\u00a0 \\n\\u00a0         boundary_matrix.vmult(tmp, solution_p);\\n\\u00a0         system_rhs_v.add(-wave_speed, tmp);\\n\\u00a0 \\n\\u00a0         solve_v();\\n\\u00a0 \\n\\u00a0         output_results();\\n\\u00a0 \\n\\u00a0         detector_data << time;\\n\\u00a0         for (unsigned int i = 0; i < detector_locations.size(); ++i)\\n\\u00a0           detector_data << ' '\\n\\u00a0                         << VectorTools::point_value(dof_handler,\\n\\u00a0                                                     solution_p,\\n\\u00a0                                                     detector_locations[i])\\n\\u00a0                         << ' ';\\n\\u00a0         detector_data << std::endl;\\n\\u00a0 \\n\\u00a0         old_solution_p = solution_p;\\n\\u00a0         old_solution_v = solution_v;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 } // namespace Step24\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nVectorTools::point_valuevoid point_value(const DoFHandler< dim, spacedim > &dof, const VectorType &fe_function, const Point< spacedim, double > &point, Vector< typename VectorType::value_type > &value)\\nVectorTools::projectvoid project(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const AffineConstraints< typename VectorType::value_type > &constraints, const Quadrature< dim > &quadrature, const Function< spacedim, typename VectorType::value_type > &function, VectorType &vec, const bool enforce_zero_boundary=false, const Quadrature< dim - 1 > &q_boundary=(dim > 1 ? QGauss< dim - 1 >(2) :Quadrature< dim - 1 >()), const bool project_to_boundary_first=false)\\n The main function\\nWhat remains is the main function of the program. There is nothing here that hasn't been shown in several of the previous programs:\\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       using namespace Step24;\\n\\u00a0 \\n\\u00a0       TATForwardProblem<2> forward_problem_solver;\\n\\u00a0       forward_problem_solver.run();\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0 \\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nThe program writes both graphical data for each time step as well as the values evaluated at each detector location to disk. We then draw them in plots. Experimental data were also collected for comparison. Currently our experiments have only been done in two dimensions by circularly scanning a single detector. The tissue sample here is a thin slice in the \\\\(X-Y\\\\) plane ( \\\\(Z=0\\\\)), and we assume that signals from other \\\\(Z\\\\) directions won't contribute to the data. Consequently, we only have to compare our experimental data with two dimensional simulated data.\\nOne absorber \\nThis movie shows the thermoacoustic waves generated by a single small absorber propagating in the medium (in our simulation, we assume the medium is mineral oil, which has a acoustic speed of 1.437 \\\\(\\\\frac{mm}{\\\\mu s}\\\\)):\\n\\nFor a single absorber, we of course have to change the InitialValuesP class accordingly.\\nNext, let us compare experimental and computational results. The visualization uses a technique long used in seismology, where the data of each detector is plotted all in one graph. The way this is done is by offsetting each detector's signal a bit compared to the previous one. For example, here is a plot of the first four detectors (from bottom to top, with time in microseconds running from left to right) using the source setup used in the program, to make things a bit more interesting compared to the present case of only a single source:\\n\\nOne thing that can be seen, for example, is that the arrival of the second and fourth signals shifts to earlier times for greater detector numbers (i.e. the topmost ones), but not the first and the third; this can be interpreted to mean that the origin of these signals must be closer to the latter detectors than to the former ones.\\nIf we stack not only 4, but all 160 detectors in one graph, the individual lines blur, but where they run together they create a pattern of darker or lighter grayscales. The following two figures show the results obtained at the detector locations stacked in that way. The left figure is obtained from experiments, and the right is the simulated data. In the experiment, a single small strong absorber was embedded in weaker absorbing tissue:\\n\\n\\n  \\n\\nIt is obvious that the source location is closer to the detectors at angle \\\\(180^\\\\circ\\\\). All the other signals that can be seen in the experimental data result from the fact that there are weak absorbers also in the rest of the tissue, which surrounds the signals generated by the small strong absorber in the center. On the other hand, in the simulated data, we only simulate the small strong absorber.\\nIn reality, detectors have limited bandwidth. The thermoacoustic waves passing through the detector will therefore be filtered. By using a high-pass filter (implemented in MATLAB and run against the data file produced by this program), the simulated results can be made to look closer to the experimental data:\\n\\nIn our simulations, we see spurious signals behind the main wave that result from numerical artifacts. This problem can be alleviated by using finer mesh, resulting in the following plot:\\n\\nMultiple absorbers\\nTo further verify the program, we will also show simulation results for multiple absorbers. This corresponds to the case that is actually implemented in the program. The following movie shows the propagation of the generated thermoacoustic waves in the medium by multiple absorbers:\\n\\nExperimental data and our simulated data are compared in the following two figures: \\n\\n  \\n\\nNote that in the experimental data, the first signal (i.e. the left-most dark line) results from absorption at the tissue boundary, and therefore reaches the detectors first and before any of the signals from the interior. This signal is also faintly visible at the end of the traces, around 30 \\\\(\\\\mu s\\\\), which indicates that the signal traveled through the entire tissue to reach detectors at the other side, after all the signals originating from the interior have reached them.\\nAs before, the numerical result better matches experimental ones by applying a bandwidth filter that matches the actual behavior of detectors (left) and by choosing a finer mesh (right):\\n\\n\\n  \\n\\nOne of the important differences between the left and the right figure is that the curves look much less \\\"angular\\\" at the right. The angularity comes from the fact that while waves in the continuous equation travel equally fast in all directions, this isn't the case after discretization: there, waves that travel diagonal to cells move at slightly different speeds to those that move parallel to mesh lines. This anisotropy leads to wave fronts that aren't perfectly circular (and would produce sinusoidal signals in the stacked plots), but are bulged out in certain directions. To make things worse, the circular mesh we use (see for example step-6 for a view of the coarse mesh) is not isotropic either. The net result is that the signal fronts are not sinusoidal unless the mesh is sufficiently fine. The right image is a lot better in this respect, though artifacts in the form of trailing spurious waves can still be seen.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2006 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Authors: Xing Jin, Wolfgang Bangerth, Texas A&M University, 2006\\n */\\n \\n \\n \\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/function.h>\\n#include <deal.II/base/utilities.h>\\n \\n#include <deal.II/lac/vector.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/precondition.h>\\n#include <deal.II/lac/affine_constraints.h>\\n \\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_generator.h>\\n \\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_values.h>\\n \\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/matrix_creator.h>\\n#include <deal.II/numerics/vector_tools.h>\\n \\n#include <fstream>\\n#include <iostream>\\n \\n#include <deal.II/grid/grid_tools.h>\\n \\nnamespace Step24\\n{\\n using namespace dealii;\\n \\n \\n template <int dim>\\n class TATForwardProblem\\n  {\\n public:\\n    TATForwardProblem();\\n void run();\\n \\n private:\\n void setup_system();\\n void solve_p();\\n void solve_v();\\n void output_results() const;\\n \\n Triangulation<dim> triangulation;\\n const FE_Q<dim>    fe;\\n DoFHandler<dim>    dof_handler;\\n \\n AffineConstraints<double> constraints;\\n \\n SparsityPattern      sparsity_pattern;\\n SparseMatrix<double> system_matrix;\\n SparseMatrix<double> mass_matrix;\\n SparseMatrix<double> laplace_matrix;\\n \\n Vector<double> solution_p, solution_v;\\n Vector<double> old_solution_p, old_solution_v;\\n Vector<double> system_rhs_p, system_rhs_v;\\n \\n double       time_step, time;\\n unsigned int timestep_number;\\n const double theta;\\n \\n SparseMatrix<double> boundary_matrix;\\n const double         wave_speed;\\n \\n    std::vector<Point<dim>> detector_locations;\\n  };\\n \\n \\n \\n template <int dim>\\n class InitialValuesP : public Function<dim>\\n  {\\n public:\\n virtual double value(const Point<dim> &p,\\n const unsigned int /*component*/ = 0) const override\\n {\\n static const std::array<Source, 5> sources{\\n        {Source(Point<dim>(0, 0), 0.025),\\n         Source(Point<dim>(-0.135, 0), 0.05),\\n         Source(Point<dim>(0.17, 0), 0.03),\\n         Source(Point<dim>(-0.25, 0), 0.02),\\n         Source(Point<dim>(-0.05, -0.15), 0.015)}};\\n \\n for (const auto &source : sources)\\n        if (p.distance(source.location) < source.radius)\\n          return 1;\\n \\n return 0;\\n    }\\n \\n private:\\n struct Source\\n    {\\n      Source(const Point<dim> &l, const double r)\\n        : location(l)\\n        , radius(r)\\n      {}\\n \\n const Point<dim> location;\\n const double     radius;\\n    };\\n  };\\n \\n \\n \\n template <int dim>\\n  TATForwardProblem<dim>::TATForwardProblem()\\n    : fe(1)\\n    , dof_handler(triangulation)\\n    , time_step(std::numeric_limits<double>::quiet_NaN())\\n    , time(time_step)\\n    , timestep_number(1)\\n    , theta(0.5)\\n    , wave_speed(1.437)\\n  {\\n Assert(dim == 2, ExcNotImplemented());\\n \\n const double detector_step_angle = 2.25;\\n const double detector_radius     = 0.5;\\n \\n for (double detector_angle = 2 * numbers::PI; detector_angle >= 0;\\n         detector_angle -= detector_step_angle / 360 * 2 * numbers::PI)\\n      detector_locations.push_back(\\n Point<dim>(std::cos(detector_angle), std::sin(detector_angle)) *\\n        detector_radius);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void TATForwardProblem<dim>::setup_system()\\n  {\\n const Point<dim> center;\\n GridGenerator::hyper_ball(triangulation, center, 1.);\\n triangulation.refine_global(7);\\n \\n    time_step = GridTools::minimal_cell_diameter(triangulation) / wave_speed /\\n std::sqrt(1. * dim);\\n \\n    std::cout << \\\"Number of active cells: \\\" << triangulation.n_active_cells()\\n              << std::endl;\\n \\n    dof_handler.distribute_dofs(fe);\\n \\n    std::cout << \\\"Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n              << std::endl\\n              << std::endl;\\n \\n DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());\\n DoFTools::make_sparsity_pattern(dof_handler, dsp);\\n    sparsity_pattern.copy_from(dsp);\\n \\n    system_matrix.reinit(sparsity_pattern);\\n mass_matrix.reinit(sparsity_pattern);\\n    laplace_matrix.reinit(sparsity_pattern);\\n \\n MatrixCreator::create_mass_matrix(dof_handler,\\n QGauss<dim>(fe.degree + 1),\\n                                      mass_matrix);\\n MatrixCreator::create_laplace_matrix(dof_handler,\\n QGauss<dim>(fe.degree + 1),\\n                                         laplace_matrix);\\n \\n    boundary_matrix.reinit(sparsity_pattern);\\n \\n    {\\n const QGauss<dim - 1> quadrature_formula(fe.degree + 1);\\n FEFaceValues<dim>     fe_values(fe,\\n                                  quadrature_formula,\\n update_values | update_JxW_values);\\n \\n const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n const unsigned int n_q_points    = quadrature_formula.size();\\n \\n FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n \\n      std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n        for (const auto &face : cell->face_iterators())\\n          if (face->at_boundary())\\n            {\\n cell_matrix = 0;\\n \\n              fe_values.reinit(cell, face);\\n \\n for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n cell_matrix(i, j) += (fe_values.shape_value(i, q_point) *\\n                                          fe_values.shape_value(j, q_point) *\\n                                          fe_values.JxW(q_point));\\n \\n              cell->get_dof_indices(local_dof_indices);\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n                  boundary_matrix.add(local_dof_indices[i],\\n                                      local_dof_indices[j],\\n cell_matrix(i, j));\\n            }\\n    }\\n \\n    system_matrix.copy_from(mass_matrix);\\n    system_matrix.add(time_step * time_step * theta * theta * wave_speed *\\n                        wave_speed,\\n                      laplace_matrix);\\n    system_matrix.add(wave_speed * theta * time_step, boundary_matrix);\\n \\n \\n    solution_p.reinit(dof_handler.n_dofs());\\n    old_solution_p.reinit(dof_handler.n_dofs());\\n    system_rhs_p.reinit(dof_handler.n_dofs());\\n \\n    solution_v.reinit(dof_handler.n_dofs());\\n    old_solution_v.reinit(dof_handler.n_dofs());\\n    system_rhs_v.reinit(dof_handler.n_dofs());\\n \\n    constraints.close();\\n  }\\n \\n \\n \\n template <int dim>\\n void TATForwardProblem<dim>::solve_p()\\n  {\\n SolverControl solver_control(1000, 1e-8 * system_rhs_p.l2_norm());\\n SolverCG<Vector<double>> cg(solver_control);\\n \\n    cg.solve(system_matrix, solution_p, system_rhs_p, PreconditionIdentity());\\n \\n    std::cout << \\\"   p-equation: \\\" << solver_control.last_step()\\n              << \\\" CG iterations.\\\" << std::endl;\\n  }\\n \\n \\n \\n template <int dim>\\n void TATForwardProblem<dim>::solve_v()\\n  {\\n SolverControl solver_control(1000, 1e-8 * system_rhs_v.l2_norm());\\n SolverCG<Vector<double>> cg(solver_control);\\n \\n    cg.solve(mass_matrix, solution_v, system_rhs_v, PreconditionIdentity());\\n \\n    std::cout << \\\"   v-equation: \\\" << solver_control.last_step()\\n              << \\\" CG iterations.\\\" << std::endl;\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void TATForwardProblem<dim>::output_results() const\\n {\\n DataOut<dim> data_out;\\n \\n    data_out.attach_dof_handler(dof_handler);\\n    data_out.add_data_vector(solution_p, \\\"P\\\");\\n    data_out.add_data_vector(solution_v, \\\"V\\\");\\n \\n    data_out.build_patches();\\n \\n const std::string filename =\\n \\\"solution-\\\" + Utilities::int_to_string(timestep_number, 3) + \\\".vtu\\\";\\n DataOutBase::VtkFlags vtk_flags;\\n    vtk_flags.compression_level = DataOutBase::CompressionLevel::best_speed;\\n    std::ofstream output(filename);\\n    data_out.write_vtu(output);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void TATForwardProblem<dim>::run()\\n  {\\n    setup_system();\\n \\n VectorTools::project(dof_handler,\\n                         constraints,\\n QGauss<dim>(fe.degree + 1),\\n                         InitialValuesP<dim>(),\\n                         old_solution_p);\\n    old_solution_v = 0;\\n \\n \\n    std::ofstream detector_data(\\\"detectors.dat\\\");\\n \\n Vector<double> tmp(solution_p.size());\\n Vector<double> G1(solution_p.size());\\n Vector<double> G2(solution_v.size());\\n \\n const double end_time = 0.7;\\n for (time = time_step; time <= end_time;\\n         time += time_step, ++timestep_number)\\n      {\\n        std::cout << std::endl;\\n        std::cout << \\\"time_step \\\" << timestep_number << \\\" @ t=\\\" << time\\n                  << std::endl;\\n \\n mass_matrix.vmult(G1, old_solution_p);\\n mass_matrix.vmult(tmp, old_solution_v);\\n        G1.add(time_step * (1 - theta), tmp);\\n \\n mass_matrix.vmult(G2, old_solution_v);\\n        laplace_matrix.vmult(tmp, old_solution_p);\\n        G2.add(-wave_speed * wave_speed * time_step * (1 - theta), tmp);\\n \\n        boundary_matrix.vmult(tmp, old_solution_p);\\n        G2.add(wave_speed, tmp);\\n \\n        system_rhs_p = G1;\\n        system_rhs_p.add(time_step * theta, G2);\\n \\n        solve_p();\\n \\n        system_rhs_v = G2;\\n        laplace_matrix.vmult(tmp, solution_p);\\n        system_rhs_v.add(-time_step * theta * wave_speed * wave_speed, tmp);\\n \\n        boundary_matrix.vmult(tmp, solution_p);\\n        system_rhs_v.add(-wave_speed, tmp);\\n \\n        solve_v();\\n \\n        output_results();\\n \\n        detector_data << time;\\n for (unsigned int i = 0; i < detector_locations.size(); ++i)\\n          detector_data << ' '\\n                        << VectorTools::point_value(dof_handler,\\n                                                    solution_p,\\n                                                    detector_locations[i])\\n                        << ' ';\\n        detector_data << std::endl;\\n \\n        old_solution_p = solution_p;\\n        old_solution_v = solution_v;\\n      }\\n  }\\n} // namespace Step24\\n \\n \\n \\n \\nint main()\\n{\\n try\\n    {\\n using namespace Step24;\\n \\n      TATForwardProblem<2> forward_problem_solver;\\n      forward_problem_solver.run();\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n \\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n \\n return 0;\\n}\\naffine_constraints.h\\nDataOutInterface::write_vtuvoid write_vtu(std::ostream &out) constDefinition data_out_base.cc:7692\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\ndof_handler.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nfe_values.h\\nfe_q.h\\nfull_matrix.h\\nfunction.h\\ntria.h\\ngrid_generator.h\\ngrid_tools.h\\nutilities.h\\nmatrix_creator.h\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\nLocalIntegrators::L2::mass_matrixvoid mass_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const double factor=1.)Definition l2.h:57\\ndata_out.h\\nprecondition.h\\nquadrature_lib.h\\nsolver_cg.h\\nsparse_matrix.h\\nvector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"