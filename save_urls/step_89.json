"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_89.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-89 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-89 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-89 tutorial program\\n\\n\\nThis tutorial depends on step-67, step-87.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nAcoustic conservation equations\\nNon-matching discretizations\\n\\nPoint-to-point interpolation\\nNitsche-type mortaring\\n\\nFERemoteEvaluation\\nOverview of the test case\\n\\n The commented program\\n\\nInclude files\\nInitial conditions for vibrating membrane\\nGauss pulse\\nHelper functions\\nMaterial parameter description\\nBoundary conditions\\nAcoustic operator\\n\\nMatrix-free boundary function for point-to-point interpolation\\nMatrix-free boundary function for Nitsche-type mortaring\\n\\nInverse mass operator\\nRunge-Kutta time-stepping\\nConstruction of non-matching triangulations\\nSet up and running of the two schemes\\n\\nSetup and running of the point-to-point interpolation scheme\\nSetup and running of the Nitsche-type mortaring scheme\\n\\nmain()\\n\\nRun vibrating membrane test case} Homogeneous pressure\\nRun test case with inhomogeneous material\\n\\n\\n\\n Results\\n\\nVibrating membrane: Point-to-point interpolation vs. Nitsche-type mortaring\\nWave propagation through in-homogeneous fluid\\nPossibilities for extensions\\n\\n The plain program\\n   \\n\\n\\n This program was contributed by Johannes Heinz, Maximilian Bergbauer, Marco Feder, and Peter Munch. Many ideas presented here are the result of common code development with Niklas Fehn, Luca Heltai, Martin Kronbichler, and Magdalena Schreter-Fleischhacker.\\nThis tutorial is loosely based on the publication \\\"High-order non-conforming discontinuous Galerkin methods for the acoustic\\nconservation equations\\\" by Johannes Heinz, Peter Munch, and Manfred Kaltenbacher [112].\\nJohannes Heinz was supported by the European Union\\u2019s Framework Programme for Research and Innovation Horizon 2020 (2014-2020) under the Marie Sk\\u0142odowsk\\u00e1\\u2013Curie Grant Agreement No. [812719]. \\nNoteIf you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation:   \\nIntroduction\\nThis tutorial presents one way how to apply non-matching and/or Chimera methods within matrix-free loops in deal.II. We are following [112] to show that in some cases a simple point-to-point interpolation is not sufficient. As a remedy, Nitsche-type mortaring is used to suppress artificial modes observed for the acoustic conservation equations [112].\\nAcoustic conservation equations\\nAcoustic conservation equations are used to describe linear wave propagation. The set of equations consists of the conservation of mass and momentum    \\n\\\\[\\n  \\\\frac{\\\\partial \\\\, p}{\\\\partial \\\\, t} + \\\\rho c^2 \\\\nabla\\\\cdot \\\\mathbf{u} = 0,\\\\\\\\\\n  \\\\frac{\\\\partial \\\\, \\\\mathbf{u}}{\\\\partial \\\\, t} + \\\\frac{1}{\\\\rho}\\\\nabla p = \\\\mathbf{0}.\\n\\\\]\\n\\n Here, \\\\(p\\\\) is the acoustic pressure, \\\\(\\\\mathbf{u}\\\\) the acoustic particle velocity, \\\\(c\\\\) the speed of sound, and \\\\(\\\\rho\\\\) the mean density of the fluid in which waves are propagating. As stated above, the two equations are simply a different way of writing the wave equation: If you take the time derivative of the first equation, and the divergence of the second, i.e., compute      \\n\\\\[\\n  \\\\frac{\\\\partial^2 \\\\, p}{\\\\partial \\\\, t^2} + \\\\rho c^2 \\\\nabla\\\\cdot\\n     \\\\frac{\\\\partial \\\\mathbf{u}}{\\\\partial t} = 0,\\\\\\\\\\n  \\\\frac{\\\\partial \\\\, \\\\nabla \\\\cdot \\\\mathbf{u}}{\\\\partial \\\\, t} +\\n     \\\\nabla \\\\cdot \\\\frac{1}{\\\\rho}\\\\nabla p = \\\\mathbf{0},\\n\\\\]\\n\\n then you can substitute the second equation into the first one to obtain    \\n\\\\[\\n  \\\\frac{\\\\partial^2 \\\\, p}{\\\\partial \\\\, t^2} - \\\\rho c^2 \\\\nabla \\\\cdot\\n     \\\\frac{1}{\\\\rho}\\\\nabla p = \\\\mathbf{0},\\n\\\\]\\n\\n which in the case of constant density \\\\(\\\\rho\\\\) results in the more familiar form of the wave equation that we have previously solved in step-23:   \\n\\\\[\\n  \\\\frac{\\\\partial^2 \\\\, p}{\\\\partial \\\\, t^2} - c^2 \\\\Delta p = \\\\mathbf{0}.\\n\\\\]\\n\\nThe reason one may want to consider the form we use here (rather than the form used in step-23) is that it has the form of a hyperbolic conservation law in which only first temporal and spatial derivatives appear. Whereas both the more familiar, second order form of the wave equation and the formulation as a first-order system conserve energy, it is often easier to devise numerical schemes that have the right amount of dissipation (necessary for numerical stability) using the well-developed machinery available for first-order systems.\\nFor the discretization of this form, we make use of discontinuous Galerkin (DG) methods. DG methods are especially attractive for the acoustic conservation equations due to their low numerical dispersion errors. More importantly for this tutorial, DG methods natively extend to non-matching Nitsche-type methods [6]. I.e., numerical fluxes are not only used on interior element faces but also as non-matching coupling conditions.\\nThe discretized equations read          \\n\\\\[\\n  \\\\int_{K} q_h\\\\frac{\\\\partial \\\\, p_h}{\\\\partial \\\\, t} +\\n     \\\\int_{K} q_h \\\\rho c^2 \\\\nabla \\\\cdot\\\\mathbf{u}_h +\\n        \\\\int_{\\\\partial K} q_h\\\\mathbf{n}\\\\cdot\\\\rho c^2 (\\\\mathbf{u}^*_h-\\\\mathbf{u}_h)\\n           = 0,\\\\\\\\\\n  \\\\int_{K} \\\\mathbf{w}_h\\\\cdot\\\\frac{\\\\partial \\\\,\\\\mathbf{u}_h}{\\\\partial \\\\, t} +\\n     \\\\int_{K} \\\\mathbf{w}_h\\\\cdot \\\\frac{1}{\\\\rho} \\\\nabla p_h +\\n        \\\\int_{\\\\partial K} \\\\mathbf{w}_h \\\\cdot\\\\mathbf{n} \\\\frac{1}{\\\\rho}(p^*_h-p_h)\\n           = \\\\mathbf{0},\\n\\\\]\\n\\n where \\\\(\\\\mathbf{w}_h\\\\) and \\\\(q_h\\\\) are test functions. The numerical fluxes are defined as follows [117] :      \\n\\\\[\\n  p_h^*=p_h-\\\\frac{\\\\tau^-}{\\\\tau^-+\\\\tau^+}[p_h] +\\n     \\\\frac{\\\\tau^-\\\\tau^+}{\\\\tau^-+\\\\tau^+}\\\\jump{\\\\mathbf{u}_h},\\\\\\\\\\n  \\\\mathbf{u}_h^*=\\\\mathbf{u}_h-\\\\frac{\\\\gamma^-}{\\\\gamma^-+\\\\gamma^+}[\\\\mathbf{u}_h]\\n     +\\\\frac{\\\\gamma^-\\\\gamma^+}{\\\\gamma^-+\\\\gamma^+}\\\\jump{p_h},\\n\\\\]\\n\\n with the penalty parameters \\\\(\\\\tau=\\\\frac{\\\\rho c}{2}\\\\) and \\\\(\\\\gamma=\\\\frac{1}{2\\\\rho c}\\\\). In these formulas, \\\\([a] = a^- - a^+ \\\\) denotes the jump of an arbitrary quantity \\\\(a\\\\) over element faces (face between elements \\\\(K^-\\\\) and \\\\(K^+\\\\)) and \\\\(\\\\jump{a} = a^- \\\\mathbf{n}^- + a^+ \\\\mathbf{n}^+\\\\). For homogeneous materials, the fluxes reduce to standard Lax\\u2013Friedrichs fluxes ( \\\\(\\\\gamma^-=\\\\gamma^+\\\\) and \\\\(\\\\tau^-=\\\\tau^+\\\\))    \\n\\\\[\\n  p_h^*=\\\\average{p_h}+\\\\tau\\\\jump{\\\\mathbf{u}_h},\\\\\\\\\\n  \\\\mathbf{u}_h^*=\\\\average{\\\\mathbf{u}_h}+\\\\gamma\\\\jump{p_h}.\\n\\\\]\\n\\n The expression \\\\(\\\\average{a}=\\\\frac{a^- + a^+}{2}\\\\) denotes the averaging operator.\\nNon-matching discretizations\\nNon-matching discretizations can be used to connect mesh regions with different element sizes without the need for a transition region. Therefore, they are highly desirable in multiphysics applications. One example is a plate that radiates sound. The plate needs a much finer discretization than the surrounding air because \\u2013 due to the vastly different speeds of sound in the two media \\u2013 the wavelengths of sound of the same frequently is very different in the two media, and the mesh size needs to be proportional to the wavelength. We will simulate this example later on.\\nA different example of the usefulness of non-matching grids is where one wants to move the mesh in parts of the domain, but not others. A typical example is the simulation of windmills: One might want to enclose the rotating wings into a co-rotating mesh (to avoid having to remesh with every time step) but of course the mesh that describes the air above the surrounding landscape and around the tower on which the windmill is located should not rotate. In a case like this, one considers sliding rotating interfaces [76] between the co-rotating part of the mesh and the stationary part of the mesh, but this also requires the ability to handle non-matching discretizations.\\nBesides this, non-matching methods can be extended to Chimera methods where elements overlap. Chimera methods can help reduce the pressure on mesh generation tools since different regions of a mesh (that may overlap) can be meshed independently.\\nDifferent methods exist to treat non-matching interfaces. Within this tutorial, we concentrate on two methods: Point-to-point interpolation and Nitsche-type mortaring.\\nPoint-to-point interpolation\\n\\n\\n\\nPoint-to-point interpolation is a naive approach. Whenever you need to compute integrals over the boundary of the cell at the left, for a coupled problem you then need to evaluate the solution or shape functions on the right at quadrature points of the face on the left, i.e., of the face of element \\\\(K^-\\\\). You can just evaluate these be interpolating the information on the right at these points, but this is in general expensive (read, for example, the documentation of VectorTools::point_value(), which implements this kind of functionality). As can be seen from the picture this approach might be subject to aliasing in some cases.\\nNitsche-type mortaring\\n\\n\\n\\nMortaring is the process of computing intersections and is not related to the Mortar method which enforces the coupling via Lagrange multipliers. Instead, in mortaring methods one refers to obtained intersections as \\\"mortars\\\". On each mortar a new integration rule is defined. The integral of the face of element \\\\(K^-\\\\) is computed on the intersections. The idea is that if we want to integrate something over a face \\\\(f\\\\subset \\\\partial K^-\\\\), that we break that integral into pieces:   \\n\\\\[\\n  \\\\int_f \\\\cdots dx = \\\\sum_i \\\\int_{f_i} \\\\cdots dx\\n\\\\]\\n\\n where each of the \\\\(f_i\\\\) corresponds to the intersection of the original face \\\\(f\\\\) on the left with exactly one of the faces on the right; or, if we had multiple faces on the left, then the \\\\(f_i\\\\) would be the intersections of exactly one face on the left and one face on the right.\\nThe point of this approach is first, that splitting the integral this way is exact. Secondly, and maybe more importantly, the terms we are integrating (the dots in the formula above) are now defined on one cell on each side, and consequently are smooth (whereas a finite element solution considered across multiple cells is, in general, not smooth). As a consequence, if we approximate the integrals via numerical integration (quadrature), then the result is exact as long as a sufficient number of integration points is used (at least for affine element shapes; for general curved elements, the integrand will contain rational expressions that are difficult to integrate exactly).\\nIn this tutorial, the intersections are computed using CGAL, the Computational Geometry Algorithms Library. Therefore, deal.II has to be configured with DEAL_II_WITH_CGAL for the Nitsche-type mortaring implementation. See the deal.II Readme file for information about installation.\\nFERemoteEvaluation\\nIn practice, for integrals as those mentioned above, we need to evaluate solutions (and shape functions) from cells across the non-matching interface. This is awkward enough if the other side is on the same processor, but outright difficult if the cells on the other side of the interface are owned by a different process in a parallel computation.\\nOn regular meshes (say, doing things as we do in step-40), this is addressed by making sure that we are only computing integrals on locally owned cells and keeping around one layer of ghost cells for which we can query information. Ghost cells are the neighbors of locally owned cells, but in cases like the picture above, where the meshes are not matching, the cells on the other side of the interface are not neighbors in the logical sense \\u2013 though they happen to be geometrically located adjacently. As a consequence, we need to find a way to efficiently query information on cells that are perhaps located on a different process.\\nFERemoteEvaluation is a wrapper class which provides a similar interface to, e.g., the FEEvaluation and FEFaceEvaluation classes to access values over non-matching interfaces in matrix-free loops. A detailed description on how to set up the class and how to use it in actual code is given below using hands-on examples. Within this tutorial we only show the usage for non-matching discretizations. Note however, that FERemoteEvaluation can also be used in other settings such as volume coupling. Under the hood, Utilities::MPI::RemotePointEvaluation is used to query the solution or gradients at quadrature points. A detailed description how this is done can be found in step-87. The main difference in the usage of FERemoteEvaluation compared to FEEvaluation is that the interpolated values/gradients of the finite element solution at all the quadrature points are precomputed globally before the loop over the cells/faces of the mesh (i.e., near the place where the communication takes place) instead of performing the interpolation on a cell-by-cell basis. (The principal reason for this design is that MPI has a communication model where you can send messages, but you won't hear back unless the other side is actually listening. As a consequence, you can't generally write code where each process is doing its thing until it needs some information at which point it sends a message to another process to ask for something; because the other process doesn't know that there are such messages, or how many, that have been sent to it, it doesn't respond and so the first process is stuck. Instead, the programming model used with MPI is generally to collect information about everything one will need up front; then each process sends it to all the others; then each process works on these combined requests and sends the required information back to the senders; and at this point everyone has everything they need for their work and can actually do that work.)\\nThe standard code to evaluate fluxes via FEEvaluation on interior faces between two cells reads as follows (where _m corresponds to \\\\(K^{-}\\\\), the current cell in minus normal direction, and _p corresponds to \\\\(K^{+}\\\\), the neighbor cell in plus normal direction):\\nIn DG methods we have to evaluate fluxes over element faces. Exemplarily for an upwind-like flux \\\\(u^*(\\\\mathbf{x}) = u^+(\\\\mathbf{x})\\\\) over element face \\\\(\\\\partial K\\\\) we have to compute     \\n\\\\[\\n  F^{\\\\partial K} = \\\\left(\\\\varphi^-, u^+\\\\right)_{\\\\partial K} \\\\approx\\n     \\\\sum_q \\\\varphi^-(\\\\mathbf{x}_q^{\\\\partial K})\\\\ u^+(\\\\mathbf{x}_q^{\\\\partial K})\\\\\\n        w_q^{\\\\partial K} |J_q|^{\\\\partial K}.\\n\\\\]\\n\\n FEFaceEvaluation::gather_evaluate(src, EvaluationFlags::values) and FEFaceEvaluation::get_value(q) extract the value at quadrature point \\\\(\\\\mathbf{x}_q^{\\\\partial K}\\\\) from src. FEFaceEvaluation::submit_value(value, q) multiplies the value with the quadrature weight and the Jacobian determinant at \\\\(\\\\mathbf{x}_q^{\\\\partial K}\\\\). Eventually FEFaceEvaluation::integrate_scatter(EvaluationFlags::values, dst) multiplies the values queued for evaluation by FEFaceEvaluation::submit_value() by the value of the basis functions and writes the result to dst. The corresponding code reads\\nconst auto face_function =\\n  [&](const MatrixFree &data, VectorType &dst, const VectorType &src,\\n const std::pair<unsigned int, unsigned int> face_range) {\\n \\n FEFaceEvaluation phi_m(data, true);  // this cell\\n FEFaceEvaluation u_p(data, false);   // neighbor cell\\n \\n for (unsigned int f = face_range.first; f < face_range.second; ++f)\\n    {\\n      phi_m.reinit(f);\\n      u_p.reinit(f);\\n \\n      u_p.gather_evaluate(src, EvaluationFlags::values); //compute values on face f\\n \\n for (unsigned int q = 0; q < phi_m.n_q_points; ++q)\\n        phi_m.submit_value(u_p.get_value(q), q);         //access values with u_p\\n \\n      phi_m.integrate_scatter(EvaluationFlags::values, dst);\\n     }\\n   };\\n \\nmatrix_free.template loop<VectorType, VectorType>(/* cell_operation= */{},\\n /* interior_face_operation= */ face_function,\\n /* boundary_face_operation= */{},\\n                                                  dst, src);\\nFEFaceEvaluationDefinition fe_evaluation.h:1818\\nMatrixFreeDefinition matrix_free.h:113\\nEvaluationFlags::values@ valuesDefinition evaluation_flags.h:50\\nThe code to do the same with FERemoteEvaluation is shown below. For brevity, we assume all boundary faces are somehow connected via non-conforming interfaces for FERemoteEvaluation.\\n// Initialize FERemoteEvaluation: Note, that FERemoteEvaluation internally manages\\n// the memory to store precomputed values. Therefore, FERemoteEvaluation\\n// should be initialized only once to avoid frequent memory\\n// allocation/deallocation. At this point, remote_communicator is assumed\\n// to be initialized.\\nFERemoteEvaluation<dim,Number> u_p_evaluator(remote_communicator);\\n \\n// Precompute the interpolated values of the finite element solution at all\\n// the quadrature points outside the loop, invoking the vector entries and\\n// respective basis function at possibly remote MPI processes before communication.\\nu_p_evaluator.gather_evaluate(src, EvaluationFlags::values);\\n \\nconst auto boundary_function =\\n  [&](const MatrixFree &data, VectorType &dst, const VectorType &src,\\n const std::pair<unsigned int, unsigned int> face_range) {\\n \\n FEFaceEvaluation phi_m(data, true);\\n // To access the values in a thread safe way each thread has\\n // to create a own accessor object. A small helper function\\n // provides the accessor.\\n internal::PrecomputedEvaluationDataAccessor u_p = u_p_evaluator.get_data_accessor();\\n \\n for (unsigned int f = face_range.first; f < face_range.second; ++f)\\n    {\\n      phi_m.reinit(f);\\n      u_p.reinit(f);\\n \\n for (unsigned int q = 0; q < phi_m.n_q_points; ++q)\\n        phi_m.submit_value(u_p.get_value(q), q); // access values with phi_p\\n \\n      phi_m.integrate_scatter(EvaluationFlags::values, dst);\\n    }\\n  };\\n \\nmatrix_free.template loop<VectorType, VectorType>({}, {}, boundary_function, dst, src);\\nFERemoteEvaluationDefinition fe_remote_evaluation.h:539\\ninternal::PrecomputedEvaluationDataAccessorDefinition fe_remote_evaluation.h:114\\ninternal::PrecomputedEvaluationDataAccessor::get_valueconst value_type get_value(const unsigned int q) constDefinition fe_remote_evaluation.h:692\\ninternal::PrecomputedEvaluationDataAccessor::reinitvoid reinit(const unsigned int index)Definition fe_remote_evaluation.h:715\\n The object remote_communicator is of type FERemoteEvaluationCommunicator and assumed to be correctly initialized prior to the above code snippet. FERemoteEvaluationCommunicator internally manages the update of ghost values over non-matching interfaces and keeps track of the mapping between quadrature point index and corresponding values/gradients. As mentioned above, the update of the values/gradients happens before the actual matrix-free loop. FERemoteEvaluationCommunicator, as well as FERemoteEvaluation, behaves differently for the given template parameter value_type. If we want to access values at arbitrary points (e.g. in combination with FEPointEvaluation), then we need to choose value_type=Number. If the values are defined at quadrature points of a FEEvaluation object it is possible to get the values at the quadrature points of batches and we need to choose value_type=VectorizedArray<Number>.\\nOverview of the test case\\nIn this program, we implemented both the point-to-point interpolation and Nitsche-type mortaring mentioned in the introduction.\\nAt first we are considering the test case of a vibrating membrane, see e.g. [163]. Standing waves of length \\\\(\\\\lambda=2/M\\\\) are oscillating with a time period of \\\\(T=2 / (M \\\\sqrt{d} c)\\\\) where \\\\(d\\\\) is the dimension of the space in which our domain is located and \\\\(M\\\\) is the number of modes per meter, i.e. the number of half-waves per meter. The corresponding analytical solution reads as\\n\\n\\\\begin{align*}\\n  p &=\\\\cos(M \\\\sqrt{d} \\\\pi c t)\\\\prod_{i=1}^{d} \\\\sin(M \\\\pi x_i),\\\\\\\\\\n  u_i&=-\\\\frac{\\\\sin(M \\\\sqrt{d} \\\\pi c t)}{\\\\sqrt{d}\\\\rho c}\\n     \\\\cos(M \\\\pi x_i)\\\\prod_{j=1,j\\\\neq i}^{d} \\\\sin(M \\\\pi x_j),\\n\\\\end{align*}\\n\\nFor simplicity, we are using homogeneous pressure Dirichlet boundary conditions within this tutorial. To be able to do so we have to tailor the domain size as well as the number of modes to conform with the homogeneous pressure Dirichlet boundary conditions. Within this tutorial we are using \\\\(M=10\\\\) and a domain \\\\(\\\\Omega=(0,1)^2\\\\). The domain will be meshed so that the left and right parts of the domain consist of separate meshes that do not match at the interface.\\nAs will become clear from the results, the point-to-point interpolation will result in aliasing, which can be resolved using Nitsche-type mortaring.\\nIn a more realistic second example, we apply this implementation to a test case in which a wave is propagating from one fluid into another fluid. The speed of sound in the left part of the domain is \\\\(c=1\\\\) and in the right part it is \\\\(c=3\\\\). Since the wavelength is directly proportional to the speed of sound, three times larger elements can be used in the right part of the domain to resolve waves up to the same frequency. A test case like this has been simulated with a different domain and different initial conditions, e.g., in [12].\\n The commented program\\n Include files\\nThe program starts with including all the relevant header files.\\n\\u00a0 #include <deal.II/base/conditional_ostream.h>\\n\\u00a0 #include <deal.II/base/mpi.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/distributed/tria.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_dgq.h>\\n\\u00a0 #include <deal.II/fe/fe_system.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 #include <deal.II/fe/mapping_q1.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_tools.h>\\n\\u00a0 #include <deal.II/grid/grid_tools_cache.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/matrix_free/fe_evaluation.h>\\n\\u00a0 #include <deal.II/matrix_free/matrix_free.h>\\n\\u00a0 #include <deal.II/matrix_free/operators.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/non_matching/mapping_info.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\nThe following header file provides the class FERemoteEvaluation, which allows to access values and/or gradients at remote triangulations similar to FEEvaluation.\\n\\u00a0 #include <deal.II/matrix_free/fe_remote_evaluation.h>\\n\\u00a0 \\nWe pack everything that is specific for this program into a namespace of its own.\\n\\u00a0 namespace Step89\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n Initial conditions for vibrating membrane\\nIn the following, let us first define a function that provides the initial condition for the vibrating membrane test case. It implements both the initial pressure (component 0) and velocity (components 1 to 1 + dim).\\nThere is also a function that computes the duration of one oscillation.\\n\\u00a0   template <int dim>\\n\\u00a0   class InitialConditionVibratingMembrane : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     InitialConditionVibratingMembrane(const double modes);\\n\\u00a0 \\n\\u00a0     double value(const Point<dim> &p, const unsigned int comp) const final;\\n\\u00a0 \\n\\u00a0     double get_period_duration(const double speed_of_sound) const;\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     const double M;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   InitialConditionVibratingMembrane<dim>::InitialConditionVibratingMembrane(\\n\\u00a0     const double modes)\\n\\u00a0     : Function<dim>(dim + 1, 0.0)\\n\\u00a0     , M(modes)\\n\\u00a0   {\\n\\u00a0     static_assert(dim == 2, \\\"Only implemented for dim==2\\\");\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double\\n\\u00a0   InitialConditionVibratingMembrane<dim>::value(const Point<dim>  &p,\\n\\u00a0                                                 const unsigned int comp) const\\n\\u00a0   {\\n\\u00a0     if (comp == 0)\\n\\u00a0       return std::sin(M * numbers::PI * p[0]) *\\n\\u00a0              std::sin(M * numbers::PI * p[1]);\\n\\u00a0 \\n\\u00a0     return 0.0;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double InitialConditionVibratingMembrane<dim>::get_period_duration(\\n\\u00a0     const double speed_of_sound) const\\n\\u00a0   {\\n\\u00a0     return 2.0 / (M * std::sqrt(dim) * speed_of_sound);\\n\\u00a0   }\\n\\u00a0 \\nFunctionDefinition function.h:152\\nFunction::valuevirtual RangeNumberType value(const Point< dim > &p, const unsigned int component=0) const\\nPointDefinition point.h:111\\nnumbers::PIstatic constexpr double PIDefinition numbers.h:259\\nstd::sin::VectorizedArray< Number, width > sin(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6589\\nstd::sqrt::VectorizedArray< Number, width > sqrt(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6869\\n Gauss pulse\\nNext up is a function that provides the values of a pressure Gauss pulse. As with the previous function, it implements both the initial pressure (component 0) and velocity (components 1 to 1 + dim).\\n\\u00a0   template <int dim>\\n\\u00a0   class GaussPulse : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     GaussPulse(const double shift_x, const double shift_y);\\n\\u00a0 \\n\\u00a0     double value(const Point<dim> &p, const unsigned int comp) const final;\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     const double shift_x;\\n\\u00a0     const double shift_y;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   GaussPulse<dim>::GaussPulse(const double shift_x, const double shift_y)\\n\\u00a0     : Function<dim>(dim + 1, 0.0)\\n\\u00a0     , shift_x(shift_x)\\n\\u00a0     , shift_y(shift_y)\\n\\u00a0   {\\n\\u00a0     static_assert(dim == 2, \\\"Only implemented for dim==2\\\");\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double GaussPulse<dim>::value(const Point<dim>  &p,\\n\\u00a0                                 const unsigned int comp) const\\n\\u00a0   {\\n\\u00a0     if (comp == 0)\\n\\u00a0       return std::exp(-1000.0 * ((std::pow(p[0] - shift_x, 2)) +\\n\\u00a0                                  (std::pow(p[1] - shift_y, 2))));\\n\\u00a0 \\n\\u00a0     return 0.0;\\n\\u00a0   }\\n\\u00a0 \\nstd::exp::VectorizedArray< Number, width > exp(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6829\\nstd::pow::VectorizedArray< Number, width > pow(const ::VectorizedArray< Number, width > &, const Number p)Definition vectorization.h:6885\\n Helper functions\\nThe following namespace contains free helper functions that are used in the tutorial.\\n\\u00a0   namespace HelperFunctions\\n\\u00a0   {\\nHelper function to check if a boundary ID is related to a non-matching face. A std::set that contains all non-matching boundary IDs is handed over in addition to the face ID under question.\\n\\u00a0     bool is_non_matching_face(\\n\\u00a0       const std::set<types::boundary_id> &non_matching_face_ids,\\n\\u00a0       const types::boundary_id            face_id)\\n\\u00a0     {\\n\\u00a0       return non_matching_face_ids.find(face_id) != non_matching_face_ids.end();\\n\\u00a0     }\\n\\u00a0 \\nunsigned int\\nHelper function to set the initial conditions for the vibrating membrane test case.\\n\\u00a0     template <int dim, typename Number, typename VectorType>\\n\\u00a0     void set_initial_condition(MatrixFree<dim, Number> matrix_free,\\n\\u00a0                                const Function<dim>    &initial_solution,\\n\\u00a0                                VectorType             &dst)\\n\\u00a0     {\\n\\u00a0       VectorTools::interpolate(*matrix_free.get_mapping_info().mapping,\\n\\u00a0                                matrix_free.get_dof_handler(),\\n\\u00a0                                initial_solution,\\n\\u00a0                                dst);\\n\\u00a0     }\\n\\u00a0 \\nMatrixFree::get_dof_handlerconst DoFHandler< dim > & get_dof_handler(const unsigned int dof_handler_index=0) const\\nMatrixFree::get_mapping_infoconst internal::MatrixFreeFunctions::MappingInfo< dim, Number, VectorizedArrayType > & get_mapping_info() const\\nVectorTools::interpolatevoid interpolate(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const Function< spacedim, typename VectorType::value_type > &function, VectorType &vec, const ComponentMask &component_mask={})\\nHelper function to compute the time step size according to the CFL condition.\\n\\u00a0     double\\n\\u00a0     compute_dt_cfl(const double hmin, const unsigned int degree, const double c)\\n\\u00a0     {\\n\\u00a0       return hmin / (std::pow(degree, 1.5) * c);\\n\\u00a0     }\\n\\u00a0 \\nHelper function that writes vtu output.\\n\\u00a0     template <typename VectorType, int dim>\\n\\u00a0     void write_vtu(const VectorType      &solution,\\n\\u00a0                    const DoFHandler<dim> &dof_handler,\\n\\u00a0                    const Mapping<dim>    &mapping,\\n\\u00a0                    const unsigned int     degree,\\n\\u00a0                    const std::string     &name_prefix)\\n\\u00a0     {\\n\\u00a0       DataOut<dim>          data_out;\\n\\u00a0       DataOutBase::VtkFlags flags;\\n\\u00a0       flags.write_higher_order_cells = true;\\n\\u00a0       data_out.set_flags(flags);\\n\\u00a0 \\n\\u00a0       std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n\\u00a0         interpretation(\\n\\u00a0           dim + 1, DataComponentInterpretation::component_is_part_of_vector);\\n\\u00a0       std::vector<std::string> names(dim + 1, \\\"U\\\");\\n\\u00a0 \\n\\u00a0       interpretation[0] = DataComponentInterpretation::component_is_scalar;\\n\\u00a0       names[0]          = \\\"P\\\";\\n\\u00a0 \\n\\u00a0       data_out.add_data_vector(dof_handler, solution, names, interpretation);\\n\\u00a0 \\n\\u00a0       data_out.build_patches(mapping, degree, DataOut<dim>::curved_inner_cells);\\n\\u00a0       data_out.write_vtu_in_parallel(name_prefix + \\\".vtu\\\",\\n\\u00a0                                      dof_handler.get_communicator());\\n\\u00a0     }\\n\\u00a0   } // namespace HelperFunctions\\n\\u00a0 \\nDataOutDefinition data_out.h:147\\nDoFHandlerDefinition dof_handler.h:317\\nMappingAbstract base class for mapping classes.Definition mapping.h:318\\nDataComponentInterpretation::component_is_scalar@ component_is_scalarDefinition data_component_interpretation.h:52\\nDataComponentInterpretation::component_is_part_of_vector@ component_is_part_of_vectorDefinition data_component_interpretation.h:58\\nDataOutBase::VtkFlagsDefinition data_out_base.h:1127\\nDataOutBase::VtkFlags::write_higher_order_cellsbool write_higher_order_cellsDefinition data_out_base.h:1201\\n Material parameter description\\nThe following class stores the information if the fluid is homogeneous as well as the material properties at every cell. This class helps access the correct values without accessing a large vector of materials in the homogeneous case.\\nThe class is provided a map from material ids to material properties (given as a pair of values for the speed of sound and the density). If the map has only one entry, the material is homogeneous \\u2013 using the same values everywhere \\u2013 and we can remember that fact in the homogeneous member variable and use it to optimize some code paths below. If the material is not homogeneous, we will fill a vector with the correct materials for each batch of cells; this information can then be access via FEEvaluationData::read_cell_data().\\nAs is usual when working with the MatrixFree framework, we will not only access material parameters at a single site, but for whole \\\"batches\\\" of cells. As a consequence, the functions below returned VectorizedArray objects for a batch at a time.\\n\\u00a0   template <typename Number>\\n\\u00a0   class CellwiseMaterialData\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     template <int dim>\\n\\u00a0     CellwiseMaterialData(\\n\\u00a0       const MatrixFree<dim, Number, VectorizedArray<Number>> &matrix_free,\\n\\u00a0       const std::map<types::material_id, std::pair<double, double>>\\n\\u00a0         &material_id_map)\\n\\u00a0       : homogeneous(material_id_map.size() == 1)\\n\\u00a0     {\\n\\u00a0       Assert(material_id_map.size() > 0,\\n\\u00a0              ExcMessage(\\\"No materials given to CellwiseMaterialData.\\\"));\\n\\u00a0 \\n\\u00a0       if (homogeneous)\\n\\u00a0         {\\n\\u00a0           speed_of_sound_homogeneous = material_id_map.begin()->second.first;\\n\\u00a0           density_homogeneous        = material_id_map.begin()->second.second;\\n\\u00a0         }\\n\\u00a0       else\\n\\u00a0         {\\n\\u00a0           const auto n_cell_batches =\\n\\u00a0             matrix_free.n_cell_batches() + matrix_free.n_ghost_cell_batches();\\n\\u00a0 \\n\\u00a0           speed_of_sound.resize(n_cell_batches);\\n\\u00a0           density.resize(n_cell_batches);\\n\\u00a0 \\n\\u00a0           for (unsigned int cell = 0; cell < n_cell_batches; ++cell)\\n\\u00a0             {\\n\\u00a0               speed_of_sound[cell] = 1.;\\n\\u00a0               density[cell]        = 1.;\\n\\u00a0               for (unsigned int v = 0;\\n\\u00a0                    v < matrix_free.n_active_entries_per_cell_batch(cell);\\n\\u00a0                    ++v)\\n\\u00a0                 {\\n\\u00a0                   const auto material_id =\\n\\u00a0                     matrix_free.get_cell_iterator(cell, v)->material_id();\\n\\u00a0 \\n\\u00a0                   speed_of_sound[cell][v] =\\n\\u00a0                     material_id_map.at(material_id).first;\\n\\u00a0                   density[cell][v] = material_id_map.at(material_id).second;\\n\\u00a0                 }\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     bool is_homogeneous() const\\n\\u00a0     {\\n\\u00a0       return homogeneous;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     const AlignedVector<VectorizedArray<Number>> &get_speed_of_sound() const\\n\\u00a0     {\\n\\u00a0       Assert(!homogeneous, ExcMessage(\\\"Use get_homogeneous_speed_of_sound().\\\"));\\n\\u00a0       return speed_of_sound;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     const AlignedVector<VectorizedArray<Number>> &get_density() const\\n\\u00a0     {\\n\\u00a0       Assert(!homogeneous, ExcMessage(\\\"Use get_homogeneous_density().\\\"));\\n\\u00a0       return density;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     VectorizedArray<Number> get_homogeneous_speed_of_sound() const\\n\\u00a0     {\\n\\u00a0       Assert(homogeneous, ExcMessage(\\\"Use get_speed_of_sound().\\\"));\\n\\u00a0       return speed_of_sound_homogeneous;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     VectorizedArray<Number> get_homogeneous_density() const\\n\\u00a0     {\\n\\u00a0       Assert(homogeneous, ExcMessage(\\\"Use get_density().\\\"));\\n\\u00a0       return density_homogeneous;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     const bool homogeneous;\\n\\u00a0 \\n\\u00a0     /* Materials in the inhomogeneous case. */\\n\\u00a0     AlignedVector<VectorizedArray<Number>> speed_of_sound;\\n\\u00a0     AlignedVector<VectorizedArray<Number>> density;\\n\\u00a0 \\n\\u00a0     /* Materials in the homogeneous case. */\\n\\u00a0     VectorizedArray<Number> speed_of_sound_homogeneous;\\n\\u00a0     VectorizedArray<Number> density_homogeneous;\\n\\u00a0   };\\n\\u00a0 \\nAlignedVectorDefinition aligned_vector.h:61\\nVectorizedArrayDefinition vectorization.h:445\\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\nTo be able to access the material data in every cell in a thread safe way, the following class MaterialEvaluation is used. Similar to FEEvaluation, functions below will create their own instances of this class; thus, there can be no race conditions even if these functions run multiple times in parallel. For inhomogeneous materials, a reinit_cell() or reinit_face() function is used to set the correct material at the current cell batch. In the homogeneous case the _reinit() functions don't have to reset the materials.\\n\\u00a0   template <int dim, typename Number>\\n\\u00a0   class MaterialEvaluation\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     MaterialEvaluation(\\n\\u00a0       const MatrixFree<dim, Number, VectorizedArray<Number>> &matrix_free,\\n\\u00a0       const CellwiseMaterialData<Number>                     &material_data)\\n\\u00a0       : phi(matrix_free)\\n\\u00a0       , phi_face(matrix_free, true)\\n\\u00a0       , material_data(material_data)\\n\\u00a0     {\\n\\u00a0       if (material_data.is_homogeneous())\\n\\u00a0         {\\n\\u00a0           speed_of_sound = material_data.get_homogeneous_speed_of_sound();\\n\\u00a0           density        = material_data.get_homogeneous_density();\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     bool is_homogeneous() const\\n\\u00a0     {\\n\\u00a0       return material_data.is_homogeneous();\\n\\u00a0     }\\n\\u00a0 \\nThe following two functions update the data for the current cell or face, given a cell batch index. If the material is homogeneous, there is nothing to do. Otherwise, we reinit the FEEvaluation object and store the data for the current object.\\n\\u00a0     void reinit_cell(const unsigned int cell)\\n\\u00a0     {\\n\\u00a0       if (!material_data.is_homogeneous())\\n\\u00a0         {\\n\\u00a0           phi.reinit(cell);\\n\\u00a0           speed_of_sound =\\n\\u00a0             phi.read_cell_data(material_data.get_speed_of_sound());\\n\\u00a0           density = phi.read_cell_data(material_data.get_density());\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     void reinit_face(const unsigned int face)\\n\\u00a0     {\\n\\u00a0       if (!material_data.is_homogeneous())\\n\\u00a0         {\\n\\u00a0           phi_face.reinit(face);\\n\\u00a0           speed_of_sound =\\n\\u00a0             phi_face.read_cell_data(material_data.get_speed_of_sound());\\n\\u00a0           density = phi_face.read_cell_data(material_data.get_density());\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\nThe following functions then return the speed of sound and density for the current cell batch.\\n\\u00a0     VectorizedArray<Number> get_speed_of_sound() const\\n\\u00a0     {\\n\\u00a0       return speed_of_sound;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     VectorizedArray<Number> get_density() const\\n\\u00a0     {\\n\\u00a0       return density;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     /* Members needed for the inhomogeneous case. */\\n\\u00a0     FEEvaluation<dim, -1, 0, 1, Number>     phi;\\n\\u00a0     FEFaceEvaluation<dim, -1, 0, 1, Number> phi_face;\\n\\u00a0 \\n\\u00a0     /* Material defined at every cell. */\\n\\u00a0     const CellwiseMaterialData<Number> &material_data;\\n\\u00a0 \\n\\u00a0     /* Materials at current cell. */\\n\\u00a0     VectorizedArray<Number> speed_of_sound;\\n\\u00a0     VectorizedArray<Number> density;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\nFEEvaluationDefinition fe_evaluation.h:1355\\n Boundary conditions\\nTo be able to use the same kernel, for all face integrals we define a class that returns the needed values at boundaries. In this tutorial homogeneous pressure Dirichlet boundary conditions are applied via the mirror principle, i.e. \\\\(p_h^+=-p_h^- + 2g\\\\) with \\\\(g=0\\\\).\\n\\u00a0   template <int dim, typename Number>\\n\\u00a0   class BCEvaluationP\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     BCEvaluationP(const FEFaceEvaluation<dim, -1, 0, 1, Number> &pressure_m)\\n\\u00a0       : pressure_m(pressure_m)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     typename FEFaceEvaluation<dim, -1, 0, 1, Number>::value_type\\n\\u00a0     get_value(const unsigned int q) const\\n\\u00a0     {\\n\\u00a0       return -pressure_m.get_value(q);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     const FEFaceEvaluation<dim, -1, 0, 1, Number> &pressure_m;\\n\\u00a0   };\\n\\u00a0 \\nint\\nWe don't have to apply boundary conditions for the velocity, i.e. \\\\(\\\\mathbf{u}_h^+=\\\\mathbf{u}_h^-\\\\).\\n\\u00a0   template <int dim, typename Number>\\n\\u00a0   class BCEvaluationU\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     BCEvaluationU(const FEFaceEvaluation<dim, -1, 0, dim, Number> &velocity_m)\\n\\u00a0       : velocity_m(velocity_m)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     typename FEFaceEvaluation<dim, -1, 0, dim, Number>::value_type\\n\\u00a0     get_value(const unsigned int q) const\\n\\u00a0     {\\n\\u00a0       return velocity_m.get_value(q);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     const FEFaceEvaluation<dim, -1, 0, dim, Number> &velocity_m;\\n\\u00a0   };\\n\\u00a0 \\n Acoustic operator\\nThe following class then defines the acoustic operator. The class is heavily based on matrix-free methods. For a better understanding in matrix-free methods please refer to step-67.\\nAt the top we define a flag that decides whether we want to use mortaring. If the remote evaluators are set up with a VectorizedArray we are using point-to-point interpolation; otherwise we make use of Nitsche-type mortaring. The decision is made using std::is_floating_point_v, which is a variable that is true if the template argument is a floating point type (such as float or double) and false otherwise (in particular if the template argument is a vectorized array type).\\n\\u00a0   template <int dim, typename Number, typename remote_value_type>\\n\\u00a0   class AcousticOperator\\n\\u00a0   {\\n\\u00a0     static constexpr bool use_mortaring =\\n\\u00a0       std::is_floating_point_v<remote_value_type>;\\n\\u00a0 \\n\\u00a0   public:\\nIn case of Nitsche-type mortaring, NonMatching::MappingInfo has to be provided in the constructor.\\n\\u00a0     AcousticOperator(\\n\\u00a0       const MatrixFree<dim, Number>                &matrix_free,\\n\\u00a0       std::shared_ptr<CellwiseMaterialData<Number>> material_data,\\n\\u00a0       const std::set<types::boundary_id>           &remote_face_ids,\\n\\u00a0       std::shared_ptr<FERemoteEvaluation<dim, 1, remote_value_type>>\\n\\u00a0         pressure_r_eval,\\n\\u00a0       std::shared_ptr<FERemoteEvaluation<dim, dim, remote_value_type>>\\n\\u00a0         velocity_r_eval,\\n\\u00a0       std::shared_ptr<FERemoteEvaluation<dim, 1, remote_value_type>> c_r_eval,\\n\\u00a0       std::shared_ptr<FERemoteEvaluation<dim, 1, remote_value_type>> rho_r_eval,\\n\\u00a0       std::shared_ptr<NonMatching::MappingInfo<dim, dim, Number>>    nm_info =\\n\\u00a0         nullptr)\\n\\u00a0       : matrix_free(matrix_free)\\n\\u00a0       , material_data(material_data)\\n\\u00a0       , remote_face_ids(remote_face_ids)\\n\\u00a0       , pressure_r_eval(pressure_r_eval)\\n\\u00a0       , velocity_r_eval(velocity_r_eval)\\n\\u00a0       , c_r_eval(c_r_eval)\\n\\u00a0       , rho_r_eval(rho_r_eval)\\n\\u00a0       , nm_mapping_info(nm_info)\\n\\u00a0     {\\n\\u00a0       if (use_mortaring)\\n\\u00a0         Assert(nm_info,\\n\\u00a0                ExcMessage(\\n\\u00a0                  \\\"In case of Nitsche-type mortaring NonMatching::MappingInfo \\\\\\n\\u00a0                   has to be provided.\\\"));\\n\\u00a0     }\\n\\u00a0 \\nNonMatching::MappingInfoDefinition mapping_info.h:222\\nThe following function then evaluates the acoustic operator. It first updates the precomputed values in corresponding the FERemoteEvaluation objects. The material parameters do not change and thus, we do not have to update precomputed values in c_r_eval and rho_r_eval.\\nIt then either performs a matrix-free loop with Nitsche-type mortaring at non-matching faces (if use_mortaring is true) or with point-to-point interpolation at non-matching faces (in the else branch). The difference is only in the third argument to the loop function, denoting the function object that is executed at boundary faces.\\n\\u00a0     template <typename VectorType>\\n\\u00a0     void evaluate(VectorType &dst, const VectorType &src) const\\n\\u00a0     {\\n\\u00a0       pressure_r_eval->gather_evaluate(src, EvaluationFlags::values);\\n\\u00a0       velocity_r_eval->gather_evaluate(src, EvaluationFlags::values);\\n\\u00a0 \\n\\u00a0       if constexpr (use_mortaring)\\n\\u00a0         {\\n\\u00a0           matrix_free.loop(\\n\\u00a0             &AcousticOperator::local_apply_cell<VectorType>,\\n\\u00a0             &AcousticOperator::local_apply_face<VectorType>,\\n\\u00a0             &AcousticOperator::local_apply_boundary_face_mortaring<VectorType>,\\n\\u00a0             this,\\n\\u00a0             dst,\\n\\u00a0             src,\\n\\u00a0             true,\\n\\u00a0             MatrixFree<dim, Number>::DataAccessOnFaces::values,\\n\\u00a0             MatrixFree<dim, Number>::DataAccessOnFaces::values);\\n\\u00a0         }\\n\\u00a0       else\\n\\u00a0         {\\n\\u00a0           matrix_free.loop(\\n\\u00a0             &AcousticOperator::local_apply_cell<VectorType>,\\n\\u00a0             &AcousticOperator::local_apply_face<VectorType>,\\n\\u00a0             &AcousticOperator::local_apply_boundary_face_point_to_point<\\n\\u00a0               VectorType>,\\n\\u00a0             this,\\n\\u00a0             dst,\\n\\u00a0             src,\\n\\u00a0             true,\\n\\u00a0             MatrixFree<dim, Number>::DataAccessOnFaces::values,\\n\\u00a0             MatrixFree<dim, Number>::DataAccessOnFaces::values);\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\nIn the private section of the class, we then define the functions that evaluate volume, interior face, and boundary face integrals. The concrete terms these functions evaluate are stated in the documentation at the top of this tutorial program. Each of these functions has its own object of type MaterialEvaluation that provides access to the material at each cell or face.\\n\\u00a0   private:\\n\\u00a0     template <typename VectorType>\\n\\u00a0     void local_apply_cell(\\n\\u00a0       const MatrixFree<dim, Number>               &matrix_free,\\n\\u00a0       VectorType                                  &dst,\\n\\u00a0       const VectorType                            &src,\\n\\u00a0       const std::pair<unsigned int, unsigned int> &cell_range) const\\n\\u00a0     {\\n\\u00a0       FEEvaluation<dim, -1, 0, 1, Number>   pressure(matrix_free, 0, 0, 0);\\n\\u00a0       FEEvaluation<dim, -1, 0, dim, Number> velocity(matrix_free, 0, 0, 1);\\n\\u00a0 \\n\\u00a0       MaterialEvaluation material(matrix_free, *material_data);\\n\\u00a0 \\n\\u00a0       for (unsigned int cell = cell_range.first; cell < cell_range.second;\\n\\u00a0            ++cell)\\n\\u00a0         {\\n\\u00a0           velocity.reinit(cell);\\n\\u00a0           pressure.reinit(cell);\\n\\u00a0 \\n\\u00a0           pressure.gather_evaluate(src, EvaluationFlags::gradients);\\n\\u00a0           velocity.gather_evaluate(src, EvaluationFlags::gradients);\\n\\u00a0 \\nEvaluationFlags::gradients@ gradientsDefinition evaluation_flags.h:54\\nGet the materials on the corresponding cell. Since we introduced MaterialEvaluation we can write the code independent of whether the material is homogeneous or inhomogeneous.\\n\\u00a0           material.reinit_cell(cell);\\n\\u00a0           const auto c   = material.get_speed_of_sound();\\n\\u00a0           const auto rho = material.get_density();\\n\\u00a0 \\n\\u00a0           for (const unsigned int q : pressure.quadrature_point_indices())\\n\\u00a0             {\\n\\u00a0               pressure.submit_value(rho * c * c * velocity.get_divergence(q),\\n\\u00a0                                     q);\\n\\u00a0               velocity.submit_value(1.0 / rho * pressure.get_gradient(q), q);\\n\\u00a0             }\\n\\u00a0 \\n\\u00a0           pressure.integrate_scatter(EvaluationFlags::values, dst);\\n\\u00a0           velocity.integrate_scatter(EvaluationFlags::values, dst);\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\nThis next function evaluates the fluxes at faces between cells with the same material. If boundary faces are under consideration fluxes into neighboring faces do not have to be considered which is enforced via weight_neighbor=false. For non-matching faces the fluxes into neighboring faces are not considered as well. This is because we iterate over each side of the non-matching face separately (similar to a cell centric loop).\\nIn this and following functions, we also introduce the factors \\\\(\\\\tau\\\\) and \\\\(\\\\gamma\\\\) that are computed from \\\\(\\\\rho\\\\) and \\\\(c\\\\) along interfaces and that appear in the bilinear forms. Their definitions are provided in the introduction.\\n\\u00a0     template <bool weight_neighbor,\\n\\u00a0               typename InternalFaceIntegratorPressure,\\n\\u00a0               typename InternalFaceIntegratorVelocity,\\n\\u00a0               typename ExternalFaceIntegratorPressure,\\n\\u00a0               typename ExternalFaceIntegratorVelocity>\\n\\u00a0     inline DEAL_II_ALWAYS_INLINE void evaluate_face_kernel(\\n\\u00a0       InternalFaceIntegratorPressure                           &pressure_m,\\n\\u00a0       InternalFaceIntegratorVelocity                           &velocity_m,\\n\\u00a0       ExternalFaceIntegratorPressure                           &pressure_p,\\n\\u00a0       ExternalFaceIntegratorVelocity                           &velocity_p,\\n\\u00a0       const typename InternalFaceIntegratorPressure::value_type c,\\n\\u00a0       const typename InternalFaceIntegratorPressure::value_type rho) const\\n\\u00a0     {\\n\\u00a0       const auto tau   = 0.5 * rho * c;\\n\\u00a0       const auto gamma = 0.5 / (rho * c);\\n\\u00a0 \\n\\u00a0       for (const unsigned int q : pressure_m.quadrature_point_indices())\\n\\u00a0         {\\n\\u00a0           const auto n  = pressure_m.normal_vector(q);\\n\\u00a0           const auto pm = pressure_m.get_value(q);\\n\\u00a0           const auto um = velocity_m.get_value(q);\\n\\u00a0 \\n\\u00a0           const auto pp = pressure_p.get_value(q);\\n\\u00a0           const auto up = velocity_p.get_value(q);\\n\\u00a0 \\nDEAL_II_ALWAYS_INLINE#define DEAL_II_ALWAYS_INLINEDefinition config.h:109\\nCompute homogeneous local Lax-Friedrichs fluxes and submit the corresponding values to the integrators.\\n\\u00a0           const auto momentum_flux =\\n\\u00a0             0.5 * (pm + pp) + 0.5 * tau * (um - up) * n;\\n\\u00a0           velocity_m.submit_value(1.0 / rho * (momentum_flux - pm) * n, q);\\n\\u00a0           if constexpr (weight_neighbor)\\n\\u00a0             velocity_p.submit_value(1.0 / rho * (momentum_flux - pp) * (-n), q);\\n\\u00a0 \\n\\u00a0           const auto mass_flux = 0.5 * (um + up) + 0.5 * gamma * (pm - pp) * n;\\n\\u00a0           pressure_m.submit_value(rho * c * c * (mass_flux - um) * n, q);\\n\\u00a0           if constexpr (weight_neighbor)\\n\\u00a0             pressure_p.submit_value(rho * c * c * (mass_flux - up) * (-n), q);\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\nThis function evaluates the fluxes at faces between cells with different materials. This can only happen over non-matching interfaces. Therefore, it is implicitly known that weight_neighbor=false and we can omit the parameter.\\n\\u00a0     template <typename InternalFaceIntegratorPressure,\\n\\u00a0               typename InternalFaceIntegratorVelocity,\\n\\u00a0               typename ExternalFaceIntegratorPressure,\\n\\u00a0               typename ExternalFaceIntegratorVelocity,\\n\\u00a0               typename MaterialIntegrator>\\n\\u00a0     void evaluate_face_kernel_inhomogeneous(\\n\\u00a0       InternalFaceIntegratorPressure                           &pressure_m,\\n\\u00a0       InternalFaceIntegratorVelocity                           &velocity_m,\\n\\u00a0       const ExternalFaceIntegratorPressure                     &pressure_p,\\n\\u00a0       const ExternalFaceIntegratorVelocity                     &velocity_p,\\n\\u00a0       const typename InternalFaceIntegratorPressure::value_type c,\\n\\u00a0       const typename InternalFaceIntegratorPressure::value_type rho,\\n\\u00a0       const MaterialIntegrator                                 &c_r,\\n\\u00a0       const MaterialIntegrator                                 &rho_r) const\\n\\u00a0     {\\n\\u00a0       const auto tau_m   = 0.5 * rho * c;\\n\\u00a0       const auto gamma_m = 0.5 / (rho * c);\\n\\u00a0 \\n\\u00a0       for (const unsigned int q : pressure_m.quadrature_point_indices())\\n\\u00a0         {\\n\\u00a0           const auto c_p           = c_r.get_value(q);\\n\\u00a0           const auto rho_p         = rho_r.get_value(q);\\n\\u00a0           const auto tau_p         = 0.5 * rho_p * c_p;\\n\\u00a0           const auto gamma_p       = 0.5 / (rho_p * c_p);\\n\\u00a0           const auto tau_sum_inv   = 1.0 / (tau_m + tau_p);\\n\\u00a0           const auto gamma_sum_inv = 1.0 / (gamma_m + gamma_p);\\n\\u00a0 \\n\\u00a0           const auto n  = pressure_m.normal_vector(q);\\n\\u00a0           const auto pm = pressure_m.get_value(q);\\n\\u00a0           const auto um = velocity_m.get_value(q);\\n\\u00a0 \\n\\u00a0           const auto pp = pressure_p.get_value(q);\\n\\u00a0           const auto up = velocity_p.get_value(q);\\n\\u00a0 \\n\\u00a0 \\nCompute inhomogeneous fluxes and submit the corresponding values to the integrators.\\n\\u00a0           const auto momentum_flux =\\n\\u00a0             pm - tau_m * tau_sum_inv * (pm - pp) +\\n\\u00a0             tau_m * tau_p * tau_sum_inv * (um - up) * n;\\n\\u00a0           velocity_m.submit_value(1.0 / rho * (momentum_flux - pm) * n, q);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0           const auto mass_flux =\\n\\u00a0             um - gamma_m * gamma_sum_inv * (um - up) +\\n\\u00a0             gamma_m * gamma_p * gamma_sum_inv * (pm - pp) * n;\\n\\u00a0 \\n\\u00a0           pressure_m.submit_value(rho * c * c * (mass_flux - um) * n, q);\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\nThis function evaluates the inner face integrals.\\n\\u00a0     template <typename VectorType>\\n\\u00a0     void local_apply_face(\\n\\u00a0       const MatrixFree<dim, Number>               &matrix_free,\\n\\u00a0       VectorType                                  &dst,\\n\\u00a0       const VectorType                            &src,\\n\\u00a0       const std::pair<unsigned int, unsigned int> &face_range) const\\n\\u00a0     {\\n\\u00a0       FEFaceEvaluation<dim, -1, 0, 1, Number> pressure_m(\\n\\u00a0         matrix_free, true, 0, 0, 0);\\n\\u00a0       FEFaceEvaluation<dim, -1, 0, 1, Number> pressure_p(\\n\\u00a0         matrix_free, false, 0, 0, 0);\\n\\u00a0       FEFaceEvaluation<dim, -1, 0, dim, Number> velocity_m(\\n\\u00a0         matrix_free, true, 0, 0, 1);\\n\\u00a0       FEFaceEvaluation<dim, -1, 0, dim, Number> velocity_p(\\n\\u00a0         matrix_free, false, 0, 0, 1);\\n\\u00a0 \\n\\u00a0       MaterialEvaluation material(matrix_free, *material_data);\\n\\u00a0 \\n\\u00a0       for (unsigned int face = face_range.first; face < face_range.second;\\n\\u00a0            ++face)\\n\\u00a0         {\\n\\u00a0           velocity_m.reinit(face);\\n\\u00a0           velocity_p.reinit(face);\\n\\u00a0 \\n\\u00a0           pressure_m.reinit(face);\\n\\u00a0           pressure_p.reinit(face);\\n\\u00a0 \\n\\u00a0           pressure_m.gather_evaluate(src, EvaluationFlags::values);\\n\\u00a0           pressure_p.gather_evaluate(src, EvaluationFlags::values);\\n\\u00a0 \\n\\u00a0           velocity_m.gather_evaluate(src, EvaluationFlags::values);\\n\\u00a0           velocity_p.gather_evaluate(src, EvaluationFlags::values);\\n\\u00a0 \\n\\u00a0           material.reinit_face(face);\\n\\u00a0           evaluate_face_kernel<true>(pressure_m,\\n\\u00a0                                      velocity_m,\\n\\u00a0                                      pressure_p,\\n\\u00a0                                      velocity_p,\\n\\u00a0                                      material.get_speed_of_sound(),\\n\\u00a0                                      material.get_density());\\n\\u00a0 \\n\\u00a0           pressure_m.integrate_scatter(EvaluationFlags::values, dst);\\n\\u00a0           pressure_p.integrate_scatter(EvaluationFlags::values, dst);\\n\\u00a0           velocity_m.integrate_scatter(EvaluationFlags::values, dst);\\n\\u00a0           velocity_p.integrate_scatter(EvaluationFlags::values, dst);\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n Matrix-free boundary function for point-to-point interpolation\\nThe following function then evaluates the boundary face integrals and the non-matching face integrals using point-to-point interpolation.\\n\\u00a0     template <typename VectorType>\\n\\u00a0     void local_apply_boundary_face_point_to_point(\\n\\u00a0       const MatrixFree<dim, Number>               &matrix_free,\\n\\u00a0       VectorType                                  &dst,\\n\\u00a0       const VectorType                            &src,\\n\\u00a0       const std::pair<unsigned int, unsigned int> &face_range) const\\n\\u00a0     {\\n\\u00a0       FEFaceEvaluation<dim, -1, 0, 1, Number> pressure_m(\\n\\u00a0         matrix_free, true, 0, 0, 0);\\n\\u00a0       FEFaceEvaluation<dim, -1, 0, dim, Number> velocity_m(\\n\\u00a0         matrix_free, true, 0, 0, 1);\\n\\u00a0 \\n\\u00a0       BCEvaluationP pressure_bc(pressure_m);\\n\\u00a0       BCEvaluationU velocity_bc(velocity_m);\\n\\u00a0 \\n\\u00a0       MaterialEvaluation material(matrix_free, *material_data);\\n\\u00a0 \\nRemote evaluators.\\n\\u00a0       auto pressure_r = pressure_r_eval->get_data_accessor();\\n\\u00a0       auto velocity_r = velocity_r_eval->get_data_accessor();\\n\\u00a0       auto c_r        = c_r_eval->get_data_accessor();\\n\\u00a0       auto rho_r      = rho_r_eval->get_data_accessor();\\n\\u00a0 \\n\\u00a0       for (unsigned int face = face_range.first; face < face_range.second;\\n\\u00a0            ++face)\\n\\u00a0         {\\n\\u00a0           velocity_m.reinit(face);\\n\\u00a0           pressure_m.reinit(face);\\n\\u00a0 \\n\\u00a0           pressure_m.gather_evaluate(src, EvaluationFlags::values);\\n\\u00a0           velocity_m.gather_evaluate(src, EvaluationFlags::values);\\n\\u00a0 \\n\\u00a0           if (HelperFunctions::is_non_matching_face(\\n\\u00a0                 remote_face_ids, matrix_free.get_boundary_id(face)))\\n\\u00a0             {\\nIf face is non-matching we have to query values via the FERemoteEvaluaton objects. This is done by passing the corresponding FERemoteEvaluaton objects to the function that evaluates the kernel. As mentioned above, each side of the non-matching interface is traversed separately and we do not have to consider the neighbor in the kernel. Note, that the values in the FERemoteEvaluaton objects are already updated at this point.\\nFor point-to-point interpolation we simply use the corresponding FERemoteEvaluaton objects in combination with the standard FEFaceEvaluation objects.\\n\\u00a0               velocity_r.reinit(face);\\n\\u00a0               pressure_r.reinit(face);\\n\\u00a0 \\n\\u00a0               material.reinit_face(face);\\n\\u00a0 \\nIf we are considering a homogeneous material, do not use the inhomogeneous fluxes. While it would be possible to use the inhomogeneous fluxes they are more expensive to compute.\\n\\u00a0               if (material.is_homogeneous())\\n\\u00a0                 {\\n\\u00a0                   evaluate_face_kernel<false>(pressure_m,\\n\\u00a0                                               velocity_m,\\n\\u00a0                                               pressure_r,\\n\\u00a0                                               velocity_r,\\n\\u00a0                                               material.get_speed_of_sound(),\\n\\u00a0                                               material.get_density());\\n\\u00a0                 }\\n\\u00a0               else\\n\\u00a0                 {\\n\\u00a0                   c_r.reinit(face);\\n\\u00a0                   rho_r.reinit(face);\\n\\u00a0                   evaluate_face_kernel_inhomogeneous(\\n\\u00a0                     pressure_m,\\n\\u00a0                     velocity_m,\\n\\u00a0                     pressure_r,\\n\\u00a0                     velocity_r,\\n\\u00a0                     material.get_speed_of_sound(),\\n\\u00a0                     material.get_density(),\\n\\u00a0                     c_r,\\n\\u00a0                     rho_r);\\n\\u00a0                 }\\n\\u00a0             }\\n\\u00a0           else\\n\\u00a0             {\\nIf face is a standard boundary face, evaluate the integral as usual in the matrix free context. To be able to use the same kernel as for inner faces we pass the boundary condition objects to the function that evaluates the kernel. As detailed above weight_neighbor=false.\\n\\u00a0               material.reinit_face(face);\\n\\u00a0               evaluate_face_kernel<false>(pressure_m,\\n\\u00a0                                           velocity_m,\\n\\u00a0                                           pressure_bc,\\n\\u00a0                                           velocity_bc,\\n\\u00a0                                           material.get_speed_of_sound(),\\n\\u00a0                                           material.get_density());\\n\\u00a0             }\\n\\u00a0 \\n\\u00a0           pressure_m.integrate_scatter(EvaluationFlags::values, dst);\\n\\u00a0           velocity_m.integrate_scatter(EvaluationFlags::values, dst);\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\n Matrix-free boundary function for Nitsche-type mortaring\\nThis function evaluates the boundary face integrals and the non-matching face integrals using Nitsche-type mortaring.\\n\\u00a0     template <typename VectorType>\\n\\u00a0     void local_apply_boundary_face_mortaring(\\n\\u00a0       const MatrixFree<dim, Number>               &matrix_free,\\n\\u00a0       VectorType                                  &dst,\\n\\u00a0       const VectorType                            &src,\\n\\u00a0       const std::pair<unsigned int, unsigned int> &face_range) const\\n\\u00a0     {\\n\\u00a0       FEFaceEvaluation<dim, -1, 0, 1, Number> pressure_m(\\n\\u00a0         matrix_free, true, 0, 0, 0);\\n\\u00a0       FEFaceEvaluation<dim, -1, 0, dim, Number> velocity_m(\\n\\u00a0         matrix_free, true, 0, 0, 1);\\n\\u00a0 \\nFor Nitsche-type mortaring we are evaluating the integrals over intersections. This is why, quadrature points are arbitrarily distributed on every face. Thus, we can not make use of face batches and FEFaceEvaluation but have to consider each face individually and make use of FEFacePointEvaluation to evaluate the integrals in the arbitrarily distributed quadrature points. Since the setup of FEFacePointEvaluation is more expensive than that of FEEvaluation we do the setup only once. For this we are using the helper function get_thread_safe_fe_face_point_evaluation_object().\\n\\u00a0       FEFacePointEvaluation<1, dim, dim, Number> &pressure_m_mortar =\\n\\u00a0         get_thread_safe_fe_face_point_evaluation_object<1>(\\n\\u00a0           thread_local_pressure_m_mortar, 0);\\n\\u00a0       FEFacePointEvaluation<dim, dim, dim, Number> &velocity_m_mortar =\\n\\u00a0         get_thread_safe_fe_face_point_evaluation_object<dim>(\\n\\u00a0           thread_local_velocity_m_mortar, 1);\\n\\u00a0 \\n\\u00a0       BCEvaluationP pressure_bc(pressure_m);\\n\\u00a0       BCEvaluationU velocity_bc(velocity_m);\\n\\u00a0 \\n\\u00a0       MaterialEvaluation material(matrix_free, *material_data);\\n\\u00a0 \\n\\u00a0       auto pressure_r_mortar = pressure_r_eval->get_data_accessor();\\n\\u00a0       auto velocity_r_mortar = velocity_r_eval->get_data_accessor();\\n\\u00a0       auto c_r               = c_r_eval->get_data_accessor();\\n\\u00a0       auto rho_r             = rho_r_eval->get_data_accessor();\\n\\u00a0 \\n\\u00a0       for (unsigned int face = face_range.first; face < face_range.second;\\n\\u00a0            ++face)\\n\\u00a0         {\\n\\u00a0           if (HelperFunctions::is_non_matching_face(\\n\\u00a0                 remote_face_ids, matrix_free.get_boundary_id(face)))\\n\\u00a0             {\\n\\u00a0               material.reinit_face(face);\\n\\u00a0 \\nFEFacePointEvaluationDefinition fe_point_evaluation.h:1536\\nFirst fetch the DoF values with standard FEFaceEvaluation objects.\\n\\u00a0               pressure_m.reinit(face);\\n\\u00a0               velocity_m.reinit(face);\\n\\u00a0 \\n\\u00a0               pressure_m.read_dof_values(src);\\n\\u00a0               velocity_m.read_dof_values(src);\\n\\u00a0 \\nProject the internally stored values into the face DoFs of the current face.\\n\\u00a0               pressure_m.project_to_face(EvaluationFlags::values);\\n\\u00a0               velocity_m.project_to_face(EvaluationFlags::values);\\n\\u00a0 \\nFor mortaring, we have to consider every face from the face batches separately and have to use the FEFacePointEvaluation objects to be able to evaluate the integrals with the arbitrarily distributed quadrature points.\\n\\u00a0               for (unsigned int v = 0;\\n\\u00a0                    v < matrix_free.n_active_entries_per_face_batch(face);\\n\\u00a0                    ++v)\\n\\u00a0                 {\\n\\u00a0                   constexpr unsigned int n_lanes =\\n\\u00a0                     VectorizedArray<Number>::size();\\n\\u00a0                   velocity_m_mortar.reinit(face * n_lanes + v);\\n\\u00a0                   pressure_m_mortar.reinit(face * n_lanes + v);\\n\\u00a0 \\nVectorizedArrayBase< VectorizedArray< Number, width >, 1 >::sizestatic constexpr std::size_t size()Definition vectorization.h:285\\nEvaluate using FEFacePointEvaluation. As buffer, simply use the internal buffers from the FEFaceEvaluation objects.\\n\\u00a0                   velocity_m_mortar.evaluate_in_face(\\n\\u00a0                     &velocity_m.get_scratch_data().begin()[0][v],\\n\\u00a0                     EvaluationFlags::values);\\n\\u00a0 \\n\\u00a0                   pressure_m_mortar.evaluate_in_face(\\n\\u00a0                     &pressure_m.get_scratch_data().begin()[0][v],\\n\\u00a0                     EvaluationFlags::values);\\n\\u00a0 \\n\\u00a0                   velocity_r_mortar.reinit(face * n_lanes + v);\\n\\u00a0                   pressure_r_mortar.reinit(face * n_lanes + v);\\n\\u00a0 \\nAs above, if we are considering a homogeneous material, do not use the inhomogeneous fluxes. Since we are operating on face v we call material.get_density()[v].\\n\\u00a0                   if (material.is_homogeneous())\\n\\u00a0                     {\\n\\u00a0                       evaluate_face_kernel<false>(\\n\\u00a0                         pressure_m_mortar,\\n\\u00a0                         velocity_m_mortar,\\n\\u00a0                         pressure_r_mortar,\\n\\u00a0                         velocity_r_mortar,\\n\\u00a0                         material.get_speed_of_sound()[v],\\n\\u00a0                         material.get_density()[v]);\\n\\u00a0                     }\\n\\u00a0                   else\\n\\u00a0                     {\\n\\u00a0                       c_r.reinit(face * n_lanes + v);\\n\\u00a0                       rho_r.reinit(face * n_lanes + v);\\n\\u00a0 \\n\\u00a0                       evaluate_face_kernel_inhomogeneous(\\n\\u00a0                         pressure_m_mortar,\\n\\u00a0                         velocity_m_mortar,\\n\\u00a0                         pressure_r_mortar,\\n\\u00a0                         velocity_r_mortar,\\n\\u00a0                         material.get_speed_of_sound()[v],\\n\\u00a0                         material.get_density()[v],\\n\\u00a0                         c_r,\\n\\u00a0                         rho_r);\\n\\u00a0                     }\\n\\u00a0 \\nIntegrate using FEFacePointEvaluation. As buffer, simply use the internal buffers from the FEFaceEvaluation objects.\\n\\u00a0                   velocity_m_mortar.integrate_in_face(\\n\\u00a0                     &velocity_m.get_scratch_data().begin()[0][v],\\n\\u00a0                     EvaluationFlags::values);\\n\\u00a0 \\n\\u00a0                   pressure_m_mortar.integrate_in_face(\\n\\u00a0                     &pressure_m.get_scratch_data().begin()[0][v],\\n\\u00a0                     EvaluationFlags::values);\\n\\u00a0                 }\\n\\u00a0 \\nCollect the contributions from the face DoFs to the internal cell DoFs to be able to use the member function distribute_local_to_global().\\n\\u00a0               pressure_m.collect_from_face(EvaluationFlags::values);\\n\\u00a0               velocity_m.collect_from_face(EvaluationFlags::values);\\n\\u00a0 \\n\\u00a0               pressure_m.distribute_local_to_global(dst);\\n\\u00a0               velocity_m.distribute_local_to_global(dst);\\n\\u00a0             }\\n\\u00a0           else\\n\\u00a0             {\\n\\u00a0               velocity_m.reinit(face);\\n\\u00a0               pressure_m.reinit(face);\\n\\u00a0 \\n\\u00a0               pressure_m.gather_evaluate(src, EvaluationFlags::values);\\n\\u00a0               velocity_m.gather_evaluate(src, EvaluationFlags::values);\\n\\u00a0 \\n\\u00a0               material.reinit_face(face);\\n\\u00a0               evaluate_face_kernel<false>(pressure_m,\\n\\u00a0                                           velocity_m,\\n\\u00a0                                           pressure_bc,\\n\\u00a0                                           velocity_bc,\\n\\u00a0                                           material.get_speed_of_sound(),\\n\\u00a0                                           material.get_density());\\n\\u00a0 \\n\\u00a0               pressure_m.integrate_scatter(EvaluationFlags::values, dst);\\n\\u00a0               velocity_m.integrate_scatter(EvaluationFlags::values, dst);\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     const MatrixFree<dim, Number> &matrix_free;\\n\\u00a0 \\n\\u00a0     const std::shared_ptr<CellwiseMaterialData<Number>> material_data;\\n\\u00a0 \\n\\u00a0     const std::set<types::boundary_id> remote_face_ids;\\n\\u00a0 \\nFERemoteEvaluation objects are stored as shared pointers. This way, they can also be used for other operators without precomputing the values multiple times.\\n\\u00a0     const std::shared_ptr<FERemoteEvaluation<dim, 1, remote_value_type>>\\n\\u00a0       pressure_r_eval;\\n\\u00a0     const std::shared_ptr<FERemoteEvaluation<dim, dim, remote_value_type>>\\n\\u00a0       velocity_r_eval;\\n\\u00a0 \\n\\u00a0     const std::shared_ptr<FERemoteEvaluation<dim, 1, remote_value_type>>\\n\\u00a0       c_r_eval;\\n\\u00a0     const std::shared_ptr<FERemoteEvaluation<dim, 1, remote_value_type>>\\n\\u00a0       rho_r_eval;\\n\\u00a0 \\n\\u00a0     const std::shared_ptr<NonMatching::MappingInfo<dim, dim, Number>>\\n\\u00a0       nm_mapping_info;\\n\\u00a0 \\nWe store FEFacePointEvaluation objects as members in a thread local way, since its creation is more expensive compared to FEEvaluation objects.\\n\\u00a0     mutable Threads::ThreadLocalStorage<\\n\\u00a0       std::unique_ptr<FEFacePointEvaluation<1, dim, dim, Number>>>\\n\\u00a0       thread_local_pressure_m_mortar;\\n\\u00a0 \\n\\u00a0     mutable Threads::ThreadLocalStorage<\\n\\u00a0       std::unique_ptr<FEFacePointEvaluation<dim, dim, dim, Number>>>\\n\\u00a0       thread_local_velocity_m_mortar;\\n\\u00a0 \\nThreads::ThreadLocalStorageA class that provides a separate storage location on each thread that accesses the object.Definition thread_local_storage.h:105\\nHelper function to create and get FEFacePointEvaluation objects in a thread safe way. On each thread, FEFacePointEvaluation is created if it has not been created by now. After that, simply return the object corresponding to the thread under consideration.\\n\\u00a0     template <int n_components>\\n\\u00a0     FEFacePointEvaluation<n_components, dim, dim, Number> &\\n\\u00a0     get_thread_safe_fe_face_point_evaluation_object(\\n\\u00a0       Threads::ThreadLocalStorage<\\n\\u00a0         std::unique_ptr<FEFacePointEvaluation<n_components, dim, dim, Number>>>\\n\\u00a0                   &fe_face_point_eval_thread_local,\\n\\u00a0       unsigned int fist_selected_comp) const\\n\\u00a0     {\\n\\u00a0       if (fe_face_point_eval_thread_local.get() == nullptr)\\n\\u00a0         {\\n\\u00a0           fe_face_point_eval_thread_local = std::make_unique<\\n\\u00a0             FEFacePointEvaluation<n_components, dim, dim, Number>>(\\n\\u00a0             *nm_mapping_info,\\n\\u00a0             matrix_free.get_dof_handler().get_fe(),\\n\\u00a0             true,\\n\\u00a0             fist_selected_comp);\\n\\u00a0         }\\n\\u00a0       return *fe_face_point_eval_thread_local.get();\\n\\u00a0     }\\n\\u00a0   };\\n\\u00a0 \\n Inverse mass operator\\nFor the time stepping methods below, we need the inverse mass operator. We apply it via a loop over all (batches of) cells as always, where the contribution of each cell is computed in a matrix-free way:\\n\\u00a0   template <int dim, typename Number>\\n\\u00a0   class InverseMassOperator\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     InverseMassOperator(const MatrixFree<dim, Number> &matrix_free)\\n\\u00a0       : matrix_free(matrix_free)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     template <typename VectorType>\\n\\u00a0     void apply(VectorType &dst, const VectorType &src) const\\n\\u00a0     {\\n\\u00a0       dst.zero_out_ghost_values();\\n\\u00a0       matrix_free.cell_loop(&InverseMassOperator::local_apply_cell<VectorType>,\\n\\u00a0                             this,\\n\\u00a0                             dst,\\n\\u00a0                             src);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     template <typename VectorType>\\n\\u00a0     void local_apply_cell(\\n\\u00a0       const MatrixFree<dim, Number>               &mf,\\n\\u00a0       VectorType                                  &dst,\\n\\u00a0       const VectorType                            &src,\\n\\u00a0       const std::pair<unsigned int, unsigned int> &cell_range) const\\n\\u00a0     {\\n\\u00a0       FEEvaluation<dim, -1, 0, dim + 1, Number> phi(mf);\\n\\u00a0       MatrixFreeOperators::CellwiseInverseMassMatrix<dim, -1, dim + 1, Number>\\n\\u00a0         minv(phi);\\n\\u00a0 \\n\\u00a0       for (unsigned int cell = cell_range.first; cell < cell_range.second;\\n\\u00a0            ++cell)\\n\\u00a0         {\\n\\u00a0           phi.reinit(cell);\\n\\u00a0           phi.read_dof_values(src);\\n\\u00a0           minv.apply(phi.begin_dof_values(), phi.begin_dof_values());\\n\\u00a0           phi.set_dof_values(dst);\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     const MatrixFree<dim, Number> &matrix_free;\\n\\u00a0   };\\n\\u00a0 \\nMatrixFreeOperators::CellwiseInverseMassMatrixDefinition operators.h:622\\nMatrixFree::cell_loopvoid cell_loop(const std::function< void(const MatrixFree< dim, Number, VectorizedArrayType > &, OutVector &, const InVector &, const std::pair< unsigned int, unsigned int > &)> &cell_operation, OutVector &dst, const InVector &src, const bool zero_dst_vector=false) const\\n Runge-Kutta time-stepping\\nThis class implements a Runge-Kutta scheme of order 2.\\n\\u00a0   template <int dim, typename Number, typename remote_value_type>\\n\\u00a0   class RungeKutta2\\n\\u00a0   {\\n\\u00a0     using VectorType = LinearAlgebra::distributed::Vector<Number>;\\n\\u00a0 \\n\\u00a0   public:\\n\\u00a0     RungeKutta2(\\n\\u00a0       const std::shared_ptr<InverseMassOperator<dim, Number>>\\n\\u00a0         inverse_mass_operator,\\n\\u00a0       const std::shared_ptr<AcousticOperator<dim, Number, remote_value_type>>\\n\\u00a0         acoustic_operator)\\n\\u00a0       : inverse_mass_operator(inverse_mass_operator)\\n\\u00a0       , acoustic_operator(acoustic_operator)\\n\\u00a0     {}\\n\\u00a0 \\nLinearAlgebra::distributed::VectorDefinition la_parallel_vector.h:250\\nThe run() function of this class contains the time loop. It starts by initializing some member variables (such as short-cuts to objects that describe the finite element, its properties, and the mapping; an by initializing vectors). It then computes the time step size via minimum element edge length. Assuming non-distorted elements, we can compute the edge length as the distance between two vertices. From this, we can then obtain the time step size via the CFL condition.\\n\\u00a0     void run(const MatrixFree<dim, Number> &matrix_free,\\n\\u00a0              const double                   cr,\\n\\u00a0              const double                   end_time,\\n\\u00a0              const double                   speed_of_sound,\\n\\u00a0              const Function<dim>           &initial_condition,\\n\\u00a0              const std::string             &vtk_prefix)\\n\\u00a0     {\\n\\u00a0       const auto &dof_handler = matrix_free.get_dof_handler();\\n\\u00a0       const auto &mapping     = *matrix_free.get_mapping_info().mapping;\\n\\u00a0       const auto  degree      = dof_handler.get_fe().degree;\\n\\u00a0 \\n\\u00a0       VectorType solution;\\n\\u00a0       matrix_free.initialize_dof_vector(solution);\\n\\u00a0       VectorType solution_temp;\\n\\u00a0       matrix_free.initialize_dof_vector(solution_temp);\\n\\u00a0 \\n\\u00a0       HelperFunctions::set_initial_condition(matrix_free,\\n\\u00a0                                              initial_condition,\\n\\u00a0                                              solution);\\n\\u00a0 \\n\\u00a0       double h_local_min = std::numeric_limits<double>::max();\\n\\u00a0       for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0         h_local_min =\\n\\u00a0           std::min(h_local_min,\\n\\u00a0                    (cell->vertex(1) - cell->vertex(0)).norm_square());\\n\\u00a0       h_local_min = std::sqrt(h_local_min);\\n\\u00a0       const double h_min =\\n\\u00a0         Utilities::MPI::min(h_local_min, dof_handler.get_communicator());\\n\\u00a0 \\n\\u00a0       const double dt =\\n\\u00a0         cr * HelperFunctions::compute_dt_cfl(h_min, degree, speed_of_sound);\\n\\u00a0 \\nMatrixFree::initialize_dof_vectorvoid initialize_dof_vector(VectorType &vec, const unsigned int dof_handler_index=0) const\\nUtilities::MPI::minT min(const T &t, const MPI_Comm mpi_communicator)\\nstdSTL namespace.\\nWe can then perform the time integration loop:\\n\\u00a0       double       time     = 0.0;\\n\\u00a0       unsigned int timestep = 0;\\n\\u00a0       while (time < end_time)\\n\\u00a0         {\\n\\u00a0           HelperFunctions::write_vtu(solution,\\n\\u00a0                                      matrix_free.get_dof_handler(),\\n\\u00a0                                      mapping,\\n\\u00a0                                      degree,\\n\\u00a0                                      \\\"step_89-\\\" + vtk_prefix +\\n\\u00a0                                        std::to_string(timestep));\\n\\u00a0 \\n\\u00a0           std::swap(solution, solution_temp);\\n\\u00a0           time += dt;\\n\\u00a0           ++timestep;\\n\\u00a0           perform_time_step(dt, solution, solution_temp);\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\nThe main work of this class is done by a private member function that performs one Runge-Kutta 2 time step. Recall that this method requires two sub-steps (\\\"stages\\\") computing intermediate values k1 and k2, after which the intermediate values are summed with weights to obtain the new solution at the end of the time step. The RK2 method allows for the elimination of the intermediate vector k2 by utilizing the dst vector as temporary storage.\\n\\u00a0   private:\\n\\u00a0     void\\n\\u00a0     perform_time_step(const double dt, VectorType &dst, const VectorType &src)\\n\\u00a0     {\\n\\u00a0       VectorType k1 = src;\\n\\u00a0 \\n\\u00a0       /* First stage. */\\n\\u00a0       evaluate_stage(k1, src);\\n\\u00a0 \\n\\u00a0       /* Second stage. */\\n\\u00a0       k1.sadd(0.5 * dt, 1.0, src);\\n\\u00a0       evaluate_stage(dst, k1);\\n\\u00a0 \\n\\u00a0       /* Summing things into the output vector. */\\n\\u00a0       dst.sadd(dt, 1.0, src);\\n\\u00a0     }\\n\\u00a0 \\nEvaluating a single Runge-Kutta stage is a straightforward step that really only requires applying the operator once, and then applying the inverse of the mass matrix.\\n\\u00a0     void evaluate_stage(VectorType &dst, const VectorType &src)\\n\\u00a0     {\\n\\u00a0       acoustic_operator->evaluate(dst, src);\\n\\u00a0       dst *= -1.0;\\n\\u00a0       inverse_mass_operator->apply(dst, dst);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     const std::shared_ptr<InverseMassOperator<dim, Number>>\\n\\u00a0       inverse_mass_operator;\\n\\u00a0     const std::shared_ptr<AcousticOperator<dim, Number, remote_value_type>>\\n\\u00a0       acoustic_operator;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n Construction of non-matching triangulations\\nLet us now make our way to the higher-level functions of this program.\\nThe first of these functions creates a two dimensional square triangulation that spans from \\\\((0,0)\\\\) to \\\\((1,1)\\\\). It consists of two sub-domains. The left sub-domain spans from \\\\((0,0)\\\\) to \\\\((0.525,1)\\\\). The right sub-domain spans from \\\\((0.525,0)\\\\) to \\\\((1,1)\\\\). The left sub-domain has elements that are three times smaller compared to the ones for the right sub-domain.\\nAt non-matching interfaces, we need to provide different boundary IDs for the cells that make up the two parts (because, while they may be physically adjacent, they are not logically neighbors given that the faces of cells on both sides do not match, and the Triangulation class will therefore treat the interface between the two parts as a \\\"boundary\\\"). These boundary IDs have to differ because later on RemotePointEvaluation has to search for remote points for each face, that are defined in the same mesh (since we merge the mesh) but not on the same side of the non-matching interface. As a consequence, we declare at the top symbolic names for these boundary indicators, and ensure that we return a set with these values to the caller for later use.\\nThe actual mesh is then constructed by first constructing the left and right parts separately (setting material ids to zero and one, respectively), and using the appropriate boundary ids for all parts of the mesh. We then use GridGenerator::merge_triangulations() to combine them into one (non-matching) mesh. We have to pay attention that should the two sub-triangulations have vertices at the same locations, that they are not merged (connecting the two triangulations logically) since we want the interface to be an actual boundary. We achieve this by providing a tolerance of zero for the merge, see the documentation of the function GridGenerator::merge_triangulations().\\n\\u00a0   template <int dim>\\n\\u00a0   void build_non_matching_triangulation(\\n\\u00a0     Triangulation<dim>           &tria,\\n\\u00a0     std::set<types::boundary_id> &non_matching_faces,\\n\\u00a0     const unsigned int            refinements)\\n\\u00a0   {\\n\\u00a0     const double length = 1.0;\\n\\u00a0 \\n\\u00a0     const types::boundary_id non_matching_id_left  = 98;\\n\\u00a0     const types::boundary_id non_matching_id_right = 99;\\n\\u00a0 \\n\\u00a0     non_matching_faces = {non_matching_id_left, non_matching_id_right};\\n\\u00a0 \\n\\u00a0     /* Construct left part of mesh. */\\n\\u00a0     Triangulation<dim> tria_left;\\n\\u00a0     const unsigned int subdiv_left = 11;\\n\\u00a0     GridGenerator::subdivided_hyper_rectangle(tria_left,\\n\\u00a0                                               {subdiv_left, 2 * subdiv_left},\\n\\u00a0                                               {0.0, 0.0},\\n\\u00a0                                               {0.525 * length, length});\\n\\u00a0 \\n\\u00a0     for (const auto &cell : tria_left.active_cell_iterators())\\n\\u00a0       cell->set_material_id(0);\\n\\u00a0     for (const auto &face : tria_left.active_face_iterators())\\n\\u00a0       if (face->at_boundary())\\n\\u00a0         {\\n\\u00a0           face->set_boundary_id(0);\\n\\u00a0           if (face->center()[0] > 0.525 * length - 1e-6)\\n\\u00a0             face->set_boundary_id(non_matching_id_left);\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0     /* Construct right part of mesh. */\\n\\u00a0     Triangulation<dim> tria_right;\\n\\u00a0     const unsigned int subdiv_right = 4;\\n\\u00a0     GridGenerator::subdivided_hyper_rectangle(tria_right,\\n\\u00a0                                               {subdiv_right, 2 * subdiv_right},\\n\\u00a0                                               {0.525 * length, 0.0},\\n\\u00a0                                               {length, length});\\n\\u00a0 \\n\\u00a0     for (const auto &cell : tria_right.active_cell_iterators())\\n\\u00a0       cell->set_material_id(1);\\n\\u00a0     for (const auto &face : tria_right.active_face_iterators())\\n\\u00a0       if (face->at_boundary())\\n\\u00a0         {\\n\\u00a0           face->set_boundary_id(0);\\n\\u00a0           if (face->center()[0] < 0.525 * length + 1e-6)\\n\\u00a0             face->set_boundary_id(non_matching_id_right);\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0     /* Merge triangulations. */\\n\\u00a0     GridGenerator::merge_triangulations(tria_left,\\n\\u00a0                                         tria_right,\\n\\u00a0                                         tria,\\n\\u00a0                                         /*tolerance*/ 0.,\\n\\u00a0                                         /*copy_manifold_ids*/ false,\\n\\u00a0                                         /*copy_boundary_ids*/ true);\\n\\u00a0 \\n\\u00a0     /* Refine the result. */\\n\\u00a0     tria.refine_global(refinements);\\n\\u00a0   }\\n\\u00a0 \\nTriangulationDefinition tria.h:1323\\nGridGenerator::subdivided_hyper_rectanglevoid subdivided_hyper_rectangle(Triangulation< dim, spacedim > &tria, const std::vector< unsigned int > &repetitions, const Point< dim > &p1, const Point< dim > &p2, const bool colorize=false)\\nGridGenerator::merge_triangulationsvoid merge_triangulations(const Triangulation< dim, spacedim > &triangulation_1, const Triangulation< dim, spacedim > &triangulation_2, Triangulation< dim, spacedim > &result, const double duplicated_vertex_tolerance=1.0e-12, const bool copy_manifold_ids=false, const bool copy_boundary_ids=false)\\n Set up and running of the two schemes\\n Setup and running of the point-to-point interpolation scheme\\nWe are now at the two functions that run the overall schemes (the point-to-point and the mortaring schemes). The first of these functions fills a FERemoteEvaluationCommunicator object that is needed for point-to-point interpolation. Additionally, the corresponding remote evaluators are set up using this remote communicator. Eventually, the operators are handed to the time integrator that runs the simulation.\\n\\u00a0   template <int dim, typename Number>\\n\\u00a0   void run_with_point_to_point_interpolation(\\n\\u00a0     const MatrixFree<dim, Number>      &matrix_free,\\n\\u00a0     const std::set<types::boundary_id> &non_matching_faces,\\n\\u00a0     const std::map<types::material_id, std::pair<double, double>> &materials,\\n\\u00a0     const double                                                   end_time,\\n\\u00a0     const Function<dim> &initial_condition,\\n\\u00a0     const std::string   &vtk_prefix)\\n\\u00a0   {\\n\\u00a0     const auto &dof_handler = matrix_free.get_dof_handler();\\n\\u00a0     const auto &tria        = dof_handler.get_triangulation();\\n\\u00a0 \\nCommunication objects know about the communication pattern. That is, they know about the cells and quadrature points that have to be evaluated at remote faces. This information is given via RemotePointEvaluation. Additionally, the communication objects have to be able to match the quadrature points of the remote points (that provide exterior information) to the quadrature points defined at the interior cell. In case of point-to-point interpolation a vector of pairs with face batch Ids and the number of faces in the batch is needed. FERemoteCommunicationObjectEntityBatches is a container to store this information.\\nThe information is filled outside of the actual class since in some cases the information is available from some heuristic and it is possible to skip some expensive operations. This is for example the case for sliding rotating interfaces with equally spaced elements on both sides of the non-matching interface [76].\\nFor the standard case of point to point-to-point interpolation without any heuristic we make use of the utility function Utilities::compute_remote_communicator_faces_point_to_point_interpolation(). Please refer to the documentation of this function to see how to manually set up the remote communicator from outside.\\nAmong the inputs for the remote communicator we need a list of boundary ids for the non-matching faces, along with a function object for each boundary id that returns a vector of true/false flags in which exactly the vertices of cells of the triangulation are marked that have a face at the boundary id in question.\\n\\u00a0     std::vector<\\n\\u00a0       std::pair<types::boundary_id, std::function<std::vector<bool>()>>>\\n\\u00a0       non_matching_faces_marked_vertices;\\n\\u00a0     for (const auto &nm_face : non_matching_faces)\\n\\u00a0       {\\n\\u00a0         auto marked_vertices = [&nm_face, &tria]() -> std::vector<bool> {\\n\\u00a0           std::vector<bool> mask(tria.n_vertices(), true);\\n\\u00a0 \\n\\u00a0           for (const auto &cell : tria.active_cell_iterators())\\n\\u00a0             for (auto const &f : cell->face_indices())\\n\\u00a0               if (cell->face(f)->at_boundary() &&\\n\\u00a0                   cell->face(f)->boundary_id() == nm_face)\\n\\u00a0                 for (const auto v : cell->vertex_indices())\\n\\u00a0                   mask[cell->vertex_index(v)] = false;\\n\\u00a0 \\n\\u00a0           return mask;\\n\\u00a0         };\\n\\u00a0 \\n\\u00a0         non_matching_faces_marked_vertices.emplace_back(\\n\\u00a0           std::make_pair(nm_face, marked_vertices));\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     auto remote_communicator =\\n\\u00a0       Utilities::compute_remote_communicator_faces_point_to_point_interpolation(\\n\\u00a0         matrix_free, non_matching_faces_marked_vertices);\\n\\u00a0 \\nbool\\nvertex_indicesunsigned int vertex_indices[2]Definition grid_tools_topology.cc:947\\nUtilities::compute_remote_communicator_faces_point_to_point_interpolationFERemoteEvaluationCommunicator< dim > compute_remote_communicator_faces_point_to_point_interpolation(const MatrixFree< dim, Number, VectorizedArrayType > &matrix_free, const std::vector< std::pair< types::boundary_id, std::function< std::vector< bool >()> > > &non_matching_faces_marked_vertices, const unsigned int quad_no=0, const unsigned int dof_no=0, const double tolerance=1e-9)Definition fe_remote_evaluation.h:1083\\nWe are using point-to-point interpolation and can therefore easily access the corresponding data at face batches. This is why we use a VectorizedArray as remote_value_type: \\n\\u00a0     using remote_value_type = VectorizedArray<Number>;\\n\\u00a0 \\nWe then set up FERemoteEvaluation objects that access the pressure and velocity at remote faces, along with an object to describe cell-wise material data.\\n\\u00a0     const auto pressure_r =\\n\\u00a0       std::make_shared<FERemoteEvaluation<dim, 1, remote_value_type>>(\\n\\u00a0         remote_communicator, dof_handler, /*first_selected_component*/ 0);\\n\\u00a0 \\n\\u00a0     const auto velocity_r =\\n\\u00a0       std::make_shared<FERemoteEvaluation<dim, dim, remote_value_type>>(\\n\\u00a0         remote_communicator, dof_handler, /*first_selected_component*/ 1);\\n\\u00a0 \\n\\u00a0     const auto material_data =\\n\\u00a0       std::make_shared<CellwiseMaterialData<Number>>(matrix_free, materials);\\n\\u00a0 \\nIf we have an inhomogeneous problem, we have to set up the material handler that accesses the materials at remote faces.\\n\\u00a0     const auto c_r =\\n\\u00a0       std::make_shared<FERemoteEvaluation<dim, 1, remote_value_type>>(\\n\\u00a0         remote_communicator,\\n\\u00a0         matrix_free.get_dof_handler().get_triangulation(),\\n\\u00a0         /*first_selected_component*/ 0);\\n\\u00a0     const auto rho_r =\\n\\u00a0       std::make_shared<FERemoteEvaluation<dim, 1, remote_value_type>>(\\n\\u00a0         remote_communicator,\\n\\u00a0         matrix_free.get_dof_handler().get_triangulation(),\\n\\u00a0         /*first_selected_component*/ 0);\\n\\u00a0 \\nIf the domain is not homogeneous, i.e., if material parameters change from cell to cell, we initialize and fill DoF vectors that contain the material properties. Materials do not change during the simulation, therefore there is no need to ever compute the values after the first gather_evaluate() (at the end of the following block) again.\\n\\u00a0     if (!material_data->is_homogeneous())\\n\\u00a0       {\\n\\u00a0         Vector<Number> c(\\n\\u00a0           matrix_free.get_dof_handler().get_triangulation().n_active_cells());\\n\\u00a0         Vector<Number> rho(\\n\\u00a0           matrix_free.get_dof_handler().get_triangulation().n_active_cells());\\n\\u00a0 \\n\\u00a0         for (const auto &cell : matrix_free.get_dof_handler()\\n\\u00a0                                   .get_triangulation()\\n\\u00a0                                   .active_cell_iterators())\\n\\u00a0           {\\n\\u00a0             c[cell->active_cell_index()] =\\n\\u00a0               materials.at(cell->material_id()).first;\\n\\u00a0             rho[cell->active_cell_index()] =\\n\\u00a0               materials.at(cell->material_id()).second;\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         c_r->gather_evaluate(c, EvaluationFlags::values);\\n\\u00a0         rho_r->gather_evaluate(rho, EvaluationFlags::values);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0 \\nVectorDefinition vector.h:120\\nfirstPoint< 2 > firstDefinition grid_out.cc:4623\\nNext, we set up the inverse mass operator and the acoustic operator. Using remote_value_type=VectorizedArray<Number> makes the operator use point-to-point interpolation. These two objects are then used to create a RungeKutta2 object to perform the time integration.\\nWe also compute the maximum speed of sound, needed for the computation of the time-step size, and then run the time integrator. For the examples considered here, we found a limiting Courant number of \\\\(\\\\mathrm{Cr}\\\\approx 0.36\\\\) to maintain stability. To ensure, the error of the temporal discretization is small, we use a considerably smaller Courant number of \\\\(0.2\\\\).\\n\\u00a0     const auto inverse_mass_operator =\\n\\u00a0       std::make_shared<InverseMassOperator<dim, Number>>(matrix_free);\\n\\u00a0 \\n\\u00a0     const auto acoustic_operator =\\n\\u00a0       std::make_shared<AcousticOperator<dim, Number, remote_value_type>>(\\n\\u00a0         matrix_free,\\n\\u00a0         material_data,\\n\\u00a0         non_matching_faces,\\n\\u00a0         pressure_r,\\n\\u00a0         velocity_r,\\n\\u00a0         c_r,\\n\\u00a0         rho_r);\\n\\u00a0 \\n\\u00a0     RungeKutta2<dim, Number, remote_value_type> time_integrator(\\n\\u00a0       inverse_mass_operator, acoustic_operator);\\n\\u00a0 \\n\\u00a0     double speed_of_sound_max = 0.0;\\n\\u00a0     for (const auto &mat : materials)\\n\\u00a0       speed_of_sound_max = std::max(speed_of_sound_max, mat.second.first);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     time_integrator.run(matrix_free,\\n\\u00a0                         /*Cr*/ 0.2,\\n\\u00a0                         end_time,\\n\\u00a0                         speed_of_sound_max,\\n\\u00a0                         initial_condition,\\n\\u00a0                         vtk_prefix);\\n\\u00a0   }\\n\\u00a0 \\nsecondPoint< 2 > secondDefinition grid_out.cc:4624\\n Setup and running of the Nitsche-type mortaring scheme\\nThe alternative to the previous function is to use the mortaring scheme \\u2013 implemented in the following function. This function can only be run when deal.II is configured using CGAL (but the previous function can still be used without CGAL), and so errors out if CGAL is not available.\\n\\u00a0   template <int dim, typename Number>\\n\\u00a0   void run_with_nitsche_type_mortaring(\\n\\u00a0     const MatrixFree<dim, Number>      &matrix_free,\\n\\u00a0     const std::set<types::boundary_id> &non_matching_faces,\\n\\u00a0     const std::map<types::material_id, std::pair<double, double>> &materials,\\n\\u00a0     const double                                                   end_time,\\n\\u00a0     const Function<dim> &initial_condition,\\n\\u00a0     const std::string   &vtk_prefix)\\n\\u00a0   {\\n\\u00a0 #ifndef DEAL_II_WITH_CGAL\\n\\u00a0     (void)matrix_free;\\n\\u00a0     (void)non_matching_faces;\\n\\u00a0     (void)materials;\\n\\u00a0     (void)end_time;\\n\\u00a0     (void)initial_condition;\\n\\u00a0     (void)vtk_prefix;\\n\\u00a0 \\n\\u00a0     ConditionalOStream pcout(\\n\\u00a0       std::cout, (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0));\\n\\u00a0 \\n\\u00a0     pcout << \\\"In this function, mortars are computed using CGAL. \\\"\\n\\u00a0              \\\"Configure deal.II with DEAL_II_WITH_CGAL to run this function.\\\\n\\\";\\n\\u00a0 \\n\\u00a0     return;\\n\\u00a0 #else\\n\\u00a0 \\n\\u00a0     const auto &dof_handler       = matrix_free.get_dof_handler();\\n\\u00a0     const auto &tria              = dof_handler.get_triangulation();\\n\\u00a0     const auto &mapping           = *matrix_free.get_mapping_info().mapping;\\n\\u00a0     const auto  n_quadrature_pnts = matrix_free.get_quadrature().size();\\n\\u00a0 \\n\\u00a0     std::vector<\\n\\u00a0       std::pair<types::boundary_id, std::function<std::vector<bool>()>>>\\n\\u00a0       non_matching_faces_marked_vertices;\\n\\u00a0 \\n\\u00a0     for (const auto &nm_face : non_matching_faces)\\n\\u00a0       {\\n\\u00a0         auto marked_vertices = [&]() {\\n\\u00a0           std::vector<bool> mask(tria.n_vertices(), true);\\n\\u00a0 \\n\\u00a0           for (const auto &cell : tria.active_cell_iterators())\\n\\u00a0             for (auto const &f : cell->face_indices())\\n\\u00a0               if (cell->face(f)->at_boundary() &&\\n\\u00a0                   cell->face(f)->boundary_id() == nm_face)\\n\\u00a0                 for (const auto v : cell->vertex_indices())\\n\\u00a0                   mask[cell->vertex_index(v)] = false;\\n\\u00a0 \\n\\u00a0           return mask;\\n\\u00a0         };\\n\\u00a0 \\n\\u00a0         non_matching_faces_marked_vertices.emplace_back(\\n\\u00a0           std::make_pair(nm_face, marked_vertices));\\n\\u00a0       }\\n\\u00a0 \\nConditionalOStreamDefinition conditional_ostream.h:80\\nDEAL_II_WITH_CGAL#define DEAL_II_WITH_CGALDefinition config.h:42\\nUtilities::MPI::this_mpi_processunsigned int this_mpi_process(const MPI_Comm mpi_communicator)Definition mpi.cc:107\\nThe only parts in this function that are functionally different from the previous one follow here.\\nFirst, quadrature points are arbitrarily distributed on each non-matching face. Therefore, we have to make use of FEFacePointEvaluation. FEFacePointEvaluation needs NonMatching::MappingInfo to work at the correct quadrature points that are in sync with used FERemoteEvaluation object. Using compute_remote_communicator_faces_nitsche_type_mortaring() to reinit NonMatching::MappingInfo ensures this. In the case of mortaring, we have to use the weights provided by the quadrature rules that are used to set up NonMatching::MappingInfo. Therefore we set the flag use_global_weights.\\n\\u00a0     typename NonMatching::MappingInfo<dim, dim, Number>::AdditionalData\\n\\u00a0       additional_data;\\n\\u00a0     additional_data.use_global_weights = true;\\n\\u00a0 \\nNonMatching::MappingInfo::AdditionalDataDefinition mapping_info.h:235\\nNonMatching::MappingInfo::AdditionalData::use_global_weightsbool use_global_weightsDefinition mapping_info.h:250\\nSet up NonMatching::MappingInfo with needed update flags and additional_data.\\n\\u00a0     auto nm_mapping_info =\\n\\u00a0       std::make_shared<NonMatching::MappingInfo<dim, dim, Number>>(\\n\\u00a0         mapping,\\n\\u00a0         update_values | update_JxW_values | update_normal_vectors |\\n\\u00a0           update_quadrature_points,\\n\\u00a0         additional_data);\\n\\u00a0 \\n\\u00a0     auto remote_communicator =\\n\\u00a0       Utilities::compute_remote_communicator_faces_nitsche_type_mortaring(\\n\\u00a0         matrix_free,\\n\\u00a0         non_matching_faces_marked_vertices,\\n\\u00a0         n_quadrature_pnts,\\n\\u00a0         0,\\n\\u00a0         nm_mapping_info.get());\\n\\u00a0 \\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_normal_vectors@ update_normal_vectorsNormal vectors.Definition fe_update_flags.h:141\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nUtilities::compute_remote_communicator_faces_nitsche_type_mortaringFERemoteEvaluationCommunicator< dim > compute_remote_communicator_faces_nitsche_type_mortaring(const MatrixFree< dim, Number, VectorizedArrayType > &matrix_free, const std::vector< std::pair< types::boundary_id, std::function< std::vector< bool >()> > > &non_matching_faces_marked_vertices, const unsigned int n_q_pnts_1D, const unsigned int dof_no=0, NonMatching::MappingInfo< dim, dim, Number > *nm_mapping_info=nullptr, const double tolerance=1e-9)Definition fe_remote_evaluation.h:1227\\nSecond, since quadrature points are arbitrarily distributed we have to consider each face in a batch separately and can not make use of VecorizedArray.\\n\\u00a0     using remote_value_type = Number;\\n\\u00a0 \\nThe rest of the code is then identical to what we had in the previous function (though it functions differently because of the difference in remote_value_type).\\n\\u00a0     const auto pressure_r =\\n\\u00a0       std::make_shared<FERemoteEvaluation<dim, 1, remote_value_type>>(\\n\\u00a0         remote_communicator, dof_handler, /*first_selected_component*/ 0);\\n\\u00a0 \\n\\u00a0     const auto velocity_r =\\n\\u00a0       std::make_shared<FERemoteEvaluation<dim, dim, remote_value_type>>(\\n\\u00a0         remote_communicator, dof_handler, /*first_selected_component*/ 1);\\n\\u00a0 \\n\\u00a0     const auto material_data =\\n\\u00a0       std::make_shared<CellwiseMaterialData<Number>>(matrix_free, materials);\\n\\u00a0 \\n\\u00a0     const auto c_r =\\n\\u00a0       std::make_shared<FERemoteEvaluation<dim, 1, remote_value_type>>(\\n\\u00a0         remote_communicator,\\n\\u00a0         matrix_free.get_dof_handler().get_triangulation(),\\n\\u00a0         /*first_selected_component*/ 0);\\n\\u00a0     const auto rho_r =\\n\\u00a0       std::make_shared<FERemoteEvaluation<dim, 1, remote_value_type>>(\\n\\u00a0         remote_communicator,\\n\\u00a0         matrix_free.get_dof_handler().get_triangulation(),\\n\\u00a0         /*first_selected_component*/ 0);\\n\\u00a0 \\n\\u00a0     if (!material_data->is_homogeneous())\\n\\u00a0       {\\n\\u00a0         Vector<Number> c(\\n\\u00a0           matrix_free.get_dof_handler().get_triangulation().n_active_cells());\\n\\u00a0         Vector<Number> rho(\\n\\u00a0           matrix_free.get_dof_handler().get_triangulation().n_active_cells());\\n\\u00a0 \\n\\u00a0         for (const auto &cell : matrix_free.get_dof_handler()\\n\\u00a0                                   .get_triangulation()\\n\\u00a0                                   .active_cell_iterators())\\n\\u00a0           {\\n\\u00a0             c[cell->active_cell_index()] =\\n\\u00a0               materials.at(cell->material_id()).first;\\n\\u00a0             rho[cell->active_cell_index()] =\\n\\u00a0               materials.at(cell->material_id()).second;\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         c_r->gather_evaluate(c, EvaluationFlags::values);\\n\\u00a0         rho_r->gather_evaluate(rho, EvaluationFlags::values);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     const auto inverse_mass_operator =\\n\\u00a0       std::make_shared<InverseMassOperator<dim, Number>>(matrix_free);\\n\\u00a0 \\n\\u00a0     const auto acoustic_operator =\\n\\u00a0       std::make_shared<AcousticOperator<dim, Number, remote_value_type>>(\\n\\u00a0         matrix_free,\\n\\u00a0         material_data,\\n\\u00a0         non_matching_faces,\\n\\u00a0         pressure_r,\\n\\u00a0         velocity_r,\\n\\u00a0         c_r,\\n\\u00a0         rho_r,\\n\\u00a0         nm_mapping_info);\\n\\u00a0 \\n\\u00a0     RungeKutta2<dim, Number, remote_value_type> time_integrator(\\n\\u00a0       inverse_mass_operator, acoustic_operator);\\n\\u00a0 \\n\\u00a0     double speed_of_sound_max = 0.0;\\n\\u00a0     for (const auto &mat : materials)\\n\\u00a0       speed_of_sound_max = std::max(speed_of_sound_max, mat.second.first);\\n\\u00a0 \\n\\u00a0     time_integrator.run(matrix_free,\\n\\u00a0                         /*Cr*/ 0.2,\\n\\u00a0                         end_time,\\n\\u00a0                         speed_of_sound_max,\\n\\u00a0                         initial_condition,\\n\\u00a0                         vtk_prefix);\\n\\u00a0 #endif\\n\\u00a0   }\\n\\u00a0 } // namespace Step89\\n\\u00a0 \\n\\u00a0 \\nVectorTools::EvaluationFlags::max@ maxDefinition vector_tools_evaluate.h:55\\n main()\\nFinally, the main() function executes the different versions of handling non-matching interfaces.\\nSimilar to step-87, the minimum requirement of this tutorial is MPI. The parallel::distributed::Triangulation class is used if deal.II is configured with p4est. Otherwise parallel::shared::Triangulation is used.\\n\\u00a0 int main(int argc, char *argv[])\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0   constexpr int dim = 2;\\n\\u00a0   using Number      = double;\\n\\u00a0 \\n\\u00a0   Utilities::MPI::MPI_InitFinalize mpi(argc, argv);\\n\\u00a0   std::cout.precision(5);\\n\\u00a0   ConditionalOStream pcout(std::cout,\\n\\u00a0                            (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) ==\\n\\u00a0                             0));\\n\\u00a0 \\n\\u00a0   const unsigned int refinements = 1;\\n\\u00a0   const unsigned int degree      = 3;\\n\\u00a0 \\n\\u00a0 #ifdef DEAL_II_WITH_P4EST\\n\\u00a0   parallel::distributed::Triangulation<dim> tria(MPI_COMM_WORLD);\\n\\u00a0 #else\\n\\u00a0   parallel::shared::Triangulation<dim> tria(MPI_COMM_WORLD);\\n\\u00a0 #endif\\n\\u00a0 \\n\\u00a0   pcout << \\\"Create non-matching grid...\\\" << std::endl;\\n\\u00a0 \\n\\u00a0   std::set<types::boundary_id> non_matching_faces;\\n\\u00a0   Step89::build_non_matching_triangulation(tria,\\n\\u00a0                                            non_matching_faces,\\n\\u00a0                                            refinements);\\n\\u00a0 \\n\\u00a0   pcout << \\\" - Refinement level: \\\" << refinements << std::endl;\\n\\u00a0   pcout << \\\" - Number of cells: \\\" << tria.n_cells() << std::endl;\\n\\u00a0 \\n\\u00a0   pcout << \\\"Create DoFHandler...\\\" << std::endl;\\n\\u00a0   DoFHandler<dim> dof_handler(tria);\\n\\u00a0   dof_handler.distribute_dofs(FESystem<dim>(FE_DGQ<dim>(degree) ^ (dim + 1)));\\n\\u00a0   pcout << \\\" - Number of DoFs: \\\" << dof_handler.n_dofs() << std::endl;\\n\\u00a0 \\n\\u00a0   AffineConstraints<Number> constraints;\\n\\u00a0   constraints.close();\\n\\u00a0 \\n\\u00a0   pcout << \\\"Set up MatrixFree...\\\" << std::endl;\\n\\u00a0   typename MatrixFree<dim, Number>::AdditionalData data;\\n\\u00a0   data.mapping_update_flags             = update_gradients | update_values;\\n\\u00a0   data.mapping_update_flags_inner_faces = update_values;\\n\\u00a0   data.mapping_update_flags_boundary_faces =\\n\\u00a0     update_quadrature_points | update_values;\\n\\u00a0 \\n\\u00a0   MatrixFree<dim, Number> matrix_free;\\n\\u00a0   matrix_free.reinit(\\n\\u00a0     MappingQ1<dim>(), dof_handler, constraints, QGauss<dim>(degree + 1), data);\\n\\u00a0 \\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nAffineConstraints::closevoid close()\\nFESystemDefinition fe_system.h:208\\nFE_DGQDefinition fe_dgq.h:112\\nMappingQ1Definition mapping_q1.h:55\\nMatrixFree::reinitvoid reinit(const MappingType &mapping, const DoFHandler< dim > &dof_handler, const AffineConstraints< number2 > &constraint, const QuadratureType &quad, const AdditionalData &additional_data=AdditionalData())\\nQGaussDefinition quadrature_lib.h:40\\nUtilities::MPI::MPI_InitFinalizeDefinition mpi.h:1081\\nparallel::distributed::TriangulationDefinition tria.h:268\\nparallel::shared::TriangulationDefinition shared_tria.h:110\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nMatrixFree::AdditionalDataDefinition matrix_free.h:184\\n Run vibrating membrane test case} Homogeneous pressure\\nDirichlet boundary conditions are applied for simplicity. Therefore, modes can not be chosen arbitrarily.\\n\\u00a0   pcout << \\\"Run vibrating membrane test case...\\\" << std::endl;\\n\\u00a0   const double                                            modes = 10.0;\\n\\u00a0   std::map<types::material_id, std::pair<double, double>> homogeneous_material;\\n\\u00a0   homogeneous_material[numbers::invalid_material_id] = std::make_pair(1.0, 1.0);\\n\\u00a0   const auto initial_solution_membrane =\\n\\u00a0     Step89::InitialConditionVibratingMembrane<dim>(modes);\\n\\u00a0 \\n\\u00a0   /* Run vibrating membrane test case using point-to-point interpolation: */\\n\\u00a0   pcout << \\\" - Point-to-point interpolation: \\\" << std::endl;\\n\\u00a0   Step89::run_with_point_to_point_interpolation(\\n\\u00a0     matrix_free,\\n\\u00a0     non_matching_faces,\\n\\u00a0     homogeneous_material,\\n\\u00a0     8.0 * initial_solution_membrane.get_period_duration(\\n\\u00a0             homogeneous_material.begin()->second.first),\\n\\u00a0     initial_solution_membrane,\\n\\u00a0     \\\"vm-p2p\\\");\\n\\u00a0 \\n\\u00a0   /* Run vibrating membrane test case using Nitsche-type mortaring: */\\n\\u00a0   pcout << \\\" - Nitsche-type mortaring: \\\" << std::endl;\\n\\u00a0   Step89::run_with_nitsche_type_mortaring(\\n\\u00a0     matrix_free,\\n\\u00a0     non_matching_faces,\\n\\u00a0     homogeneous_material,\\n\\u00a0     8.0 * initial_solution_membrane.get_period_duration(\\n\\u00a0             homogeneous_material.begin()->second.first),\\n\\u00a0     initial_solution_membrane,\\n\\u00a0     \\\"vm-nitsche\\\");\\n\\u00a0 \\nnumbers::invalid_material_idconst types::material_id invalid_material_idDefinition types.h:277\\n Run test case with inhomogeneous material\\nRun simple test case with inhomogeneous material and Nitsche-type mortaring:\\n\\u00a0   pcout << \\\"Run test case with inhomogeneous material...\\\" << std::endl;\\n\\u00a0   std::map<types::material_id, std::pair<double, double>>\\n\\u00a0     inhomogeneous_material;\\n\\u00a0   inhomogeneous_material[0] = std::make_pair(1.0, 1.0);\\n\\u00a0   inhomogeneous_material[1] = std::make_pair(3.0, 1.0);\\n\\u00a0   Step89::run_with_nitsche_type_mortaring(matrix_free,\\n\\u00a0                                           non_matching_faces,\\n\\u00a0                                           inhomogeneous_material,\\n\\u00a0                                           /*runtime*/ 0.3,\\n\\u00a0                                           Step89::GaussPulse<dim>(0.3, 0.5),\\n\\u00a0                                           \\\"inhomogeneous\\\");\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nVibrating membrane: Point-to-point interpolation vs. Nitsche-type mortaring\\nWe compare the results of the simulations after the last time step, i.e. at \\\\(t=8T\\\\). The \\\\(y\\\\)-component of the velocity field using Nitsche-type mortaring is depicted on the left. The same field using point-to-point interpolation is depicted on the right.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nBesides this, the results for the pressure and the velocity in \\\\(y\\\\) direction are plotted along the horizontal line that spans from (0,0.69) to (1,0.69).\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nWhile the results of the pressure are similar, \\\\(u_y\\\\) clearly differs. At certain positions we can see aliasing errors for the point-to-point interpolation. For different mesh configurations and/or longer run times, the aliasing effects of the point-to-point simulation accumulate and the simulation becomes instable. To keep the tutorial short we have chosen one mesh that can be used for all examples. For a configuration that yields instable results for a wide range of polynomial degrees, see [112].\\nWave propagation through in-homogeneous fluid\\nThe example that follows is just one example in which non-matching discretizations can be efficiently used to reduce the number of DoFs. The example is nice, since results for a similar test case are shown in multiple publications. As before, we slightly adapted the test case to be able to use the same mesh for all simulations. The pressure field at \\\\(t=0.3\\\\) is depicted below.\\n\\n\\n\\nAs expected, we can easily see that the wave length in the right domain is roughly three times times the wave length in the left domain. Hence, the wave can be resolved with a coarser discretization.\\nUsing the same element size in the whole domain, we can compute a reference result. The displayed reference result is obtained by choosing the same subdivision level for both sub-domains, i.e. subdiv_right = 11. In this particular example the reference result uses \\\\(92,928\\\\) DoFs, while the non-matching result uses \\\\(52,608\\\\) DoFs. The pressure result is plotted along the horizontal line that spans from (0,0.5) to (1,0.5).\\n\\n\\n\\nThe results computed using the non-matching discretization are clearly in good agreement with the reference result.\\nPossibilities for extensions\\nAll the implementations are done with overlapping triangulations in mind. In particular the intersections in the mortaring case are constructed such that they are computed correctly for overlapping triangulations. For this the intersection requests are of dimension \\\\(dim-1\\\\). The cells which are intersected with the intersection requests are of dimension \\\\(dim\\\\). For the simple case of non-conforming interfaces it would be sufficient to compute the intersections between \\\\(dim-1\\\\) and \\\\(dim-1\\\\) entities. Furthermore, the lambda could be adapted, such that cells are only marked if they are connected to a certain boundary ID (in this case, e.g., 99) instead of marking every cell that is not connected to the opposite boundary ID (in this case, e.g., 98). Marking fewer cells can reduce the setup costs significantly.\\nNote that the use of inhomogeneous materials in this procedure is questionable, since it is not clear which material is present in the overlapping part of the mesh.\\n The plain program\\n/* ---------------------------------------------------------------------\\n *\\n * Copyright (C) 2023 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * The deal.II library is free software; you can use it, redistribute\\n * it, and/or modify it under the terms of the GNU Lesser General\\n * Public License as published by the Free Software Foundation; either\\n * version 2.1 of the License, or (at your option) any later version.\\n * The full text of the license can be found in the file LICENSE.md at\\n * the top level directory of deal.II.\\n *\\n * ---------------------------------------------------------------------\\n *\\n *\\n * Authors: Johannes Heinz, TU Wien, 2023\\n *          Maximilian Bergbauer, TUM, 2023\\n *          Marco Feder, SISSA, 2023\\n *          Peter Munch, University of Augsburg/Uppsala University, 2023\\n */\\n \\n#include <deal.II/base/conditional_ostream.h>\\n#include <deal.II/base/mpi.h>\\n \\n#include <deal.II/distributed/tria.h>\\n \\n#include <deal.II/fe/fe_dgq.h>\\n#include <deal.II/fe/fe_system.h>\\n#include <deal.II/fe/fe_values.h>\\n#include <deal.II/fe/mapping_q1.h>\\n \\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_tools.h>\\n#include <deal.II/grid/grid_tools_cache.h>\\n \\n#include <deal.II/matrix_free/fe_evaluation.h>\\n#include <deal.II/matrix_free/matrix_free.h>\\n#include <deal.II/matrix_free/operators.h>\\n \\n#include <deal.II/non_matching/mapping_info.h>\\n \\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/vector_tools.h>\\n#include <deal.II/matrix_free/fe_remote_evaluation.h>\\n \\nnamespace Step89\\n{\\n using namespace dealii;\\n \\n template <int dim>\\n class InitialConditionVibratingMembrane : public Function<dim>\\n  {\\n public:\\n    InitialConditionVibratingMembrane(const double modes);\\n \\n double value(const Point<dim> &p, const unsigned int comp) const final;\\n \\n double get_period_duration(const double speed_of_sound) const;\\n \\n private:\\n const double M;\\n  };\\n \\n template <int dim>\\n  InitialConditionVibratingMembrane<dim>::InitialConditionVibratingMembrane(\\n const double modes)\\n    : Function<dim>(dim + 1, 0.0)\\n    , M(modes)\\n  {\\n static_assert(dim == 2, \\\"Only implemented for dim==2\\\");\\n  }\\n \\n template <int dim>\\n double\\n  InitialConditionVibratingMembrane<dim>::value(const Point<dim>  &p,\\n const unsigned int comp) const\\n {\\n if (comp == 0)\\n return std::sin(M * numbers::PI * p[0]) *\\n std::sin(M * numbers::PI * p[1]);\\n \\n return 0.0;\\n  }\\n \\n template <int dim>\\n double InitialConditionVibratingMembrane<dim>::get_period_duration(\\n const double speed_of_sound) const\\n {\\n return 2.0 / (M * std::sqrt(dim) * speed_of_sound);\\n  }\\n \\n template <int dim>\\n class GaussPulse : public Function<dim>\\n  {\\n public:\\n    GaussPulse(const double shift_x, const double shift_y);\\n \\n double value(const Point<dim> &p, const unsigned int comp) const final;\\n \\n private:\\n const double shift_x;\\n const double shift_y;\\n  };\\n \\n template <int dim>\\n  GaussPulse<dim>::GaussPulse(const double shift_x, const double shift_y)\\n    : Function<dim>(dim + 1, 0.0)\\n    , shift_x(shift_x)\\n    , shift_y(shift_y)\\n  {\\n static_assert(dim == 2, \\\"Only implemented for dim==2\\\");\\n  }\\n \\n template <int dim>\\n double GaussPulse<dim>::value(const Point<dim>  &p,\\n const unsigned int comp) const\\n {\\n if (comp == 0)\\n return std::exp(-1000.0 * ((std::pow(p[0] - shift_x, 2)) +\\n                                 (std::pow(p[1] - shift_y, 2))));\\n \\n return 0.0;\\n  }\\n \\n namespace HelperFunctions\\n  {\\n bool is_non_matching_face(\\n const std::set<types::boundary_id> &non_matching_face_ids,\\n const types::boundary_id            face_id)\\n    {\\n return non_matching_face_ids.find(face_id) != non_matching_face_ids.end();\\n    }\\n \\n template <int dim, typename Number, typename VectorType>\\n void set_initial_condition(MatrixFree<dim, Number> matrix_free,\\n const Function<dim>    &initial_solution,\\n                               VectorType             &dst)\\n    {\\n VectorTools::interpolate(*matrix_free.get_mapping_info().mapping,\\n                               matrix_free.get_dof_handler(),\\n                               initial_solution,\\n                               dst);\\n    }\\n \\n double\\n    compute_dt_cfl(const double hmin, const unsigned int degree, const double c)\\n    {\\n return hmin / (std::pow(degree, 1.5) * c);\\n    }\\n \\n template <typename VectorType, int dim>\\n void write_vtu(const VectorType      &solution,\\n const DoFHandler<dim> &dof_handler,\\n const Mapping<dim>    &mapping,\\n const unsigned int     degree,\\n const std::string     &name_prefix)\\n    {\\n DataOut<dim>          data_out;\\n DataOutBase::VtkFlags flags;\\n      flags.write_higher_order_cells = true;\\n      data_out.set_flags(flags);\\n \\n      std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n        interpretation(\\n          dim + 1, DataComponentInterpretation::component_is_part_of_vector);\\n      std::vector<std::string> names(dim + 1, \\\"U\\\");\\n \\n      interpretation[0] = DataComponentInterpretation::component_is_scalar;\\n      names[0]          = \\\"P\\\";\\n \\n      data_out.add_data_vector(dof_handler, solution, names, interpretation);\\n \\n      data_out.build_patches(mapping, degree, DataOut<dim>::curved_inner_cells);\\n      data_out.write_vtu_in_parallel(name_prefix + \\\".vtu\\\",\\n                                     dof_handler.get_communicator());\\n    }\\n  } // namespace HelperFunctions\\n \\n template <typename Number>\\n class CellwiseMaterialData\\n  {\\n public:\\n template <int dim>\\n    CellwiseMaterialData(\\n const MatrixFree<dim, Number, VectorizedArray<Number>> &matrix_free,\\n const std::map<types::material_id, std::pair<double, double>>\\n        &material_id_map)\\n      : homogeneous(material_id_map.size() == 1)\\n    {\\n Assert(material_id_map.size() > 0,\\n             ExcMessage(\\\"No materials given to CellwiseMaterialData.\\\"));\\n \\n if (homogeneous)\\n        {\\n          speed_of_sound_homogeneous = material_id_map.begin()->second.first;\\n          density_homogeneous        = material_id_map.begin()->second.second;\\n        }\\n else\\n        {\\n const auto n_cell_batches =\\n            matrix_free.n_cell_batches() + matrix_free.n_ghost_cell_batches();\\n \\n          speed_of_sound.resize(n_cell_batches);\\n          density.resize(n_cell_batches);\\n \\n for (unsigned int cell = 0; cell < n_cell_batches; ++cell)\\n            {\\n              speed_of_sound[cell] = 1.;\\n              density[cell]        = 1.;\\n for (unsigned int v = 0;\\n                   v < matrix_free.n_active_entries_per_cell_batch(cell);\\n                   ++v)\\n                {\\n const auto material_id =\\n                    matrix_free.get_cell_iterator(cell, v)->material_id();\\n \\n                  speed_of_sound[cell][v] =\\n                    material_id_map.at(material_id).first;\\n                  density[cell][v] = material_id_map.at(material_id).second;\\n                }\\n            }\\n        }\\n    }\\n \\n bool is_homogeneous() const\\n {\\n return homogeneous;\\n    }\\n \\n const AlignedVector<VectorizedArray<Number>> &get_speed_of_sound() const\\n {\\n Assert(!homogeneous, ExcMessage(\\\"Use get_homogeneous_speed_of_sound().\\\"));\\n return speed_of_sound;\\n    }\\n \\n const AlignedVector<VectorizedArray<Number>> &get_density() const\\n {\\n Assert(!homogeneous, ExcMessage(\\\"Use get_homogeneous_density().\\\"));\\n return density;\\n    }\\n \\n VectorizedArray<Number> get_homogeneous_speed_of_sound() const\\n {\\n Assert(homogeneous, ExcMessage(\\\"Use get_speed_of_sound().\\\"));\\n return speed_of_sound_homogeneous;\\n    }\\n \\n VectorizedArray<Number> get_homogeneous_density() const\\n {\\n Assert(homogeneous, ExcMessage(\\\"Use get_density().\\\"));\\n return density_homogeneous;\\n    }\\n \\n private:\\n const bool homogeneous;\\n \\n /* Materials in the inhomogeneous case. */\\n AlignedVector<VectorizedArray<Number>> speed_of_sound;\\n AlignedVector<VectorizedArray<Number>> density;\\n \\n /* Materials in the homogeneous case. */\\n VectorizedArray<Number> speed_of_sound_homogeneous;\\n VectorizedArray<Number> density_homogeneous;\\n  };\\n \\n template <int dim, typename Number>\\n class MaterialEvaluation\\n  {\\n public:\\n    MaterialEvaluation(\\n const MatrixFree<dim, Number, VectorizedArray<Number>> &matrix_free,\\n const CellwiseMaterialData<Number>                     &material_data)\\n      : phi(matrix_free)\\n      , phi_face(matrix_free, true)\\n      , material_data(material_data)\\n    {\\n if (material_data.is_homogeneous())\\n        {\\n          speed_of_sound = material_data.get_homogeneous_speed_of_sound();\\n          density        = material_data.get_homogeneous_density();\\n        }\\n    }\\n \\n bool is_homogeneous() const\\n {\\n return material_data.is_homogeneous();\\n    }\\n \\n void reinit_cell(const unsigned int cell)\\n    {\\n if (!material_data.is_homogeneous())\\n        {\\n          phi.reinit(cell);\\n          speed_of_sound =\\n            phi.read_cell_data(material_data.get_speed_of_sound());\\n          density = phi.read_cell_data(material_data.get_density());\\n        }\\n    }\\n \\n void reinit_face(const unsigned int face)\\n    {\\n if (!material_data.is_homogeneous())\\n        {\\n          phi_face.reinit(face);\\n          speed_of_sound =\\n            phi_face.read_cell_data(material_data.get_speed_of_sound());\\n          density = phi_face.read_cell_data(material_data.get_density());\\n        }\\n    }\\n \\n VectorizedArray<Number> get_speed_of_sound() const\\n {\\n return speed_of_sound;\\n    }\\n \\n VectorizedArray<Number> get_density() const\\n {\\n return density;\\n    }\\n \\n private:\\n /* Members needed for the inhomogeneous case. */\\n FEEvaluation<dim, -1, 0, 1, Number>     phi;\\n FEFaceEvaluation<dim, -1, 0, 1, Number> phi_face;\\n \\n /* Material defined at every cell. */\\n const CellwiseMaterialData<Number> &material_data;\\n \\n /* Materials at current cell. */\\n VectorizedArray<Number> speed_of_sound;\\n VectorizedArray<Number> density;\\n  };\\n \\n \\n template <int dim, typename Number>\\n class BCEvaluationP\\n  {\\n public:\\n    BCEvaluationP(const FEFaceEvaluation<dim, -1, 0, 1, Number> &pressure_m)\\n      : pressure_m(pressure_m)\\n    {}\\n \\n typename FEFaceEvaluation<dim, -1, 0, 1, Number>::value_type\\n    get_value(const unsigned int q) const\\n {\\n return -pressure_m.get_value(q);\\n    }\\n \\n private:\\n const FEFaceEvaluation<dim, -1, 0, 1, Number> &pressure_m;\\n  };\\n \\n template <int dim, typename Number>\\n class BCEvaluationU\\n  {\\n public:\\n    BCEvaluationU(const FEFaceEvaluation<dim, -1, 0, dim, Number> &velocity_m)\\n      : velocity_m(velocity_m)\\n    {}\\n \\n typename FEFaceEvaluation<dim, -1, 0, dim, Number>::value_type\\n    get_value(const unsigned int q) const\\n {\\n return velocity_m.get_value(q);\\n    }\\n \\n private:\\n const FEFaceEvaluation<dim, -1, 0, dim, Number> &velocity_m;\\n  };\\n \\n template <int dim, typename Number, typename remote_value_type>\\n class AcousticOperator\\n  {\\n static constexpr bool use_mortaring =\\n      std::is_floating_point_v<remote_value_type>;\\n \\n public:\\n    AcousticOperator(\\n const MatrixFree<dim, Number>                &matrix_free,\\n      std::shared_ptr<CellwiseMaterialData<Number>> material_data,\\n const std::set<types::boundary_id>           &remote_face_ids,\\n      std::shared_ptr<FERemoteEvaluation<dim, 1, remote_value_type>>\\n        pressure_r_eval,\\n      std::shared_ptr<FERemoteEvaluation<dim, dim, remote_value_type>>\\n        velocity_r_eval,\\n      std::shared_ptr<FERemoteEvaluation<dim, 1, remote_value_type>> c_r_eval,\\n      std::shared_ptr<FERemoteEvaluation<dim, 1, remote_value_type>> rho_r_eval,\\n      std::shared_ptr<NonMatching::MappingInfo<dim, dim, Number>>    nm_info =\\n nullptr)\\n      : matrix_free(matrix_free)\\n      , material_data(material_data)\\n      , remote_face_ids(remote_face_ids)\\n      , pressure_r_eval(pressure_r_eval)\\n      , velocity_r_eval(velocity_r_eval)\\n      , c_r_eval(c_r_eval)\\n      , rho_r_eval(rho_r_eval)\\n      , nm_mapping_info(nm_info)\\n    {\\n if (use_mortaring)\\n Assert(nm_info,\\n               ExcMessage(\\n \\\"In case of Nitsche-type mortaring NonMatching::MappingInfo \\\\\\n                  has to be provided.\\\"));\\n    }\\n \\n template <typename VectorType>\\n void evaluate(VectorType &dst, const VectorType &src) const\\n {\\n      pressure_r_eval->gather_evaluate(src, EvaluationFlags::values);\\n      velocity_r_eval->gather_evaluate(src, EvaluationFlags::values);\\n \\n if constexpr (use_mortaring)\\n        {\\n          matrix_free.loop(\\n            &AcousticOperator::local_apply_cell<VectorType>,\\n            &AcousticOperator::local_apply_face<VectorType>,\\n            &AcousticOperator::local_apply_boundary_face_mortaring<VectorType>,\\n this,\\n            dst,\\n            src,\\n true,\\n MatrixFree<dim, Number>::DataAccessOnFaces::values,\\n MatrixFree<dim, Number>::DataAccessOnFaces::values);\\n        }\\n else\\n        {\\n          matrix_free.loop(\\n            &AcousticOperator::local_apply_cell<VectorType>,\\n            &AcousticOperator::local_apply_face<VectorType>,\\n            &AcousticOperator::local_apply_boundary_face_point_to_point<\\n              VectorType>,\\n this,\\n            dst,\\n            src,\\n true,\\n MatrixFree<dim, Number>::DataAccessOnFaces::values,\\n MatrixFree<dim, Number>::DataAccessOnFaces::values);\\n        }\\n    }\\n \\n private:\\n template <typename VectorType>\\n void local_apply_cell(\\n const MatrixFree<dim, Number>               &matrix_free,\\n      VectorType                                  &dst,\\n const VectorType                            &src,\\n const std::pair<unsigned int, unsigned int> &cell_range) const\\n {\\n FEEvaluation<dim, -1, 0, 1, Number>   pressure(matrix_free, 0, 0, 0);\\n FEEvaluation<dim, -1, 0, dim, Number> velocity(matrix_free, 0, 0, 1);\\n \\n      MaterialEvaluation material(matrix_free, *material_data);\\n \\n for (unsigned int cell = cell_range.first; cell < cell_range.second;\\n           ++cell)\\n        {\\n          velocity.reinit(cell);\\n          pressure.reinit(cell);\\n \\n          pressure.gather_evaluate(src, EvaluationFlags::gradients);\\n          velocity.gather_evaluate(src, EvaluationFlags::gradients);\\n \\n          material.reinit_cell(cell);\\n const auto c   = material.get_speed_of_sound();\\n const auto rho = material.get_density();\\n \\n for (const unsigned int q : pressure.quadrature_point_indices())\\n            {\\n              pressure.submit_value(rho * c * c * velocity.get_divergence(q),\\n                                    q);\\n              velocity.submit_value(1.0 / rho * pressure.get_gradient(q), q);\\n            }\\n \\n          pressure.integrate_scatter(EvaluationFlags::values, dst);\\n          velocity.integrate_scatter(EvaluationFlags::values, dst);\\n        }\\n    }\\n \\n template <bool weight_neighbor,\\n typename InternalFaceIntegratorPressure,\\n typename InternalFaceIntegratorVelocity,\\n typename ExternalFaceIntegratorPressure,\\n typename ExternalFaceIntegratorVelocity>\\n inline DEAL_II_ALWAYS_INLINE void evaluate_face_kernel(\\n      InternalFaceIntegratorPressure                           &pressure_m,\\n      InternalFaceIntegratorVelocity                           &velocity_m,\\n      ExternalFaceIntegratorPressure                           &pressure_p,\\n      ExternalFaceIntegratorVelocity                           &velocity_p,\\n const typename InternalFaceIntegratorPressure::value_type c,\\n const typename InternalFaceIntegratorPressure::value_type rho) const\\n {\\n const auto tau   = 0.5 * rho * c;\\n const auto gamma = 0.5 / (rho * c);\\n \\n for (const unsigned int q : pressure_m.quadrature_point_indices())\\n        {\\n const auto n  = pressure_m.normal_vector(q);\\n const auto pm = pressure_m.get_value(q);\\n const auto um = velocity_m.get_value(q);\\n \\n const auto pp = pressure_p.get_value(q);\\n const auto up = velocity_p.get_value(q);\\n \\n const auto momentum_flux =\\n            0.5 * (pm + pp) + 0.5 * tau * (um - up) * n;\\n          velocity_m.submit_value(1.0 / rho * (momentum_flux - pm) * n, q);\\n if constexpr (weight_neighbor)\\n            velocity_p.submit_value(1.0 / rho * (momentum_flux - pp) * (-n), q);\\n \\n const auto mass_flux = 0.5 * (um + up) + 0.5 * gamma * (pm - pp) * n;\\n          pressure_m.submit_value(rho * c * c * (mass_flux - um) * n, q);\\n if constexpr (weight_neighbor)\\n            pressure_p.submit_value(rho * c * c * (mass_flux - up) * (-n), q);\\n        }\\n    }\\n \\n template <typename InternalFaceIntegratorPressure,\\n typename InternalFaceIntegratorVelocity,\\n typename ExternalFaceIntegratorPressure,\\n typename ExternalFaceIntegratorVelocity,\\n typename MaterialIntegrator>\\n void evaluate_face_kernel_inhomogeneous(\\n      InternalFaceIntegratorPressure                           &pressure_m,\\n      InternalFaceIntegratorVelocity                           &velocity_m,\\n const ExternalFaceIntegratorPressure                     &pressure_p,\\n const ExternalFaceIntegratorVelocity                     &velocity_p,\\n const typename InternalFaceIntegratorPressure::value_type c,\\n const typename InternalFaceIntegratorPressure::value_type rho,\\n const MaterialIntegrator                                 &c_r,\\n const MaterialIntegrator                                 &rho_r) const\\n {\\n const auto tau_m   = 0.5 * rho * c;\\n const auto gamma_m = 0.5 / (rho * c);\\n \\n for (const unsigned int q : pressure_m.quadrature_point_indices())\\n        {\\n const auto c_p           = c_r.get_value(q);\\n const auto rho_p         = rho_r.get_value(q);\\n const auto tau_p         = 0.5 * rho_p * c_p;\\n const auto gamma_p       = 0.5 / (rho_p * c_p);\\n const auto tau_sum_inv   = 1.0 / (tau_m + tau_p);\\n const auto gamma_sum_inv = 1.0 / (gamma_m + gamma_p);\\n \\n const auto n  = pressure_m.normal_vector(q);\\n const auto pm = pressure_m.get_value(q);\\n const auto um = velocity_m.get_value(q);\\n \\n const auto pp = pressure_p.get_value(q);\\n const auto up = velocity_p.get_value(q);\\n \\n \\n const auto momentum_flux =\\n            pm - tau_m * tau_sum_inv * (pm - pp) +\\n            tau_m * tau_p * tau_sum_inv * (um - up) * n;\\n          velocity_m.submit_value(1.0 / rho * (momentum_flux - pm) * n, q);\\n \\n \\n const auto mass_flux =\\n            um - gamma_m * gamma_sum_inv * (um - up) +\\n            gamma_m * gamma_p * gamma_sum_inv * (pm - pp) * n;\\n \\n          pressure_m.submit_value(rho * c * c * (mass_flux - um) * n, q);\\n        }\\n    }\\n \\n template <typename VectorType>\\n void local_apply_face(\\n const MatrixFree<dim, Number>               &matrix_free,\\n      VectorType                                  &dst,\\n const VectorType                            &src,\\n const std::pair<unsigned int, unsigned int> &face_range) const\\n {\\n FEFaceEvaluation<dim, -1, 0, 1, Number> pressure_m(\\n        matrix_free, true, 0, 0, 0);\\n FEFaceEvaluation<dim, -1, 0, 1, Number> pressure_p(\\n        matrix_free, false, 0, 0, 0);\\n FEFaceEvaluation<dim, -1, 0, dim, Number> velocity_m(\\n        matrix_free, true, 0, 0, 1);\\n FEFaceEvaluation<dim, -1, 0, dim, Number> velocity_p(\\n        matrix_free, false, 0, 0, 1);\\n \\n      MaterialEvaluation material(matrix_free, *material_data);\\n \\n for (unsigned int face = face_range.first; face < face_range.second;\\n           ++face)\\n        {\\n          velocity_m.reinit(face);\\n          velocity_p.reinit(face);\\n \\n          pressure_m.reinit(face);\\n          pressure_p.reinit(face);\\n \\n          pressure_m.gather_evaluate(src, EvaluationFlags::values);\\n          pressure_p.gather_evaluate(src, EvaluationFlags::values);\\n \\n          velocity_m.gather_evaluate(src, EvaluationFlags::values);\\n          velocity_p.gather_evaluate(src, EvaluationFlags::values);\\n \\n          material.reinit_face(face);\\n          evaluate_face_kernel<true>(pressure_m,\\n                                     velocity_m,\\n                                     pressure_p,\\n                                     velocity_p,\\n                                     material.get_speed_of_sound(),\\n                                     material.get_density());\\n \\n          pressure_m.integrate_scatter(EvaluationFlags::values, dst);\\n          pressure_p.integrate_scatter(EvaluationFlags::values, dst);\\n          velocity_m.integrate_scatter(EvaluationFlags::values, dst);\\n          velocity_p.integrate_scatter(EvaluationFlags::values, dst);\\n        }\\n    }\\n \\n \\n template <typename VectorType>\\n void local_apply_boundary_face_point_to_point(\\n const MatrixFree<dim, Number>               &matrix_free,\\n      VectorType                                  &dst,\\n const VectorType                            &src,\\n const std::pair<unsigned int, unsigned int> &face_range) const\\n {\\n FEFaceEvaluation<dim, -1, 0, 1, Number> pressure_m(\\n        matrix_free, true, 0, 0, 0);\\n FEFaceEvaluation<dim, -1, 0, dim, Number> velocity_m(\\n        matrix_free, true, 0, 0, 1);\\n \\n      BCEvaluationP pressure_bc(pressure_m);\\n      BCEvaluationU velocity_bc(velocity_m);\\n \\n      MaterialEvaluation material(matrix_free, *material_data);\\n \\n auto pressure_r = pressure_r_eval->get_data_accessor();\\n auto velocity_r = velocity_r_eval->get_data_accessor();\\n auto c_r        = c_r_eval->get_data_accessor();\\n auto rho_r      = rho_r_eval->get_data_accessor();\\n \\n for (unsigned int face = face_range.first; face < face_range.second;\\n           ++face)\\n        {\\n          velocity_m.reinit(face);\\n          pressure_m.reinit(face);\\n \\n          pressure_m.gather_evaluate(src, EvaluationFlags::values);\\n          velocity_m.gather_evaluate(src, EvaluationFlags::values);\\n \\n if (HelperFunctions::is_non_matching_face(\\n                remote_face_ids, matrix_free.get_boundary_id(face)))\\n            {\\n \\n              velocity_r.reinit(face);\\n              pressure_r.reinit(face);\\n \\n              material.reinit_face(face);\\n \\n if (material.is_homogeneous())\\n                {\\n                  evaluate_face_kernel<false>(pressure_m,\\n                                              velocity_m,\\n                                              pressure_r,\\n                                              velocity_r,\\n                                              material.get_speed_of_sound(),\\n                                              material.get_density());\\n                }\\n else\\n                {\\n                  c_r.reinit(face);\\n                  rho_r.reinit(face);\\n                  evaluate_face_kernel_inhomogeneous(\\n                    pressure_m,\\n                    velocity_m,\\n                    pressure_r,\\n                    velocity_r,\\n                    material.get_speed_of_sound(),\\n                    material.get_density(),\\n                    c_r,\\n                    rho_r);\\n                }\\n            }\\n else\\n            {\\n              material.reinit_face(face);\\n              evaluate_face_kernel<false>(pressure_m,\\n                                          velocity_m,\\n                                          pressure_bc,\\n                                          velocity_bc,\\n                                          material.get_speed_of_sound(),\\n                                          material.get_density());\\n            }\\n \\n          pressure_m.integrate_scatter(EvaluationFlags::values, dst);\\n          velocity_m.integrate_scatter(EvaluationFlags::values, dst);\\n        }\\n    }\\n \\n template <typename VectorType>\\n void local_apply_boundary_face_mortaring(\\n const MatrixFree<dim, Number>               &matrix_free,\\n      VectorType                                  &dst,\\n const VectorType                            &src,\\n const std::pair<unsigned int, unsigned int> &face_range) const\\n {\\n FEFaceEvaluation<dim, -1, 0, 1, Number> pressure_m(\\n        matrix_free, true, 0, 0, 0);\\n FEFaceEvaluation<dim, -1, 0, dim, Number> velocity_m(\\n        matrix_free, true, 0, 0, 1);\\n \\n FEFacePointEvaluation<1, dim, dim, Number> &pressure_m_mortar =\\n        get_thread_safe_fe_face_point_evaluation_object<1>(\\n          thread_local_pressure_m_mortar, 0);\\n FEFacePointEvaluation<dim, dim, dim, Number> &velocity_m_mortar =\\n        get_thread_safe_fe_face_point_evaluation_object<dim>(\\n          thread_local_velocity_m_mortar, 1);\\n \\n      BCEvaluationP pressure_bc(pressure_m);\\n      BCEvaluationU velocity_bc(velocity_m);\\n \\n      MaterialEvaluation material(matrix_free, *material_data);\\n \\n auto pressure_r_mortar = pressure_r_eval->get_data_accessor();\\n auto velocity_r_mortar = velocity_r_eval->get_data_accessor();\\n auto c_r               = c_r_eval->get_data_accessor();\\n auto rho_r             = rho_r_eval->get_data_accessor();\\n \\n for (unsigned int face = face_range.first; face < face_range.second;\\n           ++face)\\n        {\\n if (HelperFunctions::is_non_matching_face(\\n                remote_face_ids, matrix_free.get_boundary_id(face)))\\n            {\\n              material.reinit_face(face);\\n \\n              pressure_m.reinit(face);\\n              velocity_m.reinit(face);\\n \\n              pressure_m.read_dof_values(src);\\n              velocity_m.read_dof_values(src);\\n \\n              pressure_m.project_to_face(EvaluationFlags::values);\\n              velocity_m.project_to_face(EvaluationFlags::values);\\n \\n for (unsigned int v = 0;\\n                   v < matrix_free.n_active_entries_per_face_batch(face);\\n                   ++v)\\n                {\\n constexpr unsigned int n_lanes =\\n VectorizedArray<Number>::size();\\n                  velocity_m_mortar.reinit(face * n_lanes + v);\\n                  pressure_m_mortar.reinit(face * n_lanes + v);\\n \\n                  velocity_m_mortar.evaluate_in_face(\\n                    &velocity_m.get_scratch_data().begin()[0][v],\\n EvaluationFlags::values);\\n \\n                  pressure_m_mortar.evaluate_in_face(\\n                    &pressure_m.get_scratch_data().begin()[0][v],\\n EvaluationFlags::values);\\n \\n                  velocity_r_mortar.reinit(face * n_lanes + v);\\n                  pressure_r_mortar.reinit(face * n_lanes + v);\\n \\n if (material.is_homogeneous())\\n                    {\\n                      evaluate_face_kernel<false>(\\n                        pressure_m_mortar,\\n                        velocity_m_mortar,\\n                        pressure_r_mortar,\\n                        velocity_r_mortar,\\n                        material.get_speed_of_sound()[v],\\n                        material.get_density()[v]);\\n                    }\\n else\\n                    {\\n                      c_r.reinit(face * n_lanes + v);\\n                      rho_r.reinit(face * n_lanes + v);\\n \\n                      evaluate_face_kernel_inhomogeneous(\\n                        pressure_m_mortar,\\n                        velocity_m_mortar,\\n                        pressure_r_mortar,\\n                        velocity_r_mortar,\\n                        material.get_speed_of_sound()[v],\\n                        material.get_density()[v],\\n                        c_r,\\n                        rho_r);\\n                    }\\n \\n                  velocity_m_mortar.integrate_in_face(\\n                    &velocity_m.get_scratch_data().begin()[0][v],\\n EvaluationFlags::values);\\n \\n                  pressure_m_mortar.integrate_in_face(\\n                    &pressure_m.get_scratch_data().begin()[0][v],\\n EvaluationFlags::values);\\n                }\\n \\n              pressure_m.collect_from_face(EvaluationFlags::values);\\n              velocity_m.collect_from_face(EvaluationFlags::values);\\n \\n              pressure_m.distribute_local_to_global(dst);\\n              velocity_m.distribute_local_to_global(dst);\\n            }\\n else\\n            {\\n              velocity_m.reinit(face);\\n              pressure_m.reinit(face);\\n \\n              pressure_m.gather_evaluate(src, EvaluationFlags::values);\\n              velocity_m.gather_evaluate(src, EvaluationFlags::values);\\n \\n              material.reinit_face(face);\\n              evaluate_face_kernel<false>(pressure_m,\\n                                          velocity_m,\\n                                          pressure_bc,\\n                                          velocity_bc,\\n                                          material.get_speed_of_sound(),\\n                                          material.get_density());\\n \\n              pressure_m.integrate_scatter(EvaluationFlags::values, dst);\\n              velocity_m.integrate_scatter(EvaluationFlags::values, dst);\\n            }\\n        }\\n    }\\n \\n const MatrixFree<dim, Number> &matrix_free;\\n \\n const std::shared_ptr<CellwiseMaterialData<Number>> material_data;\\n \\n const std::set<types::boundary_id> remote_face_ids;\\n \\n const std::shared_ptr<FERemoteEvaluation<dim, 1, remote_value_type>>\\n      pressure_r_eval;\\n const std::shared_ptr<FERemoteEvaluation<dim, dim, remote_value_type>>\\n      velocity_r_eval;\\n \\n const std::shared_ptr<FERemoteEvaluation<dim, 1, remote_value_type>>\\n      c_r_eval;\\n const std::shared_ptr<FERemoteEvaluation<dim, 1, remote_value_type>>\\n      rho_r_eval;\\n \\n const std::shared_ptr<NonMatching::MappingInfo<dim, dim, Number>>\\n      nm_mapping_info;\\n \\n mutable Threads::ThreadLocalStorage<\\n      std::unique_ptr<FEFacePointEvaluation<1, dim, dim, Number>>>\\n      thread_local_pressure_m_mortar;\\n \\n mutable Threads::ThreadLocalStorage<\\n      std::unique_ptr<FEFacePointEvaluation<dim, dim, dim, Number>>>\\n      thread_local_velocity_m_mortar;\\n \\n template <int n_components>\\n FEFacePointEvaluation<n_components, dim, dim, Number> &\\n    get_thread_safe_fe_face_point_evaluation_object(\\n Threads::ThreadLocalStorage<\\n        std::unique_ptr<FEFacePointEvaluation<n_components, dim, dim, Number>>>\\n                  &fe_face_point_eval_thread_local,\\n unsigned int fist_selected_comp) const\\n {\\n if (fe_face_point_eval_thread_local.get() == nullptr)\\n        {\\n          fe_face_point_eval_thread_local = std::make_unique<\\n FEFacePointEvaluation<n_components, dim, dim, Number>>(\\n            *nm_mapping_info,\\n            matrix_free.get_dof_handler().get_fe(),\\n true,\\n            fist_selected_comp);\\n        }\\n return *fe_face_point_eval_thread_local.get();\\n    }\\n  };\\n \\n template <int dim, typename Number>\\n class InverseMassOperator\\n  {\\n public:\\n    InverseMassOperator(const MatrixFree<dim, Number> &matrix_free)\\n      : matrix_free(matrix_free)\\n    {}\\n \\n template <typename VectorType>\\n void apply(VectorType &dst, const VectorType &src) const\\n {\\n      dst.zero_out_ghost_values();\\n      matrix_free.cell_loop(&InverseMassOperator::local_apply_cell<VectorType>,\\n this,\\n                            dst,\\n                            src);\\n    }\\n \\n private:\\n template <typename VectorType>\\n void local_apply_cell(\\n const MatrixFree<dim, Number>               &mf,\\n      VectorType                                  &dst,\\n const VectorType                            &src,\\n const std::pair<unsigned int, unsigned int> &cell_range) const\\n {\\n FEEvaluation<dim, -1, 0, dim + 1, Number> phi(mf);\\n MatrixFreeOperators::CellwiseInverseMassMatrix<dim, -1, dim + 1, Number>\\n        minv(phi);\\n \\n for (unsigned int cell = cell_range.first; cell < cell_range.second;\\n           ++cell)\\n        {\\n          phi.reinit(cell);\\n          phi.read_dof_values(src);\\n          minv.apply(phi.begin_dof_values(), phi.begin_dof_values());\\n          phi.set_dof_values(dst);\\n        }\\n    }\\n \\n const MatrixFree<dim, Number> &matrix_free;\\n  };\\n \\n template <int dim, typename Number, typename remote_value_type>\\n class RungeKutta2\\n  {\\n using VectorType = LinearAlgebra::distributed::Vector<Number>;\\n \\n public:\\n    RungeKutta2(\\n const std::shared_ptr<InverseMassOperator<dim, Number>>\\n        inverse_mass_operator,\\n const std::shared_ptr<AcousticOperator<dim, Number, remote_value_type>>\\n        acoustic_operator)\\n      : inverse_mass_operator(inverse_mass_operator)\\n      , acoustic_operator(acoustic_operator)\\n    {}\\n \\n void run(const MatrixFree<dim, Number> &matrix_free,\\n const double                   cr,\\n const double                   end_time,\\n const double                   speed_of_sound,\\n const Function<dim>           &initial_condition,\\n const std::string             &vtk_prefix)\\n    {\\n const auto &dof_handler = matrix_free.get_dof_handler();\\n const auto &mapping     = *matrix_free.get_mapping_info().mapping;\\n const auto  degree      = dof_handler.get_fe().degree;\\n \\n      VectorType solution;\\n      matrix_free.initialize_dof_vector(solution);\\n      VectorType solution_temp;\\n      matrix_free.initialize_dof_vector(solution_temp);\\n \\n      HelperFunctions::set_initial_condition(matrix_free,\\n                                             initial_condition,\\n                                             solution);\\n \\n double h_local_min = std::numeric_limits<double>::max();\\n for (const auto &cell : dof_handler.active_cell_iterators())\\n        h_local_min =\\n std::min(h_local_min,\\n                   (cell->vertex(1) - cell->vertex(0)).norm_square());\\n      h_local_min = std::sqrt(h_local_min);\\n const double h_min =\\n Utilities::MPI::min(h_local_min, dof_handler.get_communicator());\\n \\n const double dt =\\n        cr * HelperFunctions::compute_dt_cfl(h_min, degree, speed_of_sound);\\n \\n double       time     = 0.0;\\n unsigned int timestep = 0;\\n while (time < end_time)\\n        {\\n          HelperFunctions::write_vtu(solution,\\n                                     matrix_free.get_dof_handler(),\\n                                     mapping,\\n                                     degree,\\n \\\"step_89-\\\" + vtk_prefix +\\n                                       std::to_string(timestep));\\n \\n          std::swap(solution, solution_temp);\\n          time += dt;\\n          ++timestep;\\n          perform_time_step(dt, solution, solution_temp);\\n        }\\n    }\\n \\n private:\\n void\\n    perform_time_step(const double dt, VectorType &dst, const VectorType &src)\\n    {\\n      VectorType k1 = src;\\n \\n /* First stage. */\\n      evaluate_stage(k1, src);\\n \\n /* Second stage. */\\n      k1.sadd(0.5 * dt, 1.0, src);\\n      evaluate_stage(dst, k1);\\n \\n /* Summing things into the output vector. */\\n      dst.sadd(dt, 1.0, src);\\n    }\\n \\n void evaluate_stage(VectorType &dst, const VectorType &src)\\n    {\\n      acoustic_operator->evaluate(dst, src);\\n      dst *= -1.0;\\n      inverse_mass_operator->apply(dst, dst);\\n    }\\n \\n const std::shared_ptr<InverseMassOperator<dim, Number>>\\n      inverse_mass_operator;\\n const std::shared_ptr<AcousticOperator<dim, Number, remote_value_type>>\\n      acoustic_operator;\\n  };\\n \\n \\n template <int dim>\\n void build_non_matching_triangulation(\\n Triangulation<dim>           &tria,\\n    std::set<types::boundary_id> &non_matching_faces,\\n const unsigned int            refinements)\\n  {\\n const double length = 1.0;\\n \\n const types::boundary_id non_matching_id_left  = 98;\\n const types::boundary_id non_matching_id_right = 99;\\n \\n    non_matching_faces = {non_matching_id_left, non_matching_id_right};\\n \\n /* Construct left part of mesh. */\\n Triangulation<dim> tria_left;\\n const unsigned int subdiv_left = 11;\\n GridGenerator::subdivided_hyper_rectangle(tria_left,\\n                                              {subdiv_left, 2 * subdiv_left},\\n                                              {0.0, 0.0},\\n                                              {0.525 * length, length});\\n \\n for (const auto &cell : tria_left.active_cell_iterators())\\n      cell->set_material_id(0);\\n for (const auto &face : tria_left.active_face_iterators())\\n      if (face->at_boundary())\\n        {\\n          face->set_boundary_id(0);\\n if (face->center()[0] > 0.525 * length - 1e-6)\\n            face->set_boundary_id(non_matching_id_left);\\n        }\\n \\n /* Construct right part of mesh. */\\n Triangulation<dim> tria_right;\\n const unsigned int subdiv_right = 4;\\n GridGenerator::subdivided_hyper_rectangle(tria_right,\\n                                              {subdiv_right, 2 * subdiv_right},\\n                                              {0.525 * length, 0.0},\\n                                              {length, length});\\n \\n for (const auto &cell : tria_right.active_cell_iterators())\\n      cell->set_material_id(1);\\n for (const auto &face : tria_right.active_face_iterators())\\n      if (face->at_boundary())\\n        {\\n          face->set_boundary_id(0);\\n if (face->center()[0] < 0.525 * length + 1e-6)\\n            face->set_boundary_id(non_matching_id_right);\\n        }\\n \\n /* Merge triangulations. */\\n GridGenerator::merge_triangulations(tria_left,\\n                                        tria_right,\\n                                        tria,\\n /*tolerance*/ 0.,\\n /*copy_manifold_ids*/ false,\\n /*copy_boundary_ids*/ true);\\n \\n /* Refine the result. */\\n    tria.refine_global(refinements);\\n  }\\n \\n \\n template <int dim, typename Number>\\n void run_with_point_to_point_interpolation(\\n const MatrixFree<dim, Number>      &matrix_free,\\n const std::set<types::boundary_id> &non_matching_faces,\\n const std::map<types::material_id, std::pair<double, double>> &materials,\\n const double                                                   end_time,\\n const Function<dim> &initial_condition,\\n const std::string   &vtk_prefix)\\n  {\\n const auto &dof_handler = matrix_free.get_dof_handler();\\n const auto &tria        = dof_handler.get_triangulation();\\n \\n    std::vector<\\n      std::pair<types::boundary_id, std::function<std::vector<bool>()>>>\\n      non_matching_faces_marked_vertices;\\n for (const auto &nm_face : non_matching_faces)\\n      {\\n auto marked_vertices = [&nm_face, &tria]() -> std::vector<bool> {\\n          std::vector<bool> mask(tria.n_vertices(), true);\\n \\n for (const auto &cell : tria.active_cell_iterators())\\n            for (auto const &f : cell->face_indices())\\n              if (cell->face(f)->at_boundary() &&\\n                  cell->face(f)->boundary_id() == nm_face)\\n                for (const auto v : cell->vertex_indices())\\n mask[cell->vertex_index(v)] = false;\\n \\n return mask;\\n        };\\n \\n        non_matching_faces_marked_vertices.emplace_back(\\n          std::make_pair(nm_face, marked_vertices));\\n      }\\n \\n auto remote_communicator =\\n Utilities::compute_remote_communicator_faces_point_to_point_interpolation(\\n        matrix_free, non_matching_faces_marked_vertices);\\n \\n using remote_value_type = VectorizedArray<Number>;\\n \\n const auto pressure_r =\\n      std::make_shared<FERemoteEvaluation<dim, 1, remote_value_type>>(\\n        remote_communicator, dof_handler, /*first_selected_component*/ 0);\\n \\n const auto velocity_r =\\n      std::make_shared<FERemoteEvaluation<dim, dim, remote_value_type>>(\\n        remote_communicator, dof_handler, /*first_selected_component*/ 1);\\n \\n const auto material_data =\\n      std::make_shared<CellwiseMaterialData<Number>>(matrix_free, materials);\\n \\n const auto c_r =\\n      std::make_shared<FERemoteEvaluation<dim, 1, remote_value_type>>(\\n        remote_communicator,\\n        matrix_free.get_dof_handler().get_triangulation(),\\n /*first_selected_component*/ 0);\\n const auto rho_r =\\n      std::make_shared<FERemoteEvaluation<dim, 1, remote_value_type>>(\\n        remote_communicator,\\n        matrix_free.get_dof_handler().get_triangulation(),\\n /*first_selected_component*/ 0);\\n \\n if (!material_data->is_homogeneous())\\n      {\\n Vector<Number> c(\\n          matrix_free.get_dof_handler().get_triangulation().n_active_cells());\\n Vector<Number> rho(\\n          matrix_free.get_dof_handler().get_triangulation().n_active_cells());\\n \\n for (const auto &cell : matrix_free.get_dof_handler()\\n                                  .get_triangulation()\\n                                  .active_cell_iterators())\\n          {\\n            c[cell->active_cell_index()] =\\n              materials.at(cell->material_id()).first;\\n            rho[cell->active_cell_index()] =\\n              materials.at(cell->material_id()).second;\\n          }\\n \\n        c_r->gather_evaluate(c, EvaluationFlags::values);\\n        rho_r->gather_evaluate(rho, EvaluationFlags::values);\\n      }\\n \\n \\n const auto inverse_mass_operator =\\n      std::make_shared<InverseMassOperator<dim, Number>>(matrix_free);\\n \\n const auto acoustic_operator =\\n      std::make_shared<AcousticOperator<dim, Number, remote_value_type>>(\\n        matrix_free,\\n        material_data,\\n        non_matching_faces,\\n        pressure_r,\\n        velocity_r,\\n        c_r,\\n        rho_r);\\n \\n    RungeKutta2<dim, Number, remote_value_type> time_integrator(\\n      inverse_mass_operator, acoustic_operator);\\n \\n double speed_of_sound_max = 0.0;\\n for (const auto &mat : materials)\\n      speed_of_sound_max = std::max(speed_of_sound_max, mat.second.first);\\n \\n \\n    time_integrator.run(matrix_free,\\n /*Cr*/ 0.2,\\n                        end_time,\\n                        speed_of_sound_max,\\n                        initial_condition,\\n                        vtk_prefix);\\n  }\\n \\n template <int dim, typename Number>\\n void run_with_nitsche_type_mortaring(\\n const MatrixFree<dim, Number>      &matrix_free,\\n const std::set<types::boundary_id> &non_matching_faces,\\n const std::map<types::material_id, std::pair<double, double>> &materials,\\n const double                                                   end_time,\\n const Function<dim> &initial_condition,\\n const std::string   &vtk_prefix)\\n  {\\n#ifndef DEAL_II_WITH_CGAL\\n    (void)matrix_free;\\n    (void)non_matching_faces;\\n    (void)materials;\\n    (void)end_time;\\n    (void)initial_condition;\\n    (void)vtk_prefix;\\n \\n ConditionalOStream pcout(\\n      std::cout, (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0));\\n \\n    pcout << \\\"In this function, mortars are computed using CGAL. \\\"\\n \\\"Configure deal.II with DEAL_II_WITH_CGAL to run this function.\\\\n\\\";\\n \\n return;\\n#else\\n \\n const auto &dof_handler       = matrix_free.get_dof_handler();\\n const auto &tria              = dof_handler.get_triangulation();\\n const auto &mapping           = *matrix_free.get_mapping_info().mapping;\\n const auto  n_quadrature_pnts = matrix_free.get_quadrature().size();\\n \\n    std::vector<\\n      std::pair<types::boundary_id, std::function<std::vector<bool>()>>>\\n      non_matching_faces_marked_vertices;\\n \\n for (const auto &nm_face : non_matching_faces)\\n      {\\n auto marked_vertices = [&]() {\\n          std::vector<bool> mask(tria.n_vertices(), true);\\n \\n for (const auto &cell : tria.active_cell_iterators())\\n            for (auto const &f : cell->face_indices())\\n              if (cell->face(f)->at_boundary() &&\\n                  cell->face(f)->boundary_id() == nm_face)\\n                for (const auto v : cell->vertex_indices())\\n mask[cell->vertex_index(v)] = false;\\n \\n return mask;\\n        };\\n \\n        non_matching_faces_marked_vertices.emplace_back(\\n          std::make_pair(nm_face, marked_vertices));\\n      }\\n \\n typename NonMatching::MappingInfo<dim, dim, Number>::AdditionalData\\n      additional_data;\\n    additional_data.use_global_weights = true;\\n \\n auto nm_mapping_info =\\n      std::make_shared<NonMatching::MappingInfo<dim, dim, Number>>(\\n        mapping,\\n update_values | update_JxW_values | update_normal_vectors |\\n update_quadrature_points,\\n        additional_data);\\n \\n auto remote_communicator =\\n Utilities::compute_remote_communicator_faces_nitsche_type_mortaring(\\n        matrix_free,\\n        non_matching_faces_marked_vertices,\\n        n_quadrature_pnts,\\n        0,\\n        nm_mapping_info.get());\\n \\n using remote_value_type = Number;\\n \\n const auto pressure_r =\\n      std::make_shared<FERemoteEvaluation<dim, 1, remote_value_type>>(\\n        remote_communicator, dof_handler, /*first_selected_component*/ 0);\\n \\n const auto velocity_r =\\n      std::make_shared<FERemoteEvaluation<dim, dim, remote_value_type>>(\\n        remote_communicator, dof_handler, /*first_selected_component*/ 1);\\n \\n const auto material_data =\\n      std::make_shared<CellwiseMaterialData<Number>>(matrix_free, materials);\\n \\n const auto c_r =\\n      std::make_shared<FERemoteEvaluation<dim, 1, remote_value_type>>(\\n        remote_communicator,\\n        matrix_free.get_dof_handler().get_triangulation(),\\n /*first_selected_component*/ 0);\\n const auto rho_r =\\n      std::make_shared<FERemoteEvaluation<dim, 1, remote_value_type>>(\\n        remote_communicator,\\n        matrix_free.get_dof_handler().get_triangulation(),\\n /*first_selected_component*/ 0);\\n \\n if (!material_data->is_homogeneous())\\n      {\\n Vector<Number> c(\\n          matrix_free.get_dof_handler().get_triangulation().n_active_cells());\\n Vector<Number> rho(\\n          matrix_free.get_dof_handler().get_triangulation().n_active_cells());\\n \\n for (const auto &cell : matrix_free.get_dof_handler()\\n                                  .get_triangulation()\\n                                  .active_cell_iterators())\\n          {\\n            c[cell->active_cell_index()] =\\n              materials.at(cell->material_id()).first;\\n            rho[cell->active_cell_index()] =\\n              materials.at(cell->material_id()).second;\\n          }\\n \\n        c_r->gather_evaluate(c, EvaluationFlags::values);\\n        rho_r->gather_evaluate(rho, EvaluationFlags::values);\\n      }\\n \\n const auto inverse_mass_operator =\\n      std::make_shared<InverseMassOperator<dim, Number>>(matrix_free);\\n \\n const auto acoustic_operator =\\n      std::make_shared<AcousticOperator<dim, Number, remote_value_type>>(\\n        matrix_free,\\n        material_data,\\n        non_matching_faces,\\n        pressure_r,\\n        velocity_r,\\n        c_r,\\n        rho_r,\\n        nm_mapping_info);\\n \\n    RungeKutta2<dim, Number, remote_value_type> time_integrator(\\n      inverse_mass_operator, acoustic_operator);\\n \\n double speed_of_sound_max = 0.0;\\n for (const auto &mat : materials)\\n      speed_of_sound_max = std::max(speed_of_sound_max, mat.second.first);\\n \\n    time_integrator.run(matrix_free,\\n /*Cr*/ 0.2,\\n                        end_time,\\n                        speed_of_sound_max,\\n                        initial_condition,\\n                        vtk_prefix);\\n#endif\\n  }\\n} // namespace Step89\\n \\n \\nint main(int argc, char *argv[])\\n{\\n using namespace dealii;\\n constexpr int dim = 2;\\n using Number      = double;\\n \\n Utilities::MPI::MPI_InitFinalize mpi(argc, argv);\\n  std::cout.precision(5);\\n ConditionalOStream pcout(std::cout,\\n                           (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) ==\\n                            0));\\n \\n const unsigned int refinements = 1;\\n const unsigned int degree      = 3;\\n \\n#ifdef DEAL_II_WITH_P4EST\\n parallel::distributed::Triangulation<dim> tria(MPI_COMM_WORLD);\\n#else\\n parallel::shared::Triangulation<dim> tria(MPI_COMM_WORLD);\\n#endif\\n \\n  pcout << \\\"Create non-matching grid...\\\" << std::endl;\\n \\n  std::set<types::boundary_id> non_matching_faces;\\n  Step89::build_non_matching_triangulation(tria,\\n                                           non_matching_faces,\\n                                           refinements);\\n \\n  pcout << \\\" - Refinement level: \\\" << refinements << std::endl;\\n  pcout << \\\" - Number of cells: \\\" << tria.n_cells() << std::endl;\\n \\n  pcout << \\\"Create DoFHandler...\\\" << std::endl;\\n DoFHandler<dim> dof_handler(tria);\\n  dof_handler.distribute_dofs(FESystem<dim>(FE_DGQ<dim>(degree) ^ (dim + 1)));\\n  pcout << \\\" - Number of DoFs: \\\" << dof_handler.n_dofs() << std::endl;\\n \\n AffineConstraints<Number> constraints;\\n  constraints.close();\\n \\n  pcout << \\\"Set up MatrixFree...\\\" << std::endl;\\n typename MatrixFree<dim, Number>::AdditionalData data;\\n  data.mapping_update_flags             = update_gradients | update_values;\\n  data.mapping_update_flags_inner_faces = update_values;\\n  data.mapping_update_flags_boundary_faces =\\n update_quadrature_points | update_values;\\n \\n MatrixFree<dim, Number> matrix_free;\\n  matrix_free.reinit(\\n MappingQ1<dim>(), dof_handler, constraints, QGauss<dim>(degree + 1), data);\\n \\n \\n  pcout << \\\"Run vibrating membrane test case...\\\" << std::endl;\\n const double                                            modes = 10.0;\\n  std::map<types::material_id, std::pair<double, double>> homogeneous_material;\\n  homogeneous_material[numbers::invalid_material_id] = std::make_pair(1.0, 1.0);\\n const auto initial_solution_membrane =\\n    Step89::InitialConditionVibratingMembrane<dim>(modes);\\n \\n /* Run vibrating membrane test case using point-to-point interpolation: */\\n  pcout << \\\" - Point-to-point interpolation: \\\" << std::endl;\\n  Step89::run_with_point_to_point_interpolation(\\n    matrix_free,\\n    non_matching_faces,\\n    homogeneous_material,\\n    8.0 * initial_solution_membrane.get_period_duration(\\n            homogeneous_material.begin()->second.first),\\n    initial_solution_membrane,\\n \\\"vm-p2p\\\");\\n \\n /* Run vibrating membrane test case using Nitsche-type mortaring: */\\n  pcout << \\\" - Nitsche-type mortaring: \\\" << std::endl;\\n  Step89::run_with_nitsche_type_mortaring(\\n    matrix_free,\\n    non_matching_faces,\\n    homogeneous_material,\\n    8.0 * initial_solution_membrane.get_period_duration(\\n            homogeneous_material.begin()->second.first),\\n    initial_solution_membrane,\\n \\\"vm-nitsche\\\");\\n \\n  pcout << \\\"Run test case with inhomogeneous material...\\\" << std::endl;\\n  std::map<types::material_id, std::pair<double, double>>\\n    inhomogeneous_material;\\n  inhomogeneous_material[0] = std::make_pair(1.0, 1.0);\\n  inhomogeneous_material[1] = std::make_pair(3.0, 1.0);\\n  Step89::run_with_nitsche_type_mortaring(matrix_free,\\n                                          non_matching_faces,\\n                                          inhomogeneous_material,\\n /*runtime*/ 0.3,\\n                                          Step89::GaussPulse<dim>(0.3, 0.5),\\n \\\"inhomogeneous\\\");\\n \\n \\n return 0;\\n}\\nDataOutInterface::write_vtu_in_parallelvoid write_vtu_in_parallel(const std::string &filename, const MPI_Comm comm) constDefinition data_out_base.cc:7715\\nDataOutInterface::set_flagsvoid set_flags(const FlagType &flags)Definition data_out_base.cc:8863\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nDoFHandler::get_feconst FiniteElement< dim, spacedim > & get_fe(const types::fe_index index=0) const\\nDoFHandler::get_triangulationconst Triangulation< dim, spacedim > & get_triangulation() const\\nDoFHandler::get_communicatorMPI_Comm get_communicator() const\\nFEEvaluationBase::get_valuevalue_type get_value(const unsigned int q_point) const\\nFEFacePointEvaluation::integrate_in_facevoid integrate_in_face(ScalarNumber *face_dof_values, const EvaluationFlags::EvaluationFlags &integration_flags, const bool sum_into_values=false)Definition fe_point_evaluation.h:3729\\nFEFacePointEvaluation::evaluate_in_facevoid evaluate_in_face(const ScalarNumber *face_dof_values, const EvaluationFlags::EvaluationFlags &evaluation_flags)Definition fe_point_evaluation.h:3556\\nFEFacePointEvaluation::reinitvoid reinit(const unsigned int cell_index, const unsigned int face_number)Definition fe_point_evaluation.h:3225\\nFiniteElementData::degreeconst unsigned int degreeDefinition fe_data.h:452\\nMatrixFree::get_boundary_idtypes::boundary_id get_boundary_id(const unsigned int face_batch_index) const\\nMatrixFree::get_quadratureconst Quadrature< dim > & get_quadrature(const unsigned int quad_index=0, const unsigned int hp_active_fe_index=0) const\\nMatrixFree::loopvoid loop(const std::function< void(const MatrixFree< dim, Number, VectorizedArrayType > &, OutVector &, const InVector &, const std::pair< unsigned int, unsigned int > &)> &cell_operation, const std::function< void(const MatrixFree< dim, Number, VectorizedArrayType > &, OutVector &, const InVector &, const std::pair< unsigned int, unsigned int > &)> &inner_face_operation, const std::function< void(const MatrixFree< dim, Number, VectorizedArrayType > &, OutVector &, const InVector &, const std::pair< unsigned int, unsigned int > &)> &boundary_face_operation, OutVector &dst, const InVector &src, const bool zero_dst_vector=false, const DataAccessOnFaces dst_vector_face_access=DataAccessOnFaces::unspecified, const DataAccessOnFaces src_vector_face_access=DataAccessOnFaces::unspecified) const\\nMatrixFree::n_active_entries_per_face_batchunsigned int n_active_entries_per_face_batch(const unsigned int face_batch_index) const\\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nTriangulation::n_cellsunsigned int n_cells() const\\nTriangulation::get_triangulationTriangulation< dim, spacedim > & get_triangulation()\\nTriangulation::n_verticesunsigned int n_vertices() const\\nconditional_ostream.h\\ntria.h\\nfe_values.h\\nfe_dgq.h\\nfe_evaluation.h\\nfe_remote_evaluation.h\\nfe_system.h\\ngrid_generator.h\\ngrid_tools.h\\ngrid_tools_cache.h\\nmapping_q1.h\\nmatrix_free.h\\nmpi.h\\nDataOutBase::write_vtuvoid write_vtu(const std::vector< Patch< dim, spacedim > > &patches, const std::vector< std::string > &data_names, const std::vector< std::tuple< unsigned int, unsigned int, std::string, DataComponentInterpretation::DataComponentInterpretation > > &nonscalar_data_ranges, const VtkFlags &flags, std::ostream &out)Definition data_out_base.cc:5228\\nVectorTools::EvaluationFlags::min@ minDefinition vector_tools_evaluate.h:61\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\ninternal::QGaussLobatto::gammalong double gamma(const unsigned int n)Definition quadrature_lib.cc:103\\ninternal::VectorizationTypes::mask@ mask\\ntypes::material_idunsigned int material_idDefinition types.h:167\\ntypes::boundary_idunsigned int boundary_idDefinition types.h:144\\nmapping_info.h\\ndata_out.h\\noperators.h\\nMatrixFree::AdditionalData::mapping_update_flags_inner_facesUpdateFlags mapping_update_flags_inner_facesDefinition matrix_free.h:413\\nMatrixFree::AdditionalData::mapping_update_flags_boundary_facesUpdateFlags mapping_update_flags_boundary_facesDefinition matrix_free.h:393\\nMatrixFree::AdditionalData::mapping_update_flagsUpdateFlags mapping_update_flagsDefinition matrix_free.h:373\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"