"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_42.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-42 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-42 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-42 tutorial program\\n\\n\\nThis tutorial depends on step-41, step-40.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nIntroduction\\nClassical formulation\\nReformulation as a variational inequality\\nA Newton method for the plastic nonlinearity\\nActive Set methods to solve the saddle point problem\\nOverall algorithm\\nAdaptive mesh refinement\\nImplementation\\n\\n The commented program\\n\\nInclude files\\nThe ConstitutiveLaw class template\\n\\nConstitutiveLaw::get_stress_strain_tensor\\nConstitutiveLaw::get_linearized_stress_strain_tensors\\nThe SphereObstacle class\\nThe BitmapFile and ChineseObstacle classes\\n\\nThe PlasticityContactProblem class template\\nImplementation of the PlasticityContactProblem class\\n\\nPlasticityContactProblem::declare_parameters\\nThe PlasticityContactProblem constructor\\nPlasticityContactProblem::make_grid\\nPlasticityContactProblem::setup_system\\nPlasticityContactProblem::compute_dirichlet_constraints\\nPlasticityContactProblem::assemble_mass_matrix_diagonal\\nPlasticityContactProblem::update_solution_and_constraints\\nPlasticityContactProblem::assemble_newton_system\\nPlasticityContactProblem::compute_nonlinear_residual\\nPlasticityContactProblem::solve_newton_system\\nPlasticityContactProblem::solve_newton\\nPlasticityContactProblem::refine_grid\\nPlasticityContactProblem::move_mesh\\nPlasticityContactProblem::output_results\\nPlasticityContactProblem::output_contact_force\\nPlasticityContactProblem::run\\n\\nThe main function\\n\\n\\n Results\\n\\n\\n The plain program\\n   \\n\\n\\nThis program was contributed by J\\u00f6rg Frohne (University of Siegen, Germany) while on a long-term visit to Texas A&M University, with significant contributions by Timo Heister and Wolfgang Bangerth. \\n\\n The code described here provides the basis for the numerical experiments shown in the following paper: \\n J. Frohne, T. Heister, W. Bangerth: Efficient numerical methods for the large-scale, parallel solution of elastoplastic contact problems. Accepted for publication in International Journal for Numerical Methods in Engineering, 2015. \\n Introduction\\nThis example is an extension of step-41, considering a 3d contact problem with an elasto-plastic material behavior with isotropic hardening in three dimensions. In other words, it considers how a three-dimensional body deforms if one pushes into it a rigid obstacle (the contact problem) where deformation is governed by an elasto-plastic material law (a material that can only accommodate a certain maximal stress) that hardens as deformation accumulates. To show what we intend to do before going into too many details, let us just show a picture of what the solution will look like (the deformable body is a cube - only half of which is actually shown -, the obstacle corresponds to a Chinese character that is discussed below):\\n\\nThis problem description implies that we have to take care of an additional nonlinearity compared to step-41: the material behavior. Since we consider a three dimensional problem here, we also have to account for the fact that the contact area is at the boundary of the deformable body now, rather than in the interior. Finally, compared to step-41, we also have to deal with hanging nodes in both the handling of the linear system as well as of the inequality constraints as we would like to use an adaptive mesh; in the latter case, we will have to deal with prioritizing whether the constraints from the hanging nodes or from the inequalities are more important.\\nSince you can very easily reach a few million degrees of freedom in three dimensions, even with adaptive mesh refinement, we decided to use Trilinos and p4est to run our code in parallel, building on the framework of step-40 for the parallelization. Additional pointers for parallelization can be found in step-32.\\nClassical formulation\\nThe classical formulation of the problem possesses the following form:             \\n\\\\begin{align*}\\n \\\\varepsilon(\\\\mathbf u) &= A\\\\sigma + \\\\varepsilon^p & &\\\\quad\\\\text{in } \\\\Omega,\\\\\\\\\\n  -\\\\textrm{div}\\\\ \\\\sigma &= \\\\mathbf f & &\\\\quad\\\\text{in } \\\\Omega,\\\\\\\\\\n  \\\\varepsilon^p:(\\\\tau - \\\\sigma) &\\\\geq 0\\\\quad\\\\forall\\\\tau\\\\text{ with\\n  }\\\\mathcal{F}(\\\\tau)\\\\leq 0 & &\\\\quad\\\\text{in } \\\\Omega,\\\\\\\\\\n  \\\\mathbf u &= 0 & &\\\\quad\\\\text{on }\\\\Gamma_D,\\\\\\\\\\n  \\\\sigma \\\\mathbf n - [\\\\mathbf n \\\\cdot(\\\\sigma \\\\mathbf n)]\\\\mathbf n &= 0,\\n  \\\\quad \\\\mathbf n \\\\cdot (\\\\sigma\\n  \\\\mathbf n) \\\\leq 0 & &\\\\quad\\\\text{on }\\\\Gamma_C,\\\\\\\\\\n  (\\\\mathbf n \\\\cdot (\\\\sigma\\n  \\\\mathbf n))(\\\\mathbf n \\\\cdot \\\\mathbf u - g) &= 0,\\\\quad \\\\mathbf n\\n  \\\\cdot \\\\mathbf u - g \\\\leq 0 & &\\\\quad\\\\text{on } \\\\Gamma_C.\\n\\\\end{align*}\\n\\n Here, the first of these equations defines the relationship between strain  \\\\(\\\\varepsilon(\\\\mathbf u)=\\\\frac{1}{2}\\\\left(\\\\nabla \\\\mathbf u\\n  + \\\\nabla \\\\mathbf u^T\\\\right)\\\\) and stress \\\\(\\\\sigma\\\\) via the fourth-order compliance tensor \\\\(A\\\\); \\\\(\\\\varepsilon^p\\\\) provides the plastic component of the strain to ensure that the stress does not exceed the yield stress. We will only consider isotropic materials for which \\\\(A\\\\) can be expressed in terms of the Lam\\u00e9 moduli \\\\(\\\\lambda\\\\) and \\\\(\\\\mu\\\\) or alternatively in terms of the bulk modulus \\\\(\\\\kappa\\\\) and \\\\(\\\\mu\\\\). The second equation is the force balance; we will here not consider any body forces and henceforth assume that \\\\(\\\\mathbf f=0\\\\). The complementarity condition in the third line implies that \\\\(\\\\varepsilon^p=0\\\\) if \\\\(\\\\mathcal{F}(\\\\sigma)< 0\\\\) but that \\\\(\\\\varepsilon^p\\\\) may be a nonzero tensor if and only if \\\\(\\\\mathcal{F}(\\\\sigma) = 0\\\\), and in particular that in this case \\\\(\\\\varepsilon^p\\\\) must point in the direction  \\\\(\\\\partial\\n\\\\mathcal{F}(\\\\sigma)/\\\\partial \\\\sigma\\\\). The inequality \\\\(\\\\mathcal{F}(\\\\sigma)\\\\le 0\\\\) is a statement of the fact that plastic materials can only support a finite amount of stress; in other words, they react with plastic deformations \\\\(\\\\varepsilon^p\\\\) if external forces would result in a stress \\\\(\\\\sigma\\\\) for which \\\\(\\\\mathcal{F}(\\\\sigma)> 0\\\\) would result. A typical form for this yield function is \\\\(\\\\mathcal{F}(\\\\sigma)=|\\\\sigma^D|-\\\\sigma_{\\\\text{yield}}\\\\) where  \\\\(\\\\tau^D\\n= \\\\tau - \\\\dfrac{1}{3}tr(\\\\tau)I\\\\) is the deviatoric part of a tensor and \\\\(|\\\\cdot|\\\\) denotes the Frobenius norm.\\nFurther equations describe a fixed, zero displacement on \\\\(\\\\Gamma_D\\\\) and that on the surface \\\\(\\\\Gamma_C=\\\\partial\\\\Omega\\\\backslash\\\\Gamma_D\\\\) where contact may appear, the normal force  \\\\(\\\\sigma_n=\\\\mathbf n \\\\cdot (\\\\sigma(\\\\mathbf u)\\n  \\\\mathbf n)\\\\) exerted by the obstacle is inward (no \\\"pull\\\" by the obstacle on our body) and with zero tangential component  \\\\(\\\\mathbf \\\\sigma_t= \\\\sigma \\\\mathbf n - \\\\mathbf \\\\sigma_n \\\\mathbf n\\n= \\\\sigma \\\\mathbf n - [\\\\mathbf n \\\\cdot(\\\\sigma \\\\mathbf n)]\\\\mathbf n\\\\). The last condition is again a complementarity condition that implies that on \\\\(\\\\Gamma_C\\\\), the normal force can only be nonzero if the body is in contact with the obstacle; the second part describes the impenetrability of the obstacle and the body. The last two equations are commonly referred to as the Signorini contact conditions.\\nMost materials - especially metals - have the property that they show some hardening as a result of deformation. In other words, \\\\(\\\\sigma_{\\\\text{yield}}\\\\) increases with deformation. In practice, it is not the elastic deformation that results in hardening, but the plastic component. There are different constitutive laws to describe those material behaviors. The simplest one is called linear isotropic hardening described by the flow function  \\\\(\\\\mathcal{F}(\\\\sigma,\\\\varepsilon^p) = \\\\vert\\\\sigma^D\\\\vert - (\\\\sigma_0 +\\n\\\\gamma^{\\\\text{iso}}|\\\\varepsilon^p|)\\\\).\\nReformulation as a variational inequality\\nIt is generally rather awkward to deal with inequalities. Here, we have to deal with two: plasticity and the contact problem. As described in more detail in the paper mentioned at the top of this page, one can at least reformulate the plasticity in a way that makes it look like a nonlinearity that we can then treat with Newton's method. This is slightly tricky mathematically since the nonlinearity is not just some smooth function but instead has kinks where the stress reaches the yield stress; however, it can be shown for such semismooth functions that Newton's method still converges.\\nWithout going into details, we will also get rid of the stress as an independent variable and instead work exclusively with the displacements \\\\(\\\\mathbf u\\\\). Ultimately, the goal of this reformulation is that we will want to end up with a symmetric, positive definite problem - such as a linearized elasticity problem with spatially variable coefficients resulting from the plastic behavior - that needs to be solved in each Newton step. We want this because there are efficient and scalable methods for the solution of such linear systems, such as CG preconditioned with an algebraic multigrid. This is opposed to the saddle point problem akin to the mixed Laplace (see step-20) we would get were we to continue with the mixed formulation containing both displacements and stresses, and for which step-20 already gives a hint at how difficult it is to construct good solvers and preconditioners.\\nWith this said, let us simply state the problem we obtain after reformulation (again, details can be found in the paper): Find a displacement  \\\\(\\\\mathbf u \\\\in\\nV^+\\\\) so that   \\n\\\\begin{align*}\\n\\\\left(P_{\\\\Pi}(C\\\\varepsilon(\\\\mathbf u)),\\\\varepsilon(\\\\varphi) - \\\\varepsilon(\\\\mathbf u)\\\\right) \\\\geq 0,\\\\quad \\\\forall \\\\varphi\\\\in V^+.\\n\\\\end{align*}\\n\\n where the projector \\\\(P_\\\\Pi\\\\) is defined as           \\n\\\\begin{align*}\\n P_{\\\\Pi}(\\\\tau) \\\\dealcoloneq \\\\begin{cases}\\n    \\\\tau, & \\\\text{if }\\\\vert\\\\tau^D\\\\vert \\\\leq \\\\sigma_0,\\\\\\\\\\n    \\\\left[\\n      \\\\dfrac{\\\\gamma^{\\\\text{iso}}}{2\\\\mu + \\\\gamma^{\\\\text{iso}}} +\\n      \\\\left(1-\\\\dfrac{\\\\gamma^{\\\\text{iso}}}{2\\\\mu + \\\\gamma^{\\\\text{iso}}}\\\\right)\\\\dfrac{\\\\sigma_0}{\\\\vert\\\\tau^D\\\\vert}\\n    \\\\right]\\\\tau^D\\n    + \\\\dfrac{1}{3}\\\\text{trace}(\\\\tau) I, & \\\\text{if }\\\\vert\\\\tau^D\\\\vert >\\n    \\\\sigma_0,\\n  \\\\end{cases}\\n\\\\end{align*}\\n\\n and the space \\\\(V^+\\\\) is the space of all displacements that satisfy the contact condition:          \\n\\\\begin{align*}\\n  V\\n  &=\\n  \\\\left\\\\{ \\\\mathbf u\\\\in \\\\left[H^1(\\\\Omega)\\\\right]^{d}:\\n    \\\\mathbf u = 0 \\\\text{ on } \\\\Gamma_D\\\\right\\\\},\\n  \\\\\\\\\\n  V^+\\n  &=\\n  \\\\left\\\\{ \\\\mathbf u\\\\in V: \\\\mathbf n \\\\cdot \\\\mathbf u\\\\leq g \\\\text{ on } \\\\Gamma_C \\\\right\\\\}.\\n\\\\end{align*}\\n\\nIn the actual code, we will use the abbreviation \\\\(\\\\gamma=\\\\dfrac{\\\\gamma^{\\\\text{iso}}}{2\\\\mu + \\\\gamma^{\\\\text{iso}}}\\\\).\\nGiven this formulation, we will apply two techniques:\\nRun a Newton method to iterate out the nonlinearity in the projector.\\nRun an active set method for the contact condition, in much the same way as we did in step-41.\\n\\nA strict approach would keep the active set fixed while we iterate the Newton method to convergence (or maybe the other way around: find the final active set before moving on to the next Newton iteration). In practice, it turns out that it is sufficient to do only a single Newton step per active set iteration, and so we will iterate over them concurrently. We will also, every once in a while, refine the mesh.\\nA Newton method for the plastic nonlinearity\\nAs mentioned, we will treat the nonlinearity of the operator \\\\(P_\\\\Pi\\\\) by applying a Newton method, despite the fact that the operator is not differentiable in the strict sense. However, it satisfies the conditions of slant differentiability and this turns out to be enough for Newton's method to work. The resulting method then goes by the name semi-smooth Newton method, which sounds impressive but is, in reality, just a Newton method applied to a semi-smooth function with an appropriately chosen \\\"derivative\\\".\\nIn the current case, we will run our iteration by solving in each iteration \\\\(i\\\\) the following equation (still an inequality, but linearized):          \\n\\\\begin{align*}\\n  \\\\label{eq:linearization}\\n  \\\\left(I_{\\\\Pi}\\\\varepsilon(\\\\tilde {\\\\mathbf u}^{i}),\\n    \\\\varepsilon(\\\\varphi) - \\\\varepsilon(\\\\tilde {\\\\mathbf u}^{i})\\\\right) \\\\geq\\n  \\\\left(\\\\left(I_{\\\\Pi}\\\\varepsilon({\\\\mathbf u}^{i-1}),\\n    \\\\varepsilon(\\\\varphi) - \\\\varepsilon(\\\\tilde {\\\\mathbf u}^{i})\\\\right) -\\n  \\\\left(P_{\\\\Pi}(C\\\\varepsilon({\\\\mathbf u}^{i-1})),\\n    \\\\varepsilon(\\\\varphi) - \\\\varepsilon(\\\\tilde {\\\\mathbf u}^{i})\\\\right)\\\\right),\\n  \\\\quad \\\\forall \\\\varphi\\\\in V^+,\\n\\\\end{align*}\\n\\n where the rank-4 tensor \\\\(I_\\\\Pi=I_\\\\Pi(\\\\varepsilon^D(\\\\mathbf u^{i-1}))\\\\) given by         \\n\\\\begin{align}\\n  I_\\\\Pi = \\\\begin{cases}\\n    C_{\\\\mu} + C_{\\\\kappa}, & \\\\hspace{-8em} \\\\text{if } \\\\vert C\\\\varepsilon^D(\\\\mathbf u^{i-1}) \\\\vert \\\\leq \\\\sigma_0,\\n    \\\\\\\\\\n    \\\\frac{\\\\gamma^{\\\\text{iso}}}{2\\\\mu + \\\\gamma^{\\\\text{iso}}} C_{\\\\mu} + \\\\frac{\\\\left(1-\\\\frac{\\\\gamma^{\\\\text{iso}}}{2\\\\mu + \\\\gamma^{\\\\text{iso}}}\\\\right)\\\\sigma_0}{\\\\vert C\\\\varepsilon^D(\\\\mathbf u^{i-1}) \\\\vert}\\\\left(C_{\\\\mu} -\\n      2\\\\mu\\\\dfrac{C\\\\varepsilon^D(\\\\mathbf u^{i-1})\\\\otimes C\\\\varepsilon^D(\\\\mathbf\\n        u^{i-1})}{\\\\vert C\\\\varepsilon^D(\\\\mathbf u^{i-1})\\\\vert^2}\\\\right) + C_{\\\\kappa}, & \\\\text{ else.}\\n\\\\end{cases}\\n\\\\end{align}\\n\\n This tensor is the (formal) linearization of \\\\(P_\\\\Pi(C\\\\cdot)\\\\) around \\\\(\\\\varepsilon^D(\\\\mathbf u^{i-1})\\\\). For the linear isotropic material we consider here, the bulk and shear components of the projector are given by      \\n\\\\begin{gather*}\\n  C_{\\\\kappa} = \\\\kappa I\\\\otimes I,\\n  \\\\qquad\\\\qquad\\\\qquad\\\\qquad\\n  C_{\\\\mu} = 2\\\\mu\\\\left(\\\\mathbb{I}  - \\\\dfrac{1}{3} I\\\\otimes\\n    I\\\\right),\\n\\\\end{gather*}\\n\\n where \\\\(I\\\\) and \\\\(\\\\mathbb{I}\\\\) are the identity tensors of rank 2 and 4, respectively.\\nNote that this problem corresponds to a linear elastic contact problem where \\\\(I_\\\\Pi\\\\) plays the role of the elasticity tensor \\\\(C=A^{-1}\\\\). Indeed, if the material is not plastic at a point, then \\\\(I_\\\\Pi=C\\\\). However, at places where the material is plastic, \\\\(I_\\\\Pi\\\\) is a spatially varying function. In any case, the system we have to solve for the Newton iterate \\\\(\\\\tilde {\\\\mathbf u}^{i}\\\\) gets us closer to the goal of rewriting our problem in a way that allows us to use well-known solvers and preconditioners for elliptic systems.\\nAs a final note about the Newton method let us mention that as is common with Newton methods we need to globalize it by controlling the step length. In other words, while the system above solves for \\\\(\\\\tilde {\\\\mathbf u}^{i}\\\\), the final iterate will rather be   \\n\\\\begin{align*}\\n  {\\\\mathbf u}^{i} = {\\\\mathbf u}^{i-1} + \\\\alpha_i (\\\\tilde {\\\\mathbf u}^{i} - {\\\\mathbf u}^{i-1})\\n\\\\end{align*}\\n\\n where the difference in parentheses on the right takes the role of the traditional Newton direction, \\\\(\\\\delta {\\\\mathbf u}^{i}\\\\). We will determine \\\\(\\\\alpha^i\\\\) using a standard line search.\\nActive Set methods to solve the saddle point problem\\nThis linearized problem to be solved in each Newton step is essentially like in step-41. The only difference consists in the fact that the contact area is at the boundary instead of in the domain. But this has no further consequence so that we refer to the documentation of step-41 with the only hint that \\\\(\\\\mathcal{S}\\\\) contains all the vertices at the contact boundary \\\\(\\\\Gamma_C\\\\) this time. As there, what we need to do is keep a subset of degrees of freedom fixed, leading to additional constraints that one can write as a saddle point problem. However, as discussed in the paper, by writing these constraints in an appropriate way that removes the coupling between degrees of freedom, we end up with a set of nodes that essentially just have Dirichlet values attached to them.\\nOverall algorithm\\nThe algorithm outlined above combines the damped semismooth Newton-method, which we use for the nonlinear constitutive law, with the semismooth Newton method for the contact. It works as follows: \\n\\nInitialize the active and inactive sets \\\\(\\\\mathcal{A}_i\\\\) and \\\\(\\\\mathcal{F}_i\\\\) such that \\\\(\\\\mathcal{S} = \\\\mathcal{A}_i \\\\cup \\\\mathcal{F}_i\\\\) and  \\\\(\\\\mathcal{A}_i \\\\cap\\n \\\\mathcal{F}_i = \\\\emptyset\\\\) and set \\\\(i = 1\\\\). Here, \\\\(\\\\mathcal{S}\\\\) is the set of all degrees of freedom located at the surface of the domain where contact may happen. The start value  \\\\(\\\\hat U^0 \\\\dealcoloneq\\n P_{\\\\mathcal{A}_k}(0)\\\\) fulfills our obstacle condition, i.e., we project an initial zero displacement onto the set of feasible displacements.\\n\\n\\n\\nAssemble the Newton matrix  \\\\(A_{pq} \\\\dealcoloneq a'(\\n U^{i-1};\\\\varphi_p,\\\\varphi_q)\\\\) and the right-hand-side \\\\(F(\\\\hat U^{i-1})\\\\). These correspond to the linearized Newton step, ignoring for the moment the contact inequality.\\n\\n\\n\\nFind the primal-dual pair \\\\((\\\\tilde U^i,\\\\Lambda^i)\\\\) that satisfies     \\n\\\\begin{align*}\\n A\\\\tilde U^i + B\\\\Lambda^i & = F, &\\\\\\\\\\n \\\\left[B^T\\\\tilde U^i\\\\right]_p & = G_p & \\\\forall p\\\\in\\\\mathcal{A}_i,\\\\\\\\\\n \\\\Lambda^i_p & = 0 & \\\\forall p\\\\in\\\\mathcal{F}_i.\\n \\\\end{align*}\\n\\n As in step-41, we can obtain the solution to this problem by eliminating those degrees of freedom in \\\\({\\\\cal A}_i\\\\) from the first equation and obtain a linear system \\\\(\\\\hat {\\\\hat A}(U^{i-1}) \\\\tilde U^i = \\\\hat {\\\\hat H}(U^{i-1})\\\\).\\n\\n\\n\\nDamp the Newton iteration for \\\\(i>2\\\\) by applying a line search and calculating a linear combination of \\\\(U^{i-1}\\\\) and \\\\(\\\\tilde U^i\\\\). This requires finding an \\\\(\\\\alpha^i_l \\\\dealcoloneq 2^{-l},(l=0,\\\\ldots,10)\\\\) so that  \\n\\\\begin{gather*}U^i \\\\dealcoloneq \\\\alpha^i_l\\\\bar U^i +\\n (1-\\\\alpha^i_l)U^{i-1}\\\\end{gather*}\\n\\n satisfies   \\n\\\\begin{gather*}\\n   \\\\vert {\\\\hat R}\\\\left({\\\\mathbf u}^{i}\\\\right) \\\\vert < \\\\vert {\\\\hat R}\\\\left({\\\\mathbf u}^{i-1}\\\\right) \\\\vert.\\n \\\\end{gather*}\\n\\n with \\\\({\\\\hat R}\\\\left({\\\\mathbf u}\\\\right)=\\\\left(P_{Pi}(C\\\\varepsilon(u)),\\\\varepsilon(\\\\varphi^{i}_p\\\\right)\\\\) with the exceptions of (i) elements \\\\(p\\\\in\\\\mathcal{A}_i\\\\) where we set \\\\({\\\\hat R}\\\\left({\\\\mathbf u}\\\\right)=0\\\\), and (ii) elements that correspond to hanging nodes, which we eliminate in the usual manner.\\n\\n\\n\\nDefine the new active and inactive sets by  \\n\\\\begin{gather*}\\\\mathcal{A}_{i+1} \\\\dealcoloneq \\\\lbrace p\\\\in\\\\mathcal{S}:\\\\Lambda^i_p +\\n c\\\\left(\\\\left[B^TU^i\\\\right]_p - G_p\\\\right) > 0\\\\rbrace,\\\\end{gather*}\\n\\n\\n\\\\begin{gather*}\\\\mathcal{F}_{i+1} \\\\dealcoloneq \\\\lbrace p\\\\in\\\\mathcal{S}:\\\\Lambda^i_p +\\n c\\\\left(\\\\left[B^TU^i\\\\right]_p - G_p\\\\right) \\\\leq 0\\\\rbrace.\\\\end{gather*}\\n\\n\\n\\n\\nProject \\\\(U^i\\\\) so that it satisfies the contact inequality, \\n\\\\begin{gather*}\\\\hat U^i \\\\dealcoloneq P_{\\\\mathcal{A}_{i+1}}(U^i).\\\\end{gather*}\\n\\n{ Here, \\\\(P_{\\\\mathcal{A}}(U)\\\\) is the projection of the active components in \\\\(\\\\mathcal{A}\\\\) to the gap     \\n\\\\begin{gather*}P_{\\\\mathcal{A}}(U)_p \\\\dealcoloneq \\\\begin{cases}\\n U_p, & \\\\textrm{if}\\\\quad p\\\\notin\\\\mathcal{A}\\\\\\\\\\n g_{h,p}, & \\\\textrm{if}\\\\quad\\n p\\\\in\\\\mathcal{A},\\n \\\\end{cases}\\\\end{gather*}\\n\\n where \\\\(g_{h,p}\\\\) is the gap denoting the distance of the obstacle from the undisplaced configuration of the body.\\n\\n\\n\\nIf \\\\(\\\\mathcal{A}_{i+1} = \\\\mathcal{A}_k\\\\) and  \\\\(\\\\left\\\\|\\n {\\\\hat R}\\\\left({\\\\mathbf u}^{i}\\\\right) \\\\right\\\\|_{\\\\ell_2} < \\\\delta\\\\) then stop, else set \\\\(i=i+1\\\\) and go to step (1). This step ensures that we only stop iterations if both the correct active set has been found and the plasticity has been iterated to sufficient accuracy. \\n\\nIn step 3 of this algorithm, the matrix \\\\(B\\\\in\\\\mathbb{R}^{n\\\\times m}\\\\), \\\\(n>m\\\\) describes the coupling of the bases for the displacements and Lagrange multiplier (contact forces) and it is not quadratic in our situation since \\\\(\\\\Lambda^k\\\\) is only defined on \\\\(\\\\Gamma_C\\\\), i.e., the surface where contact may happen. As shown in the paper, we can choose \\\\(B\\\\) to be a matrix that has only one entry per row, (see also H\\u00fceber, Wohlmuth: A primal-dual active set strategy for non-linear multibody contact problems, Comput. Methods Appl. Mech. Engrg. 194, 2005, pp. 3147-3166). The vector \\\\(G\\\\) is defined by a suitable approximation \\\\(g_h\\\\) of the gap \\\\(g\\\\)    \\n\\\\begin{gather*}G_p = \\\\begin{cases}\\ng_{h,p}, & \\\\text{if}\\\\quad p\\\\in\\\\mathcal{S}\\\\\\\\\\n0, & \\\\text{if}\\\\quad p\\\\notin\\\\mathcal{S}.\\n\\\\end{cases}\\\\end{gather*}\\n\\nAdaptive mesh refinement\\nSince we run our program in 3d, the computations the program performs are expensive. Consequently using adaptive mesh refinement is an important step towards staying within acceptable run-times. To make our lives easier we simply choose the KellyErrorEstimator that is already implemented in deal.II. We hand the solution vector to it which contains the displacement \\\\(u\\\\). As we will see in the results it yields a quite reasonable adaptive mesh for the contact zone as well as for plasticity.\\nImplementation\\nThis tutorial is essentially a mixture of step-40 and step-41 but instead of PETSc we let the Trilinos library deal with parallelizing the linear algebra (like in step-32). Since we are trying to solve a similar problem like in step-41 we will use the same methods but now in parallel.\\nA difficulty is handling of the constraints from the Dirichlet conditions, hanging nodes and the inequality condition that arises from the contact. For this purpose we create three objects of type AffineConstraints that describe the various constraints and that we will combine as appropriate in each iteration.\\nCompared to step-41, the programs has a few new classes:\\n\\n\\nConstitutiveLaw describes the plastic behavior of the material\\n\\n\\n\\nSphereObstacle describes a sphere that serves as the obstacle that is pushed into the deformable, elastoplastic body. Whether this or the next class is used to describe the obstacle is determined from the input parameter file.\\n\\n\\n\\nChineseObstacle (and a helper class) is a class that allows us to read in an obstacle from a file. In the example we will show in the results section, this file will be 'obstacle_file.dat' and will correspond to data that shows the Chinese, Japanese or Korean symbol for force or power (see http://www.orientaloutpost.com/ : \\\"This word can be used for motivation - it\\n  can also mean power/motion/propulsion/force. It can be anything\\n  internal or external that keeps you going. This is the safest way to express\\n  motivation in Chinese. If your audience is Japanese, please see the other entry\\n  for motivation. This is a word in Japanese and Korean, but it means \\\"motive power\\\" or \\\"kinetic energy\\\" (without the motivation meaning that you are\\n  probably looking for)\\\"). In essence, we will pretend that we have a stamp (i.e., a mask that corresponds to a flat bottomed obstacle with no pieces of intermediate height) that we press into the body. The symbol in question looks as follows (see also the picture at the top of this section on how the end result looks like):\\n \\n\\n\\nOther than that, let us comment only on the following aspects: \\n\\nThe program allows you to select from two different coarse meshes through the parameter file. These are either a cube \\\\([0,1]^3\\\\) or a half sphere with the open side facing the positive \\\\(z\\\\) direction.\\n\\n\\n\\nIn either case, we will assume the convention that the part of the boundary that may be in contact with the obstacle has boundary indicator one. For both kinds of meshes, we assume that this is a free surface, i.e., the body is either in contact there or there is no force acting on it. For the half sphere, the curved part has boundary indicator zero and we impose zero displacement there. For the box, we impose zero displacement along the bottom but allow vertical displacement along the sides (though no horizontal displacement). \\n\\n The commented program\\n Include files\\nThe set of include files is not much of a surprise any more at this time:\\n\\u00a0 #include <deal.II/base/conditional_ostream.h>\\n\\u00a0 #include <deal.II/base/parameter_handler.h>\\n\\u00a0 #include <deal.II/base/utilities.h>\\n\\u00a0 #include <deal.II/base/index_set.h>\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/base/timer.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/sparsity_tools.h>\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/block_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/solver_bicgstab.h>\\n\\u00a0 #include <deal.II/lac/precondition.h>\\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 #include <deal.II/lac/trilinos_sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/trilinos_block_sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/trilinos_vector.h>\\n\\u00a0 #include <deal.II/lac/trilinos_parallel_block_vector.h>\\n\\u00a0 #include <deal.II/lac/trilinos_precondition.h>\\n\\u00a0 #include <deal.II/lac/trilinos_solver.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_tools.h>\\n\\u00a0 #include <deal.II/grid/manifold_lib.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/distributed/tria.h>\\n\\u00a0 #include <deal.II/distributed/grid_refinement.h>\\n\\u00a0 #include <deal.II/distributed/solution_transfer.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_renumbering.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_system.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/error_estimator.h>\\n\\u00a0 #include <deal.II/numerics/fe_field_function.h>\\n\\u00a0 \\n\\u00a0 #include <fstream>\\n\\u00a0 #include <iostream>\\n\\u00a0 \\nFinally, we include two system headers that let us create a directory for output files. The first header provides the mkdir function and the second lets us determine what happened if mkdir fails.\\n\\u00a0 #include <sys/stat.h>\\n\\u00a0 #include <cerrno>\\n\\u00a0 \\n\\u00a0 namespace Step42\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n The ConstitutiveLaw class template\\nThis class provides an interface for a constitutive law, i.e., for the relationship between strain \\\\(\\\\varepsilon(\\\\mathbf u)\\\\) and stress \\\\(\\\\sigma\\\\). In this example we are using an elastoplastic material behavior with linear, isotropic hardening. Such materials are characterized by Young's modulus \\\\(E\\\\), Poisson's ratio \\\\(\\\\nu\\\\), the initial yield stress \\\\(\\\\sigma_0\\\\) and the isotropic hardening parameter \\\\(\\\\gamma\\\\). For  \\\\(\\\\gamma =\\n   0\\\\) we obtain perfect elastoplastic behavior.\\nAs explained in the paper that describes this program, the first Newton steps are solved with a completely elastic material model to avoid having to deal with both nonlinearities (plasticity and contact) at once. To this end, this class has a function set_sigma_0() that we use later on to simply set \\\\(\\\\sigma_0\\\\) to a very large value \\u2013 essentially guaranteeing that the actual stress will not exceed it, and thereby producing an elastic material. When we are ready to use a plastic model, we set \\\\(\\\\sigma_0\\\\) back to its proper value, using the same function. As a result of this approach, we need to leave sigma_0 as the only non-const member variable of this class.\\n\\u00a0   template <int dim>\\n\\u00a0   class ConstitutiveLaw\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     ConstitutiveLaw(const double E,\\n\\u00a0                     const double nu,\\n\\u00a0                     const double sigma_0,\\n\\u00a0                     const double gamma);\\n\\u00a0 \\n\\u00a0     void set_sigma_0(double sigma_zero);\\n\\u00a0 \\n\\u00a0     bool get_stress_strain_tensor(\\n\\u00a0       const SymmetricTensor<2, dim> &strain_tensor,\\n\\u00a0       SymmetricTensor<4, dim>       &stress_strain_tensor) const;\\n\\u00a0 \\n\\u00a0     void get_linearized_stress_strain_tensors(\\n\\u00a0       const SymmetricTensor<2, dim> &strain_tensor,\\n\\u00a0       SymmetricTensor<4, dim>       &stress_strain_tensor_linearized,\\n\\u00a0       SymmetricTensor<4, dim>       &stress_strain_tensor) const;\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     const double kappa;\\n\\u00a0     const double mu;\\n\\u00a0     double       sigma_0;\\n\\u00a0     const double gamma;\\n\\u00a0 \\n\\u00a0     const SymmetricTensor<4, dim> stress_strain_tensor_kappa;\\n\\u00a0     const SymmetricTensor<4, dim> stress_strain_tensor_mu;\\n\\u00a0   };\\n\\u00a0 \\nSymmetricTensorDefinition symmetric_tensor.h:719\\nThe constructor of the ConstitutiveLaw class sets the required material parameter for our deformable body. Material parameters for elastic isotropic media can be defined in a variety of ways, such as the pair  \\\\(E,\\n   \\\\nu\\\\) (elastic modulus and Poisson's number), using the Lam\\u00e9 parameters \\\\(\\\\lambda,mu\\\\) or several other commonly used conventions. Here, the constructor takes a description of material parameters in the form of \\\\(E,\\\\nu\\\\), but since this turns out to these are not the coefficients that appear in the equations of the plastic projector, we immediately convert them into the more suitable set \\\\(\\\\kappa,\\\\mu\\\\) of bulk and shear moduli. In addition, the constructor takes \\\\(\\\\sigma_0\\\\) (the yield stress absent any plastic strain) and \\\\(\\\\gamma\\\\) (the hardening parameter) as arguments. In this constructor, we also compute the two principal components of the stress-strain relation and its linearization.\\n\\u00a0   template <int dim>\\n\\u00a0   ConstitutiveLaw<dim>::ConstitutiveLaw(double E,\\n\\u00a0                                         double nu,\\n\\u00a0                                         double sigma_0,\\n\\u00a0                                         double gamma)\\n\\u00a0     : kappa(E / (3 * (1 - 2 * nu)))\\n\\u00a0     , mu(E / (2 * (1 + nu)))\\n\\u00a0     , sigma_0(sigma_0)\\n\\u00a0     , gamma(gamma)\\n\\u00a0     , stress_strain_tensor_kappa(kappa *\\n\\u00a0                                  outer_product(unit_symmetric_tensor<dim>(),\\n\\u00a0                                                unit_symmetric_tensor<dim>()))\\n\\u00a0     , stress_strain_tensor_mu(\\n\\u00a0         2 * mu *\\n\\u00a0         (identity_tensor<dim>() - outer_product(unit_symmetric_tensor<dim>(),\\n\\u00a0                                                 unit_symmetric_tensor<dim>()) /\\n\\u00a0                                     3.0))\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void ConstitutiveLaw<dim>::set_sigma_0(double sigma_zero)\\n\\u00a0   {\\n\\u00a0     sigma_0 = sigma_zero;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nint\\nouter_productDEAL_II_HOST constexpr SymmetricTensor< 4, dim, Number > outer_product(const SymmetricTensor< 2, dim, Number > &t1, const SymmetricTensor< 2, dim, Number > &t2)Definition symmetric_tensor.h:3301\\nidentity_tensorDEAL_II_HOST constexpr SymmetricTensor< 4, dim, Number > identity_tensor()Definition symmetric_tensor.h:3215\\nunit_symmetric_tensorDEAL_II_HOST constexpr SymmetricTensor< 2, dim, Number > unit_symmetric_tensor()Definition symmetric_tensor.h:3158\\n ConstitutiveLaw::get_stress_strain_tensor\\nThis is the principal component of the constitutive law. It computes the fourth order symmetric tensor that relates the strain to the stress according to the projection given above, when evaluated at a particular strain point. We need this function to calculate the nonlinear residual in PlasticityContactProblem::compute_nonlinear_residual() where we multiply this tensor with the strain given in a quadrature point. The computations follow the formulas laid out in the introduction. In comparing the formulas there with the implementation below, recall that \\\\(C_\\\\mu : \\\\varepsilon = \\\\tau_D\\\\) and that  \\\\(C_\\\\kappa : \\\\varepsilon = \\\\kappa\\n   \\\\text{trace}(\\\\varepsilon) I = \\\\frac 13 \\\\text{trace}(\\\\tau) I\\\\).\\nThe function returns whether the quadrature point is plastic to allow for some statistics downstream on how many of the quadrature points are plastic and how many are elastic.\\n\\u00a0   template <int dim>\\n\\u00a0   bool ConstitutiveLaw<dim>::get_stress_strain_tensor(\\n\\u00a0     const SymmetricTensor<2, dim> &strain_tensor,\\n\\u00a0     SymmetricTensor<4, dim>       &stress_strain_tensor) const\\n\\u00a0   {\\n\\u00a0     Assert(dim == 3, ExcNotImplemented());\\n\\u00a0 \\n\\u00a0     SymmetricTensor<2, dim> stress_tensor;\\n\\u00a0     stress_tensor =\\n\\u00a0       (stress_strain_tensor_kappa + stress_strain_tensor_mu) * strain_tensor;\\n\\u00a0 \\n\\u00a0     const SymmetricTensor<2, dim> deviator_stress_tensor =\\n\\u00a0       deviator(stress_tensor);\\n\\u00a0     const double deviator_stress_tensor_norm = deviator_stress_tensor.norm();\\n\\u00a0 \\n\\u00a0     stress_strain_tensor = stress_strain_tensor_mu;\\n\\u00a0     if (deviator_stress_tensor_norm > sigma_0)\\n\\u00a0       {\\n\\u00a0         const double beta = sigma_0 / deviator_stress_tensor_norm;\\n\\u00a0         stress_strain_tensor *= (gamma + (1 - gamma) * beta);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     stress_strain_tensor += stress_strain_tensor_kappa;\\n\\u00a0 \\n\\u00a0     return (deviator_stress_tensor_norm > sigma_0);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\ndeviatorDEAL_II_HOST constexpr SymmetricTensor< 2, dim, Number > deviator(const SymmetricTensor< 2, dim, Number > &)Definition symmetric_tensor.h:3141\\n ConstitutiveLaw::get_linearized_stress_strain_tensors\\nThis function returns the linearized stress strain tensor, linearized around the solution \\\\(u^{i-1}\\\\) of the previous Newton step \\\\(i-1\\\\). The parameter strain_tensor (commonly denoted \\\\(\\\\varepsilon(u^{i-1})\\\\)) must be passed as an argument, and serves as the linearization point. The function returns the derivative of the nonlinear constitutive law in the variable stress_strain_tensor, as well as the stress-strain tensor of the linearized problem in stress_strain_tensor_linearized. See PlasticityContactProblem::assemble_newton_system() where this function is used.\\n\\u00a0   template <int dim>\\n\\u00a0   void ConstitutiveLaw<dim>::get_linearized_stress_strain_tensors(\\n\\u00a0     const SymmetricTensor<2, dim> &strain_tensor,\\n\\u00a0     SymmetricTensor<4, dim>       &stress_strain_tensor_linearized,\\n\\u00a0     SymmetricTensor<4, dim>       &stress_strain_tensor) const\\n\\u00a0   {\\n\\u00a0     Assert(dim == 3, ExcNotImplemented());\\n\\u00a0 \\n\\u00a0     SymmetricTensor<2, dim> stress_tensor;\\n\\u00a0     stress_tensor =\\n\\u00a0       (stress_strain_tensor_kappa + stress_strain_tensor_mu) * strain_tensor;\\n\\u00a0 \\n\\u00a0     stress_strain_tensor            = stress_strain_tensor_mu;\\n\\u00a0     stress_strain_tensor_linearized = stress_strain_tensor_mu;\\n\\u00a0 \\n\\u00a0     SymmetricTensor<2, dim> deviator_stress_tensor = deviator(stress_tensor);\\n\\u00a0     const double deviator_stress_tensor_norm = deviator_stress_tensor.norm();\\n\\u00a0 \\n\\u00a0     if (deviator_stress_tensor_norm > sigma_0)\\n\\u00a0       {\\n\\u00a0         const double beta = sigma_0 / deviator_stress_tensor_norm;\\n\\u00a0         stress_strain_tensor *= (gamma + (1 - gamma) * beta);\\n\\u00a0         stress_strain_tensor_linearized *= (gamma + (1 - gamma) * beta);\\n\\u00a0         deviator_stress_tensor /= deviator_stress_tensor_norm;\\n\\u00a0         stress_strain_tensor_linearized -=\\n\\u00a0           (1 - gamma) * beta * 2 * mu *\\n\\u00a0           outer_product(deviator_stress_tensor, deviator_stress_tensor);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     stress_strain_tensor += stress_strain_tensor_kappa;\\n\\u00a0     stress_strain_tensor_linearized += stress_strain_tensor_kappa;\\n\\u00a0   }\\n\\u00a0 \\nEquation data: boundary forces, boundary values, obstacles\\nThe following should be relatively standard. We need classes for the boundary forcing term (which we here choose to be zero) and boundary values on those part of the boundary that are not part of the contact surface (also chosen to be zero here).\\n\\u00a0   namespace EquationData\\n\\u00a0   {\\n\\u00a0     template <int dim>\\n\\u00a0     class BoundaryForce : public Function<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       BoundaryForce();\\n\\u00a0 \\n\\u00a0       virtual double value(const Point<dim>  &p,\\n\\u00a0                            const unsigned int component = 0) const override;\\n\\u00a0 \\n\\u00a0       virtual void vector_value(const Point<dim> &p,\\n\\u00a0                                 Vector<double>   &values) const override;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     BoundaryForce<dim>::BoundaryForce()\\n\\u00a0       : Function<dim>(dim)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double BoundaryForce<dim>::value(const Point<dim> &,\\n\\u00a0                                      const unsigned int) const\\n\\u00a0     {\\n\\u00a0       return 0.;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void BoundaryForce<dim>::vector_value(const Point<dim> &p,\\n\\u00a0                                           Vector<double>   &values) const\\n\\u00a0     {\\n\\u00a0       for (unsigned int c = 0; c < this->n_components; ++c)\\n\\u00a0         values(c) = BoundaryForce<dim>::value(p, c);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     class BoundaryValues : public Function<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       BoundaryValues();\\n\\u00a0 \\n\\u00a0       virtual double value(const Point<dim>  &p,\\n\\u00a0                            const unsigned int component = 0) const override;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     BoundaryValues<dim>::BoundaryValues()\\n\\u00a0       : Function<dim>(dim)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double BoundaryValues<dim>::value(const Point<dim> &,\\n\\u00a0                                       const unsigned int) const\\n\\u00a0     {\\n\\u00a0       return 0.;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFunctionDefinition function.h:152\\nPointDefinition point.h:111\\nVectorDefinition vector.h:120\\ninternal::EvaluatorQuantity::value@ value\\n The SphereObstacle class\\nThe following class is the first of two obstacles that can be selected from the input file. It describes a sphere centered at position \\\\(x=y=0.5, z=z_{\\\\text{surface}}+0.59\\\\) and radius \\\\(r=0.6\\\\), where \\\\(z_{\\\\text{surface}}\\\\) is the vertical position of the (flat) surface of the deformable body. The function's value returns the location of the obstacle for a given \\\\(x,y\\\\) value if the point actually lies below the sphere, or a large positive value that can't possibly interfere with the deformation if it lies outside the \\\"shadow\\\" of the sphere.\\n\\u00a0     template <int dim>\\n\\u00a0     class SphereObstacle : public Function<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       SphereObstacle(const double z_surface);\\n\\u00a0 \\n\\u00a0       virtual double value(const Point<dim>  &p,\\n\\u00a0                            const unsigned int component = 0) const override;\\n\\u00a0 \\n\\u00a0       virtual void vector_value(const Point<dim> &p,\\n\\u00a0                                 Vector<double>   &values) const override;\\n\\u00a0 \\n\\u00a0     private:\\n\\u00a0       const double z_surface;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     SphereObstacle<dim>::SphereObstacle(const double z_surface)\\n\\u00a0       : Function<dim>(dim)\\n\\u00a0       , z_surface(z_surface)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double SphereObstacle<dim>::value(const Point<dim>  &p,\\n\\u00a0                                       const unsigned int component) const\\n\\u00a0     {\\n\\u00a0       if (component == 0)\\n\\u00a0         return p[0];\\n\\u00a0       else if (component == 1)\\n\\u00a0         return p[1];\\n\\u00a0       else if (component == 2)\\n\\u00a0         {\\n\\u00a0           if ((p[0] - 0.5) * (p[0] - 0.5) + (p[1] - 0.5) * (p[1] - 0.5) < 0.36)\\n\\u00a0             return (-std::sqrt(0.36 - (p[0] - 0.5) * (p[0] - 0.5) -\\n\\u00a0                                (p[1] - 0.5) * (p[1] - 0.5)) +\\n\\u00a0                     z_surface + 0.59);\\n\\u00a0           else\\n\\u00a0             return 1000;\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0       DEAL_II_NOT_IMPLEMENTED();\\n\\u00a0       return 1e9; // an unreasonable value; ignored in debug mode because of the\\nFunction::valuevirtual RangeNumberType value(const Point< dim > &p, const unsigned int component=0) const\\nFunction::vector_valuevirtual void vector_value(const Point< dim > &p, Vector< RangeNumberType > &values) const\\nDEAL_II_NOT_IMPLEMENTED#define DEAL_II_NOT_IMPLEMENTED()Definition exceptions.h:1814\\nstd::sqrt::VectorizedArray< Number, width > sqrt(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6869\\npreceding Assert\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void SphereObstacle<dim>::vector_value(const Point<dim> &p,\\n\\u00a0                                            Vector<double>   &values) const\\n\\u00a0     {\\n\\u00a0       for (unsigned int c = 0; c < this->n_components; ++c)\\n\\u00a0         values(c) = SphereObstacle<dim>::value(p, c);\\n\\u00a0     }\\n\\u00a0 \\n The BitmapFile and ChineseObstacle classes\\nThe following two classes describe the obstacle outlined in the introduction, i.e., the Chinese character. The first of the two, BitmapFile is responsible for reading in data from a picture file stored in pbm ascii format. This data will be bilinearly interpolated and thereby provides a function that describes the obstacle. (The code below shows how one can construct a function by interpolating between given data points. One could use the Functions::InterpolatedUniformGridData, introduced after this tutorial program was written, which does exactly what we want here, but it is instructive to see how to do it by hand.)\\nThe data which we read from the file will be stored in a double std::vector named obstacle_data. This vector composes the base to calculate a piecewise bilinear function as a polynomial interpolation. The data we will read from a file consists of zeros (white) and ones (black).\\nThe hx,hy variables denote the spacing between pixels in \\\\(x\\\\) and \\\\(y\\\\) directions. nx,ny are the numbers of pixels in each of these directions. get_value() returns the value of the image at a given location, interpolated from the adjacent pixel values.\\n\\u00a0     template <int dim>\\n\\u00a0     class BitmapFile\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       BitmapFile(const std::string &name);\\n\\u00a0 \\n\\u00a0       double get_value(const double x, const double y) const;\\n\\u00a0 \\n\\u00a0     private:\\n\\u00a0       std::vector<double> obstacle_data;\\n\\u00a0       double              hx, hy;\\n\\u00a0       int                 nx, ny;\\n\\u00a0 \\n\\u00a0       double get_pixel_value(const int i, const int j) const;\\n\\u00a0     };\\n\\u00a0 \\nThe constructor of this class reads in the data that describes the obstacle from the given file name.\\n\\u00a0     template <int dim>\\n\\u00a0     BitmapFile<dim>::BitmapFile(const std::string &name)\\n\\u00a0       : obstacle_data(0)\\n\\u00a0       , hx(0)\\n\\u00a0       , hy(0)\\n\\u00a0       , nx(0)\\n\\u00a0       , ny(0)\\n\\u00a0     {\\n\\u00a0       std::ifstream f(name);\\n\\u00a0       AssertThrow(f,\\n\\u00a0                   ExcMessage(std::string(\\\"Can't read from file <\\\") + name +\\n\\u00a0                              \\\">!\\\"));\\n\\u00a0 \\n\\u00a0       std::string temp;\\n\\u00a0       f >> temp >> nx >> ny;\\n\\u00a0 \\n\\u00a0       AssertThrow(nx > 0 && ny > 0, ExcMessage(\\\"Invalid file format.\\\"));\\n\\u00a0 \\n\\u00a0       for (int k = 0; k < nx * ny; ++k)\\n\\u00a0         {\\n\\u00a0           double val;\\n\\u00a0           f >> val;\\n\\u00a0           obstacle_data.push_back(val);\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0       hx = 1.0 / (nx - 1);\\n\\u00a0       hy = 1.0 / (ny - 1);\\n\\u00a0 \\n\\u00a0       if (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)\\n\\u00a0         std::cout << \\\"Read obstacle from file <\\\" << name << '>' << std::endl\\n\\u00a0                   << \\\"Resolution of the scanned obstacle picture: \\\" << nx\\n\\u00a0                   << \\\" x \\\" << ny << std::endl;\\n\\u00a0     }\\n\\u00a0 \\nAssertThrow#define AssertThrow(cond, exc)Definition exceptions.h:1739\\nUtilities::MPI::this_mpi_processunsigned int this_mpi_process(const MPI_Comm mpi_communicator)Definition mpi.cc:107\\nstdSTL namespace.\\nThe following two functions return the value of a given pixel with coordinates \\\\(i,j\\\\), which we identify with the values of a function defined at positions i*hx, j*hy, and at arbitrary coordinates \\\\(x,y\\\\) where we do a bilinear interpolation between point values returned by the first of the two functions. In the second function, for each \\\\(x,y\\\\), we first compute the (integer) location of the nearest pixel coordinate to the bottom left of \\\\(x,y\\\\), and then compute the coordinates \\\\(\\\\xi,\\\\eta\\\\) within this pixel. We truncate both kinds of variables from both below and above to avoid problems when evaluating the function outside of its defined range as may happen due to roundoff errors.\\n\\u00a0     template <int dim>\\n\\u00a0     double BitmapFile<dim>::get_pixel_value(const int i, const int j) const\\n\\u00a0     {\\n\\u00a0       assert(i >= 0 && i < nx);\\n\\u00a0       assert(j >= 0 && j < ny);\\n\\u00a0       return obstacle_data[nx * (ny - 1 - j) + i];\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double BitmapFile<dim>::get_value(const double x, const double y) const\\n\\u00a0     {\\n\\u00a0       const int ix = std::min(std::max(static_cast<int>(x / hx), 0), nx - 2);\\n\\u00a0       const int iy = std::min(std::max(static_cast<int>(y / hy), 0), ny - 2);\\n\\u00a0 \\n\\u00a0       const double xi  = std::min(std::max((x - ix * hx) / hx, 1.), 0.);\\n\\u00a0       const double eta = std::min(std::max((y - iy * hy) / hy, 1.), 0.);\\n\\u00a0 \\n\\u00a0       return ((1 - xi) * (1 - eta) * get_pixel_value(ix, iy) +\\n\\u00a0               xi * (1 - eta) * get_pixel_value(ix + 1, iy) +\\n\\u00a0               (1 - xi) * eta * get_pixel_value(ix, iy + 1) +\\n\\u00a0               xi * eta * get_pixel_value(ix + 1, iy + 1));\\n\\u00a0     }\\n\\u00a0 \\nstd::min::VectorizedArray< Number, width > min(const ::VectorizedArray< Number, width > &, const ::VectorizedArray< Number, width > &)Definition vectorization.h:6960\\nstd::max::VectorizedArray< Number, width > max(const ::VectorizedArray< Number, width > &, const ::VectorizedArray< Number, width > &)Definition vectorization.h:6943\\nFinally, this is the class that actually uses the class above. It has a BitmapFile object as a member that describes the height of the obstacle. As mentioned above, the BitmapFile class will provide us with a mask, i.e., values that are either zero or one (and, if you ask for locations between pixels, values that are interpolated between zero and one). This class translates this to heights that are either 0.001 below the surface of the deformable body (if the BitmapFile class reports a one at this location) or 0.999 above the obstacle (if the BitmapFile class reports a zero). The following function should then be self-explanatory.\\n\\u00a0     template <int dim>\\n\\u00a0     class ChineseObstacle : public Function<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       ChineseObstacle(const std::string &filename, const double z_surface);\\n\\u00a0 \\n\\u00a0       virtual double value(const Point<dim>  &p,\\n\\u00a0                            const unsigned int component = 0) const override;\\n\\u00a0 \\n\\u00a0       virtual void vector_value(const Point<dim> &p,\\n\\u00a0                                 Vector<double>   &values) const override;\\n\\u00a0 \\n\\u00a0     private:\\n\\u00a0       const BitmapFile<dim> input_obstacle;\\n\\u00a0       double                z_surface;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     ChineseObstacle<dim>::ChineseObstacle(const std::string &filename,\\n\\u00a0                                           const double       z_surface)\\n\\u00a0       : Function<dim>(dim)\\n\\u00a0       , input_obstacle(filename)\\n\\u00a0       , z_surface(z_surface)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double ChineseObstacle<dim>::value(const Point<dim>  &p,\\n\\u00a0                                        const unsigned int component) const\\n\\u00a0     {\\n\\u00a0       if (component == 0)\\n\\u00a0         return p[0];\\n\\u00a0       if (component == 1)\\n\\u00a0         return p[1];\\n\\u00a0       else if (component == 2)\\n\\u00a0         {\\n\\u00a0           if (p[0] >= 0.0 && p[0] <= 1.0 && p[1] >= 0.0 && p[1] <= 1.0)\\n\\u00a0             return z_surface + 0.999 - input_obstacle.get_value(p[0], p[1]);\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0       DEAL_II_NOT_IMPLEMENTED();\\n\\u00a0       return 1e9; // an unreasonable value; ignored in debug mode because of the\\npreceding Assert\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void ChineseObstacle<dim>::vector_value(const Point<dim> &p,\\n\\u00a0                                             Vector<double>   &values) const\\n\\u00a0     {\\n\\u00a0       for (unsigned int c = 0; c < this->n_components; ++c)\\n\\u00a0         values(c) = ChineseObstacle<dim>::value(p, c);\\n\\u00a0     }\\n\\u00a0   } // namespace EquationData\\n\\u00a0 \\n The PlasticityContactProblem class template\\nThis is the main class of this program and supplies all functions and variables needed to describe the nonlinear contact problem. It is close to step-41 but with some additional features like handling hanging nodes, a Newton method, using Trilinos and p4est for parallel distributed computing. To deal with hanging nodes makes life a bit more complicated since we need another AffineConstraints object now. We create a Newton method for the active set method for the contact situation and to handle the nonlinear operator for the constitutive law.\\nThe general layout of this class is very much like for most other tutorial programs. To make our life a bit easier, this class reads a set of input parameters from an input file. These parameters, using the ParameterHandler class, are declared in the declare_parameters function (which is static so that it can be called before we even create an object of the current type), and a ParameterHandler object that has been used to read an input file will then be passed to the constructor of this class.\\nThe remaining member functions are by and large as we have seen in several of the other tutorial programs, though with additions for the current nonlinear system. We will comment on their purpose as we get to them further below.\\n\\u00a0   template <int dim>\\n\\u00a0   class PlasticityContactProblem\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     PlasticityContactProblem(const ParameterHandler &prm);\\n\\u00a0 \\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0     static void declare_parameters(ParameterHandler &prm);\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void make_grid();\\n\\u00a0     void setup_system();\\n\\u00a0     void compute_dirichlet_constraints();\\n\\u00a0     void update_solution_and_constraints();\\n\\u00a0     void\\n\\u00a0     assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &mass_matrix);\\n\\u00a0     void assemble_newton_system(\\n\\u00a0       const TrilinosWrappers::MPI::Vector &linearization_point);\\n\\u00a0     void compute_nonlinear_residual(\\n\\u00a0       const TrilinosWrappers::MPI::Vector &linearization_point);\\n\\u00a0     void solve_newton_system();\\n\\u00a0     void solve_newton();\\n\\u00a0     void refine_grid();\\n\\u00a0     void move_mesh(const TrilinosWrappers::MPI::Vector &displacement) const;\\n\\u00a0     void output_results(const unsigned int current_refinement_cycle);\\n\\u00a0 \\n\\u00a0     void output_contact_force() const;\\n\\u00a0 \\nParameterHandlerDefinition parameter_handler.h:855\\nTrilinosWrappers::MPI::VectorDefinition trilinos_vector.h:405\\nTrilinosWrappers::SparseMatrixDefinition trilinos_sparse_matrix.h:550\\nAs far as member variables are concerned, we start with ones that we use to indicate the MPI universe this program runs on, a stream we use to let exactly one processor produce output to the console (see step-17) and a variable that is used to time the various sections of the program:\\n\\u00a0     MPI_Comm           mpi_communicator;\\n\\u00a0     ConditionalOStream pcout;\\n\\u00a0     TimerOutput        computing_timer;\\n\\u00a0 \\nConditionalOStreamDefinition conditional_ostream.h:80\\nMPI_Comm\\nTimerOutputDefinition timer.h:549\\nThe next group describes the mesh and the finite element space. In particular, for this parallel program, the finite element space has associated with it variables that indicate which degrees of freedom live on the current processor (the index sets, see also step-40 and the Parallel computing with multiple processors using distributed memory documentation topic) as well as a variety of constraints: those imposed by hanging nodes, by Dirichlet boundary conditions, and by the active set of contact nodes. Of the three AffineConstraints variables defined here, the first only contains hanging node constraints, the second also those associated with Dirichlet boundary conditions, and the third these plus the contact constraints.\\nThe variable active_set consists of those degrees of freedom constrained by the contact, and we use fraction_of_plastic_q_points_per_cell to keep track of the fraction of quadrature points on each cell where the stress equals the yield stress. The latter is only used to create graphical output showing the plastic zone, but not for any further computation; the variable is a member variable of this class since the information is computed as a by-product of computing the residual, but is used only much later. (Note that the vector is a vector of length equal to the number of active cells on the local mesh; it is never used to exchange information between processors and can therefore be a regular deal.II vector.)\\n\\u00a0     const unsigned int                        n_initial_global_refinements;\\n\\u00a0     parallel::distributed::Triangulation<dim> triangulation;\\n\\u00a0 \\n\\u00a0     const unsigned int  fe_degree;\\n\\u00a0     const FESystem<dim> fe;\\n\\u00a0     DoFHandler<dim>     dof_handler;\\n\\u00a0 \\n\\u00a0     IndexSet locally_owned_dofs;\\n\\u00a0     IndexSet locally_relevant_dofs;\\n\\u00a0 \\n\\u00a0     AffineConstraints<double> constraints_hanging_nodes;\\n\\u00a0     AffineConstraints<double> constraints_dirichlet_and_hanging_nodes;\\n\\u00a0     AffineConstraints<double> all_constraints;\\n\\u00a0 \\n\\u00a0     IndexSet      active_set;\\n\\u00a0     Vector<float> fraction_of_plastic_q_points_per_cell;\\n\\u00a0 \\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nDoFHandlerDefinition dof_handler.h:317\\nFESystemDefinition fe_system.h:208\\nIndexSetDefinition index_set.h:70\\nparallel::distributed::TriangulationDefinition tria.h:268\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\nThe next block of variables corresponds to the solution and the linear systems we need to form. In particular, this includes the Newton matrix and right hand side; the vector that corresponds to the residual (i.e., the Newton right hand side) but from which we have not eliminated the various constraints and that is used to determine which degrees of freedom need to be constrained in the next iteration; and a vector that corresponds to the diagonal of the \\\\(B\\\\) matrix briefly mentioned in the introduction and discussed in the accompanying paper.\\n\\u00a0     TrilinosWrappers::SparseMatrix newton_matrix;\\n\\u00a0 \\n\\u00a0     TrilinosWrappers::MPI::Vector solution;\\n\\u00a0     TrilinosWrappers::MPI::Vector newton_rhs;\\n\\u00a0     TrilinosWrappers::MPI::Vector newton_rhs_uncondensed;\\n\\u00a0     TrilinosWrappers::MPI::Vector diag_mass_matrix_vector;\\n\\u00a0 \\nThe next block contains the variables that describe the material response:\\n\\u00a0     const double         e_modulus, nu, gamma, sigma_0;\\n\\u00a0     ConstitutiveLaw<dim> constitutive_law;\\n\\u00a0 \\nAnd then there is an assortment of other variables that are used to identify the mesh we are asked to build as selected by the parameter file, the obstacle that is being pushed into the deformable body, the mesh refinement strategy, whether to transfer the solution from one mesh to the next, and how many mesh refinement cycles to perform. As possible, we mark these kinds of variables as const to help the reader identify which ones may or may not be modified later on (the output directory being an exception \\u2013 it is never modified outside the constructor but it is awkward to initialize in the member-initializer-list following the colon in the constructor since there we have only one shot at setting it; the same is true for the mesh refinement criterion):\\n\\u00a0     const std::string                          base_mesh;\\n\\u00a0     const std::shared_ptr<const Function<dim>> obstacle;\\n\\u00a0 \\n\\u00a0     struct RefinementStrategy\\n\\u00a0     {\\n\\u00a0       enum value\\n\\u00a0       {\\n\\u00a0         refine_global,\\n\\u00a0         refine_percentage,\\n\\u00a0         refine_fix_dofs\\n\\u00a0       };\\n\\u00a0     };\\n\\u00a0     typename RefinementStrategy::value refinement_strategy;\\n\\u00a0 \\n\\u00a0     const bool         transfer_solution;\\n\\u00a0     std::string        output_dir;\\n\\u00a0     const unsigned int n_refinement_cycles;\\n\\u00a0     unsigned int       current_refinement_cycle;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n Implementation of the PlasticityContactProblem class\\n PlasticityContactProblem::declare_parameters\\nLet us start with the declaration of run-time parameters that can be selected in the input file. These values will be read back in the constructor of this class to initialize the member variables of this class:\\n\\u00a0   template <int dim>\\n\\u00a0   void PlasticityContactProblem<dim>::declare_parameters(ParameterHandler &prm)\\n\\u00a0   {\\n\\u00a0     prm.declare_entry(\\n\\u00a0       \\\"polynomial degree\\\",\\n\\u00a0       \\\"1\\\",\\n\\u00a0       Patterns::Integer(),\\n\\u00a0       \\\"Polynomial degree of the FE_Q finite element space, typically 1 or 2.\\\");\\n\\u00a0     prm.declare_entry(\\\"number of initial refinements\\\",\\n\\u00a0                       \\\"2\\\",\\n\\u00a0                       Patterns::Integer(),\\n\\u00a0                       \\\"Number of initial global mesh refinement steps before \\\"\\n\\u00a0                       \\\"the first computation.\\\");\\n\\u00a0     prm.declare_entry(\\n\\u00a0       \\\"refinement strategy\\\",\\n\\u00a0       \\\"percentage\\\",\\n\\u00a0       Patterns::Selection(\\\"global|percentage\\\"),\\n\\u00a0       \\\"Mesh refinement strategy:\\\\n\\\"\\n\\u00a0       \\\" global: one global refinement\\\\n\\\"\\n\\u00a0       \\\" percentage: a fixed percentage of cells gets refined using the Kelly estimator.\\\");\\n\\u00a0     prm.declare_entry(\\\"number of cycles\\\",\\n\\u00a0                       \\\"5\\\",\\n\\u00a0                       Patterns::Integer(),\\n\\u00a0                       \\\"Number of adaptive mesh refinement cycles to run.\\\");\\n\\u00a0     prm.declare_entry(\\n\\u00a0       \\\"obstacle\\\",\\n\\u00a0       \\\"sphere\\\",\\n\\u00a0       Patterns::Selection(\\\"sphere|read from file\\\"),\\n\\u00a0       \\\"The name of the obstacle to use. This may either be 'sphere' if we should \\\"\\n\\u00a0       \\\"use a spherical obstacle, or 'read from file' in which case the obstacle \\\"\\n\\u00a0       \\\"will be read from a file named 'obstacle.pbm' that is supposed to be in \\\"\\n\\u00a0       \\\"ASCII PBM format.\\\");\\n\\u00a0     prm.declare_entry(\\n\\u00a0       \\\"output directory\\\",\\n\\u00a0       \\\"\\\",\\n\\u00a0       Patterns::Anything(),\\n\\u00a0       \\\"Directory for output files (graphical output and benchmark \\\"\\n\\u00a0       \\\"statistics). If empty, use the current directory.\\\");\\n\\u00a0     prm.declare_entry(\\n\\u00a0       \\\"transfer solution\\\",\\n\\u00a0       \\\"false\\\",\\n\\u00a0       Patterns::Bool(),\\n\\u00a0       \\\"Whether the solution should be used as a starting guess \\\"\\n\\u00a0       \\\"for the next finer mesh. If false, then the iteration starts at \\\"\\n\\u00a0       \\\"zero on every mesh.\\\");\\n\\u00a0     prm.declare_entry(\\\"base mesh\\\",\\n\\u00a0                       \\\"box\\\",\\n\\u00a0                       Patterns::Selection(\\\"box|half sphere\\\"),\\n\\u00a0                       \\\"Select the shape of the domain: 'box' or 'half sphere'\\\");\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nParameterHandler::declare_entryvoid declare_entry(const std::string &entry, const std::string &default_value, const Patterns::PatternBase &pattern=Patterns::Anything(), const std::string &documentation=\\\"\\\", const bool has_to_be_set=false)Definition parameter_handler.cc:846\\nPatterns::AnythingDefinition patterns.h:1021\\nPatterns::BoolDefinition patterns.h:980\\nPatterns::IntegerDefinition patterns.h:188\\nPatterns::SelectionDefinition patterns.h:381\\n The PlasticityContactProblem constructor\\nGiven the declarations of member variables as well as the declarations of run-time parameters that are read from the input file, there is nothing surprising in this constructor. In the body we initialize the mesh refinement strategy and the output directory, creating such a directory if necessary.\\n\\u00a0   template <int dim>\\n\\u00a0   PlasticityContactProblem<dim>::PlasticityContactProblem(\\n\\u00a0     const ParameterHandler &prm)\\n\\u00a0     : mpi_communicator(MPI_COMM_WORLD)\\n\\u00a0     , pcout(std::cout,\\n\\u00a0             (Utilities::MPI::this_mpi_process(mpi_communicator) == 0))\\n\\u00a0     , computing_timer(MPI_COMM_WORLD,\\n\\u00a0                       pcout,\\n\\u00a0                       TimerOutput::never,\\n\\u00a0                       TimerOutput::wall_times)\\n\\u00a0 \\n\\u00a0     , n_initial_global_refinements(\\n\\u00a0         prm.get_integer(\\\"number of initial refinements\\\"))\\n\\u00a0     , triangulation(mpi_communicator)\\n\\u00a0     , fe_degree(prm.get_integer(\\\"polynomial degree\\\"))\\n\\u00a0     , fe(FE_Q<dim>(QGaussLobatto<1>(fe_degree + 1)) ^ dim)\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0 \\n\\u00a0     , e_modulus(200000)\\n\\u00a0     , nu(0.3)\\n\\u00a0     , gamma(0.01)\\n\\u00a0     , sigma_0(400.0)\\n\\u00a0     , constitutive_law(e_modulus, nu, sigma_0, gamma)\\n\\u00a0 \\n\\u00a0     , base_mesh(prm.get(\\\"base mesh\\\"))\\n\\u00a0     , obstacle(prm.get(\\\"obstacle\\\") == \\\"read from file\\\" ?\\n\\u00a0                  static_cast<const Function<dim> *>(\\n\\u00a0                    new EquationData::ChineseObstacle<dim>(\\n\\u00a0                      \\\"obstacle.pbm\\\",\\n\\u00a0                      (base_mesh == \\\"box\\\" ? 1.0 : 0.5))) :\\n\\u00a0                  static_cast<const Function<dim> *>(\\n\\u00a0                    new EquationData::SphereObstacle<dim>(\\n\\u00a0                      base_mesh == \\\"box\\\" ? 1.0 : 0.5)))\\n\\u00a0 \\n\\u00a0     , transfer_solution(prm.get_bool(\\\"transfer solution\\\"))\\n\\u00a0     , n_refinement_cycles(prm.get_integer(\\\"number of cycles\\\"))\\n\\u00a0     , current_refinement_cycle(0)\\n\\u00a0 \\n\\u00a0   {\\n\\u00a0     std::string strat = prm.get(\\\"refinement strategy\\\");\\n\\u00a0     if (strat == \\\"global\\\")\\n\\u00a0       refinement_strategy = RefinementStrategy::refine_global;\\n\\u00a0     else if (strat == \\\"percentage\\\")\\n\\u00a0       refinement_strategy = RefinementStrategy::refine_percentage;\\n\\u00a0     else\\n\\u00a0       AssertThrow(false, ExcNotImplemented());\\n\\u00a0 \\n\\u00a0     output_dir = prm.get(\\\"output directory\\\");\\n\\u00a0     if (output_dir != \\\"\\\" && *(output_dir.rbegin()) != '/')\\n\\u00a0       output_dir += \\\"/\\\";\\n\\u00a0 \\nFE_QDefinition fe_q.h:554\\nQGaussLobattoDefinition quadrature_lib.h:140\\nInitializeLibrary::MPI@ MPI\\nUtilitiesDefinition communication_pattern_base.h:30\\nIf necessary, create a new directory for the output.\\n\\u00a0     if (Utilities::MPI::this_mpi_process(mpi_communicator) == 0)\\n\\u00a0       {\\n\\u00a0         const int ierr = mkdir(output_dir.c_str(), 0777);\\n\\u00a0         AssertThrow(ierr == 0 || errno == EEXIST, ExcIO());\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     pcout << \\\"    Using output directory '\\\" << output_dir << \\\"'\\\" << std::endl;\\n\\u00a0     pcout << \\\"    FE degree \\\" << fe_degree << std::endl;\\n\\u00a0     pcout << \\\"    transfer solution \\\" << (transfer_solution ? \\\"true\\\" : \\\"false\\\")\\n\\u00a0           << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n PlasticityContactProblem::make_grid\\nThe next block deals with constructing the starting mesh. We will use the following helper function and the first block of the make_grid() to construct a mesh that corresponds to a half sphere. deal.II has a function that creates such a mesh, but it is in the wrong location and facing the wrong direction, so we need to shift and rotate it a bit before using it.\\nFor later reference, as described in the documentation of GridGenerator::half_hyper_ball(), the flat surface of the halfsphere has boundary indicator zero, while the remainder has boundary indicator one.\\n\\u00a0   Point<3> rotate_half_sphere(const Point<3> &in)\\n\\u00a0   {\\n\\u00a0     return {in[2], in[1], -in[0]};\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void PlasticityContactProblem<dim>::make_grid()\\n\\u00a0   {\\n\\u00a0     if (base_mesh == \\\"half sphere\\\")\\n\\u00a0       {\\n\\u00a0         const Point<dim> center(0, 0, 0);\\n\\u00a0         const double     radius = 0.8;\\n\\u00a0         GridGenerator::half_hyper_ball(triangulation, center, radius);\\ncenterPoint< 3 > centerDefinition data_out_base.cc:267\\nGridGenerator::half_hyper_ballvoid half_hyper_ball(Triangulation< dim > &tria, const Point< dim > &center=Point< dim >(), const double radius=1.)\\nSince we will attach a different manifold below, we immediately clear the default manifold description:\\n\\u00a0         triangulation.reset_all_manifolds();\\n\\u00a0 \\n\\u00a0         GridTools::transform(&rotate_half_sphere, triangulation);\\n\\u00a0         GridTools::shift(Point<dim>(0.5, 0.5, 0.5), triangulation);\\n\\u00a0 \\n\\u00a0         SphericalManifold<dim> manifold_description(Point<dim>(0.5, 0.5, 0.5));\\n\\u00a0         GridTools::copy_boundary_to_manifold_id(triangulation);\\n\\u00a0         triangulation.set_manifold(0, manifold_description);\\n\\u00a0       }\\nSphericalManifoldDefinition manifold_lib.h:263\\nGridTools::copy_boundary_to_manifold_idvoid copy_boundary_to_manifold_id(Triangulation< dim, spacedim > &tria, const bool reset_boundary_ids=false)Definition grid_tools.cc:2801\\nTriangulation::set_manifoldvoid set_manifold(const types::manifold_id number, const Manifold< dim, spacedim > &manifold_object)\\nTriangulation::reset_all_manifoldsvoid reset_all_manifolds()\\nGridTools::transformvoid transform(const Transformation &transformation, Triangulation< dim, spacedim > &triangulation)\\nGridTools::shiftvoid shift(const Tensor< 1, spacedim > &shift_vector, Triangulation< dim, spacedim > &triangulation)Definition grid_tools.cc:190\\nAlternatively, create a hypercube mesh. After creating it, assign boundary indicators as follows:  >     _______\\n>    /  1    /|\\n>   /______ / |\\n>  |       | 8|\\n>  |   8   | /\\n>  |_______|/\\n>      6\\n  In other words, the boundary indicators of the sides of the cube are 8. The boundary indicator of the bottom is 6 and the top has indicator 1. We set these by looping over all cells of all faces and looking at coordinate values of the cell center, and will make use of these indicators later when evaluating which boundary will carry Dirichlet boundary conditions or will be subject to potential contact. (In the current case, the mesh contains only a single cell, and all of its faces are on the boundary, so both the loop over all cells and the query whether a face is on the boundary are, strictly speaking, unnecessary; we retain them simply out of habit: this kind of code can be found in many programs in essentially this form.)\\n\\u00a0     else\\n\\u00a0       {\\n\\u00a0         const Point<dim> p1(0, 0, 0);\\n\\u00a0         const Point<dim> p2(1.0, 1.0, 1.0);\\n\\u00a0 \\n\\u00a0         GridGenerator::hyper_rectangle(triangulation, p1, p2);\\n\\u00a0 \\n\\u00a0         for (const auto &cell : triangulation.active_cell_iterators())\\n\\u00a0           for (const auto &face : cell->face_iterators())\\n\\u00a0             if (face->at_boundary())\\n\\u00a0               {\\n\\u00a0                 if (std::fabs(face->center()[2] - p2[2]) < 1e-12)\\n\\u00a0                   face->set_boundary_id(1);\\n\\u00a0                 if (std::fabs(face->center()[0] - p1[0]) < 1e-12 ||\\n\\u00a0                     std::fabs(face->center()[0] - p2[0]) < 1e-12 ||\\n\\u00a0                     std::fabs(face->center()[1] - p1[1]) < 1e-12 ||\\n\\u00a0                     std::fabs(face->center()[1] - p2[1]) < 1e-12)\\n\\u00a0                   face->set_boundary_id(8);\\n\\u00a0                 if (std::fabs(face->center()[2] - p1[2]) < 1e-12)\\n\\u00a0                   face->set_boundary_id(6);\\n\\u00a0               }\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     triangulation.refine_global(n_initial_global_refinements);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nGridGenerator::hyper_rectanglevoid hyper_rectangle(Triangulation< dim, spacedim > &tria, const Point< dim > &p1, const Point< dim > &p2, const bool colorize=false)\\n PlasticityContactProblem::setup_system\\nThe next piece in the puzzle is to set up the DoFHandler, resize vectors and take care of various other status variables such as index sets and constraint matrices.\\nIn the following, each group of operations is put into a brace-enclosed block that is being timed by the variable declared at the top of the block (the constructor of the TimerOutput::Scope variable starts the timed section, the destructor that is called at the end of the block stops it again).\\n\\u00a0   template <int dim>\\n\\u00a0   void PlasticityContactProblem<dim>::setup_system()\\n\\u00a0   {\\n\\u00a0     /* setup dofs and get index sets for locally owned and relevant dofs */\\n\\u00a0     {\\n\\u00a0       TimerOutput::Scope t(computing_timer, \\\"Setup: distribute DoFs\\\");\\n\\u00a0       dof_handler.distribute_dofs(fe);\\n\\u00a0 \\n\\u00a0       locally_owned_dofs = dof_handler.locally_owned_dofs();\\n\\u00a0       locally_relevant_dofs =\\n\\u00a0         DoFTools::extract_locally_relevant_dofs(dof_handler);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     /* setup hanging nodes and Dirichlet constraints */\\n\\u00a0     {\\n\\u00a0       TimerOutput::Scope t(computing_timer, \\\"Setup: constraints\\\");\\n\\u00a0       constraints_hanging_nodes.reinit(locally_owned_dofs,\\n\\u00a0                                        locally_relevant_dofs);\\n\\u00a0       DoFTools::make_hanging_node_constraints(dof_handler,\\n\\u00a0                                               constraints_hanging_nodes);\\n\\u00a0       constraints_hanging_nodes.close();\\n\\u00a0 \\n\\u00a0       pcout << \\\"   Number of active cells: \\\"\\n\\u00a0             << triangulation.n_global_active_cells() << std::endl\\n\\u00a0             << \\\"   Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n\\u00a0             << std::endl;\\n\\u00a0 \\n\\u00a0       compute_dirichlet_constraints();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     /* initialization of vectors and the active set */\\n\\u00a0     {\\n\\u00a0       TimerOutput::Scope t(computing_timer, \\\"Setup: vectors\\\");\\n\\u00a0       solution.reinit(locally_relevant_dofs, mpi_communicator);\\n\\u00a0       newton_rhs.reinit(locally_owned_dofs, mpi_communicator);\\n\\u00a0       newton_rhs_uncondensed.reinit(locally_owned_dofs, mpi_communicator);\\n\\u00a0       diag_mass_matrix_vector.reinit(locally_owned_dofs, mpi_communicator);\\n\\u00a0       fraction_of_plastic_q_points_per_cell.reinit(\\n\\u00a0         triangulation.n_active_cells());\\n\\u00a0 \\n\\u00a0       active_set.clear();\\n\\u00a0       active_set.set_size(dof_handler.n_dofs());\\n\\u00a0     }\\n\\u00a0 \\nTimerOutput::ScopeDefinition timer.h:557\\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nparallel::TriangulationBase::n_global_active_cellsvirtual types::global_cell_index n_global_active_cells() const overrideDefinition tria_base.cc:151\\nDoFTools::make_hanging_node_constraintsvoid make_hanging_node_constraints(const DoFHandler< dim, spacedim > &dof_handler, AffineConstraints< number > &constraints)Definition dof_tools_constraints.cc:3073\\nDoFTools::extract_locally_relevant_dofsIndexSet extract_locally_relevant_dofs(const DoFHandler< dim, spacedim > &dof_handler)Definition dof_tools.cc:1164\\nFinally, we set up sparsity patterns and matrices. We temporarily (ab)use the system matrix to also build the (diagonal) matrix that we use in eliminating degrees of freedom that are in contact with the obstacle, but we then immediately set the Newton matrix back to zero.\\n\\u00a0     {\\n\\u00a0       TimerOutput::Scope                t(computing_timer, \\\"Setup: matrix\\\");\\n\\u00a0       TrilinosWrappers::SparsityPattern sp(locally_owned_dofs,\\n\\u00a0                                            mpi_communicator);\\n\\u00a0 \\n\\u00a0       DoFTools::make_sparsity_pattern(dof_handler,\\n\\u00a0                                       sp,\\n\\u00a0                                       constraints_dirichlet_and_hanging_nodes,\\n\\u00a0                                       false,\\n\\u00a0                                       Utilities::MPI::this_mpi_process(\\n\\u00a0                                         mpi_communicator));\\n\\u00a0       sp.compress();\\n\\u00a0       newton_matrix.reinit(sp);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0       TrilinosWrappers::SparseMatrix &mass_matrix = newton_matrix;\\n\\u00a0 \\n\\u00a0       assemble_mass_matrix_diagonal(mass_matrix);\\n\\u00a0 \\n\\u00a0       const unsigned int start = (newton_rhs.local_range().first),\\n\\u00a0                          end   = (newton_rhs.local_range().second);\\n\\u00a0       for (unsigned int j = start; j < end; ++j)\\n\\u00a0         diag_mass_matrix_vector(j) = mass_matrix.diag_element(j);\\n\\u00a0       diag_mass_matrix_vector.compress(VectorOperation::insert);\\n\\u00a0 \\n\\u00a0       mass_matrix = 0;\\n\\u00a0     }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nTrilinosWrappers::SparsityPatternDefinition trilinos_sparsity_pattern.h:275\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nVectorOperation::insert@ insertDefinition vector_operation.h:49\\n PlasticityContactProblem::compute_dirichlet_constraints\\nThis function, broken out of the preceding one, computes the constraints associated with Dirichlet-type boundary conditions and puts them into the constraints_dirichlet_and_hanging_nodes variable by merging with the constraints that come from hanging nodes.\\nAs laid out in the introduction, we need to distinguish between two cases:\\nIf the domain is a box, we set the displacement to zero at the bottom, and allow vertical movement in z-direction along the sides. As shown in the make_grid() function, the former corresponds to boundary indicator 6, the latter to 8.\\nIf the domain is a half sphere, then we impose zero displacement along the curved part of the boundary, associated with boundary indicator zero.\\n\\n\\u00a0   template <int dim>\\n\\u00a0   void PlasticityContactProblem<dim>::compute_dirichlet_constraints()\\n\\u00a0   {\\n\\u00a0     constraints_dirichlet_and_hanging_nodes.reinit(locally_owned_dofs,\\n\\u00a0                                                    locally_relevant_dofs);\\n\\u00a0     constraints_dirichlet_and_hanging_nodes.merge(constraints_hanging_nodes);\\n\\u00a0 \\n\\u00a0     if (base_mesh == \\\"box\\\")\\n\\u00a0       {\\ninterpolate all components of the solution\\n\\u00a0         VectorTools::interpolate_boundary_values(\\n\\u00a0           dof_handler,\\n\\u00a0           6,\\n\\u00a0           EquationData::BoundaryValues<dim>(),\\n\\u00a0           constraints_dirichlet_and_hanging_nodes,\\n\\u00a0           ComponentMask());\\n\\u00a0 \\nComponentMaskDefinition component_mask.h:81\\nVectorTools::interpolate_boundary_valuesvoid interpolate_boundary_values(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const std::map< types::boundary_id, const Function< spacedim, number > * > &function_map, std::map< types::global_dof_index, number > &boundary_values, const ComponentMask &component_mask={})\\ninterpolate x- and y-components of the solution (this is a bit mask, so apply operator| )\\n\\u00a0         const FEValuesExtractors::Scalar x_displacement(0);\\n\\u00a0         const FEValuesExtractors::Scalar y_displacement(1);\\n\\u00a0         VectorTools::interpolate_boundary_values(\\n\\u00a0           dof_handler,\\n\\u00a0           8,\\n\\u00a0           EquationData::BoundaryValues<dim>(),\\n\\u00a0           constraints_dirichlet_and_hanging_nodes,\\n\\u00a0           (fe.component_mask(x_displacement) |\\n\\u00a0            fe.component_mask(y_displacement)));\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       VectorTools::interpolate_boundary_values(\\n\\u00a0         dof_handler,\\n\\u00a0         0,\\n\\u00a0         EquationData::BoundaryValues<dim>(),\\n\\u00a0         constraints_dirichlet_and_hanging_nodes,\\n\\u00a0         ComponentMask());\\n\\u00a0 \\n\\u00a0     constraints_dirichlet_and_hanging_nodes.close();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFEValuesExtractors::ScalarDefinition fe_values_extractors.h:95\\n PlasticityContactProblem::assemble_mass_matrix_diagonal\\nThe next helper function computes the (diagonal) mass matrix that is used to determine the active set of the active set method we use in the contact algorithm. This matrix is of mass matrix type, but unlike the standard mass matrix, we can make it diagonal (even in the case of higher order elements) by using a quadrature formula that has its quadrature points at exactly the same locations as the interpolation points for the finite element are located. We achieve this by using a QGaussLobatto quadrature formula here, along with initializing the finite element with a set of interpolation points derived from the same quadrature formula. The remainder of the function is relatively straightforward: we put the resulting matrix into the given argument; because we know the matrix is diagonal, it is sufficient to have a loop over only \\\\(i\\\\) and not over \\\\(j\\\\). Strictly speaking, we could even avoid multiplying the shape function's values at quadrature point q_point by itself because we know the shape value to be a vector with exactly one one which when dotted with itself yields one. Since this function is not time critical we add this term for clarity.\\n\\u00a0   template <int dim>\\n\\u00a0   void PlasticityContactProblem<dim>::assemble_mass_matrix_diagonal(\\n\\u00a0     TrilinosWrappers::SparseMatrix &mass_matrix)\\n\\u00a0   {\\n\\u00a0     const QGaussLobatto<dim - 1> face_quadrature_formula(fe.degree + 1);\\n\\u00a0 \\n\\u00a0     FEFaceValues<dim> fe_values_face(fe,\\n\\u00a0                                      face_quadrature_formula,\\n\\u00a0                                      update_values | update_JxW_values);\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell   = fe.n_dofs_per_cell();\\n\\u00a0     const unsigned int n_face_q_points = face_quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     const FEValuesExtractors::Vector displacement(0);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       if (cell->is_locally_owned())\\n\\u00a0         for (const auto &face : cell->face_iterators())\\n\\u00a0           if (face->at_boundary() && face->boundary_id() == 1)\\n\\u00a0             {\\n\\u00a0               fe_values_face.reinit(cell, face);\\n\\u00a0               cell_matrix = 0;\\n\\u00a0 \\n\\u00a0               for (unsigned int q_point = 0; q_point < n_face_q_points;\\n\\u00a0                    ++q_point)\\n\\u00a0                 for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0                   cell_matrix(i, i) +=\\n\\u00a0                     (fe_values_face[displacement].value(i, q_point) *\\n\\u00a0                      fe_values_face[displacement].value(i, q_point) *\\n\\u00a0                      fe_values_face.JxW(q_point));\\n\\u00a0 \\n\\u00a0               cell->get_dof_indices(local_dof_indices);\\n\\u00a0 \\n\\u00a0               for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0                 mass_matrix.add(local_dof_indices[i],\\n\\u00a0                                 local_dof_indices[i],\\n\\u00a0                                 cell_matrix(i, i));\\n\\u00a0             }\\n\\u00a0     mass_matrix.compress(VectorOperation::add);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nFEFaceValuesDefinition fe_values.h:322\\nFullMatrixDefinition full_matrix.h:79\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nFEValuesExtractors::VectorDefinition fe_values_extractors.h:150\\nVectorOperation::add@ addDefinition vector_operation.h:53\\n PlasticityContactProblem::update_solution_and_constraints\\nThe following function is the first function we call in each Newton iteration in the solve_newton() function. What it does is to project the solution onto the feasible set and update the active set for the degrees of freedom that touch or penetrate the obstacle.\\nIn order to function, we first need to do some bookkeeping: We need to write into the solution vector (which we can only do with fully distributed vectors without ghost elements) and we need to read the Lagrange multiplier and the elements of the diagonal mass matrix from their respective vectors (which we can only do with vectors that do have ghost elements), so we create the respective vectors. We then also initialize the constraints object that will contain constraints from contact and all other sources, as well as an object that contains an index set of all locally owned degrees of freedom that are part of the contact:\\n\\u00a0   template <int dim>\\n\\u00a0   void PlasticityContactProblem<dim>::update_solution_and_constraints()\\n\\u00a0   {\\n\\u00a0     std::vector<bool> dof_touched(dof_handler.n_dofs(), false);\\n\\u00a0 \\n\\u00a0     TrilinosWrappers::MPI::Vector distributed_solution(locally_owned_dofs,\\n\\u00a0                                                        mpi_communicator);\\n\\u00a0     distributed_solution = solution;\\n\\u00a0 \\n\\u00a0     TrilinosWrappers::MPI::Vector lambda(locally_relevant_dofs,\\n\\u00a0                                          mpi_communicator);\\n\\u00a0     lambda = newton_rhs_uncondensed;\\n\\u00a0 \\n\\u00a0     TrilinosWrappers::MPI::Vector diag_mass_matrix_vector_relevant(\\n\\u00a0       locally_relevant_dofs, mpi_communicator);\\n\\u00a0     diag_mass_matrix_vector_relevant = diag_mass_matrix_vector;\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     all_constraints.reinit(locally_owned_dofs, locally_relevant_dofs);\\n\\u00a0     active_set.clear();\\n\\u00a0 \\nThe second part is a loop over all cells in which we look at each point where a degree of freedom is defined whether the active set condition is true and we need to add this degree of freedom to the active set of contact nodes. As we always do, if we want to evaluate functions at individual points, we do this with an FEValues object (or, here, an FEFaceValues object since we need to check contact at the surface) with an appropriately chosen quadrature object. We create this face quadrature object by choosing the \\\"support points\\\" of the shape functions defined on the faces of cells (for more on support points, see this glossary entry). As a consequence, we have as many quadrature points as there are shape functions per face and looping over quadrature points is equivalent to looping over shape functions defined on a face. With this, the code looks as follows:\\n\\u00a0     const Quadrature<dim - 1> face_quadrature(\\n\\u00a0       fe.get_unit_face_support_points());\\n\\u00a0     FEFaceValues<dim> fe_values_face(fe,\\n\\u00a0                                      face_quadrature,\\n\\u00a0                                      update_quadrature_points);\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_face   = fe.n_dofs_per_face();\\n\\u00a0     const unsigned int n_face_q_points = face_quadrature.size();\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> dof_indices(dofs_per_face);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       if (!cell->is_artificial())\\n\\u00a0         for (const auto &face : cell->face_iterators())\\n\\u00a0           if (face->at_boundary() && face->boundary_id() == 1)\\n\\u00a0             {\\n\\u00a0               fe_values_face.reinit(cell, face);\\n\\u00a0               face->get_dof_indices(dof_indices);\\n\\u00a0 \\n\\u00a0               for (unsigned int q_point = 0; q_point < n_face_q_points;\\n\\u00a0                    ++q_point)\\n\\u00a0                 {\\nQuadratureDefinition quadrature.h:123\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nAt each quadrature point (i.e., at each support point of a degree of freedom located on the contact boundary), we then ask whether it is part of the z-displacement degrees of freedom and if we haven't encountered this degree of freedom yet (which can happen for those on the edges between faces), we need to evaluate the gap between the deformed object and the obstacle. If the active set condition is true, then we add a constraint to the AffineConstraints object that the next Newton update needs to satisfy, set the solution vector's corresponding element to the correct value, and add the index to the IndexSet object that stores which degree of freedom is part of the contact:\\n\\u00a0                   const unsigned int component =\\n\\u00a0                     fe.face_system_to_component_index(q_point).first;\\n\\u00a0 \\n\\u00a0                   const unsigned int index_z = dof_indices[q_point];\\n\\u00a0 \\n\\u00a0                   if ((component == 2) && (dof_touched[index_z] == false))\\n\\u00a0                     {\\n\\u00a0                       dof_touched[index_z] = true;\\n\\u00a0 \\n\\u00a0                       const Point<dim> this_support_point =\\n\\u00a0                         fe_values_face.quadrature_point(q_point);\\n\\u00a0 \\n\\u00a0                       const double obstacle_value =\\n\\u00a0                         obstacle->value(this_support_point, 2);\\n\\u00a0                       const double solution_here = solution(index_z);\\n\\u00a0                       const double undeformed_gap =\\n\\u00a0                         obstacle_value - this_support_point[2];\\n\\u00a0 \\n\\u00a0                       const double c = 100.0 * e_modulus;\\n\\u00a0                       if ((lambda(index_z) /\\n\\u00a0                                diag_mass_matrix_vector_relevant(index_z) +\\n\\u00a0                              c * (solution_here - undeformed_gap) >\\n\\u00a0                            0) &&\\n\\u00a0                           !constraints_hanging_nodes.is_constrained(index_z))\\n\\u00a0                         {\\n\\u00a0                           all_constraints.add_constraint(index_z,\\n\\u00a0                                                          {},\\n\\u00a0                                                          undeformed_gap);\\n\\u00a0                           distributed_solution(index_z) = undeformed_gap;\\n\\u00a0 \\n\\u00a0                           active_set.add_index(index_z);\\n\\u00a0                         }\\n\\u00a0                     }\\n\\u00a0                 }\\n\\u00a0             }\\n\\u00a0 \\nAt the end of this function, we exchange data between processors updating those ghost elements in the solution variable that have been written by other processors. We then merge the Dirichlet constraints and those from hanging nodes into the AffineConstraints object that already contains the active set. We finish the function by outputting the total number of actively constrained degrees of freedom for which we sum over the number of actively constrained degrees of freedom owned by each of the processors. This number of locally owned constrained degrees of freedom is of course the number of elements of the intersection of the active set and the set of locally owned degrees of freedom, which we can get by using operator& on two IndexSets:\\n\\u00a0     distributed_solution.compress(VectorOperation::insert);\\n\\u00a0     solution = distributed_solution;\\n\\u00a0 \\n\\u00a0     all_constraints.close();\\n\\u00a0     all_constraints.merge(constraints_dirichlet_and_hanging_nodes);\\n\\u00a0 \\n\\u00a0     pcout << \\\"         Size of active set: \\\"\\n\\u00a0           << Utilities::MPI::sum((active_set & locally_owned_dofs).n_elements(),\\n\\u00a0                                  mpi_communicator)\\n\\u00a0           << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nUtilities::MPI::sumT sum(const T &t, const MPI_Comm mpi_communicator)\\n PlasticityContactProblem::assemble_newton_system\\nGiven the complexity of the problem, it may come as a bit of a surprise that assembling the linear system we have to solve in each Newton iteration is actually fairly straightforward. The following function builds the Newton right hand side and Newton matrix. It looks fairly innocent because the heavy lifting happens in the call to ConstitutiveLaw::get_linearized_stress_strain_tensors() and in particular in AffineConstraints::distribute_local_to_global(), using the constraints we have previously computed.\\n\\u00a0   template <int dim>\\n\\u00a0   void PlasticityContactProblem<dim>::assemble_newton_system(\\n\\u00a0     const TrilinosWrappers::MPI::Vector &linearization_point)\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope t(computing_timer, \\\"Assembling\\\");\\n\\u00a0 \\n\\u00a0     const QGauss<dim>     quadrature_formula(fe.degree + 1);\\n\\u00a0     const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);\\n\\u00a0 \\n\\u00a0     FEValues<dim> fe_values(fe,\\n\\u00a0                             quadrature_formula,\\n\\u00a0                             update_values | update_gradients |\\n\\u00a0                               update_JxW_values);\\n\\u00a0 \\n\\u00a0     FEFaceValues<dim> fe_values_face(fe,\\n\\u00a0                                      face_quadrature_formula,\\n\\u00a0                                      update_values | update_quadrature_points |\\n\\u00a0                                        update_JxW_values);\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell   = fe.n_dofs_per_cell();\\n\\u00a0     const unsigned int n_q_points      = quadrature_formula.size();\\n\\u00a0     const unsigned int n_face_q_points = face_quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     const EquationData::BoundaryForce<dim> boundary_force;\\n\\u00a0     std::vector<Vector<double>> boundary_force_values(n_face_q_points,\\n\\u00a0                                                       Vector<double>(dim));\\n\\u00a0 \\n\\u00a0     FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0     Vector<double>     cell_rhs(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     const FEValuesExtractors::Vector displacement(0);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       if (cell->is_locally_owned())\\n\\u00a0         {\\n\\u00a0           fe_values.reinit(cell);\\n\\u00a0           cell_matrix = 0;\\n\\u00a0           cell_rhs    = 0;\\n\\u00a0 \\n\\u00a0           std::vector<SymmetricTensor<2, dim>> strain_tensor(n_q_points);\\n\\u00a0           fe_values[displacement].get_function_symmetric_gradients(\\n\\u00a0             linearization_point, strain_tensor);\\n\\u00a0 \\n\\u00a0           for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n\\u00a0             {\\n\\u00a0               SymmetricTensor<4, dim> stress_strain_tensor_linearized;\\n\\u00a0               SymmetricTensor<4, dim> stress_strain_tensor;\\n\\u00a0               constitutive_law.get_linearized_stress_strain_tensors(\\n\\u00a0                 strain_tensor[q_point],\\n\\u00a0                 stress_strain_tensor_linearized,\\n\\u00a0                 stress_strain_tensor);\\n\\u00a0 \\n\\u00a0               for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0                 {\\nFEValuesDefinition fe_values.h:63\\nQGaussDefinition quadrature_lib.h:40\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nHaving computed the stress-strain tensor and its linearization, we can now put together the parts of the matrix and right hand side. In both, we need the linearized stress-strain tensor times the symmetric gradient of \\\\(\\\\varphi_i\\\\), i.e. the term \\\\(I_\\\\Pi\\\\varepsilon(\\\\varphi_i)\\\\), so we introduce an abbreviation of this term. Recall that the matrix corresponds to the bilinear form \\\\(A_{ij}=(I_\\\\Pi\\\\varepsilon(\\\\varphi_i),\\\\varepsilon(\\\\varphi_j))\\\\) in the notation of the accompanying publication, whereas the right hand side is  \\\\(F_i=([I_\\\\Pi-P_\\\\Pi\\n   C]\\\\varepsilon(\\\\varphi_i),\\\\varepsilon(\\\\mathbf u))\\\\) where \\\\(u\\\\) is the current linearization points (typically the last solution). This might suggest that the right hand side will be zero if the material is completely elastic (where \\\\(I_\\\\Pi=P_\\\\Pi\\\\)) but this ignores the fact that the right hand side will also contain contributions from non-homogeneous constraints due to the contact.\\nThe code block that follows this adds contributions that are due to boundary forces, should there be any.\\n\\u00a0                   const SymmetricTensor<2, dim> stress_phi_i =\\n\\u00a0                     stress_strain_tensor_linearized *\\n\\u00a0                     fe_values[displacement].symmetric_gradient(i, q_point);\\n\\u00a0 \\n\\u00a0                   for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0                     cell_matrix(i, j) +=\\n\\u00a0                       (stress_phi_i *\\n\\u00a0                        fe_values[displacement].symmetric_gradient(j, q_point) *\\n\\u00a0                        fe_values.JxW(q_point));\\n\\u00a0 \\n\\u00a0                   cell_rhs(i) +=\\n\\u00a0                     ((stress_phi_i -\\n\\u00a0                       stress_strain_tensor *\\n\\u00a0                         fe_values[displacement].symmetric_gradient(i,\\n\\u00a0                                                                    q_point)) *\\n\\u00a0                      strain_tensor[q_point] * fe_values.JxW(q_point));\\n\\u00a0                 }\\n\\u00a0             }\\n\\u00a0 \\n\\u00a0           for (const auto &face : cell->face_iterators())\\n\\u00a0             if (face->at_boundary() && face->boundary_id() == 1)\\n\\u00a0               {\\n\\u00a0                 fe_values_face.reinit(cell, face);\\n\\u00a0 \\n\\u00a0                 boundary_force.vector_value_list(\\n\\u00a0                   fe_values_face.get_quadrature_points(),\\n\\u00a0                   boundary_force_values);\\n\\u00a0 \\n\\u00a0                 for (unsigned int q_point = 0; q_point < n_face_q_points;\\n\\u00a0                      ++q_point)\\n\\u00a0                   {\\n\\u00a0                     Tensor<1, dim> rhs_values;\\n\\u00a0                     rhs_values[2] = boundary_force_values[q_point][2];\\n\\u00a0                     for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0                       cell_rhs(i) +=\\n\\u00a0                         (fe_values_face[displacement].value(i, q_point) *\\n\\u00a0                          rhs_values * fe_values_face.JxW(q_point));\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0           cell->get_dof_indices(local_dof_indices);\\n\\u00a0           all_constraints.distribute_local_to_global(cell_matrix,\\n\\u00a0                                                      cell_rhs,\\n\\u00a0                                                      local_dof_indices,\\n\\u00a0                                                      newton_matrix,\\n\\u00a0                                                      newton_rhs,\\n\\u00a0                                                      true);\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0     newton_matrix.compress(VectorOperation::add);\\n\\u00a0     newton_rhs.compress(VectorOperation::add);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nTensorDefinition tensor.h:471\\ninternal::reinitvoid reinit(MatrixBlock< MatrixType > &v, const BlockSparsityPattern &p)Definition matrix_block.h:617\\ntypes::boundary_idunsigned int boundary_idDefinition types.h:144\\n PlasticityContactProblem::compute_nonlinear_residual\\nThe following function computes the nonlinear residual of the equation given the current solution (or any other linearization point). This is needed in the linear search algorithm where we need to try various linear combinations of previous and current (trial) solution to compute the (real, globalized) solution of the current Newton step.\\nThat said, in a slight abuse of the name of the function, it actually does significantly more. For example, it also computes the vector that corresponds to the Newton residual but without eliminating constrained degrees of freedom. We need this vector to compute contact forces and, ultimately, to compute the next active set. Likewise, by keeping track of how many quadrature points we encounter on each cell that show plastic yielding, we also compute the fraction_of_plastic_q_points_per_cell vector that we can later output to visualize the plastic zone. In both of these cases, the results are not necessary as part of the line search, and so we may be wasting a small amount of time computing them. At the same time, this information appears as a natural by-product of what we need to do here anyway, and we want to collect it once at the end of each Newton step, so we may as well do it here.\\nThe actual implementation of this function should be rather obvious:\\n\\u00a0   template <int dim>\\n\\u00a0   void PlasticityContactProblem<dim>::compute_nonlinear_residual(\\n\\u00a0     const TrilinosWrappers::MPI::Vector &linearization_point)\\n\\u00a0   {\\n\\u00a0     const QGauss<dim>     quadrature_formula(fe.degree + 1);\\n\\u00a0     const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);\\n\\u00a0 \\n\\u00a0     FEValues<dim> fe_values(fe,\\n\\u00a0                             quadrature_formula,\\n\\u00a0                             update_values | update_gradients |\\n\\u00a0                               update_JxW_values);\\n\\u00a0 \\n\\u00a0     FEFaceValues<dim> fe_values_face(fe,\\n\\u00a0                                      face_quadrature_formula,\\n\\u00a0                                      update_values | update_quadrature_points |\\n\\u00a0                                        update_JxW_values);\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell   = fe.n_dofs_per_cell();\\n\\u00a0     const unsigned int n_q_points      = quadrature_formula.size();\\n\\u00a0     const unsigned int n_face_q_points = face_quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     const EquationData::BoundaryForce<dim> boundary_force;\\n\\u00a0     std::vector<Vector<double>> boundary_force_values(n_face_q_points,\\n\\u00a0                                                       Vector<double>(dim));\\n\\u00a0 \\n\\u00a0     Vector<double> cell_rhs(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     const FEValuesExtractors::Vector displacement(0);\\n\\u00a0 \\n\\u00a0     newton_rhs             = 0;\\n\\u00a0     newton_rhs_uncondensed = 0;\\n\\u00a0 \\n\\u00a0     fraction_of_plastic_q_points_per_cell = 0;\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       if (cell->is_locally_owned())\\n\\u00a0         {\\n\\u00a0           fe_values.reinit(cell);\\n\\u00a0           cell_rhs = 0;\\n\\u00a0 \\n\\u00a0           std::vector<SymmetricTensor<2, dim>> strain_tensors(n_q_points);\\n\\u00a0           fe_values[displacement].get_function_symmetric_gradients(\\n\\u00a0             linearization_point, strain_tensors);\\n\\u00a0 \\n\\u00a0           for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n\\u00a0             {\\n\\u00a0               SymmetricTensor<4, dim> stress_strain_tensor;\\n\\u00a0               const bool              q_point_is_plastic =\\n\\u00a0                 constitutive_law.get_stress_strain_tensor(\\n\\u00a0                   strain_tensors[q_point], stress_strain_tensor);\\n\\u00a0               if (q_point_is_plastic)\\n\\u00a0                 ++fraction_of_plastic_q_points_per_cell(\\n\\u00a0                   cell->active_cell_index());\\n\\u00a0 \\n\\u00a0               for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0                 {\\n\\u00a0                   cell_rhs(i) -=\\n\\u00a0                     (strain_tensors[q_point] * stress_strain_tensor *\\n\\u00a0                      fe_values[displacement].symmetric_gradient(i, q_point) *\\n\\u00a0                      fe_values.JxW(q_point));\\n\\u00a0 \\n\\u00a0                   Tensor<1, dim> rhs_values;\\n\\u00a0                   rhs_values = 0;\\n\\u00a0                   cell_rhs(i) += (fe_values[displacement].value(i, q_point) *\\n\\u00a0                                   rhs_values * fe_values.JxW(q_point));\\n\\u00a0                 }\\n\\u00a0             }\\n\\u00a0 \\n\\u00a0           for (const auto &face : cell->face_iterators())\\n\\u00a0             if (face->at_boundary() && face->boundary_id() == 1)\\n\\u00a0               {\\n\\u00a0                 fe_values_face.reinit(cell, face);\\n\\u00a0 \\n\\u00a0                 boundary_force.vector_value_list(\\n\\u00a0                   fe_values_face.get_quadrature_points(),\\n\\u00a0                   boundary_force_values);\\n\\u00a0 \\n\\u00a0                 for (unsigned int q_point = 0; q_point < n_face_q_points;\\n\\u00a0                      ++q_point)\\n\\u00a0                   {\\n\\u00a0                     Tensor<1, dim> rhs_values;\\n\\u00a0                     rhs_values[2] = boundary_force_values[q_point][2];\\n\\u00a0                     for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0                       cell_rhs(i) +=\\n\\u00a0                         (fe_values_face[displacement].value(i, q_point) *\\n\\u00a0                          rhs_values * fe_values_face.JxW(q_point));\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0           cell->get_dof_indices(local_dof_indices);\\n\\u00a0           constraints_dirichlet_and_hanging_nodes.distribute_local_to_global(\\n\\u00a0             cell_rhs, local_dof_indices, newton_rhs);\\n\\u00a0 \\n\\u00a0           for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0             newton_rhs_uncondensed(local_dof_indices[i]) += cell_rhs(i);\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0     fraction_of_plastic_q_points_per_cell /= quadrature_formula.size();\\n\\u00a0     newton_rhs.compress(VectorOperation::add);\\n\\u00a0     newton_rhs_uncondensed.compress(VectorOperation::add);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n PlasticityContactProblem::solve_newton_system\\nThe last piece before we can discuss the actual Newton iteration on a single mesh is the solver for the linear systems. There are a couple of complications that slightly obscure the code, but mostly it is just setup then solve. Among the complications are:\\n\\nFor the hanging nodes we have to apply the AffineConstraints::set_zero function to newton_rhs. This is necessary if a hanging node with solution value \\\\(x_0\\\\) has one neighbor with value \\\\(x_1\\\\) which is in contact with the obstacle and one neighbor \\\\(x_2\\\\) which is not in contact. Because the update for the former will be prescribed, the hanging node constraint will have an inhomogeneity and will look like  \\\\(x_0 = x_1/2 +\\n   \\\\text{gap}/2\\\\). So the corresponding entries in the right-hand-side are non-zero with a meaningless value. These values we have to set to zero.\\nLike in step-40, we need to shuffle between vectors that do and do not have ghost elements when solving or using the solution.\\n\\nThe rest of the function is similar to step-40 and step-41 except that we use a BiCGStab solver instead of CG. This is due to the fact that for very small hardening parameters \\\\(\\\\gamma\\\\), the linear system becomes almost semidefinite though still symmetric. BiCGStab appears to have an easier time with such linear systems.\\n\\u00a0   template <int dim>\\n\\u00a0   void PlasticityContactProblem<dim>::solve_newton_system()\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope t(computing_timer, \\\"Solve\\\");\\n\\u00a0 \\n\\u00a0     TrilinosWrappers::MPI::Vector distributed_solution(locally_owned_dofs,\\n\\u00a0                                                        mpi_communicator);\\n\\u00a0     distributed_solution = solution;\\n\\u00a0 \\n\\u00a0     constraints_hanging_nodes.set_zero(distributed_solution);\\n\\u00a0     constraints_hanging_nodes.set_zero(newton_rhs);\\n\\u00a0 \\n\\u00a0     TrilinosWrappers::PreconditionAMG preconditioner;\\n\\u00a0     {\\n\\u00a0       TimerOutput::Scope t(computing_timer, \\\"Solve: setup preconditioner\\\");\\n\\u00a0 \\n\\u00a0       std::vector<std::vector<bool>> constant_modes;\\n\\u00a0       DoFTools::extract_constant_modes(dof_handler,\\n\\u00a0                                        ComponentMask(),\\n\\u00a0                                        constant_modes);\\n\\u00a0 \\n\\u00a0       TrilinosWrappers::PreconditionAMG::AdditionalData additional_data;\\n\\u00a0       additional_data.constant_modes        = constant_modes;\\n\\u00a0       additional_data.elliptic              = true;\\n\\u00a0       additional_data.n_cycles              = 1;\\n\\u00a0       additional_data.w_cycle               = false;\\n\\u00a0       additional_data.output_details        = false;\\n\\u00a0       additional_data.smoother_sweeps       = 2;\\n\\u00a0       additional_data.aggregation_threshold = 1e-2;\\n\\u00a0 \\n\\u00a0       preconditioner.initialize(newton_matrix, additional_data);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       TimerOutput::Scope t(computing_timer, \\\"Solve: iterate\\\");\\n\\u00a0 \\n\\u00a0       TrilinosWrappers::MPI::Vector tmp(locally_owned_dofs, mpi_communicator);\\n\\u00a0 \\n\\u00a0       const double relative_accuracy = 1e-8;\\n\\u00a0       const double solver_tolerance =\\n\\u00a0         relative_accuracy *\\n\\u00a0         newton_matrix.residual(tmp, distributed_solution, newton_rhs);\\n\\u00a0 \\n\\u00a0       SolverControl solver_control(newton_matrix.m(), solver_tolerance);\\n\\u00a0       SolverBicgstab<TrilinosWrappers::MPI::Vector> solver(solver_control);\\n\\u00a0       solver.solve(newton_matrix,\\n\\u00a0                    distributed_solution,\\n\\u00a0                    newton_rhs,\\n\\u00a0                    preconditioner);\\n\\u00a0 \\n\\u00a0       pcout << \\\"         Error: \\\" << solver_control.initial_value() << \\\" -> \\\"\\n\\u00a0             << solver_control.last_value() << \\\" in \\\"\\n\\u00a0             << solver_control.last_step() << \\\" Bicgstab iterations.\\\"\\n\\u00a0             << std::endl;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     all_constraints.distribute(distributed_solution);\\n\\u00a0 \\n\\u00a0     solution = distributed_solution;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nSolverBicgstabDefinition solver_bicgstab.h:81\\nSolverControlDefinition solver_control.h:67\\nTrilinosWrappers::PreconditionAMGDefinition trilinos_precondition.h:1321\\nDoFTools::extract_constant_modesvoid extract_constant_modes(const DoFHandler< dim, spacedim > &dof_handler, const ComponentMask &component_mask, std::vector< std::vector< bool > > &constant_modes)Definition dof_tools.cc:1416\\nTrilinosWrappers::PreconditionAMG::AdditionalDataDefinition trilinos_precondition.h:1330\\nTrilinosWrappers::PreconditionAMG::AdditionalData::constant_modesstd::vector< std::vector< bool > > constant_modesDefinition trilinos_precondition.h:1500\\n PlasticityContactProblem::solve_newton\\nThis is, finally, the function that implements the damped Newton method on the current mesh. There are two nested loops: the outer loop for the Newton iteration and the inner loop for the line search which will be used only if necessary. To obtain a good and reasonable starting value we solve an elastic problem in the very first Newton step on each mesh (or only on the first mesh if we transfer solutions between meshes). We do so by setting the yield stress to an unreasonably large value in these iterations and then setting it back to the correct value in subsequent iterations.\\nOther than this, the top part of this function should be reasonably obvious. We initialize the variable previous_residual_norm to the most negative value representable with double precision numbers so that the comparison whether the current residual is less than that of the previous step will always fail in the first step.\\n\\u00a0   template <int dim>\\n\\u00a0   void PlasticityContactProblem<dim>::solve_newton()\\n\\u00a0   {\\n\\u00a0     TrilinosWrappers::MPI::Vector old_solution(locally_owned_dofs,\\n\\u00a0                                                mpi_communicator);\\n\\u00a0     TrilinosWrappers::MPI::Vector residual(locally_owned_dofs,\\n\\u00a0                                            mpi_communicator);\\n\\u00a0     TrilinosWrappers::MPI::Vector tmp_vector(locally_owned_dofs,\\n\\u00a0                                              mpi_communicator);\\n\\u00a0     TrilinosWrappers::MPI::Vector locally_relevant_tmp_vector(\\n\\u00a0       locally_relevant_dofs, mpi_communicator);\\n\\u00a0     TrilinosWrappers::MPI::Vector distributed_solution(locally_owned_dofs,\\n\\u00a0                                                        mpi_communicator);\\n\\u00a0 \\n\\u00a0     double residual_norm;\\n\\u00a0     double previous_residual_norm = -std::numeric_limits<double>::max();\\n\\u00a0 \\n\\u00a0     const double correct_sigma = sigma_0;\\n\\u00a0 \\n\\u00a0     IndexSet old_active_set(active_set);\\n\\u00a0 \\n\\u00a0     for (unsigned int newton_step = 1; newton_step <= 100; ++newton_step)\\n\\u00a0       {\\n\\u00a0         if (newton_step == 1 &&\\n\\u00a0             ((transfer_solution && current_refinement_cycle == 0) ||\\n\\u00a0              !transfer_solution))\\n\\u00a0           constitutive_law.set_sigma_0(1e+10);\\n\\u00a0         else if (newton_step == 2 || current_refinement_cycle > 0 ||\\n\\u00a0                  !transfer_solution)\\n\\u00a0           constitutive_law.set_sigma_0(correct_sigma);\\n\\u00a0 \\n\\u00a0         pcout << ' ' << std::endl;\\n\\u00a0         pcout << \\\"   Newton iteration \\\" << newton_step << std::endl;\\n\\u00a0         pcout << \\\"      Updating active set...\\\" << std::endl;\\n\\u00a0 \\n\\u00a0         {\\n\\u00a0           TimerOutput::Scope t(computing_timer, \\\"update active set\\\");\\n\\u00a0           update_solution_and_constraints();\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0         pcout << \\\"      Assembling system... \\\" << std::endl;\\n\\u00a0         newton_matrix = 0;\\n\\u00a0         newton_rhs    = 0;\\n\\u00a0         assemble_newton_system(solution);\\n\\u00a0 \\n\\u00a0         pcout << \\\"      Solving system... \\\" << std::endl;\\n\\u00a0         solve_newton_system();\\n\\u00a0 \\nIt gets a bit more hairy after we have computed the trial solution \\\\(\\\\tilde{\\\\mathbf u}\\\\) of the current Newton step. We handle a highly nonlinear problem so we have to damp Newton's method using a line search. To understand how we do this, recall that in our formulation, we compute a trial solution in each Newton step and not the update between old and new solution. Since the solution set is a convex set, we will use a line search that tries linear combinations of the previous and the trial solution to guarantee that the damped solution is in our solution set again. At most we apply 5 damping steps.\\nThere are exceptions to when we use a line search. First, if this is the first Newton step on any mesh, then we don't have any point to compare the residual to, so we always accept a full step. Likewise, if this is the second Newton step on the first mesh (or the second on any mesh if we don't transfer solutions from mesh to mesh), then we have computed the first of these steps using just an elastic model (see how we set the yield stress sigma to an unreasonably large value above). In this case, the first Newton solution was a purely elastic one, the second one a plastic one, and any linear combination would not necessarily be expected to lie in the feasible set \\u2013 so we just accept the solution we just got.\\nIn either of these two cases, we bypass the line search and just update residual and other vectors as necessary.\\n\\u00a0         if ((newton_step == 1) ||\\n\\u00a0             (transfer_solution && newton_step == 2 &&\\n\\u00a0              current_refinement_cycle == 0) ||\\n\\u00a0             (!transfer_solution && newton_step == 2))\\n\\u00a0           {\\n\\u00a0             compute_nonlinear_residual(solution);\\n\\u00a0             old_solution = solution;\\n\\u00a0 \\n\\u00a0             residual                     = newton_rhs;\\n\\u00a0             const unsigned int start_res = (residual.local_range().first),\\n\\u00a0                                end_res   = (residual.local_range().second);\\n\\u00a0             for (unsigned int n = start_res; n < end_res; ++n)\\n\\u00a0               if (all_constraints.is_inhomogeneously_constrained(n))\\n\\u00a0                 residual(n) = 0;\\n\\u00a0 \\n\\u00a0             residual.compress(VectorOperation::insert);\\n\\u00a0 \\n\\u00a0             residual_norm = residual.l2_norm();\\n\\u00a0 \\n\\u00a0             pcout << \\\"      Accepting Newton solution with residual: \\\"\\n\\u00a0                   << residual_norm << std::endl;\\n\\u00a0           }\\n\\u00a0         else\\n\\u00a0           {\\n\\u00a0             for (unsigned int i = 0; i < 5; ++i)\\n\\u00a0               {\\n\\u00a0                 distributed_solution = solution;\\n\\u00a0 \\n\\u00a0                 const double alpha = std::pow(0.5, static_cast<double>(i));\\n\\u00a0                 tmp_vector         = old_solution;\\n\\u00a0                 tmp_vector.sadd(1 - alpha, alpha, distributed_solution);\\n\\u00a0 \\n\\u00a0                 TimerOutput::Scope t(computing_timer, \\\"Residual and lambda\\\");\\n\\u00a0 \\n\\u00a0                 locally_relevant_tmp_vector = tmp_vector;\\n\\u00a0                 compute_nonlinear_residual(locally_relevant_tmp_vector);\\n\\u00a0                 residual = newton_rhs;\\n\\u00a0 \\n\\u00a0                 const unsigned int start_res = (residual.local_range().first),\\n\\u00a0                                    end_res   = (residual.local_range().second);\\n\\u00a0                 for (unsigned int n = start_res; n < end_res; ++n)\\n\\u00a0                   if (all_constraints.is_inhomogeneously_constrained(n))\\n\\u00a0                     residual(n) = 0;\\n\\u00a0 \\n\\u00a0                 residual.compress(VectorOperation::insert);\\n\\u00a0 \\n\\u00a0                 residual_norm = residual.l2_norm();\\n\\u00a0 \\n\\u00a0                 pcout\\n\\u00a0                   << \\\"      Residual of the non-contact part of the system: \\\"\\n\\u00a0                   << residual_norm << std::endl\\n\\u00a0                   << \\\"         with a damping parameter alpha = \\\" << alpha\\n\\u00a0                   << std::endl;\\n\\u00a0 \\n\\u00a0                 if (residual_norm < previous_residual_norm)\\n\\u00a0                   break;\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0             solution     = tmp_vector;\\n\\u00a0             old_solution = solution;\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         previous_residual_norm = residual_norm;\\n\\u00a0 \\n\\u00a0 \\nstd::pow::VectorizedArray< Number, width > pow(const ::VectorizedArray< Number, width > &, const Number p)Definition vectorization.h:6885\\nThe final step is to check for convergence. If the active set has not changed across all processors and the residual is less than a threshold of \\\\(10^{-10}\\\\), then we terminate the iteration on the current mesh:\\n\\u00a0         if (Utilities::MPI::sum((active_set == old_active_set) ? 0 : 1,\\n\\u00a0                                 mpi_communicator) == 0)\\n\\u00a0           {\\n\\u00a0             pcout << \\\"      Active set did not change!\\\" << std::endl;\\n\\u00a0             if (residual_norm < 1e-10)\\n\\u00a0               break;\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         old_active_set = active_set;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n PlasticityContactProblem::refine_grid\\nIf you've made it this far into the deal.II tutorial, the following function refining the mesh should not pose any challenges to you any more. It refines the mesh, either globally or using the Kelly error estimator, and if so asked also transfers the solution from the previous to the next mesh. In the latter case, we also need to compute the active set and other quantities again, for which we need the information computed by compute_nonlinear_residual().\\n\\u00a0   template <int dim>\\n\\u00a0   void PlasticityContactProblem<dim>::refine_grid()\\n\\u00a0   {\\n\\u00a0     if (refinement_strategy == RefinementStrategy::refine_global)\\n\\u00a0       {\\n\\u00a0         for (typename Triangulation<dim>::active_cell_iterator cell =\\n\\u00a0                triangulation.begin_active();\\n\\u00a0              cell != triangulation.end();\\n\\u00a0              ++cell)\\n\\u00a0           if (cell->is_locally_owned())\\n\\u00a0             cell->set_refine_flag();\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       {\\n\\u00a0         Vector<float> estimated_error_per_cell(triangulation.n_active_cells());\\n\\u00a0         KellyErrorEstimator<dim>::estimate(\\n\\u00a0           dof_handler,\\n\\u00a0           QGauss<dim - 1>(fe.degree + 2),\\n\\u00a0           std::map<types::boundary_id, const Function<dim> *>(),\\n\\u00a0           solution,\\n\\u00a0           estimated_error_per_cell);\\n\\u00a0 \\n\\u00a0         parallel::distributed::GridRefinement ::refine_and_coarsen_fixed_number(\\n\\u00a0           triangulation, estimated_error_per_cell, 0.3, 0.03);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     triangulation.prepare_coarsening_and_refinement();\\n\\u00a0 \\n\\u00a0     parallel::distributed::SolutionTransfer<dim, TrilinosWrappers::MPI::Vector>\\n\\u00a0       solution_transfer(dof_handler);\\n\\u00a0     if (transfer_solution)\\n\\u00a0       solution_transfer.prepare_for_coarsening_and_refinement(solution);\\n\\u00a0 \\n\\u00a0     triangulation.execute_coarsening_and_refinement();\\n\\u00a0 \\n\\u00a0     setup_system();\\n\\u00a0 \\n\\u00a0     if (transfer_solution)\\n\\u00a0       {\\n\\u00a0         TrilinosWrappers::MPI::Vector distributed_solution(locally_owned_dofs,\\n\\u00a0                                                            mpi_communicator);\\n\\u00a0         solution_transfer.interpolate(distributed_solution);\\n\\u00a0 \\nKellyErrorEstimator::estimatestatic void estimate(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const Quadrature< dim - 1 > &quadrature, const std::map< types::boundary_id, const Function< spacedim, Number > * > &neumann_bc, const ReadVector< Number > &solution, Vector< float > &error, const ComponentMask &component_mask={}, const Function< spacedim > *coefficients=nullptr, const unsigned int n_threads=numbers::invalid_unsigned_int, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id, const types::material_id material_id=numbers::invalid_material_id, const Strategy strategy=cell_diameter_over_24)\\nTriaActiveIteratorDefinition tria_iterator.h:755\\nTriangulation::endcell_iterator end() const\\nTriangulation::begin_activeactive_cell_iterator begin_active(const unsigned int level=0) const\\nparallel::distributed::SolutionTransferDefinition solution_transfer.h:224\\nparallel::distributed::Triangulation::execute_coarsening_and_refinementvirtual void execute_coarsening_and_refinement() overrideDefinition tria.cc:3320\\nparallel::distributed::Triangulation::prepare_coarsening_and_refinementvirtual bool prepare_coarsening_and_refinement() overrideDefinition tria.cc:2805\\nunsigned int\\nenforce constraints to make the interpolated solution conforming on the new mesh:\\n\\u00a0         constraints_hanging_nodes.distribute(distributed_solution);\\n\\u00a0 \\n\\u00a0         solution = distributed_solution;\\n\\u00a0         compute_nonlinear_residual(solution);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n PlasticityContactProblem::move_mesh\\nThe remaining three functions before we get to run() have to do with generating output. The following one is an attempt at showing the deformed body in its deformed configuration. To this end, this function takes a displacement vector field and moves every vertex of the (local part) of the mesh by the previously computed displacement. We will call this function with the current displacement field before we generate graphical output, and we will call it again after generating graphical output with the negative displacement field to undo the changes to the mesh so made.\\nThe function itself is pretty straightforward. All we have to do is keep track which vertices we have already touched, as we encounter the same vertices multiple times as we loop over cells.\\n\\u00a0   template <int dim>\\n\\u00a0   void PlasticityContactProblem<dim>::move_mesh(\\n\\u00a0     const TrilinosWrappers::MPI::Vector &displacement) const\\n\\u00a0   {\\n\\u00a0     std::vector<bool> vertex_touched(triangulation.n_vertices(), false);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       if (cell->is_locally_owned())\\n\\u00a0         for (const auto v : cell->vertex_indices())\\n\\u00a0           if (vertex_touched[cell->vertex_index(v)] == false)\\n\\u00a0             {\\n\\u00a0               vertex_touched[cell->vertex_index(v)] = true;\\n\\u00a0 \\n\\u00a0               Point<dim> vertex_displacement;\\n\\u00a0               for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0                 vertex_displacement[d] =\\n\\u00a0                   displacement(cell->vertex_dof_index(v, d));\\n\\u00a0 \\n\\u00a0               cell->vertex(v) += vertex_displacement;\\n\\u00a0             }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nTriangulation::n_verticesunsigned int n_vertices() const\\nvertex_indicesunsigned int vertex_indices[2]Definition grid_tools_topology.cc:947\\n PlasticityContactProblem::output_results\\nNext is the function we use to actually generate graphical output. The function is a bit tedious, but not actually particularly complicated. It moves the mesh at the top (and moves it back at the end), then computes the contact forces along the contact surface. We can do so (as shown in the accompanying paper) by taking the untreated residual vector and identifying which degrees of freedom correspond to those with contact by asking whether they have an inhomogeneous constraints associated with them. As always, we need to be mindful that we can only write into completely distributed vectors (i.e., vectors without ghost elements) but that when we want to generate output, we need vectors that do indeed have ghost entries for all locally relevant degrees of freedom.\\n\\u00a0   template <int dim>\\n\\u00a0   void PlasticityContactProblem<dim>::output_results(\\n\\u00a0     const unsigned int current_refinement_cycle)\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope t(computing_timer, \\\"Graphical output\\\");\\n\\u00a0 \\n\\u00a0     pcout << \\\"      Writing graphical output... \\\" << std::flush;\\n\\u00a0 \\n\\u00a0     move_mesh(solution);\\n\\u00a0 \\nCalculation of the contact forces\\n\\u00a0     TrilinosWrappers::MPI::Vector distributed_lambda(locally_owned_dofs,\\n\\u00a0                                                      mpi_communicator);\\n\\u00a0     const unsigned int start_res = (newton_rhs_uncondensed.local_range().first),\\n\\u00a0                        end_res = (newton_rhs_uncondensed.local_range().second);\\n\\u00a0     for (unsigned int n = start_res; n < end_res; ++n)\\n\\u00a0       if (all_constraints.is_inhomogeneously_constrained(n))\\n\\u00a0         distributed_lambda(n) =\\n\\u00a0           newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n);\\n\\u00a0     distributed_lambda.compress(VectorOperation::insert);\\n\\u00a0     constraints_hanging_nodes.distribute(distributed_lambda);\\n\\u00a0 \\n\\u00a0     TrilinosWrappers::MPI::Vector lambda(locally_relevant_dofs,\\n\\u00a0                                          mpi_communicator);\\n\\u00a0     lambda = distributed_lambda;\\n\\u00a0 \\n\\u00a0     TrilinosWrappers::MPI::Vector distributed_active_set_vector(\\n\\u00a0       locally_owned_dofs, mpi_communicator);\\n\\u00a0     distributed_active_set_vector = 0.;\\n\\u00a0     for (const auto index : active_set)\\n\\u00a0       distributed_active_set_vector[index] = 1.;\\n\\u00a0     distributed_lambda.compress(VectorOperation::insert);\\n\\u00a0 \\n\\u00a0     TrilinosWrappers::MPI::Vector active_set_vector(locally_relevant_dofs,\\n\\u00a0                                                     mpi_communicator);\\n\\u00a0     active_set_vector = distributed_active_set_vector;\\n\\u00a0 \\n\\u00a0     DataOut<dim> data_out;\\n\\u00a0 \\n\\u00a0     data_out.attach_dof_handler(dof_handler);\\n\\u00a0 \\n\\u00a0     const std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n\\u00a0       data_component_interpretation(\\n\\u00a0         dim, DataComponentInterpretation::component_is_part_of_vector);\\n\\u00a0     data_out.add_data_vector(solution,\\n\\u00a0                              std::vector<std::string>(dim, \\\"displacement\\\"),\\n\\u00a0                              DataOut<dim>::type_dof_data,\\n\\u00a0                              data_component_interpretation);\\n\\u00a0     data_out.add_data_vector(lambda,\\n\\u00a0                              std::vector<std::string>(dim, \\\"contact_force\\\"),\\n\\u00a0                              DataOut<dim>::type_dof_data,\\n\\u00a0                              data_component_interpretation);\\n\\u00a0     data_out.add_data_vector(active_set_vector,\\n\\u00a0                              std::vector<std::string>(dim, \\\"active_set\\\"),\\n\\u00a0                              DataOut<dim>::type_dof_data,\\n\\u00a0                              data_component_interpretation);\\n\\u00a0 \\n\\u00a0     Vector<float> subdomain(triangulation.n_active_cells());\\n\\u00a0     for (unsigned int i = 0; i < subdomain.size(); ++i)\\n\\u00a0       subdomain(i) = triangulation.locally_owned_subdomain();\\n\\u00a0     data_out.add_data_vector(subdomain, \\\"subdomain\\\");\\n\\u00a0 \\n\\u00a0     data_out.add_data_vector(fraction_of_plastic_q_points_per_cell,\\n\\u00a0                              \\\"fraction_of_plastic_q_points\\\");\\n\\u00a0 \\n\\u00a0     data_out.build_patches();\\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nparallel::TriangulationBase::locally_owned_subdomaintypes::subdomain_id locally_owned_subdomain() const overrideDefinition tria_base.cc:345\\nDataComponentInterpretation::component_is_part_of_vector@ component_is_part_of_vectorDefinition data_component_interpretation.h:58\\nIn the remainder of the function, we generate one VTU file on every processor, indexed by the subdomain id of this processor. On the first processor, we then also create a .pvtu file that indexes all of the VTU files so that the entire set of output files can be read at once. These .pvtu are used by Paraview to describe an entire parallel computation's output files. We then do the same again for the competitor of Paraview, the VisIt visualization program, by creating a matching .visit file.\\n\\u00a0     const std::string pvtu_filename = data_out.write_vtu_with_pvtu_record(\\n\\u00a0       output_dir, \\\"solution\\\", current_refinement_cycle, mpi_communicator, 2);\\n\\u00a0     pcout << pvtu_filename << std::endl;\\n\\u00a0 \\n\\u00a0     TrilinosWrappers::MPI::Vector tmp(solution);\\n\\u00a0     tmp *= -1;\\n\\u00a0     move_mesh(tmp);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n PlasticityContactProblem::output_contact_force\\nThis last auxiliary function computes the contact force by calculating an integral over the contact pressure in z-direction over the contact area. For this purpose we set the contact pressure lambda to 0 for all inactive dofs (whether a degree of freedom is part of the contact is determined just as we did in the previous function). For all active dofs, lambda contains the quotient of the nonlinear residual (newton_rhs_uncondensed) and corresponding diagonal entry of the mass matrix (diag_mass_matrix_vector). Because it is not unlikely that hanging nodes show up in the contact area it is important to apply constraints_hanging_nodes.distribute to the distributed_lambda vector.\\n\\u00a0   template <int dim>\\n\\u00a0   void PlasticityContactProblem<dim>::output_contact_force() const\\n\\u00a0   {\\n\\u00a0     TrilinosWrappers::MPI::Vector distributed_lambda(locally_owned_dofs,\\n\\u00a0                                                      mpi_communicator);\\n\\u00a0     const unsigned int start_res = (newton_rhs_uncondensed.local_range().first),\\n\\u00a0                        end_res = (newton_rhs_uncondensed.local_range().second);\\n\\u00a0     for (unsigned int n = start_res; n < end_res; ++n)\\n\\u00a0       if (all_constraints.is_inhomogeneously_constrained(n))\\n\\u00a0         distributed_lambda(n) =\\n\\u00a0           newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n);\\n\\u00a0       else\\n\\u00a0         distributed_lambda(n) = 0;\\n\\u00a0     distributed_lambda.compress(VectorOperation::insert);\\n\\u00a0     constraints_hanging_nodes.distribute(distributed_lambda);\\n\\u00a0 \\n\\u00a0     TrilinosWrappers::MPI::Vector lambda(locally_relevant_dofs,\\n\\u00a0                                          mpi_communicator);\\n\\u00a0     lambda = distributed_lambda;\\n\\u00a0 \\n\\u00a0     double contact_force = 0.0;\\n\\u00a0 \\n\\u00a0     const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);\\n\\u00a0     FEFaceValues<dim>     fe_values_face(fe,\\n\\u00a0                                      face_quadrature_formula,\\n\\u00a0                                      update_values | update_JxW_values);\\n\\u00a0 \\n\\u00a0     const unsigned int n_face_q_points = face_quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     const FEValuesExtractors::Vector displacement(0);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       if (cell->is_locally_owned())\\n\\u00a0         for (const auto &face : cell->face_iterators())\\n\\u00a0           if (face->at_boundary() && face->boundary_id() == 1)\\n\\u00a0             {\\n\\u00a0               fe_values_face.reinit(cell, face);\\n\\u00a0 \\n\\u00a0               std::vector<Tensor<1, dim>> lambda_values(n_face_q_points);\\n\\u00a0               fe_values_face[displacement].get_function_values(lambda,\\n\\u00a0                                                                lambda_values);\\n\\u00a0 \\n\\u00a0               for (unsigned int q_point = 0; q_point < n_face_q_points;\\n\\u00a0                    ++q_point)\\n\\u00a0                 contact_force +=\\n\\u00a0                   lambda_values[q_point][2] * fe_values_face.JxW(q_point);\\n\\u00a0             }\\n\\u00a0     contact_force = Utilities::MPI::sum(contact_force, MPI_COMM_WORLD);\\n\\u00a0 \\n\\u00a0     pcout << \\\"Contact force = \\\" << contact_force << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n PlasticityContactProblem::run\\nAs in all other tutorial programs, the run() function contains the overall logic. There is not very much to it here: in essence, it performs the loops over all mesh refinement cycles, and within each, hands things over to the Newton solver in solve_newton() on the current mesh and calls the function that creates graphical output for the so-computed solution. It then outputs some statistics concerning both run times and memory consumption that has been collected over the course of computations on this mesh.\\n\\u00a0   template <int dim>\\n\\u00a0   void PlasticityContactProblem<dim>::run()\\n\\u00a0   {\\n\\u00a0     computing_timer.reset();\\n\\u00a0     for (; current_refinement_cycle < n_refinement_cycles;\\n\\u00a0          ++current_refinement_cycle)\\n\\u00a0       {\\n\\u00a0         {\\n\\u00a0           TimerOutput::Scope t(computing_timer, \\\"Setup\\\");\\n\\u00a0 \\n\\u00a0           pcout << std::endl;\\n\\u00a0           pcout << \\\"Cycle \\\" << current_refinement_cycle << ':' << std::endl;\\n\\u00a0 \\n\\u00a0           if (current_refinement_cycle == 0)\\n\\u00a0             {\\n\\u00a0               make_grid();\\n\\u00a0               setup_system();\\n\\u00a0             }\\n\\u00a0           else\\n\\u00a0             {\\n\\u00a0               TimerOutput::Scope t(computing_timer, \\\"Setup: refine mesh\\\");\\n\\u00a0               refine_grid();\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0         solve_newton();\\n\\u00a0 \\n\\u00a0         output_results(current_refinement_cycle);\\n\\u00a0 \\n\\u00a0         computing_timer.print_summary();\\n\\u00a0         computing_timer.reset();\\n\\u00a0 \\n\\u00a0         Utilities::System::MemoryStats stats;\\n\\u00a0         Utilities::System::get_memory_stats(stats);\\n\\u00a0         pcout << \\\"Peak virtual memory used, resident in kB: \\\" << stats.VmSize\\n\\u00a0               << ' ' << stats.VmRSS << std::endl;\\n\\u00a0 \\n\\u00a0         if (base_mesh == \\\"box\\\")\\n\\u00a0           output_contact_force();\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 } // namespace Step42\\n\\u00a0 \\nUtilities::System::get_memory_statsvoid get_memory_stats(MemoryStats &stats)Definition utilities.cc:964\\nUtilities::System::MemoryStatsDefinition utilities.h:864\\n The main function\\nThere really isn't much to the main() function. It looks like they always do:\\n\\u00a0 int main(int argc, char *argv[])\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0   using namespace Step42;\\n\\u00a0 \\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       ParameterHandler prm;\\n\\u00a0       PlasticityContactProblem<3>::declare_parameters(prm);\\n\\u00a0       if (argc != 2)\\n\\u00a0         {\\n\\u00a0           std::cerr << \\\"*** Call this program as <./step-42 input.prm>\\\"\\n\\u00a0                     << std::endl;\\n\\u00a0           return 1;\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0       prm.parse_input(argv[1]);\\n\\u00a0       Utilities::MPI::MPI_InitFinalize mpi_initialization(\\n\\u00a0         argc, argv, numbers::invalid_unsigned_int);\\n\\u00a0       {\\n\\u00a0         PlasticityContactProblem<3> problem(prm);\\n\\u00a0         problem.run();\\n\\u00a0       }\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0 \\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\nUtilities::MPI::MPI_InitFinalizeDefinition mpi.h:1081\\nnumbers::invalid_unsigned_intstatic const unsigned int invalid_unsigned_intDefinition types.h:220\\n Results\\nThe directory that contains this program also contains a number of input parameter files that can be used to create various different simulations. For example, running the program with the p1_adaptive.prm parameter file (using a ball as obstacle and the box as domain) on 16 cores produces output like this:     Using output directory 'p1adaptive/'\\n    FE degree 1\\n    transfer solution false\\n \\nCycle 0:\\n   Number of active cells: 512\\n   Number of degrees of freedom: 2187\\n \\n  Newton iteration 1\\n      Updating active set...\\n         Size of active set: 1\\n      Assembling system...\\n      Solving system...\\n         Error: 173.076 -> 1.64265e-06 in 7 Bicgstab iterations.\\n      Accepting Newton solution with residual: 1.64265e-06\\n \\n   Newton iteration 2\\n      Updating active set...\\n         Size of active set: 1\\n      Assembling system...\\n      Solving system...\\n         Error: 57.3622 -> 3.23721e-07 in 8 Bicgstab iterations.\\n      Accepting Newton solution with residual: 24.9028\\n      Active set did not change!\\n \\n   Newton iteration 3\\n      Updating active set...\\n         Size of active set: 1\\n      Assembling system...\\n      Solving system...\\n         Error: 24.9028 -> 9.94326e-08 in 7 Bicgstab iterations.\\n      Residual of the non-contact part of the system: 1.63333\\n         with a damping parameter alpha = 1\\n      Active set did not change!\\n \\n...\\n \\n  Newton iteration 6\\n      Updating active set...\\n         Size of active set: 1\\n      Assembling system...\\n      Solving system...\\n         Error: 1.43188e-07 -> 3.56218e-16 in 8 Bicgstab iterations.\\n      Residual of the non-contact part of the system: 4.298e-14\\n         with a damping parameter alpha = 1\\n      Active set did not change!\\n      Writing graphical output... p1_adaptive/solution-00.pvtu\\n \\n \\n+---------------------------------------------+------------+------------+\\n| Total wallclock time elapsed since start    |      1.13s |            |\\n|                                             |            |            |\\n| Section                         | no. calls |  wall time | % of total |\\n+---------------------------------+-----------+------------+------------+\\n| Assembling                      |         6 |     0.463s |        41% |\\n| Graphical output                |         1 |    0.0257s |       2.3% |\\n| Residual and lambda             |         4 |    0.0754s |       6.7% |\\n| Setup                           |         1 |     0.227s |        20% |\\n| Setup: constraints              |         1 |    0.0347s |       3.1% |\\n| Setup: distribute DoFs          |         1 |    0.0441s |       3.9% |\\n| Setup: matrix                   |         1 |    0.0119s |       1.1% |\\n| Setup: vectors                  |         1 |   0.00155s |      0.14% |\\n| Solve                           |         6 |     0.246s |        22% |\\n| Solve: iterate                  |         6 |    0.0631s |       5.6% |\\n| Solve: setup preconditioner     |         6 |     0.167s |        15% |\\n| update active set               |         6 |    0.0401s |       3.6% |\\n+---------------------------------+-----------+------------+------------+\\n \\nPeak virtual memory used, resident in kB: 541884 77464\\nContact force = 37.3058\\n \\n...\\n \\nCycle 3:\\n   Number of active cells: 14652\\n   Number of degrees of freedom: 52497\\n \\n   Newton iteration 1\\n      Updating active set...\\n         Size of active set: 145\\n      Assembling system...\\n      Solving system...\\n         Error: 296.309 -> 2.72484e-06 in 10 Bicgstab iterations.\\n      Accepting Newton solution with residual: 2.72484e-06\\n \\n...\\n \\n   Newton iteration 10\\n      Updating active set...\\n         Size of active set: 145\\n      Assembling system...\\n      Solving system...\\n         Error: 2.71541e-07 -> 1.5428e-15 in 27 Bicgstab iterations.\\n      Residual of the non-contact part of the system: 1.89261e-13\\n         with a damping parameter alpha = 1\\n      Active set did not change!\\n      Writing graphical output... p1_adaptive/solution-03.pvtu\\n \\n \\n+---------------------------------------------+------------+------------+\\n| Total wallclock time elapsed since start    |      38.4s |            |\\n|                                             |            |            |\\n| Section                         | no. calls |  wall time | % of total |\\n+---------------------------------+-----------+------------+------------+\\n| Assembling                      |        10 |      22.5s |        58% |\\n| Graphical output                |         1 |     0.327s |      0.85% |\\n| Residual and lambda             |         9 |      3.75s |       9.8% |\\n| Setup                           |         1 |      4.83s |        13% |\\n| Setup: constraints              |         1 |     0.578s |       1.5% |\\n| Setup: distribute DoFs          |         1 |      0.71s |       1.8% |\\n| Setup: matrix                   |         1 |     0.111s |      0.29% |\\n| Setup: refine mesh              |         1 |      4.83s |        13% |\\n| Setup: vectors                  |         1 |   0.00548s |     0.014% |\\n| Solve                           |        10 |      5.49s |        14% |\\n| Solve: iterate                  |        10 |       3.5s |       9.1% |\\n| Solve: setup preconditioner     |        10 |      1.84s |       4.8% |\\n| update active set               |        10 |     0.662s |       1.7% |\\n+---------------------------------+-----------+------------+------------+\\n \\nPeak virtual memory used, resident in kB: 566052 105788\\nContact force = 56.794\\n \\n...\\nThe tables at the end of each cycle show information about computing time (these numbers are of course specific to the machine on which this output was produced) and the number of calls of different parts of the program like assembly or calculating the residual, for the most recent mesh refinement cycle. Some of the numbers above can be improved by transferring the solution from one mesh to the next, an option we have not exercised here. Of course, you can also make the program run faster, especially on the later refinement cycles, by just using more processors: the accompanying paper shows good scaling to at least 1000 cores.\\nIn a typical run, you can observe that for every refinement step, the active set - the contact points - are iterated out at first. After that the Newton method has only to resolve the plasticity. For the finer meshes, quadratic convergence can be observed for the last 4 or 5 Newton iterations.\\nWe will not discuss here in all detail what happens with each of the input files. Rather, let us just show pictures of the solution (the left half of the domain is omitted if cells have zero quadrature points at which the plastic inequality is active):\\n\\n\\n  \\u00a0   \\n\\nThe picture shows the adaptive refinement and as well how much a cell is plastified during the contact with the ball. Remember that we consider the norm of the deviator part of the stress in each quadrature point to see if there is elastic or plastic behavior. The blue color means that this cell contains only elastic quadrature points in contrast to the red cells in which all quadrature points are plastified. In the middle of the top surface - where the mesh is finest - a very close look shows the dimple caused by the obstacle. This is the result of the move_mesh() function. However, because the indentation of the obstacles we consider here is so small, it is hard to discern this effect; one could play with displacing vertices of the mesh by a multiple of the computed displacement.\\nFurther discussion of results that can be obtained using this program is provided in the publication mentioned at the very top of this page.\\n Possibilities for extensions\\nThere are, as always, multiple possibilities for extending this program. From an algorithmic perspective, this program goes about as far as one can at the time of writing, using the best available algorithms for the contact inequality, the plastic nonlinearity, and the linear solvers. However, there are things one would like to do with this program as far as more realistic situations are concerned: \\n\\nExtend the program from a static to a quasi-static situation, perhaps by choosing a backward-Euler-scheme for the time discretization. Some theoretical results can be found in the PhD thesis by J\\u00f6rg Frohne, FEM-Simulation der Umformtechnik metallischer Oberfl\\u00e4chen im Mikrokosmos, University of Siegen, Germany, 2011.\\n\\n\\n\\nIt would also be an interesting advance to consider a contact problem with friction. In almost every mechanical process friction has a big influence. To model this situation, we have to take into account tangential stresses at the contact surface. Friction also adds another inequality to our problem since body and obstacle will typically stick together as long as the tangential stress does not exceed a certain limit, beyond which the two bodies slide past each other.\\n\\n\\n\\nIf we already simulate a frictional contact, the next step to consider is heat generation over the contact zone. The heat that is caused by friction between two bodies raises the temperature in the deformable body and entails an change of some material parameters.\\n\\n\\n\\nIt might be of interest to implement more accurate, problem-adapted error estimators for contact as well as for the plasticity. \\n\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2012 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Authors: Joerg Frohne, Texas A&M University and\\n *                        University of Siegen, 2012, 2013\\n *          Wolfgang Bangerth, Texas A&M University, 2012, 2013\\n *          Timo Heister, Texas A&M University, 2013\\n */\\n \\n#include <deal.II/base/conditional_ostream.h>\\n#include <deal.II/base/parameter_handler.h>\\n#include <deal.II/base/utilities.h>\\n#include <deal.II/base/index_set.h>\\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/function.h>\\n#include <deal.II/base/timer.h>\\n \\n#include <deal.II/lac/vector.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/sparsity_tools.h>\\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/lac/block_sparsity_pattern.h>\\n#include <deal.II/lac/solver_bicgstab.h>\\n#include <deal.II/lac/precondition.h>\\n#include <deal.II/lac/affine_constraints.h>\\n#include <deal.II/lac/trilinos_sparse_matrix.h>\\n#include <deal.II/lac/trilinos_block_sparse_matrix.h>\\n#include <deal.II/lac/trilinos_vector.h>\\n#include <deal.II/lac/trilinos_parallel_block_vector.h>\\n#include <deal.II/lac/trilinos_precondition.h>\\n#include <deal.II/lac/trilinos_solver.h>\\n \\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_tools.h>\\n#include <deal.II/grid/manifold_lib.h>\\n \\n#include <deal.II/distributed/tria.h>\\n#include <deal.II/distributed/grid_refinement.h>\\n#include <deal.II/distributed/solution_transfer.h>\\n \\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_renumbering.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_system.h>\\n#include <deal.II/fe/fe_values.h>\\n \\n#include <deal.II/numerics/vector_tools.h>\\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/error_estimator.h>\\n#include <deal.II/numerics/fe_field_function.h>\\n \\n#include <fstream>\\n#include <iostream>\\n \\n#include <sys/stat.h>\\n#include <cerrno>\\n \\nnamespace Step42\\n{\\n using namespace dealii;\\n \\n \\n template <int dim>\\n class ConstitutiveLaw\\n  {\\n public:\\n    ConstitutiveLaw(const double E,\\n const double nu,\\n const double sigma_0,\\n const double gamma);\\n \\n void set_sigma_0(double sigma_zero);\\n \\n bool get_stress_strain_tensor(\\n const SymmetricTensor<2, dim> &strain_tensor,\\n SymmetricTensor<4, dim>       &stress_strain_tensor) const;\\n \\n void get_linearized_stress_strain_tensors(\\n const SymmetricTensor<2, dim> &strain_tensor,\\n SymmetricTensor<4, dim>       &stress_strain_tensor_linearized,\\n SymmetricTensor<4, dim>       &stress_strain_tensor) const;\\n \\n private:\\n const double kappa;\\n const double mu;\\n double       sigma_0;\\n const double gamma;\\n \\n const SymmetricTensor<4, dim> stress_strain_tensor_kappa;\\n const SymmetricTensor<4, dim> stress_strain_tensor_mu;\\n  };\\n \\n template <int dim>\\n  ConstitutiveLaw<dim>::ConstitutiveLaw(double E,\\n double nu,\\n double sigma_0,\\n double gamma)\\n    : kappa(E / (3 * (1 - 2 * nu)))\\n    , mu(E / (2 * (1 + nu)))\\n    , sigma_0(sigma_0)\\n    , gamma(gamma)\\n    , stress_strain_tensor_kappa(kappa *\\n outer_product(unit_symmetric_tensor<dim>(),\\n unit_symmetric_tensor<dim>()))\\n    , stress_strain_tensor_mu(\\n        2 * mu *\\n        (identity_tensor<dim>() - outer_product(unit_symmetric_tensor<dim>(),\\n unit_symmetric_tensor<dim>()) /\\n                                    3.0))\\n  {}\\n \\n \\n template <int dim>\\n void ConstitutiveLaw<dim>::set_sigma_0(double sigma_zero)\\n  {\\n    sigma_0 = sigma_zero;\\n  }\\n \\n \\n \\n template <int dim>\\n bool ConstitutiveLaw<dim>::get_stress_strain_tensor(\\n const SymmetricTensor<2, dim> &strain_tensor,\\n SymmetricTensor<4, dim>       &stress_strain_tensor) const\\n {\\n Assert(dim == 3, ExcNotImplemented());\\n \\n SymmetricTensor<2, dim> stress_tensor;\\n    stress_tensor =\\n      (stress_strain_tensor_kappa + stress_strain_tensor_mu) * strain_tensor;\\n \\n const SymmetricTensor<2, dim> deviator_stress_tensor =\\n deviator(stress_tensor);\\n const double deviator_stress_tensor_norm = deviator_stress_tensor.norm();\\n \\n    stress_strain_tensor = stress_strain_tensor_mu;\\n if (deviator_stress_tensor_norm > sigma_0)\\n      {\\n const double beta = sigma_0 / deviator_stress_tensor_norm;\\n        stress_strain_tensor *= (gamma + (1 - gamma) * beta);\\n      }\\n \\n    stress_strain_tensor += stress_strain_tensor_kappa;\\n \\n return (deviator_stress_tensor_norm > sigma_0);\\n  }\\n \\n \\n \\n template <int dim>\\n void ConstitutiveLaw<dim>::get_linearized_stress_strain_tensors(\\n const SymmetricTensor<2, dim> &strain_tensor,\\n SymmetricTensor<4, dim>       &stress_strain_tensor_linearized,\\n SymmetricTensor<4, dim>       &stress_strain_tensor) const\\n {\\n Assert(dim == 3, ExcNotImplemented());\\n \\n SymmetricTensor<2, dim> stress_tensor;\\n    stress_tensor =\\n      (stress_strain_tensor_kappa + stress_strain_tensor_mu) * strain_tensor;\\n \\n    stress_strain_tensor            = stress_strain_tensor_mu;\\n    stress_strain_tensor_linearized = stress_strain_tensor_mu;\\n \\n SymmetricTensor<2, dim> deviator_stress_tensor = deviator(stress_tensor);\\n const double deviator_stress_tensor_norm = deviator_stress_tensor.norm();\\n \\n if (deviator_stress_tensor_norm > sigma_0)\\n      {\\n const double beta = sigma_0 / deviator_stress_tensor_norm;\\n        stress_strain_tensor *= (gamma + (1 - gamma) * beta);\\n        stress_strain_tensor_linearized *= (gamma + (1 - gamma) * beta);\\n        deviator_stress_tensor /= deviator_stress_tensor_norm;\\n        stress_strain_tensor_linearized -=\\n          (1 - gamma) * beta * 2 * mu *\\n outer_product(deviator_stress_tensor, deviator_stress_tensor);\\n      }\\n \\n    stress_strain_tensor += stress_strain_tensor_kappa;\\n    stress_strain_tensor_linearized += stress_strain_tensor_kappa;\\n  }\\n \\n namespace EquationData\\n  {\\n template <int dim>\\n class BoundaryForce : public Function<dim>\\n    {\\n public:\\n      BoundaryForce();\\n \\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n \\n virtual void vector_value(const Point<dim> &p,\\n Vector<double>   &values) const override;\\n    };\\n \\n template <int dim>\\n    BoundaryForce<dim>::BoundaryForce()\\n      : Function<dim>(dim)\\n    {}\\n \\n \\n template <int dim>\\n double BoundaryForce<dim>::value(const Point<dim> &,\\n const unsigned int) const\\n {\\n return 0.;\\n    }\\n \\n template <int dim>\\n void BoundaryForce<dim>::vector_value(const Point<dim> &p,\\n Vector<double>   &values) const\\n {\\n for (unsigned int c = 0; c < this->n_components; ++c)\\n        values(c) = BoundaryForce<dim>::value(p, c);\\n    }\\n \\n \\n \\n template <int dim>\\n class BoundaryValues : public Function<dim>\\n    {\\n public:\\n      BoundaryValues();\\n \\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n    };\\n \\n \\n template <int dim>\\n    BoundaryValues<dim>::BoundaryValues()\\n      : Function<dim>(dim)\\n    {}\\n \\n \\n template <int dim>\\n double BoundaryValues<dim>::value(const Point<dim> &,\\n const unsigned int) const\\n {\\n return 0.;\\n    }\\n \\n \\n \\n \\n template <int dim>\\n class SphereObstacle : public Function<dim>\\n    {\\n public:\\n      SphereObstacle(const double z_surface);\\n \\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n \\n virtual void vector_value(const Point<dim> &p,\\n Vector<double>   &values) const override;\\n \\n private:\\n const double z_surface;\\n    };\\n \\n \\n template <int dim>\\n    SphereObstacle<dim>::SphereObstacle(const double z_surface)\\n      : Function<dim>(dim)\\n      , z_surface(z_surface)\\n    {}\\n \\n \\n template <int dim>\\n double SphereObstacle<dim>::value(const Point<dim>  &p,\\n const unsigned int component) const\\n {\\n if (component == 0)\\n return p[0];\\n else if (component == 1)\\n return p[1];\\n else if (component == 2)\\n        {\\n if ((p[0] - 0.5) * (p[0] - 0.5) + (p[1] - 0.5) * (p[1] - 0.5) < 0.36)\\n return (-std::sqrt(0.36 - (p[0] - 0.5) * (p[0] - 0.5) -\\n                               (p[1] - 0.5) * (p[1] - 0.5)) +\\n                    z_surface + 0.59);\\n else\\n return 1000;\\n        }\\n \\n DEAL_II_NOT_IMPLEMENTED();\\n return 1e9; // an unreasonable value; ignored in debug mode because of the\\n    }\\n \\n \\n template <int dim>\\n void SphereObstacle<dim>::vector_value(const Point<dim> &p,\\n Vector<double>   &values) const\\n {\\n for (unsigned int c = 0; c < this->n_components; ++c)\\n        values(c) = SphereObstacle<dim>::value(p, c);\\n    }\\n \\n \\n template <int dim>\\n class BitmapFile\\n    {\\n public:\\n      BitmapFile(const std::string &name);\\n \\n double get_value(const double x, const double y) const;\\n \\n private:\\n      std::vector<double> obstacle_data;\\n double              hx, hy;\\n int                 nx, ny;\\n \\n double get_pixel_value(const int i, const int j) const;\\n    };\\n \\n template <int dim>\\n    BitmapFile<dim>::BitmapFile(const std::string &name)\\n      : obstacle_data(0)\\n      , hx(0)\\n      , hy(0)\\n      , nx(0)\\n      , ny(0)\\n    {\\n      std::ifstream f(name);\\n AssertThrow(f,\\n                  ExcMessage(std::string(\\\"Can't read from file <\\\") + name +\\n \\\">!\\\"));\\n \\n      std::string temp;\\n      f >> temp >> nx >> ny;\\n \\n AssertThrow(nx > 0 && ny > 0, ExcMessage(\\\"Invalid file format.\\\"));\\n \\n for (int k = 0; k < nx * ny; ++k)\\n        {\\n double val;\\n          f >> val;\\n          obstacle_data.push_back(val);\\n        }\\n \\n      hx = 1.0 / (nx - 1);\\n      hy = 1.0 / (ny - 1);\\n \\n if (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)\\n        std::cout << \\\"Read obstacle from file <\\\" << name << '>' << std::endl\\n                  << \\\"Resolution of the scanned obstacle picture: \\\" << nx\\n                  << \\\" x \\\" << ny << std::endl;\\n    }\\n \\n template <int dim>\\n double BitmapFile<dim>::get_pixel_value(const int i, const int j) const\\n {\\n      assert(i >= 0 && i < nx);\\n      assert(j >= 0 && j < ny);\\n return obstacle_data[nx * (ny - 1 - j) + i];\\n    }\\n \\n template <int dim>\\n double BitmapFile<dim>::get_value(const double x, const double y) const\\n {\\n const int ix = std::min(std::max(static_cast<int>(x / hx), 0), nx - 2);\\n const int iy = std::min(std::max(static_cast<int>(y / hy), 0), ny - 2);\\n \\n const double xi  = std::min(std::max((x - ix * hx) / hx, 1.), 0.);\\n const double eta = std::min(std::max((y - iy * hy) / hy, 1.), 0.);\\n \\n return ((1 - xi) * (1 - eta) * get_pixel_value(ix, iy) +\\n              xi * (1 - eta) * get_pixel_value(ix + 1, iy) +\\n              (1 - xi) * eta * get_pixel_value(ix, iy + 1) +\\n              xi * eta * get_pixel_value(ix + 1, iy + 1));\\n    }\\n \\n template <int dim>\\n class ChineseObstacle : public Function<dim>\\n    {\\n public:\\n      ChineseObstacle(const std::string &filename, const double z_surface);\\n \\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n \\n virtual void vector_value(const Point<dim> &p,\\n Vector<double>   &values) const override;\\n \\n private:\\n const BitmapFile<dim> input_obstacle;\\n double                z_surface;\\n    };\\n \\n \\n template <int dim>\\n    ChineseObstacle<dim>::ChineseObstacle(const std::string &filename,\\n const double       z_surface)\\n      : Function<dim>(dim)\\n      , input_obstacle(filename)\\n      , z_surface(z_surface)\\n    {}\\n \\n \\n template <int dim>\\n double ChineseObstacle<dim>::value(const Point<dim>  &p,\\n const unsigned int component) const\\n {\\n if (component == 0)\\n return p[0];\\n if (component == 1)\\n return p[1];\\n else if (component == 2)\\n        {\\n if (p[0] >= 0.0 && p[0] <= 1.0 && p[1] >= 0.0 && p[1] <= 1.0)\\n return z_surface + 0.999 - input_obstacle.get_value(p[0], p[1]);\\n        }\\n \\n DEAL_II_NOT_IMPLEMENTED();\\n return 1e9; // an unreasonable value; ignored in debug mode because of the\\n    }\\n \\n template <int dim>\\n void ChineseObstacle<dim>::vector_value(const Point<dim> &p,\\n Vector<double>   &values) const\\n {\\n for (unsigned int c = 0; c < this->n_components; ++c)\\n        values(c) = ChineseObstacle<dim>::value(p, c);\\n    }\\n  } // namespace EquationData\\n \\n \\n template <int dim>\\n class PlasticityContactProblem\\n  {\\n public:\\n    PlasticityContactProblem(const ParameterHandler &prm);\\n \\n void run();\\n \\n static void declare_parameters(ParameterHandler &prm);\\n \\n private:\\n void make_grid();\\n void setup_system();\\n void compute_dirichlet_constraints();\\n void update_solution_and_constraints();\\n void\\n    assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &mass_matrix);\\n void assemble_newton_system(\\n const TrilinosWrappers::MPI::Vector &linearization_point);\\n void compute_nonlinear_residual(\\n const TrilinosWrappers::MPI::Vector &linearization_point);\\n void solve_newton_system();\\n void solve_newton();\\n void refine_grid();\\n void move_mesh(const TrilinosWrappers::MPI::Vector &displacement) const;\\n void output_results(const unsigned int current_refinement_cycle);\\n \\n void output_contact_force() const;\\n \\n MPI_Comm           mpi_communicator;\\n ConditionalOStream pcout;\\n TimerOutput        computing_timer;\\n \\n const unsigned int                        n_initial_global_refinements;\\n parallel::distributed::Triangulation<dim> triangulation;\\n \\n const unsigned int  fe_degree;\\n const FESystem<dim> fe;\\n DoFHandler<dim>     dof_handler;\\n \\n IndexSet locally_owned_dofs;\\n IndexSet locally_relevant_dofs;\\n \\n AffineConstraints<double> constraints_hanging_nodes;\\n AffineConstraints<double> constraints_dirichlet_and_hanging_nodes;\\n AffineConstraints<double> all_constraints;\\n \\n IndexSet      active_set;\\n Vector<float> fraction_of_plastic_q_points_per_cell;\\n \\n \\n TrilinosWrappers::SparseMatrix newton_matrix;\\n \\n TrilinosWrappers::MPI::Vector solution;\\n TrilinosWrappers::MPI::Vector newton_rhs;\\n TrilinosWrappers::MPI::Vector newton_rhs_uncondensed;\\n TrilinosWrappers::MPI::Vector diag_mass_matrix_vector;\\n \\n const double         e_modulus, nu, gamma, sigma_0;\\n    ConstitutiveLaw<dim> constitutive_law;\\n \\n const std::string                          base_mesh;\\n const std::shared_ptr<const Function<dim>> obstacle;\\n \\n struct RefinementStrategy\\n    {\\n enum value\\n      {\\n        refine_global,\\n        refine_percentage,\\n        refine_fix_dofs\\n      };\\n    };\\n typename RefinementStrategy::value refinement_strategy;\\n \\n const bool         transfer_solution;\\n    std::string        output_dir;\\n const unsigned int n_refinement_cycles;\\n unsigned int       current_refinement_cycle;\\n  };\\n \\n \\n \\n \\n template <int dim>\\n void PlasticityContactProblem<dim>::declare_parameters(ParameterHandler &prm)\\n  {\\n    prm.declare_entry(\\n \\\"polynomial degree\\\",\\n \\\"1\\\",\\n Patterns::Integer(),\\n \\\"Polynomial degree of the FE_Q finite element space, typically 1 or 2.\\\");\\n    prm.declare_entry(\\\"number of initial refinements\\\",\\n \\\"2\\\",\\n Patterns::Integer(),\\n \\\"Number of initial global mesh refinement steps before \\\"\\n \\\"the first computation.\\\");\\n    prm.declare_entry(\\n \\\"refinement strategy\\\",\\n \\\"percentage\\\",\\n Patterns::Selection(\\\"global|percentage\\\"),\\n \\\"Mesh refinement strategy:\\\\n\\\"\\n \\\" global: one global refinement\\\\n\\\"\\n \\\" percentage: a fixed percentage of cells gets refined using the Kelly estimator.\\\");\\n    prm.declare_entry(\\\"number of cycles\\\",\\n \\\"5\\\",\\n Patterns::Integer(),\\n \\\"Number of adaptive mesh refinement cycles to run.\\\");\\n    prm.declare_entry(\\n \\\"obstacle\\\",\\n \\\"sphere\\\",\\n Patterns::Selection(\\\"sphere|read from file\\\"),\\n \\\"The name of the obstacle to use. This may either be 'sphere' if we should \\\"\\n \\\"use a spherical obstacle, or 'read from file' in which case the obstacle \\\"\\n \\\"will be read from a file named 'obstacle.pbm' that is supposed to be in \\\"\\n \\\"ASCII PBM format.\\\");\\n    prm.declare_entry(\\n \\\"output directory\\\",\\n \\\"\\\",\\n Patterns::Anything(),\\n \\\"Directory for output files (graphical output and benchmark \\\"\\n \\\"statistics). If empty, use the current directory.\\\");\\n    prm.declare_entry(\\n \\\"transfer solution\\\",\\n \\\"false\\\",\\n Patterns::Bool(),\\n \\\"Whether the solution should be used as a starting guess \\\"\\n \\\"for the next finer mesh. If false, then the iteration starts at \\\"\\n \\\"zero on every mesh.\\\");\\n    prm.declare_entry(\\\"base mesh\\\",\\n \\\"box\\\",\\n Patterns::Selection(\\\"box|half sphere\\\"),\\n \\\"Select the shape of the domain: 'box' or 'half sphere'\\\");\\n  }\\n \\n \\n \\n template <int dim>\\n  PlasticityContactProblem<dim>::PlasticityContactProblem(\\n const ParameterHandler &prm)\\n    : mpi_communicator(MPI_COMM_WORLD)\\n    , pcout(std::cout,\\n            (Utilities::MPI::this_mpi_process(mpi_communicator) == 0))\\n    , computing_timer(MPI_COMM_WORLD,\\n                      pcout,\\n TimerOutput::never,\\n TimerOutput::wall_times)\\n \\n    , n_initial_global_refinements(\\n        prm.get_integer(\\\"number of initial refinements\\\"))\\n    , triangulation(mpi_communicator)\\n    , fe_degree(prm.get_integer(\\\"polynomial degree\\\"))\\n    , fe(FE_Q<dim>(QGaussLobatto<1>(fe_degree + 1)) ^ dim)\\n    , dof_handler(triangulation)\\n \\n    , e_modulus(200000)\\n    , nu(0.3)\\n    , gamma(0.01)\\n    , sigma_0(400.0)\\n    , constitutive_law(e_modulus, nu, sigma_0, gamma)\\n \\n    , base_mesh(prm.get(\\\"base mesh\\\"))\\n    , obstacle(prm.get(\\\"obstacle\\\") == \\\"read from file\\\" ?\\n                 static_cast<const Function<dim> *>(\\n                   new EquationData::ChineseObstacle<dim>(\\n \\\"obstacle.pbm\\\",\\n                     (base_mesh == \\\"box\\\" ? 1.0 : 0.5))) :\\n                 static_cast<const Function<dim> *>(\\n                   new EquationData::SphereObstacle<dim>(\\n                     base_mesh == \\\"box\\\" ? 1.0 : 0.5)))\\n \\n    , transfer_solution(prm.get_bool(\\\"transfer solution\\\"))\\n    , n_refinement_cycles(prm.get_integer(\\\"number of cycles\\\"))\\n    , current_refinement_cycle(0)\\n \\n  {\\n    std::string strat = prm.get(\\\"refinement strategy\\\");\\n if (strat == \\\"global\\\")\\n      refinement_strategy = RefinementStrategy::refine_global;\\n else if (strat == \\\"percentage\\\")\\n      refinement_strategy = RefinementStrategy::refine_percentage;\\n else\\n AssertThrow(false, ExcNotImplemented());\\n \\n    output_dir = prm.get(\\\"output directory\\\");\\n if (output_dir != \\\"\\\" && *(output_dir.rbegin()) != '/')\\n      output_dir += \\\"/\\\";\\n \\n if (Utilities::MPI::this_mpi_process(mpi_communicator) == 0)\\n      {\\n const int ierr = mkdir(output_dir.c_str(), 0777);\\n AssertThrow(ierr == 0 || errno == EEXIST, ExcIO());\\n      }\\n \\n    pcout << \\\"    Using output directory '\\\" << output_dir << \\\"'\\\" << std::endl;\\n    pcout << \\\"    FE degree \\\" << fe_degree << std::endl;\\n    pcout << \\\"    transfer solution \\\" << (transfer_solution ? \\\"true\\\" : \\\"false\\\")\\n          << std::endl;\\n  }\\n \\n \\n \\n \\n Point<3> rotate_half_sphere(const Point<3> &in)\\n  {\\n return {in[2], in[1], -in[0]};\\n  }\\n \\n template <int dim>\\n void PlasticityContactProblem<dim>::make_grid()\\n  {\\n if (base_mesh == \\\"half sphere\\\")\\n      {\\n const Point<dim> center(0, 0, 0);\\n const double     radius = 0.8;\\n GridGenerator::half_hyper_ball(triangulation, center, radius);\\n triangulation.reset_all_manifolds();\\n \\n GridTools::transform(&rotate_half_sphere, triangulation);\\n GridTools::shift(Point<dim>(0.5, 0.5, 0.5), triangulation);\\n \\n SphericalManifold<dim> manifold_description(Point<dim>(0.5, 0.5, 0.5));\\n GridTools::copy_boundary_to_manifold_id(triangulation);\\n triangulation.set_manifold(0, manifold_description);\\n      }\\n else\\n      {\\n const Point<dim> p1(0, 0, 0);\\n const Point<dim> p2(1.0, 1.0, 1.0);\\n \\n GridGenerator::hyper_rectangle(triangulation, p1, p2);\\n \\n for (const auto &cell : triangulation.active_cell_iterators())\\n          for (const auto &face : cell->face_iterators())\\n            if (face->at_boundary())\\n              {\\n if (std::fabs(face->center()[2] - p2[2]) < 1e-12)\\n                  face->set_boundary_id(1);\\n if (std::fabs(face->center()[0] - p1[0]) < 1e-12 ||\\n                    std::fabs(face->center()[0] - p2[0]) < 1e-12 ||\\n                    std::fabs(face->center()[1] - p1[1]) < 1e-12 ||\\n                    std::fabs(face->center()[1] - p2[1]) < 1e-12)\\n                  face->set_boundary_id(8);\\n if (std::fabs(face->center()[2] - p1[2]) < 1e-12)\\n                  face->set_boundary_id(6);\\n              }\\n      }\\n \\n triangulation.refine_global(n_initial_global_refinements);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void PlasticityContactProblem<dim>::setup_system()\\n  {\\n /* setup dofs and get index sets for locally owned and relevant dofs */\\n    {\\n TimerOutput::Scope t(computing_timer, \\\"Setup: distribute DoFs\\\");\\n      dof_handler.distribute_dofs(fe);\\n \\n      locally_owned_dofs = dof_handler.locally_owned_dofs();\\n      locally_relevant_dofs =\\n DoFTools::extract_locally_relevant_dofs(dof_handler);\\n    }\\n \\n /* setup hanging nodes and Dirichlet constraints */\\n    {\\n TimerOutput::Scope t(computing_timer, \\\"Setup: constraints\\\");\\n      constraints_hanging_nodes.reinit(locally_owned_dofs,\\n                                       locally_relevant_dofs);\\n DoFTools::make_hanging_node_constraints(dof_handler,\\n                                              constraints_hanging_nodes);\\n      constraints_hanging_nodes.close();\\n \\n      pcout << \\\"   Number of active cells: \\\"\\n            << triangulation.n_global_active_cells() << std::endl\\n            << \\\"   Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n            << std::endl;\\n \\n      compute_dirichlet_constraints();\\n    }\\n \\n /* initialization of vectors and the active set */\\n    {\\n TimerOutput::Scope t(computing_timer, \\\"Setup: vectors\\\");\\n      solution.reinit(locally_relevant_dofs, mpi_communicator);\\n      newton_rhs.reinit(locally_owned_dofs, mpi_communicator);\\n      newton_rhs_uncondensed.reinit(locally_owned_dofs, mpi_communicator);\\n      diag_mass_matrix_vector.reinit(locally_owned_dofs, mpi_communicator);\\n      fraction_of_plastic_q_points_per_cell.reinit(\\n triangulation.n_active_cells());\\n \\n      active_set.clear();\\n      active_set.set_size(dof_handler.n_dofs());\\n    }\\n \\n    {\\n TimerOutput::Scope                t(computing_timer, \\\"Setup: matrix\\\");\\n TrilinosWrappers::SparsityPattern sp(locally_owned_dofs,\\n                                           mpi_communicator);\\n \\n DoFTools::make_sparsity_pattern(dof_handler,\\n                                      sp,\\n                                      constraints_dirichlet_and_hanging_nodes,\\n false,\\n Utilities::MPI::this_mpi_process(\\n                                        mpi_communicator));\\n      sp.compress();\\n      newton_matrix.reinit(sp);\\n \\n \\n TrilinosWrappers::SparseMatrix &mass_matrix = newton_matrix;\\n \\n      assemble_mass_matrix_diagonal(mass_matrix);\\n \\n const unsigned int start = (newton_rhs.local_range().first),\\n                         end   = (newton_rhs.local_range().second);\\n for (unsigned int j = start; j < end; ++j)\\n        diag_mass_matrix_vector(j) = mass_matrix.diag_element(j);\\n      diag_mass_matrix_vector.compress(VectorOperation::insert);\\n \\n mass_matrix = 0;\\n    }\\n  }\\n \\n \\n \\n template <int dim>\\n void PlasticityContactProblem<dim>::compute_dirichlet_constraints()\\n  {\\n    constraints_dirichlet_and_hanging_nodes.reinit(locally_owned_dofs,\\n                                                   locally_relevant_dofs);\\n    constraints_dirichlet_and_hanging_nodes.merge(constraints_hanging_nodes);\\n \\n if (base_mesh == \\\"box\\\")\\n      {\\n VectorTools::interpolate_boundary_values(\\n          dof_handler,\\n          6,\\n          EquationData::BoundaryValues<dim>(),\\n          constraints_dirichlet_and_hanging_nodes,\\n ComponentMask());\\n \\n const FEValuesExtractors::Scalar x_displacement(0);\\n const FEValuesExtractors::Scalar y_displacement(1);\\n VectorTools::interpolate_boundary_values(\\n          dof_handler,\\n          8,\\n          EquationData::BoundaryValues<dim>(),\\n          constraints_dirichlet_and_hanging_nodes,\\n          (fe.component_mask(x_displacement) |\\n           fe.component_mask(y_displacement)));\\n      }\\n else\\n VectorTools::interpolate_boundary_values(\\n        dof_handler,\\n        0,\\n        EquationData::BoundaryValues<dim>(),\\n        constraints_dirichlet_and_hanging_nodes,\\n ComponentMask());\\n \\n    constraints_dirichlet_and_hanging_nodes.close();\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void PlasticityContactProblem<dim>::assemble_mass_matrix_diagonal(\\n TrilinosWrappers::SparseMatrix &mass_matrix)\\n  {\\n const QGaussLobatto<dim - 1> face_quadrature_formula(fe.degree + 1);\\n \\n FEFaceValues<dim> fe_values_face(fe,\\n                                     face_quadrature_formula,\\n update_values | update_JxW_values);\\n \\n const unsigned int dofs_per_cell   = fe.n_dofs_per_cell();\\n const unsigned int n_face_q_points = face_quadrature_formula.size();\\n \\n FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n const FEValuesExtractors::Vector displacement(0);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      if (cell->is_locally_owned())\\n        for (const auto &face : cell->face_iterators())\\n          if (face->at_boundary() && face->boundary_id() == 1)\\n            {\\n              fe_values_face.reinit(cell, face);\\n cell_matrix = 0;\\n \\n for (unsigned int q_point = 0; q_point < n_face_q_points;\\n                   ++q_point)\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n cell_matrix(i, i) +=\\n                    (fe_values_face[displacement].value(i, q_point) *\\n                     fe_values_face[displacement].value(i, q_point) *\\n                     fe_values_face.JxW(q_point));\\n \\n              cell->get_dof_indices(local_dof_indices);\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n mass_matrix.add(local_dof_indices[i],\\n                                local_dof_indices[i],\\n cell_matrix(i, i));\\n            }\\n mass_matrix.compress(VectorOperation::add);\\n  }\\n \\n \\n \\n template <int dim>\\n void PlasticityContactProblem<dim>::update_solution_and_constraints()\\n  {\\n    std::vector<bool> dof_touched(dof_handler.n_dofs(), false);\\n \\n TrilinosWrappers::MPI::Vector distributed_solution(locally_owned_dofs,\\n                                                       mpi_communicator);\\n    distributed_solution = solution;\\n \\n TrilinosWrappers::MPI::Vector lambda(locally_relevant_dofs,\\n                                         mpi_communicator);\\n lambda = newton_rhs_uncondensed;\\n \\n TrilinosWrappers::MPI::Vector diag_mass_matrix_vector_relevant(\\n      locally_relevant_dofs, mpi_communicator);\\n    diag_mass_matrix_vector_relevant = diag_mass_matrix_vector;\\n \\n \\n    all_constraints.reinit(locally_owned_dofs, locally_relevant_dofs);\\n    active_set.clear();\\n \\n const Quadrature<dim - 1> face_quadrature(\\n      fe.get_unit_face_support_points());\\n FEFaceValues<dim> fe_values_face(fe,\\n                                     face_quadrature,\\n update_quadrature_points);\\n \\n const unsigned int dofs_per_face   = fe.n_dofs_per_face();\\n const unsigned int n_face_q_points = face_quadrature.size();\\n \\n    std::vector<types::global_dof_index> dof_indices(dofs_per_face);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      if (!cell->is_artificial())\\n        for (const auto &face : cell->face_iterators())\\n          if (face->at_boundary() && face->boundary_id() == 1)\\n            {\\n              fe_values_face.reinit(cell, face);\\n              face->get_dof_indices(dof_indices);\\n \\n for (unsigned int q_point = 0; q_point < n_face_q_points;\\n                   ++q_point)\\n                {\\n const unsigned int component =\\n                    fe.face_system_to_component_index(q_point).first;\\n \\n const unsigned int index_z = dof_indices[q_point];\\n \\n if ((component == 2) && (dof_touched[index_z] == false))\\n                    {\\n                      dof_touched[index_z] = true;\\n \\n const Point<dim> this_support_point =\\n                        fe_values_face.quadrature_point(q_point);\\n \\n const double obstacle_value =\\n                        obstacle->value(this_support_point, 2);\\n const double solution_here = solution(index_z);\\n const double undeformed_gap =\\n                        obstacle_value - this_support_point[2];\\n \\n const double c = 100.0 * e_modulus;\\n if ((lambda(index_z) /\\n                               diag_mass_matrix_vector_relevant(index_z) +\\n                             c * (solution_here - undeformed_gap) >\\n                           0) &&\\n                          !constraints_hanging_nodes.is_constrained(index_z))\\n                        {\\n                          all_constraints.add_constraint(index_z,\\n                                                         {},\\n                                                         undeformed_gap);\\n                          distributed_solution(index_z) = undeformed_gap;\\n \\n                          active_set.add_index(index_z);\\n                        }\\n                    }\\n                }\\n            }\\n \\n    distributed_solution.compress(VectorOperation::insert);\\n    solution = distributed_solution;\\n \\n    all_constraints.close();\\n    all_constraints.merge(constraints_dirichlet_and_hanging_nodes);\\n \\n    pcout << \\\"         Size of active set: \\\"\\n          << Utilities::MPI::sum((active_set & locally_owned_dofs).n_elements(),\\n                                 mpi_communicator)\\n          << std::endl;\\n  }\\n \\n \\n \\n template <int dim>\\n void PlasticityContactProblem<dim>::assemble_newton_system(\\n const TrilinosWrappers::MPI::Vector &linearization_point)\\n  {\\n TimerOutput::Scope t(computing_timer, \\\"Assembling\\\");\\n \\n const QGauss<dim>     quadrature_formula(fe.degree + 1);\\n const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);\\n \\n FEValues<dim> fe_values(fe,\\n                            quadrature_formula,\\n update_values | update_gradients |\\n update_JxW_values);\\n \\n FEFaceValues<dim> fe_values_face(fe,\\n                                     face_quadrature_formula,\\n update_values | update_quadrature_points |\\n update_JxW_values);\\n \\n const unsigned int dofs_per_cell   = fe.n_dofs_per_cell();\\n const unsigned int n_q_points      = quadrature_formula.size();\\n const unsigned int n_face_q_points = face_quadrature_formula.size();\\n \\n const EquationData::BoundaryForce<dim> boundary_force;\\n    std::vector<Vector<double>> boundary_force_values(n_face_q_points,\\n Vector<double>(dim));\\n \\n FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n Vector<double>     cell_rhs(dofs_per_cell);\\n \\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n const FEValuesExtractors::Vector displacement(0);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      if (cell->is_locally_owned())\\n        {\\n          fe_values.reinit(cell);\\n cell_matrix = 0;\\n          cell_rhs    = 0;\\n \\n          std::vector<SymmetricTensor<2, dim>> strain_tensor(n_q_points);\\n          fe_values[displacement].get_function_symmetric_gradients(\\n            linearization_point, strain_tensor);\\n \\n for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n            {\\n SymmetricTensor<4, dim> stress_strain_tensor_linearized;\\n SymmetricTensor<4, dim> stress_strain_tensor;\\n              constitutive_law.get_linearized_stress_strain_tensors(\\n                strain_tensor[q_point],\\n                stress_strain_tensor_linearized,\\n                stress_strain_tensor);\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n                {\\n const SymmetricTensor<2, dim> stress_phi_i =\\n                    stress_strain_tensor_linearized *\\n                    fe_values[displacement].symmetric_gradient(i, q_point);\\n \\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n cell_matrix(i, j) +=\\n                      (stress_phi_i *\\n                       fe_values[displacement].symmetric_gradient(j, q_point) *\\n                       fe_values.JxW(q_point));\\n \\n                  cell_rhs(i) +=\\n                    ((stress_phi_i -\\n                      stress_strain_tensor *\\n                        fe_values[displacement].symmetric_gradient(i,\\n                                                                   q_point)) *\\n                     strain_tensor[q_point] * fe_values.JxW(q_point));\\n                }\\n            }\\n \\n for (const auto &face : cell->face_iterators())\\n            if (face->at_boundary() && face->boundary_id() == 1)\\n              {\\n                fe_values_face.reinit(cell, face);\\n \\n                boundary_force.vector_value_list(\\n                  fe_values_face.get_quadrature_points(),\\n                  boundary_force_values);\\n \\n for (unsigned int q_point = 0; q_point < n_face_q_points;\\n                     ++q_point)\\n                  {\\n Tensor<1, dim> rhs_values;\\n                    rhs_values[2] = boundary_force_values[q_point][2];\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n                      cell_rhs(i) +=\\n                        (fe_values_face[displacement].value(i, q_point) *\\n                         rhs_values * fe_values_face.JxW(q_point));\\n                  }\\n              }\\n \\n          cell->get_dof_indices(local_dof_indices);\\n          all_constraints.distribute_local_to_global(cell_matrix,\\n                                                     cell_rhs,\\n                                                     local_dof_indices,\\n                                                     newton_matrix,\\n                                                     newton_rhs,\\n true);\\n        }\\n \\n    newton_matrix.compress(VectorOperation::add);\\n    newton_rhs.compress(VectorOperation::add);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void PlasticityContactProblem<dim>::compute_nonlinear_residual(\\n const TrilinosWrappers::MPI::Vector &linearization_point)\\n  {\\n const QGauss<dim>     quadrature_formula(fe.degree + 1);\\n const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);\\n \\n FEValues<dim> fe_values(fe,\\n                            quadrature_formula,\\n update_values | update_gradients |\\n update_JxW_values);\\n \\n FEFaceValues<dim> fe_values_face(fe,\\n                                     face_quadrature_formula,\\n update_values | update_quadrature_points |\\n update_JxW_values);\\n \\n const unsigned int dofs_per_cell   = fe.n_dofs_per_cell();\\n const unsigned int n_q_points      = quadrature_formula.size();\\n const unsigned int n_face_q_points = face_quadrature_formula.size();\\n \\n const EquationData::BoundaryForce<dim> boundary_force;\\n    std::vector<Vector<double>> boundary_force_values(n_face_q_points,\\n Vector<double>(dim));\\n \\n Vector<double> cell_rhs(dofs_per_cell);\\n \\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n const FEValuesExtractors::Vector displacement(0);\\n \\n    newton_rhs             = 0;\\n    newton_rhs_uncondensed = 0;\\n \\n    fraction_of_plastic_q_points_per_cell = 0;\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      if (cell->is_locally_owned())\\n        {\\n          fe_values.reinit(cell);\\n          cell_rhs = 0;\\n \\n          std::vector<SymmetricTensor<2, dim>> strain_tensors(n_q_points);\\n          fe_values[displacement].get_function_symmetric_gradients(\\n            linearization_point, strain_tensors);\\n \\n for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n            {\\n SymmetricTensor<4, dim> stress_strain_tensor;\\n const bool              q_point_is_plastic =\\n                constitutive_law.get_stress_strain_tensor(\\n                  strain_tensors[q_point], stress_strain_tensor);\\n if (q_point_is_plastic)\\n                ++fraction_of_plastic_q_points_per_cell(\\n                  cell->active_cell_index());\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n                {\\n                  cell_rhs(i) -=\\n                    (strain_tensors[q_point] * stress_strain_tensor *\\n                     fe_values[displacement].symmetric_gradient(i, q_point) *\\n                     fe_values.JxW(q_point));\\n \\n Tensor<1, dim> rhs_values;\\n                  rhs_values = 0;\\n                  cell_rhs(i) += (fe_values[displacement].value(i, q_point) *\\n                                  rhs_values * fe_values.JxW(q_point));\\n                }\\n            }\\n \\n for (const auto &face : cell->face_iterators())\\n            if (face->at_boundary() && face->boundary_id() == 1)\\n              {\\n                fe_values_face.reinit(cell, face);\\n \\n                boundary_force.vector_value_list(\\n                  fe_values_face.get_quadrature_points(),\\n                  boundary_force_values);\\n \\n for (unsigned int q_point = 0; q_point < n_face_q_points;\\n                     ++q_point)\\n                  {\\n Tensor<1, dim> rhs_values;\\n                    rhs_values[2] = boundary_force_values[q_point][2];\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n                      cell_rhs(i) +=\\n                        (fe_values_face[displacement].value(i, q_point) *\\n                         rhs_values * fe_values_face.JxW(q_point));\\n                  }\\n              }\\n \\n          cell->get_dof_indices(local_dof_indices);\\n          constraints_dirichlet_and_hanging_nodes.distribute_local_to_global(\\n            cell_rhs, local_dof_indices, newton_rhs);\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n            newton_rhs_uncondensed(local_dof_indices[i]) += cell_rhs(i);\\n        }\\n \\n    fraction_of_plastic_q_points_per_cell /= quadrature_formula.size();\\n    newton_rhs.compress(VectorOperation::add);\\n    newton_rhs_uncondensed.compress(VectorOperation::add);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void PlasticityContactProblem<dim>::solve_newton_system()\\n  {\\n TimerOutput::Scope t(computing_timer, \\\"Solve\\\");\\n \\n TrilinosWrappers::MPI::Vector distributed_solution(locally_owned_dofs,\\n                                                       mpi_communicator);\\n    distributed_solution = solution;\\n \\n    constraints_hanging_nodes.set_zero(distributed_solution);\\n    constraints_hanging_nodes.set_zero(newton_rhs);\\n \\n TrilinosWrappers::PreconditionAMG preconditioner;\\n    {\\n TimerOutput::Scope t(computing_timer, \\\"Solve: setup preconditioner\\\");\\n \\n      std::vector<std::vector<bool>> constant_modes;\\n DoFTools::extract_constant_modes(dof_handler,\\n ComponentMask(),\\n                                       constant_modes);\\n \\n TrilinosWrappers::PreconditionAMG::AdditionalData additional_data;\\n      additional_data.constant_modes        = constant_modes;\\n      additional_data.elliptic              = true;\\n      additional_data.n_cycles              = 1;\\n      additional_data.w_cycle               = false;\\n      additional_data.output_details        = false;\\n      additional_data.smoother_sweeps       = 2;\\n      additional_data.aggregation_threshold = 1e-2;\\n \\n      preconditioner.initialize(newton_matrix, additional_data);\\n    }\\n \\n    {\\n TimerOutput::Scope t(computing_timer, \\\"Solve: iterate\\\");\\n \\n TrilinosWrappers::MPI::Vector tmp(locally_owned_dofs, mpi_communicator);\\n \\n const double relative_accuracy = 1e-8;\\n const double solver_tolerance =\\n        relative_accuracy *\\n        newton_matrix.residual(tmp, distributed_solution, newton_rhs);\\n \\n SolverControl solver_control(newton_matrix.m(), solver_tolerance);\\n SolverBicgstab<TrilinosWrappers::MPI::Vector> solver(solver_control);\\n      solver.solve(newton_matrix,\\n                   distributed_solution,\\n                   newton_rhs,\\n                   preconditioner);\\n \\n      pcout << \\\"         Error: \\\" << solver_control.initial_value() << \\\" -> \\\"\\n            << solver_control.last_value() << \\\" in \\\"\\n            << solver_control.last_step() << \\\" Bicgstab iterations.\\\"\\n            << std::endl;\\n    }\\n \\n    all_constraints.distribute(distributed_solution);\\n \\n    solution = distributed_solution;\\n  }\\n \\n \\n \\n template <int dim>\\n void PlasticityContactProblem<dim>::solve_newton()\\n  {\\n TrilinosWrappers::MPI::Vector old_solution(locally_owned_dofs,\\n                                               mpi_communicator);\\n TrilinosWrappers::MPI::Vector residual(locally_owned_dofs,\\n                                           mpi_communicator);\\n TrilinosWrappers::MPI::Vector tmp_vector(locally_owned_dofs,\\n                                             mpi_communicator);\\n TrilinosWrappers::MPI::Vector locally_relevant_tmp_vector(\\n      locally_relevant_dofs, mpi_communicator);\\n TrilinosWrappers::MPI::Vector distributed_solution(locally_owned_dofs,\\n                                                       mpi_communicator);\\n \\n double residual_norm;\\n double previous_residual_norm = -std::numeric_limits<double>::max();\\n \\n const double correct_sigma = sigma_0;\\n \\n IndexSet old_active_set(active_set);\\n \\n for (unsigned int newton_step = 1; newton_step <= 100; ++newton_step)\\n      {\\n if (newton_step == 1 &&\\n            ((transfer_solution && current_refinement_cycle == 0) ||\\n             !transfer_solution))\\n          constitutive_law.set_sigma_0(1e+10);\\n else if (newton_step == 2 || current_refinement_cycle > 0 ||\\n                 !transfer_solution)\\n          constitutive_law.set_sigma_0(correct_sigma);\\n \\n        pcout << ' ' << std::endl;\\n        pcout << \\\"   Newton iteration \\\" << newton_step << std::endl;\\n        pcout << \\\"      Updating active set...\\\" << std::endl;\\n \\n        {\\n TimerOutput::Scope t(computing_timer, \\\"update active set\\\");\\n          update_solution_and_constraints();\\n        }\\n \\n        pcout << \\\"      Assembling system... \\\" << std::endl;\\n        newton_matrix = 0;\\n        newton_rhs    = 0;\\n        assemble_newton_system(solution);\\n \\n        pcout << \\\"      Solving system... \\\" << std::endl;\\n        solve_newton_system();\\n \\n if ((newton_step == 1) ||\\n            (transfer_solution && newton_step == 2 &&\\n             current_refinement_cycle == 0) ||\\n            (!transfer_solution && newton_step == 2))\\n          {\\n            compute_nonlinear_residual(solution);\\n            old_solution = solution;\\n \\n            residual                     = newton_rhs;\\n const unsigned int start_res = (residual.local_range().first),\\n                               end_res   = (residual.local_range().second);\\n for (unsigned int n = start_res; n < end_res; ++n)\\n if (all_constraints.is_inhomogeneously_constrained(n))\\n                residual(n) = 0;\\n \\n            residual.compress(VectorOperation::insert);\\n \\n            residual_norm = residual.l2_norm();\\n \\n            pcout << \\\"      Accepting Newton solution with residual: \\\"\\n                  << residual_norm << std::endl;\\n          }\\n else\\n          {\\n for (unsigned int i = 0; i < 5; ++i)\\n              {\\n                distributed_solution = solution;\\n \\n const double alpha = std::pow(0.5, static_cast<double>(i));\\n                tmp_vector         = old_solution;\\n                tmp_vector.sadd(1 - alpha, alpha, distributed_solution);\\n \\n TimerOutput::Scope t(computing_timer, \\\"Residual and lambda\\\");\\n \\n                locally_relevant_tmp_vector = tmp_vector;\\n                compute_nonlinear_residual(locally_relevant_tmp_vector);\\n                residual = newton_rhs;\\n \\n const unsigned int start_res = (residual.local_range().first),\\n                                   end_res   = (residual.local_range().second);\\n for (unsigned int n = start_res; n < end_res; ++n)\\n if (all_constraints.is_inhomogeneously_constrained(n))\\n                    residual(n) = 0;\\n \\n                residual.compress(VectorOperation::insert);\\n \\n                residual_norm = residual.l2_norm();\\n \\n                pcout\\n                  << \\\"      Residual of the non-contact part of the system: \\\"\\n                  << residual_norm << std::endl\\n                  << \\\"         with a damping parameter alpha = \\\" << alpha\\n                  << std::endl;\\n \\n if (residual_norm < previous_residual_norm)\\n break;\\n              }\\n \\n            solution     = tmp_vector;\\n            old_solution = solution;\\n          }\\n \\n        previous_residual_norm = residual_norm;\\n \\n \\n if (Utilities::MPI::sum((active_set == old_active_set) ? 0 : 1,\\n                                mpi_communicator) == 0)\\n          {\\n            pcout << \\\"      Active set did not change!\\\" << std::endl;\\n if (residual_norm < 1e-10)\\n break;\\n          }\\n \\n        old_active_set = active_set;\\n      }\\n  }\\n \\n \\n template <int dim>\\n void PlasticityContactProblem<dim>::refine_grid()\\n  {\\n if (refinement_strategy == RefinementStrategy::refine_global)\\n      {\\n for (typename Triangulation<dim>::active_cell_iterator cell =\\n triangulation.begin_active();\\n             cell != triangulation.end();\\n             ++cell)\\n if (cell->is_locally_owned())\\n            cell->set_refine_flag();\\n      }\\n else\\n      {\\n Vector<float> estimated_error_per_cell(triangulation.n_active_cells());\\n KellyErrorEstimator<dim>::estimate(\\n          dof_handler,\\n QGauss<dim - 1>(fe.degree + 2),\\n          std::map<types::boundary_id, const Function<dim> *>(),\\n          solution,\\n          estimated_error_per_cell);\\n \\n        parallel::distributed::GridRefinement ::refine_and_coarsen_fixed_number(\\n triangulation, estimated_error_per_cell, 0.3, 0.03);\\n      }\\n \\n triangulation.prepare_coarsening_and_refinement();\\n \\n parallel::distributed::SolutionTransfer<dim, TrilinosWrappers::MPI::Vector>\\n      solution_transfer(dof_handler);\\n if (transfer_solution)\\n      solution_transfer.prepare_for_coarsening_and_refinement(solution);\\n \\n triangulation.execute_coarsening_and_refinement();\\n \\n    setup_system();\\n \\n if (transfer_solution)\\n      {\\n TrilinosWrappers::MPI::Vector distributed_solution(locally_owned_dofs,\\n                                                           mpi_communicator);\\n        solution_transfer.interpolate(distributed_solution);\\n \\n        constraints_hanging_nodes.distribute(distributed_solution);\\n \\n        solution = distributed_solution;\\n        compute_nonlinear_residual(solution);\\n      }\\n  }\\n \\n \\n \\n template <int dim>\\n void PlasticityContactProblem<dim>::move_mesh(\\n const TrilinosWrappers::MPI::Vector &displacement) const\\n {\\n    std::vector<bool> vertex_touched(triangulation.n_vertices(), false);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      if (cell->is_locally_owned())\\n        for (const auto v : cell->vertex_indices())\\n          if (vertex_touched[cell->vertex_index(v)] == false)\\n            {\\n              vertex_touched[cell->vertex_index(v)] = true;\\n \\n Point<dim> vertex_displacement;\\n for (unsigned int d = 0; d < dim; ++d)\\n                vertex_displacement[d] =\\n                  displacement(cell->vertex_dof_index(v, d));\\n \\n              cell->vertex(v) += vertex_displacement;\\n            }\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void PlasticityContactProblem<dim>::output_results(\\n const unsigned int current_refinement_cycle)\\n  {\\n TimerOutput::Scope t(computing_timer, \\\"Graphical output\\\");\\n \\n    pcout << \\\"      Writing graphical output... \\\" << std::flush;\\n \\n    move_mesh(solution);\\n \\n TrilinosWrappers::MPI::Vector distributed_lambda(locally_owned_dofs,\\n                                                     mpi_communicator);\\n const unsigned int start_res = (newton_rhs_uncondensed.local_range().first),\\n                       end_res = (newton_rhs_uncondensed.local_range().second);\\n for (unsigned int n = start_res; n < end_res; ++n)\\n if (all_constraints.is_inhomogeneously_constrained(n))\\n        distributed_lambda(n) =\\n          newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n);\\n    distributed_lambda.compress(VectorOperation::insert);\\n    constraints_hanging_nodes.distribute(distributed_lambda);\\n \\n TrilinosWrappers::MPI::Vector lambda(locally_relevant_dofs,\\n                                         mpi_communicator);\\n lambda = distributed_lambda;\\n \\n TrilinosWrappers::MPI::Vector distributed_active_set_vector(\\n      locally_owned_dofs, mpi_communicator);\\n    distributed_active_set_vector = 0.;\\n for (const auto index : active_set)\\n      distributed_active_set_vector[index] = 1.;\\n    distributed_lambda.compress(VectorOperation::insert);\\n \\n TrilinosWrappers::MPI::Vector active_set_vector(locally_relevant_dofs,\\n                                                    mpi_communicator);\\n    active_set_vector = distributed_active_set_vector;\\n \\n DataOut<dim> data_out;\\n \\n    data_out.attach_dof_handler(dof_handler);\\n \\n const std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n      data_component_interpretation(\\n        dim, DataComponentInterpretation::component_is_part_of_vector);\\n    data_out.add_data_vector(solution,\\n                             std::vector<std::string>(dim, \\\"displacement\\\"),\\n DataOut<dim>::type_dof_data,\\n                             data_component_interpretation);\\n    data_out.add_data_vector(lambda,\\n                             std::vector<std::string>(dim, \\\"contact_force\\\"),\\n DataOut<dim>::type_dof_data,\\n                             data_component_interpretation);\\n    data_out.add_data_vector(active_set_vector,\\n                             std::vector<std::string>(dim, \\\"active_set\\\"),\\n DataOut<dim>::type_dof_data,\\n                             data_component_interpretation);\\n \\n Vector<float> subdomain(triangulation.n_active_cells());\\n for (unsigned int i = 0; i < subdomain.size(); ++i)\\n      subdomain(i) = triangulation.locally_owned_subdomain();\\n    data_out.add_data_vector(subdomain, \\\"subdomain\\\");\\n \\n    data_out.add_data_vector(fraction_of_plastic_q_points_per_cell,\\n \\\"fraction_of_plastic_q_points\\\");\\n \\n    data_out.build_patches();\\n \\n const std::string pvtu_filename = data_out.write_vtu_with_pvtu_record(\\n      output_dir, \\\"solution\\\", current_refinement_cycle, mpi_communicator, 2);\\n    pcout << pvtu_filename << std::endl;\\n \\n TrilinosWrappers::MPI::Vector tmp(solution);\\n    tmp *= -1;\\n    move_mesh(tmp);\\n  }\\n \\n \\n \\n template <int dim>\\n void PlasticityContactProblem<dim>::output_contact_force() const\\n {\\n TrilinosWrappers::MPI::Vector distributed_lambda(locally_owned_dofs,\\n                                                     mpi_communicator);\\n const unsigned int start_res = (newton_rhs_uncondensed.local_range().first),\\n                       end_res = (newton_rhs_uncondensed.local_range().second);\\n for (unsigned int n = start_res; n < end_res; ++n)\\n if (all_constraints.is_inhomogeneously_constrained(n))\\n        distributed_lambda(n) =\\n          newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n);\\n else\\n        distributed_lambda(n) = 0;\\n    distributed_lambda.compress(VectorOperation::insert);\\n    constraints_hanging_nodes.distribute(distributed_lambda);\\n \\n TrilinosWrappers::MPI::Vector lambda(locally_relevant_dofs,\\n                                         mpi_communicator);\\n lambda = distributed_lambda;\\n \\n double contact_force = 0.0;\\n \\n const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);\\n FEFaceValues<dim>     fe_values_face(fe,\\n                                     face_quadrature_formula,\\n update_values | update_JxW_values);\\n \\n const unsigned int n_face_q_points = face_quadrature_formula.size();\\n \\n const FEValuesExtractors::Vector displacement(0);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      if (cell->is_locally_owned())\\n        for (const auto &face : cell->face_iterators())\\n          if (face->at_boundary() && face->boundary_id() == 1)\\n            {\\n              fe_values_face.reinit(cell, face);\\n \\n              std::vector<Tensor<1, dim>> lambda_values(n_face_q_points);\\n              fe_values_face[displacement].get_function_values(lambda,\\n                                                               lambda_values);\\n \\n for (unsigned int q_point = 0; q_point < n_face_q_points;\\n                   ++q_point)\\n                contact_force +=\\n                  lambda_values[q_point][2] * fe_values_face.JxW(q_point);\\n            }\\n    contact_force = Utilities::MPI::sum(contact_force, MPI_COMM_WORLD);\\n \\n    pcout << \\\"Contact force = \\\" << contact_force << std::endl;\\n  }\\n \\n \\n \\n template <int dim>\\n void PlasticityContactProblem<dim>::run()\\n  {\\n    computing_timer.reset();\\n for (; current_refinement_cycle < n_refinement_cycles;\\n         ++current_refinement_cycle)\\n      {\\n        {\\n TimerOutput::Scope t(computing_timer, \\\"Setup\\\");\\n \\n          pcout << std::endl;\\n          pcout << \\\"Cycle \\\" << current_refinement_cycle << ':' << std::endl;\\n \\n if (current_refinement_cycle == 0)\\n            {\\n              make_grid();\\n              setup_system();\\n            }\\n else\\n            {\\n TimerOutput::Scope t(computing_timer, \\\"Setup: refine mesh\\\");\\n              refine_grid();\\n            }\\n        }\\n \\n        solve_newton();\\n \\n        output_results(current_refinement_cycle);\\n \\n        computing_timer.print_summary();\\n        computing_timer.reset();\\n \\n Utilities::System::MemoryStats stats;\\n Utilities::System::get_memory_stats(stats);\\n        pcout << \\\"Peak virtual memory used, resident in kB: \\\" << stats.VmSize\\n              << ' ' << stats.VmRSS << std::endl;\\n \\n if (base_mesh == \\\"box\\\")\\n          output_contact_force();\\n      }\\n  }\\n} // namespace Step42\\n \\n \\nint main(int argc, char *argv[])\\n{\\n using namespace dealii;\\n using namespace Step42;\\n \\n try\\n    {\\n ParameterHandler prm;\\n      PlasticityContactProblem<3>::declare_parameters(prm);\\n if (argc != 2)\\n        {\\n          std::cerr << \\\"*** Call this program as <./step-42 input.prm>\\\"\\n                    << std::endl;\\n return 1;\\n        }\\n \\n      prm.parse_input(argv[1]);\\n Utilities::MPI::MPI_InitFinalize mpi_initialization(\\n        argc, argv, numbers::invalid_unsigned_int);\\n      {\\n        PlasticityContactProblem<3> problem(prm);\\n        problem.run();\\n      }\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n \\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n \\n return 0;\\n}\\naffine_constraints.h\\nblock_sparsity_pattern.h\\nDataOutInterface::write_vtu_with_pvtu_recordstd::string write_vtu_with_pvtu_record(const std::string &directory, const std::string &filename_without_extension, const unsigned int counter, const MPI_Comm mpi_communicator, const unsigned int n_digits_for_counter=numbers::invalid_unsigned_int, const unsigned int n_groups=0) constDefinition data_out_base.cc:7854\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nParameterHandler::parse_inputvirtual void parse_input(std::istream &input, const std::string &filename=\\\"input file\\\", const std::string &last_line=\\\"\\\", const bool skip_undefined=false)Definition parameter_handler.cc:433\\nParameterHandler::getstd::string get(const std::string &entry_string) constDefinition parameter_handler.cc:1049\\nSymmetricTensor::normDEAL_II_HOST constexpr numbers::NumberTraits< Number >::real_type norm() const\\nTrilinosWrappers::PreconditionAMG::initializevoid initialize(const SparseMatrix &matrix, const AdditionalData &additional_data=AdditionalData())Definition trilinos_precondition_ml.cc:221\\nconditional_ostream.h\\ngrid_refinement.h\\nsolution_transfer.h\\ntria.h\\ndof_handler.h\\ndof_renumbering.h\\ndof_tools.h\\nerror_estimator.h\\nfe_values.h\\nfe_field_function.h\\nfe_q.h\\nfe_system.h\\nfull_matrix.h\\nfunction.h\\nmanifold_lib.h\\ntria.h\\ngrid_generator.h\\ngrid_tools.h\\nutilities.h\\nindex_set.h\\nDifferentiation::SD::OptimizerType::lambda@ lambda\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\nLocalIntegrators::L2::mass_matrixvoid mass_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const double factor=1.)Definition l2.h:57\\nPhysics::Elasticity::Kinematics::eSymmetricTensor< 2, dim, Number > e(const Tensor< 2, dim, Number > &F)\\nPhysics::Elasticity::Kinematics::dSymmetricTensor< 2, dim, Number > d(const Tensor< 2, dim, Number > &F, const Tensor< 2, dim, Number > &dF_dt)\\nTrilinosWrappers::internal::endVectorType::value_type * end(VectorType &V)Definition trilinos_sparse_matrix.cc:64\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\ninternal::QGaussLobatto::gammalong double gamma(const unsigned int n)Definition quadrature_lib.cc:103\\ninternal::VectorizationTypes::index@ index\\ndata_out.h\\nparameter_handler.h\\nprecondition.h\\nquadrature_lib.h\\nsolver_bicgstab.h\\nsparse_matrix.h\\nsparsity_tools.h\\nTrilinosWrappers::PreconditionAMG::AdditionalData::aggregation_thresholddouble aggregation_thresholdDefinition trilinos_precondition.h:1474\\nTrilinosWrappers::PreconditionAMG::AdditionalData::n_cyclesunsigned int n_cyclesDefinition trilinos_precondition.h:1457\\nTrilinosWrappers::PreconditionAMG::AdditionalData::w_cyclebool w_cycleDefinition trilinos_precondition.h:1463\\nTrilinosWrappers::PreconditionAMG::AdditionalData::smoother_sweepsunsigned int smoother_sweepsDefinition trilinos_precondition.h:1512\\nTrilinosWrappers::PreconditionAMG::AdditionalData::ellipticbool ellipticDefinition trilinos_precondition.h:1445\\nTrilinosWrappers::PreconditionAMG::AdditionalData::output_detailsbool output_detailsDefinition trilinos_precondition.h:1525\\nUtilities::System::MemoryStats::VmRSSunsigned long int VmRSSDefinition utilities.h:884\\nUtilities::System::MemoryStats::VmSizeunsigned long int VmSizeDefinition utilities.h:873\\ntimer.h\\ntrilinos_block_sparse_matrix.h\\ntrilinos_parallel_block_vector.h\\ntrilinos_precondition.h\\ntrilinos_solver.h\\ntrilinos_sparse_matrix.h\\ntrilinos_vector.h\\nvector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"