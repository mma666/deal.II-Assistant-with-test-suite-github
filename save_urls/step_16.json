"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_16.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-16 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-16 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-16 tutorial program\\n\\n\\nThis tutorial depends on step-6.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nThe testcase\\n\\n The commented program\\n\\nInclude files\\nThe Scratch and Copy objects\\nThe LaplaceProblem class template\\nThe LaplaceProblem class implementation\\n\\nLaplaceProblem::setup_system\\nLaplaceProblem::cell_worker\\nLaplaceProblem::assemble_system\\nLaplaceProblem::assemble_multigrid\\nLaplaceProblem::solve\\nPostprocessing\\nLaplaceProblem::run\\n\\nThe main() function\\n\\n\\n Results\\n\\n Possibilities for extensions \\n\\n The plain program\\n   \\n\\n\\n Introduction\\nThis example shows the basic usage of the multilevel functions in deal.II. It solves almost the same problem as used in step-6, but demonstrating the things one has to provide when using multigrid as a preconditioner. In particular, this requires that we define a hierarchy of levels, provide transfer operators from one level to the next and back, and provide representations of the Laplace operator on each level.\\nIn order to allow sufficient flexibility in conjunction with systems of differential equations and block preconditioners, quite a few different objects have to be created before starting the multilevel method, although most of what needs to be done is provided by deal.II itself. These are\\nthe object handling transfer between grids; we use the MGTransferPrebuilt class for this that does almost all of the work inside the library,\\nthe solver on the coarsest level; here, we use MGCoarseGridHouseholder,\\nthe smoother on all other levels, which in our case will be the mg::SmootherRelaxation class using SOR as the underlying method,\\nand mg::Matrix, a class having a special level multiplication, i.e. we basically store one matrix per grid level and allow multiplication with it.\\n\\nMost of these objects will only be needed inside the function that actually solves the linear system. There, these objects are combined in an object of type Multigrid, containing the implementation of the V-cycle, which is in turn used by the preconditioner PreconditionMG, ready for plug-in into a linear solver of the LAC library.\\nThe multigrid method implemented here for adaptively refined meshes follows the outline in the Multigrid paper, which describes the underlying implementation in deal.II and also introduces a lot of the nomenclature. First, we have to distinguish between level meshes, namely cells that have the same refinement distance from the coarse mesh, and the leaf mesh consisting of active cells of the hierarchy (in older work we refer to this as the global mesh, but this term is overused). Most importantly, the leaf mesh is not identical with the level mesh on the finest level. The following image shows what we consider to be a \\\"level mesh\\\":\\n\\n\\n\\n\\nThe fine level in this mesh consists only of the degrees of freedom that are defined on the refined cells, but does not extend to that part of the domain that is not refined. While this guarantees that the overall effort grows as \\\\({\\\\cal O}(N)\\\\) as necessary for optimal multigrid complexity, it leads to problems when defining where to smooth and what boundary conditions to pose for the operators defined on individual levels if the level boundary is not an external boundary. These questions are discussed in detail in the article cited above.\\nThe testcase\\nThe problem we solve here is similar to step-6, with two main differences: first, the multigrid preconditioner, obviously. We also change the discontinuity of the coefficients such that the local assembler does not look more complicated than necessary.\\n The commented program\\n Include files\\nAgain, the first few include files are already known, so we won't comment on them:\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/base/utilities.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/solver_cg.h>\\n\\u00a0 #include <deal.II/lac/precondition.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_refinement.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 #include <deal.II/fe/mapping_q1.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/error_estimator.h>\\n\\u00a0 \\nThese, now, are the include necessary for the multilevel methods. The first one declares how to handle Dirichlet boundary conditions on each of the levels of the multigrid method. For the actual description of the degrees of freedom, we do not need any new include file because DoFHandler already has all necessary methods implemented. We will only need to distribute the DoFs for the levels further down.\\nThe rest of the include files deals with the mechanics of multigrid as a linear operator (solver or preconditioner).\\n\\u00a0 #include <deal.II/multigrid/mg_constrained_dofs.h>\\n\\u00a0 #include <deal.II/multigrid/multigrid.h>\\n\\u00a0 #include <deal.II/multigrid/mg_transfer.h>\\n\\u00a0 #include <deal.II/multigrid/mg_tools.h>\\n\\u00a0 #include <deal.II/multigrid/mg_coarse.h>\\n\\u00a0 #include <deal.II/multigrid/mg_smoother.h>\\n\\u00a0 #include <deal.II/multigrid/mg_matrix.h>\\n\\u00a0 \\nWe will be using MeshWorker::mesh_loop to loop over the cells, so include it here:\\n\\u00a0 #include <deal.II/meshworker/mesh_loop.h>\\n\\u00a0 \\n\\u00a0 \\nThis is C++:\\n\\u00a0 #include <iostream>\\n\\u00a0 #include <fstream>\\n\\u00a0 \\n\\u00a0 using namespace dealii;\\n\\u00a0 \\n\\u00a0 namespace Step16\\n\\u00a0 {\\ndealiiDefinition namespace_dealii.h:25\\n The Scratch and Copy objects\\nWe use MeshWorker::mesh_loop() to assemble our matrices. For this, we need a ScratchData object to store temporary data on each cell (this is just the FEValues object) and a CopyData object that will contain the output of each cell assembly. For more details about the usage of scratch and copy objects, see the WorkStream namespace.\\n\\u00a0   template <int dim>\\n\\u00a0   struct ScratchData\\n\\u00a0   {\\n\\u00a0     ScratchData(const Mapping<dim>       &mapping,\\n\\u00a0                 const FiniteElement<dim> &fe,\\n\\u00a0                 const unsigned int        quadrature_degree,\\n\\u00a0                 const UpdateFlags         update_flags)\\n\\u00a0       : fe_values(mapping, fe, QGauss<dim>(quadrature_degree), update_flags)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     ScratchData(const ScratchData<dim> &scratch_data)\\n\\u00a0       : fe_values(scratch_data.fe_values.get_mapping(),\\n\\u00a0                   scratch_data.fe_values.get_fe(),\\n\\u00a0                   scratch_data.fe_values.get_quadrature(),\\n\\u00a0                   scratch_data.fe_values.get_update_flags())\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     FEValues<dim> fe_values;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0   struct CopyData\\n\\u00a0   {\\n\\u00a0     unsigned int level;\\n\\u00a0     FullMatrix<double>                   cell_matrix;\\n\\u00a0     Vector<double>                       cell_rhs;\\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices;\\n\\u00a0 \\n\\u00a0     template <class Iterator>\\n\\u00a0     void reinit(const Iterator &cell, unsigned int dofs_per_cell)\\n\\u00a0     {\\n\\u00a0       cell_matrix.reinit(dofs_per_cell, dofs_per_cell);\\n\\u00a0       cell_rhs.reinit(dofs_per_cell);\\n\\u00a0 \\n\\u00a0       local_dof_indices.resize(dofs_per_cell);\\n\\u00a0       cell->get_active_or_mg_dof_indices(local_dof_indices);\\n\\u00a0       level = cell->level();\\n\\u00a0     }\\n\\u00a0   };\\n\\u00a0 \\nFEValuesDefinition fe_values.h:63\\nFiniteElementDefinition fe.h:655\\nFullMatrixDefinition full_matrix.h:79\\nMappingAbstract base class for mapping classes.Definition mapping.h:318\\nQGaussDefinition quadrature_lib.h:40\\nVectorDefinition vector.h:120\\nlevelunsigned int levelDefinition grid_out.cc:4626\\nUpdateFlagsUpdateFlagsDefinition fe_update_flags.h:64\\n The LaplaceProblem class template\\nThis main class is similar to the same class in step-6. As far as member functions is concerned, the only additions are:\\nThe assemble_multigrid function that assembles the matrices that correspond to the discrete operators on intermediate levels.\\nThe cell_worker function that assembles our PDE on a single cell.\\n\\n\\u00a0   template <int dim>\\n\\u00a0   class LaplaceProblem\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     LaplaceProblem(const unsigned int degree);\\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     template <class Iterator>\\n\\u00a0     void cell_worker(const Iterator   &cell,\\n\\u00a0                      ScratchData<dim> &scratch_data,\\n\\u00a0                      CopyData         &copy_data);\\n\\u00a0 \\n\\u00a0     void setup_system();\\n\\u00a0     void assemble_system();\\n\\u00a0     void assemble_multigrid();\\n\\u00a0     void solve();\\n\\u00a0     void refine_grid();\\n\\u00a0     void output_results(const unsigned int cycle) const;\\n\\u00a0 \\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0     const FE_Q<dim>    fe;\\n\\u00a0     DoFHandler<dim>    dof_handler;\\n\\u00a0 \\n\\u00a0     SparsityPattern      sparsity_pattern;\\n\\u00a0     SparseMatrix<double> system_matrix;\\n\\u00a0 \\n\\u00a0     AffineConstraints<double> constraints;\\n\\u00a0 \\n\\u00a0     Vector<double> solution;\\n\\u00a0     Vector<double> system_rhs;\\n\\u00a0 \\n\\u00a0     const unsigned int degree;\\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nDoFHandlerDefinition dof_handler.h:317\\nFE_QDefinition fe_q.h:554\\nSparseMatrixDefinition sparse_matrix.h:520\\nSparsityPatternDefinition sparsity_pattern.h:343\\nTriangulationDefinition tria.h:1323\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\nThe following members are the essential data structures for the multigrid method. The first four represent the sparsity patterns and the matrices on individual levels of the multilevel hierarchy, very much like the objects for the global mesh above.\\nThen we have two new matrices only needed for multigrid methods with local smoothing on adaptive meshes. They convey data between the interior part of the refined region and the refinement edge, as outlined in detail in the multigrid paper.\\nThe last object stores information about the boundary indices on each level and information about indices lying on a refinement edge between two different refinement levels. It thus serves a similar purpose as AffineConstraints, but on each level.\\n\\u00a0     MGLevelObject<SparsityPattern> mg_sparsity_patterns;\\n\\u00a0     MGLevelObject<SparsityPattern> mg_interface_sparsity_patterns;\\n\\u00a0 \\n\\u00a0     MGLevelObject<SparseMatrix<double>> mg_matrices;\\n\\u00a0     MGLevelObject<SparseMatrix<double>> mg_interface_matrices;\\n\\u00a0     MGConstrainedDoFs                   mg_constrained_dofs;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\nMGConstrainedDoFsDefinition mg_constrained_dofs.h:45\\nMGLevelObjectDefinition mg_level_object.h:49\\n The LaplaceProblem class implementation\\nJust one short remark about the constructor of the Triangulation: by convention, all adaptively refined triangulations in deal.II never change by more than one level across a face between cells. For our multigrid algorithms, however, we need a slightly stricter guarantee, namely that the mesh also does not change by more than refinement level across vertices that might connect two cells. In other words, we must prevent the following situation:\\n\\n\\n\\nThis is achieved by passing the Triangulation::limit_level_difference_at_vertices flag to the constructor of the triangulation class.\\n\\u00a0   template <int dim>\\n\\u00a0   LaplaceProblem<dim>::LaplaceProblem(const unsigned int degree)\\n\\u00a0     : triangulation(Triangulation<dim>::limit_level_difference_at_vertices)\\n\\u00a0     , fe(degree)\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0     , degree(degree)\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n LaplaceProblem::setup_system\\nIn addition to just distributing the degrees of freedom in the DoFHandler, we do the same on each level. Then, we follow the same procedure as before to set up the system on the leaf mesh.\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceProblem<dim>::setup_system()\\n\\u00a0   {\\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0     dof_handler.distribute_mg_dofs();\\n\\u00a0 \\n\\u00a0     std::cout << \\\"   Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n\\u00a0               << \\\" (by level: \\\";\\n\\u00a0     for (unsigned int level = 0; level < triangulation.n_levels(); ++level)\\n\\u00a0       std::cout << dof_handler.n_dofs(level)\\n\\u00a0                 << (level == triangulation.n_levels() - 1 ? \\\")\\\" : \\\", \\\");\\n\\u00a0     std::cout << std::endl;\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     solution.reinit(dof_handler.n_dofs());\\n\\u00a0     system_rhs.reinit(dof_handler.n_dofs());\\n\\u00a0 \\n\\u00a0     constraints.clear();\\n\\u00a0     DoFTools::make_hanging_node_constraints(dof_handler, constraints);\\n\\u00a0 \\n\\u00a0     std::set<types::boundary_id> dirichlet_boundary_ids = {0};\\n\\u00a0     Functions::ZeroFunction<dim> homogeneous_dirichlet_bc;\\n\\u00a0     const std::map<types::boundary_id, const Function<dim> *>\\n\\u00a0       dirichlet_boundary_functions = {\\n\\u00a0         {types::boundary_id(0), &homogeneous_dirichlet_bc}};\\n\\u00a0     VectorTools::interpolate_boundary_values(dof_handler,\\n\\u00a0                                              dirichlet_boundary_functions,\\n\\u00a0                                              constraints);\\n\\u00a0     constraints.close();\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());\\n\\u00a0       DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints);\\n\\u00a0       sparsity_pattern.copy_from(dsp);\\n\\u00a0     }\\n\\u00a0     system_matrix.reinit(sparsity_pattern);\\n\\u00a0 \\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nFunctions::ZeroFunctionDefinition function.h:510\\nTriangulation::n_levelsunsigned int n_levels() const\\nDoFTools::make_hanging_node_constraintsvoid make_hanging_node_constraints(const DoFHandler< dim, spacedim > &dof_handler, AffineConstraints< number > &constraints)Definition dof_tools_constraints.cc:3073\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nVectorTools::interpolate_boundary_valuesvoid interpolate_boundary_values(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const std::map< types::boundary_id, const Function< spacedim, number > * > &function_map, std::map< types::global_dof_index, number > &boundary_values, const ComponentMask &component_mask={})\\ntypes::boundary_idunsigned int boundary_idDefinition types.h:144\\nThe multigrid constraints have to be initialized. They need to know where Dirichlet boundary conditions are prescribed.\\n\\u00a0     mg_constrained_dofs.clear();\\n\\u00a0     mg_constrained_dofs.initialize(dof_handler);\\n\\u00a0     mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,\\n\\u00a0                                                        dirichlet_boundary_ids);\\n\\u00a0 \\n\\u00a0 \\nNow for the things that concern the multigrid data structures. First, we resize the multilevel objects to hold matrices and sparsity patterns for every level. The coarse level is zero (this is mandatory right now but may change in a future revision). Note that these functions take a complete, inclusive range here (not a starting index and size), so the finest level is n_levels-1. We first have to resize the container holding the SparseMatrix classes, since they have to release their SparsityPattern before they can be destroyed upon resizing.\\n\\u00a0     const unsigned int n_levels = triangulation.n_levels();\\n\\u00a0 \\n\\u00a0     mg_interface_matrices.resize(0, n_levels - 1);\\n\\u00a0     mg_matrices.resize(0, n_levels - 1);\\n\\u00a0     mg_sparsity_patterns.resize(0, n_levels - 1);\\n\\u00a0     mg_interface_sparsity_patterns.resize(0, n_levels - 1);\\n\\u00a0 \\nNow, we have to provide a matrix on each level. To this end, we first use the MGTools::make_sparsity_pattern function to generate a preliminary compressed sparsity pattern on each level (see the Sparsity patterns topic for more information on this topic) and then copy it over to the one we really want. The next step is to initialize the interface matrices with the fitting sparsity pattern.\\nIt may be worth pointing out that the interface matrices only have entries for degrees of freedom that sit at or next to the interface between coarser and finer levels of the mesh. They are therefore even sparser than the matrices on the individual levels of our multigrid hierarchy. Therefore, we use a function specifically build for this purpose to generate it.\\n\\u00a0     for (unsigned int level = 0; level < n_levels; ++level)\\n\\u00a0       {\\n\\u00a0         {\\n\\u00a0           DynamicSparsityPattern dsp(dof_handler.n_dofs(level),\\n\\u00a0                                      dof_handler.n_dofs(level));\\n\\u00a0           MGTools::make_sparsity_pattern(dof_handler, dsp, level);\\n\\u00a0 \\n\\u00a0           mg_sparsity_patterns[level].copy_from(dsp);\\n\\u00a0           mg_matrices[level].reinit(mg_sparsity_patterns[level]);\\n\\u00a0         }\\n\\u00a0         {\\n\\u00a0           DynamicSparsityPattern dsp(dof_handler.n_dofs(level),\\n\\u00a0                                      dof_handler.n_dofs(level));\\n\\u00a0           MGTools::make_interface_sparsity_pattern(dof_handler,\\n\\u00a0                                                    mg_constrained_dofs,\\n\\u00a0                                                    dsp,\\n\\u00a0                                                    level);\\n\\u00a0           mg_interface_sparsity_patterns[level].copy_from(dsp);\\n\\u00a0           mg_interface_matrices[level].reinit(\\n\\u00a0             mg_interface_sparsity_patterns[level]);\\n\\u00a0         }\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nMGTools::make_interface_sparsity_patternvoid make_interface_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, const MGConstrainedDoFs &mg_constrained_dofs, SparsityPatternBase &sparsity, const unsigned int level)Definition mg_tools.cc:1013\\nMGTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity, const unsigned int level, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true)Definition mg_tools.cc:575\\n LaplaceProblem::cell_worker\\nThe cell_worker function is used to assemble the matrix and right-hand side on the given cell. This function is used for the active cells to generate the system_matrix and on each level to build the level matrices.\\nNote that we also assemble a right-hand side when called from assemble_multigrid() even though it is not used.\\n\\u00a0   template <int dim>\\n\\u00a0   template <class Iterator>\\n\\u00a0   void LaplaceProblem<dim>::cell_worker(const Iterator   &cell,\\n\\u00a0                                         ScratchData<dim> &scratch_data,\\n\\u00a0                                         CopyData         &copy_data)\\n\\u00a0   {\\n\\u00a0     FEValues<dim> &fe_values = scratch_data.fe_values;\\n\\u00a0     fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell = fe_values.get_fe().n_dofs_per_cell();\\n\\u00a0     const unsigned int n_q_points    = fe_values.get_quadrature().size();\\n\\u00a0 \\n\\u00a0     copy_data.reinit(cell, dofs_per_cell);\\n\\u00a0 \\n\\u00a0     const std::vector<double> &JxW = fe_values.get_JxW_values();\\n\\u00a0 \\n\\u00a0     for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0       {\\n\\u00a0         const double coefficient =\\n\\u00a0           (fe_values.get_quadrature_points()[q][0] < 0.0) ? 1.0 : 0.1;\\n\\u00a0 \\n\\u00a0         for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0           {\\n\\u00a0             for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0               {\\n\\u00a0                 copy_data.cell_matrix(i, j) +=\\n\\u00a0                   coefficient *\\n\\u00a0                   (fe_values.shape_grad(i, q) * fe_values.shape_grad(j, q)) *\\n\\u00a0                   JxW[q];\\n\\u00a0               }\\n\\u00a0             copy_data.cell_rhs(i) += 1.0 * fe_values.shape_value(i, q) * JxW[q];\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFEValues::reinitvoid reinit(const TriaIterator< DoFCellAccessor< dim, spacedim, level_dof_access > > &cell)\\n LaplaceProblem::assemble_system\\nThe following function assembles the linear system on the active cells of the mesh. For this, we pass two lambda functions to the mesh_loop() function. The cell_worker function redirects to the class member function of the same name, while the copier is specific to this function and copies local matrix and vector to the corresponding global ones using the constraints.\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceProblem<dim>::assemble_system()\\n\\u00a0   {\\n\\u00a0     MappingQ1<dim> mapping;\\n\\u00a0 \\n\\u00a0     auto cell_worker =\\n\\u00a0       [&](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0           ScratchData<dim>                                     &scratch_data,\\n\\u00a0           CopyData                                             &copy_data) {\\n\\u00a0         this->cell_worker(cell, scratch_data, copy_data);\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0     auto copier = [&](const CopyData &cd) {\\n\\u00a0       this->constraints.distribute_local_to_global(cd.cell_matrix,\\n\\u00a0                                                    cd.cell_rhs,\\n\\u00a0                                                    cd.local_dof_indices,\\n\\u00a0                                                    system_matrix,\\n\\u00a0                                                    system_rhs);\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     const unsigned int n_gauss_points = degree + 1;\\n\\u00a0 \\n\\u00a0     ScratchData<dim> scratch_data(mapping,\\n\\u00a0                                   fe,\\n\\u00a0                                   n_gauss_points,\\n\\u00a0                                   update_values | update_gradients |\\n\\u00a0                                     update_JxW_values |\\n\\u00a0                                     update_quadrature_points);\\n\\u00a0 \\n\\u00a0     MeshWorker::mesh_loop(dof_handler.begin_active(),\\n\\u00a0                           dof_handler.end(),\\n\\u00a0                           cell_worker,\\n\\u00a0                           copier,\\n\\u00a0                           scratch_data,\\n\\u00a0                           CopyData(),\\n\\u00a0                           MeshWorker::assemble_own_cells);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nMappingQ1Definition mapping_q1.h:55\\nDoFHandler::active_cell_iteratortypename ActiveSelector::active_cell_iterator active_cell_iteratorDefinition dof_handler.h:440\\nMeshWorker::mesh_loopvoid mesh_loop(const CellIteratorType &begin, const CellIteratorType &end, const CellWorkerFunctionType &cell_worker, const CopierType &copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const AssembleFlags flags=assemble_own_cells, const BoundaryWorkerFunctionType &boundary_worker=BoundaryWorkerFunctionType(), const FaceWorkerFunctionType &face_worker=FaceWorkerFunctionType(), const unsigned int queue_length=2 *MultithreadInfo::n_threads(), const unsigned int chunk_size=8)Definition mesh_loop.h:281\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nMeshWorker::assemble_own_cells@ assemble_own_cellsDefinition assemble_flags.h:49\\n LaplaceProblem::assemble_multigrid\\nThe next function is the one that builds the matrices that define the multigrid method on each level of the mesh. The integration core is the same as above, but the loop below will go over all existing cells instead of just the active ones, and the results must be entered into the correct level matrices. Fortunately, MeshWorker hides most of that from us, and thus the difference between this function and the previous lies only in the setup of the assembler and the different iterators in the loop.\\nWe generate an AffineConstraints object for each level containing the boundary and interface dofs as constrained entries. The corresponding object is then used to generate the level matrices.\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceProblem<dim>::assemble_multigrid()\\n\\u00a0   {\\n\\u00a0     MappingQ1<dim>     mapping;\\n\\u00a0     const unsigned int n_levels = triangulation.n_levels();\\n\\u00a0 \\n\\u00a0     std::vector<AffineConstraints<double>> boundary_constraints(n_levels);\\n\\u00a0     for (unsigned int level = 0; level < n_levels; ++level)\\n\\u00a0       {\\n\\u00a0         boundary_constraints[level].reinit(\\n\\u00a0           dof_handler.locally_owned_mg_dofs(level),\\n\\u00a0           DoFTools::extract_locally_relevant_level_dofs(dof_handler, level));\\n\\u00a0 \\n\\u00a0         for (const types::global_dof_index dof_index :\\n\\u00a0              mg_constrained_dofs.get_refinement_edge_indices(level))\\n\\u00a0           boundary_constraints[level].constrain_dof_to_zero(dof_index);\\n\\u00a0         for (const types::global_dof_index dof_index :\\n\\u00a0              mg_constrained_dofs.get_boundary_indices(level))\\n\\u00a0           boundary_constraints[level].constrain_dof_to_zero(dof_index);\\n\\u00a0         boundary_constraints[level].close();\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     auto cell_worker =\\n\\u00a0       [&](const typename DoFHandler<dim>::level_cell_iterator &cell,\\n\\u00a0           ScratchData<dim>                                    &scratch_data,\\n\\u00a0           CopyData                                            &copy_data) {\\n\\u00a0         this->cell_worker(cell, scratch_data, copy_data);\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0     auto copier = [&](const CopyData &cd) {\\n\\u00a0       boundary_constraints[cd.level].distribute_local_to_global(\\n\\u00a0         cd.cell_matrix, cd.local_dof_indices, mg_matrices[cd.level]);\\n\\u00a0 \\n\\u00a0       const unsigned int dofs_per_cell = cd.local_dof_indices.size();\\n\\u00a0 \\nDoFHandler::level_cell_iteratortypename LevelSelector::cell_iterator level_cell_iteratorDefinition dof_handler.h:504\\nunsigned int\\nDoFTools::extract_locally_relevant_level_dofsIndexSet extract_locally_relevant_level_dofs(const DoFHandler< dim, spacedim > &dof_handler, const unsigned int level)Definition dof_tools.cc:1212\\nInterface entries are ignored by the boundary_constraints object above when filling the mg_matrices[cd.level]. Instead, we copy these entries into the interface matrix of the current level manually:\\n\\u00a0       for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0         for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0           if (mg_constrained_dofs.is_interface_matrix_entry(\\n\\u00a0                 cd.level, cd.local_dof_indices[i], cd.local_dof_indices[j]))\\n\\u00a0             {\\n\\u00a0               mg_interface_matrices[cd.level].add(cd.local_dof_indices[i],\\n\\u00a0                                                   cd.local_dof_indices[j],\\n\\u00a0                                                   cd.cell_matrix(i, j));\\n\\u00a0             }\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     const unsigned int n_gauss_points = degree + 1;\\n\\u00a0 \\n\\u00a0     ScratchData<dim> scratch_data(mapping,\\n\\u00a0                                   fe,\\n\\u00a0                                   n_gauss_points,\\n\\u00a0                                   update_values | update_gradients |\\n\\u00a0                                     update_JxW_values |\\n\\u00a0                                     update_quadrature_points);\\n\\u00a0 \\n\\u00a0     MeshWorker::mesh_loop(dof_handler.begin_mg(),\\n\\u00a0                           dof_handler.end_mg(),\\n\\u00a0                           cell_worker,\\n\\u00a0                           copier,\\n\\u00a0                           scratch_data,\\n\\u00a0                           CopyData(),\\n\\u00a0                           MeshWorker::assemble_own_cells);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n LaplaceProblem::solve\\nThis is the other function that is significantly different in support of the multigrid solver (or, in fact, the preconditioner for which we use the multigrid method).\\nLet us start out by setting up two of the components of multilevel methods: transfer operators between levels, and a solver on the coarsest level. In finite element methods, the transfer operators are derived from the finite element function spaces involved and can often be computed in a generic way independent of the problem under consideration. In that case, we can use the MGTransferPrebuilt class that, given the constraints of the final linear system and the MGConstrainedDoFs object that knows about the boundary conditions on the each level and the degrees of freedom on interfaces between different refinement level can build the matrices for those transfer operations from a DoFHandler object with level degrees of freedom.\\nThe second part of the following lines deals with the coarse grid solver. Since our coarse grid is very coarse indeed, we decide for a direct solver (a Householder decomposition of the coarsest level matrix), even if its implementation is not particularly sophisticated. If our coarse mesh had many more cells than the five we have here, something better suited would obviously be necessary here.\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceProblem<dim>::solve()\\n\\u00a0   {\\n\\u00a0     MGTransferPrebuilt<Vector<double>> mg_transfer(mg_constrained_dofs);\\n\\u00a0     mg_transfer.build(dof_handler);\\n\\u00a0 \\n\\u00a0     FullMatrix<double> coarse_matrix;\\n\\u00a0     coarse_matrix.copy_from(mg_matrices[0]);\\n\\u00a0     MGCoarseGridHouseholder<double, Vector<double>> coarse_grid_solver;\\n\\u00a0     coarse_grid_solver.initialize(coarse_matrix);\\n\\u00a0 \\nFullMatrix::copy_fromvoid copy_from(const MatrixType &)\\nMGCoarseGridHouseholderDefinition mg_coarse.h:177\\nMGCoarseGridHouseholder::initializevoid initialize(const FullMatrix< number > &A)\\nMGTransferPrebuiltDefinition mg_transfer.h:628\\nThe next component of a multilevel solver or preconditioner is that we need a smoother on each level. A common choice for this is to use the application of a relaxation method (such as the SOR, Jacobi or Richardson method) or a small number of iterations of a solver method (such as CG or GMRES). The mg::SmootherRelaxation and MGSmootherPrecondition classes provide support for these two kinds of smoothers. Here, we opt for the application of a single SOR iteration. To this end, we define an appropriate alias and then setup a smoother object.\\nThe last step is to initialize the smoother object with our level matrices and to set some smoothing parameters. The initialize() function can optionally take additional arguments that will be passed to the smoother object on each level. In the current case for the SOR smoother, this could, for example, include a relaxation parameter. However, we here leave these at their default values. The call to set_steps() indicates that we will use two pre- and two post-smoothing steps on each level; to use a variable number of smoother steps on different levels, more options can be set in the constructor call to the mg_smoother object.\\nThe last step results from the fact that we use the SOR method as a smoother - which is not symmetric - but we use the conjugate gradient iteration (which requires a symmetric preconditioner) below, we need to let the multilevel preconditioner make sure that we get a symmetric operator even for nonsymmetric smoothers:\\n\\u00a0     using Smoother = PreconditionSOR<SparseMatrix<double>>;\\n\\u00a0     mg::SmootherRelaxation<Smoother, Vector<double>> mg_smoother;\\n\\u00a0     mg_smoother.initialize(mg_matrices);\\n\\u00a0     mg_smoother.set_steps(2);\\n\\u00a0     mg_smoother.set_symmetric(true);\\n\\u00a0 \\nPreconditionSORDefinition precondition.h:1726\\nmg::SmootherRelaxationDefinition mg_smoother.h:186\\nmg::SmootherRelaxation::initializevoid initialize(const MGLevelObject< MatrixType2 > &matrices, const typename RelaxationType::AdditionalData &additional_data=typename RelaxationType::AdditionalData())\\nThe next preparatory step is that we must wrap our level and interface matrices in an object having the required multiplication functions. We will create two objects for the interface objects going from coarse to fine and the other way around; the multigrid algorithm will later use the transpose operator for the latter operation, allowing us to initialize both up and down versions of the operator with the matrices we already built:\\n\\u00a0     mg::Matrix<Vector<double>> mg_matrix(mg_matrices);\\n\\u00a0     mg::Matrix<Vector<double>> mg_interface_up(mg_interface_matrices);\\n\\u00a0     mg::Matrix<Vector<double>> mg_interface_down(mg_interface_matrices);\\n\\u00a0 \\nmg::MatrixDefinition mg_matrix.h:46\\nNow, we are ready to set up the V-cycle operator and the multilevel preconditioner.\\n\\u00a0     Multigrid<Vector<double>> mg(\\n\\u00a0       mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);\\n\\u00a0     mg.set_edge_matrices(mg_interface_down, mg_interface_up);\\n\\u00a0 \\n\\u00a0     PreconditionMG<dim, Vector<double>, MGTransferPrebuilt<Vector<double>>>\\n\\u00a0       preconditioner(dof_handler, mg, mg_transfer);\\n\\u00a0 \\nMultigridDefinition multigrid.h:163\\nPreconditionMGDefinition multigrid.h:501\\nmgDefinition mg.h:81\\nWith all this together, we can finally get about solving the linear system in the usual way:\\n\\u00a0     SolverControl            solver_control(1000, 1e-6 * system_rhs.l2_norm());\\n\\u00a0     SolverCG<Vector<double>> solver(solver_control);\\n\\u00a0 \\n\\u00a0     solution = 0;\\n\\u00a0 \\n\\u00a0     solver.solve(system_matrix, solution, system_rhs, preconditioner);\\n\\u00a0     std::cout << \\\"   Number of CG iterations: \\\" << solver_control.last_step()\\n\\u00a0               << '\\\\n'\\n\\u00a0               << std::endl;\\n\\u00a0     constraints.distribute(solution);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nSolverCGDefinition solver_cg.h:179\\nSolverControlDefinition solver_control.h:67\\n Postprocessing\\nThe following two functions postprocess a solution once it is computed. In particular, the first one refines the mesh at the beginning of each cycle while the second one outputs results at the end of each such cycle. The functions are almost unchanged from those in step-6.\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceProblem<dim>::refine_grid()\\n\\u00a0   {\\n\\u00a0     Vector<float> estimated_error_per_cell(triangulation.n_active_cells());\\n\\u00a0 \\n\\u00a0     KellyErrorEstimator<dim>::estimate(\\n\\u00a0       dof_handler,\\n\\u00a0       QGauss<dim - 1>(degree + 2),\\n\\u00a0       std::map<types::boundary_id, const Function<dim> *>(),\\n\\u00a0       solution,\\n\\u00a0       estimated_error_per_cell);\\n\\u00a0     GridRefinement::refine_and_coarsen_fixed_number(triangulation,\\n\\u00a0                                                     estimated_error_per_cell,\\n\\u00a0                                                     0.3,\\n\\u00a0                                                     0.03);\\n\\u00a0     triangulation.execute_coarsening_and_refinement();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceProblem<dim>::output_results(const unsigned int cycle) const\\n\\u00a0   {\\n\\u00a0     DataOut<dim> data_out;\\n\\u00a0 \\n\\u00a0     data_out.attach_dof_handler(dof_handler);\\n\\u00a0     data_out.add_data_vector(solution, \\\"solution\\\");\\n\\u00a0     data_out.build_patches();\\n\\u00a0 \\n\\u00a0     std::ofstream output(\\\"solution-\\\" + std::to_string(cycle) + \\\".vtk\\\");\\n\\u00a0     data_out.write_vtk(output);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nFunctionDefinition function.h:152\\nKellyErrorEstimator::estimatestatic void estimate(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const Quadrature< dim - 1 > &quadrature, const std::map< types::boundary_id, const Function< spacedim, Number > * > &neumann_bc, const ReadVector< Number > &solution, Vector< float > &error, const ComponentMask &component_mask={}, const Function< spacedim > *coefficients=nullptr, const unsigned int n_threads=numbers::invalid_unsigned_int, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id, const types::material_id material_id=numbers::invalid_material_id, const Strategy strategy=cell_diameter_over_24)\\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nparallel::distributed::Triangulation::execute_coarsening_and_refinementvirtual void execute_coarsening_and_refinement() overrideDefinition tria.cc:3320\\nGridRefinement::refine_and_coarsen_fixed_numbervoid refine_and_coarsen_fixed_number(Triangulation< dim, spacedim > &triangulation, const Vector< Number > &criteria, const double top_fraction_of_cells, const double bottom_fraction_of_cells, const unsigned int max_n_cells=std::numeric_limits< unsigned int >::max())Definition grid_refinement.cc:318\\n LaplaceProblem::run\\nLike several of the functions above, this is almost exactly a copy of the corresponding function in step-6. The only difference is the call to assemble_multigrid that takes care of forming the matrices on every level that we need in the multigrid method.\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceProblem<dim>::run()\\n\\u00a0   {\\n\\u00a0     for (unsigned int cycle = 0; cycle < 8; ++cycle)\\n\\u00a0       {\\n\\u00a0         std::cout << \\\"Cycle \\\" << cycle << std::endl;\\n\\u00a0 \\n\\u00a0         if (cycle == 0)\\n\\u00a0           {\\n\\u00a0             GridGenerator::hyper_ball(triangulation);\\n\\u00a0             triangulation.refine_global(2);\\n\\u00a0           }\\n\\u00a0         else\\n\\u00a0           refine_grid();\\n\\u00a0 \\n\\u00a0         std::cout << \\\"   Number of active cells:       \\\"\\n\\u00a0                   << triangulation.n_active_cells() << std::endl;\\n\\u00a0 \\n\\u00a0         setup_system();\\n\\u00a0 \\n\\u00a0         assemble_system();\\n\\u00a0         assemble_multigrid();\\n\\u00a0 \\n\\u00a0         solve();\\n\\u00a0         output_results(cycle);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 } // namespace Step16\\n\\u00a0 \\n\\u00a0 \\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nGridGenerator::hyper_ballvoid hyper_ball(Triangulation< dim > &tria, const Point< dim > &center=Point< dim >(), const double radius=1., const bool attach_spherical_manifold_on_boundary_cells=false)\\n The main() function\\nThis is again the same function as in step-6:\\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       using namespace Step16;\\n\\u00a0 \\n\\u00a0       LaplaceProblem<2> laplace_problem(1);\\n\\u00a0       laplace_problem.run();\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0 \\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nOn the finest mesh, the solution looks like this:\\n\\n \\nMore importantly, we would like to see if the multigrid method really improved the solver performance. Therefore, here is the textual output:\\n\\nCycle 0\\n   Number of active cells:       80\\n   Number of degrees of freedom: 89 (by level: 8, 25, 89)\\n   Number of CG iterations: 5\\n\\nCycle 1\\n   Number of active cells:       152\\n   Number of degrees of freedom: 174 (by level: 8, 25, 89, 123)\\n   Number of CG iterations: 5\\n\\nCycle 2\\n   Number of active cells:       287\\n   Number of degrees of freedom: 331 (by level: 8, 25, 89, 223, 127)\\n   Number of CG iterations: 6\\n\\nCycle 3\\n   Number of active cells:       545\\n   Number of degrees of freedom: 608 (by level: 8, 25, 89, 231, 476, 24)\\n   Number of CG iterations: 6\\n\\nCycle 4\\n   Number of active cells:       1034\\n   Number of degrees of freedom: 1137 (by level: 8, 25, 89, 274, 756, 417, 15)\\n   Number of CG iterations: 6\\n\\nCycle 5\\n   Number of active cells:       1964\\n   Number of degrees of freedom: 2181 (by level: 8, 25, 89, 304, 779, 1030, 817)\\n   Number of CG iterations: 6\\n\\nCycle 6\\n   Number of active cells:       3734\\n   Number of degrees of freedom: 4101 (by level: 8, 25, 89, 337, 779, 2046, 885, 1545)\\n   Number of CG iterations: 6\\n\\nCycle 7\\n   Number of active cells:       7094\\n   Number of degrees of freedom: 7833 (by level: 8, 25, 89, 337, 1056, 2835, 1740, 1765, 3085)\\n   Number of CG iterations: 6\\n\\nThat's almost perfect multigrid performance: the linear residual gets reduced by 6 orders of magnitude in 5 or 6 iterations, and the results are almost independent of the mesh size. That's obviously in part due to the simple nature of the problem solved, but it also shows the power of multigrid methods.\\nPossibilities for extensions \\nWe encourage you to generate timings for the solve() call and compare to step-6. You will see that the multigrid method has quite an overhead on coarse meshes, but that it always beats other methods on fine meshes because of its optimal complexity.\\nA close inspection of this program's performance shows that it is mostly dominated by matrix-vector operations. step-37 shows one way how this can be avoided by working with matrix-free methods.\\nAnother avenue would be to use algebraic multigrid methods. The geometric multigrid method used here can at times be a bit awkward to implement because it needs all those additional data structures, and it becomes even more difficult if the program is to run in parallel on machines coupled through MPI, for example. In that case, it would be simpler if one could use a black-box preconditioner that uses some sort of multigrid hierarchy for good performance but can figure out level matrices and similar things by itself. Algebraic multigrid methods do exactly this, and we will use them in step-31 for the solution of a Stokes problem and in step-32 and step-40 for a parallel variation. That said, a parallel version of this example program with MPI can be found in step-50.\\nFinally, one may want to think how to use geometric multigrid for other kinds of problems, specifically vector valued problems. This is the topic of step-56 where we use the techniques shown here for the Stokes equation.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2003 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Authors: Guido Kanschat, University of Heidelberg, 2003\\n *          Baerbel Janssen, University of Heidelberg, 2010\\n *          Wolfgang Bangerth, Texas A&M University, 2010\\n *          Timo Heister, Clemson University, 2018\\n */\\n \\n \\n \\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/function.h>\\n#include <deal.II/base/utilities.h>\\n \\n#include <deal.II/lac/affine_constraints.h>\\n#include <deal.II/lac/vector.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/precondition.h>\\n \\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_refinement.h>\\n \\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_values.h>\\n#include <deal.II/fe/mapping_q1.h>\\n \\n#include <deal.II/numerics/vector_tools.h>\\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/error_estimator.h>\\n \\n#include <deal.II/multigrid/mg_constrained_dofs.h>\\n#include <deal.II/multigrid/multigrid.h>\\n#include <deal.II/multigrid/mg_transfer.h>\\n#include <deal.II/multigrid/mg_tools.h>\\n#include <deal.II/multigrid/mg_coarse.h>\\n#include <deal.II/multigrid/mg_smoother.h>\\n#include <deal.II/multigrid/mg_matrix.h>\\n \\n#include <deal.II/meshworker/mesh_loop.h>\\n \\n \\n#include <iostream>\\n#include <fstream>\\n \\nusing namespace dealii;\\n \\nnamespace Step16\\n{\\n template <int dim>\\n struct ScratchData\\n  {\\n    ScratchData(const Mapping<dim>       &mapping,\\n const FiniteElement<dim> &fe,\\n const unsigned int        quadrature_degree,\\n const UpdateFlags         update_flags)\\n      : fe_values(mapping, fe, QGauss<dim>(quadrature_degree), update_flags)\\n    {}\\n \\n    ScratchData(const ScratchData<dim> &scratch_data)\\n      : fe_values(scratch_data.fe_values.get_mapping(),\\n                  scratch_data.fe_values.get_fe(),\\n                  scratch_data.fe_values.get_quadrature(),\\n                  scratch_data.fe_values.get_update_flags())\\n    {}\\n \\n FEValues<dim> fe_values;\\n  };\\n \\n struct CopyData\\n  {\\n unsigned int level;\\n FullMatrix<double> cell_matrix;\\n Vector<double>                       cell_rhs;\\n    std::vector<types::global_dof_index> local_dof_indices;\\n \\n template <class Iterator>\\n void reinit(const Iterator &cell, unsigned int dofs_per_cell)\\n    {\\n cell_matrix.reinit(dofs_per_cell, dofs_per_cell);\\n      cell_rhs.reinit(dofs_per_cell);\\n \\n      local_dof_indices.resize(dofs_per_cell);\\n      cell->get_active_or_mg_dof_indices(local_dof_indices);\\n level = cell->level();\\n    }\\n  };\\n \\n \\n template <int dim>\\n class LaplaceProblem\\n  {\\n public:\\n    LaplaceProblem(const unsigned int degree);\\n void run();\\n \\n private:\\n template <class Iterator>\\n void cell_worker(const Iterator   &cell,\\n                     ScratchData<dim> &scratch_data,\\n                     CopyData         &copy_data);\\n \\n void setup_system();\\n void assemble_system();\\n void assemble_multigrid();\\n void solve();\\n void refine_grid();\\n void output_results(const unsigned int cycle) const;\\n \\n Triangulation<dim> triangulation;\\n const FE_Q<dim>    fe;\\n DoFHandler<dim>    dof_handler;\\n \\n SparsityPattern      sparsity_pattern;\\n SparseMatrix<double> system_matrix;\\n \\n AffineConstraints<double> constraints;\\n \\n Vector<double> solution;\\n Vector<double> system_rhs;\\n \\n const unsigned int degree;\\n \\n MGLevelObject<SparsityPattern> mg_sparsity_patterns;\\n MGLevelObject<SparsityPattern> mg_interface_sparsity_patterns;\\n \\n MGLevelObject<SparseMatrix<double>> mg_matrices;\\n MGLevelObject<SparseMatrix<double>> mg_interface_matrices;\\n MGConstrainedDoFs                   mg_constrained_dofs;\\n  };\\n \\n \\n \\n template <int dim>\\n  LaplaceProblem<dim>::LaplaceProblem(const unsigned int degree)\\n    : triangulation(Triangulation<dim>::limit_level_difference_at_vertices)\\n    , fe(degree)\\n    , dof_handler(triangulation)\\n    , degree(degree)\\n  {}\\n \\n \\n \\n \\n template <int dim>\\n void LaplaceProblem<dim>::setup_system()\\n  {\\n    dof_handler.distribute_dofs(fe);\\n    dof_handler.distribute_mg_dofs();\\n \\n    std::cout << \\\"   Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n              << \\\" (by level: \\\";\\n for (unsigned int level = 0; level < triangulation.n_levels(); ++level)\\n      std::cout << dof_handler.n_dofs(level)\\n                << (level == triangulation.n_levels() - 1 ? \\\")\\\" : \\\", \\\");\\n    std::cout << std::endl;\\n \\n \\n    solution.reinit(dof_handler.n_dofs());\\n    system_rhs.reinit(dof_handler.n_dofs());\\n \\n    constraints.clear();\\n DoFTools::make_hanging_node_constraints(dof_handler, constraints);\\n \\n    std::set<types::boundary_id> dirichlet_boundary_ids = {0};\\n Functions::ZeroFunction<dim> homogeneous_dirichlet_bc;\\n const std::map<types::boundary_id, const Function<dim> *>\\n      dirichlet_boundary_functions = {\\n        {types::boundary_id(0), &homogeneous_dirichlet_bc}};\\n VectorTools::interpolate_boundary_values(dof_handler,\\n                                             dirichlet_boundary_functions,\\n                                             constraints);\\n    constraints.close();\\n \\n    {\\n DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());\\n DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints);\\n      sparsity_pattern.copy_from(dsp);\\n    }\\n    system_matrix.reinit(sparsity_pattern);\\n \\n    mg_constrained_dofs.clear();\\n    mg_constrained_dofs.initialize(dof_handler);\\n    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,\\n                                                       dirichlet_boundary_ids);\\n \\n \\n const unsigned int n_levels = triangulation.n_levels();\\n \\n    mg_interface_matrices.resize(0, n_levels - 1);\\n    mg_matrices.resize(0, n_levels - 1);\\n    mg_sparsity_patterns.resize(0, n_levels - 1);\\n    mg_interface_sparsity_patterns.resize(0, n_levels - 1);\\n \\n for (unsigned int level = 0; level < n_levels; ++level)\\n      {\\n        {\\n DynamicSparsityPattern dsp(dof_handler.n_dofs(level),\\n                                     dof_handler.n_dofs(level));\\n MGTools::make_sparsity_pattern(dof_handler, dsp, level);\\n \\n          mg_sparsity_patterns[level].copy_from(dsp);\\n          mg_matrices[level].reinit(mg_sparsity_patterns[level]);\\n        }\\n        {\\n DynamicSparsityPattern dsp(dof_handler.n_dofs(level),\\n                                     dof_handler.n_dofs(level));\\n MGTools::make_interface_sparsity_pattern(dof_handler,\\n                                                   mg_constrained_dofs,\\n                                                   dsp,\\n level);\\n          mg_interface_sparsity_patterns[level].copy_from(dsp);\\n          mg_interface_matrices[level].reinit(\\n            mg_interface_sparsity_patterns[level]);\\n        }\\n      }\\n  }\\n \\n \\n \\n template <int dim>\\n template <class Iterator>\\n void LaplaceProblem<dim>::cell_worker(const Iterator   &cell,\\n                                        ScratchData<dim> &scratch_data,\\n                                        CopyData         &copy_data)\\n  {\\n FEValues<dim> &fe_values = scratch_data.fe_values;\\n    fe_values.reinit(cell);\\n \\n const unsigned int dofs_per_cell = fe_values.get_fe().n_dofs_per_cell();\\n const unsigned int n_q_points    = fe_values.get_quadrature().size();\\n \\n    copy_data.reinit(cell, dofs_per_cell);\\n \\n const std::vector<double> &JxW = fe_values.get_JxW_values();\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n      {\\n const double coefficient =\\n          (fe_values.get_quadrature_points()[q][0] < 0.0) ? 1.0 : 0.1;\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n          {\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n              {\\n                copy_data.cell_matrix(i, j) +=\\n                  coefficient *\\n                  (fe_values.shape_grad(i, q) * fe_values.shape_grad(j, q)) *\\n                  JxW[q];\\n              }\\n            copy_data.cell_rhs(i) += 1.0 * fe_values.shape_value(i, q) * JxW[q];\\n          }\\n      }\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void LaplaceProblem<dim>::assemble_system()\\n  {\\n MappingQ1<dim> mapping;\\n \\n auto cell_worker =\\n      [&](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n          ScratchData<dim>                                     &scratch_data,\\n          CopyData                                             &copy_data) {\\n        this->cell_worker(cell, scratch_data, copy_data);\\n      };\\n \\n auto copier = [&](const CopyData &cd) {\\n      this->constraints.distribute_local_to_global(cd.cell_matrix,\\n                                                   cd.cell_rhs,\\n                                                   cd.local_dof_indices,\\n                                                   system_matrix,\\n                                                   system_rhs);\\n    };\\n \\n const unsigned int n_gauss_points = degree + 1;\\n \\n    ScratchData<dim> scratch_data(mapping,\\n                                  fe,\\n                                  n_gauss_points,\\n update_values | update_gradients |\\n update_JxW_values |\\n update_quadrature_points);\\n \\n MeshWorker::mesh_loop(dof_handler.begin_active(),\\n                          dof_handler.end(),\\n                          cell_worker,\\n                          copier,\\n                          scratch_data,\\n                          CopyData(),\\n MeshWorker::assemble_own_cells);\\n  }\\n \\n \\n \\n template <int dim>\\n void LaplaceProblem<dim>::assemble_multigrid()\\n  {\\n MappingQ1<dim>     mapping;\\n const unsigned int n_levels = triangulation.n_levels();\\n \\n    std::vector<AffineConstraints<double>> boundary_constraints(n_levels);\\n for (unsigned int level = 0; level < n_levels; ++level)\\n      {\\n        boundary_constraints[level].reinit(\\n          dof_handler.locally_owned_mg_dofs(level),\\n DoFTools::extract_locally_relevant_level_dofs(dof_handler, level));\\n \\n for (const types::global_dof_index dof_index :\\n             mg_constrained_dofs.get_refinement_edge_indices(level))\\n          boundary_constraints[level].constrain_dof_to_zero(dof_index);\\n for (const types::global_dof_index dof_index :\\n             mg_constrained_dofs.get_boundary_indices(level))\\n          boundary_constraints[level].constrain_dof_to_zero(dof_index);\\n        boundary_constraints[level].close();\\n      }\\n \\n auto cell_worker =\\n      [&](const typename DoFHandler<dim>::level_cell_iterator &cell,\\n          ScratchData<dim>                                    &scratch_data,\\n          CopyData                                            &copy_data) {\\n        this->cell_worker(cell, scratch_data, copy_data);\\n      };\\n \\n auto copier = [&](const CopyData &cd) {\\n      boundary_constraints[cd.level].distribute_local_to_global(\\n        cd.cell_matrix, cd.local_dof_indices, mg_matrices[cd.level]);\\n \\n const unsigned int dofs_per_cell = cd.local_dof_indices.size();\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n if (mg_constrained_dofs.is_interface_matrix_entry(\\n                cd.level, cd.local_dof_indices[i], cd.local_dof_indices[j]))\\n            {\\n              mg_interface_matrices[cd.level].add(cd.local_dof_indices[i],\\n                                                  cd.local_dof_indices[j],\\n                                                  cd.cell_matrix(i, j));\\n            }\\n    };\\n \\n const unsigned int n_gauss_points = degree + 1;\\n \\n    ScratchData<dim> scratch_data(mapping,\\n                                  fe,\\n                                  n_gauss_points,\\n update_values | update_gradients |\\n update_JxW_values |\\n update_quadrature_points);\\n \\n MeshWorker::mesh_loop(dof_handler.begin_mg(),\\n                          dof_handler.end_mg(),\\n                          cell_worker,\\n                          copier,\\n                          scratch_data,\\n                          CopyData(),\\n MeshWorker::assemble_own_cells);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void LaplaceProblem<dim>::solve()\\n  {\\n MGTransferPrebuilt<Vector<double>> mg_transfer(mg_constrained_dofs);\\n    mg_transfer.build(dof_handler);\\n \\n FullMatrix<double> coarse_matrix;\\n    coarse_matrix.copy_from(mg_matrices[0]);\\n MGCoarseGridHouseholder<double, Vector<double>> coarse_grid_solver;\\n    coarse_grid_solver.initialize(coarse_matrix);\\n \\n using Smoother = PreconditionSOR<SparseMatrix<double>>;\\n mg::SmootherRelaxation<Smoother, Vector<double>> mg_smoother;\\n    mg_smoother.initialize(mg_matrices);\\n    mg_smoother.set_steps(2);\\n    mg_smoother.set_symmetric(true);\\n \\n mg::Matrix<Vector<double>> mg_matrix(mg_matrices);\\n mg::Matrix<Vector<double>> mg_interface_up(mg_interface_matrices);\\n mg::Matrix<Vector<double>> mg_interface_down(mg_interface_matrices);\\n \\n Multigrid<Vector<double>> mg(\\n      mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);\\n mg.set_edge_matrices(mg_interface_down, mg_interface_up);\\n \\n PreconditionMG<dim, Vector<double>, MGTransferPrebuilt<Vector<double>>>\\n      preconditioner(dof_handler, mg, mg_transfer);\\n \\n SolverControl            solver_control(1000, 1e-6 * system_rhs.l2_norm());\\n SolverCG<Vector<double>> solver(solver_control);\\n \\n    solution = 0;\\n \\n    solver.solve(system_matrix, solution, system_rhs, preconditioner);\\n    std::cout << \\\"   Number of CG iterations: \\\" << solver_control.last_step()\\n              << '\\\\n'\\n              << std::endl;\\n    constraints.distribute(solution);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void LaplaceProblem<dim>::refine_grid()\\n  {\\n Vector<float> estimated_error_per_cell(triangulation.n_active_cells());\\n \\n KellyErrorEstimator<dim>::estimate(\\n      dof_handler,\\n QGauss<dim - 1>(degree + 2),\\n      std::map<types::boundary_id, const Function<dim> *>(),\\n      solution,\\n      estimated_error_per_cell);\\n GridRefinement::refine_and_coarsen_fixed_number(triangulation,\\n                                                    estimated_error_per_cell,\\n                                                    0.3,\\n                                                    0.03);\\n triangulation.execute_coarsening_and_refinement();\\n  }\\n \\n \\n \\n template <int dim>\\n void LaplaceProblem<dim>::output_results(const unsigned int cycle) const\\n {\\n DataOut<dim> data_out;\\n \\n    data_out.attach_dof_handler(dof_handler);\\n    data_out.add_data_vector(solution, \\\"solution\\\");\\n    data_out.build_patches();\\n \\n    std::ofstream output(\\\"solution-\\\" + std::to_string(cycle) + \\\".vtk\\\");\\n    data_out.write_vtk(output);\\n  }\\n \\n \\n \\n template <int dim>\\n void LaplaceProblem<dim>::run()\\n  {\\n for (unsigned int cycle = 0; cycle < 8; ++cycle)\\n      {\\n        std::cout << \\\"Cycle \\\" << cycle << std::endl;\\n \\n if (cycle == 0)\\n          {\\n GridGenerator::hyper_ball(triangulation);\\n triangulation.refine_global(2);\\n          }\\n else\\n          refine_grid();\\n \\n        std::cout << \\\"   Number of active cells:       \\\"\\n                  << triangulation.n_active_cells() << std::endl;\\n \\n        setup_system();\\n \\n        assemble_system();\\n        assemble_multigrid();\\n \\n        solve();\\n        output_results(cycle);\\n      }\\n  }\\n} // namespace Step16\\n \\n \\nint main()\\n{\\n try\\n    {\\n using namespace Step16;\\n \\n      LaplaceProblem<2> laplace_problem(1);\\n      laplace_problem.run();\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n \\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n \\n return 0;\\n}\\naffine_constraints.h\\nDataOutInterface::write_vtkvoid write_vtk(std::ostream &out) constDefinition data_out_base.cc:7681\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nFEValuesBase::get_JxW_valuesconst std::vector< double > & get_JxW_values() const\\nFEValuesBase::get_quadrature_pointsconst std::vector< Point< spacedim > > & get_quadrature_points() const\\nFEValuesBase::shape_gradconst Tensor< 1, spacedim > & shape_grad(const unsigned int i, const unsigned int q_point) const\\nFEValuesBase::get_feconst FiniteElement< dim, spacedim > & get_fe() const\\nFEValuesBase::shape_valueconst double & shape_value(const unsigned int i, const unsigned int q_point) const\\nFEValues::get_quadratureconst Quadrature< dim > & get_quadrature() const\\nFiniteElementData::n_dofs_per_cellunsigned int n_dofs_per_cell() const\\nMGSmoother::set_stepsvoid set_steps(const unsigned int)\\nMGSmoother::set_symmetricvoid set_symmetric(const bool)\\nVector::reinitvirtual void reinit(const size_type N, const bool omit_zeroing_entries=false)\\ndof_tools.h\\nerror_estimator.h\\nfe_values.h\\nfe_q.h\\nfull_matrix.h\\nfunction.h\\ngrid_refinement.h\\ntria.h\\ngrid_generator.h\\nutilities.h\\nmapping_q1.h\\nmesh_loop.h\\nmg_coarse.h\\nmg_constrained_dofs.h\\nmg_matrix.h\\nmg_smoother.h\\nmg_tools.h\\nmg_transfer.h\\nmultigrid.h\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\ninternal::reinitvoid reinit(MatrixBlock< MatrixType > &v, const BlockSparsityPattern &p)Definition matrix_block.h:617\\ndata_out.h\\nprecondition.h\\nquadrature_lib.h\\nsolver_cg.h\\nsparse_matrix.h\\nvector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"