"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_45.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-45 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-45 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-45 tutorial program\\n\\n\\nThis tutorial depends on step-6.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\n\\n The commented program\\n\\nSetting up periodicity constraints on distributed triangulations\\n\\n\\n Results\\n\\n\\n The plain program\\n   \\n\\n\\nThis program was contributed by Daniel Arndt and Matthias Maier.  Introduction\\nIn this example we present how to use periodic boundary conditions in deal.II. Periodic boundary conditions are algebraic constraints that typically occur in computations on representative regions of a larger domain that repeat in one or more directions.\\nAn example is the simulation of the electronic structure of photonic crystals, because they have a lattice-like structure and, thus, it often suffices to do the actual computation on only one box of the lattice. To be able to proceed this way one has to assume that the model can be periodically extended to the other boxes; this requires the solution to have a periodic structure.\\nProcedure\\ndeal.II provides a number of high level entry points to impose periodic boundary conditions. The general approach to apply periodic boundary conditions consists of three steps (see also the Glossary entry on periodic boundary conditions):\\nCreate a mesh\\nIdentify those pairs of faces on different parts of the boundary across which the solution should be symmetric, using GridTools::collect_periodic_faces()\\nAdd the periodicity information to the mesh using parallel::distributed::Triangulation::add_periodicity()\\nAdd periodicity constraints using DoFTools::make_periodicity_constraints()\\n\\nThe second and third step are necessary for parallel meshes using the parallel::distributed::Triangulation class to ensure that cells on opposite sides of the domain but connected by periodic faces are part of the ghost layer if one of them is stored on the local processor. If the Triangulation is not a parallel::distributed::Triangulation, these steps are not necessary.\\nThe first step consists of collecting matching periodic faces and storing them in a std::vector of GridTools::PeriodicFacePair. This is done with the function GridTools::collect_periodic_faces() that can be invoked for example like this: GridTools::collect_periodic_faces(dof_handler,\\n                                  b_id1,\\n                                  b_id2,\\n                                  direction,\\n                                  matched_pairs,\\n                                  offset = <default value>,\\n                                  matrix = <default value>,\\n                                  first_vector_components = <default value>);\\nGridTools::collect_periodic_facesvoid collect_periodic_faces(const MeshType &mesh, const types::boundary_id b_id1, const types::boundary_id b_id2, const unsigned int direction, std::vector< PeriodicFacePair< typename MeshType::cell_iterator > > &matched_pairs, const Tensor< 1, MeshType::space_dimension > &offset=::Tensor< 1, MeshType::space_dimension >(), const FullMatrix< double > &matrix=FullMatrix< double >())Definition grid_tools_dof_handlers.cc:2299\\nThis call loops over all faces of the container dof_handler on the periodic boundaries with boundary indicator b_id1 and b_id2, respectively. (You can assign these boundary indicators by hand after creating the coarse mesh, see Boundary indicator. Alternatively, you can also let many of the functions in namespace GridGenerator do this for if you specify the \\\"colorize\\\" flag; in that case, these functions will assign different boundary indicators to different parts of the boundary, with the details typically spelled out in the documentation of these functions.)\\nConcretely, if \\\\(\\\\text{vertices}_{1/2}\\\\) are the vertices of two faces \\\\(\\\\text{face}_{1/2}\\\\), then the function call above will match pairs of faces (and dofs) such that the difference between \\\\(\\\\text{vertices}_2\\\\) and \\\\(matrix\\\\cdot \\\\text{vertices}_1+\\\\text{offset}\\\\) vanishes in every component apart from direction and stores the resulting pairs with associated data in matched_pairs. (See GridTools::orthogonal_equality() for detailed information about the matching process.)\\nConsider, for example, the colored unit square \\\\(\\\\Omega=[0,1]^2\\\\) with boundary indicator 0 on the left, 1 on the right, 2 on the bottom and 3 on the top faces. (See the documentation of GridGenerator::hyper_cube() for this convention on how boundary indicators are assigned.) Then, GridTools::collect_periodic_faces(dof_handler,\\n /*b_id1*/ 0,\\n /*b_id2*/ 1,\\n /*direction*/ 0,\\n                                  matched_pairs);\\n would yield periodicity constraints such that \\\\(u(0,y)=u(1,y)\\\\) for all \\\\(y\\\\in[0,1]\\\\).\\nIf we instead consider the parallelogram given by the convex hull of \\\\((0,0)\\\\), \\\\((1,1)\\\\), \\\\((1,2)\\\\), \\\\((0,1)\\\\) we can achieve the constraints \\\\(u(0,y)=u(1,y+1)\\\\) by specifying an offset: GridTools::collect_periodic_faces(dof_handler,\\n /*b_id1*/ 0,\\n /*b_id2*/ 1,\\n /*direction*/ 0,\\n                                  matched_pairs,\\n Tensor<1, 2>(0.,1.));\\nTensorDefinition tensor.h:471\\n or GridTools::collect_periodic_faces(dof_handler,\\n /*b_id1*/ 0,\\n /*b_id2*/ 1,\\n /*arbitrary direction*/ 0,\\n                                  matched_pairs,\\n Tensor<1, 2>(1.,1.));\\n Here, again, the assignment of boundary indicators 0 and 1 stems from what GridGenerator::parallelogram() documents.\\nThe resulting matched_pairs can be used in DoFTools::make_periodicity_constraints for populating an AffineConstraints object with periodicity constraints: DoFTools::make_periodicity_constraints(matched_pairs, constraints);\\nDoFTools::make_periodicity_constraintsvoid make_periodicity_constraints(const FaceIterator &face_1, const std_cxx20::type_identity_t< FaceIterator > &face_2, AffineConstraints< number > &constraints, const ComponentMask &component_mask={}, const unsigned char combined_orientation=ReferenceCell::default_combined_face_orientation(), const FullMatrix< double > &matrix=FullMatrix< double >(), const std::vector< unsigned int > &first_vector_components=std::vector< unsigned int >(), const number periodicity_factor=1.)Definition dof_tools_constraints.cc:3591\\nApart from this high level interface there are also variants of DoFTools::make_periodicity_constraints available that combine those two steps (see the variants of DofTools::make_periodicity_constraints).\\nThere is also a low level interface to DoFTools::make_periodicity_constraints if more flexibility is needed. The low level variant allows to directly specify two faces that shall be constrained: using namespace DoFTools;\\nmake_periodicity_constraints(face_1,\\n                             face_2,\\n                             affine_constraints,\\n                             component_mask = <default value>;\\n                             face_orientation = <default value>,\\n                             face_flip = <default value>,\\n                             face_rotation = <default value>,\\n                             matrix = <default value>);\\nDoFToolsDefinition dof_tools.h:226\\n Here, we need to specify the orientation of the two faces using face_orientation, face_flip and face_orientation. For a closer description have a look at the documentation of DoFTools::make_periodicity_constraints. The remaining parameters are the same as for the high level interface apart from the self-explaining component_mask and affine_constraints.\\n A practical example\\nIn the following, we show how to use the above functions in a more involved example. The task is to enforce rotated periodicity constraints for the velocity component of a Stokes flow.\\nOn a quarter-circle defined by \\\\(\\\\Omega=\\\\{{\\\\bf x}\\\\in(0,1)^2:\\\\|{\\\\bf x}\\\\|\\\\in (0.5,1)\\\\}\\\\) we are going to solve the Stokes problem     \\n\\\\begin{eqnarray*}\\n  -\\\\Delta \\\\; \\\\textbf{u} + \\\\nabla p &=& (\\\\exp(-100\\\\|{\\\\bf x}-(.75,0.1)^T\\\\|^2),0)^T, \\\\\\\\\\n  -\\\\textrm{div}\\\\;  \\\\textbf{u}&=&0,\\\\\\\\\\n  \\\\textbf{u}|_{\\\\Gamma_1}&=&{\\\\bf 0},\\n\\\\end{eqnarray*}\\n\\n where the boundary \\\\(\\\\Gamma_1\\\\) is defined as \\\\(\\\\Gamma_1 \\\\dealcoloneq \\\\{x\\\\in \\\\partial\\\\Omega: \\\\|x\\\\|\\\\in\\\\{0.5,1\\\\}\\\\}\\\\). For the remaining parts of the boundary we are going to use periodic boundary conditions, i.e.    \\n\\\\begin{align*}\\n  u_x(0,\\\\nu)&=-u_y(\\\\nu,0)&\\\\nu&\\\\in[0,1]\\\\\\\\\\n  u_y(0,\\\\nu)&=u_x(\\\\nu,0)&\\\\nu&\\\\in[0,1].\\n\\\\end{align*}\\n\\nThe mesh will be generated by GridGenerator::quarter_hyper_shell(), which also documents how it assigns boundary indicators to its various boundaries if its colorize argument is set to true.\\n The commented program\\nThis example program is a slight modification of step-22 running in parallel using Trilinos to demonstrate the usage of periodic boundary conditions in deal.II. We thus omit to discuss the majority of the source code and only comment on the parts that deal with periodicity constraints. For the rest have a look at step-22 and the full source code at the bottom.\\nIn order to implement periodic boundary conditions only two functions have to be modified:\\nStokesProblem<dim>::setup_dofs(): To populate an AffineConstraints object with periodicity constraints\\nStokesProblem<dim>::create_mesh(): To supply a distributed triangulation with periodicity information.\\n\\nThe rest of the program is identical to step-22, so let us skip this part and only show these two functions in the following. (The full program can be found in the \\\"Plain program\\\" section below, though.)\\n Setting up periodicity constraints on distributed triangulations\\n\\u00a0   template <int dim>\\n\\u00a0   void StokesProblem<dim>::create_mesh()\\n\\u00a0   {\\n\\u00a0     Point<dim> center;\\n\\u00a0     const double inner_radius = .5;\\n\\u00a0     const double outer_radius = 1.;\\n\\u00a0 \\n\\u00a0     GridGenerator::quarter_hyper_shell(\\n\\u00a0       triangulation, center, inner_radius, outer_radius, 0, true);\\n\\u00a0 \\nPointDefinition point.h:111\\ncenterPoint< 3 > centerDefinition data_out_base.cc:267\\nGridGenerator::quarter_hyper_shellvoid quarter_hyper_shell(Triangulation< dim > &tria, const Point< dim > &center, const double inner_radius, const double outer_radius, const unsigned int n_cells=0, const bool colorize=false)\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\nBefore we can prescribe periodicity constraints, we need to ensure that cells on opposite sides of the domain but connected by periodic faces are part of the ghost layer if one of them is stored on the local processor. At this point we need to think about how we want to prescribe periodicity. The vertices \\\\(\\\\text{vertices}_2\\\\) of a face on the left boundary should be matched to the vertices \\\\(\\\\text{vertices}_1\\\\) of a face on the lower boundary given by  \\\\(\\\\text{vertices}_2=R\\\\cdot\\n   \\\\text{vertices}_1+b\\\\) where the rotation matrix \\\\(R\\\\) and the offset \\\\(b\\\\) are given by       \\n\\\\begin{align*}\\n   R=\\\\begin{pmatrix}\\n   0&1\\\\\\\\-1&0\\n   \\\\end{pmatrix},\\n   \\\\quad\\n   b=\\\\begin{pmatrix}0&0\\\\end{pmatrix}.\\n   \\\\end{align*}\\n\\n The data structure we are saving the resulting information into is here based on the Triangulation.\\n\\u00a0     std::vector<GridTools::PeriodicFacePair<\\n\\u00a0       typename parallel::distributed::Triangulation<dim>::cell_iterator>>\\n\\u00a0       periodicity_vector;\\n\\u00a0 \\n\\u00a0     FullMatrix<double> rotation_matrix(dim);\\n\\u00a0     rotation_matrix[0][1] = 1.;\\n\\u00a0     rotation_matrix[1][0] = -1.;\\n\\u00a0 \\n\\u00a0     GridTools::collect_periodic_faces(triangulation,\\n\\u00a0                                       2,\\n\\u00a0                                       3,\\n\\u00a0                                       1,\\n\\u00a0                                       periodicity_vector,\\n\\u00a0                                       Tensor<1, dim>(),\\n\\u00a0                                       rotation_matrix);\\n\\u00a0 \\nFullMatrixDefinition full_matrix.h:79\\nparallel::distributed::Triangulation::cell_iteratortypename ::Triangulation< dim, spacedim >::cell_iterator cell_iteratorDefinition tria.h:287\\nGridTools::PeriodicFacePairDefinition grid_tools.h:2333\\nNow telling the triangulation about the desired periodicity is particularly easy by just calling parallel::distributed::Triangulation::add_periodicity.\\n\\u00a0     triangulation.add_periodicity(periodicity_vector);\\n\\u00a0 \\n\\u00a0     triangulation.refine_global(4 - dim);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void StokesProblem<dim>::setup_dofs()\\n\\u00a0   {\\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0 \\n\\u00a0     std::vector<unsigned int> block_component(dim + 1, 0);\\n\\u00a0     block_component[dim] = 1;\\n\\u00a0     DoFRenumbering::component_wise(dof_handler, block_component);\\n\\u00a0 \\n\\u00a0     const std::vector<types::global_dof_index> dofs_per_block =\\n\\u00a0       DoFTools::count_dofs_per_fe_block(dof_handler, block_component);\\n\\u00a0     const unsigned int n_u = dofs_per_block[0], n_p = dofs_per_block[1];\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       owned_partitioning.clear();\\n\\u00a0       const IndexSet &locally_owned_dofs = dof_handler.locally_owned_dofs();\\n\\u00a0       owned_partitioning.push_back(locally_owned_dofs.get_view(0, n_u));\\n\\u00a0       owned_partitioning.push_back(locally_owned_dofs.get_view(n_u, n_u + n_p));\\n\\u00a0 \\n\\u00a0       relevant_partitioning.clear();\\n\\u00a0       const IndexSet locally_relevant_dofs =\\n\\u00a0         DoFTools::extract_locally_relevant_dofs(dof_handler);\\n\\u00a0       relevant_partitioning.push_back(locally_relevant_dofs.get_view(0, n_u));\\n\\u00a0       relevant_partitioning.push_back(\\n\\u00a0         locally_relevant_dofs.get_view(n_u, n_u + n_p));\\n\\u00a0 \\n\\u00a0       constraints.clear();\\n\\u00a0       constraints.reinit(locally_owned_dofs, locally_relevant_dofs);\\n\\u00a0 \\n\\u00a0       const FEValuesExtractors::Vector velocities(0);\\n\\u00a0 \\n\\u00a0       DoFTools::make_hanging_node_constraints(dof_handler, constraints);\\n\\u00a0       VectorTools::interpolate_boundary_values(mapping,\\n\\u00a0                                                dof_handler,\\n\\u00a0                                                0,\\n\\u00a0                                                BoundaryValues<dim>(),\\n\\u00a0                                                constraints,\\n\\u00a0                                                fe.component_mask(velocities));\\n\\u00a0       VectorTools::interpolate_boundary_values(mapping,\\n\\u00a0                                                dof_handler,\\n\\u00a0                                                1,\\n\\u00a0                                                BoundaryValues<dim>(),\\n\\u00a0                                                constraints,\\n\\u00a0                                                fe.component_mask(velocities));\\n\\u00a0 \\nIndexSetDefinition index_set.h:70\\nIndexSet::clearvoid clear()Definition index_set.h:1752\\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nparallel::distributed::Triangulation::add_periodicityvirtual void add_periodicity(const std::vector<::GridTools::PeriodicFacePair< cell_iterator > > &) overrideDefinition tria.cc:3806\\nDoFTools::make_hanging_node_constraintsvoid make_hanging_node_constraints(const DoFHandler< dim, spacedim > &dof_handler, AffineConstraints< number > &constraints)Definition dof_tools_constraints.cc:3073\\nDoFRenumbering::component_wisevoid component_wise(DoFHandler< dim, spacedim > &dof_handler, const std::vector< unsigned int > &target_component=std::vector< unsigned int >())Definition dof_renumbering.cc:666\\nDoFTools::extract_locally_relevant_dofsIndexSet extract_locally_relevant_dofs(const DoFHandler< dim, spacedim > &dof_handler)Definition dof_tools.cc:1164\\nDoFTools::count_dofs_per_fe_blockstd::vector< types::global_dof_index > count_dofs_per_fe_block(const DoFHandler< dim, spacedim > &dof, const std::vector< unsigned int > &target_block=std::vector< unsigned int >())Definition dof_tools.cc:2104\\nVectorTools::interpolate_boundary_valuesvoid interpolate_boundary_values(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const std::map< types::boundary_id, const Function< spacedim, number > * > &function_map, std::map< types::global_dof_index, number > &boundary_values, const ComponentMask &component_mask={})\\nFEValuesExtractors::VectorDefinition fe_values_extractors.h:150\\nAfter we provided the mesh with the necessary information for the periodicity constraints, we are now able to actual create them. For describing the matching we are using the same approach as before, i.e., the \\\\(\\\\text{vertices}_2\\\\) of a face on the left boundary should be matched to the vertices \\\\(\\\\text{vertices}_1\\\\) of a face on the lower boundary given by \\\\(\\\\text{vertices}_2=R\\\\cdot \\\\text{vertices}_1+b\\\\) where the rotation matrix \\\\(R\\\\) and the offset \\\\(b\\\\) are given by       \\n\\\\begin{align*}\\n   R=\\\\begin{pmatrix}\\n   0&1\\\\\\\\-1&0\\n   \\\\end{pmatrix},\\n   \\\\quad\\n   b=\\\\begin{pmatrix}0&0\\\\end{pmatrix}.\\n   \\\\end{align*}\\n\\n These two objects not only describe how faces should be matched but also in which sense the solution should be transformed from \\\\(\\\\text{face}_2\\\\) to \\\\(\\\\text{face}_1\\\\).\\n\\u00a0       FullMatrix<double> rotation_matrix(dim);\\n\\u00a0       rotation_matrix[0][1] = 1.;\\n\\u00a0       rotation_matrix[1][0] = -1.;\\n\\u00a0 \\n\\u00a0       Tensor<1, dim> offset;\\n\\u00a0 \\nFor setting up the constraints, we first store the periodicity information in an auxiliary object of type std::vector<GridTools::PeriodicFacePair<typename DoFHandler<dim>::cell_iterator> . The periodic boundaries have the boundary indicators 2 (x=0) and 3 (y=0). All the other parameters we have set up before. In this case the direction does not matter. Due to \\\\(\\\\text{vertices}_2=R\\\\cdot \\\\text{vertices}_1+b\\\\) this is exactly what we want.\\n\\u00a0       std::vector<\\n\\u00a0         GridTools::PeriodicFacePair<typename DoFHandler<dim>::cell_iterator>>\\n\\u00a0         periodicity_vector;\\n\\u00a0 \\n\\u00a0       const unsigned int direction = 1;\\n\\u00a0 \\n\\u00a0       GridTools::collect_periodic_faces(dof_handler,\\n\\u00a0                                         2,\\n\\u00a0                                         3,\\n\\u00a0                                         direction,\\n\\u00a0                                         periodicity_vector,\\n\\u00a0                                         offset,\\n\\u00a0                                         rotation_matrix);\\n\\u00a0 \\nNext, we need to provide information on which vector valued components of the solution should be rotated. Since we choose here to just constraint the velocity and this starts at the first component of the solution vector, we simply insert a 0:\\n\\u00a0       std::vector<unsigned int> first_vector_components;\\n\\u00a0       first_vector_components.push_back(0);\\n\\u00a0 \\nAfter setting up all the information in periodicity_vector all we have to do is to tell make_periodicity_constraints to create the desired constraints.\\n\\u00a0       DoFTools::make_periodicity_constraints<dim, dim>(periodicity_vector,\\n\\u00a0                                                        constraints,\\n\\u00a0                                                        fe.component_mask(\\n\\u00a0                                                          velocities),\\n\\u00a0                                                        first_vector_components);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     constraints.close();\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       TrilinosWrappers::BlockSparsityPattern bsp(owned_partitioning,\\n\\u00a0                                                  owned_partitioning,\\n\\u00a0                                                  relevant_partitioning,\\n\\u00a0                                                  mpi_communicator);\\n\\u00a0 \\n\\u00a0       Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);\\n\\u00a0       for (unsigned int c = 0; c < dim + 1; ++c)\\n\\u00a0         for (unsigned int d = 0; d < dim + 1; ++d)\\n\\u00a0           if (!((c == dim) && (d == dim)))\\n\\u00a0             coupling[c][d] = DoFTools::always;\\n\\u00a0           else\\n\\u00a0             coupling[c][d] = DoFTools::none;\\n\\u00a0 \\n\\u00a0       DoFTools::make_sparsity_pattern(dof_handler,\\n\\u00a0                                       coupling,\\n\\u00a0                                       bsp,\\n\\u00a0                                       constraints,\\n\\u00a0                                       false,\\n\\u00a0                                       Utilities::MPI::this_mpi_process(\\n\\u00a0                                         mpi_communicator));\\n\\u00a0 \\n\\u00a0       bsp.compress();\\n\\u00a0 \\n\\u00a0       system_matrix.reinit(bsp);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       TrilinosWrappers::BlockSparsityPattern preconditioner_bsp(\\n\\u00a0         owned_partitioning,\\n\\u00a0         owned_partitioning,\\n\\u00a0         relevant_partitioning,\\n\\u00a0         mpi_communicator);\\n\\u00a0 \\n\\u00a0       Table<2, DoFTools::Coupling> preconditioner_coupling(dim + 1, dim + 1);\\n\\u00a0       for (unsigned int c = 0; c < dim + 1; ++c)\\n\\u00a0         for (unsigned int d = 0; d < dim + 1; ++d)\\n\\u00a0           if ((c == dim) && (d == dim))\\n\\u00a0             preconditioner_coupling[c][d] = DoFTools::always;\\n\\u00a0           else\\n\\u00a0             preconditioner_coupling[c][d] = DoFTools::none;\\n\\u00a0 \\n\\u00a0       DoFTools::make_sparsity_pattern(dof_handler,\\n\\u00a0                                       preconditioner_coupling,\\n\\u00a0                                       preconditioner_bsp,\\n\\u00a0                                       constraints,\\n\\u00a0                                       false,\\n\\u00a0                                       Utilities::MPI::this_mpi_process(\\n\\u00a0                                         mpi_communicator));\\n\\u00a0 \\n\\u00a0       preconditioner_bsp.compress();\\n\\u00a0 \\n\\u00a0       preconditioner_matrix.reinit(preconditioner_bsp);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     system_rhs.reinit(owned_partitioning, mpi_communicator);\\n\\u00a0     solution.reinit(owned_partitioning,\\n\\u00a0                     relevant_partitioning,\\n\\u00a0                     mpi_communicator);\\n\\u00a0   }\\n\\u00a0 \\nTableDefinition array_view.h:39\\nTrilinosWrappers::BlockSparsityPatternDefinition block_sparsity_pattern.h:665\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nDoFTools::none@ noneDefinition dof_tools.h:243\\nDoFTools::always@ alwaysDefinition dof_tools.h:247\\nPhysics::Elasticity::Kinematics::dSymmetricTensor< 2, dim, Number > d(const Tensor< 2, dim, Number > &F, const Tensor< 2, dim, Number > &dF_dt)\\nUtilities::MPI::this_mpi_processunsigned int this_mpi_process(const MPI_Comm mpi_communicator)Definition mpi.cc:107\\nThe rest of the program is then again identical to step-22. We will omit it here now, but as before, you can find these parts in the \\\"Plain program\\\" section below.\\nResults\\nThe created output is not very surprising. We simply see that the solution is periodic with respect to the left and lower boundary:\\n\\nWithout the periodicity constraints we would have ended up with the following solution:\\n\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2010 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Authors: Daniel Arndt, Matthias Maier, 2015\\n *\\n * Based on @ref step_22 \\\"step-22\\\" by Wolfgang Bangerth and Martin Kronbichler\\n */\\n \\n \\n \\n \\n#include <deal.II/base/conditional_ostream.h>\\n \\n#include <deal.II/distributed/grid_refinement.h>\\n \\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/affine_constraints.h>\\n \\n#include <deal.II/lac/trilinos_solver.h>\\n#include <deal.II/lac/trilinos_precondition.h>\\n#include <deal.II/lac/trilinos_block_sparse_matrix.h>\\n#include <deal.II/lac/trilinos_parallel_block_vector.h>\\n#include <deal.II/lac/block_sparsity_pattern.h>\\n \\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_tools.h>\\n \\n#include <deal.II/dofs/dof_renumbering.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_system.h>\\n#include <deal.II/fe/mapping_q.h>\\n \\n#include <deal.II/numerics/vector_tools.h>\\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/error_estimator.h>\\n \\nnamespace Step45\\n{\\n using namespace dealii;\\n \\n template <int dim>\\n class StokesProblem\\n  {\\n public:\\n    StokesProblem(const unsigned int degree);\\n void run();\\n \\n private:\\n void create_mesh();\\n void setup_dofs();\\n void assemble_system();\\n void solve();\\n void output_results(const unsigned int refinement_cycle) const;\\n void refine_mesh();\\n \\n const unsigned int degree;\\n \\n MPI_Comm mpi_communicator;\\n \\n parallel::distributed::Triangulation<dim> triangulation;\\n const FESystem<dim>                       fe;\\n DoFHandler<dim>                           dof_handler;\\n \\n AffineConstraints<double> constraints;\\n    std::vector<IndexSet>     owned_partitioning;\\n    std::vector<IndexSet>     relevant_partitioning;\\n \\n TrilinosWrappers::BlockSparseMatrix system_matrix;\\n \\n TrilinosWrappers::BlockSparseMatrix preconditioner_matrix;\\n \\n TrilinosWrappers::MPI::BlockVector solution;\\n TrilinosWrappers::MPI::BlockVector system_rhs;\\n \\n ConditionalOStream pcout;\\n \\n MappingQ<dim> mapping;\\n  };\\n \\n \\n \\n template <int dim>\\n class BoundaryValues : public Function<dim>\\n  {\\n public:\\n    BoundaryValues()\\n      : Function<dim>(dim + 1)\\n    {}\\n \\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n \\n virtual void vector_value(const Point<dim> &p,\\n Vector<double>   &value) const override;\\n  };\\n \\n \\n template <int dim>\\n double BoundaryValues<dim>::value(const Point<dim> & /*p*/,\\n const unsigned int component) const\\n {\\n    (void)component;\\n Assert(component < this->n_components,\\n           ExcIndexRange(component, 0, this->n_components));\\n \\n return 0;\\n  }\\n \\n \\n template <int dim>\\n void BoundaryValues<dim>::vector_value(const Point<dim> &p,\\n Vector<double>   &values) const\\n {\\n for (unsigned int c = 0; c < this->n_components; ++c)\\n      values(c) = BoundaryValues<dim>::value(p, c);\\n  }\\n \\n \\n template <int dim>\\n class RightHandSide : public Function<dim>\\n  {\\n public:\\n    RightHandSide()\\n      : Function<dim>(dim + 1)\\n    {}\\n \\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n \\n virtual void vector_value(const Point<dim> &p,\\n Vector<double>   &value) const override;\\n  };\\n \\n \\n template <int dim>\\n double RightHandSide<dim>::value(const Point<dim>  &p,\\n const unsigned int component) const\\n {\\n const Point<dim> center(0.75, 0.1);\\n const double     r = (p - center).norm();\\n \\n if (component == 0)\\n return std::exp(-100. * r * r);\\n return 0;\\n  }\\n \\n \\n template <int dim>\\n void RightHandSide<dim>::vector_value(const Point<dim> &p,\\n Vector<double>   &values) const\\n {\\n for (unsigned int c = 0; c < this->n_components; ++c)\\n      values(c) = RightHandSide<dim>::value(p, c);\\n  }\\n \\n \\n \\n template <class MatrixType, class PreconditionerType>\\n class InverseMatrix : public Subscriptor\\n  {\\n public:\\n    InverseMatrix(const MatrixType         &m,\\n const PreconditionerType &preconditioner,\\n const IndexSet           &locally_owned,\\n const MPI_Comm            mpi_communicator);\\n \\n void vmult(TrilinosWrappers::MPI::Vector       &dst,\\n const TrilinosWrappers::MPI::Vector &src) const;\\n \\n private:\\n const SmartPointer<const MatrixType> matrix;\\n const SmartPointer<const PreconditionerType> preconditioner;\\n \\n mutable TrilinosWrappers::MPI::Vector tmp;\\n  };\\n \\n \\n \\n template <class MatrixType, class PreconditionerType>\\n  InverseMatrix<MatrixType, PreconditionerType>::InverseMatrix(\\n const MatrixType         &m,\\n const PreconditionerType &preconditioner,\\n const IndexSet           &locally_owned,\\n const MPI_Comm            mpi_communicator)\\n    : matrix(&m)\\n    , preconditioner(&preconditioner)\\n    , tmp(locally_owned, mpi_communicator)\\n  {}\\n \\n \\n \\n template <class MatrixType, class PreconditionerType>\\n void InverseMatrix<MatrixType, PreconditionerType>::vmult(\\n TrilinosWrappers::MPI::Vector       &dst,\\n const TrilinosWrappers::MPI::Vector &src) const\\n {\\n SolverControl              solver_control(src.size(), 1e-6 * src.l2_norm());\\n TrilinosWrappers::SolverCG cg(solver_control,\\n TrilinosWrappers::SolverCG::AdditionalData());\\n \\n    tmp = 0.;\\n    cg.solve(*matrix, tmp, src, *preconditioner);\\n    dst = tmp;\\n  }\\n \\n \\n \\n template <class PreconditionerType>\\n class SchurComplement : public TrilinosWrappers::SparseMatrix\\n  {\\n public:\\n    SchurComplement(const TrilinosWrappers::BlockSparseMatrix &system_matrix,\\n const InverseMatrix<TrilinosWrappers::SparseMatrix,\\n                                        PreconditionerType>   &A_inverse,\\n const IndexSet                            &owned_pres,\\n const MPI_Comm mpi_communicator);\\n \\n void vmult(TrilinosWrappers::MPI::Vector       &dst,\\n const TrilinosWrappers::MPI::Vector &src) const;\\n \\n private:\\n const SmartPointer<const TrilinosWrappers::BlockSparseMatrix> system_matrix;\\n const SmartPointer<\\n const InverseMatrix<TrilinosWrappers::SparseMatrix, PreconditionerType>>\\n                                          A_inverse;\\n mutable TrilinosWrappers::MPI::Vector tmp1, tmp2;\\n  };\\n \\n \\n \\n template <class PreconditionerType>\\n  SchurComplement<PreconditionerType>::SchurComplement(\\n const TrilinosWrappers::BlockSparseMatrix &system_matrix,\\n const InverseMatrix<TrilinosWrappers::SparseMatrix, PreconditionerType>\\n                   &A_inverse,\\n const IndexSet &owned_vel,\\n const MPI_Comm  mpi_communicator)\\n    : system_matrix(&system_matrix)\\n    , A_inverse(&A_inverse)\\n    , tmp1(owned_vel, mpi_communicator)\\n    , tmp2(tmp1)\\n  {}\\n \\n \\n \\n template <class PreconditionerType>\\n void SchurComplement<PreconditionerType>::vmult(\\n TrilinosWrappers::MPI::Vector       &dst,\\n const TrilinosWrappers::MPI::Vector &src) const\\n {\\n    system_matrix->block(0, 1).vmult(tmp1, src);\\n    A_inverse->vmult(tmp2, tmp1);\\n    system_matrix->block(1, 0).vmult(dst, tmp2);\\n  }\\n \\n \\n \\n template <int dim>\\n  StokesProblem<dim>::StokesProblem(const unsigned int degree)\\n    : degree(degree)\\n    , mpi_communicator(MPI_COMM_WORLD)\\n    , triangulation(mpi_communicator)\\n    , fe(FE_Q<dim>(degree + 1) ^ dim, FE_Q<dim>(degree))\\n    , dof_handler(triangulation)\\n    , pcout(std::cout, Utilities::MPI::this_mpi_process(mpi_communicator) == 0)\\n    , mapping(degree + 1)\\n  {}\\n template <int dim>\\n void StokesProblem<dim>::create_mesh()\\n  {\\n Point<dim> center;\\n const double inner_radius = .5;\\n const double outer_radius = 1.;\\n \\n GridGenerator::quarter_hyper_shell(\\n triangulation, center, inner_radius, outer_radius, 0, true);\\n \\n    std::vector<GridTools::PeriodicFacePair<\\n typename parallel::distributed::Triangulation<dim>::cell_iterator>>\\n      periodicity_vector;\\n \\n FullMatrix<double> rotation_matrix(dim);\\n    rotation_matrix[0][1] = 1.;\\n    rotation_matrix[1][0] = -1.;\\n \\n GridTools::collect_periodic_faces(triangulation,\\n                                      2,\\n                                      3,\\n                                      1,\\n                                      periodicity_vector,\\n Tensor<1, dim>(),\\n                                      rotation_matrix);\\n \\n triangulation.add_periodicity(periodicity_vector);\\n \\n triangulation.refine_global(4 - dim);\\n  }\\n \\n \\n template <int dim>\\n void StokesProblem<dim>::setup_dofs()\\n  {\\n    dof_handler.distribute_dofs(fe);\\n \\n    std::vector<unsigned int> block_component(dim + 1, 0);\\n    block_component[dim] = 1;\\n DoFRenumbering::component_wise(dof_handler, block_component);\\n \\n const std::vector<types::global_dof_index> dofs_per_block =\\n DoFTools::count_dofs_per_fe_block(dof_handler, block_component);\\n const unsigned int n_u = dofs_per_block[0], n_p = dofs_per_block[1];\\n \\n    {\\n      owned_partitioning.clear();\\n const IndexSet &locally_owned_dofs = dof_handler.locally_owned_dofs();\\n      owned_partitioning.push_back(locally_owned_dofs.get_view(0, n_u));\\n      owned_partitioning.push_back(locally_owned_dofs.get_view(n_u, n_u + n_p));\\n \\n      relevant_partitioning.clear();\\n const IndexSet locally_relevant_dofs =\\n DoFTools::extract_locally_relevant_dofs(dof_handler);\\n      relevant_partitioning.push_back(locally_relevant_dofs.get_view(0, n_u));\\n      relevant_partitioning.push_back(\\n        locally_relevant_dofs.get_view(n_u, n_u + n_p));\\n \\n      constraints.clear();\\n      constraints.reinit(locally_owned_dofs, locally_relevant_dofs);\\n \\n const FEValuesExtractors::Vector velocities(0);\\n \\n DoFTools::make_hanging_node_constraints(dof_handler, constraints);\\n VectorTools::interpolate_boundary_values(mapping,\\n                                               dof_handler,\\n                                               0,\\n                                               BoundaryValues<dim>(),\\n                                               constraints,\\n                                               fe.component_mask(velocities));\\n VectorTools::interpolate_boundary_values(mapping,\\n                                               dof_handler,\\n                                               1,\\n                                               BoundaryValues<dim>(),\\n                                               constraints,\\n                                               fe.component_mask(velocities));\\n \\n FullMatrix<double> rotation_matrix(dim);\\n      rotation_matrix[0][1] = 1.;\\n      rotation_matrix[1][0] = -1.;\\n \\n Tensor<1, dim> offset;\\n \\n      std::vector<\\n GridTools::PeriodicFacePair<typename DoFHandler<dim>::cell_iterator>>\\n        periodicity_vector;\\n \\n const unsigned int direction = 1;\\n \\n GridTools::collect_periodic_faces(dof_handler,\\n                                        2,\\n                                        3,\\n                                        direction,\\n                                        periodicity_vector,\\n                                        offset,\\n                                        rotation_matrix);\\n \\n      std::vector<unsigned int> first_vector_components;\\n      first_vector_components.push_back(0);\\n \\n DoFTools::make_periodicity_constraints<dim, dim>(periodicity_vector,\\n                                                       constraints,\\n                                                       fe.component_mask(\\n                                                         velocities),\\n                                                       first_vector_components);\\n    }\\n \\n    constraints.close();\\n \\n    {\\n TrilinosWrappers::BlockSparsityPattern bsp(owned_partitioning,\\n                                                 owned_partitioning,\\n                                                 relevant_partitioning,\\n                                                 mpi_communicator);\\n \\n Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);\\n for (unsigned int c = 0; c < dim + 1; ++c)\\n for (unsigned int d = 0; d < dim + 1; ++d)\\n if (!((c == dim) && (d == dim)))\\n            coupling[c][d] = DoFTools::always;\\n else\\n            coupling[c][d] = DoFTools::none;\\n \\n DoFTools::make_sparsity_pattern(dof_handler,\\n                                      coupling,\\n                                      bsp,\\n                                      constraints,\\n false,\\n Utilities::MPI::this_mpi_process(\\n                                        mpi_communicator));\\n \\n      bsp.compress();\\n \\n      system_matrix.reinit(bsp);\\n    }\\n \\n    {\\n TrilinosWrappers::BlockSparsityPattern preconditioner_bsp(\\n        owned_partitioning,\\n        owned_partitioning,\\n        relevant_partitioning,\\n        mpi_communicator);\\n \\n Table<2, DoFTools::Coupling> preconditioner_coupling(dim + 1, dim + 1);\\n for (unsigned int c = 0; c < dim + 1; ++c)\\n for (unsigned int d = 0; d < dim + 1; ++d)\\n if ((c == dim) && (d == dim))\\n            preconditioner_coupling[c][d] = DoFTools::always;\\n else\\n            preconditioner_coupling[c][d] = DoFTools::none;\\n \\n DoFTools::make_sparsity_pattern(dof_handler,\\n                                      preconditioner_coupling,\\n                                      preconditioner_bsp,\\n                                      constraints,\\n false,\\n Utilities::MPI::this_mpi_process(\\n                                        mpi_communicator));\\n \\n      preconditioner_bsp.compress();\\n \\n      preconditioner_matrix.reinit(preconditioner_bsp);\\n    }\\n \\n    system_rhs.reinit(owned_partitioning, mpi_communicator);\\n    solution.reinit(owned_partitioning,\\n                    relevant_partitioning,\\n                    mpi_communicator);\\n  }\\n \\n \\n template <int dim>\\n void StokesProblem<dim>::assemble_system()\\n  {\\n    system_matrix         = 0.;\\n    system_rhs            = 0.;\\n    preconditioner_matrix = 0.;\\n \\n const QGauss<dim> quadrature_formula(degree + 2);\\n \\n FEValues<dim> fe_values(mapping,\\n                            fe,\\n                            quadrature_formula,\\n update_values | update_quadrature_points |\\n update_JxW_values | update_gradients);\\n \\n const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n \\n const unsigned int n_q_points = quadrature_formula.size();\\n \\n FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);\\n FullMatrix<double> local_preconditioner_matrix(dofs_per_cell,\\n                                                   dofs_per_cell);\\n Vector<double>     local_rhs(dofs_per_cell);\\n \\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n const RightHandSide<dim>    right_hand_side;\\n    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim + 1));\\n \\n const FEValuesExtractors::Vector velocities(0);\\n const FEValuesExtractors::Scalar pressure(dim);\\n \\n    std::vector<SymmetricTensor<2, dim>> symgrad_phi_u(dofs_per_cell);\\n    std::vector<double>                  div_phi_u(dofs_per_cell);\\n    std::vector<double>                  phi_p(dofs_per_cell);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      if (cell->is_locally_owned())\\n        {\\n          fe_values.reinit(cell);\\n          local_matrix                = 0;\\n          local_preconditioner_matrix = 0;\\n          local_rhs                   = 0;\\n \\n          right_hand_side.vector_value_list(fe_values.get_quadrature_points(),\\n                                            rhs_values);\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n            {\\n for (unsigned int k = 0; k < dofs_per_cell; ++k)\\n                {\\n                  symgrad_phi_u[k] =\\n                    fe_values[velocities].symmetric_gradient(k, q);\\n                  div_phi_u[k] = fe_values[velocities].divergence(k, q);\\n                  phi_p[k]     = fe_values[pressure].value(k, q);\\n                }\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n                {\\n for (unsigned int j = 0; j <= i; ++j)\\n                    {\\n                      local_matrix(i, j) +=\\n                        (symgrad_phi_u[i] * symgrad_phi_u[j] // diffusion\\n                         - div_phi_u[i] * phi_p[j]           // pressure force\\n                         - phi_p[i] * div_phi_u[j])          // divergence\\n                        * fe_values.JxW(q);\\n \\n                      local_preconditioner_matrix(i, j) +=\\n                        (phi_p[i] * phi_p[j]) * fe_values.JxW(q);\\n                    }\\n \\n const unsigned int component_i =\\n                    fe.system_to_component_index(i).first;\\n                  local_rhs(i) += fe_values.shape_value(i, q)  \\n                                  * rhs_values[q](component_i) \\n                                  * fe_values.JxW(q);\\n                }\\n            }\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int j = i + 1; j < dofs_per_cell; ++j)\\n              {\\n                local_matrix(i, j) = local_matrix(j, i);\\n                local_preconditioner_matrix(i, j) =\\n                  local_preconditioner_matrix(j, i);\\n              }\\n \\n          cell->get_dof_indices(local_dof_indices);\\n          constraints.distribute_local_to_global(local_matrix,\\n                                                 local_rhs,\\n                                                 local_dof_indices,\\n                                                 system_matrix,\\n                                                 system_rhs);\\n          constraints.distribute_local_to_global(local_preconditioner_matrix,\\n                                                 local_dof_indices,\\n                                                 preconditioner_matrix);\\n        }\\n \\n    system_matrix.compress(VectorOperation::add);\\n    system_rhs.compress(VectorOperation::add);\\n \\n    pcout << \\\"   Computing preconditioner...\\\" << std::endl << std::flush;\\n  }\\n \\n \\n \\n template <int dim>\\n void StokesProblem<dim>::solve()\\n  {\\n TrilinosWrappers::PreconditionJacobi A_preconditioner;\\n    A_preconditioner.initialize(system_matrix.block(0, 0));\\n \\n const InverseMatrix<TrilinosWrappers::SparseMatrix,\\n TrilinosWrappers::PreconditionJacobi>\\n      A_inverse(system_matrix.block(0, 0),\\n                A_preconditioner,\\n                owned_partitioning[0],\\n                mpi_communicator);\\n \\n TrilinosWrappers::MPI::BlockVector tmp(owned_partitioning,\\n                                           mpi_communicator);\\n \\n    {\\n TrilinosWrappers::MPI::Vector schur_rhs(owned_partitioning[1],\\n                                              mpi_communicator);\\n      A_inverse.vmult(tmp.block(0), system_rhs.block(0));\\n      system_matrix.block(1, 0).vmult(schur_rhs, tmp.block(0));\\n      schur_rhs -= system_rhs.block(1);\\n \\n      SchurComplement<TrilinosWrappers::PreconditionJacobi> schur_complement(\\n        system_matrix, A_inverse, owned_partitioning[0], mpi_communicator);\\n \\n SolverControl solver_control(solution.block(1).size(),\\n                                   1e-6 * schur_rhs.l2_norm());\\n SolverCG<TrilinosWrappers::MPI::Vector> cg(solver_control);\\n \\n TrilinosWrappers::PreconditionAMG preconditioner;\\n      preconditioner.initialize(preconditioner_matrix.block(1, 1));\\n \\n      InverseMatrix<TrilinosWrappers::SparseMatrix,\\n TrilinosWrappers::PreconditionAMG>\\n        m_inverse(preconditioner_matrix.block(1, 1),\\n                  preconditioner,\\n                  owned_partitioning[1],\\n                  mpi_communicator);\\n \\n      cg.solve(schur_complement, tmp.block(1), schur_rhs, preconditioner);\\n \\n      constraints.distribute(tmp);\\n      solution.block(1) = tmp.block(1);\\n    }\\n \\n    {\\n      system_matrix.block(0, 1).vmult(tmp.block(0), tmp.block(1));\\n      tmp.block(0) *= -1;\\n      tmp.block(0) += system_rhs.block(0);\\n \\n      A_inverse.vmult(tmp.block(0), tmp.block(0));\\n \\n      constraints.distribute(tmp);\\n      solution.block(0) = tmp.block(0);\\n    }\\n  }\\n \\n \\n \\n template <int dim>\\n void\\n  StokesProblem<dim>::output_results(const unsigned int refinement_cycle) const\\n {\\n    std::vector<std::string> solution_names(dim, \\\"velocity\\\");\\n    solution_names.emplace_back(\\\"pressure\\\");\\n \\n    std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n      data_component_interpretation(\\n        dim, DataComponentInterpretation::component_is_part_of_vector);\\n    data_component_interpretation.push_back(\\n DataComponentInterpretation::component_is_scalar);\\n \\n DataOut<dim> data_out;\\n    data_out.attach_dof_handler(dof_handler);\\n    data_out.add_data_vector(solution,\\n                             solution_names,\\n DataOut<dim>::type_dof_data,\\n                             data_component_interpretation);\\n Vector<float> subdomain(triangulation.n_active_cells());\\n for (unsigned int i = 0; i < subdomain.size(); ++i)\\n      subdomain(i) = triangulation.locally_owned_subdomain();\\n    data_out.add_data_vector(subdomain, \\\"subdomain\\\");\\n    data_out.build_patches(mapping, degree + 1);\\n \\n    data_out.write_vtu_with_pvtu_record(\\n \\\"./\\\", \\\"solution\\\", refinement_cycle, MPI_COMM_WORLD, 2);\\n  }\\n \\n \\n \\n template <int dim>\\n void StokesProblem<dim>::refine_mesh()\\n  {\\n Vector<float> estimated_error_per_cell(triangulation.n_active_cells());\\n \\n const FEValuesExtractors::Scalar pressure(dim);\\n KellyErrorEstimator<dim>::estimate(\\n      dof_handler,\\n QGauss<dim - 1>(degree + 1),\\n      std::map<types::boundary_id, const Function<dim> *>(),\\n      solution,\\n      estimated_error_per_cell,\\n      fe.component_mask(pressure));\\n \\n parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number(\\n triangulation, estimated_error_per_cell, 0.3, 0.0);\\n triangulation.execute_coarsening_and_refinement();\\n  }\\n \\n \\n template <int dim>\\n void StokesProblem<dim>::run()\\n  {\\n    create_mesh();\\n \\n for (unsigned int refinement_cycle = 0; refinement_cycle < 9;\\n         ++refinement_cycle)\\n      {\\n        pcout << \\\"Refinement cycle \\\" << refinement_cycle << std::endl;\\n \\n if (refinement_cycle > 0)\\n          refine_mesh();\\n \\n        setup_dofs();\\n \\n        pcout << \\\"   Assembling...\\\" << std::endl << std::flush;\\n        assemble_system();\\n \\n        pcout << \\\"   Solving...\\\" << std::flush;\\n        solve();\\n \\n        output_results(refinement_cycle);\\n \\n        pcout << std::endl;\\n      }\\n  }\\n} // namespace Step45\\n \\n \\nint main(int argc, char *argv[])\\n{\\n try\\n    {\\n using namespace dealii;\\n using namespace Step45;\\n \\n Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);\\n      StokesProblem<2>                 flow_problem(1);\\n      flow_problem.run();\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n \\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n \\n return 0;\\n}\\naffine_constraints.h\\nblock_sparsity_pattern.h\\nAffineConstraintsDefinition affine_constraints.h:507\\nConditionalOStreamDefinition conditional_ostream.h:80\\nDataOutInterface::write_vtu_with_pvtu_recordstd::string write_vtu_with_pvtu_record(const std::string &directory, const std::string &filename_without_extension, const unsigned int counter, const MPI_Comm mpi_communicator, const unsigned int n_digits_for_counter=numbers::invalid_unsigned_int, const unsigned int n_groups=0) constDefinition data_out_base.cc:7854\\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOutDefinition data_out.h:147\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nDoFHandlerDefinition dof_handler.h:317\\nFESystemDefinition fe_system.h:208\\nFEValuesDefinition fe_values.h:63\\nFE_QDefinition fe_q.h:554\\nFunctionDefinition function.h:152\\nIndexSet::get_viewIndexSet get_view(const size_type begin, const size_type end) constDefinition index_set.cc:273\\nKellyErrorEstimator::estimatestatic void estimate(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const Quadrature< dim - 1 > &quadrature, const std::map< types::boundary_id, const Function< spacedim, Number > * > &neumann_bc, const ReadVector< Number > &solution, Vector< float > &error, const ComponentMask &component_mask={}, const Function< spacedim > *coefficients=nullptr, const unsigned int n_threads=numbers::invalid_unsigned_int, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id, const types::material_id material_id=numbers::invalid_material_id, const Strategy strategy=cell_diameter_over_24)\\nMPI_Comm\\nMappingQDefinition mapping_q.h:110\\nQGaussDefinition quadrature_lib.h:40\\nSmartPointerDefinition smartpointer.h:93\\nSolverCGDefinition solver_cg.h:179\\nSolverControlDefinition solver_control.h:67\\nSubscriptorDefinition subscriptor.h:60\\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nTrilinosWrappers::BlockSparseMatrixDefinition trilinos_block_sparse_matrix.h:72\\nTrilinosWrappers::MPI::BlockVectorDefinition trilinos_parallel_block_vector.h:75\\nTrilinosWrappers::MPI::VectorDefinition trilinos_vector.h:405\\nTrilinosWrappers::MPI::Vector::sizesize_type size() const override\\nTrilinosWrappers::MPI::Vector::l2_normreal_type l2_norm() const\\nTrilinosWrappers::PreconditionAMGDefinition trilinos_precondition.h:1321\\nTrilinosWrappers::PreconditionAMG::initializevoid initialize(const SparseMatrix &matrix, const AdditionalData &additional_data=AdditionalData())Definition trilinos_precondition_ml.cc:221\\nTrilinosWrappers::PreconditionJacobiDefinition trilinos_precondition.h:248\\nTrilinosWrappers::PreconditionJacobi::initializevoid initialize(const SparseMatrix &matrix, const AdditionalData &additional_data=AdditionalData())Definition trilinos_precondition.cc:89\\nTrilinosWrappers::SolverCGDefinition trilinos_solver.h:375\\nTrilinosWrappers::SparseMatrixDefinition trilinos_sparse_matrix.h:550\\nTrilinosWrappers::SparseMatrix::vmultstd::enable_if_t< std::is_same_v< typename VectorType::value_type, TrilinosScalar > > vmult(VectorType &dst, const VectorType &src) constDefinition trilinos_sparse_matrix.cc:1989\\nUtilities::MPI::MPI_InitFinalizeDefinition mpi.h:1081\\nVectorDefinition vector.h:120\\nparallel::TriangulationBase::locally_owned_subdomaintypes::subdomain_id locally_owned_subdomain() const overrideDefinition tria_base.cc:345\\nparallel::distributed::TriangulationDefinition tria.h:268\\nparallel::distributed::Triangulation::execute_coarsening_and_refinementvirtual void execute_coarsening_and_refinement() overrideDefinition tria.cc:3320\\nunsigned int\\nconditional_ostream.h\\ngrid_refinement.h\\ndof_renumbering.h\\ndof_tools.h\\nerror_estimator.h\\nfe_q.h\\nfe_system.h\\ngrid_generator.h\\ngrid_tools.h\\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\nschur_complementLinearOperator< Range_2, Domain_2, Payload > schur_complement(const LinearOperator< Domain_1, Range_1, Payload > &A_inv, const LinearOperator< Range_1, Domain_2, Payload > &B, const LinearOperator< Range_2, Domain_1, Payload > &C, const LinearOperator< Range_2, Domain_2, Payload > &D)Definition schur_complement.h:247\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nInitializeLibrary::MPI@ MPI\\nmapping_q.h\\nDataComponentInterpretation::component_is_scalar@ component_is_scalarDefinition data_component_interpretation.h:52\\nDataComponentInterpretation::component_is_part_of_vector@ component_is_part_of_vectorDefinition data_component_interpretation.h:58\\nLAPACKSupport::matrix@ matrixContents is actually a matrix.Definition lapack_support.h:57\\nLocalIntegrators::Divergence::normdouble norm(const FEValuesBase< dim > &fe, const ArrayView< const std::vector< Tensor< 1, dim > > > &Du)Definition divergence.h:471\\nUtilitiesDefinition communication_pattern_base.h:30\\ndealiiDefinition namespace_dealii.h:25\\ninternal::EvaluatorQuantity::value@ value\\nparallel::distributed::GridRefinement::refine_and_coarsen_fixed_numbervoid refine_and_coarsen_fixed_number(::Triangulation< dim, spacedim > &tria, const ::Vector< Number > &criteria, const double top_fraction_of_cells, const double bottom_fraction_of_cells, const types::global_cell_index max_n_cells=std::numeric_limits< types::global_cell_index >::max())Definition grid_refinement.cc:503\\nstdSTL namespace.\\nstd::exp::VectorizedArray< Number, width > exp(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6829\\ndata_out.h\\nsolver_cg.h\\nFEValuesExtractors::ScalarDefinition fe_values_extractors.h:95\\nTrilinosWrappers::SolverBase::AdditionalDataDefinition trilinos_solver.h:118\\nVectorOperation::add@ addDefinition vector_operation.h:53\\ntrilinos_block_sparse_matrix.h\\ntrilinos_parallel_block_vector.h\\ntrilinos_precondition.h\\ntrilinos_solver.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"