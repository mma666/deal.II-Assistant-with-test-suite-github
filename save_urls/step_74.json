"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_74.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-74 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-74 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-74 tutorial program\\n\\n\\nThis tutorial depends on step-12.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nOverview\\nThe equation\\nThe penalty parameter\\nA posteriori error estimator\\nThe test case\\n\\n The commented program\\n\\nEquation data\\nAuxiliary functions\\nThe CopyData\\nThe SIPGLaplace class\\nThe assemble_system function\\nThe solve() and output_results() function\\nThe compute_error_estimate() function\\nThe compute_energy_norm_error() function\\nThe refine_grid() function\\nThe compute_errors() function\\nThe run() function\\nThe main() function\\n\\n\\n Results\\n\\n\\n The plain program\\n   \\n\\n\\n This program was contributed by Jiaqi Zhang and Timo Heister. \\n This material is based upon work partly supported by the National Science Foundation Award DMS-2028346, OAC-2015848, EAR-1925575, by the Computational Infrastructure in Geodynamics initiative (CIG), through the NSF under Award EAR-0949446 and EAR-1550901 and The University of California \\u2013 Davis. \\nNoteIf you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation:   \\n Symmetric interior penalty Galerkin (SIPG) method for Poisson's equation\\nOverview\\nIn this tutorial, we display the usage of the FEInterfaceValues class, which is designed for assembling face terms arising from discontinuous Galerkin (DG) methods. The FEInterfaceValues class provides an easy way to obtain the jump and the average of shape functions and of the solution across cell faces. This tutorial includes the following topics. \\n\\nThe SIPG method for Poisson's equation, which has already been used in step-39 and step-59. \\n\\nAssembling of face terms using FEInterfaceValues and the system matrix using MeshWorker::mesh_loop(), which is similar to step-12. \\n\\nAdaptive mesh refinement using an error estimator. \\n\\nTwo test cases: convergence test for a smooth function and adaptive mesh refinement test for a singular solution. \\n\\nThe equation\\nIn this example, we consider Poisson's equation   \\n\\\\[\\n- \\\\nabla \\\\cdot \\\\left( \\\\nu  \\\\nabla u\\\\right) = f  \\\\qquad   \\\\mbox{in } \\\\Omega,\\n\\\\]\\n\\n subject to the boundary condition   \\n\\\\[\\nu = g_D \\\\qquad \\\\mbox{on } \\\\partial \\\\Omega.\\n\\\\]\\n\\n For simplicity, we assume that the diffusion coefficient \\\\(\\\\nu\\\\) is constant here. Note that if \\\\(\\\\nu\\\\) is discontinuous, we need to take this into account when computing jump terms on cell faces.\\nWe denote the mesh by \\\\({\\\\mathbb T}_h\\\\), and \\\\(K\\\\in{\\\\mathbb T}_h\\\\) is a mesh cell. The sets of interior and boundary faces are denoted by \\\\({\\\\mathbb F}^i_h\\\\) and \\\\({\\\\mathbb F}^b_h\\\\) respectively. Let \\\\(K^0\\\\) and \\\\(K^1\\\\) be the two cells sharing a face \\\\(f\\\\in F_h^i\\\\), and \\\\(\\\\mathbf n\\\\) be the outer normal vector of \\\\(K^0\\\\). Then the jump operator is given by the \\\"here minus there\\\" formula,   \\n\\\\[\\n\\\\jump{v} = v^0 - v^1\\n\\\\]\\n\\n and the averaging operator as   \\n\\\\[\\n\\\\average{v} = \\\\frac{v^0 + v^1}{2}\\n\\\\]\\n\\n respectively. Note that when \\\\(f\\\\subset \\\\partial \\\\Omega\\\\), we define \\\\(\\\\jump{v} = v\\\\) and \\\\(\\\\average{v}=v\\\\). The discretization using the SIPG is given by the following weak formula (more details can be found in [177] and the references therein)                 \\n\\\\begin{align*}\\n&\\\\sum_{K\\\\in {\\\\mathbb T}_h} (\\\\nabla v_h, \\\\nu \\\\nabla u_h)_K\\\\\\\\\\n&-\\\\sum_{F \\\\in F_h^i} \\\\left\\\\{\\n    \\\\left< \\\\jump{v_h}, \\\\nu\\\\average{ \\\\nabla u_h} \\\\cdot  \\\\mathbf n \\\\right>_F\\n   +\\\\left<\\\\average{ \\\\nabla v_h }\\\\cdot \\\\mathbf n,\\\\nu\\\\jump{u_h}\\\\right>_F\\n   -\\\\left<\\\\jump{v_h},\\\\nu \\\\sigma \\\\jump{u_h} \\\\right>_F\\n  \\\\right\\\\}\\\\\\\\\\n&-\\\\sum_{F \\\\in F_h^b} \\\\left\\\\{\\n    \\\\left<v_h, \\\\nu  \\\\nabla u_h\\\\cdot \\\\mathbf n \\\\right>_F\\n  + \\\\left< \\\\nabla v_h \\\\cdot \\\\mathbf n , \\\\nu u_h\\\\right>_F\\n  - \\\\left< v_h,\\\\nu \\\\sigma u_h\\\\right>_F\\n  \\\\right\\\\}\\\\\\\\\\n&=(v_h, f)_\\\\Omega\\n  - \\\\sum_{F \\\\in F_h^b} \\\\left\\\\{\\n    \\\\left< \\\\nabla v_h \\\\cdot \\\\mathbf n, \\\\nu g_D\\\\right>_F - \\\\left<v_h,\\\\nu \\\\sigma g_D\\\\right>_F\\n  \\\\right\\\\}.\\n\\\\end{align*}\\n\\nThe penalty parameter\\nThe penalty parameter is defined as \\\\(\\\\sigma = \\\\gamma/h_f\\\\), where \\\\(h_f\\\\) a local length scale associated with the cell face; here we choose an approximation of the length of the cell in the direction normal to the face: \\\\(\\\\frac 1{h_f} = \\\\frac 12 \\\\left(\\\\frac 1{h_K} + \\\\frac 1{h_{K'}}\\\\right)\\\\), where \\\\(K,K'\\\\) are the two cells adjacent to the face \\\\(f\\\\) and we we compute \\\\(h_K = \\\\frac{|K|}{|f|}\\\\).\\nIn the formula above, \\\\(\\\\gamma\\\\) is the penalization constant. To ensure the discrete coercivity, the penalization constant has to be large enough [3]. People do not really have consensus on which of the formulas proposed in the literature should be used. (This is similar to the situation discussed in the \\\"Results\\\" section of step-47.) One can just pick a large constant, while other options could be the multiples of \\\\((p+1)^2\\\\) or \\\\(p(p+1)\\\\). In this code, we follow step-39 and use \\\\(\\\\gamma = p(p+1)\\\\).\\nA posteriori error estimator\\nIn this example, with a slight modification, we use the error estimator by Karakashian and Pascal [126] \\n\\\\[\\n\\\\eta^2 = \\\\sum_{K \\\\in {\\\\mathbb T}_h} \\\\eta^2_{K} +  \\\\sum_{f_i \\\\in {\\\\mathbb F}^i_h}  \\\\eta^2_{f_i} + \\\\sum_{f_b \\\\in F^i_b}\\\\eta^2_{f_b}\\n\\\\]\\n\\n where       \\n\\\\begin{align*}\\n\\\\eta^2_{K} &= h_K^2 \\\\left\\\\| f + \\\\nu \\\\Delta u_h \\\\right\\\\|_K^2,\\n\\\\\\\\\\n\\\\eta^2_{f_i} &= \\\\sigma \\\\left\\\\| \\\\jump{u_h}  \\\\right\\\\|_f^2   +  h_f \\\\left\\\\|  \\\\jump{\\\\nu \\\\nabla u_h} \\\\cdot \\\\mathbf n   \\\\right\\\\|_f^2,\\n\\\\\\\\\\n\\\\eta_{f_b}^2 &=  \\\\sigma \\\\left\\\\| u_h-g_D \\\\right\\\\|_f^2.\\n\\\\end{align*}\\n\\n Here we use \\\\(\\\\sigma = \\\\gamma/h_f\\\\) instead of \\\\(\\\\gamma^2/h_f\\\\) for the jump terms of \\\\(u_h\\\\) (the first term in \\\\(\\\\eta^2_{f_i}\\\\) and \\\\(\\\\eta_{f_b}^2\\\\)).\\nIn order to compute this estimator, in each cell \\\\(K\\\\) we compute       \\n\\\\begin{align*}\\n\\\\eta_{c}^2 &= h_K^2 \\\\left\\\\| f + \\\\nu \\\\Delta u_h \\\\right\\\\|_K^2,\\n\\\\\\\\\\n\\\\eta_{f}^2 &= \\\\sum_{f\\\\in \\\\partial K}\\\\lbrace \\\\sigma \\\\left\\\\| \\\\jump{u_h}  \\\\right\\\\|_f^2   +  h_f \\\\left\\\\|  \\\\jump{\\\\nu \\\\nabla u_h} \\\\cdot \\\\mathbf n  \\\\right\\\\|_f^2 \\\\rbrace,\\n\\\\\\\\\\n\\\\eta_{b}^2 &= \\\\sum_{f\\\\in \\\\partial K \\\\cap \\\\partial \\\\Omega}  \\\\sigma \\\\left\\\\| (u_h -g_D)  \\\\right\\\\|_f^2.\\n\\\\end{align*}\\n\\n Then the square of the error estimate per cell is   \\n\\\\[\\n\\\\eta_\\\\text{local}^2 =\\\\eta_{c}^2+0.5\\\\eta_{f}^2+\\\\eta_{b}^2.\\n\\\\]\\n\\n The factor of \\\\(0.5\\\\) results from the fact that the overall error estimator includes each interior face only once, and so the estimators per cell count it with a factor of one half for each of the two adjacent cells. Note that we compute \\\\(\\\\eta_\\\\text{local}^2\\\\) instead of \\\\(\\\\eta_\\\\text{local}\\\\) to simplify the implementation. The error estimate square per cell is then stored in a global vector, whose \\\\(l_1\\\\) norm is equal to \\\\(\\\\eta^2\\\\).\\nThe test case\\nIn the first test problem, we run a convergence test using a smooth manufactured solution with \\\\(\\\\nu =1\\\\) in 2D     \\n\\\\begin{align*}\\nu&=\\\\sin(2\\\\pi x)\\\\sin(2\\\\pi y), &\\\\qquad\\\\qquad &(x,y)\\\\in\\\\Omega=(0,1)\\\\times (0,1),\\n\\\\\\\\\\nu&=0,                        &\\\\qquad\\\\qquad &\\\\text{on } \\\\partial \\\\Omega,\\n\\\\end{align*}\\n\\n and \\\\(f= 8\\\\pi^2 u\\\\). We compute errors against the manufactured solution and evaluate the convergence rate.\\nIn the second test, we choose Functions::LSingularityFunction on a L-shaped domain (GridGenerator::hyper_L) in 2D. The solution is given in the polar coordinates by \\\\(u(r,\\\\phi) = r^{\\\\frac{2}{3}}\\\\sin \\\\left(\\\\frac{2}{3}\\\\phi \\\\right)\\\\), which has a singularity at the origin. An error estimator is constructed to detect the region with large errors, according to which the mesh is refined adaptively.\\n The commented program\\nThe first few files have already been covered in previous examples and will thus not be further commented on:\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/base/function_lib.h>\\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/sparse_direct.h>\\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_out.h>\\n\\u00a0 #include <deal.II/grid/grid_refinement.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 #include <deal.II/fe/mapping_q1.h>\\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 #include <deal.II/numerics/data_out.h>\\nHere the discontinuous finite elements and FEInterfaceValues are defined.\\n\\u00a0 #include <deal.II/fe/fe_dgq.h>\\n\\u00a0 #include <deal.II/fe/fe_interface_values.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/derivative_approximation.h>\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 #include <deal.II/base/convergence_table.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/meshworker/copy_data.h>\\n\\u00a0 #include <deal.II/meshworker/mesh_loop.h>\\n\\u00a0 #include <deal.II/meshworker/scratch_data.h>\\n\\u00a0 \\n\\u00a0 namespace Step74\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n Equation data\\nHere we define two test cases: convergence_rate for a smooth function and l_singularity for the Functions::LSingularityFunction.\\n\\u00a0   enum class TestCase\\n\\u00a0   {\\n\\u00a0     convergence_rate,\\n\\u00a0     l_singularity\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nA smooth solution for the convergence test:\\n\\u00a0   template <int dim>\\n\\u00a0   class SmoothSolution : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     SmoothSolution()\\n\\u00a0       : Function<dim>()\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     virtual void value_list(const std::vector<Point<dim>> &points,\\n\\u00a0                             std::vector<double>           &values,\\n\\u00a0                             const unsigned int component = 0) const override;\\n\\u00a0 \\n\\u00a0     virtual Tensor<1, dim>\\n\\u00a0     gradient(const Point<dim>  &point,\\n\\u00a0              const unsigned int component = 0) const override;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void SmoothSolution<dim>::value_list(const std::vector<Point<dim>> &points,\\n\\u00a0                                        std::vector<double>           &values,\\n\\u00a0                                        const unsigned int /*component*/) const\\n\\u00a0   {\\n\\u00a0     using numbers::PI;\\n\\u00a0     for (unsigned int i = 0; i < values.size(); ++i)\\n\\u00a0       values[i] =\\n\\u00a0         std::sin(2. * PI * points[i][0]) * std::sin(2. * PI * points[i][1]);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   Tensor<1, dim>\\n\\u00a0   SmoothSolution<dim>::gradient(const Point<dim> &point,\\n\\u00a0                                 const unsigned int /*component*/) const\\n\\u00a0   {\\n\\u00a0     Tensor<1, dim> return_value;\\n\\u00a0     using numbers::PI;\\n\\u00a0     return_value[0] =\\n\\u00a0       2. * PI * std::cos(2. * PI * point[0]) * std::sin(2. * PI * point[1]);\\n\\u00a0     return_value[1] =\\n\\u00a0       2. * PI * std::sin(2. * PI * point[0]) * std::cos(2. * PI * point[1]);\\n\\u00a0     return return_value;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFunctionDefinition function.h:152\\nFunction::gradientvirtual Tensor< 1, dim, RangeNumberType > gradient(const Point< dim > &p, const unsigned int component=0) const\\nFunction::value_listvirtual void value_list(const std::vector< Point< dim > > &points, std::vector< RangeNumberType > &values, const unsigned int component=0) const\\nPointDefinition point.h:111\\nTensorDefinition tensor.h:471\\nnumbers::PIstatic constexpr double PIDefinition numbers.h:259\\nstd::cos::VectorizedArray< Number, width > cos(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6609\\nstd::sin::VectorizedArray< Number, width > sin(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6589\\nThe corresponding right-hand side of the smooth function:\\n\\u00a0   template <int dim>\\n\\u00a0   class SmoothRightHandSide : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     SmoothRightHandSide()\\n\\u00a0       : Function<dim>()\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     virtual void value_list(const std::vector<Point<dim>> &points,\\n\\u00a0                             std::vector<double>           &values,\\n\\u00a0                             const unsigned int /*component*/) const override;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void\\n\\u00a0   SmoothRightHandSide<dim>::value_list(const std::vector<Point<dim>> &points,\\n\\u00a0                                        std::vector<double>           &values,\\n\\u00a0                                        const unsigned int /*component*/) const\\n\\u00a0   {\\n\\u00a0     using numbers::PI;\\n\\u00a0     for (unsigned int i = 0; i < values.size(); ++i)\\n\\u00a0       values[i] = 8. * PI * PI * std::sin(2. * PI * points[i][0]) *\\n\\u00a0                   std::sin(2. * PI * points[i][1]);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nThe right-hand side that corresponds to the function Functions::LSingularityFunction, where we assume that the diffusion coefficient \\\\(\\\\nu = 1\\\\):\\n\\u00a0   template <int dim>\\n\\u00a0   class SingularRightHandSide : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     SingularRightHandSide()\\n\\u00a0       : Function<dim>()\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     virtual void value_list(const std::vector<Point<dim>> &points,\\n\\u00a0                             std::vector<double>           &values,\\n\\u00a0                             const unsigned int /*component*/) const override;\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     const Functions::LSingularityFunction ref;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void\\n\\u00a0   SingularRightHandSide<dim>::value_list(const std::vector<Point<dim>> &points,\\n\\u00a0                                          std::vector<double>           &values,\\n\\u00a0                                          const unsigned int /*component*/) const\\n\\u00a0   {\\n\\u00a0     for (unsigned int i = 0; i < values.size(); ++i)\\n\\u00a0       values[i] = -ref.laplacian(points[i]);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFunctions::LSingularityFunctionDefinition function_lib.h:410\\nFunctions::LSingularityFunction::laplacianvirtual double laplacian(const Point< 2 > &p, const unsigned int component=0) const overrideDefinition function_lib.cc:1245\\n Auxiliary functions\\nThis function computes the penalty \\\\(\\\\sigma\\\\).\\n\\u00a0   double get_penalty_factor(const unsigned int fe_degree,\\n\\u00a0                             const double       cell_extent_left,\\n\\u00a0                             const double       cell_extent_right)\\n\\u00a0   {\\n\\u00a0     const unsigned int degree = std::max(1U, fe_degree);\\n\\u00a0     return degree * (degree + 1.) * 0.5 *\\n\\u00a0            (1. / cell_extent_left + 1. / cell_extent_right);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nstd::max::VectorizedArray< Number, width > max(const ::VectorizedArray< Number, width > &, const ::VectorizedArray< Number, width > &)Definition vectorization.h:6943\\n The CopyData\\nIn the following, we define \\\"Copy\\\" objects for the MeshWorker::mesh_loop(), which is essentially the same as step-12. Note that the \\\"Scratch\\\" object is not defined here because we use MeshWorker::ScratchData<dim> instead. (The use of \\\"Copy\\\" and \\\"Scratch\\\" objects is extensively explained in the WorkStream namespace documentation.\\n\\u00a0   struct CopyDataFace\\n\\u00a0   {\\n\\u00a0     FullMatrix<double>                   cell_matrix;\\n\\u00a0     std::vector<types::global_dof_index> joint_dof_indices;\\n\\u00a0     std::array<double, 2>                values;\\n\\u00a0     std::array<unsigned int, 2>          cell_indices;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   struct CopyData\\n\\u00a0   {\\n\\u00a0     FullMatrix<double>                   cell_matrix;\\n\\u00a0     Vector<double>                       cell_rhs;\\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices;\\n\\u00a0     std::vector<CopyDataFace>            face_data;\\n\\u00a0     double                               value;\\n\\u00a0     unsigned int cell_index;\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <class Iterator>\\n\\u00a0     void reinit(const Iterator &cell, const unsigned int dofs_per_cell)\\n\\u00a0     {\\n\\u00a0       cell_matrix.reinit(dofs_per_cell, dofs_per_cell);\\n\\u00a0       cell_rhs.reinit(dofs_per_cell);\\n\\u00a0       local_dof_indices.resize(dofs_per_cell);\\n\\u00a0       cell->get_dof_indices(local_dof_indices);\\n\\u00a0     }\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFullMatrixDefinition full_matrix.h:79\\nVectorDefinition vector.h:120\\ncell_indexunsigned int cell_indexDefinition grid_tools_topology.cc:783\\n The SIPGLaplace class\\nAfter these preparations, we proceed with the main class of this program, called SIPGLaplace. The overall structure of the class is as in many of the other tutorial programs. Major differences will only come up in the implementation of the assemble functions, since we use FEInterfaceValues to assemble face terms.\\n\\u00a0   template <int dim>\\n\\u00a0   class SIPGLaplace\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     SIPGLaplace(const TestCase &test_case);\\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void setup_system();\\n\\u00a0     void assemble_system();\\n\\u00a0     void solve();\\n\\u00a0     void refine_grid();\\n\\u00a0     void output_results(const unsigned int cycle) const;\\n\\u00a0 \\n\\u00a0     void   compute_errors();\\n\\u00a0     void   compute_error_estimate();\\n\\u00a0     double compute_energy_norm_error();\\n\\u00a0 \\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0     const unsigned int    degree;\\n\\u00a0     const QGauss<dim>     quadrature;\\n\\u00a0     const QGauss<dim - 1> face_quadrature;\\n\\u00a0     const QGauss<dim>     quadrature_overintegration;\\n\\u00a0     const QGauss<dim - 1> face_quadrature_overintegration;\\n\\u00a0     const MappingQ1<dim>  mapping;\\n\\u00a0 \\n\\u00a0     using ScratchData = MeshWorker::ScratchData<dim>;\\n\\u00a0 \\n\\u00a0     const FE_DGQ<dim> fe;\\n\\u00a0     DoFHandler<dim>   dof_handler;\\n\\u00a0 \\n\\u00a0     SparsityPattern      sparsity_pattern;\\n\\u00a0     SparseMatrix<double> system_matrix;\\n\\u00a0     Vector<double>       solution;\\n\\u00a0     Vector<double>       system_rhs;\\n\\u00a0 \\nDoFHandlerDefinition dof_handler.h:317\\nFE_DGQDefinition fe_dgq.h:112\\nMappingQ1Definition mapping_q1.h:55\\nMeshWorker::ScratchDataDefinition scratch_data.h:210\\nQGaussDefinition quadrature_lib.h:40\\nSparseMatrixDefinition sparse_matrix.h:520\\nSparsityPatternDefinition sparsity_pattern.h:343\\nTriangulationDefinition tria.h:1323\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\nThe remainder of the class's members are used for the following:\\nVectors to store error estimator square and energy norm square per cell.\\nPrint convergence rate and errors on the screen.\\nThe fiffusion coefficient \\\\(\\\\nu\\\\) is set to 1.\\nMembers that store information about the test case to be computed.\\n\\n\\u00a0     Vector<double> estimated_error_square_per_cell;\\n\\u00a0     Vector<double> energy_norm_square_per_cell;\\n\\u00a0 \\n\\u00a0     ConvergenceTable convergence_table;\\n\\u00a0 \\n\\u00a0     const double diffusion_coefficient = 1.;\\n\\u00a0 \\n\\u00a0     const TestCase                       test_case;\\n\\u00a0     std::unique_ptr<const Function<dim>> exact_solution;\\n\\u00a0     std::unique_ptr<const Function<dim>> rhs_function;\\n\\u00a0   };\\n\\u00a0 \\nConvergenceTableDefinition convergence_table.h:64\\nThe constructor here takes the test case as input and then determines the correct solution and right-hand side classes. The remaining member variables are initialized in the obvious way.\\n\\u00a0   template <int dim>\\n\\u00a0   SIPGLaplace<dim>::SIPGLaplace(const TestCase &test_case)\\n\\u00a0     : degree(3)\\n\\u00a0     , quadrature(degree + 1)\\n\\u00a0     , face_quadrature(degree + 1)\\n\\u00a0     , quadrature_overintegration(degree + 2)\\n\\u00a0     , face_quadrature_overintegration(degree + 2)\\n\\u00a0     , mapping()\\n\\u00a0     , fe(degree)\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0     , test_case(test_case)\\n\\u00a0   {\\n\\u00a0     if (test_case == TestCase::convergence_rate)\\n\\u00a0       {\\n\\u00a0         exact_solution = std::make_unique<const SmoothSolution<dim>>();\\n\\u00a0         rhs_function   = std::make_unique<const SmoothRightHandSide<dim>>();\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     else if (test_case == TestCase::l_singularity)\\n\\u00a0       {\\n\\u00a0         exact_solution =\\n\\u00a0           std::make_unique<const Functions::LSingularityFunction>();\\n\\u00a0         rhs_function = std::make_unique<const SingularRightHandSide<dim>>();\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       AssertThrow(false, ExcNotImplemented());\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void SIPGLaplace<dim>::setup_system()\\n\\u00a0   {\\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0     DynamicSparsityPattern dsp(dof_handler.n_dofs());\\n\\u00a0     DoFTools::make_flux_sparsity_pattern(dof_handler, dsp);\\n\\u00a0     sparsity_pattern.copy_from(dsp);\\n\\u00a0 \\n\\u00a0     system_matrix.reinit(sparsity_pattern);\\n\\u00a0     solution.reinit(dof_handler.n_dofs());\\n\\u00a0     system_rhs.reinit(dof_handler.n_dofs());\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nAssertThrow#define AssertThrow(cond, exc)Definition exceptions.h:1739\\nDoFTools::make_flux_sparsity_patternvoid make_flux_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern)Definition dof_tools_sparsity.cc:697\\nstdSTL namespace.\\n The assemble_system function\\nThe assemble function here is similar to that in step-12 and step-47. Different from assembling by hand, we just need to focus on assembling on each cell, each boundary face, and each interior face. The loops over cells and faces are handled automatically by MeshWorker::mesh_loop().\\nThe function starts by defining a local (lambda) function that is used to integrate the cell terms:\\n\\u00a0   template <int dim>\\n\\u00a0   void SIPGLaplace<dim>::assemble_system()\\n\\u00a0   {\\n\\u00a0     const auto cell_worker =\\n\\u00a0       [&](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0           ScratchData                                          &scratch_data,\\n\\u00a0           CopyData                                             &copy_data) {\\n\\u00a0         const FEValues<dim> &fe_v          = scratch_data.reinit(cell);\\n\\u00a0         const unsigned int   dofs_per_cell = fe_v.dofs_per_cell;\\n\\u00a0         copy_data.reinit(cell, dofs_per_cell);\\n\\u00a0 \\n\\u00a0         const std::vector<Point<dim>> &q_points =\\n\\u00a0           scratch_data.get_quadrature_points();\\n\\u00a0         const unsigned int         n_q_points = q_points.size();\\n\\u00a0         const std::vector<double> &JxW        = scratch_data.get_JxW_values();\\n\\u00a0 \\n\\u00a0         std::vector<double> rhs(n_q_points);\\n\\u00a0         rhs_function->value_list(q_points, rhs);\\n\\u00a0 \\n\\u00a0         for (unsigned int point = 0; point < n_q_points; ++point)\\n\\u00a0           for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)\\n\\u00a0             {\\n\\u00a0               for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j)\\n\\u00a0                 copy_data.cell_matrix(i, j) +=\\n\\u00a0                   diffusion_coefficient *     // nu\\n\\u00a0                   fe_v.shape_grad(i, point) * // grad v_h\\n\\u00a0                   fe_v.shape_grad(j, point) * // grad u_h\\n\\u00a0                   JxW[point];                 // dx\\n\\u00a0 \\n\\u00a0               copy_data.cell_rhs(i) += fe_v.shape_value(i, point) * // v_h\\n\\u00a0                                        rhs[point] *                 // f\\n\\u00a0                                        JxW[point];                  // dx\\n\\u00a0             }\\n\\u00a0       };\\n\\u00a0 \\nFEValuesDefinition fe_values.h:63\\nFEValues::reinitvoid reinit(const TriaIterator< DoFCellAccessor< dim, spacedim, level_dof_access > > &cell)\\nDoFHandler::active_cell_iteratortypename ActiveSelector::active_cell_iterator active_cell_iteratorDefinition dof_handler.h:440\\nNext, we need a function that assembles face integrals on the boundary:\\n\\u00a0     const auto boundary_worker =\\n\\u00a0       [&](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0           const unsigned int                                   &face_no,\\n\\u00a0           ScratchData                                          &scratch_data,\\n\\u00a0           CopyData                                             &copy_data) {\\n\\u00a0         const FEFaceValuesBase<dim> &fe_fv = scratch_data.reinit(cell, face_no);\\n\\u00a0 \\n\\u00a0         const std::vector<Point<dim>> &q_points =\\n\\u00a0           scratch_data.get_quadrature_points();\\n\\u00a0         const unsigned int n_q_points    = q_points.size();\\n\\u00a0         const unsigned int dofs_per_cell = fe_fv.dofs_per_cell;\\n\\u00a0 \\n\\u00a0         const std::vector<double>         &JxW = scratch_data.get_JxW_values();\\n\\u00a0         const std::vector<Tensor<1, dim>> &normals =\\n\\u00a0           scratch_data.get_normal_vectors();\\n\\u00a0 \\n\\u00a0         std::vector<double> g(n_q_points);\\n\\u00a0         exact_solution->value_list(q_points, g);\\n\\u00a0 \\n\\u00a0         const double extent1 = cell->measure() / cell->face(face_no)->measure();\\n\\u00a0         const double penalty = get_penalty_factor(degree, extent1, extent1);\\n\\u00a0 \\n\\u00a0         for (unsigned int point = 0; point < n_q_points; ++point)\\n\\u00a0           {\\n\\u00a0             for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0               for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0                 copy_data.cell_matrix(i, j) +=\\n\\u00a0                   (-diffusion_coefficient *        // - nu\\n\\u00a0                      fe_fv.shape_value(i, point) * // v_h\\n\\u00a0                      (fe_fv.shape_grad(j, point) * // (grad u_h .\\n\\u00a0                       normals[point])              //  n)\\n\\u00a0 \\n\\u00a0                    - diffusion_coefficient *         // - nu\\n\\u00a0                        (fe_fv.shape_grad(i, point) * // (grad v_h .\\n\\u00a0                         normals[point]) *            //  n)\\n\\u00a0                        fe_fv.shape_value(j, point)   // u_h\\n\\u00a0 \\n\\u00a0                    + diffusion_coefficient * penalty * // + nu sigma\\n\\u00a0                        fe_fv.shape_value(i, point) *   // v_h\\n\\u00a0                        fe_fv.shape_value(j, point)     // u_h\\n\\u00a0 \\n\\u00a0                    ) *\\n\\u00a0                   JxW[point]; // dx\\n\\u00a0 \\n\\u00a0             for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0               copy_data.cell_rhs(i) +=\\n\\u00a0                 (-diffusion_coefficient *        // - nu\\n\\u00a0                    (fe_fv.shape_grad(i, point) * // (grad v_h .\\n\\u00a0                     normals[point]) *            //  n)\\n\\u00a0                    g[point]                      // g\\n\\u00a0 \\n\\u00a0 \\n\\u00a0                  + diffusion_coefficient * penalty *        // + nu sigma\\n\\u00a0                      fe_fv.shape_value(i, point) * g[point] // v_h g\\n\\u00a0 \\n\\u00a0                  ) *\\n\\u00a0                 JxW[point]; // dx\\n\\u00a0           }\\n\\u00a0       };\\n\\u00a0 \\nFEFaceValuesBaseDefinition fe_values.h:202\\nFEValuesBase::get_quadrature_pointsconst std::vector< Point< spacedim > > & get_quadrature_points() const\\nFinally, a function that assembles face integrals on interior faces. To reinitialize FEInterfaceValues, we need to pass cells, face and subface indices (for adaptive refinement) to the reinit() function of FEInterfaceValues:\\n\\u00a0     const auto face_worker =\\n\\u00a0       [&](const typename DoFHandler<dim>::cell_iterator &cell,\\n\\u00a0           const unsigned int                            &f,\\n\\u00a0           const unsigned int                            &sf,\\n\\u00a0           const typename DoFHandler<dim>::cell_iterator &ncell,\\n\\u00a0           const unsigned int                            &nf,\\n\\u00a0           const unsigned int                            &nsf,\\n\\u00a0           ScratchData                                   &scratch_data,\\n\\u00a0           CopyData                                      &copy_data) {\\n\\u00a0         const FEInterfaceValues<dim> &fe_iv =\\n\\u00a0           scratch_data.reinit(cell, f, sf, ncell, nf, nsf);\\n\\u00a0 \\n\\u00a0         copy_data.face_data.emplace_back();\\n\\u00a0         CopyDataFace      &copy_data_face = copy_data.face_data.back();\\n\\u00a0         const unsigned int n_dofs_face    = fe_iv.n_current_interface_dofs();\\n\\u00a0         copy_data_face.joint_dof_indices  = fe_iv.get_interface_dof_indices();\\n\\u00a0         copy_data_face.cell_matrix.reinit(n_dofs_face, n_dofs_face);\\n\\u00a0 \\n\\u00a0         const std::vector<double>         &JxW     = fe_iv.get_JxW_values();\\n\\u00a0         const std::vector<Tensor<1, dim>> &normals = fe_iv.get_normal_vectors();\\n\\u00a0 \\n\\u00a0         const double extent1 = cell->measure() / cell->face(f)->measure();\\n\\u00a0         const double extent2 = ncell->measure() / ncell->face(nf)->measure();\\n\\u00a0         const double penalty = get_penalty_factor(degree, extent1, extent2);\\n\\u00a0 \\n\\u00a0         for (const unsigned int point : fe_iv.quadrature_point_indices())\\n\\u00a0           {\\n\\u00a0             for (const unsigned int i : fe_iv.dof_indices())\\n\\u00a0               for (const unsigned int j : fe_iv.dof_indices())\\n\\u00a0                 copy_data_face.cell_matrix(i, j) +=\\n\\u00a0                   (-diffusion_coefficient *                     // - nu\\n\\u00a0                      fe_iv.jump_in_shape_values(i, point) *     // [v_h]\\n\\u00a0                      (fe_iv.average_of_shape_gradients(j,       \\n\\u00a0                                                        point) * // ({grad u_h} .\\n\\u00a0                       normals[point])                           //  n)\\n\\u00a0 \\n\\u00a0                    - diffusion_coefficient * // - nu\\n\\u00a0                        (fe_iv.average_of_shape_gradients(i,\\n\\u00a0                                                          point) * // (grad v_h .\\n\\u00a0                         normals[point]) *                         //  n)\\n\\u00a0                        fe_iv.jump_in_shape_values(j, point)       // [u_h]\\n\\u00a0 \\n\\u00a0                    + diffusion_coefficient * penalty *        // + nu sigma\\n\\u00a0                        fe_iv.jump_in_shape_values(i, point) * // [v_h]\\n\\u00a0                        fe_iv.jump_in_shape_values(j, point)   // [u_h]\\n\\u00a0 \\n\\u00a0                    ) *\\n\\u00a0                   JxW[point]; // dx\\n\\u00a0           }\\n\\u00a0       };\\n\\u00a0 \\nFEInterfaceValuesDefinition fe_interface_values.h:1277\\nFEInterfaceValues::reinitvoid reinit(const CellIteratorType &cell, const unsigned int face_no, const unsigned int sub_face_no, const CellNeighborIteratorType &cell_neighbor, const unsigned int face_no_neighbor, const unsigned int sub_face_no_neighbor, const unsigned int q_index=numbers::invalid_unsigned_int, const unsigned int mapping_index=numbers::invalid_unsigned_int, const unsigned int fe_index=numbers::invalid_unsigned_int, const unsigned int fe_index_neighbor=numbers::invalid_unsigned_int)\\nint\\nDoFHandler::cell_iteratortypename ActiveSelector::cell_iterator cell_iteratorDefinition dof_handler.h:468\\nThe following lambda function will then copy data into the global matrix and right-hand side. Though there are no hanging node constraints in DG discretization, we define an empty AffineConstraints object that allows us to use the AffineConstraints::distribute_local_to_global() functionality.\\n\\u00a0     AffineConstraints<double> constraints;\\n\\u00a0     constraints.close();\\n\\u00a0     const auto copier = [&](const CopyData &c) {\\n\\u00a0       constraints.distribute_local_to_global(c.cell_matrix,\\n\\u00a0                                              c.cell_rhs,\\n\\u00a0                                              c.local_dof_indices,\\n\\u00a0                                              system_matrix,\\n\\u00a0                                              system_rhs);\\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nAffineConstraints::closevoid close()\\nCopy data from interior face assembly to the global matrix.\\n\\u00a0       for (const CopyDataFace &cdf : c.face_data)\\n\\u00a0         {\\n\\u00a0           constraints.distribute_local_to_global(cdf.cell_matrix,\\n\\u00a0                                                  cdf.joint_dof_indices,\\n\\u00a0                                                  system_matrix);\\n\\u00a0         }\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\nWith the assembly functions defined, we can now create ScratchData and CopyData objects, and pass them together with the lambda functions above to MeshWorker::mesh_loop(). In addition, we need to specify that we want to assemble on interior faces exactly once.\\n\\u00a0     const UpdateFlags cell_flags = update_values | update_gradients |\\n\\u00a0                                    update_quadrature_points | update_JxW_values;\\n\\u00a0     const UpdateFlags face_flags = update_values | update_gradients |\\n\\u00a0                                    update_quadrature_points |\\n\\u00a0                                    update_normal_vectors | update_JxW_values;\\n\\u00a0 \\n\\u00a0     ScratchData scratch_data(\\n\\u00a0       mapping, fe, quadrature, cell_flags, face_quadrature, face_flags);\\n\\u00a0     CopyData copy_data;\\n\\u00a0 \\n\\u00a0     MeshWorker::mesh_loop(dof_handler.begin_active(),\\n\\u00a0                           dof_handler.end(),\\n\\u00a0                           cell_worker,\\n\\u00a0                           copier,\\n\\u00a0                           scratch_data,\\n\\u00a0                           copy_data,\\n\\u00a0                           MeshWorker::assemble_own_cells |\\n\\u00a0                             MeshWorker::assemble_boundary_faces |\\n\\u00a0                             MeshWorker::assemble_own_interior_faces_once,\\n\\u00a0                           boundary_worker,\\n\\u00a0                           face_worker);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nMeshWorker::mesh_loopvoid mesh_loop(const CellIteratorType &begin, const CellIteratorType &end, const CellWorkerFunctionType &cell_worker, const CopierType &copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const AssembleFlags flags=assemble_own_cells, const BoundaryWorkerFunctionType &boundary_worker=BoundaryWorkerFunctionType(), const FaceWorkerFunctionType &face_worker=FaceWorkerFunctionType(), const unsigned int queue_length=2 *MultithreadInfo::n_threads(), const unsigned int chunk_size=8)Definition mesh_loop.h:281\\nUpdateFlagsUpdateFlagsDefinition fe_update_flags.h:64\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_normal_vectors@ update_normal_vectorsNormal vectors.Definition fe_update_flags.h:141\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nMeshWorker::assemble_boundary_faces@ assemble_boundary_facesDefinition assemble_flags.h:80\\nMeshWorker::assemble_own_cells@ assemble_own_cellsDefinition assemble_flags.h:49\\nMeshWorker::assemble_own_interior_faces_once@ assemble_own_interior_faces_onceDefinition assemble_flags.h:58\\n The solve() and output_results() function\\nThe following two functions are entirely standard and without difficulty.\\n\\u00a0   template <int dim>\\n\\u00a0   void SIPGLaplace<dim>::solve()\\n\\u00a0   {\\n\\u00a0     SparseDirectUMFPACK A_direct;\\n\\u00a0     A_direct.initialize(system_matrix);\\n\\u00a0     A_direct.vmult(solution, system_rhs);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void SIPGLaplace<dim>::output_results(const unsigned int cycle) const\\n\\u00a0   {\\n\\u00a0     const std::string filename = \\\"sol_Q\\\" + Utilities::int_to_string(degree, 1) +\\n\\u00a0                                  \\\"-\\\" + Utilities::int_to_string(cycle, 2) +\\n\\u00a0                                  \\\".vtu\\\";\\n\\u00a0     std::ofstream output(filename);\\n\\u00a0 \\n\\u00a0     DataOut<dim> data_out;\\n\\u00a0     data_out.attach_dof_handler(dof_handler);\\n\\u00a0     data_out.add_data_vector(solution, \\\"u\\\", DataOut<dim>::type_dof_data);\\n\\u00a0     data_out.build_patches(mapping);\\n\\u00a0     data_out.write_vtu(output);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nSparseDirectUMFPACKDefinition sparse_direct.h:92\\nSparseDirectUMFPACK::initializevoid initialize(const SparsityPattern &sparsity_pattern)Definition sparse_direct.cc:67\\nUtilities::int_to_stringstd::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)Definition utilities.cc:470\\n The compute_error_estimate() function\\nThe assembly of the error estimator here is quite similar to that of the global matrix and right-had side and can be handled by the MeshWorker::mesh_loop() framework. To understand what each of the local (lambda) functions is doing, recall first that the local cell residual is defined as \\\\(h_K^2 \\\\left\\\\| f + \\\\nu \\\\Delta u_h \\\\right\\\\|_K^2\\\\):\\n\\u00a0   template <int dim>\\n\\u00a0   void SIPGLaplace<dim>::compute_error_estimate()\\n\\u00a0   {\\n\\u00a0     const auto cell_worker =\\n\\u00a0       [&](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0           ScratchData                                          &scratch_data,\\n\\u00a0           CopyData                                             &copy_data) {\\n\\u00a0         const FEValues<dim> &fe_v = scratch_data.reinit(cell);\\n\\u00a0 \\n\\u00a0         copy_data.cell_index = cell->active_cell_index();\\n\\u00a0 \\n\\u00a0         const std::vector<Point<dim>> &q_points = fe_v.get_quadrature_points();\\n\\u00a0         const unsigned int             n_q_points = q_points.size();\\n\\u00a0         const std::vector<double>     &JxW        = fe_v.get_JxW_values();\\n\\u00a0 \\n\\u00a0         std::vector<Tensor<2, dim>> hessians(n_q_points);\\n\\u00a0         fe_v.get_function_hessians(solution, hessians);\\n\\u00a0 \\n\\u00a0         std::vector<double> rhs(n_q_points);\\n\\u00a0         rhs_function->value_list(q_points, rhs);\\n\\u00a0 \\n\\u00a0         const double hk                   = cell->diameter();\\n\\u00a0         double       residual_norm_square = 0;\\n\\u00a0 \\n\\u00a0         for (unsigned int point = 0; point < n_q_points; ++point)\\n\\u00a0           {\\n\\u00a0             const double residual =\\n\\u00a0               rhs[point] + diffusion_coefficient * trace(hessians[point]);\\n\\u00a0             residual_norm_square += residual * residual * JxW[point];\\n\\u00a0           }\\n\\u00a0         copy_data.value = hk * hk * residual_norm_square;\\n\\u00a0       };\\n\\u00a0 \\ntraceDEAL_II_HOST constexpr Number trace(const SymmetricTensor< 2, dim2, Number > &)\\nNext compute boundary terms  \\\\(\\\\sum_{f\\\\in \\\\partial K \\\\cap \\\\partial \\\\Omega}\\n   \\\\sigma \\\\left\\\\| [  u_h-g_D ]  \\\\right\\\\|_f^2  \\\\):\\n\\u00a0     const auto boundary_worker =\\n\\u00a0       [&](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0           const unsigned int                                   &face_no,\\n\\u00a0           ScratchData                                          &scratch_data,\\n\\u00a0           CopyData                                             &copy_data) {\\n\\u00a0         const FEFaceValuesBase<dim> &fe_fv = scratch_data.reinit(cell, face_no);\\n\\u00a0 \\n\\u00a0         const std::vector<Point<dim>> &q_points = fe_fv.get_quadrature_points();\\n\\u00a0         const unsigned                 n_q_points = q_points.size();\\n\\u00a0 \\n\\u00a0         const std::vector<double> &JxW = fe_fv.get_JxW_values();\\n\\u00a0 \\n\\u00a0         std::vector<double> g(n_q_points);\\n\\u00a0         exact_solution->value_list(q_points, g);\\n\\u00a0 \\n\\u00a0         std::vector<double> sol_u(n_q_points);\\n\\u00a0         fe_fv.get_function_values(solution, sol_u);\\n\\u00a0 \\n\\u00a0         const double extent1 = cell->measure() / cell->face(face_no)->measure();\\n\\u00a0         const double penalty = get_penalty_factor(degree, extent1, extent1);\\n\\u00a0 \\n\\u00a0         double difference_norm_square = 0.;\\n\\u00a0         for (unsigned int point = 0; point < q_points.size(); ++point)\\n\\u00a0           {\\n\\u00a0             const double diff = (g[point] - sol_u[point]);\\n\\u00a0             difference_norm_square += diff * diff * JxW[point];\\n\\u00a0           }\\n\\u00a0         copy_data.value += penalty * difference_norm_square;\\n\\u00a0       };\\n\\u00a0 \\nAnd finally interior face terms   \\\\(\\\\sum_{f\\\\in \\\\partial K}\\\\lbrace \\\\sigma\\n   \\\\left\\\\| [u_h]  \\\\right\\\\|_f^2   +  h_f \\\\left\\\\|  [\\\\nu \\\\nabla u_h \\\\cdot\\n   \\\\mathbf n ] \\\\right\\\\|_f^2 \\\\rbrace\\\\):\\n\\u00a0     const auto face_worker =\\n\\u00a0       [&](const typename DoFHandler<dim>::cell_iterator &cell,\\n\\u00a0           const unsigned int                            &f,\\n\\u00a0           const unsigned int                            &sf,\\n\\u00a0           const typename DoFHandler<dim>::cell_iterator &ncell,\\n\\u00a0           const unsigned int                            &nf,\\n\\u00a0           const unsigned int                            &nsf,\\n\\u00a0           ScratchData                                   &scratch_data,\\n\\u00a0           CopyData                                      &copy_data) {\\n\\u00a0         const FEInterfaceValues<dim> &fe_iv =\\n\\u00a0           scratch_data.reinit(cell, f, sf, ncell, nf, nsf);\\n\\u00a0 \\n\\u00a0         copy_data.face_data.emplace_back();\\n\\u00a0         CopyDataFace &copy_data_face = copy_data.face_data.back();\\n\\u00a0 \\n\\u00a0         copy_data_face.cell_indices[0] = cell->active_cell_index();\\n\\u00a0         copy_data_face.cell_indices[1] = ncell->active_cell_index();\\n\\u00a0 \\n\\u00a0         const std::vector<double>         &JxW     = fe_iv.get_JxW_values();\\n\\u00a0         const std::vector<Tensor<1, dim>> &normals = fe_iv.get_normal_vectors();\\n\\u00a0 \\n\\u00a0         const std::vector<Point<dim>> &q_points = fe_iv.get_quadrature_points();\\n\\u00a0         const unsigned int             n_q_points = q_points.size();\\n\\u00a0 \\n\\u00a0         std::vector<double> jump(n_q_points);\\n\\u00a0         fe_iv.get_jump_in_function_values(solution, jump);\\n\\u00a0 \\n\\u00a0         std::vector<Tensor<1, dim>> grad_jump(n_q_points);\\n\\u00a0         fe_iv.get_jump_in_function_gradients(solution, grad_jump);\\n\\u00a0 \\n\\u00a0         const double h = cell->face(f)->diameter();\\n\\u00a0 \\n\\u00a0         const double extent1 = cell->measure() / cell->face(f)->measure();\\n\\u00a0         const double extent2 = ncell->measure() / ncell->face(nf)->measure();\\n\\u00a0         const double penalty = get_penalty_factor(degree, extent1, extent2);\\n\\u00a0 \\n\\u00a0         double flux_jump_square = 0;\\n\\u00a0         double u_jump_square    = 0;\\n\\u00a0         for (unsigned int point = 0; point < n_q_points; ++point)\\n\\u00a0           {\\n\\u00a0             u_jump_square += jump[point] * jump[point] * JxW[point];\\n\\u00a0             const double flux_jump = grad_jump[point] * normals[point];\\n\\u00a0             flux_jump_square +=\\n\\u00a0               diffusion_coefficient * flux_jump * flux_jump * JxW[point];\\n\\u00a0           }\\n\\u00a0         copy_data_face.values[0] =\\n\\u00a0           0.5 * h * (flux_jump_square + penalty * u_jump_square);\\n\\u00a0         copy_data_face.values[1] = copy_data_face.values[0];\\n\\u00a0       };\\n\\u00a0 \\nHaving computed local contributions for each cell, we still need a way to copy these into the global vector that will hold the error estimators for all cells:\\n\\u00a0     const auto copier = [&](const CopyData &copy_data) {\\n\\u00a0       if (copy_data.cell_index != numbers::invalid_unsigned_int)\\n\\u00a0         estimated_error_square_per_cell[copy_data.cell_index] +=\\n\\u00a0           copy_data.value;\\n\\u00a0       for (const CopyDataFace &cdf : copy_data.face_data)\\n\\u00a0         for (unsigned int j = 0; j < 2; ++j)\\n\\u00a0           estimated_error_square_per_cell[cdf.cell_indices[j]] += cdf.values[j];\\n\\u00a0     };\\n\\u00a0 \\nnumbers::invalid_unsigned_intstatic const unsigned int invalid_unsigned_intDefinition types.h:220\\nAfter all of this set-up, let's do the actual work: We resize the vector into which the results will be written, and then drive the whole process using the MeshWorker::mesh_loop() function.\\n\\u00a0     estimated_error_square_per_cell.reinit(triangulation.n_active_cells());\\n\\u00a0 \\n\\u00a0     const UpdateFlags cell_flags =\\n\\u00a0       update_hessians | update_quadrature_points | update_JxW_values;\\n\\u00a0     const UpdateFlags face_flags = update_values | update_gradients |\\n\\u00a0                                    update_quadrature_points |\\n\\u00a0                                    update_JxW_values | update_normal_vectors;\\n\\u00a0 \\n\\u00a0     ScratchData scratch_data(\\n\\u00a0       mapping, fe, quadrature, cell_flags, face_quadrature, face_flags);\\n\\u00a0 \\n\\u00a0     CopyData copy_data;\\n\\u00a0     MeshWorker::mesh_loop(dof_handler.begin_active(),\\n\\u00a0                           dof_handler.end(),\\n\\u00a0                           cell_worker,\\n\\u00a0                           copier,\\n\\u00a0                           scratch_data,\\n\\u00a0                           copy_data,\\n\\u00a0                           MeshWorker::assemble_own_cells |\\n\\u00a0                             MeshWorker::assemble_own_interior_faces_once |\\n\\u00a0                             MeshWorker::assemble_boundary_faces,\\n\\u00a0                           boundary_worker,\\n\\u00a0                           face_worker);\\n\\u00a0   }\\n\\u00a0 \\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nupdate_hessians@ update_hessiansSecond derivatives of shape functions.Definition fe_update_flags.h:87\\n The compute_energy_norm_error() function\\nNext, we evaluate the accuracy in terms of the energy norm. This function is similar to the assembling of the error estimator above. Here we compute the square of the energy norm defined by     \\n\\\\[\\n   \\\\|u \\\\|_{1,h}^2 = \\\\sum_{K \\\\in \\\\Gamma_h} \\\\nu\\\\|\\\\nabla u \\\\|_K^2 +\\n   \\\\sum_{f \\\\in F_i} \\\\sigma \\\\| [ u ] \\\\|_f^2 +\\n   \\\\sum_{f \\\\in F_b} \\\\sigma  \\\\|u\\\\|_f^2.\\n   \\\\]\\n\\n Therefore the corresponding error is     \\n\\\\[\\n   \\\\|u -u_h \\\\|_{1,h}^2 = \\\\sum_{K \\\\in \\\\Gamma_h} \\\\nu\\\\|\\\\nabla (u_h - u)  \\\\|_K^2\\n   + \\\\sum_{f \\\\in F_i} \\\\sigma  \\\\|[ u_h ] \\\\|_f^2 + \\\\sum_{f \\\\in F_b}\\\\sigma\\n   \\\\|u_h-g_D\\\\|_f^2.\\n   \\\\]\\n\\n\\u00a0   template <int dim>\\n\\u00a0   double SIPGLaplace<dim>::compute_energy_norm_error()\\n\\u00a0   {\\n\\u00a0     energy_norm_square_per_cell.reinit(triangulation.n_active_cells());\\n\\u00a0 \\nAssemble \\\\(\\\\sum_{K \\\\in \\\\Gamma_h} \\\\nu\\\\|\\\\nabla (u_h - u)  \\\\|_K^2 \\\\).\\n\\u00a0     const auto cell_worker =\\n\\u00a0       [&](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0           ScratchData                                          &scratch_data,\\n\\u00a0           CopyData                                             &copy_data) {\\n\\u00a0         const FEValues<dim> &fe_v = scratch_data.reinit(cell);\\n\\u00a0 \\n\\u00a0         copy_data.cell_index = cell->active_cell_index();\\n\\u00a0 \\n\\u00a0         const std::vector<Point<dim>> &q_points = fe_v.get_quadrature_points();\\n\\u00a0         const unsigned int             n_q_points = q_points.size();\\n\\u00a0         const std::vector<double>     &JxW        = fe_v.get_JxW_values();\\n\\u00a0 \\n\\u00a0         std::vector<Tensor<1, dim>> grad_u(n_q_points);\\n\\u00a0         fe_v.get_function_gradients(solution, grad_u);\\n\\u00a0 \\n\\u00a0         std::vector<Tensor<1, dim>> grad_exact(n_q_points);\\n\\u00a0         exact_solution->gradient_list(q_points, grad_exact);\\n\\u00a0 \\n\\u00a0         double norm_square = 0;\\n\\u00a0         for (unsigned int point = 0; point < n_q_points; ++point)\\n\\u00a0           {\\n\\u00a0             norm_square +=\\n\\u00a0               (grad_u[point] - grad_exact[point]).norm_square() * JxW[point];\\n\\u00a0           }\\n\\u00a0         copy_data.value = diffusion_coefficient * norm_square;\\n\\u00a0       };\\n\\u00a0 \\nAssemble \\\\(\\\\sum_{f \\\\in F_b}\\\\sigma  \\\\|u_h-g_D\\\\|_f^2\\\\).\\n\\u00a0     const auto boundary_worker =\\n\\u00a0       [&](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0           const unsigned int                                   &face_no,\\n\\u00a0           ScratchData                                          &scratch_data,\\n\\u00a0           CopyData                                             &copy_data) {\\n\\u00a0         const FEFaceValuesBase<dim> &fe_fv = scratch_data.reinit(cell, face_no);\\n\\u00a0 \\n\\u00a0         const std::vector<Point<dim>> &q_points = fe_fv.get_quadrature_points();\\n\\u00a0         const unsigned                 n_q_points = q_points.size();\\n\\u00a0 \\n\\u00a0         const std::vector<double> &JxW = fe_fv.get_JxW_values();\\n\\u00a0 \\n\\u00a0         std::vector<double> g(n_q_points);\\n\\u00a0         exact_solution->value_list(q_points, g);\\n\\u00a0 \\n\\u00a0         std::vector<double> sol_u(n_q_points);\\n\\u00a0         fe_fv.get_function_values(solution, sol_u);\\n\\u00a0 \\n\\u00a0         const double extent1 = cell->measure() / cell->face(face_no)->measure();\\n\\u00a0         const double penalty = get_penalty_factor(degree, extent1, extent1);\\n\\u00a0 \\n\\u00a0         double difference_norm_square = 0.;\\n\\u00a0         for (unsigned int point = 0; point < q_points.size(); ++point)\\n\\u00a0           {\\n\\u00a0             const double diff = (g[point] - sol_u[point]);\\n\\u00a0             difference_norm_square += diff * diff * JxW[point];\\n\\u00a0           }\\n\\u00a0         copy_data.value += penalty * difference_norm_square;\\n\\u00a0       };\\n\\u00a0 \\nAssemble \\\\(\\\\sum_{f \\\\in F_i} \\\\sigma  \\\\| [ u_h ] \\\\|_f^2\\\\).\\n\\u00a0     const auto face_worker =\\n\\u00a0       [&](const typename DoFHandler<dim>::cell_iterator &cell,\\n\\u00a0           const unsigned int                            &f,\\n\\u00a0           const unsigned int                            &sf,\\n\\u00a0           const typename DoFHandler<dim>::cell_iterator &ncell,\\n\\u00a0           const unsigned int                            &nf,\\n\\u00a0           const unsigned int                            &nsf,\\n\\u00a0           ScratchData                                   &scratch_data,\\n\\u00a0           CopyData                                      &copy_data) {\\n\\u00a0         const FEInterfaceValues<dim> &fe_iv =\\n\\u00a0           scratch_data.reinit(cell, f, sf, ncell, nf, nsf);\\n\\u00a0 \\n\\u00a0         copy_data.face_data.emplace_back();\\n\\u00a0         CopyDataFace &copy_data_face = copy_data.face_data.back();\\n\\u00a0 \\n\\u00a0         copy_data_face.cell_indices[0] = cell->active_cell_index();\\n\\u00a0         copy_data_face.cell_indices[1] = ncell->active_cell_index();\\n\\u00a0 \\n\\u00a0         const std::vector<double> &JxW = fe_iv.get_JxW_values();\\n\\u00a0 \\n\\u00a0         const std::vector<Point<dim>> &q_points = fe_iv.get_quadrature_points();\\n\\u00a0         const unsigned int             n_q_points = q_points.size();\\n\\u00a0 \\n\\u00a0         std::vector<double> jump(n_q_points);\\n\\u00a0         fe_iv.get_jump_in_function_values(solution, jump);\\n\\u00a0 \\n\\u00a0         const double extent1 = cell->measure() / cell->face(f)->measure();\\n\\u00a0         const double extent2 = ncell->measure() / ncell->face(nf)->measure();\\n\\u00a0         const double penalty = get_penalty_factor(degree, extent1, extent2);\\n\\u00a0 \\n\\u00a0         double u_jump_square = 0;\\n\\u00a0         for (unsigned int point = 0; point < n_q_points; ++point)\\n\\u00a0           {\\n\\u00a0             u_jump_square += jump[point] * jump[point] * JxW[point];\\n\\u00a0           }\\n\\u00a0         copy_data_face.values[0] = 0.5 * penalty * u_jump_square;\\n\\u00a0         copy_data_face.values[1] = copy_data_face.values[0];\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0     const auto copier = [&](const CopyData &copy_data) {\\n\\u00a0       if (copy_data.cell_index != numbers::invalid_unsigned_int)\\n\\u00a0         energy_norm_square_per_cell[copy_data.cell_index] += copy_data.value;\\n\\u00a0       for (const CopyDataFace &cdf : copy_data.face_data)\\n\\u00a0         for (unsigned int j = 0; j < 2; ++j)\\n\\u00a0           energy_norm_square_per_cell[cdf.cell_indices[j]] += cdf.values[j];\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     const UpdateFlags cell_flags =\\n\\u00a0       update_gradients | update_quadrature_points | update_JxW_values;\\n\\u00a0     UpdateFlags face_flags =\\n\\u00a0       update_values | update_quadrature_points | update_JxW_values;\\n\\u00a0 \\n\\u00a0     const ScratchData scratch_data(mapping,\\n\\u00a0                                    fe,\\n\\u00a0                                    quadrature_overintegration,\\n\\u00a0                                    cell_flags,\\n\\u00a0                                    face_quadrature_overintegration,\\n\\u00a0                                    face_flags);\\n\\u00a0 \\n\\u00a0     CopyData copy_data;\\n\\u00a0     MeshWorker::mesh_loop(dof_handler.begin_active(),\\n\\u00a0                           dof_handler.end(),\\n\\u00a0                           cell_worker,\\n\\u00a0                           copier,\\n\\u00a0                           scratch_data,\\n\\u00a0                           copy_data,\\n\\u00a0                           MeshWorker::assemble_own_cells |\\n\\u00a0                             MeshWorker::assemble_own_interior_faces_once |\\n\\u00a0                             MeshWorker::assemble_boundary_faces,\\n\\u00a0                           boundary_worker,\\n\\u00a0                           face_worker);\\n\\u00a0     const double energy_error =\\n\\u00a0       std::sqrt(energy_norm_square_per_cell.l1_norm());\\n\\u00a0     return energy_error;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nstd::sqrt::VectorizedArray< Number, width > sqrt(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6869\\n The refine_grid() function\\n\\u00a0   template <int dim>\\n\\u00a0   void SIPGLaplace<dim>::refine_grid()\\n\\u00a0   {\\n\\u00a0     const double refinement_fraction = 0.1;\\n\\u00a0 \\n\\u00a0     GridRefinement::refine_and_coarsen_fixed_number(\\n\\u00a0       triangulation, estimated_error_square_per_cell, refinement_fraction, 0.);\\n\\u00a0 \\n\\u00a0     triangulation.execute_coarsening_and_refinement();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nparallel::distributed::Triangulation::execute_coarsening_and_refinementvirtual void execute_coarsening_and_refinement() overrideDefinition tria.cc:3320\\nGridRefinement::refine_and_coarsen_fixed_numbervoid refine_and_coarsen_fixed_number(Triangulation< dim, spacedim > &triangulation, const Vector< Number > &criteria, const double top_fraction_of_cells, const double bottom_fraction_of_cells, const unsigned int max_n_cells=std::numeric_limits< unsigned int >::max())Definition grid_refinement.cc:318\\n The compute_errors() function\\nWe compute three errors in the \\\\(L_2\\\\) norm, \\\\(H_1\\\\) seminorm, and the energy norm, respectively. These are then printed to screen, but also stored in a table that records how these errors decay with mesh refinement and which can be output in one step at the end of the program.\\n\\u00a0   template <int dim>\\n\\u00a0   void SIPGLaplace<dim>::compute_errors()\\n\\u00a0   {\\n\\u00a0     double L2_error, H1_error, energy_error;\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       Vector<float> difference_per_cell(triangulation.n_active_cells());\\n\\u00a0       VectorTools::integrate_difference(mapping,\\n\\u00a0                                         dof_handler,\\n\\u00a0                                         solution,\\n\\u00a0                                         *(exact_solution.get()),\\n\\u00a0                                         difference_per_cell,\\n\\u00a0                                         quadrature_overintegration,\\n\\u00a0                                         VectorTools::L2_norm);\\n\\u00a0 \\n\\u00a0       L2_error = VectorTools::compute_global_error(triangulation,\\n\\u00a0                                                    difference_per_cell,\\n\\u00a0                                                    VectorTools::L2_norm);\\n\\u00a0       convergence_table.add_value(\\\"L2\\\", L2_error);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       Vector<float> difference_per_cell(triangulation.n_active_cells());\\n\\u00a0       VectorTools::integrate_difference(mapping,\\n\\u00a0                                         dof_handler,\\n\\u00a0                                         solution,\\n\\u00a0                                         *(exact_solution.get()),\\n\\u00a0                                         difference_per_cell,\\n\\u00a0                                         quadrature_overintegration,\\n\\u00a0                                         VectorTools::H1_seminorm);\\n\\u00a0 \\n\\u00a0       H1_error = VectorTools::compute_global_error(triangulation,\\n\\u00a0                                                    difference_per_cell,\\n\\u00a0                                                    VectorTools::H1_seminorm);\\n\\u00a0       convergence_table.add_value(\\\"H1\\\", H1_error);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       energy_error = compute_energy_norm_error();\\n\\u00a0       convergence_table.add_value(\\\"Energy\\\", energy_error);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     std::cout << \\\"  Error in the L2 norm         : \\\" << L2_error << std::endl\\n\\u00a0               << \\\"  Error in the H1 seminorm     : \\\" << H1_error << std::endl\\n\\u00a0               << \\\"  Error in the energy norm     : \\\" << energy_error\\n\\u00a0               << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nVectorTools::compute_global_errordouble compute_global_error(const Triangulation< dim, spacedim > &tria, const InVector &cellwise_error, const NormType &norm, const double exponent=2.)\\nVectorTools::H1_seminorm@ H1_seminormDefinition vector_tools_common.h:164\\nVectorTools::L2_norm@ L2_normDefinition vector_tools_common.h:112\\nVectorTools::integrate_differencevoid integrate_difference(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const ReadVector< Number > &fe_function, const Function< spacedim, Number > &exact_solution, OutVector &difference, const Quadrature< dim > &q, const NormType &norm, const Function< spacedim, double > *weight=nullptr, const double exponent=2.)\\n The run() function\\n\\u00a0   template <int dim>\\n\\u00a0   void SIPGLaplace<dim>::run()\\n\\u00a0   {\\n\\u00a0     const unsigned int max_cycle =\\n\\u00a0       (test_case == TestCase::convergence_rate ? 6 : 20);\\n\\u00a0     for (unsigned int cycle = 0; cycle < max_cycle; ++cycle)\\n\\u00a0       {\\n\\u00a0         std::cout << \\\"Cycle \\\" << cycle << std::endl;\\n\\u00a0 \\n\\u00a0         switch (test_case)\\n\\u00a0           {\\n\\u00a0             case TestCase::convergence_rate:\\n\\u00a0               {\\n\\u00a0                 if (cycle == 0)\\n\\u00a0                   {\\n\\u00a0                     GridGenerator::hyper_cube(triangulation);\\n\\u00a0 \\n\\u00a0                     triangulation.refine_global(2);\\n\\u00a0                   }\\n\\u00a0                 else\\n\\u00a0                   {\\n\\u00a0                     triangulation.refine_global(1);\\n\\u00a0                   }\\n\\u00a0                 break;\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0             case TestCase::l_singularity:\\n\\u00a0               {\\n\\u00a0                 if (cycle == 0)\\n\\u00a0                   {\\n\\u00a0                     GridGenerator::hyper_L(triangulation);\\n\\u00a0                     triangulation.refine_global(3);\\n\\u00a0                   }\\n\\u00a0                 else\\n\\u00a0                   {\\n\\u00a0                     refine_grid();\\n\\u00a0                   }\\n\\u00a0                 break;\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0             default:\\n\\u00a0               {\\n\\u00a0                 DEAL_II_NOT_IMPLEMENTED();\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         std::cout << \\\"  Number of active cells       : \\\"\\n\\u00a0                   << triangulation.n_active_cells() << std::endl;\\n\\u00a0         setup_system();\\n\\u00a0 \\n\\u00a0         std::cout << \\\"  Number of degrees of freedom : \\\" << dof_handler.n_dofs()\\n\\u00a0                   << std::endl;\\n\\u00a0 \\n\\u00a0         assemble_system();\\n\\u00a0         solve();\\n\\u00a0         output_results(cycle);\\n\\u00a0         {\\n\\u00a0           convergence_table.add_value(\\\"cycle\\\", cycle);\\n\\u00a0           convergence_table.add_value(\\\"cells\\\", triangulation.n_active_cells());\\n\\u00a0           convergence_table.add_value(\\\"dofs\\\", dof_handler.n_dofs());\\n\\u00a0         }\\n\\u00a0         compute_errors();\\n\\u00a0 \\n\\u00a0         if (test_case == TestCase::l_singularity)\\n\\u00a0           {\\n\\u00a0             compute_error_estimate();\\n\\u00a0             std::cout << \\\"  Estimated error              : \\\"\\n\\u00a0                       << std::sqrt(estimated_error_square_per_cell.l1_norm())\\n\\u00a0                       << std::endl;\\n\\u00a0 \\n\\u00a0             convergence_table.add_value(\\n\\u00a0               \\\"Estimator\\\",\\n\\u00a0               std::sqrt(estimated_error_square_per_cell.l1_norm()));\\n\\u00a0           }\\n\\u00a0         std::cout << std::endl;\\n\\u00a0       }\\n\\u00a0 \\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nDEAL_II_NOT_IMPLEMENTED#define DEAL_II_NOT_IMPLEMENTED()Definition exceptions.h:1814\\nGridGenerator::hyper_Lvoid hyper_L(Triangulation< dim > &tria, const double left=-1., const double right=1., const bool colorize=false)\\nGridGenerator::hyper_cubevoid hyper_cube(Triangulation< dim, spacedim > &tria, const double left=0., const double right=1., const bool colorize=false)\\nl1_normNumber l1_norm(const Tensor< 2, dim, Number > &t)Definition tensor.h:3039\\nHaving run all of our computations, let us tell the convergence table how to format its data and output it to screen:\\n\\u00a0     convergence_table.set_precision(\\\"L2\\\", 3);\\n\\u00a0     convergence_table.set_precision(\\\"H1\\\", 3);\\n\\u00a0     convergence_table.set_precision(\\\"Energy\\\", 3);\\n\\u00a0 \\n\\u00a0     convergence_table.set_scientific(\\\"L2\\\", true);\\n\\u00a0     convergence_table.set_scientific(\\\"H1\\\", true);\\n\\u00a0     convergence_table.set_scientific(\\\"Energy\\\", true);\\n\\u00a0 \\n\\u00a0     if (test_case == TestCase::convergence_rate)\\n\\u00a0       {\\n\\u00a0         convergence_table.evaluate_convergence_rates(\\n\\u00a0           \\\"L2\\\", ConvergenceTable::reduction_rate_log2);\\n\\u00a0         convergence_table.evaluate_convergence_rates(\\n\\u00a0           \\\"H1\\\", ConvergenceTable::reduction_rate_log2);\\n\\u00a0       }\\n\\u00a0     if (test_case == TestCase::l_singularity)\\n\\u00a0       {\\n\\u00a0         convergence_table.set_precision(\\\"Estimator\\\", 3);\\n\\u00a0         convergence_table.set_scientific(\\\"Estimator\\\", true);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     std::cout << \\\"degree = \\\" << degree << std::endl;\\n\\u00a0     convergence_table.write_text(\\n\\u00a0       std::cout, TableHandler::TextOutputFormat::org_mode_table);\\n\\u00a0   }\\n\\u00a0 } // namespace Step74\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nConvergenceTable::reduction_rate_log2@ reduction_rate_log2Definition convergence_table.h:88\\nTableHandler::org_mode_table@ org_mode_tableDefinition table_handler.h:371\\n The main() function\\nThe following main function is similar to previous examples as well, and need not be commented on.\\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       using namespace dealii;\\n\\u00a0       using namespace Step74;\\n\\u00a0 \\n\\u00a0       const TestCase test_case = TestCase::l_singularity;\\n\\u00a0 \\n\\u00a0       SIPGLaplace<2> problem(test_case);\\n\\u00a0       problem.run();\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nThe output of this program consist of the console output and solutions in vtu format.\\nIn the first test case, when you run the program, the screen output should look like the following: Cycle 0\\n  Number of active cells       : 16\\n  Number of degrees of freedom : 256\\n  Error in the L2 norm         : 0.00193285\\n  Error in the H1 seminorm     : 0.106087\\n  Error in the energy norm     : 0.150625\\n \\nCycle 1\\n  Number of active cells       : 64\\n  Number of degrees of freedom : 1024\\n  Error in the L2 norm         : 9.60497e-05\\n  Error in the H1 seminorm     : 0.0089954\\n  Error in the energy norm     : 0.0113265\\n \\nCycle 2\\n.\\n.\\n.\\nWhen using the smooth case with polynomial degree 3, the convergence table will look like this: \\n\\ncycle n_cells n_dofs L2  rate H1 rate Energy  \\n\\n0 16 256 1.933e-03 \\u00a0 1.061e-01 \\u00a0 1.506e-01  \\n\\n1 64 1024 9.605e-05 4.33 8.995e-03 3.56 1.133e-02  \\n\\n2 256 4096 5.606e-06 4.10 9.018e-04 3.32 9.736e-04  \\n\\n3 1024 16384 3.484e-07 4.01 1.071e-04 3.07 1.088e-04  \\n\\n4 4096 65536 2.179e-08 4.00 1.327e-05 3.01 1.331e-05  \\n\\n5 16384 262144 1.363e-09 4.00 1.656e-06 3.00 1.657e-06  \\n\\nTheoretically, for polynomial degree \\\\(p\\\\), the order of convergence in \\\\(L_2\\\\) norm and \\\\(H^1\\\\) seminorm should be \\\\(p+1\\\\) and \\\\(p\\\\), respectively. Our numerical results are in good agreement with theory.\\nIn the second test case, when you run the program, the screen output should look like the following: Cycle 0\\n  Number of active cells       : 192\\n  Number of degrees of freedom : 3072\\n  Error in the L2 norm         : 0.000323585\\n  Error in the H1 seminorm     : 0.0296202\\n  Error in the energy norm     : 0.0420478\\n  Estimated error              : 0.136067\\n \\nCycle 1\\n  Number of active cells       : 249\\n  Number of degrees of freedom : 3984\\n  Error in the L2 norm         : 0.000114739\\n  Error in the H1 seminorm     : 0.0186571\\n  Error in the energy norm     : 0.0264879\\n  Estimated error              : 0.0857186\\n \\nCycle 2\\n.\\n.\\n.\\nThe following figure provides a log-log plot of the errors versus the number of degrees of freedom for this test case on the L-shaped domain. In order to interpret it, let \\\\(n\\\\) be the number of degrees of freedom, then on uniformly refined meshes, \\\\(h\\\\) is of order \\\\(1/\\\\sqrt{n}\\\\) in 2D. Combining the theoretical results in the previous case, we see that if the solution is sufficiently smooth, we can expect the error in the \\\\(L_2\\\\) norm to be of order \\\\(O(n^{-\\\\frac{p+1}{2}})\\\\) and in \\\\(H^1\\\\) seminorm to be \\\\(O(n^{-\\\\frac{p}{2}})\\\\). It is not a priori clear that one would get the same kind of behavior as a function of \\\\(n\\\\) on adaptively refined meshes like the ones we use for this second test case, but one can certainly hope. Indeed, from the figure, we see that the SIPG with adaptive mesh refinement produces asymptotically the kinds of hoped-for results:\\n\\nIn addition, we observe that the error estimator decreases at almost the same rate as the errors in the energy norm and \\\\(H^1\\\\) seminorm, and one order lower than the \\\\(L_2\\\\) error. This suggests its ability to predict regions with large errors.\\nWhile this tutorial is focused on the implementation, the step-59 tutorial program achieves an efficient large-scale solver in terms of computing time with matrix-free solution techniques. Note that the step-59 tutorial does not work with meshes containing hanging nodes at this moment, because the multigrid interface matrices are not as easily determined, but that is merely the lack of some interfaces in deal.II, nothing fundamental.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2020 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Authors: Timo Heister and Jiaqi Zhang, Clemson University, 2020\\n */\\n \\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/function.h>\\n#include <deal.II/base/function_lib.h>\\n#include <deal.II/lac/vector.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/lac/sparse_direct.h>\\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_out.h>\\n#include <deal.II/grid/grid_refinement.h>\\n#include <deal.II/fe/fe_values.h>\\n#include <deal.II/fe/mapping_q1.h>\\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_tools.h>\\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/fe/fe_dgq.h>\\n#include <deal.II/fe/fe_interface_values.h>\\n \\n#include <deal.II/numerics/derivative_approximation.h>\\n#include <deal.II/numerics/vector_tools.h>\\n#include <deal.II/base/convergence_table.h>\\n \\n#include <deal.II/meshworker/copy_data.h>\\n#include <deal.II/meshworker/mesh_loop.h>\\n#include <deal.II/meshworker/scratch_data.h>\\n \\nnamespace Step74\\n{\\n using namespace dealii;\\n \\n enum class TestCase\\n  {\\n    convergence_rate,\\n    l_singularity\\n  };\\n \\n \\n \\n template <int dim>\\n class SmoothSolution : public Function<dim>\\n  {\\n public:\\n    SmoothSolution()\\n      : Function<dim>()\\n    {}\\n \\n virtual void value_list(const std::vector<Point<dim>> &points,\\n                            std::vector<double>           &values,\\n const unsigned int component = 0) const override;\\n \\n virtual Tensor<1, dim>\\n gradient(const Point<dim>  &point,\\n const unsigned int component = 0) const override;\\n  };\\n \\n \\n \\n template <int dim>\\n void SmoothSolution<dim>::value_list(const std::vector<Point<dim>> &points,\\n                                       std::vector<double>           &values,\\n const unsigned int /*component*/) const\\n {\\n using numbers::PI;\\n for (unsigned int i = 0; i < values.size(); ++i)\\n      values[i] =\\n std::sin(2. * PI * points[i][0]) * std::sin(2. * PI * points[i][1]);\\n  }\\n \\n \\n \\n template <int dim>\\n Tensor<1, dim>\\n  SmoothSolution<dim>::gradient(const Point<dim> &point,\\n const unsigned int /*component*/) const\\n {\\n Tensor<1, dim> return_value;\\n using numbers::PI;\\n    return_value[0] =\\n      2. * PI * std::cos(2. * PI * point[0]) * std::sin(2. * PI * point[1]);\\n    return_value[1] =\\n      2. * PI * std::sin(2. * PI * point[0]) * std::cos(2. * PI * point[1]);\\n return return_value;\\n  }\\n \\n \\n \\n template <int dim>\\n class SmoothRightHandSide : public Function<dim>\\n  {\\n public:\\n    SmoothRightHandSide()\\n      : Function<dim>()\\n    {}\\n \\n virtual void value_list(const std::vector<Point<dim>> &points,\\n                            std::vector<double>           &values,\\n const unsigned int /*component*/) const override;\\n  };\\n \\n \\n \\n template <int dim>\\n void\\n  SmoothRightHandSide<dim>::value_list(const std::vector<Point<dim>> &points,\\n                                       std::vector<double>           &values,\\n const unsigned int /*component*/) const\\n {\\n using numbers::PI;\\n for (unsigned int i = 0; i < values.size(); ++i)\\n      values[i] = 8. * PI * PI * std::sin(2. * PI * points[i][0]) *\\n std::sin(2. * PI * points[i][1]);\\n  }\\n \\n \\n \\n template <int dim>\\n class SingularRightHandSide : public Function<dim>\\n  {\\n public:\\n    SingularRightHandSide()\\n      : Function<dim>()\\n    {}\\n \\n virtual void value_list(const std::vector<Point<dim>> &points,\\n                            std::vector<double>           &values,\\n const unsigned int /*component*/) const override;\\n \\n private:\\n const Functions::LSingularityFunction ref;\\n  };\\n \\n \\n \\n template <int dim>\\n void\\n  SingularRightHandSide<dim>::value_list(const std::vector<Point<dim>> &points,\\n                                         std::vector<double>           &values,\\n const unsigned int /*component*/) const\\n {\\n for (unsigned int i = 0; i < values.size(); ++i)\\n      values[i] = -ref.laplacian(points[i]);\\n  }\\n \\n \\n \\n double get_penalty_factor(const unsigned int fe_degree,\\n const double       cell_extent_left,\\n const double       cell_extent_right)\\n  {\\n const unsigned int degree = std::max(1U, fe_degree);\\n return degree * (degree + 1.) * 0.5 *\\n           (1. / cell_extent_left + 1. / cell_extent_right);\\n  }\\n \\n \\n struct CopyDataFace\\n  {\\n FullMatrix<double> cell_matrix;\\n    std::vector<types::global_dof_index> joint_dof_indices;\\n    std::array<double, 2>                values;\\n    std::array<unsigned int, 2>          cell_indices;\\n  };\\n \\n \\n \\n struct CopyData\\n  {\\n FullMatrix<double> cell_matrix;\\n Vector<double>                       cell_rhs;\\n    std::vector<types::global_dof_index> local_dof_indices;\\n    std::vector<CopyDataFace>            face_data;\\n double value;\\n unsigned int cell_index;\\n \\n \\n template <class Iterator>\\n void reinit(const Iterator &cell, const unsigned int dofs_per_cell)\\n    {\\n cell_matrix.reinit(dofs_per_cell, dofs_per_cell);\\n      cell_rhs.reinit(dofs_per_cell);\\n      local_dof_indices.resize(dofs_per_cell);\\n      cell->get_dof_indices(local_dof_indices);\\n    }\\n  };\\n \\n \\n \\n template <int dim>\\n class SIPGLaplace\\n  {\\n public:\\n    SIPGLaplace(const TestCase &test_case);\\n void run();\\n \\n private:\\n void setup_system();\\n void assemble_system();\\n void solve();\\n void refine_grid();\\n void output_results(const unsigned int cycle) const;\\n \\n void   compute_errors();\\n void   compute_error_estimate();\\n double compute_energy_norm_error();\\n \\n Triangulation<dim> triangulation;\\n const unsigned int    degree;\\n const QGauss<dim>     quadrature;\\n const QGauss<dim - 1> face_quadrature;\\n const QGauss<dim>     quadrature_overintegration;\\n const QGauss<dim - 1> face_quadrature_overintegration;\\n const MappingQ1<dim>  mapping;\\n \\n using ScratchData = MeshWorker::ScratchData<dim>;\\n \\n const FE_DGQ<dim> fe;\\n DoFHandler<dim>   dof_handler;\\n \\n SparsityPattern      sparsity_pattern;\\n SparseMatrix<double> system_matrix;\\n Vector<double>       solution;\\n Vector<double>       system_rhs;\\n \\n Vector<double> estimated_error_square_per_cell;\\n Vector<double> energy_norm_square_per_cell;\\n \\n ConvergenceTable convergence_table;\\n \\n const double diffusion_coefficient = 1.;\\n \\n const TestCase                       test_case;\\n    std::unique_ptr<const Function<dim>> exact_solution;\\n    std::unique_ptr<const Function<dim>> rhs_function;\\n  };\\n \\n template <int dim>\\n  SIPGLaplace<dim>::SIPGLaplace(const TestCase &test_case)\\n    : degree(3)\\n    , quadrature(degree + 1)\\n    , face_quadrature(degree + 1)\\n    , quadrature_overintegration(degree + 2)\\n    , face_quadrature_overintegration(degree + 2)\\n    , mapping()\\n    , fe(degree)\\n    , dof_handler(triangulation)\\n    , test_case(test_case)\\n  {\\n if (test_case == TestCase::convergence_rate)\\n      {\\n        exact_solution = std::make_unique<const SmoothSolution<dim>>();\\n        rhs_function   = std::make_unique<const SmoothRightHandSide<dim>>();\\n      }\\n \\n else if (test_case == TestCase::l_singularity)\\n      {\\n        exact_solution =\\n          std::make_unique<const Functions::LSingularityFunction>();\\n        rhs_function = std::make_unique<const SingularRightHandSide<dim>>();\\n      }\\n else\\n AssertThrow(false, ExcNotImplemented());\\n  }\\n \\n \\n \\n template <int dim>\\n void SIPGLaplace<dim>::setup_system()\\n  {\\n    dof_handler.distribute_dofs(fe);\\n DynamicSparsityPattern dsp(dof_handler.n_dofs());\\n DoFTools::make_flux_sparsity_pattern(dof_handler, dsp);\\n    sparsity_pattern.copy_from(dsp);\\n \\n    system_matrix.reinit(sparsity_pattern);\\n    solution.reinit(dof_handler.n_dofs());\\n    system_rhs.reinit(dof_handler.n_dofs());\\n  }\\n \\n \\n \\n template <int dim>\\n void SIPGLaplace<dim>::assemble_system()\\n  {\\n const auto cell_worker =\\n      [&](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n          ScratchData                                          &scratch_data,\\n          CopyData                                             &copy_data) {\\n const FEValues<dim> &fe_v          = scratch_data.reinit(cell);\\n const unsigned int   dofs_per_cell = fe_v.dofs_per_cell;\\n        copy_data.reinit(cell, dofs_per_cell);\\n \\n const std::vector<Point<dim>> &q_points =\\n          scratch_data.get_quadrature_points();\\n const unsigned int         n_q_points = q_points.size();\\n const std::vector<double> &JxW        = scratch_data.get_JxW_values();\\n \\n        std::vector<double> rhs(n_q_points);\\n        rhs_function->value_list(q_points, rhs);\\n \\n for (unsigned int point = 0; point < n_q_points; ++point)\\n for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)\\n            {\\n for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j)\\n                copy_data.cell_matrix(i, j) +=\\n                  diffusion_coefficient *     // nu\\n                  fe_v.shape_grad(i, point) * // grad v_h\\n                  fe_v.shape_grad(j, point) * // grad u_h\\n                  JxW[point];                 // dx\\n \\n              copy_data.cell_rhs(i) += fe_v.shape_value(i, point) * // v_h\\n                                       rhs[point] *                 // f\\n                                       JxW[point];                  // dx\\n            }\\n      };\\n \\n const auto boundary_worker =\\n      [&](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n const unsigned int                                   &face_no,\\n          ScratchData                                          &scratch_data,\\n          CopyData                                             &copy_data) {\\n const FEFaceValuesBase<dim> &fe_fv = scratch_data.reinit(cell, face_no);\\n \\n const std::vector<Point<dim>> &q_points =\\n          scratch_data.get_quadrature_points();\\n const unsigned int n_q_points    = q_points.size();\\n const unsigned int dofs_per_cell = fe_fv.dofs_per_cell;\\n \\n const std::vector<double>         &JxW = scratch_data.get_JxW_values();\\n const std::vector<Tensor<1, dim>> &normals =\\n          scratch_data.get_normal_vectors();\\n \\n        std::vector<double> g(n_q_points);\\n        exact_solution->value_list(q_points, g);\\n \\n const double extent1 = cell->measure() / cell->face(face_no)->measure();\\n const double penalty = get_penalty_factor(degree, extent1, extent1);\\n \\n for (unsigned int point = 0; point < n_q_points; ++point)\\n          {\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n                copy_data.cell_matrix(i, j) +=\\n                  (-diffusion_coefficient *        // - nu\\n                     fe_fv.shape_value(i, point) * // v_h\\n                     (fe_fv.shape_grad(j, point) * // (grad u_h .\\n                      normals[point])              //  n)\\n \\n                   - diffusion_coefficient *         // - nu\\n                       (fe_fv.shape_grad(i, point) * // (grad v_h .\\n                        normals[point]) *            //  n)\\n                       fe_fv.shape_value(j, point)   // u_h\\n \\n                   + diffusion_coefficient * penalty * // + nu sigma\\n                       fe_fv.shape_value(i, point) *   // v_h\\n                       fe_fv.shape_value(j, point)     // u_h\\n \\n                   ) *\\n                  JxW[point]; // dx\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n              copy_data.cell_rhs(i) +=\\n                (-diffusion_coefficient *        // - nu\\n                   (fe_fv.shape_grad(i, point) * // (grad v_h .\\n                    normals[point]) *            //  n)\\n                   g[point]                      // g\\n \\n \\n                 + diffusion_coefficient * penalty *        // + nu sigma\\n                     fe_fv.shape_value(i, point) * g[point] // v_h g\\n \\n                 ) *\\n                JxW[point]; // dx\\n          }\\n      };\\n \\n const auto face_worker =\\n      [&](const typename DoFHandler<dim>::cell_iterator &cell,\\n const unsigned int                            &f,\\n const unsigned int                            &sf,\\n const typename DoFHandler<dim>::cell_iterator &ncell,\\n const unsigned int                            &nf,\\n const unsigned int                            &nsf,\\n          ScratchData                                   &scratch_data,\\n          CopyData                                      &copy_data) {\\n const FEInterfaceValues<dim> &fe_iv =\\n          scratch_data.reinit(cell, f, sf, ncell, nf, nsf);\\n \\n        copy_data.face_data.emplace_back();\\n        CopyDataFace      &copy_data_face = copy_data.face_data.back();\\n const unsigned int n_dofs_face    = fe_iv.n_current_interface_dofs();\\n        copy_data_face.joint_dof_indices  = fe_iv.get_interface_dof_indices();\\n        copy_data_face.cell_matrix.reinit(n_dofs_face, n_dofs_face);\\n \\n const std::vector<double>         &JxW     = fe_iv.get_JxW_values();\\n const std::vector<Tensor<1, dim>> &normals = fe_iv.get_normal_vectors();\\n \\n const double extent1 = cell->measure() / cell->face(f)->measure();\\n const double extent2 = ncell->measure() / ncell->face(nf)->measure();\\n const double penalty = get_penalty_factor(degree, extent1, extent2);\\n \\n for (const unsigned int point : fe_iv.quadrature_point_indices())\\n          {\\n for (const unsigned int i : fe_iv.dof_indices())\\n              for (const unsigned int j : fe_iv.dof_indices())\\n                copy_data_face.cell_matrix(i, j) +=\\n                  (-diffusion_coefficient *                     // - nu\\n                     fe_iv.jump_in_shape_values(i, point) *     // [v_h]\\n                     (fe_iv.average_of_shape_gradients(j,       \\n point) * // ({grad u_h} .\\n                      normals[point])                           //  n)\\n \\n                   - diffusion_coefficient * // - nu\\n                       (fe_iv.average_of_shape_gradients(i,\\n point) * // (grad v_h .\\n                        normals[point]) *                         //  n)\\n                       fe_iv.jump_in_shape_values(j, point)       // [u_h]\\n \\n                   + diffusion_coefficient * penalty *        // + nu sigma\\n                       fe_iv.jump_in_shape_values(i, point) * // [v_h]\\n                       fe_iv.jump_in_shape_values(j, point)   // [u_h]\\n \\n                   ) *\\n                  JxW[point]; // dx\\n          }\\n      };\\n \\n AffineConstraints<double> constraints;\\n    constraints.close();\\n const auto copier = [&](const CopyData &c) {\\n      constraints.distribute_local_to_global(c.cell_matrix,\\n                                             c.cell_rhs,\\n                                             c.local_dof_indices,\\n                                             system_matrix,\\n                                             system_rhs);\\n \\n for (const CopyDataFace &cdf : c.face_data)\\n        {\\n          constraints.distribute_local_to_global(cdf.cell_matrix,\\n                                                 cdf.joint_dof_indices,\\n                                                 system_matrix);\\n        }\\n    };\\n \\n \\n const UpdateFlags cell_flags = update_values | update_gradients |\\n update_quadrature_points | update_JxW_values;\\n const UpdateFlags face_flags = update_values | update_gradients |\\n update_quadrature_points |\\n update_normal_vectors | update_JxW_values;\\n \\n    ScratchData scratch_data(\\n      mapping, fe, quadrature, cell_flags, face_quadrature, face_flags);\\n    CopyData copy_data;\\n \\n MeshWorker::mesh_loop(dof_handler.begin_active(),\\n                          dof_handler.end(),\\n                          cell_worker,\\n                          copier,\\n                          scratch_data,\\n                          copy_data,\\n MeshWorker::assemble_own_cells |\\n MeshWorker::assemble_boundary_faces |\\n MeshWorker::assemble_own_interior_faces_once,\\n                          boundary_worker,\\n                          face_worker);\\n  }\\n \\n \\n \\n template <int dim>\\n void SIPGLaplace<dim>::solve()\\n  {\\n SparseDirectUMFPACK A_direct;\\n    A_direct.initialize(system_matrix);\\n    A_direct.vmult(solution, system_rhs);\\n  }\\n \\n \\n \\n template <int dim>\\n void SIPGLaplace<dim>::output_results(const unsigned int cycle) const\\n {\\n const std::string filename = \\\"sol_Q\\\" + Utilities::int_to_string(degree, 1) +\\n \\\"-\\\" + Utilities::int_to_string(cycle, 2) +\\n \\\".vtu\\\";\\n    std::ofstream output(filename);\\n \\n DataOut<dim> data_out;\\n    data_out.attach_dof_handler(dof_handler);\\n    data_out.add_data_vector(solution, \\\"u\\\", DataOut<dim>::type_dof_data);\\n    data_out.build_patches(mapping);\\n    data_out.write_vtu(output);\\n  }\\n \\n \\n template <int dim>\\n void SIPGLaplace<dim>::compute_error_estimate()\\n  {\\n const auto cell_worker =\\n      [&](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n          ScratchData                                          &scratch_data,\\n          CopyData                                             &copy_data) {\\n const FEValues<dim> &fe_v = scratch_data.reinit(cell);\\n \\n        copy_data.cell_index = cell->active_cell_index();\\n \\n const std::vector<Point<dim>> &q_points = fe_v.get_quadrature_points();\\n const unsigned int             n_q_points = q_points.size();\\n const std::vector<double>     &JxW        = fe_v.get_JxW_values();\\n \\n        std::vector<Tensor<2, dim>> hessians(n_q_points);\\n        fe_v.get_function_hessians(solution, hessians);\\n \\n        std::vector<double> rhs(n_q_points);\\n        rhs_function->value_list(q_points, rhs);\\n \\n const double hk                   = cell->diameter();\\n double       residual_norm_square = 0;\\n \\n for (unsigned int point = 0; point < n_q_points; ++point)\\n          {\\n const double residual =\\n              rhs[point] + diffusion_coefficient * trace(hessians[point]);\\n            residual_norm_square += residual * residual * JxW[point];\\n          }\\n        copy_data.value = hk * hk * residual_norm_square;\\n      };\\n \\n const auto boundary_worker =\\n      [&](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n const unsigned int                                   &face_no,\\n          ScratchData                                          &scratch_data,\\n          CopyData                                             &copy_data) {\\n const FEFaceValuesBase<dim> &fe_fv = scratch_data.reinit(cell, face_no);\\n \\n const std::vector<Point<dim>> &q_points = fe_fv.get_quadrature_points();\\n const unsigned                 n_q_points = q_points.size();\\n \\n const std::vector<double> &JxW = fe_fv.get_JxW_values();\\n \\n        std::vector<double> g(n_q_points);\\n        exact_solution->value_list(q_points, g);\\n \\n        std::vector<double> sol_u(n_q_points);\\n        fe_fv.get_function_values(solution, sol_u);\\n \\n const double extent1 = cell->measure() / cell->face(face_no)->measure();\\n const double penalty = get_penalty_factor(degree, extent1, extent1);\\n \\n double difference_norm_square = 0.;\\n for (unsigned int point = 0; point < q_points.size(); ++point)\\n          {\\n const double diff = (g[point] - sol_u[point]);\\n            difference_norm_square += diff * diff * JxW[point];\\n          }\\n        copy_data.value += penalty * difference_norm_square;\\n      };\\n \\n const auto face_worker =\\n      [&](const typename DoFHandler<dim>::cell_iterator &cell,\\n const unsigned int                            &f,\\n const unsigned int                            &sf,\\n const typename DoFHandler<dim>::cell_iterator &ncell,\\n const unsigned int                            &nf,\\n const unsigned int                            &nsf,\\n          ScratchData                                   &scratch_data,\\n          CopyData                                      &copy_data) {\\n const FEInterfaceValues<dim> &fe_iv =\\n          scratch_data.reinit(cell, f, sf, ncell, nf, nsf);\\n \\n        copy_data.face_data.emplace_back();\\n        CopyDataFace &copy_data_face = copy_data.face_data.back();\\n \\n        copy_data_face.cell_indices[0] = cell->active_cell_index();\\n        copy_data_face.cell_indices[1] = ncell->active_cell_index();\\n \\n const std::vector<double>         &JxW     = fe_iv.get_JxW_values();\\n const std::vector<Tensor<1, dim>> &normals = fe_iv.get_normal_vectors();\\n \\n const std::vector<Point<dim>> &q_points = fe_iv.get_quadrature_points();\\n const unsigned int             n_q_points = q_points.size();\\n \\n        std::vector<double> jump(n_q_points);\\n        fe_iv.get_jump_in_function_values(solution, jump);\\n \\n        std::vector<Tensor<1, dim>> grad_jump(n_q_points);\\n        fe_iv.get_jump_in_function_gradients(solution, grad_jump);\\n \\n const double h = cell->face(f)->diameter();\\n \\n const double extent1 = cell->measure() / cell->face(f)->measure();\\n const double extent2 = ncell->measure() / ncell->face(nf)->measure();\\n const double penalty = get_penalty_factor(degree, extent1, extent2);\\n \\n double flux_jump_square = 0;\\n double u_jump_square    = 0;\\n for (unsigned int point = 0; point < n_q_points; ++point)\\n          {\\n            u_jump_square += jump[point] * jump[point] * JxW[point];\\n const double flux_jump = grad_jump[point] * normals[point];\\n            flux_jump_square +=\\n              diffusion_coefficient * flux_jump * flux_jump * JxW[point];\\n          }\\n        copy_data_face.values[0] =\\n          0.5 * h * (flux_jump_square + penalty * u_jump_square);\\n        copy_data_face.values[1] = copy_data_face.values[0];\\n      };\\n \\n const auto copier = [&](const CopyData &copy_data) {\\n if (copy_data.cell_index != numbers::invalid_unsigned_int)\\n        estimated_error_square_per_cell[copy_data.cell_index] +=\\n          copy_data.value;\\n for (const CopyDataFace &cdf : copy_data.face_data)\\n        for (unsigned int j = 0; j < 2; ++j)\\n          estimated_error_square_per_cell[cdf.cell_indices[j]] += cdf.values[j];\\n    };\\n \\n    estimated_error_square_per_cell.reinit(triangulation.n_active_cells());\\n \\n const UpdateFlags cell_flags =\\n update_hessians | update_quadrature_points | update_JxW_values;\\n const UpdateFlags face_flags = update_values | update_gradients |\\n update_quadrature_points |\\n update_JxW_values | update_normal_vectors;\\n \\n    ScratchData scratch_data(\\n      mapping, fe, quadrature, cell_flags, face_quadrature, face_flags);\\n \\n    CopyData copy_data;\\n MeshWorker::mesh_loop(dof_handler.begin_active(),\\n                          dof_handler.end(),\\n                          cell_worker,\\n                          copier,\\n                          scratch_data,\\n                          copy_data,\\n MeshWorker::assemble_own_cells |\\n MeshWorker::assemble_own_interior_faces_once |\\n MeshWorker::assemble_boundary_faces,\\n                          boundary_worker,\\n                          face_worker);\\n  }\\n \\n template <int dim>\\n double SIPGLaplace<dim>::compute_energy_norm_error()\\n  {\\n    energy_norm_square_per_cell.reinit(triangulation.n_active_cells());\\n \\n const auto cell_worker =\\n      [&](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n          ScratchData                                          &scratch_data,\\n          CopyData                                             &copy_data) {\\n const FEValues<dim> &fe_v = scratch_data.reinit(cell);\\n \\n        copy_data.cell_index = cell->active_cell_index();\\n \\n const std::vector<Point<dim>> &q_points = fe_v.get_quadrature_points();\\n const unsigned int             n_q_points = q_points.size();\\n const std::vector<double>     &JxW        = fe_v.get_JxW_values();\\n \\n        std::vector<Tensor<1, dim>> grad_u(n_q_points);\\n        fe_v.get_function_gradients(solution, grad_u);\\n \\n        std::vector<Tensor<1, dim>> grad_exact(n_q_points);\\n        exact_solution->gradient_list(q_points, grad_exact);\\n \\n double norm_square = 0;\\n for (unsigned int point = 0; point < n_q_points; ++point)\\n          {\\n            norm_square +=\\n              (grad_u[point] - grad_exact[point]).norm_square() * JxW[point];\\n          }\\n        copy_data.value = diffusion_coefficient * norm_square;\\n      };\\n \\n const auto boundary_worker =\\n      [&](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n const unsigned int                                   &face_no,\\n          ScratchData                                          &scratch_data,\\n          CopyData                                             &copy_data) {\\n const FEFaceValuesBase<dim> &fe_fv = scratch_data.reinit(cell, face_no);\\n \\n const std::vector<Point<dim>> &q_points = fe_fv.get_quadrature_points();\\n const unsigned                 n_q_points = q_points.size();\\n \\n const std::vector<double> &JxW = fe_fv.get_JxW_values();\\n \\n        std::vector<double> g(n_q_points);\\n        exact_solution->value_list(q_points, g);\\n \\n        std::vector<double> sol_u(n_q_points);\\n        fe_fv.get_function_values(solution, sol_u);\\n \\n const double extent1 = cell->measure() / cell->face(face_no)->measure();\\n const double penalty = get_penalty_factor(degree, extent1, extent1);\\n \\n double difference_norm_square = 0.;\\n for (unsigned int point = 0; point < q_points.size(); ++point)\\n          {\\n const double diff = (g[point] - sol_u[point]);\\n            difference_norm_square += diff * diff * JxW[point];\\n          }\\n        copy_data.value += penalty * difference_norm_square;\\n      };\\n \\n const auto face_worker =\\n      [&](const typename DoFHandler<dim>::cell_iterator &cell,\\n const unsigned int                            &f,\\n const unsigned int                            &sf,\\n const typename DoFHandler<dim>::cell_iterator &ncell,\\n const unsigned int                            &nf,\\n const unsigned int                            &nsf,\\n          ScratchData                                   &scratch_data,\\n          CopyData                                      &copy_data) {\\n const FEInterfaceValues<dim> &fe_iv =\\n          scratch_data.reinit(cell, f, sf, ncell, nf, nsf);\\n \\n        copy_data.face_data.emplace_back();\\n        CopyDataFace &copy_data_face = copy_data.face_data.back();\\n \\n        copy_data_face.cell_indices[0] = cell->active_cell_index();\\n        copy_data_face.cell_indices[1] = ncell->active_cell_index();\\n \\n const std::vector<double> &JxW = fe_iv.get_JxW_values();\\n \\n const std::vector<Point<dim>> &q_points = fe_iv.get_quadrature_points();\\n const unsigned int             n_q_points = q_points.size();\\n \\n        std::vector<double> jump(n_q_points);\\n        fe_iv.get_jump_in_function_values(solution, jump);\\n \\n const double extent1 = cell->measure() / cell->face(f)->measure();\\n const double extent2 = ncell->measure() / ncell->face(nf)->measure();\\n const double penalty = get_penalty_factor(degree, extent1, extent2);\\n \\n double u_jump_square = 0;\\n for (unsigned int point = 0; point < n_q_points; ++point)\\n          {\\n            u_jump_square += jump[point] * jump[point] * JxW[point];\\n          }\\n        copy_data_face.values[0] = 0.5 * penalty * u_jump_square;\\n        copy_data_face.values[1] = copy_data_face.values[0];\\n      };\\n \\n const auto copier = [&](const CopyData &copy_data) {\\n if (copy_data.cell_index != numbers::invalid_unsigned_int)\\n        energy_norm_square_per_cell[copy_data.cell_index] += copy_data.value;\\n for (const CopyDataFace &cdf : copy_data.face_data)\\n        for (unsigned int j = 0; j < 2; ++j)\\n          energy_norm_square_per_cell[cdf.cell_indices[j]] += cdf.values[j];\\n    };\\n \\n const UpdateFlags cell_flags =\\n update_gradients | update_quadrature_points | update_JxW_values;\\n UpdateFlags face_flags =\\n update_values | update_quadrature_points | update_JxW_values;\\n \\n const ScratchData scratch_data(mapping,\\n                                   fe,\\n                                   quadrature_overintegration,\\n                                   cell_flags,\\n                                   face_quadrature_overintegration,\\n                                   face_flags);\\n \\n    CopyData copy_data;\\n MeshWorker::mesh_loop(dof_handler.begin_active(),\\n                          dof_handler.end(),\\n                          cell_worker,\\n                          copier,\\n                          scratch_data,\\n                          copy_data,\\n MeshWorker::assemble_own_cells |\\n MeshWorker::assemble_own_interior_faces_once |\\n MeshWorker::assemble_boundary_faces,\\n                          boundary_worker,\\n                          face_worker);\\n const double energy_error =\\n std::sqrt(energy_norm_square_per_cell.l1_norm());\\n return energy_error;\\n  }\\n \\n \\n \\n template <int dim>\\n void SIPGLaplace<dim>::refine_grid()\\n  {\\n const double refinement_fraction = 0.1;\\n \\n GridRefinement::refine_and_coarsen_fixed_number(\\n triangulation, estimated_error_square_per_cell, refinement_fraction, 0.);\\n \\n triangulation.execute_coarsening_and_refinement();\\n  }\\n \\n \\n \\n template <int dim>\\n void SIPGLaplace<dim>::compute_errors()\\n  {\\n double L2_error, H1_error, energy_error;\\n \\n    {\\n Vector<float> difference_per_cell(triangulation.n_active_cells());\\n VectorTools::integrate_difference(mapping,\\n                                        dof_handler,\\n                                        solution,\\n                                        *(exact_solution.get()),\\n                                        difference_per_cell,\\n                                        quadrature_overintegration,\\n VectorTools::L2_norm);\\n \\n      L2_error = VectorTools::compute_global_error(triangulation,\\n                                                   difference_per_cell,\\n VectorTools::L2_norm);\\n      convergence_table.add_value(\\\"L2\\\", L2_error);\\n    }\\n \\n    {\\n Vector<float> difference_per_cell(triangulation.n_active_cells());\\n VectorTools::integrate_difference(mapping,\\n                                        dof_handler,\\n                                        solution,\\n                                        *(exact_solution.get()),\\n                                        difference_per_cell,\\n                                        quadrature_overintegration,\\n VectorTools::H1_seminorm);\\n \\n      H1_error = VectorTools::compute_global_error(triangulation,\\n                                                   difference_per_cell,\\n VectorTools::H1_seminorm);\\n      convergence_table.add_value(\\\"H1\\\", H1_error);\\n    }\\n \\n    {\\n      energy_error = compute_energy_norm_error();\\n      convergence_table.add_value(\\\"Energy\\\", energy_error);\\n    }\\n \\n    std::cout << \\\"  Error in the L2 norm         : \\\" << L2_error << std::endl\\n              << \\\"  Error in the H1 seminorm     : \\\" << H1_error << std::endl\\n              << \\\"  Error in the energy norm     : \\\" << energy_error\\n              << std::endl;\\n  }\\n \\n \\n \\n template <int dim>\\n void SIPGLaplace<dim>::run()\\n  {\\n const unsigned int max_cycle =\\n      (test_case == TestCase::convergence_rate ? 6 : 20);\\n for (unsigned int cycle = 0; cycle < max_cycle; ++cycle)\\n      {\\n        std::cout << \\\"Cycle \\\" << cycle << std::endl;\\n \\n switch (test_case)\\n          {\\n case TestCase::convergence_rate:\\n              {\\n if (cycle == 0)\\n                  {\\n GridGenerator::hyper_cube(triangulation);\\n \\n triangulation.refine_global(2);\\n                  }\\n else\\n                  {\\n triangulation.refine_global(1);\\n                  }\\n break;\\n              }\\n \\n case TestCase::l_singularity:\\n              {\\n if (cycle == 0)\\n                  {\\n GridGenerator::hyper_L(triangulation);\\n triangulation.refine_global(3);\\n                  }\\n else\\n                  {\\n                    refine_grid();\\n                  }\\n break;\\n              }\\n \\n default:\\n              {\\n DEAL_II_NOT_IMPLEMENTED();\\n              }\\n          }\\n \\n        std::cout << \\\"  Number of active cells       : \\\"\\n                  << triangulation.n_active_cells() << std::endl;\\n        setup_system();\\n \\n        std::cout << \\\"  Number of degrees of freedom : \\\" << dof_handler.n_dofs()\\n                  << std::endl;\\n \\n        assemble_system();\\n        solve();\\n        output_results(cycle);\\n        {\\n          convergence_table.add_value(\\\"cycle\\\", cycle);\\n          convergence_table.add_value(\\\"cells\\\", triangulation.n_active_cells());\\n          convergence_table.add_value(\\\"dofs\\\", dof_handler.n_dofs());\\n        }\\n        compute_errors();\\n \\n if (test_case == TestCase::l_singularity)\\n          {\\n            compute_error_estimate();\\n            std::cout << \\\"  Estimated error              : \\\"\\n                      << std::sqrt(estimated_error_square_per_cell.l1_norm())\\n                      << std::endl;\\n \\n            convergence_table.add_value(\\n \\\"Estimator\\\",\\n std::sqrt(estimated_error_square_per_cell.l1_norm()));\\n          }\\n        std::cout << std::endl;\\n      }\\n \\n    convergence_table.set_precision(\\\"L2\\\", 3);\\n    convergence_table.set_precision(\\\"H1\\\", 3);\\n    convergence_table.set_precision(\\\"Energy\\\", 3);\\n \\n    convergence_table.set_scientific(\\\"L2\\\", true);\\n    convergence_table.set_scientific(\\\"H1\\\", true);\\n    convergence_table.set_scientific(\\\"Energy\\\", true);\\n \\n if (test_case == TestCase::convergence_rate)\\n      {\\n        convergence_table.evaluate_convergence_rates(\\n \\\"L2\\\", ConvergenceTable::reduction_rate_log2);\\n        convergence_table.evaluate_convergence_rates(\\n \\\"H1\\\", ConvergenceTable::reduction_rate_log2);\\n      }\\n if (test_case == TestCase::l_singularity)\\n      {\\n        convergence_table.set_precision(\\\"Estimator\\\", 3);\\n        convergence_table.set_scientific(\\\"Estimator\\\", true);\\n      }\\n \\n    std::cout << \\\"degree = \\\" << degree << std::endl;\\n    convergence_table.write_text(\\n      std::cout, TableHandler::TextOutputFormat::org_mode_table);\\n  }\\n} // namespace Step74\\n \\n \\n \\nint main()\\n{\\n try\\n    {\\n using namespace dealii;\\n using namespace Step74;\\n \\n const TestCase test_case = TestCase::l_singularity;\\n \\n      SIPGLaplace<2> problem(test_case);\\n      problem.run();\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    };\\n \\n return 0;\\n}\\nAffineConstraints::distribute_local_to_globalvoid distribute_local_to_global(const InVector &local_vector, const std::vector< size_type > &local_dof_indices, OutVector &global_vector) constDefinition affine_constraints.h:2651\\nDataOutInterface::write_vtuvoid write_vtu(std::ostream &out) constDefinition data_out_base.cc:7692\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nDoFHandler::reinitvoid reinit(const Triangulation< dim, spacedim > &tria)\\nFEInterfaceValues::get_JxW_valuesconst std::vector< double > & get_JxW_values() const\\nFEInterfaceValues::n_current_interface_dofsunsigned n_current_interface_dofs() const\\nFEInterfaceValues::get_normal_vectorsconst std::vector< Tensor< 1, spacedim > > & get_normal_vectors() const\\nFEInterfaceValues::get_quadrature_pointsconst std::vector< Point< spacedim > > & get_quadrature_points() const\\nFEInterfaceValues::get_interface_dof_indicesstd::vector< types::global_dof_index > get_interface_dof_indices() const\\nFEInterfaceValues::get_jump_in_function_valuesvoid get_jump_in_function_values(const InputVector &fe_function, std::vector< typename InputVector::value_type > &values) const\\nFEInterfaceValues::get_jump_in_function_gradientsvoid get_jump_in_function_gradients(const InputVector &fe_function, std::vector< Tensor< 1, spacedim, typename InputVector::value_type > > &gradients) const\\nFEValuesBase::get_JxW_valuesconst std::vector< double > & get_JxW_values() const\\nFEValuesBase::get_function_valuesvoid get_function_values(const ReadVector< Number > &fe_function, std::vector< Number > &values) constDefinition fe_values_base.cc:716\\nFEValuesBase::dofs_per_cellconst unsigned int dofs_per_cellDefinition fe_values_base.h:192\\nFEValuesBase::get_function_hessiansvoid get_function_hessians(const ReadVector< Number > &fe_function, std::vector< Tensor< 2, spacedim, Number > > &hessians) constDefinition fe_values_base.cc:954\\nFEValuesBase::get_function_gradientsvoid get_function_gradients(const ReadVector< Number > &fe_function, std::vector< Tensor< 1, spacedim, Number > > &gradients) constDefinition fe_values_base.cc:851\\nFEValuesBase::shape_gradconst Tensor< 1, spacedim > & shape_grad(const unsigned int i, const unsigned int q_point) const\\nFEValuesBase::shape_valueconst double & shape_value(const unsigned int i, const unsigned int q_point) const\\nSparseDirectUMFPACK::vmultvoid vmult(Vector< double > &dst, const Vector< double > &src) constDefinition sparse_direct.cc:795\\nVector::reinitvirtual void reinit(const size_type N, const bool omit_zeroing_entries=false)\\nconvergence_table.h\\ncopy_data.h\\nderivative_approximation.h\\ndof_handler.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nfe_values.h\\nfe_dgq.h\\nfe_interface_values.h\\nfunction.h\\nfunction_lib.h\\ngrid_refinement.h\\ntria.h\\ngrid_generator.h\\ngrid_out.h\\nmapping_q1.h\\nmesh_loop.h\\nEvaluationFlags::hessians@ hessiansDefinition evaluation_flags.h:58\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\nOpenCASCADE::pointPoint< spacedim > point(const gp_Pnt &p, const double tolerance=1e-10)Definition utilities.cc:191\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\ninternal::reinitvoid reinit(MatrixBlock< MatrixType > &v, const BlockSparsityPattern &p)Definition matrix_block.h:617\\ninternal::EvaluatorQuantity::value@ value\\ninternal::EvaluatorQuantity::gradient@ gradient\\ndata_out.h\\nquadrature_lib.h\\nscratch_data.h\\nsparse_direct.h\\nsparse_matrix.h\\nvector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"