"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_43.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-43 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-43 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-43 tutorial program\\n\\n\\nThis tutorial depends on step-31.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nAdvection-dominated two-phase flow mathematical model\\nAdaptive operator splitting and time stepping\\nTime discretization\\nWeak form, space discretization for the pressure-velocity part\\nStabilization, weak form and space discretization for the saturation transport equation\\nAdaptive mesh refinement\\nThe linear system and its preconditioning\\nThe test cases\\nA note on the implementation\\n\\n The commented program\\n\\nInclude files\\nBoundary and initial value classes\\nPermeability models\\nPhysical quantities\\nHelper classes for solvers and preconditioners\\nThe TwoPhaseFlowProblem class\\nTwoPhaseFlowProblem::TwoPhaseFlowProblem\\nTwoPhaseFlowProblem::setup_dofs\\nAssembling matrices and preconditioners\\n\\nTwoPhaseFlowProblem::assemble_darcy_preconditioner\\nTwoPhaseFlowProblem::build_darcy_preconditioner\\nTwoPhaseFlowProblem::assemble_darcy_system\\nTwoPhaseFlowProblem::assemble_saturation_system\\nTwoPhaseFlowProblem::assemble_saturation_matrix\\nTwoPhaseFlowProblem::assemble_saturation_rhs\\nTwoPhaseFlowProblem::assemble_saturation_rhs_cell_term\\nTwoPhaseFlowProblem::assemble_saturation_rhs_boundary_term\\n\\nTwoPhaseFlowProblem::solve\\nTwoPhaseFlowProblem::refine_mesh\\nTwoPhaseFlowProblem::output_results\\nTool functions\\n\\nTwoPhaseFlowProblem::determine_whether_to_solve_for_pressure_and_velocity\\nTwoPhaseFlowProblem::project_back_saturation\\nTwoPhaseFlowProblem::get_max_u_F_prime\\nTwoPhaseFlowProblem::get_extrapolated_saturation_range\\nTwoPhaseFlowProblem::compute_viscosity\\n\\nTwoPhaseFlowProblem::run\\nThe main() function\\n\\n\\n Results\\n\\nPossibilities for extensions\\n\\n The plain program\\n   \\n\\n\\n This program was contributed by Chih-Che Chueh (University of Victoria) and Wolfgang Bangerth. Results from this program are used and discussed in the following publications (in particular in the second one):\\nChih-Che Chueh, Marc Secanell, Wolfgang Bangerth, Ned Djilali. Multi-level adaptive simulation of transient two-phase flow in heterogeneous porous media. Computers & Fluids, 39:1585-1596, 2010 (see [58]).\\nChih-Che Chueh, Ned Djilali, Wolfgang Bangerth. An h-adaptive operator splitting method for two-phase flow in 3D heterogeneous porous media. SIAM Journal on Scientific Computing, 35:B149-B175, 2013 (see [59]).\\n\\n\\nThe implementation discussed here uses and extends parts of the step-21 and step-31 tutorial programs.\\nThe work of the Chih-Che Chueh was funded through the Canada Research Chairs Program and the MITACS Network of Centres of Excellence. Parts of the work by Wolfgang Bangerth were funded through Award No. KUS-C1-016-04, made by the King Abdullah University of Science and Technology, and through an Alfred P. Sloan Research Fellowship. This material is also in parts based upon work supported by the National Science Foundation under Award No. EAR-0426271 and The California Institute of Technology; and in a continuation by the National Science Foundation under Award No. EAR-0949446 and The University of California \\u2013 Davis. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the author and do not necessarily reflect the views of the National Science Foundation, The California Institute of Technology, or of The University of California \\u2013 Davis. \\n Introduction\\nThe simulation of multiphase flow in porous media is a ubiquitous problem, and we have previously addressed it already in some form in step-20 and step-21. However, as was easy to see there, it faces two major difficulties: numerical accuracy and efficiency. The first is easy to see in the stationary solver step-20: using lowest order Raviart-Thomas elements can not be expected to yield highly accurate solutions. We need more accurate methods. The second reason is apparent from the time dependent step-21: that program is excruciatingly slow, and there is no hope to get highly accurate solutions in 3d within reasonable time frames.\\nIn this program, in order to overcome these two problems, there are five areas which we are trying to improve for a high performance simulator:\\n\\n\\nHigher order spatial discretizations \\n\\nAdaptive mesh refinement \\n\\nAdaptive time stepping \\n\\nOperator splitting \\n\\nEfficient solver and preconditioning \\n\\nMuch inspiration for this program comes from step-31 but several of the techniques discussed here are original.\\nAdvection-dominated two-phase flow mathematical model\\nWe consider the flow of a two-phase immiscible, incompressible fluid. Capillary and gravity effects are neglected, and viscous effects are assumed dominant. The governing equations for such a flow that are identical to those used in step-21 and are     \\n\\\\begin{align*}\\n  \\\\mathbf{u}_t &= - \\\\mathbf{K} \\\\lambda_t \\\\left(S\\\\right) \\\\nabla p, \\\\\\\\\\n  \\\\nabla \\\\cdot \\\\mathbf{u}_t &= q, \\\\\\\\\\n  \\\\epsilon \\\\frac{\\\\partial S}{\\\\partial t} + \\\\nabla \\\\cdot \\\\left( \\\\mathbf{u}_t  F\\\\left( S \\\\right) \\\\right)&=0,\\n\\\\end{align*}\\n\\n where \\\\(S\\\\) is the saturation (volume fraction between zero and one) of the second (wetting) phase, \\\\(p\\\\) is the pressure, \\\\(\\\\mathbf{K}\\\\) is the permeability tensor, \\\\(\\\\lambda_t\\\\) is the total mobility, \\\\(\\\\epsilon\\\\) is the porosity, \\\\(F\\\\) is the fractional flow of the wetting phase, \\\\(q\\\\) is the source term and \\\\(\\\\mathbf{u}_t\\\\) is the total velocity. The total mobility, fractional flow of the wetting phase and total velocity are respectively given by     \\n\\\\begin{align*}\\n   \\\\lambda_t(S)&= \\\\lambda_w + \\\\lambda_{nw} = \\\\frac{k_{rw}(S)}{\\\\mu_w} + \\\\frac{k_{rnw}(S)}{\\\\mu_{nw}}, \\\\\\\\\\n   F(S) &= \\\\frac{\\\\lambda_w}{\\\\lambda_t} = \\\\frac{\\\\lambda_w}{\\\\lambda_w + \\\\lambda_{nw}} = \\\\frac{k_{rw}(S)/\\\\mu_w}{k_{rw}(S)/\\\\mu_w + k_{rnw}(S)/\\\\mu_{nw}}, \\\\\\\\\\n   \\\\mathbf{u}_t &= \\\\mathbf{u}_w + \\\\mathbf{u}_{nw} = -\\\\lambda_t(S)\\\\mathbf{K} \\\\cdot \\\\nabla p,\\n\\\\end{align*}\\n\\n where subscripts \\\\(w, nw\\\\) represent the wetting and non-wetting phases, respectively.\\nFor convenience, the porosity \\\\(\\\\epsilon\\\\) in the saturation equation, which can be considered a scaling factor for the time variable, is set to one. Following a commonly used prescription for the dependence of the relative permeabilities \\\\(k_{rw}\\\\) and \\\\(k_{rnw}\\\\) on saturation, we use    \\n\\\\begin{align*}\\n   k_{rw}  &= S^2, \\\\qquad&\\\\qquad\\n   k_{rnw} &= \\\\left( 1-S \\\\right)^2.\\n\\\\end{align*}\\n\\nThe porous media equations above are augmented by initial conditions for the saturation and boundary conditions for the pressure. Since saturation and the gradient of the pressure uniquely determine the velocity, no boundary conditions are necessary for the velocity. Since the flow equations do not contain time derivatives, initial conditions for the velocity and pressure variables are not required. The flow field separates the boundary into inflow or outflow parts. Specifically,   \\n\\\\[\\n   \\\\mathbf{\\\\Gamma}_{in}(t) = \\\\left\\\\{\\\\mathbf{x} \\\\in \\\\partial \\\\Omega:\\\\mathbf{n} \\\\cdot \\\\mathbf{u}_t<0\\\\right\\\\},\\n\\\\]\\n\\n and we arrive at a complete model by also imposing boundary values for the saturation variable on the inflow boundary \\\\(\\\\mathbf{\\\\Gamma}_{in}\\\\).\\nAdaptive operator splitting and time stepping\\nAs seen in step-21, solving the flow equations for velocity and pressure are the parts of the program that take far longer than the (explicit) updating step for the saturation variable once we know the flow variables. On the other hand, the pressure and velocity depend only weakly on saturation, so one may think about only solving for pressure and velocity every few time steps while updating the saturation in every step. If we can find a criterion for when the flow variables need to be updated, we call this splitting an \\\"adaptive\\noperator splitting\\\" scheme.\\nHere, we use the following a posteriori criterion to decide when to re-compute pressure and velocity variables (detailed derivations and descriptions can be found in [59]):           \\n\\\\begin{align*}\\n  \\\\theta(n,n_p)\\n  =\\n    \\\\max_{\\\\kappa\\\\in{\\\\mathbb T}}\\n    \\\\left(\\n    \\\\left\\\\|\\n      \\\\frac 1{\\\\lambda_t\\\\left(S^{(n-1)}\\\\right)}\\n      - \\\\frac 1{\\\\lambda_t\\\\left(S^{(n_p)}\\\\right)} \\\\right\\\\|_{L^\\\\infty(\\\\kappa)}\\n    \\\\left\\\\|\\\\|\\\\mathbf{K}^{-1}\\\\|_1\\\\right\\\\|_{L^\\\\infty(\\\\kappa)}\\n    \\\\right).\\n\\\\end{align*}\\n\\n where superscripts in parentheses denote the number of the saturation time step at which any quantity is defined and \\\\(n_p<n\\\\) represents the last step where we actually computed the pressure and velocity. If \\\\(\\\\theta(n,n_p)\\\\) exceeds a certain threshold we re-compute the flow variables; otherwise, we skip this computation in time step \\\\(n\\\\) and only move the saturation variable one time step forward.\\nIn short, the algorithm allows us to perform a number of saturation time steps of length \\\\(\\\\Delta t_c^{(n)}=t^{(n)}_c-t^{(n-1)}_c\\\\) until the criterion above tells us to re-compute velocity and pressure variables, leading to a macro time step of length   \\n\\\\[\\n   \\\\Delta t_p^{(n)} = \\\\sum_{i=n_p+1}^{n} \\\\Delta t_c^{(i)}.\\n\\\\]\\n\\n We choose the length of (micro) steps subject to the Courant-Friedrichs-Lewy (CFL) restriction according to the criterion   \\n\\\\[\\n  \\\\Delta t_c = \\\\frac{\\\\textrm{min}_{K}h_{K}}{7 \\\\|\\\\mathbf{u}_t\\\\|_{L^{\\\\infty}\\\\left(\\\\Omega\\\\right)}},\\n\\\\]\\n\\n which we have confirmed to be stable for the choice of finite element and time stepping scheme for the saturation equation discussed below ( \\\\(h_K\\\\) denotes the diameter of cell \\\\(K\\\\)). The result is a scheme where neither micro nor macro time steps are of uniform length, and both are chosen adaptively.\\nTime discretization\\nUsing this time discretization, we obtain the following set of equations for each time step from the IMPES approach (see step-21):     \\n\\\\begin{align*}\\n   \\\\mathbf{u}^{(n)}_t + \\\\lambda_t\\\\left(S^{(n-1)}\\\\right) \\\\mathbf{K} \\\\nabla p^{(n)} =0, \\\\\\\\\\n   \\\\nabla \\\\cdot \\\\mathbf{u}^{(n)}_t = q, \\\\\\\\\\n   \\\\epsilon \\\\left( \\\\frac{S^{(n-1)}-S^{(n)}}{\\\\Delta t^{(n)}_c} \\\\right) + \\\\mathbf{u}^{(n)}_t \\\\cdot \\\\nabla F\\\\left(S^{(n-1)}\\\\right) + F\\\\left(S^{(n-1)}\\\\right) \\\\nabla \\\\cdot \\\\mathbf{u}^{(n)}_t =0.\\n\\\\end{align*}\\n\\nUsing the fact that \\\\(\\\\nabla \\\\cdot \\\\mathbf{u}_t = q\\\\), the time discrete saturation equation becomes   \\n\\\\begin{align*}\\n  &\\\\epsilon \\\\left( \\\\frac{S^{(n)}-S^{(n-1)}}{\\\\Delta t^{(n)}_c} \\\\right) + \\\\mathbf{u}^{(n)}_t \\\\cdot \\\\nabla F\\\\left(S^{(n-1)}\\\\right) + F\\\\left(S^{(n-1)}\\\\right)q=0.\\n\\\\end{align*}\\n\\nWeak form, space discretization for the pressure-velocity part\\nBy multiplying the equations defining the total velocity \\\\(\\\\mathbf u_t^{(n)}\\\\) and the equation that expresses its divergence in terms of source terms, with test functions \\\\(\\\\mathbf{v}\\\\) and \\\\(w\\\\) respectively and then integrating terms by parts as necessary, the weak form of the problem reads: Find \\\\(\\\\mathbf u, p\\\\) so that for all test functions \\\\(\\\\mathbf{v}, w\\\\) there holds    \\n\\\\begin{gather*}\\n   \\\\left( \\\\left( \\\\mathbf{K} \\\\lambda_t\\\\left(S^{(n-1)}\\\\right) \\\\right)^{-1} \\\\mathbf{u}^{(n)}_t, \\\\mathbf{v}\\\\right)_{\\\\Omega} - \\\\left(p^{(n)}, \\\\nabla \\\\cdot \\\\mathbf{v}\\\\right)_{\\\\Omega} = -\\\\left(p^{(n)}, \\\\mathbf{n} \\\\cdot \\\\mathbf{v} \\\\right)_{\\\\partial \\\\Omega}, \\\\\\\\\\n   - \\\\left( \\\\nabla \\\\cdot \\\\mathbf{u}^{(n)}_t,w\\\\right)_{\\\\Omega} = - \\\\big(q,w\\\\big)_{\\\\Omega}.\\n\\\\end{gather*}\\n\\n Here, \\\\(\\\\mathbf{n}\\\\) represents the unit outward normal vector to  \\\\(\\\\partial\\n\\\\Omega\\\\) and the pressure \\\\(p^{(n)}\\\\) can be prescribed weakly on the open part of the boundary \\\\(\\\\partial \\\\Omega\\\\) whereas on those parts where a velocity is prescribed (for example impermeable boundaries with  \\\\(\\\\mathbf n \\\\cdot \\\\mathbf\\nu=0\\\\) the term disappears altogether because  \\\\(\\\\mathbf n \\\\cdot \\\\mathbf\\nv=0\\\\).\\nWe use continuous finite elements to discretize the velocity and pressure equations. Specifically, we use mixed finite elements to ensure high order approximation for both vector (e.g. a fluid velocity) and scalar variables (e.g. pressure) simultaneously. For saddle point problems, it is well established that the so-called Babuska-Brezzi or Ladyzhenskaya-Babuska-Brezzi (LBB) conditions [45], [55] need to be satisfied to ensure stability of the pressure-velocity system. These stability conditions are satisfied in the present work by using elements for velocity that are one order higher than for the pressure, i.e. \\\\(u_h \\\\in Q^d_{p+1}\\\\) and \\\\(p_h \\\\in Q_p\\\\), where \\\\(p=1\\\\), \\\\(d\\\\) is the space dimension, and \\\\(Q_s\\\\) denotes the space of tensor product Lagrange polynomials of degree \\\\(s\\\\) in each variable.\\nStabilization, weak form and space discretization for the saturation transport equation\\nThe chosen \\\\(Q_1\\\\) elements for the saturation equation do not lead to a stable discretization without upwinding or other kinds of stabilization, and spurious oscillations will appear in the numerical solution. Adding an artificial diffusion term is one approach to eliminating these oscillations [55]. On the other hand, adding too much diffusion smears sharp fronts in the solution and suffers from grid-orientation difficulties [55]. To avoid these effects, we use the artificial diffusion term proposed by [104] and validated in [59] and [138], as well as in step-31.\\nThis method modifies the (discrete) weak form of the saturation equation to read              \\n\\\\begin{align*}\\n  \\\\left(\\\\epsilon \\\\frac{\\\\partial S_h}{\\\\partial t},\\\\sigma_h\\\\right)\\n  -\\n  \\\\left(\\\\mathbf{u}_t  F\\\\left( S_h \\\\right),\\n    \\\\nabla \\\\sigma_h\\\\right)\\n  +\\n  \\\\left(\\\\mathbf n \\\\cdot \\\\mathbf{u}_t  \\\\hat F\\\\left( S_h \\\\right),\\n    \\\\sigma_h\\\\right)_{\\\\partial\\\\Omega}\\n  +\\n  (\\\\nu(S_h) \\\\nabla S_h, \\\\nabla \\\\sigma_h)\\n  &=0\\n  \\\\qquad\\n  \\\\forall \\\\sigma_h,\\n\\\\end{align*}\\n\\n where \\\\(\\\\nu\\\\) is the artificial diffusion parameter and \\\\(\\\\hat F\\\\) is an appropriately chosen numerical flux on the boundary of the domain (we choose the obvious full upwind flux for this).\\nFollowing [104] (and as detailed in [59]), we use the parameter as a piecewise constant function set on each cell \\\\(K\\\\) with the diameter \\\\(h_{K}\\\\) as   \\n\\\\[\\n   \\\\nu(S_h)|_{K} = \\\\beta \\\\| \\\\mathbf{u}_t \\\\max\\\\{F'(S_h),1\\\\} \\\\|_{L^{\\\\infty}(K)} \\\\textrm{min} \\\\left\\\\{ h_{K},h^{\\\\alpha}_{K} \\\\frac{\\\\|\\\\textrm{Res}(S_h)\\\\|_{L^{\\\\infty}(K)}}{c(\\\\mathbf{u}_t,S)} \\\\right\\\\}\\n\\\\]\\n\\n where \\\\(\\\\alpha\\\\) is a stabilization exponent and \\\\(\\\\beta\\\\) is a dimensionless user-defined stabilization constant. Following [104] as well as the implementation in step-31, the velocity and saturation global normalization constant, \\\\(c(\\\\mathbf{u}_t,S)\\\\), and the residual \\\\(\\\\textrm{Res}(S)\\\\) are respectively given by   \\n\\\\[\\n   c(\\\\mathbf{u}_t,S) = c_R \\\\|\\\\mathbf{u}_t \\\\max\\\\{F'(S),1\\\\}\\\\|_{L^{\\\\infty}(\\\\Omega)} \\\\textrm{var}(S)^\\\\alpha | \\\\textrm{diam} (\\\\Omega) |^{\\\\alpha - 2}\\n\\\\]\\n\\n and   \\n\\\\[\\n   \\\\textrm{Res}(S) = \\\\left( \\\\epsilon \\\\frac{\\\\partial S}{\\\\partial t} + \\\\mathbf{u}_t \\\\cdot \\\\nabla F(S) + F(S)q \\\\right) \\\\cdot S^{\\\\alpha - 1}\\n\\\\]\\n\\n where \\\\(c_R\\\\) is a second dimensionless user-defined constant, \\\\(\\\\textrm{diam}(\\\\Omega)\\\\) is the diameter of the domain and  \\\\(\\\\textrm{var}(S) =\\n\\\\textrm{max}_{\\\\Omega} S - \\\\textrm{min}_{\\\\Omega} S\\\\) is the range of the present saturation values in the entire computational domain \\\\(\\\\Omega\\\\).\\nThis stabilization scheme has a number of advantages over simpler schemes such as finite volume (or discontinuous Galerkin) methods or streamline upwind Petrov Galerkin (SUPG) discretizations. In particular, the artificial diffusion term acts primarily in the vicinity of discontinuities since the residual is small in areas where the saturation is smooth. It therefore provides for a higher degree of accuracy. On the other hand, it is nonlinear since \\\\(\\\\nu\\\\) depends on the saturation \\\\(S\\\\). We avoid this difficulty by treating all nonlinear terms explicitly, which leads to the following fully discrete problem at time step \\\\(n\\\\):     \\n\\\\begin{align*}\\n   &\\\\left( \\\\epsilon S_h^{(n)},\\\\sigma_h\\\\right)_{\\\\Omega} - \\\\Delta t^{(n)}_c \\\\Big(F\\\\left(S_h^{(n-1)}\\\\right)\\\\mathbf{u}^{*}_t,\\\\nabla\\\\sigma_h\\\\Big)_{\\\\Omega} + \\\\Delta t^{(n)}_c \\\\Big(F\\\\left(S_h^{(n-1)}\\\\right)\\\\left(\\\\mathbf{n}\\\\cdot\\\\mathbf{u}^{*}_t\\\\right),\\\\sigma_h\\\\Big)_{\\\\partial\\\\Omega} \\\\nonumber \\\\\\\\\\n   & \\\\quad = \\\\left( \\\\epsilon S_h^{(n-1)},\\\\sigma_h\\\\right)_{\\\\Omega} - \\\\Delta t^{(n)}_c \\\\bigg(\\\\nu\\\\left(S_h^{(n-1)}\\\\right)\\\\nabla S_h^{(n-1)},\\\\nabla\\\\sigma_h\\\\bigg)_{\\\\Omega} \\\\nonumber \\\\\\\\\\n   & \\\\qquad + \\\\Delta t^{(n)}_c \\\\bigg(\\\\mathbf{n}\\\\cdot\\\\nu\\\\left(S_h^{(n-1)}\\\\right)\\\\nabla S^{(n-1)},\\\\sigma_h\\\\bigg)_{\\\\partial\\\\Omega}\\n\\\\end{align*}\\n\\n where \\\\(\\\\mathbf{u}_t^{*}\\\\) is the velocity linearly extrapolated from \\\\(\\\\mathbf{u}^{(n_p)}_t\\\\) and \\\\(\\\\mathbf{u}^{(n_{pp})}_t\\\\) to the current time \\\\(t^{(n)}\\\\) if \\\\(\\\\theta<\\\\theta^*\\\\) while \\\\(\\\\mathbf{u}_t^{*}\\\\) is \\\\(\\\\mathbf{u}^{(n_p)}_t\\\\) if \\\\(\\\\theta>\\\\theta^*\\\\). Consequently, the equation is linear in \\\\(S_h^{(n)}\\\\) and all that is required is to solve with a mass matrix on the saturation space.\\nSince the Dirichlet boundary conditions for saturation are only imposed on the inflow boundaries, the third term on the left hand side of the equation above needs to be split further into two parts:    \\n\\\\begin{align*}\\n  &\\\\Delta t^{(n)}_c \\\\Big(F\\\\left(S_h^{(n-1)}\\\\right)\\\\left(\\\\mathbf{n}\\\\cdot\\\\mathbf{u}^{(n)}_t\\\\right),\\\\sigma_h\\\\Big)_{\\\\partial\\\\Omega} \\\\nonumber \\\\\\\\\\n  &\\\\qquad= \\\\Delta t^{(n)}_c \\\\Big(F\\\\left(S^{(n-1)}_{(+)}\\\\right)\\\\left(\\\\mathbf{n}\\\\cdot\\\\mathbf{u}^{(n)}_{t(+)}\\\\right),\\\\sigma_h\\\\Big)_{\\\\partial\\\\Omega_{(+)}} + \\\\Delta t^{(n)}_c \\\\Big(F\\\\left(S^{(n-1)}_{(-)}\\\\right)\\\\left(\\\\mathbf{n}\\\\cdot\\\\mathbf{u}^{(n)}_{t(-)}\\\\right),\\\\sigma_h\\\\Big)_{\\\\partial\\\\Omega_{(-)}}\\n\\\\end{align*}\\n\\n where  \\\\(\\\\partial\\\\Omega_{(-)} = \\\\left\\\\{\\\\mathbf{x} \\\\in \\\\partial\\\\Omega : \\\\mathbf{n}\\n  \\\\cdot \\\\mathbf{u}_t<0\\\\right\\\\}\\\\) and  \\\\(\\\\partial\\\\Omega_{(+)} = \\\\left\\\\{\\\\mathbf{x} \\\\in \\\\partial\\\\Omega : \\\\mathbf{n} \\\\cdot\\n  \\\\mathbf{u}_t>0\\\\right\\\\}\\\\) represent inflow and outflow boundaries, respectively. We choose values using an upwind formulation, i.e. \\\\(S^{(n-1)}_{(+)}\\\\) and \\\\(\\\\mathbf{u}^{(n)}_{t(+)}\\\\) correspond to the values taken from the present cell, while the values of \\\\(S^{(n-1)}_{(-)}\\\\) and \\\\(\\\\mathbf{u}^{(n)}_{t(-)}\\\\) are those taken from the neighboring boundary \\\\(\\\\partial\\\\Omega_{(-)}\\\\).\\nAdaptive mesh refinement\\nChoosing meshes adaptively to resolve sharp saturation fronts is an essential ingredient to achieve efficiency in our algorithm. Here, we use the same shock-type refinement approach used in [59] to select those cells that should be refined or coarsened. The refinement indicator for each cell \\\\(K\\\\) of the triangulation is computed by   \\n\\\\[\\n   \\\\eta_{K} = |\\\\nabla S_h(\\\\mathbf x_K)|\\n\\\\]\\n\\n where \\\\(\\\\nabla S_h(\\\\mathbf x_K)\\\\) is the gradient of the discrete saturation variable evaluated at the center \\\\(\\\\mathbf x_K\\\\) of cell \\\\(K\\\\). This approach is analogous to ones frequently used in compressible flow problems, where density gradients are used to indicate refinement. That said, as we will discuss at the end of the results section, this turns out to not be a very useful criterion since it leads to refinement basically everywhere. We only show it here for illustrative purposes.\\nThe linear system and its preconditioning\\nFollowing the discretization of the governing equations discussed above, we obtain a linear system of equations in time step \\\\((n)\\\\) of the following form:                        \\n\\\\[\\n \\\\left(\\n  \\\\begin{array}{ccc}\\n   \\\\mathbf{M}^{\\\\mathbf{u}} & \\\\mathbf{B}^{T} & \\\\mathbf{0}  \\\\\\\\\\n   \\\\mathbf{B}           & \\\\mathbf{0}     & \\\\mathbf{0}   \\\\\\\\\\n   \\\\mathbf{H}           & \\\\mathbf{0}     & \\\\mathbf{M}^{S}\\n  \\\\end{array}\\n \\\\right)\\n \\\\left(\\n  \\\\begin{array}{c}\\n   \\\\mathbf{U}^{(n)} \\\\\\\\\\n   \\\\mathbf{P}^{(n)} \\\\\\\\\\n   \\\\mathbf{S}^{(n)}\\n  \\\\end{array}\\n \\\\right)\\n =\\n \\\\left(\\n  \\\\begin{array}{c}\\n   0 \\\\\\\\\\n   \\\\mathbf{F}_{2} \\\\\\\\\\n   \\\\mathbf{F}_{3}\\n  \\\\end{array}\\n \\\\right)\\n\\\\]\\n\\n where the individual matrices and vectors are defined as follows using shape functions \\\\(\\\\mathbf{v}_i\\\\) for velocity, and \\\\(\\\\phi_i\\\\) for both pressure and saturation:                \\n\\\\begin{align*}\\n  \\\\mathbf{M}^{\\\\mathbf{u}}_{ij}\\n  &= \\\\left( \\\\left( \\\\mathbf{K} \\\\lambda_t\\\\left(S^{(n-1)}\\\\right) \\\\right)^{-1}\\n  \\\\mathbf{v}_{i},\\\\mathbf{v}_{j}\\\\right)_{\\\\Omega},\\n  &\\n  \\\\mathbf{M}^{S}_{ij}           &= \\\\left(\\\\epsilon \\\\phi_i,\\\\phi_j\\\\right)_{\\\\Omega}\\n  \\\\\\\\\\n  \\\\mathbf{B}_{ij}\\n  &= - \\\\left( \\\\nabla \\\\cdot \\\\mathbf{v}_{j},\\\\phi_{i}\\\\right)_{\\\\Omega},\\n  &\\n  \\\\mathbf{H}_{ij}\\n  &= - \\\\Delta t^{(n)}_c \\\\Big( F\\\\left(S^{(n-1)}\\\\right) \\\\mathbf{v}_i,\\\\nabla\\\\phi_j\\\\Big)_{\\\\Omega}\\n  \\\\\\\\\\n  \\\\left(\\\\mathbf{F}_{2}\\\\right)_i\\n  &= - \\\\big(F\\\\left(S^{(n-1)}\\\\right)q,\\\\phi_i\\\\big)_{\\\\Omega},\\n\\\\end{align*}\\n\\n and \\\\(\\\\mathbf{F}_{3}\\\\) as given in the definition of the stabilized transport equation.\\nThe linear system above is of block triangular form if we consider the top left \\\\(2\\\\times 2\\\\) panel of matrices as one block. We can therefore first solve for the velocity and pressure (unless we decide to use \\\\(\\\\mathbf U^{(n_p)}\\\\) in place of the velocity) followed by a solve for the saturation variable. The first of these steps requires us to solve                     \\n\\\\[\\n \\\\left(\\n  \\\\begin{array}{cc}\\n   \\\\mathbf{M}^{\\\\mathbf{u}} & \\\\mathbf{B}^{T}  \\\\\\\\\\n   \\\\mathbf{B}           & \\\\mathbf{0}\\n  \\\\end{array}\\n \\\\right)\\n \\\\left(\\n  \\\\begin{array}{c}\\n   \\\\mathbf{U}^{(n)} \\\\\\\\\\n   \\\\mathbf{P}^{(n)}\\n  \\\\end{array}\\n \\\\right)\\n =\\n \\\\left(\\n  \\\\begin{array}{c}\\n   0 \\\\\\\\\\n   \\\\mathbf{F}_{2}\\n  \\\\end{array}\\n \\\\right)\\n\\\\]\\n\\n We apply the Generalized Minimal Residual (GMRES) method [186] to this linear system. The ideal preconditioner for the velocity-pressure system is                 \\n\\\\begin{align*}\\n\\\\mathbf{P} =\\n \\\\left(\\n  \\\\begin{array}{cc}\\n   \\\\mathbf{M}^{\\\\mathbf{u}} &  \\\\mathbf{0}  \\\\\\\\\\n   \\\\mathbf{B}           & -\\\\mathbf{S}\\n  \\\\end{array}\\n \\\\right),\\n & \\\\qquad\\n \\\\mathbf{P}^{-1} =\\n \\\\left(\\n  \\\\begin{array}{cc}\\n   \\\\left(\\\\mathbf{M}^{\\\\mathbf{u}}\\\\right)^{-1}                              &  \\\\mathbf{0}  \\\\\\\\\\n   \\\\mathbf{S}^{-1} \\\\mathbf{B} \\\\left(\\\\mathbf{M}^{\\\\mathbf{u}}\\\\right)^{-1}   & -\\\\mathbf{S}^{-1}\\n  \\\\end{array}\\n \\\\right)\\n \\\\end{align*}\\n\\n where \\\\(\\\\mathbf{S}=\\\\mathbf{B}\\\\left(\\\\mathbf{M}^{\\\\mathbf{u}}\\\\right)^{-1}\\\\mathbf{B}^T\\\\) is the Schur complement [215] of the system. This preconditioner is optimal since                \\n\\\\begin{align*}\\n \\\\mathbf{P}^{-1}\\n \\\\left(\\n  \\\\begin{array}{cc}\\n   \\\\mathbf{M}^{\\\\mathbf{u}} & \\\\mathbf{B}^{T}  \\\\\\\\\\n   \\\\mathbf{B}           & \\\\mathbf{0}\\n  \\\\end{array}\\n \\\\right)\\n =\\n  \\\\left(\\n  \\\\begin{array}{cc}\\n   \\\\mathbf{I}         &  \\\\left(\\\\mathbf{M}^{\\\\mathbf{u}}\\\\right)^{-1} \\\\mathbf{B}^{T}  \\\\\\\\\\n   \\\\mathbf{0}         &  \\\\mathbf{I}\\n  \\\\end{array}\\n \\\\right),\\n\\\\end{align*}\\n\\n for which it can be shown that GMRES converges in two iterations.\\nHowever, we cannot of course expect to use exact inverses of the velocity mass matrix and the Schur complement. We therefore follow the approach by [194] originally proposed for the Stokes system. (See also the note in the \\\"Possibilities for extensions\\\" section of step-22.) Adapting it to the current set of equations yield the preconditioner          \\n\\\\begin{align*}\\n \\\\mathbf{\\\\tilde{P}}^{-1} =\\n \\\\left(\\n  \\\\begin{array}{cc}\\n   \\\\widetilde{\\\\left(\\\\mathbf{{M}}^{\\\\mathbf{u}}\\\\right)^{-1}}\\n                              &  \\\\mathbf{0}  \\\\\\\\\\n   \\\\widetilde{\\\\mathbf{{S}}^{-1}} \\\\mathbf{B} \\\\widetilde{\\\\left(\\\\mathbf{{M}}^{\\\\mathbf{u}}\\\\right)^{-1}}   & -\\\\widetilde{\\\\mathbf{{S}}^{-1}}\\n  \\\\end{array}\\n \\\\right)\\n\\\\end{align*}\\n\\n where a tilde indicates an approximation of the exact inverse matrix. In particular, since   \\\\(\\\\left(\\\\mathbf{{M}}^{\\\\mathbf{u}}\\\\right)^{-1}=\\\\left( \\\\left(\\n    \\\\mathbf{K} \\\\lambda_t \\\\right)^{-1}\\n  \\\\mathbf{v}_{i},\\\\mathbf{v}_{j}\\\\right)_{\\\\Omega}\\\\) is a sparse symmetric and positive definite matrix, we choose for \\\\(\\\\widetilde{\\\\left(\\\\mathbf{{M}}^{\\\\mathbf{u}}\\\\right)^{-1}}\\\\) a single application of a sparse incomplete Cholesky decomposition of this matrix [99]. We note that the Schur complement that corresponds to the porous media flow operator in non-mixed form,  \\\\(-\\\\nabla \\\\cdot [\\\\mathbf K\\n\\\\lambda_t(S)]\\\\nabla\\\\) and \\\\(\\\\mathbf{\\\\tilde {S}} = \\\\left( \\\\left( \\\\mathbf{K} \\\\lambda_t \\\\right) \\\\nabla \\\\phi_{i},\\\\nabla \\\\phi_{j}\\\\right)_{\\\\Omega}\\\\) should be a good approximation of the actual Schur complement matrix  \\\\(\\\\mathbf\\nS\\\\). Since both of these matrices are again symmetric and positive definite, we use an incomplete Cholesky decomposition of \\\\(\\\\mathbf{\\\\tilde S}\\\\) for  \\\\(\\\\widetilde\\n{\\\\mathbf{{S}}^{-1}}\\\\). It is important to note that \\\\(\\\\mathbf{\\\\tilde S}\\\\) needs to be built with Dirichlet boundary conditions to ensure its invertibility.\\nOnce the velocity \\\\(\\\\mathbf{U}^{(n)} \\\\equiv \\\\mathbf{u}^*_t\\\\) is available, we can assemble \\\\(\\\\mathbf{H}\\\\) and \\\\(\\\\mathbf{F}_{3}\\\\) and solve for the saturations using   \\n\\\\begin{align*}\\n  \\\\mathbf{M}^{S} \\\\mathbf{S}^{(n)} = \\\\mathbf{F}_{3} - \\\\mathbf{H} \\\\mathbf{U}^{(n)}.\\n\\\\end{align*}\\n\\n where the mass matrix \\\\(\\\\mathbf{M}^{S}\\\\) is solved by the conjugate gradient method, using an incomplete Cholesky decomposition as preconditioner once more.\\nThe test cases\\nNoteThe implementation discussed here uses and extends parts of the step-21, step-31 and step-33 tutorial programs of this library. In particular, if you want to understand how it works, please consult step-21 for a discussion of the mathematical problem, and step-31 from which most of the implementation is derived. We will not discuss aspects of the implementation that have already been discussed in step-31.\\nWe show numerical results for some two-phase flow equations augmented by appropriate initial and boundary conditions in conjunction with two different choices of the permeability model. In the problems considered, there is no internal source term ( \\\\(q=0\\\\)). As mentioned above, quantitative numerical results are presented in [59].\\nFor simplicity, we choose \\\\(\\\\Omega=[0,1]^d,d=2,3\\\\), though all methods (as well as our implementation) should work equally well on general unstructured meshes.\\nInitial conditions are only required for the saturation variable, and we choose \\\\(S(\\\\mathbf{x},0)=0.2\\\\), i.e. the porous medium is initially filled by a mixture of the non-wetting (80%) and wetting (20%) phases. This differs from the initial condition in step-21 where we had taken \\\\(S(\\\\mathbf{x},0)=0\\\\), but for complicated mathematical reasons that are mentioned there in a longish remark, the current method using an entropy-based artificial diffusion term does not converge to the viscosity solution with this initial condition without additional modifications to the method. We therefore choose this modified version for the current program.\\nFurthermore, we prescribe a linear pressure on the boundaries:    \\n\\\\[\\n   p(\\\\mathbf{x},t) = 1 - x \\\\qquad\\n   \\\\textrm{on} \\\\quad \\\\partial \\\\Omega \\\\times [0,T].\\n\\\\]\\n\\n Pressure and saturation uniquely determine a velocity, and the velocity determines whether a boundary segment is an inflow or outflow boundary. On the inflow part of the boundary, \\\\(\\\\mathbf{\\\\Gamma}_{in}(t)\\\\), we impose    \\n\\\\begin{align*}\\n   S(\\\\mathbf{x},t) = 1 \\\\qquad & \\\\textrm{on} \\\\quad \\\\mathbf{\\\\Gamma}_{in}(t) \\\\cap \\\\left\\\\{x = 0\\\\right\\\\}, \\\\\\\\\\n   S(\\\\mathbf{x},t) = 0 \\\\qquad & \\\\textrm{on} \\\\quad \\\\mathbf{\\\\Gamma}_{in}(t) \\\\backslash \\\\left\\\\{x = 0\\\\right\\\\}.\\n\\\\end{align*}\\n\\n In other words, the domain is flooded by the wetting phase from the left. No boundary conditions for the saturation are required for the outflow parts of the boundary.\\nAll the numerical and physical parameters used for the 2D/3D cases are listed in the following table:\\n\\n\\nParameter Symbol Value units \\n\\nPorosity \\\\(\\\\epsilon\\\\) 1.0 - \\n\\nViscosity (wetting) \\\\(\\\\mu_w\\\\) 0.2 \\\\(kg \\\\cdot m^{-1} \\\\cdot sec^{-1}\\\\) \\n\\nViscosity (nonwetting) \\\\(\\\\mu_{nw}\\\\) 1.0 \\\\(kg \\\\cdot m^{-1} \\\\cdot sec^{-1}\\\\) \\n\\nStabilization exponent \\\\(\\\\alpha\\\\) 1.0 - \\n\\nStabilization constant \\\\(\\\\beta\\\\) 2D: 0.3; 3D: 0.27 - \\n\\nNormalization constant \\\\(c_R\\\\) 1.0 - \\n\\nNumber of high-permeability regions \\\\(N\\\\) 50; 200 - \\n\\nOperator splitting threshold \\\\(\\\\theta^\\\\ast\\\\) 5.0 -  \\n\\nA note on the implementation\\nWe have mentioned many areas above in which this program improves over the step-20 and step-21 programs upon which it is based. It also uses the Trilinos interfaces for its vectors and matrices; this specifically has the advantage that we can use an excellent implementation of the Incomplete Cholesky method we use as preconditioners for both the top left and bottom right blocks of the \\\\(2\\\\times 2\\\\) matrix that describes the flow portion of the coupled problem.\\nWe note that while we use the TrilinosWrappers::MPI::BlockVector class to store vectors, the program does not actually use MPI (or any other way to run in parallel): There is no non-MPI vector class in the TrilinosWrappers namespace, but we can use the MPI version to also run a sequential code as we do here.\\n The commented program\\n Include files\\nThe first step, as always, is to include the functionality of a number of deal.II and C++ header files.\\nThe list includes some header files that provide vector, matrix, and preconditioner classes that implement interfaces to the respective Trilinos classes; some more information on these may be found in step-31.\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/utilities.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/base/tensor_function.h>\\n\\u00a0 #include <deal.II/base/index_set.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/solver_gmres.h>\\n\\u00a0 #include <deal.II/lac/solver_cg.h>\\n\\u00a0 #include <deal.II/lac/block_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_renumbering.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_system.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/solution_transfer.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/trilinos_sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/trilinos_block_sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/trilinos_vector.h>\\n\\u00a0 #include <deal.II/lac/trilinos_parallel_block_vector.h>\\n\\u00a0 #include <deal.II/lac/trilinos_precondition.h>\\n\\u00a0 \\n\\u00a0 #include <iostream>\\n\\u00a0 #include <fstream>\\n\\u00a0 #include <memory>\\n\\u00a0 \\n\\u00a0 \\nAt the end of this top-matter, we open a namespace for the current project into which all the following material will go, and then import all deal.II names into this namespace:\\n\\u00a0 namespace Step43\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n Boundary and initial value classes\\nThe following part is taken directly from step-21 so there is no need to repeat the descriptions found there.\\n\\u00a0   template <int dim>\\n\\u00a0   class PressureBoundaryValues : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     PressureBoundaryValues()\\n\\u00a0       : Function<dim>(1)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component = 0) const override;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double\\n\\u00a0   PressureBoundaryValues<dim>::value(const Point<dim> &p,\\n\\u00a0                                      const unsigned int /*component*/) const\\n\\u00a0   {\\n\\u00a0     return 1 - p[0];\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   class SaturationBoundaryValues : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     SaturationBoundaryValues()\\n\\u00a0       : Function<dim>(1)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component = 0) const override;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double\\n\\u00a0   SaturationBoundaryValues<dim>::value(const Point<dim> &p,\\n\\u00a0                                        const unsigned int /*component*/) const\\n\\u00a0   {\\n\\u00a0     if (p[0] == 0)\\n\\u00a0       return 1;\\n\\u00a0     else\\n\\u00a0       return 0;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   class SaturationInitialValues : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     SaturationInitialValues()\\n\\u00a0       : Function<dim>(1)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component = 0) const override;\\n\\u00a0 \\n\\u00a0     virtual void vector_value(const Point<dim> &p,\\n\\u00a0                               Vector<double>   &value) const override;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double\\n\\u00a0   SaturationInitialValues<dim>::value(const Point<dim> & /*p*/,\\n\\u00a0                                       const unsigned int /*component*/) const\\n\\u00a0   {\\n\\u00a0     return 0.2;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void SaturationInitialValues<dim>::vector_value(const Point<dim> &p,\\n\\u00a0                                                   Vector<double> &values) const\\n\\u00a0   {\\n\\u00a0     for (unsigned int c = 0; c < this->n_components; ++c)\\n\\u00a0       values(c) = SaturationInitialValues<dim>::value(p, c);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nFunctionDefinition function.h:152\\nFunction::valuevirtual RangeNumberType value(const Point< dim > &p, const unsigned int component=0) const\\nFunction::vector_valuevirtual void vector_value(const Point< dim > &p, Vector< RangeNumberType > &values) const\\nPointDefinition point.h:111\\nVectorDefinition vector.h:120\\n Permeability models\\nIn this tutorial, we still use the two permeability models previously used in step-21 so we again refrain from commenting in detail about them.\\n\\u00a0   namespace SingleCurvingCrack\\n\\u00a0   {\\n\\u00a0     template <int dim>\\n\\u00a0     class KInverse : public TensorFunction<2, dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       KInverse()\\n\\u00a0         : TensorFunction<2, dim>()\\n\\u00a0       {}\\n\\u00a0 \\n\\u00a0       virtual void\\n\\u00a0       value_list(const std::vector<Point<dim>> &points,\\n\\u00a0                  std::vector<Tensor<2, dim>>   &values) const override;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void KInverse<dim>::value_list(const std::vector<Point<dim>> &points,\\n\\u00a0                                    std::vector<Tensor<2, dim>>   &values) const\\n\\u00a0     {\\n\\u00a0       AssertDimension(points.size(), values.size());\\n\\u00a0 \\n\\u00a0       for (unsigned int p = 0; p < points.size(); ++p)\\n\\u00a0         {\\n\\u00a0           values[p].clear();\\n\\u00a0 \\n\\u00a0           const double distance_to_flowline =\\n\\u00a0             std::fabs(points[p][1] - 0.5 - 0.1 * std::sin(10 * points[p][0]));\\n\\u00a0 \\n\\u00a0           const double permeability =\\n\\u00a0             std::max(std::exp(-(distance_to_flowline * distance_to_flowline) /\\n\\u00a0                               (0.1 * 0.1)),\\n\\u00a0                      0.01);\\n\\u00a0 \\n\\u00a0           for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0             values[p][d][d] = 1. / permeability;\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0   } // namespace SingleCurvingCrack\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   namespace RandomMedium\\n\\u00a0   {\\n\\u00a0     template <int dim>\\n\\u00a0     class KInverse : public TensorFunction<2, dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       KInverse()\\n\\u00a0         : TensorFunction<2, dim>()\\n\\u00a0       {}\\n\\u00a0 \\n\\u00a0       virtual void\\n\\u00a0       value_list(const std::vector<Point<dim>> &points,\\n\\u00a0                  std::vector<Tensor<2, dim>>   &values) const override;\\n\\u00a0 \\n\\u00a0     private:\\n\\u00a0       static std::vector<Point<dim>> centers;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     std::vector<Point<dim>> KInverse<dim>::centers = []() {\\n\\u00a0       const unsigned int N =\\n\\u00a0         (dim == 2 ? 40 : (dim == 3 ? 100 : throw ExcNotImplemented()));\\n\\u00a0 \\n\\u00a0       std::vector<Point<dim>> centers_list(N);\\n\\u00a0       for (unsigned int i = 0; i < N; ++i)\\n\\u00a0         for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0           centers_list[i][d] = static_cast<double>(rand()) / RAND_MAX;\\n\\u00a0 \\n\\u00a0       return centers_list;\\n\\u00a0     }();\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void KInverse<dim>::value_list(const std::vector<Point<dim>> &points,\\n\\u00a0                                    std::vector<Tensor<2, dim>>   &values) const\\n\\u00a0     {\\n\\u00a0       AssertDimension(points.size(), values.size());\\n\\u00a0 \\n\\u00a0       for (unsigned int p = 0; p < points.size(); ++p)\\n\\u00a0         {\\n\\u00a0           values[p].clear();\\n\\u00a0 \\n\\u00a0           double permeability = 0;\\n\\u00a0           for (unsigned int i = 0; i < centers.size(); ++i)\\n\\u00a0             permeability +=\\n\\u00a0               std::exp(-(points[p] - centers[i]).norm_square() / (0.05 * 0.05));\\n\\u00a0 \\n\\u00a0           const double normalized_permeability =\\n\\u00a0             std::min(std::max(permeability, 0.01), 4.);\\n\\u00a0 \\n\\u00a0           for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0             values[p][d][d] = 1. / normalized_permeability;\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0   } // namespace RandomMedium\\n\\u00a0 \\n\\u00a0 \\nTensorFunctionDefinition tensor_function.h:58\\nTensorDefinition tensor.h:471\\nAssertDimension#define AssertDimension(dim1, dim2)Definition exceptions.h:1985\\nPhysics::Elasticity::Kinematics::dSymmetricTensor< 2, dim, Number > d(const Tensor< 2, dim, Number > &F, const Tensor< 2, dim, Number > &dF_dt)\\nstd::exp::VectorizedArray< Number, width > exp(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6829\\nstd::min::VectorizedArray< Number, width > min(const ::VectorizedArray< Number, width > &, const ::VectorizedArray< Number, width > &)Definition vectorization.h:6960\\nstd::max::VectorizedArray< Number, width > max(const ::VectorizedArray< Number, width > &, const ::VectorizedArray< Number, width > &)Definition vectorization.h:6943\\nstd::sin::VectorizedArray< Number, width > sin(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6589\\n Physical quantities\\nThe implementations of all the physical quantities such as total mobility \\\\(\\\\lambda_t\\\\) and fractional flow of water \\\\(F\\\\) are taken from step-21 so again we don't have do any comment about them. Compared to step-21 we have added checks that the saturation passed to these functions is in fact within the physically valid range. Furthermore, given that the wetting phase moves at speed \\\\(\\\\mathbf u F'(S)\\\\) it is clear that \\\\(F'(S)\\\\) must be greater or equal to zero, so we assert that as well to make sure that our calculations to get at the formula for the derivative made sense.\\n\\u00a0   double mobility_inverse(const double S, const double viscosity)\\n\\u00a0   {\\n\\u00a0     return 1.0 / (1.0 / viscosity * S * S + (1 - S) * (1 - S));\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   double fractional_flow(const double S, const double viscosity)\\n\\u00a0   {\\n\\u00a0     Assert((S >= 0) && (S <= 1),\\n\\u00a0            ExcMessage(\\\"Saturation is outside its physically valid range.\\\"));\\n\\u00a0 \\n\\u00a0     return S * S / (S * S + viscosity * (1 - S) * (1 - S));\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   double fractional_flow_derivative(const double S, const double viscosity)\\n\\u00a0   {\\n\\u00a0     Assert((S >= 0) && (S <= 1),\\n\\u00a0            ExcMessage(\\\"Saturation is outside its physically valid range.\\\"));\\n\\u00a0 \\n\\u00a0     const double temp = (S * S + viscosity * (1 - S) * (1 - S));\\n\\u00a0 \\n\\u00a0     const double numerator =\\n\\u00a0       2.0 * S * temp - S * S * (2.0 * S - 2.0 * viscosity * (1 - S));\\n\\u00a0     const double denominator = Utilities::fixed_power<2>(temp);\\n\\u00a0 \\n\\u00a0     const double F_prime = numerator / denominator;\\n\\u00a0 \\n\\u00a0     Assert(F_prime >= 0, ExcInternalError());\\n\\u00a0 \\n\\u00a0     return F_prime;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\nUtilities::fixed_powerconstexpr T fixed_power(const T t)Definition utilities.h:942\\n Helper classes for solvers and preconditioners\\nIn this first part we define a number of classes that we need in the construction of linear solvers and preconditioners. This part is essentially the same as that used in step-31. The only difference is that the original variable name stokes_matrix is replaced by another name darcy_matrix to match our problem.\\n\\u00a0   namespace LinearSolvers\\n\\u00a0   {\\n\\u00a0     template <class MatrixType, class PreconditionerType>\\n\\u00a0     class InverseMatrix : public Subscriptor\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       InverseMatrix(const MatrixType         &m,\\n\\u00a0                     const PreconditionerType &preconditioner);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0       template <typename VectorType>\\n\\u00a0       void vmult(VectorType &dst, const VectorType &src) const;\\n\\u00a0 \\n\\u00a0     private:\\n\\u00a0       const SmartPointer<const MatrixType> matrix;\\n\\u00a0       const PreconditionerType            &preconditioner;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <class MatrixType, class PreconditionerType>\\n\\u00a0     InverseMatrix<MatrixType, PreconditionerType>::InverseMatrix(\\n\\u00a0       const MatrixType         &m,\\n\\u00a0       const PreconditionerType &preconditioner)\\n\\u00a0       : matrix(&m)\\n\\u00a0       , preconditioner(preconditioner)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <class MatrixType, class PreconditionerType>\\n\\u00a0     template <typename VectorType>\\n\\u00a0     void InverseMatrix<MatrixType, PreconditionerType>::vmult(\\n\\u00a0       VectorType       &dst,\\n\\u00a0       const VectorType &src) const\\n\\u00a0     {\\n\\u00a0       SolverControl        solver_control(src.size(), 1e-7 * src.l2_norm());\\n\\u00a0       SolverCG<VectorType> cg(solver_control);\\n\\u00a0 \\n\\u00a0       dst = 0;\\n\\u00a0 \\n\\u00a0       try\\n\\u00a0         {\\n\\u00a0           cg.solve(*matrix, dst, src, preconditioner);\\n\\u00a0         }\\n\\u00a0       catch (std::exception &e)\\n\\u00a0         {\\n\\u00a0           Assert(false, ExcMessage(e.what()));\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     template <class PreconditionerTypeA, class PreconditionerTypeMp>\\n\\u00a0     class BlockSchurPreconditioner : public Subscriptor\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       BlockSchurPreconditioner(\\n\\u00a0         const TrilinosWrappers::BlockSparseMatrix &S,\\n\\u00a0         const InverseMatrix<TrilinosWrappers::SparseMatrix,\\n\\u00a0                             PreconditionerTypeMp> &Mpinv,\\n\\u00a0         const PreconditionerTypeA                 &Apreconditioner);\\n\\u00a0 \\n\\u00a0       void vmult(TrilinosWrappers::MPI::BlockVector       &dst,\\n\\u00a0                  const TrilinosWrappers::MPI::BlockVector &src) const;\\n\\u00a0 \\n\\u00a0     private:\\n\\u00a0       const SmartPointer<const TrilinosWrappers::BlockSparseMatrix>\\n\\u00a0         darcy_matrix;\\n\\u00a0       const SmartPointer<const InverseMatrix<TrilinosWrappers::SparseMatrix,\\n\\u00a0                                              PreconditionerTypeMp>>\\n\\u00a0                                  m_inverse;\\n\\u00a0       const PreconditionerTypeA &a_preconditioner;\\n\\u00a0 \\n\\u00a0       mutable TrilinosWrappers::MPI::Vector tmp;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <class PreconditionerTypeA, class PreconditionerTypeMp>\\n\\u00a0     BlockSchurPreconditioner<PreconditionerTypeA, PreconditionerTypeMp>::\\n\\u00a0       BlockSchurPreconditioner(\\n\\u00a0         const TrilinosWrappers::BlockSparseMatrix &S,\\n\\u00a0         const InverseMatrix<TrilinosWrappers::SparseMatrix,\\n\\u00a0                             PreconditionerTypeMp> &Mpinv,\\n\\u00a0         const PreconditionerTypeA                 &Apreconditioner)\\n\\u00a0       : darcy_matrix(&S)\\n\\u00a0       , m_inverse(&Mpinv)\\n\\u00a0       , a_preconditioner(Apreconditioner)\\n\\u00a0       , tmp(complete_index_set(darcy_matrix->block(1, 1).m()))\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <class PreconditionerTypeA, class PreconditionerTypeMp>\\n\\u00a0     void\\n\\u00a0     BlockSchurPreconditioner<PreconditionerTypeA, PreconditionerTypeMp>::vmult(\\n\\u00a0       TrilinosWrappers::MPI::BlockVector       &dst,\\n\\u00a0       const TrilinosWrappers::MPI::BlockVector &src) const\\n\\u00a0     {\\n\\u00a0       a_preconditioner.vmult(dst.block(0), src.block(0));\\n\\u00a0       darcy_matrix->block(1, 0).residual(tmp, dst.block(0), src.block(1));\\n\\u00a0       tmp *= -1;\\n\\u00a0       m_inverse->vmult(dst.block(1), tmp);\\n\\u00a0     }\\n\\u00a0   } // namespace LinearSolvers\\n\\u00a0 \\n\\u00a0 \\nBlockVectorDefinition block_vector.h:71\\nSmartPointerDefinition smartpointer.h:93\\nSolverCGDefinition solver_cg.h:179\\nSolverControlDefinition solver_control.h:67\\nSubscriptorDefinition subscriptor.h:60\\nTrilinosWrappers::BlockSparseMatrixDefinition trilinos_block_sparse_matrix.h:72\\nTrilinosWrappers::MPI::BlockVectorDefinition trilinos_parallel_block_vector.h:75\\nTrilinosWrappers::MPI::VectorDefinition trilinos_vector.h:405\\nTrilinosWrappers::SparseMatrixDefinition trilinos_sparse_matrix.h:550\\ncomplete_index_setIndexSet complete_index_set(const IndexSet::size_type N)Definition index_set.h:1204\\nInitializeLibrary::MPI@ MPI\\nPhysics::Elasticity::Kinematics::eSymmetricTensor< 2, dim, Number > e(const Tensor< 2, dim, Number > &F)\\nTrilinosWrappersDefinition template_constraints.h:652\\n The TwoPhaseFlowProblem class\\nThe definition of the class that defines the top-level logic of solving the time-dependent advection-dominated two-phase flow problem (or Buckley-Leverett problem [48]) is mainly based on tutorial programs step-21 and step-33, and in particular on step-31 where we have used basically the same general structure as done here. As in step-31, the key routines to look for in the implementation below are the run() and solve() functions.\\nThe main difference to step-31 is that, since adaptive operator splitting is considered, we need a couple more member variables to hold the last two computed Darcy (velocity/pressure) solutions in addition to the current one (which is either computed directly, or extrapolated from the previous two), and we need to remember the last two times we computed the Darcy solution. We also need a helper function that figures out whether we do indeed need to recompute the Darcy solution.\\nUnlike step-31, this step uses one more AffineConstraints object called darcy_preconditioner_constraints. This constraint object is used only for assembling the matrix for the Darcy preconditioner and includes hanging node constraints as well as Dirichlet boundary value constraints for the pressure variable. We need this because we are building a Laplace matrix for the pressure as an approximation of the Schur complement) which is only positive definite if boundary conditions are applied.\\nThe collection of member functions and variables thus declared in this class is then rather similar to those in step-31:\\n\\u00a0   template <int dim>\\n\\u00a0   class TwoPhaseFlowProblem\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     TwoPhaseFlowProblem(const unsigned int degree);\\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void setup_dofs();\\n\\u00a0     void assemble_darcy_preconditioner();\\n\\u00a0     void build_darcy_preconditioner();\\n\\u00a0     void assemble_darcy_system();\\n\\u00a0     void assemble_saturation_system();\\n\\u00a0     void assemble_saturation_matrix();\\n\\u00a0     void assemble_saturation_rhs();\\n\\u00a0     void assemble_saturation_rhs_cell_term(\\n\\u00a0       const FEValues<dim>                        &saturation_fe_values,\\n\\u00a0       const FEValues<dim>                        &darcy_fe_values,\\n\\u00a0       const double                                global_max_u_F_prime,\\n\\u00a0       const double                                global_S_variation,\\n\\u00a0       const std::vector<types::global_dof_index> &local_dof_indices);\\n\\u00a0     void assemble_saturation_rhs_boundary_term(\\n\\u00a0       const FEFaceValues<dim>                    &saturation_fe_face_values,\\n\\u00a0       const FEFaceValues<dim>                    &darcy_fe_face_values,\\n\\u00a0       const std::vector<types::global_dof_index> &local_dof_indices);\\n\\u00a0     void solve();\\n\\u00a0     void refine_mesh(const unsigned int min_grid_level,\\n\\u00a0                      const unsigned int max_grid_level);\\n\\u00a0     void output_results() const;\\n\\u00a0 \\nFEFaceValuesDefinition fe_values.h:322\\nFEValuesDefinition fe_values.h:63\\nWe follow with a number of helper functions that are used in a variety of places throughout the program:\\n\\u00a0     double                    get_max_u_F_prime() const;\\n\\u00a0     std::pair<double, double> get_extrapolated_saturation_range() const;\\n\\u00a0     bool   determine_whether_to_solve_for_pressure_and_velocity() const;\\n\\u00a0     void   project_back_saturation();\\n\\u00a0     double compute_viscosity(\\n\\u00a0       const std::vector<double>         &old_saturation,\\n\\u00a0       const std::vector<double>         &old_old_saturation,\\n\\u00a0       const std::vector<Tensor<1, dim>> &old_saturation_grads,\\n\\u00a0       const std::vector<Tensor<1, dim>> &old_old_saturation_grads,\\n\\u00a0       const std::vector<Vector<double>> &present_darcy_values,\\n\\u00a0       const double                       global_max_u_F_prime,\\n\\u00a0       const double                       global_S_variation,\\n\\u00a0       const double                       cell_diameter) const;\\n\\u00a0 \\n\\u00a0 \\nThis all is followed by the member variables, most of which are similar to the ones in step-31, with the exception of the ones that pertain to the macro time stepping for the velocity/pressure system:\\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0     double             global_Omega_diameter;\\n\\u00a0 \\n\\u00a0     const unsigned int degree;\\n\\u00a0 \\n\\u00a0     const unsigned int        darcy_degree;\\n\\u00a0     const FESystem<dim>       darcy_fe;\\n\\u00a0     DoFHandler<dim>           darcy_dof_handler;\\n\\u00a0     AffineConstraints<double> darcy_constraints;\\n\\u00a0 \\n\\u00a0     AffineConstraints<double> darcy_preconditioner_constraints;\\n\\u00a0 \\n\\u00a0     TrilinosWrappers::BlockSparseMatrix darcy_matrix;\\n\\u00a0     TrilinosWrappers::BlockSparseMatrix darcy_preconditioner_matrix;\\n\\u00a0 \\n\\u00a0     TrilinosWrappers::MPI::BlockVector darcy_solution;\\n\\u00a0     TrilinosWrappers::MPI::BlockVector darcy_rhs;\\n\\u00a0 \\n\\u00a0     TrilinosWrappers::MPI::BlockVector last_computed_darcy_solution;\\n\\u00a0     TrilinosWrappers::MPI::BlockVector second_last_computed_darcy_solution;\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     const unsigned int        saturation_degree;\\n\\u00a0     const FE_Q<dim>           saturation_fe;\\n\\u00a0     DoFHandler<dim>           saturation_dof_handler;\\n\\u00a0     AffineConstraints<double> saturation_constraints;\\n\\u00a0 \\n\\u00a0     TrilinosWrappers::SparseMatrix saturation_matrix;\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     TrilinosWrappers::MPI::Vector saturation_solution;\\n\\u00a0     TrilinosWrappers::MPI::Vector old_saturation_solution;\\n\\u00a0     TrilinosWrappers::MPI::Vector old_old_saturation_solution;\\n\\u00a0     TrilinosWrappers::MPI::Vector saturation_rhs;\\n\\u00a0 \\n\\u00a0     TrilinosWrappers::MPI::Vector\\n\\u00a0       saturation_matching_last_computed_darcy_solution;\\n\\u00a0 \\n\\u00a0     const double saturation_refinement_threshold;\\n\\u00a0 \\n\\u00a0     double       time;\\n\\u00a0     const double end_time;\\n\\u00a0 \\n\\u00a0     double current_macro_time_step;\\n\\u00a0     double old_macro_time_step;\\n\\u00a0 \\n\\u00a0     double       time_step;\\n\\u00a0     double       old_time_step;\\n\\u00a0     unsigned int timestep_number;\\n\\u00a0 \\n\\u00a0     const double viscosity;\\n\\u00a0     const double porosity;\\n\\u00a0     const double AOS_threshold;\\n\\u00a0 \\n\\u00a0     std::shared_ptr<TrilinosWrappers::PreconditionIC> top_left_preconditioner;\\n\\u00a0     std::shared_ptr<TrilinosWrappers::PreconditionIC>\\n\\u00a0       bottom_right_preconditioner;\\n\\u00a0 \\n\\u00a0     bool rebuild_saturation_matrix;\\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nDoFHandlerDefinition dof_handler.h:317\\nFESystemDefinition fe_system.h:208\\nFE_QDefinition fe_q.h:554\\nTriangulationDefinition tria.h:1323\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\nAt the very end we declare a variable that denotes the material model. Compared to step-21, we do this here as a member variable since we will want to use it in a variety of places and so having a central place where such a variable is declared will make it simpler to replace one class by another (e.g. replace RandomMedium::KInverse by SingleCurvingCrack::KInverse).\\n\\u00a0     const RandomMedium::KInverse<dim> k_inverse;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n TwoPhaseFlowProblem<dim>::TwoPhaseFlowProblem\\nThe constructor of this class is an extension of the constructors in step-21 and step-31. We need to add the various variables that concern the saturation. As discussed in the introduction, we are going to use \\\\(Q_2 \\\\times Q_1\\\\) (Taylor-Hood) elements again for the Darcy system, an element combination that fulfills the Ladyzhenskaya-Babuska-Brezzi (LBB) conditions [Brezzi and Fortin 1991, Chen 2005], and \\\\(Q_1\\\\) elements for the saturation. However, by using variables that store the polynomial degree of the Darcy and temperature finite elements, it is easy to consistently modify the degree of the elements as well as all quadrature formulas used on them downstream. Moreover, we initialize the time stepping variables related to operator splitting as well as the option for matrix assembly and preconditioning:\\n\\u00a0   template <int dim>\\n\\u00a0   TwoPhaseFlowProblem<dim>::TwoPhaseFlowProblem(const unsigned int degree)\\n\\u00a0     : triangulation(Triangulation<dim>::maximum_smoothing)\\n\\u00a0     , global_Omega_diameter(std::numeric_limits<double>::quiet_NaN())\\n\\u00a0     , degree(degree)\\n\\u00a0     , darcy_degree(degree)\\n\\u00a0     , darcy_fe(FE_Q<dim>(darcy_degree + 1) ^ dim, FE_Q<dim>(darcy_degree))\\n\\u00a0     , darcy_dof_handler(triangulation)\\n\\u00a0     ,\\n\\u00a0 \\n\\u00a0     saturation_degree(degree + 1)\\n\\u00a0     , saturation_fe(saturation_degree)\\n\\u00a0     , saturation_dof_handler(triangulation)\\n\\u00a0     ,\\n\\u00a0 \\n\\u00a0     saturation_refinement_threshold(0.5)\\n\\u00a0     ,\\n\\u00a0 \\n\\u00a0     time(0)\\n\\u00a0     , end_time(10)\\n\\u00a0     ,\\n\\u00a0 \\n\\u00a0     current_macro_time_step(0)\\n\\u00a0     , old_macro_time_step(0)\\n\\u00a0     ,\\n\\u00a0 \\n\\u00a0     time_step(0)\\n\\u00a0     , old_time_step(0)\\n\\u00a0     , timestep_number(0)\\n\\u00a0     , viscosity(0.2)\\n\\u00a0     , porosity(1.0)\\n\\u00a0     , AOS_threshold(3.0)\\n\\u00a0     ,\\n\\u00a0 \\n\\u00a0     rebuild_saturation_matrix(true)\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\nstdSTL namespace.\\n TwoPhaseFlowProblem<dim>::setup_dofs\\nThis is the function that sets up the DoFHandler objects we have here (one for the Darcy part and one for the saturation part) as well as set to the right sizes the various objects required for the linear algebra in this program. Its basic operations are similar to what step-31 did.\\nThe body of the function first enumerates all degrees of freedom for the Darcy and saturation systems. For the Darcy part, degrees of freedom are then sorted to ensure that velocities precede pressure DoFs so that we can partition the Darcy matrix into a \\\\(2 \\\\times 2\\\\) matrix.\\nThen, we need to incorporate hanging node constraints and Dirichlet boundary value constraints into darcy_preconditioner_constraints. The boundary condition constraints are only set on the pressure component since the Schur complement preconditioner that corresponds to the porous media flow operator in non-mixed form,  \\\\(-\\\\nabla \\\\cdot [\\\\mathbf K\\n   \\\\lambda_t(S)]\\\\nabla\\\\), acts only on the pressure variable. Therefore, we use a component_mask that filters out the velocity component, so that the condensation is performed on pressure degrees of freedom only.\\nAfter having done so, we count the number of degrees of freedom in the various blocks. This information is then used to create the sparsity pattern for the Darcy and saturation system matrices as well as the preconditioner matrix from which we build the Darcy preconditioner. As in step-31, we choose to create the pattern using the blocked version of DynamicSparsityPattern. So, for this, we follow the same way as step-31 did and we don't have to repeat descriptions again for the rest of the member function.\\n\\u00a0   template <int dim>\\n\\u00a0   void TwoPhaseFlowProblem<dim>::setup_dofs()\\n\\u00a0   {\\n\\u00a0     std::vector<unsigned int> darcy_block_component(dim + 1, 0);\\n\\u00a0     darcy_block_component[dim] = 1;\\n\\u00a0     {\\n\\u00a0       darcy_dof_handler.distribute_dofs(darcy_fe);\\n\\u00a0       DoFRenumbering::Cuthill_McKee(darcy_dof_handler);\\n\\u00a0       DoFRenumbering::component_wise(darcy_dof_handler, darcy_block_component);\\n\\u00a0 \\n\\u00a0       darcy_constraints.clear();\\n\\u00a0       DoFTools::make_hanging_node_constraints(darcy_dof_handler,\\n\\u00a0                                               darcy_constraints);\\n\\u00a0       darcy_constraints.close();\\n\\u00a0     }\\n\\u00a0     {\\n\\u00a0       saturation_dof_handler.distribute_dofs(saturation_fe);\\n\\u00a0 \\n\\u00a0       saturation_constraints.clear();\\n\\u00a0       DoFTools::make_hanging_node_constraints(saturation_dof_handler,\\n\\u00a0                                               saturation_constraints);\\n\\u00a0       saturation_constraints.close();\\n\\u00a0     }\\n\\u00a0     {\\n\\u00a0       darcy_preconditioner_constraints.clear();\\n\\u00a0 \\n\\u00a0       const FEValuesExtractors::Scalar pressure(dim);\\n\\u00a0 \\n\\u00a0       DoFTools::make_hanging_node_constraints(darcy_dof_handler,\\n\\u00a0                                               darcy_preconditioner_constraints);\\n\\u00a0       DoFTools::make_zero_boundary_constraints(darcy_dof_handler,\\n\\u00a0                                                darcy_preconditioner_constraints,\\n\\u00a0                                                darcy_fe.component_mask(\\n\\u00a0                                                  pressure));\\n\\u00a0 \\n\\u00a0       darcy_preconditioner_constraints.close();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     const std::vector<types::global_dof_index> darcy_dofs_per_block =\\n\\u00a0       DoFTools::count_dofs_per_fe_block(darcy_dof_handler,\\n\\u00a0                                         darcy_block_component);\\n\\u00a0     const types::global_dof_index n_u = darcy_dofs_per_block[0],\\n\\u00a0                                   n_p = darcy_dofs_per_block[1],\\n\\u00a0                                   n_s = saturation_dof_handler.n_dofs();\\n\\u00a0 \\n\\u00a0     std::cout << \\\"Number of active cells: \\\" << triangulation.n_active_cells()\\n\\u00a0               << \\\" (on \\\" << triangulation.n_levels() << \\\" levels)\\\" << std::endl\\n\\u00a0               << \\\"Number of degrees of freedom: \\\" << n_u + n_p + n_s << \\\" (\\\"\\n\\u00a0               << n_u << '+' << n_p << '+' << n_s << ')' << std::endl\\n\\u00a0               << std::endl;\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       darcy_matrix.clear();\\n\\u00a0 \\n\\u00a0       BlockDynamicSparsityPattern dsp(darcy_dofs_per_block,\\n\\u00a0                                       darcy_dofs_per_block);\\n\\u00a0 \\n\\u00a0       Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);\\n\\u00a0       for (unsigned int c = 0; c < dim + 1; ++c)\\n\\u00a0         for (unsigned int d = 0; d < dim + 1; ++d)\\n\\u00a0           if (!((c == dim) && (d == dim)))\\n\\u00a0             coupling[c][d] = DoFTools::always;\\n\\u00a0           else\\n\\u00a0             coupling[c][d] = DoFTools::none;\\n\\u00a0 \\n\\u00a0 \\n\\u00a0       DoFTools::make_sparsity_pattern(\\n\\u00a0         darcy_dof_handler, coupling, dsp, darcy_constraints, false);\\n\\u00a0 \\n\\u00a0       darcy_matrix.reinit(dsp);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       top_left_preconditioner.reset();\\n\\u00a0       bottom_right_preconditioner.reset();\\n\\u00a0       darcy_preconditioner_matrix.clear();\\n\\u00a0 \\n\\u00a0       BlockDynamicSparsityPattern dsp(darcy_dofs_per_block,\\n\\u00a0                                       darcy_dofs_per_block);\\n\\u00a0 \\n\\u00a0       Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);\\n\\u00a0       for (unsigned int c = 0; c < dim + 1; ++c)\\n\\u00a0         for (unsigned int d = 0; d < dim + 1; ++d)\\n\\u00a0           if (c == d)\\n\\u00a0             coupling[c][d] = DoFTools::always;\\n\\u00a0           else\\n\\u00a0             coupling[c][d] = DoFTools::none;\\n\\u00a0 \\n\\u00a0       DoFTools::make_sparsity_pattern(\\n\\u00a0         darcy_dof_handler, coupling, dsp, darcy_constraints, false);\\n\\u00a0 \\n\\u00a0       darcy_preconditioner_matrix.reinit(dsp);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       saturation_matrix.clear();\\n\\u00a0 \\n\\u00a0       DynamicSparsityPattern dsp(n_s, n_s);\\n\\u00a0 \\n\\u00a0       DoFTools::make_sparsity_pattern(saturation_dof_handler,\\n\\u00a0                                       dsp,\\n\\u00a0                                       saturation_constraints,\\n\\u00a0                                       false);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0       saturation_matrix.reinit(dsp);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     const std::vector<IndexSet> darcy_partitioning = {complete_index_set(n_u),\\n\\u00a0                                                       complete_index_set(n_p)};\\n\\u00a0 \\n\\u00a0     darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD);\\n\\u00a0 \\n\\u00a0     last_computed_darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD);\\n\\u00a0 \\n\\u00a0     second_last_computed_darcy_solution.reinit(darcy_partitioning,\\n\\u00a0                                                MPI_COMM_WORLD);\\n\\u00a0 \\n\\u00a0     darcy_rhs.reinit(darcy_partitioning, MPI_COMM_WORLD);\\n\\u00a0 \\n\\u00a0     const IndexSet saturation_partitioning = complete_index_set(n_s);\\n\\u00a0     saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);\\n\\u00a0     old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);\\n\\u00a0     old_old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);\\n\\u00a0 \\n\\u00a0     saturation_matching_last_computed_darcy_solution.reinit(\\n\\u00a0       saturation_partitioning, MPI_COMM_WORLD);\\n\\u00a0 \\n\\u00a0     saturation_rhs.reinit(saturation_partitioning, MPI_COMM_WORLD);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nBlockDynamicSparsityPatternDefinition block_sparsity_pattern.h:549\\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nIndexSetDefinition index_set.h:70\\nTableDefinition array_view.h:39\\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nTriangulation::n_levelsunsigned int n_levels() const\\nunsigned int\\nDoFTools::make_hanging_node_constraintsvoid make_hanging_node_constraints(const DoFHandler< dim, spacedim > &dof_handler, AffineConstraints< number > &constraints)Definition dof_tools_constraints.cc:3073\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nDoFTools::make_zero_boundary_constraintsvoid make_zero_boundary_constraints(const DoFHandler< dim, spacedim > &dof, const types::boundary_id boundary_id, AffineConstraints< number > &zero_boundary_constraints, const ComponentMask &component_mask={})Definition dof_tools_constraints.cc:4712\\nDoFRenumbering::component_wisevoid component_wise(DoFHandler< dim, spacedim > &dof_handler, const std::vector< unsigned int > &target_component=std::vector< unsigned int >())Definition dof_renumbering.cc:666\\nDoFRenumbering::Cuthill_McKeevoid Cuthill_McKee(DoFHandler< dim, spacedim > &dof_handler, const bool reversed_numbering=false, const bool use_constraints=false, const std::vector< types::global_dof_index > &starting_indices=std::vector< types::global_dof_index >())Definition dof_renumbering.cc:366\\nDoFTools::count_dofs_per_fe_blockstd::vector< types::global_dof_index > count_dofs_per_fe_block(const DoFHandler< dim, spacedim > &dof, const std::vector< unsigned int > &target_block=std::vector< unsigned int >())Definition dof_tools.cc:2104\\nDoFTools::none@ noneDefinition dof_tools.h:243\\nDoFTools::always@ alwaysDefinition dof_tools.h:247\\nFEValuesExtractors::ScalarDefinition fe_values_extractors.h:95\\n Assembling matrices and preconditioners\\nThe next few functions are devoted to setting up the various system and preconditioner matrices and right hand sides that we have to deal with in this program.\\n TwoPhaseFlowProblem<dim>::assemble_darcy_preconditioner\\nThis function assembles the matrix we use for preconditioning the Darcy system. What we need are a vector mass matrix weighted by \\\\(\\\\left(\\\\mathbf{K} \\\\lambda_t\\\\right)^{-1}\\\\) on the velocity components and a mass matrix weighted by \\\\(\\\\left(\\\\mathbf{K} \\\\lambda_t\\\\right)\\\\) on the pressure component. We start by generating a quadrature object of appropriate order, the FEValues object that can give values and gradients at the quadrature points (together with quadrature weights). Next we create data structures for the cell matrix and the relation between local and global DoFs. The vectors phi_u and grad_phi_p are going to hold the values of the basis functions in order to faster build up the local matrices, as was already done in step-22. Before we start the loop over all active cells, we have to specify which components are pressure and which are velocity.\\nThe creation of the local matrix is rather simple. There are only a term weighted by \\\\(\\\\left(\\\\mathbf{K} \\\\lambda_t\\\\right)^{-1}\\\\) (on the velocity) and a Laplace matrix weighted by \\\\(\\\\left(\\\\mathbf{K} \\\\lambda_t\\\\right)\\\\) to be generated, so the creation of the local matrix is done in essentially two lines. Since the material model functions at the top of this file only provide the inverses of the permeability and mobility, we have to compute \\\\(\\\\mathbf K\\\\) and \\\\(\\\\lambda_t\\\\) by hand from the given values, once per quadrature point.\\nOnce the local matrix is ready (loop over rows and columns in the local matrix on each quadrature point), we get the local DoF indices and write the local information into the global matrix. We do this by directly applying the constraints (i.e. darcy_preconditioner_constraints) that takes care of hanging node and zero Dirichlet boundary condition constraints. By doing so, we don't have to do that afterwards, and we later don't have to use AffineConstraints::condense and MatrixTools::apply_boundary_values, both functions that would need to modify matrix and vector entries and so are difficult to write for the Trilinos classes where we don't immediately have access to individual memory locations.\\n\\u00a0   template <int dim>\\n\\u00a0   void TwoPhaseFlowProblem<dim>::assemble_darcy_preconditioner()\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"   Rebuilding darcy preconditioner...\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     darcy_preconditioner_matrix = 0;\\n\\u00a0 \\n\\u00a0     const QGauss<dim> quadrature_formula(darcy_degree + 2);\\n\\u00a0     FEValues<dim>     darcy_fe_values(darcy_fe,\\n\\u00a0                                   quadrature_formula,\\n\\u00a0                                   update_JxW_values | update_values |\\n\\u00a0                                     update_gradients |\\n\\u00a0                                     update_quadrature_points);\\n\\u00a0     FEValues<dim>     saturation_fe_values(saturation_fe,\\n\\u00a0                                        quadrature_formula,\\n\\u00a0                                        update_values);\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell = darcy_fe.n_dofs_per_cell();\\n\\u00a0     const unsigned int n_q_points    = quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     std::vector<Tensor<2, dim>> k_inverse_values(n_q_points);\\n\\u00a0 \\n\\u00a0     std::vector<double> old_saturation_values(n_q_points);\\n\\u00a0 \\n\\u00a0     FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     std::vector<Tensor<1, dim>> phi_u(dofs_per_cell);\\n\\u00a0     std::vector<Tensor<1, dim>> grad_phi_p(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     const FEValuesExtractors::Vector velocities(0);\\n\\u00a0     const FEValuesExtractors::Scalar pressure(dim);\\n\\u00a0 \\n\\u00a0     auto       cell            = darcy_dof_handler.begin_active();\\n\\u00a0     const auto endc            = darcy_dof_handler.end();\\n\\u00a0     auto       saturation_cell = saturation_dof_handler.begin_active();\\n\\u00a0 \\n\\u00a0     for (; cell != endc; ++cell, ++saturation_cell)\\n\\u00a0       {\\n\\u00a0         darcy_fe_values.reinit(cell);\\n\\u00a0         saturation_fe_values.reinit(saturation_cell);\\n\\u00a0 \\n\\u00a0         local_matrix = 0;\\n\\u00a0 \\n\\u00a0         saturation_fe_values.get_function_values(old_saturation_solution,\\n\\u00a0                                                  old_saturation_values);\\n\\u00a0 \\n\\u00a0         k_inverse.value_list(darcy_fe_values.get_quadrature_points(),\\n\\u00a0                              k_inverse_values);\\n\\u00a0 \\n\\u00a0         for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0           {\\n\\u00a0             const double old_s = old_saturation_values[q];\\n\\u00a0 \\n\\u00a0             const double inverse_mobility = mobility_inverse(old_s, viscosity);\\n\\u00a0             const double mobility         = 1.0 / inverse_mobility;\\n\\u00a0             const Tensor<2, dim> permeability = invert(k_inverse_values[q]);\\n\\u00a0 \\n\\u00a0             for (unsigned int k = 0; k < dofs_per_cell; ++k)\\n\\u00a0               {\\n\\u00a0                 phi_u[k]      = darcy_fe_values[velocities].value(k, q);\\n\\u00a0                 grad_phi_p[k] = darcy_fe_values[pressure].gradient(k, q);\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0             for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0               for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0                 {\\n\\u00a0                   local_matrix(i, j) +=\\n\\u00a0                     (k_inverse_values[q] * inverse_mobility * phi_u[i] *\\n\\u00a0                        phi_u[j] +\\n\\u00a0                      permeability * mobility * grad_phi_p[i] * grad_phi_p[j]) *\\n\\u00a0                     darcy_fe_values.JxW(q);\\n\\u00a0                 }\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0         darcy_preconditioner_constraints.distribute_local_to_global(\\n\\u00a0           local_matrix, local_dof_indices, darcy_preconditioner_matrix);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nFullMatrixDefinition full_matrix.h:79\\nQGaussDefinition quadrature_lib.h:40\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nFEValuesExtractors::VectorDefinition fe_values_extractors.h:150\\ninvertDEAL_II_HOST constexpr SymmetricTensor< 2, dim, Number > invert(const SymmetricTensor< 2, dim, Number > &)Definition symmetric_tensor.h:3250\\n TwoPhaseFlowProblem<dim>::build_darcy_preconditioner\\nAfter calling the above functions to assemble the preconditioner matrix, this function generates the inner preconditioners that are going to be used for the Schur complement block preconditioner. The preconditioners need to be regenerated at every saturation time step since they depend on the saturation \\\\(S\\\\) that varies with time.\\nIn here, we set up the preconditioner for the velocity-velocity matrix \\\\(\\\\mathbf{M}^{\\\\mathbf{u}}\\\\) and the Schur complement \\\\(\\\\mathbf{S}\\\\). As explained in the introduction, we are going to use an IC preconditioner based on the vector matrix \\\\(\\\\mathbf{M}^{\\\\mathbf{u}}\\\\) and another based on the scalar Laplace matrix \\\\(\\\\tilde{\\\\mathbf{S}}^p\\\\) (which is spectrally close to the Schur complement of the Darcy matrix). Usually, the TrilinosWrappers::PreconditionIC class can be seen as a good black-box preconditioner which does not need any special knowledge of the matrix structure and/or the operator that's behind it.\\n\\u00a0   template <int dim>\\n\\u00a0   void TwoPhaseFlowProblem<dim>::build_darcy_preconditioner()\\n\\u00a0   {\\n\\u00a0     assemble_darcy_preconditioner();\\n\\u00a0 \\n\\u00a0     top_left_preconditioner =\\n\\u00a0       std::make_shared<TrilinosWrappers::PreconditionIC>();\\n\\u00a0     top_left_preconditioner->initialize(\\n\\u00a0       darcy_preconditioner_matrix.block(0, 0));\\n\\u00a0 \\n\\u00a0     bottom_right_preconditioner =\\n\\u00a0       std::make_shared<TrilinosWrappers::PreconditionIC>();\\n\\u00a0     bottom_right_preconditioner->initialize(\\n\\u00a0       darcy_preconditioner_matrix.block(1, 1));\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n TwoPhaseFlowProblem<dim>::assemble_darcy_system\\nThis is the function that assembles the linear system for the Darcy system.\\nRegarding the technical details of implementation, the procedures are similar to those in step-22 and step-31. We reset matrix and vector, create a quadrature formula on the cells, and then create the respective FEValues object.\\nThere is one thing that needs to be commented: since we have a separate finite element and DoFHandler for the saturation, we need to generate a second FEValues object for the proper evaluation of the saturation solution. This isn't too complicated to realize here: just use the saturation structures and set an update flag for the basis function values which we need for evaluation of the saturation solution. The only important part to remember here is that the same quadrature formula is used for both FEValues objects to ensure that we get matching information when we loop over the quadrature points of the two objects.\\nThe declarations proceed with some shortcuts for array sizes, the creation of the local matrix, right hand side as well as the vector for the indices of the local dofs compared to the global system.\\n\\u00a0   template <int dim>\\n\\u00a0   void TwoPhaseFlowProblem<dim>::assemble_darcy_system()\\n\\u00a0   {\\n\\u00a0     darcy_matrix = 0;\\n\\u00a0     darcy_rhs    = 0;\\n\\u00a0 \\n\\u00a0     const QGauss<dim>     quadrature_formula(darcy_degree + 2);\\n\\u00a0     const QGauss<dim - 1> face_quadrature_formula(darcy_degree + 2);\\n\\u00a0 \\n\\u00a0     FEValues<dim> darcy_fe_values(darcy_fe,\\n\\u00a0                                   quadrature_formula,\\n\\u00a0                                   update_values | update_gradients |\\n\\u00a0                                     update_quadrature_points |\\n\\u00a0                                     update_JxW_values);\\n\\u00a0 \\n\\u00a0     FEValues<dim> saturation_fe_values(saturation_fe,\\n\\u00a0                                        quadrature_formula,\\n\\u00a0                                        update_values);\\n\\u00a0 \\n\\u00a0     FEFaceValues<dim> darcy_fe_face_values(darcy_fe,\\n\\u00a0                                            face_quadrature_formula,\\n\\u00a0                                            update_values |\\n\\u00a0                                              update_normal_vectors |\\n\\u00a0                                              update_quadrature_points |\\n\\u00a0                                              update_JxW_values);\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell = darcy_fe.n_dofs_per_cell();\\n\\u00a0 \\n\\u00a0     const unsigned int n_q_points      = quadrature_formula.size();\\n\\u00a0     const unsigned int n_face_q_points = face_quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0     Vector<double>     local_rhs(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     const Functions::ZeroFunction<dim> pressure_right_hand_side;\\n\\u00a0     const PressureBoundaryValues<dim>  pressure_boundary_values;\\n\\u00a0 \\n\\u00a0     std::vector<double>         pressure_rhs_values(n_q_points);\\n\\u00a0     std::vector<double>         boundary_values(n_face_q_points);\\n\\u00a0     std::vector<Tensor<2, dim>> k_inverse_values(n_q_points);\\n\\u00a0 \\nFunctions::ZeroFunctionDefinition function.h:510\\nupdate_normal_vectors@ update_normal_vectorsNormal vectors.Definition fe_update_flags.h:141\\nNext we need a vector that will contain the values of the saturation solution at the previous time level at the quadrature points to assemble the saturation dependent coefficients in the Darcy equations.\\nThe set of vectors we create next hold the evaluations of the basis functions as well as their gradients that will be used for creating the matrices. Putting these into their own arrays rather than asking the FEValues object for this information each time it is needed is an optimization to accelerate the assembly process, see step-22 for details.\\nThe last two declarations are used to extract the individual blocks (velocity, pressure, saturation) from the total FE system.\\n\\u00a0     std::vector<double> old_saturation_values(n_q_points);\\n\\u00a0 \\n\\u00a0     std::vector<Tensor<1, dim>> phi_u(dofs_per_cell);\\n\\u00a0     std::vector<double>         div_phi_u(dofs_per_cell);\\n\\u00a0     std::vector<double>         phi_p(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     const FEValuesExtractors::Vector velocities(0);\\n\\u00a0     const FEValuesExtractors::Scalar pressure(dim);\\n\\u00a0 \\nNow start the loop over all cells in the problem. We are working on two different DoFHandlers for this assembly routine, so we must have two different cell iterators for the two objects in use. This might seem a bit peculiar, but since both the Darcy system and the saturation system use the same grid we can assume that the two iterators run in sync over the cells of the two DoFHandler objects.\\nThe first statements within the loop are again all very familiar, doing the update of the finite element data as specified by the update flags, zeroing out the local arrays and getting the values of the old solution at the quadrature points. At this point we also have to get the values of the saturation function of the previous time step at the quadrature points. To this end, we can use the FEValues::get_function_values (previously already used in step-9, step-14 and step-15), a function that takes a solution vector and returns a list of function values at the quadrature points of the present cell. In fact, it returns the complete vector-valued solution at each quadrature point, i.e. not only the saturation but also the velocities and pressure.\\nThen we are ready to loop over the quadrature points on the cell to do the integration. The formula for this follows in a straightforward way from what has been discussed in the introduction.\\nOnce this is done, we start the loop over the rows and columns of the local matrix and feed the matrix with the relevant products.\\nThe last step in the loop over all cells is to enter the local contributions into the global matrix and vector structures to the positions specified in local_dof_indices. Again, we let the AffineConstraints class do the insertion of the cell matrix elements to the global matrix, which already condenses the hanging node constraints.\\n\\u00a0     auto       cell            = darcy_dof_handler.begin_active();\\n\\u00a0     const auto endc            = darcy_dof_handler.end();\\n\\u00a0     auto       saturation_cell = saturation_dof_handler.begin_active();\\n\\u00a0 \\n\\u00a0     for (; cell != endc; ++cell, ++saturation_cell)\\n\\u00a0       {\\n\\u00a0         darcy_fe_values.reinit(cell);\\n\\u00a0         saturation_fe_values.reinit(saturation_cell);\\n\\u00a0 \\n\\u00a0         local_matrix = 0;\\n\\u00a0         local_rhs    = 0;\\n\\u00a0 \\n\\u00a0         saturation_fe_values.get_function_values(old_saturation_solution,\\n\\u00a0                                                  old_saturation_values);\\n\\u00a0 \\n\\u00a0         pressure_right_hand_side.value_list(\\n\\u00a0           darcy_fe_values.get_quadrature_points(), pressure_rhs_values);\\n\\u00a0         k_inverse.value_list(darcy_fe_values.get_quadrature_points(),\\n\\u00a0                              k_inverse_values);\\n\\u00a0 \\n\\u00a0         for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0           {\\n\\u00a0             for (unsigned int k = 0; k < dofs_per_cell; ++k)\\n\\u00a0               {\\n\\u00a0                 phi_u[k]     = darcy_fe_values[velocities].value(k, q);\\n\\u00a0                 div_phi_u[k] = darcy_fe_values[velocities].divergence(k, q);\\n\\u00a0                 phi_p[k]     = darcy_fe_values[pressure].value(k, q);\\n\\u00a0               }\\n\\u00a0             for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0               {\\n\\u00a0                 const double old_s = old_saturation_values[q];\\n\\u00a0                 for (unsigned int j = 0; j <= i; ++j)\\n\\u00a0                   {\\n\\u00a0                     local_matrix(i, j) +=\\n\\u00a0                       (phi_u[i] * k_inverse_values[q] *\\n\\u00a0                          mobility_inverse(old_s, viscosity) * phi_u[j] -\\n\\u00a0                        div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *\\n\\u00a0                       darcy_fe_values.JxW(q);\\n\\u00a0                   }\\n\\u00a0 \\n\\u00a0                 local_rhs(i) +=\\n\\u00a0                   (-phi_p[i] * pressure_rhs_values[q]) * darcy_fe_values.JxW(q);\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         for (const auto &face : cell->face_iterators())\\n\\u00a0           if (face->at_boundary())\\n\\u00a0             {\\n\\u00a0               darcy_fe_face_values.reinit(cell, face);\\n\\u00a0 \\n\\u00a0               pressure_boundary_values.value_list(\\n\\u00a0                 darcy_fe_face_values.get_quadrature_points(), boundary_values);\\n\\u00a0 \\n\\u00a0               for (unsigned int q = 0; q < n_face_q_points; ++q)\\n\\u00a0                 for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0                   {\\n\\u00a0                     const Tensor<1, dim> phi_i_u =\\n\\u00a0                       darcy_fe_face_values[velocities].value(i, q);\\n\\u00a0 \\n\\u00a0                     local_rhs(i) +=\\n\\u00a0                       -(phi_i_u * darcy_fe_face_values.normal_vector(q) *\\n\\u00a0                         boundary_values[q] * darcy_fe_face_values.JxW(q));\\n\\u00a0                   }\\n\\u00a0             }\\n\\u00a0 \\n\\u00a0         for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0           for (unsigned int j = i + 1; j < dofs_per_cell; ++j)\\n\\u00a0             local_matrix(i, j) = local_matrix(j, i);\\n\\u00a0 \\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0 \\n\\u00a0         darcy_constraints.distribute_local_to_global(\\n\\u00a0           local_matrix, local_rhs, local_dof_indices, darcy_matrix, darcy_rhs);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\ninternal::reinitvoid reinit(MatrixBlock< MatrixType > &v, const BlockSparsityPattern &p)Definition matrix_block.h:617\\n TwoPhaseFlowProblem<dim>::assemble_saturation_system\\nThis function is to assemble the linear system for the saturation transport equation. It calls, if necessary, two other member functions: assemble_saturation_matrix() and assemble_saturation_rhs(). The former function then assembles the saturation matrix that only needs to be changed occasionally. On the other hand, the latter function that assembles the right hand side must be called at every saturation time step.\\n\\u00a0   template <int dim>\\n\\u00a0   void TwoPhaseFlowProblem<dim>::assemble_saturation_system()\\n\\u00a0   {\\n\\u00a0     if (rebuild_saturation_matrix == true)\\n\\u00a0       {\\n\\u00a0         saturation_matrix = 0;\\n\\u00a0         assemble_saturation_matrix();\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     saturation_rhs = 0;\\n\\u00a0     assemble_saturation_rhs();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n TwoPhaseFlowProblem<dim>::assemble_saturation_matrix\\nThis function is easily understood since it only forms a simple mass matrix for the left hand side of the saturation linear system by basis functions phi_i_s and phi_j_s only. Finally, as usual, we enter the local contribution into the global matrix by specifying the position in local_dof_indices. This is done by letting the AffineConstraints class do the insertion of the cell matrix elements to the global matrix, which already condenses the hanging node constraints.\\n\\u00a0   template <int dim>\\n\\u00a0   void TwoPhaseFlowProblem<dim>::assemble_saturation_matrix()\\n\\u00a0   {\\n\\u00a0     const QGauss<dim> quadrature_formula(saturation_degree + 2);\\n\\u00a0 \\n\\u00a0     FEValues<dim> saturation_fe_values(saturation_fe,\\n\\u00a0                                        quadrature_formula,\\n\\u00a0                                        update_values | update_JxW_values);\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell = saturation_fe.n_dofs_per_cell();\\n\\u00a0 \\n\\u00a0     const unsigned int n_q_points = quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0     Vector<double>     local_rhs(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : saturation_dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         saturation_fe_values.reinit(cell);\\n\\u00a0         local_matrix = 0;\\n\\u00a0         local_rhs    = 0;\\n\\u00a0 \\n\\u00a0         for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0           for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0             {\\n\\u00a0               const double phi_i_s = saturation_fe_values.shape_value(i, q);\\n\\u00a0               for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0                 {\\n\\u00a0                   const double phi_j_s = saturation_fe_values.shape_value(j, q);\\n\\u00a0                   local_matrix(i, j) +=\\n\\u00a0                     porosity * phi_i_s * phi_j_s * saturation_fe_values.JxW(q);\\n\\u00a0                 }\\n\\u00a0             }\\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0 \\n\\u00a0         saturation_constraints.distribute_local_to_global(local_matrix,\\n\\u00a0                                                           local_dof_indices,\\n\\u00a0                                                           saturation_matrix);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n TwoPhaseFlowProblem<dim>::assemble_saturation_rhs\\nThis function is to assemble the right hand side of the saturation transport equation. Before going about it, we have to create two FEValues objects for the Darcy and saturation systems respectively and, in addition, two FEFaceValues objects for the two systems because we have a boundary integral term in the weak form of saturation equation. For the FEFaceValues object of the saturation system, we also require normal vectors, which we request using the update_normal_vectors flag.\\nNext, before looping over all the cells, we have to compute some parameters (e.g. global_u_infty, global_S_variation, and global_Omega_diameter) that the artificial viscosity \\\\(\\\\nu\\\\) needs. This is largely the same as was done in step-31, so you may see there for more information.\\nThe real works starts with the loop over all the saturation and Darcy cells to put the local contributions into the global vector. In this loop, in order to simplify the implementation, we split some of the work into two helper functions: assemble_saturation_rhs_cell_term and assemble_saturation_rhs_boundary_term. We note that we insert cell or boundary contributions into the global vector in the two functions rather than in this present function.\\n\\u00a0   template <int dim>\\n\\u00a0   void TwoPhaseFlowProblem<dim>::assemble_saturation_rhs()\\n\\u00a0   {\\n\\u00a0     const QGauss<dim>     quadrature_formula(saturation_degree + 2);\\n\\u00a0     const QGauss<dim - 1> face_quadrature_formula(saturation_degree + 2);\\n\\u00a0 \\n\\u00a0     FEValues<dim> saturation_fe_values(saturation_fe,\\n\\u00a0                                        quadrature_formula,\\n\\u00a0                                        update_values | update_gradients |\\n\\u00a0                                          update_quadrature_points |\\n\\u00a0                                          update_JxW_values);\\n\\u00a0     FEValues<dim> darcy_fe_values(darcy_fe, quadrature_formula, update_values);\\n\\u00a0     FEFaceValues<dim> saturation_fe_face_values(saturation_fe,\\n\\u00a0                                                 face_quadrature_formula,\\n\\u00a0                                                 update_values |\\n\\u00a0                                                   update_normal_vectors |\\n\\u00a0                                                   update_quadrature_points |\\n\\u00a0                                                   update_JxW_values);\\n\\u00a0     FEFaceValues<dim> darcy_fe_face_values(darcy_fe,\\n\\u00a0                                            face_quadrature_formula,\\n\\u00a0                                            update_values);\\n\\u00a0     FEFaceValues<dim> saturation_fe_face_values_neighbor(\\n\\u00a0       saturation_fe, face_quadrature_formula, update_values);\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell =\\n\\u00a0       saturation_dof_handler.get_fe().n_dofs_per_cell();\\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     const double                    global_max_u_F_prime = get_max_u_F_prime();\\n\\u00a0     const std::pair<double, double> global_S_range =\\n\\u00a0       get_extrapolated_saturation_range();\\n\\u00a0     const double global_S_variation =\\n\\u00a0       global_S_range.second - global_S_range.first;\\n\\u00a0 \\n\\u00a0     auto       cell       = saturation_dof_handler.begin_active();\\n\\u00a0     const auto endc       = saturation_dof_handler.end();\\n\\u00a0     auto       darcy_cell = darcy_dof_handler.begin_active();\\n\\u00a0     for (; cell != endc; ++cell, ++darcy_cell)\\n\\u00a0       {\\n\\u00a0         saturation_fe_values.reinit(cell);\\n\\u00a0         darcy_fe_values.reinit(darcy_cell);\\n\\u00a0 \\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0 \\n\\u00a0         assemble_saturation_rhs_cell_term(saturation_fe_values,\\n\\u00a0                                           darcy_fe_values,\\n\\u00a0                                           global_max_u_F_prime,\\n\\u00a0                                           global_S_variation,\\n\\u00a0                                           local_dof_indices);\\n\\u00a0 \\n\\u00a0         for (const auto &face : cell->face_iterators())\\n\\u00a0           if (face->at_boundary())\\n\\u00a0             {\\n\\u00a0               darcy_fe_face_values.reinit(darcy_cell, face);\\n\\u00a0               saturation_fe_face_values.reinit(cell, face);\\n\\u00a0               assemble_saturation_rhs_boundary_term(saturation_fe_face_values,\\n\\u00a0                                                     darcy_fe_face_values,\\n\\u00a0                                                     local_dof_indices);\\n\\u00a0             }\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_cell_term\\nThis function takes care of integrating the cell terms of the right hand side of the saturation equation, and then assembling it into the global right hand side vector. Given the discussion in the introduction, the form of these contributions is clear. The only tricky part is getting the artificial viscosity and all that is necessary to compute it. The first half of the function is devoted to this task.\\nThe last part of the function is copying the local contributions into the global vector with position specified in local_dof_indices.\\n\\u00a0   template <int dim>\\n\\u00a0   void TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_cell_term(\\n\\u00a0     const FEValues<dim>                        &saturation_fe_values,\\n\\u00a0     const FEValues<dim>                        &darcy_fe_values,\\n\\u00a0     const double                                global_max_u_F_prime,\\n\\u00a0     const double                                global_S_variation,\\n\\u00a0     const std::vector<types::global_dof_index> &local_dof_indices)\\n\\u00a0   {\\n\\u00a0     const unsigned int dofs_per_cell = saturation_fe_values.dofs_per_cell;\\n\\u00a0     const unsigned int n_q_points    = saturation_fe_values.n_quadrature_points;\\n\\u00a0 \\n\\u00a0     std::vector<double>         old_saturation_solution_values(n_q_points);\\n\\u00a0     std::vector<double>         old_old_saturation_solution_values(n_q_points);\\n\\u00a0     std::vector<Tensor<1, dim>> old_grad_saturation_solution_values(n_q_points);\\n\\u00a0     std::vector<Tensor<1, dim>> old_old_grad_saturation_solution_values(\\n\\u00a0       n_q_points);\\n\\u00a0     std::vector<Vector<double>> present_darcy_solution_values(\\n\\u00a0       n_q_points, Vector<double>(dim + 1));\\n\\u00a0 \\n\\u00a0     saturation_fe_values.get_function_values(old_saturation_solution,\\n\\u00a0                                              old_saturation_solution_values);\\n\\u00a0     saturation_fe_values.get_function_values(\\n\\u00a0       old_old_saturation_solution, old_old_saturation_solution_values);\\n\\u00a0     saturation_fe_values.get_function_gradients(\\n\\u00a0       old_saturation_solution, old_grad_saturation_solution_values);\\n\\u00a0     saturation_fe_values.get_function_gradients(\\n\\u00a0       old_old_saturation_solution, old_old_grad_saturation_solution_values);\\n\\u00a0     darcy_fe_values.get_function_values(darcy_solution,\\n\\u00a0                                         present_darcy_solution_values);\\n\\u00a0 \\n\\u00a0     const double nu =\\n\\u00a0       compute_viscosity(old_saturation_solution_values,\\n\\u00a0                         old_old_saturation_solution_values,\\n\\u00a0                         old_grad_saturation_solution_values,\\n\\u00a0                         old_old_grad_saturation_solution_values,\\n\\u00a0                         present_darcy_solution_values,\\n\\u00a0                         global_max_u_F_prime,\\n\\u00a0                         global_S_variation,\\n\\u00a0                         saturation_fe_values.get_cell()->diameter());\\n\\u00a0 \\n\\u00a0     Vector<double> local_rhs(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0       for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0         {\\n\\u00a0           const double   old_s = old_saturation_solution_values[q];\\n\\u00a0           Tensor<1, dim> present_u;\\n\\u00a0           for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0             present_u[d] = present_darcy_solution_values[q](d);\\n\\u00a0 \\n\\u00a0           const double         phi_i_s = saturation_fe_values.shape_value(i, q);\\n\\u00a0           const Tensor<1, dim> grad_phi_i_s =\\n\\u00a0             saturation_fe_values.shape_grad(i, q);\\n\\u00a0 \\n\\u00a0           local_rhs(i) +=\\n\\u00a0             (time_step * fractional_flow(old_s, viscosity) * present_u *\\n\\u00a0                grad_phi_i_s -\\n\\u00a0              time_step * nu * old_grad_saturation_solution_values[q] *\\n\\u00a0                grad_phi_i_s +\\n\\u00a0              porosity * old_s * phi_i_s) *\\n\\u00a0             saturation_fe_values.JxW(q);\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0     saturation_constraints.distribute_local_to_global(local_rhs,\\n\\u00a0                                                       local_dof_indices,\\n\\u00a0                                                       saturation_rhs);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_boundary_term\\nThe next function is responsible for the boundary integral terms in the right hand side form of the saturation equation. For these, we have to compute the upwinding flux on the global boundary faces, i.e. we impose Dirichlet boundary conditions weakly only on inflow parts of the global boundary. As before, this has been described in step-21 so we refrain from giving more descriptions about that.\\n\\u00a0   template <int dim>\\n\\u00a0   void TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_boundary_term(\\n\\u00a0     const FEFaceValues<dim>                    &saturation_fe_face_values,\\n\\u00a0     const FEFaceValues<dim>                    &darcy_fe_face_values,\\n\\u00a0     const std::vector<types::global_dof_index> &local_dof_indices)\\n\\u00a0   {\\n\\u00a0     const unsigned int dofs_per_cell = saturation_fe_face_values.dofs_per_cell;\\n\\u00a0     const unsigned int n_face_q_points =\\n\\u00a0       saturation_fe_face_values.n_quadrature_points;\\n\\u00a0 \\n\\u00a0     Vector<double> local_rhs(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     std::vector<double> old_saturation_solution_values_face(n_face_q_points);\\n\\u00a0     std::vector<Vector<double>> present_darcy_solution_values_face(\\n\\u00a0       n_face_q_points, Vector<double>(dim + 1));\\n\\u00a0     std::vector<double> neighbor_saturation(n_face_q_points);\\n\\u00a0 \\n\\u00a0     saturation_fe_face_values.get_function_values(\\n\\u00a0       old_saturation_solution, old_saturation_solution_values_face);\\n\\u00a0     darcy_fe_face_values.get_function_values(\\n\\u00a0       darcy_solution, present_darcy_solution_values_face);\\n\\u00a0 \\n\\u00a0     SaturationBoundaryValues<dim> saturation_boundary_values;\\n\\u00a0     saturation_boundary_values.value_list(\\n\\u00a0       saturation_fe_face_values.get_quadrature_points(), neighbor_saturation);\\n\\u00a0 \\n\\u00a0     for (unsigned int q = 0; q < n_face_q_points; ++q)\\n\\u00a0       {\\n\\u00a0         Tensor<1, dim> present_u_face;\\n\\u00a0         for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0           present_u_face[d] = present_darcy_solution_values_face[q](d);\\n\\u00a0 \\n\\u00a0         const double normal_flux =\\n\\u00a0           present_u_face * saturation_fe_face_values.normal_vector(q);\\n\\u00a0 \\n\\u00a0         const bool is_outflow_q_point = (normal_flux >= 0);\\n\\u00a0 \\n\\u00a0         for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0           local_rhs(i) -=\\n\\u00a0             time_step * normal_flux *\\n\\u00a0             fractional_flow((is_outflow_q_point == true ?\\n\\u00a0                                old_saturation_solution_values_face[q] :\\n\\u00a0                                neighbor_saturation[q]),\\n\\u00a0                             viscosity) *\\n\\u00a0             saturation_fe_face_values.shape_value(i, q) *\\n\\u00a0             saturation_fe_face_values.JxW(q);\\n\\u00a0       }\\n\\u00a0     saturation_constraints.distribute_local_to_global(local_rhs,\\n\\u00a0                                                       local_dof_indices,\\n\\u00a0                                                       saturation_rhs);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n TwoPhaseFlowProblem<dim>::solve\\nThis function implements the operator splitting algorithm, i.e. in each time step it either re-computes the solution of the Darcy system or extrapolates velocity/pressure from previous time steps, then determines the size of the time step, and then updates the saturation variable. The implementation largely follows similar code in step-31. It is, next to the run() function, the central one in this program.\\nAt the beginning of the function, we ask whether to solve the pressure-velocity part by evaluating the a posteriori criterion (see the following function). If necessary, we will solve the pressure-velocity part using the GMRES solver with the Schur complement block preconditioner as is described in the introduction.\\n\\u00a0   template <int dim>\\n\\u00a0   void TwoPhaseFlowProblem<dim>::solve()\\n\\u00a0   {\\n\\u00a0     const bool solve_for_pressure_and_velocity =\\n\\u00a0       determine_whether_to_solve_for_pressure_and_velocity();\\n\\u00a0 \\n\\u00a0     if (solve_for_pressure_and_velocity == true)\\n\\u00a0       {\\n\\u00a0         std::cout << \\\"   Solving Darcy (pressure-velocity) system...\\\"\\n\\u00a0                   << std::endl;\\n\\u00a0 \\n\\u00a0         assemble_darcy_system();\\n\\u00a0         build_darcy_preconditioner();\\n\\u00a0 \\n\\u00a0         {\\n\\u00a0           const LinearSolvers::InverseMatrix<TrilinosWrappers::SparseMatrix,\\n\\u00a0                                              TrilinosWrappers::PreconditionIC>\\n\\u00a0             mp_inverse(darcy_preconditioner_matrix.block(1, 1),\\n\\u00a0                        *bottom_right_preconditioner);\\n\\u00a0 \\n\\u00a0           const LinearSolvers::BlockSchurPreconditioner<\\n\\u00a0             TrilinosWrappers::PreconditionIC,\\n\\u00a0             TrilinosWrappers::PreconditionIC>\\n\\u00a0             preconditioner(darcy_matrix, mp_inverse, *top_left_preconditioner);\\n\\u00a0 \\n\\u00a0           SolverControl solver_control(darcy_matrix.m(),\\n\\u00a0                                        1e-16 * darcy_rhs.l2_norm());\\n\\u00a0 \\n\\u00a0           SolverGMRES<TrilinosWrappers::MPI::BlockVector> gmres(\\n\\u00a0             solver_control,\\n\\u00a0             SolverGMRES<TrilinosWrappers::MPI::BlockVector>::AdditionalData(\\n\\u00a0               100));\\n\\u00a0 \\n\\u00a0           for (unsigned int i = 0; i < darcy_solution.size(); ++i)\\n\\u00a0             if (darcy_constraints.is_constrained(i))\\n\\u00a0               darcy_solution(i) = 0;\\n\\u00a0 \\n\\u00a0           gmres.solve(darcy_matrix, darcy_solution, darcy_rhs, preconditioner);\\n\\u00a0 \\n\\u00a0           darcy_constraints.distribute(darcy_solution);\\n\\u00a0 \\n\\u00a0           std::cout << \\\"        ...\\\" << solver_control.last_step()\\n\\u00a0                     << \\\" GMRES iterations.\\\" << std::endl;\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0         {\\n\\u00a0           second_last_computed_darcy_solution = last_computed_darcy_solution;\\n\\u00a0           last_computed_darcy_solution        = darcy_solution;\\n\\u00a0 \\n\\u00a0           saturation_matching_last_computed_darcy_solution =\\n\\u00a0             saturation_solution;\\n\\u00a0         }\\n\\u00a0       }\\nSolverGMRESDefinition solver_gmres.h:353\\nTrilinosWrappers::PreconditionICDefinition trilinos_precondition.h:842\\nSolverGMRES::AdditionalDataDefinition solver_gmres.h:359\\nOn the other hand, if we have decided that we don't want to compute the solution of the Darcy system for the current time step, then we need to simply extrapolate the previous two Darcy solutions to the same time as we would have computed the velocity/pressure at. We do a simple linear extrapolation, i.e. given the current length \\\\(dt\\\\) of the macro time step from the time when we last computed the Darcy solution to now (given by current_macro_time_step), and \\\\(DT\\\\) the length of the last macro time step (given by old_macro_time_step), then we get  \\\\(u^\\\\ast = u_p + dt \\\\frac{u_p-u_{pp}}{DT} = (1+dt/DT)u_p -\\n   dt/DT u_{pp}\\\\), where \\\\(u_p\\\\) and \\\\(u_{pp}\\\\) are the last two computed Darcy solutions. We can implement this formula using just two lines of code.\\nNote that the algorithm here only works if we have at least two previously computed Darcy solutions from which we can extrapolate to the current time, and this is ensured by requiring re-computation of the Darcy solution for the first 2 time steps.\\n\\u00a0     else\\n\\u00a0       {\\n\\u00a0         darcy_solution = last_computed_darcy_solution;\\n\\u00a0         darcy_solution.sadd(1 + current_macro_time_step / old_macro_time_step,\\n\\u00a0                             -current_macro_time_step / old_macro_time_step,\\n\\u00a0                             second_last_computed_darcy_solution);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0 \\nWith the so computed velocity vector, compute the optimal time step based on the CFL criterion discussed in the introduction...\\n\\u00a0     {\\n\\u00a0       old_time_step = time_step;\\n\\u00a0 \\n\\u00a0       const double max_u_F_prime = get_max_u_F_prime();\\n\\u00a0       if (max_u_F_prime > 0)\\n\\u00a0         time_step = porosity * GridTools::minimal_cell_diameter(triangulation) /\\n\\u00a0                     saturation_degree / max_u_F_prime / 50;\\n\\u00a0       else\\n\\u00a0         time_step = end_time - time;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nGridTools::minimal_cell_diameterdouble minimal_cell_diameter(const Triangulation< dim, spacedim > &triangulation, const Mapping< dim, spacedim > &mapping=(ReferenceCells::get_hypercube< dim >() .template get_default_linear_mapping< dim, spacedim >()))Definition grid_tools_geometry.cc:407\\n...and then also update the length of the macro time steps we use while we're dealing with time step sizes. In particular, this involves: (i) If we have just recomputed the Darcy solution, then the length of the previous macro time step is now fixed and the length of the current macro time step is, up to now, simply the length of the current (micro) time step. (ii) If we have not recomputed the Darcy solution, then the length of the current macro time step has just grown by time_step.\\n\\u00a0     if (solve_for_pressure_and_velocity == true)\\n\\u00a0       {\\n\\u00a0         old_macro_time_step     = current_macro_time_step;\\n\\u00a0         current_macro_time_step = time_step;\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       current_macro_time_step += time_step;\\n\\u00a0 \\nThe last step in this function is to recompute the saturation solution based on the velocity field we've just obtained. This naturally happens in every time step, and we don't skip any of these computations. At the end of computing the saturation, we project back into the allowed interval \\\\([0,1]\\\\) to make sure our solution remains physical.\\n\\u00a0     {\\n\\u00a0       std::cout << \\\"   Solving saturation transport equation...\\\" << std::endl;\\n\\u00a0 \\n\\u00a0       assemble_saturation_system();\\n\\u00a0 \\n\\u00a0       SolverControl solver_control(saturation_matrix.m(),\\n\\u00a0                                    1e-16 * saturation_rhs.l2_norm());\\n\\u00a0       SolverCG<TrilinosWrappers::MPI::Vector> cg(solver_control);\\n\\u00a0 \\n\\u00a0       TrilinosWrappers::PreconditionIC preconditioner;\\n\\u00a0       preconditioner.initialize(saturation_matrix);\\n\\u00a0 \\n\\u00a0       cg.solve(saturation_matrix,\\n\\u00a0                saturation_solution,\\n\\u00a0                saturation_rhs,\\n\\u00a0                preconditioner);\\n\\u00a0 \\n\\u00a0       saturation_constraints.distribute(saturation_solution);\\n\\u00a0       project_back_saturation();\\n\\u00a0 \\n\\u00a0       std::cout << \\\"        ...\\\" << solver_control.last_step()\\n\\u00a0                 << \\\" CG iterations.\\\" << std::endl;\\n\\u00a0     }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nTrilinosWrappers::PreconditionIC::initializevoid initialize(const SparseMatrix &matrix, const AdditionalData &additional_data=AdditionalData())Definition trilinos_precondition.cc:453\\n TwoPhaseFlowProblem<dim>::refine_mesh\\nThe next function does the refinement and coarsening of the mesh. It does its work in three blocks: (i) Compute refinement indicators by looking at the gradient of a solution vector extrapolated linearly from the previous two using the respective sizes of the time step (or taking the only solution we have if this is the first time step). (ii) Flagging those cells for refinement and coarsening where the gradient is larger or smaller than a certain threshold, preserving minimal and maximal levels of mesh refinement. (iii) Transferring the solution from the old to the new mesh. None of this is particularly difficult.\\n\\u00a0   template <int dim>\\n\\u00a0   void TwoPhaseFlowProblem<dim>::refine_mesh(const unsigned int min_grid_level,\\n\\u00a0                                              const unsigned int max_grid_level)\\n\\u00a0   {\\n\\u00a0     Vector<double> refinement_indicators(triangulation.n_active_cells());\\n\\u00a0     {\\n\\u00a0       const QMidpoint<dim>        quadrature_formula;\\n\\u00a0       FEValues<dim>               fe_values(saturation_fe,\\n\\u00a0                               quadrature_formula,\\n\\u00a0                               update_gradients);\\n\\u00a0       std::vector<Tensor<1, dim>> grad_saturation(1);\\n\\u00a0 \\n\\u00a0       TrilinosWrappers::MPI::Vector extrapolated_saturation_solution(\\n\\u00a0         saturation_solution);\\n\\u00a0       if (timestep_number != 0)\\n\\u00a0         extrapolated_saturation_solution.sadd((1. + time_step / old_time_step),\\n\\u00a0                                               time_step / old_time_step,\\n\\u00a0                                               old_saturation_solution);\\n\\u00a0 \\n\\u00a0       for (const auto &cell : saturation_dof_handler.active_cell_iterators())\\n\\u00a0         {\\n\\u00a0           const unsigned int cell_no = cell->active_cell_index();\\n\\u00a0           fe_values.reinit(cell);\\n\\u00a0           fe_values.get_function_gradients(extrapolated_saturation_solution,\\n\\u00a0                                            grad_saturation);\\n\\u00a0 \\n\\u00a0           refinement_indicators(cell_no) = grad_saturation[0].norm();\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       for (const auto &cell : saturation_dof_handler.active_cell_iterators())\\n\\u00a0         {\\n\\u00a0           const unsigned int cell_no = cell->active_cell_index();\\n\\u00a0           cell->clear_coarsen_flag();\\n\\u00a0           cell->clear_refine_flag();\\n\\u00a0 \\n\\u00a0           if ((static_cast<unsigned int>(cell->level()) < max_grid_level) &&\\n\\u00a0               (std::fabs(refinement_indicators(cell_no)) >\\n\\u00a0                saturation_refinement_threshold))\\n\\u00a0             cell->set_refine_flag();\\n\\u00a0           else if ((static_cast<unsigned int>(cell->level()) >\\n\\u00a0                     min_grid_level) &&\\n\\u00a0                    (std::fabs(refinement_indicators(cell_no)) <\\n\\u00a0                     0.5 * saturation_refinement_threshold))\\n\\u00a0             cell->set_coarsen_flag();\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     triangulation.prepare_coarsening_and_refinement();\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       std::vector<TrilinosWrappers::MPI::Vector> x_saturation(3);\\n\\u00a0       x_saturation[0] = saturation_solution;\\n\\u00a0       x_saturation[1] = old_saturation_solution;\\n\\u00a0       x_saturation[2] = saturation_matching_last_computed_darcy_solution;\\n\\u00a0 \\n\\u00a0       std::vector<TrilinosWrappers::MPI::BlockVector> x_darcy(2);\\n\\u00a0       x_darcy[0] = last_computed_darcy_solution;\\n\\u00a0       x_darcy[1] = second_last_computed_darcy_solution;\\n\\u00a0 \\n\\u00a0       SolutionTransfer<dim, TrilinosWrappers::MPI::Vector> saturation_soltrans(\\n\\u00a0         saturation_dof_handler);\\n\\u00a0 \\n\\u00a0       SolutionTransfer<dim, TrilinosWrappers::MPI::BlockVector> darcy_soltrans(\\n\\u00a0         darcy_dof_handler);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0       triangulation.prepare_coarsening_and_refinement();\\n\\u00a0       saturation_soltrans.prepare_for_coarsening_and_refinement(x_saturation);\\n\\u00a0 \\n\\u00a0       darcy_soltrans.prepare_for_coarsening_and_refinement(x_darcy);\\n\\u00a0 \\n\\u00a0       triangulation.execute_coarsening_and_refinement();\\n\\u00a0       setup_dofs();\\n\\u00a0 \\n\\u00a0       std::vector<TrilinosWrappers::MPI::Vector> tmp_saturation(3);\\n\\u00a0       tmp_saturation[0].reinit(saturation_solution);\\n\\u00a0       tmp_saturation[1].reinit(saturation_solution);\\n\\u00a0       tmp_saturation[2].reinit(saturation_solution);\\n\\u00a0       saturation_soltrans.interpolate(x_saturation, tmp_saturation);\\n\\u00a0 \\n\\u00a0       saturation_solution                              = tmp_saturation[0];\\n\\u00a0       old_saturation_solution                          = tmp_saturation[1];\\n\\u00a0       saturation_matching_last_computed_darcy_solution = tmp_saturation[2];\\n\\u00a0 \\n\\u00a0       saturation_constraints.distribute(saturation_solution);\\n\\u00a0       saturation_constraints.distribute(old_saturation_solution);\\n\\u00a0       saturation_constraints.distribute(\\n\\u00a0         saturation_matching_last_computed_darcy_solution);\\n\\u00a0 \\n\\u00a0       std::vector<TrilinosWrappers::MPI::BlockVector> tmp_darcy(2);\\n\\u00a0       tmp_darcy[0].reinit(darcy_solution);\\n\\u00a0       tmp_darcy[1].reinit(darcy_solution);\\n\\u00a0       darcy_soltrans.interpolate(x_darcy, tmp_darcy);\\n\\u00a0 \\n\\u00a0       last_computed_darcy_solution        = tmp_darcy[0];\\n\\u00a0       second_last_computed_darcy_solution = tmp_darcy[1];\\n\\u00a0 \\n\\u00a0       darcy_constraints.distribute(last_computed_darcy_solution);\\n\\u00a0       darcy_constraints.distribute(second_last_computed_darcy_solution);\\n\\u00a0 \\n\\u00a0       rebuild_saturation_matrix = true;\\n\\u00a0     }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nQMidpointDefinition quadrature_lib.h:162\\nSolutionTransferDefinition solution_transfer.h:337\\nint\\nparallel::distributed::Triangulation::execute_coarsening_and_refinementvirtual void execute_coarsening_and_refinement() overrideDefinition tria.cc:3320\\nparallel::distributed::Triangulation::prepare_coarsening_and_refinementvirtual bool prepare_coarsening_and_refinement() overrideDefinition tria.cc:2805\\n TwoPhaseFlowProblem<dim>::output_results\\nThis function generates graphical output. It is in essence a copy of the implementation in step-31.\\n\\u00a0   template <int dim>\\n\\u00a0   void TwoPhaseFlowProblem<dim>::output_results() const\\n\\u00a0   {\\n\\u00a0     const FESystem<dim> joint_fe(darcy_fe, 1, saturation_fe, 1);\\n\\u00a0     DoFHandler<dim>     joint_dof_handler(triangulation);\\n\\u00a0     joint_dof_handler.distribute_dofs(joint_fe);\\n\\u00a0     Assert(joint_dof_handler.n_dofs() ==\\n\\u00a0              darcy_dof_handler.n_dofs() + saturation_dof_handler.n_dofs(),\\n\\u00a0            ExcInternalError());\\n\\u00a0 \\n\\u00a0     Vector<double> joint_solution(joint_dof_handler.n_dofs());\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       std::vector<types::global_dof_index> local_joint_dof_indices(\\n\\u00a0         joint_fe.n_dofs_per_cell());\\n\\u00a0       std::vector<types::global_dof_index> local_darcy_dof_indices(\\n\\u00a0         darcy_fe.n_dofs_per_cell());\\n\\u00a0       std::vector<types::global_dof_index> local_saturation_dof_indices(\\n\\u00a0         saturation_fe.n_dofs_per_cell());\\n\\u00a0 \\n\\u00a0       auto       joint_cell      = joint_dof_handler.begin_active();\\n\\u00a0       const auto joint_endc      = joint_dof_handler.end();\\n\\u00a0       auto       darcy_cell      = darcy_dof_handler.begin_active();\\n\\u00a0       auto       saturation_cell = saturation_dof_handler.begin_active();\\n\\u00a0 \\n\\u00a0       for (; joint_cell != joint_endc;\\n\\u00a0            ++joint_cell, ++darcy_cell, ++saturation_cell)\\n\\u00a0         {\\n\\u00a0           joint_cell->get_dof_indices(local_joint_dof_indices);\\n\\u00a0           darcy_cell->get_dof_indices(local_darcy_dof_indices);\\n\\u00a0           saturation_cell->get_dof_indices(local_saturation_dof_indices);\\n\\u00a0 \\n\\u00a0           for (unsigned int i = 0; i < joint_fe.n_dofs_per_cell(); ++i)\\n\\u00a0             if (joint_fe.system_to_base_index(i).first.first == 0)\\n\\u00a0               {\\n\\u00a0                 Assert(joint_fe.system_to_base_index(i).second <\\n\\u00a0                          local_darcy_dof_indices.size(),\\n\\u00a0                        ExcInternalError());\\n\\u00a0                 joint_solution(local_joint_dof_indices[i]) = darcy_solution(\\n\\u00a0                   local_darcy_dof_indices[joint_fe.system_to_base_index(i)\\n\\u00a0                                             .second]);\\n\\u00a0               }\\n\\u00a0             else\\n\\u00a0               {\\n\\u00a0                 Assert(joint_fe.system_to_base_index(i).first.first == 1,\\n\\u00a0                        ExcInternalError());\\n\\u00a0                 Assert(joint_fe.system_to_base_index(i).second <\\n\\u00a0                          local_darcy_dof_indices.size(),\\n\\u00a0                        ExcInternalError());\\n\\u00a0                 joint_solution(local_joint_dof_indices[i]) =\\n\\u00a0                   saturation_solution(\\n\\u00a0                     local_saturation_dof_indices\\n\\u00a0                       [joint_fe.system_to_base_index(i).second]);\\n\\u00a0               }\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0     std::vector<std::string> joint_solution_names(dim, \\\"velocity\\\");\\n\\u00a0     joint_solution_names.emplace_back(\\\"pressure\\\");\\n\\u00a0     joint_solution_names.emplace_back(\\\"saturation\\\");\\n\\u00a0 \\n\\u00a0     std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n\\u00a0       data_component_interpretation(\\n\\u00a0         dim, DataComponentInterpretation::component_is_part_of_vector);\\n\\u00a0     data_component_interpretation.push_back(\\n\\u00a0       DataComponentInterpretation::component_is_scalar);\\n\\u00a0     data_component_interpretation.push_back(\\n\\u00a0       DataComponentInterpretation::component_is_scalar);\\n\\u00a0 \\n\\u00a0     DataOut<dim> data_out;\\n\\u00a0 \\n\\u00a0     data_out.attach_dof_handler(joint_dof_handler);\\n\\u00a0     data_out.add_data_vector(joint_solution,\\n\\u00a0                              joint_solution_names,\\n\\u00a0                              DataOut<dim>::type_dof_data,\\n\\u00a0                              data_component_interpretation);\\n\\u00a0 \\n\\u00a0     data_out.build_patches();\\n\\u00a0 \\n\\u00a0     std::string filename =\\n\\u00a0       \\\"solution-\\\" + Utilities::int_to_string(timestep_number, 5) + \\\".vtu\\\";\\n\\u00a0     std::ofstream output(filename);\\n\\u00a0     data_out.write_vtu(output);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nDataComponentInterpretation::component_is_scalar@ component_is_scalarDefinition data_component_interpretation.h:52\\nDataComponentInterpretation::component_is_part_of_vector@ component_is_part_of_vectorDefinition data_component_interpretation.h:58\\nUtilities::int_to_stringstd::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)Definition utilities.cc:470\\n Tool functions\\n TwoPhaseFlowProblem<dim>::determine_whether_to_solve_for_pressure_and_velocity\\nThis function implements the a posteriori criterion for adaptive operator splitting. The function is relatively straightforward given the way we have implemented other functions above and given the formula for the criterion derived in the paper.\\nIf one decides that one wants the original IMPES method in which the Darcy equation is solved in every time step, then this can be achieved by setting the threshold value AOS_threshold (with a default of \\\\(5.0\\\\)) to zero, thereby forcing the function to always return true.\\nFinally, note that the function returns true unconditionally for the first two time steps to ensure that we have always solved the Darcy system at least twice when skipping its solution, thereby allowing us to extrapolate the velocity from the last two solutions in solve().\\n\\u00a0   template <int dim>\\n\\u00a0   bool TwoPhaseFlowProblem<\\n\\u00a0     dim>::determine_whether_to_solve_for_pressure_and_velocity() const\\n\\u00a0   {\\n\\u00a0     if (timestep_number <= 2)\\n\\u00a0       return true;\\n\\u00a0 \\n\\u00a0     const QGauss<dim>  quadrature_formula(saturation_degree + 2);\\n\\u00a0     const unsigned int n_q_points = quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     FEValues<dim> fe_values(saturation_fe,\\n\\u00a0                             quadrature_formula,\\n\\u00a0                             update_values | update_quadrature_points);\\n\\u00a0 \\n\\u00a0     std::vector<double> old_saturation_after_solving_pressure(n_q_points);\\n\\u00a0     std::vector<double> present_saturation(n_q_points);\\n\\u00a0 \\n\\u00a0     std::vector<Tensor<2, dim>> k_inverse_values(n_q_points);\\n\\u00a0 \\n\\u00a0     double max_global_aop_indicator = 0.0;\\n\\u00a0 \\n\\u00a0     for (const auto &cell : saturation_dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         double max_local_mobility_reciprocal_difference = 0.0;\\n\\u00a0         double max_local_permeability_inverse_l1_norm   = 0.0;\\n\\u00a0 \\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0         fe_values.get_function_values(\\n\\u00a0           saturation_matching_last_computed_darcy_solution,\\n\\u00a0           old_saturation_after_solving_pressure);\\n\\u00a0         fe_values.get_function_values(saturation_solution, present_saturation);\\n\\u00a0 \\n\\u00a0         k_inverse.value_list(fe_values.get_quadrature_points(),\\n\\u00a0                              k_inverse_values);\\n\\u00a0 \\n\\u00a0         for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0           {\\n\\u00a0             const double mobility_reciprocal_difference = std::fabs(\\n\\u00a0               mobility_inverse(present_saturation[q], viscosity) -\\n\\u00a0               mobility_inverse(old_saturation_after_solving_pressure[q],\\n\\u00a0                                viscosity));\\n\\u00a0 \\n\\u00a0             max_local_mobility_reciprocal_difference =\\n\\u00a0               std::max(max_local_mobility_reciprocal_difference,\\n\\u00a0                        mobility_reciprocal_difference);\\n\\u00a0 \\n\\u00a0             max_local_permeability_inverse_l1_norm =\\n\\u00a0               std::max(max_local_permeability_inverse_l1_norm,\\n\\u00a0                        l1_norm(k_inverse_values[q]));\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         max_global_aop_indicator =\\n\\u00a0           std::max(max_global_aop_indicator,\\n\\u00a0                    (max_local_mobility_reciprocal_difference *\\n\\u00a0                     max_local_permeability_inverse_l1_norm));\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     return (max_global_aop_indicator > AOS_threshold);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nl1_normNumber l1_norm(const Tensor< 2, dim, Number > &t)Definition tensor.h:3039\\n TwoPhaseFlowProblem<dim>::project_back_saturation\\nThe next function simply makes sure that the saturation values always remain within the physically reasonable range of \\\\([0,1]\\\\). While the continuous equations guarantee that this is so, the discrete equations don't. However, if we allow the discrete solution to escape this range we get into trouble because terms like \\\\(F(S)\\\\) and \\\\(F'(S)\\\\) will produce unreasonable results (e.g. \\\\(F'(S)<0\\\\) for \\\\(S<0\\\\), which would imply that the wetting fluid phase flows against the direction of the bulk fluid velocity)). Consequently, at the end of each time step, we simply project the saturation field back into the physically reasonable region.\\n\\u00a0   template <int dim>\\n\\u00a0   void TwoPhaseFlowProblem<dim>::project_back_saturation()\\n\\u00a0   {\\n\\u00a0     for (unsigned int i = 0; i < saturation_solution.size(); ++i)\\n\\u00a0       if (saturation_solution(i) < 0.2)\\n\\u00a0         saturation_solution(i) = 0.2;\\n\\u00a0       else if (saturation_solution(i) > 1)\\n\\u00a0         saturation_solution(i) = 1;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n TwoPhaseFlowProblem<dim>::get_max_u_F_prime\\nAnother simpler helper function: Compute the maximum of the total velocity times the derivative of the fraction flow function, i.e., compute \\\\(\\\\|\\\\mathbf{u} F'(S)\\\\|_{L_\\\\infty(\\\\Omega)}\\\\). This term is used in both the computation of the time step as well as in normalizing the entropy-residual term in the artificial viscosity.\\n\\u00a0   template <int dim>\\n\\u00a0   double TwoPhaseFlowProblem<dim>::get_max_u_F_prime() const\\n\\u00a0   {\\n\\u00a0     const QGauss<dim>  quadrature_formula(darcy_degree + 2);\\n\\u00a0     const unsigned int n_q_points = quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     FEValues<dim> darcy_fe_values(darcy_fe, quadrature_formula, update_values);\\n\\u00a0     FEValues<dim> saturation_fe_values(saturation_fe,\\n\\u00a0                                        quadrature_formula,\\n\\u00a0                                        update_values);\\n\\u00a0 \\n\\u00a0     std::vector<Vector<double>> darcy_solution_values(n_q_points,\\n\\u00a0                                                       Vector<double>(dim + 1));\\n\\u00a0     std::vector<double>         saturation_values(n_q_points);\\n\\u00a0 \\n\\u00a0     double max_velocity_times_dF_dS = 0;\\n\\u00a0 \\n\\u00a0     auto       cell            = darcy_dof_handler.begin_active();\\n\\u00a0     const auto endc            = darcy_dof_handler.end();\\n\\u00a0     auto       saturation_cell = saturation_dof_handler.begin_active();\\n\\u00a0     for (; cell != endc; ++cell, ++saturation_cell)\\n\\u00a0       {\\n\\u00a0         darcy_fe_values.reinit(cell);\\n\\u00a0         saturation_fe_values.reinit(saturation_cell);\\n\\u00a0 \\n\\u00a0         darcy_fe_values.get_function_values(darcy_solution,\\n\\u00a0                                             darcy_solution_values);\\n\\u00a0         saturation_fe_values.get_function_values(old_saturation_solution,\\n\\u00a0                                                  saturation_values);\\n\\u00a0 \\n\\u00a0         for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0           {\\n\\u00a0             Tensor<1, dim> velocity;\\n\\u00a0             for (unsigned int i = 0; i < dim; ++i)\\n\\u00a0               velocity[i] = darcy_solution_values[q](i);\\n\\u00a0 \\n\\u00a0             const double dF_dS =\\n\\u00a0               fractional_flow_derivative(saturation_values[q], viscosity);\\n\\u00a0 \\n\\u00a0             max_velocity_times_dF_dS =\\n\\u00a0               std::max(max_velocity_times_dF_dS, velocity.norm() * dF_dS);\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     return max_velocity_times_dF_dS;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n TwoPhaseFlowProblem<dim>::get_extrapolated_saturation_range\\nFor computing the stabilization term, we need to know the range of the saturation variable. Unlike in step-31, this range is trivially bounded by the interval \\\\([0,1]\\\\) but we can do a bit better by looping over a collection of quadrature points and seeing what the values are there. If we can, i.e., if there are at least two timesteps around, we can even take the values extrapolated to the next time step.\\nAs before, the function is taken with minimal modifications from step-31.\\n\\u00a0   template <int dim>\\n\\u00a0   std::pair<double, double>\\n\\u00a0   TwoPhaseFlowProblem<dim>::get_extrapolated_saturation_range() const\\n\\u00a0   {\\n\\u00a0     const QGauss<dim>  quadrature_formula(saturation_degree + 2);\\n\\u00a0     const unsigned int n_q_points = quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     FEValues<dim> fe_values(saturation_fe, quadrature_formula, update_values);\\n\\u00a0     std::vector<double> old_saturation_values(n_q_points);\\n\\u00a0     std::vector<double> old_old_saturation_values(n_q_points);\\n\\u00a0 \\n\\u00a0     if (timestep_number != 0)\\n\\u00a0       {\\n\\u00a0         double min_saturation = std::numeric_limits<double>::max(),\\n\\u00a0                max_saturation = -std::numeric_limits<double>::max();\\n\\u00a0 \\n\\u00a0         for (const auto &cell : saturation_dof_handler.active_cell_iterators())\\n\\u00a0           {\\n\\u00a0             fe_values.reinit(cell);\\n\\u00a0             fe_values.get_function_values(old_saturation_solution,\\n\\u00a0                                           old_saturation_values);\\n\\u00a0             fe_values.get_function_values(old_old_saturation_solution,\\n\\u00a0                                           old_old_saturation_values);\\n\\u00a0 \\n\\u00a0             for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0               {\\n\\u00a0                 const double saturation =\\n\\u00a0                   (1. + time_step / old_time_step) * old_saturation_values[q] -\\n\\u00a0                   time_step / old_time_step * old_old_saturation_values[q];\\n\\u00a0 \\n\\u00a0                 min_saturation = std::min(min_saturation, saturation);\\n\\u00a0                 max_saturation = std::max(max_saturation, saturation);\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         return std::make_pair(min_saturation, max_saturation);\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       {\\n\\u00a0         double min_saturation = std::numeric_limits<double>::max(),\\n\\u00a0                max_saturation = -std::numeric_limits<double>::max();\\n\\u00a0 \\n\\u00a0         for (const auto &cell : saturation_dof_handler.active_cell_iterators())\\n\\u00a0           {\\n\\u00a0             fe_values.reinit(cell);\\n\\u00a0             fe_values.get_function_values(old_saturation_solution,\\n\\u00a0                                           old_saturation_values);\\n\\u00a0 \\n\\u00a0             for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0               {\\n\\u00a0                 const double saturation = old_saturation_values[q];\\n\\u00a0 \\n\\u00a0                 min_saturation = std::min(min_saturation, saturation);\\n\\u00a0                 max_saturation = std::max(max_saturation, saturation);\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         return std::make_pair(min_saturation, max_saturation);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n TwoPhaseFlowProblem<dim>::compute_viscosity\\nThe final tool function is used to compute the artificial viscosity on a given cell. This isn't particularly complicated if you have the formula for it in front of you, and looking at the implementation in step-31. The major difference to that tutorial program is that the velocity here is not simply \\\\(\\\\mathbf u\\\\) but \\\\(\\\\mathbf u F'(S)\\\\) and some of the formulas need to be adjusted accordingly.\\n\\u00a0   template <int dim>\\n\\u00a0   double TwoPhaseFlowProblem<dim>::compute_viscosity(\\n\\u00a0     const std::vector<double>         &old_saturation,\\n\\u00a0     const std::vector<double>         &old_old_saturation,\\n\\u00a0     const std::vector<Tensor<1, dim>> &old_saturation_grads,\\n\\u00a0     const std::vector<Tensor<1, dim>> &old_old_saturation_grads,\\n\\u00a0     const std::vector<Vector<double>> &present_darcy_values,\\n\\u00a0     const double                       global_max_u_F_prime,\\n\\u00a0     const double                       global_S_variation,\\n\\u00a0     const double                       cell_diameter) const\\n\\u00a0   {\\n\\u00a0     const double beta  = .4 * dim;\\n\\u00a0     const double alpha = 1;\\n\\u00a0 \\n\\u00a0     if (global_max_u_F_prime == 0)\\n\\u00a0       return 5e-3 * cell_diameter;\\n\\u00a0 \\n\\u00a0     const unsigned int n_q_points = old_saturation.size();\\n\\u00a0 \\n\\u00a0     double max_residual             = 0;\\n\\u00a0     double max_velocity_times_dF_dS = 0;\\n\\u00a0 \\n\\u00a0     const bool use_dF_dS = true;\\n\\u00a0 \\n\\u00a0     for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0       {\\n\\u00a0         Tensor<1, dim> u;\\n\\u00a0         for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0           u[d] = present_darcy_values[q](d);\\n\\u00a0 \\n\\u00a0         const double dS_dt = porosity *\\n\\u00a0                              (old_saturation[q] - old_old_saturation[q]) /\\n\\u00a0                              old_time_step;\\n\\u00a0 \\n\\u00a0         const double dF_dS = fractional_flow_derivative(\\n\\u00a0           (old_saturation[q] + old_old_saturation[q]) / 2.0, viscosity);\\n\\u00a0 \\n\\u00a0         const double u_grad_S =\\n\\u00a0           u * dF_dS * (old_saturation_grads[q] + old_old_saturation_grads[q]) /\\n\\u00a0           2.0;\\n\\u00a0 \\n\\u00a0         const double residual =\\n\\u00a0           std::abs((dS_dt + u_grad_S) *\\n\\u00a0                    std::pow((old_saturation[q] + old_old_saturation[q]) / 2,\\n\\u00a0                             alpha - 1.));\\n\\u00a0 \\n\\u00a0         max_residual = std::max(residual, max_residual);\\n\\u00a0         max_velocity_times_dF_dS =\\n\\u00a0           std::max(std::sqrt(u * u) * (use_dF_dS ? std::max(dF_dS, 1.) : 1),\\n\\u00a0                    max_velocity_times_dF_dS);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     const double c_R            = 1.0;\\n\\u00a0     const double global_scaling = c_R * porosity *\\n\\u00a0                                   (global_max_u_F_prime)*global_S_variation /\\n\\u00a0                                   std::pow(global_Omega_diameter, alpha - 2.);\\n\\u00a0 \\n\\u00a0     return (beta *\\n\\u00a0             (max_velocity_times_dF_dS)*std::min(cell_diameter,\\n\\u00a0                                                 std::pow(cell_diameter, alpha) *\\n\\u00a0                                                   max_residual /\\n\\u00a0                                                   global_scaling));\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nstd::sqrt::VectorizedArray< Number, width > sqrt(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6869\\nstd::pow::VectorizedArray< Number, width > pow(const ::VectorizedArray< Number, width > &, const Number p)Definition vectorization.h:6885\\nstd::abs::VectorizedArray< Number, width > abs(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6927\\n TwoPhaseFlowProblem<dim>::run\\nThis function is, besides solve(), the primary function of this program as it controls the time iteration as well as when the solution is written into output files and when to do mesh refinement.\\nWith the exception of the startup code that loops back to the beginning of the function through the goto start_time_iteration label, everything should be relatively straightforward. In any case, it mimics the corresponding function in step-31.\\n\\u00a0   template <int dim>\\n\\u00a0   void TwoPhaseFlowProblem<dim>::run()\\n\\u00a0   {\\n\\u00a0     const unsigned int initial_refinement     = (dim == 2 ? 5 : 2);\\n\\u00a0     const unsigned int n_pre_refinement_steps = (dim == 2 ? 3 : 2);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     GridGenerator::hyper_cube(triangulation, 0, 1);\\n\\u00a0     triangulation.refine_global(initial_refinement);\\n\\u00a0     global_Omega_diameter = GridTools::diameter(triangulation);\\n\\u00a0 \\n\\u00a0     setup_dofs();\\n\\u00a0 \\n\\u00a0     unsigned int pre_refinement_step = 0;\\n\\u00a0 \\n\\u00a0   start_time_iteration:\\n\\u00a0 \\n\\u00a0     VectorTools::project(saturation_dof_handler,\\n\\u00a0                          saturation_constraints,\\n\\u00a0                          QGauss<dim>(saturation_degree + 2),\\n\\u00a0                          SaturationInitialValues<dim>(),\\n\\u00a0                          old_saturation_solution);\\n\\u00a0 \\n\\u00a0     time_step = old_time_step = 0;\\n\\u00a0     current_macro_time_step = old_macro_time_step = 0;\\n\\u00a0 \\n\\u00a0     time = 0;\\n\\u00a0 \\n\\u00a0     do\\n\\u00a0       {\\n\\u00a0         std::cout << \\\"Timestep \\\" << timestep_number << \\\":  t=\\\" << time\\n\\u00a0                   << \\\", dt=\\\" << time_step << std::endl;\\n\\u00a0 \\n\\u00a0         solve();\\n\\u00a0 \\n\\u00a0         std::cout << std::endl;\\n\\u00a0 \\n\\u00a0         if (timestep_number % 200 == 0)\\n\\u00a0           output_results();\\n\\u00a0 \\n\\u00a0         if (timestep_number % 25 == 0)\\n\\u00a0           refine_mesh(initial_refinement,\\n\\u00a0                       initial_refinement + n_pre_refinement_steps);\\n\\u00a0 \\n\\u00a0         if ((timestep_number == 0) &&\\n\\u00a0             (pre_refinement_step < n_pre_refinement_steps))\\n\\u00a0           {\\n\\u00a0             ++pre_refinement_step;\\n\\u00a0             goto start_time_iteration;\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         time += time_step;\\n\\u00a0         ++timestep_number;\\n\\u00a0 \\n\\u00a0         old_old_saturation_solution = old_saturation_solution;\\n\\u00a0         old_saturation_solution     = saturation_solution;\\n\\u00a0       }\\n\\u00a0     while (time <= end_time);\\n\\u00a0   }\\n\\u00a0 } // namespace Step43\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nGridGenerator::hyper_cubevoid hyper_cube(Triangulation< dim, spacedim > &tria, const double left=0., const double right=1., const bool colorize=false)\\nGridTools::diameterdouble diameter(const Triangulation< dim, spacedim > &tria)Definition grid_tools_geometry.cc:43\\nVectorTools::projectvoid project(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const AffineConstraints< typename VectorType::value_type > &constraints, const Quadrature< dim > &quadrature, const Function< spacedim, typename VectorType::value_type > &function, VectorType &vec, const bool enforce_zero_boundary=false, const Quadrature< dim - 1 > &q_boundary=(dim > 1 ? QGauss< dim - 1 >(2) :Quadrature< dim - 1 >()), const bool project_to_boundary_first=false)\\n The main() function\\nThe main function looks almost the same as in all other programs. The need to initialize the MPI subsystem for a program that uses Trilinos \\u2013 even for programs that do not actually run in parallel \\u2013 is explained in step-31.\\n\\u00a0 int main(int argc, char *argv[])\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       using namespace dealii;\\n\\u00a0       using namespace Step43;\\n\\u00a0 \\n\\u00a0       Utilities::MPI::MPI_InitFinalize mpi_initialization(\\n\\u00a0         argc, argv, numbers::invalid_unsigned_int);\\n\\u00a0 \\nUtilities::MPI::MPI_InitFinalizeDefinition mpi.h:1081\\nnumbers::invalid_unsigned_intstatic const unsigned int invalid_unsigned_intDefinition types.h:220\\nThis program can only be run in serial. Otherwise, throw an exception.\\n\\u00a0       AssertThrow(Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) == 1,\\n\\u00a0                   ExcMessage(\\n\\u00a0                     \\\"This program can only be run in serial, use ./step-43\\\"));\\n\\u00a0 \\n\\u00a0       TwoPhaseFlowProblem<2> two_phase_flow_problem(1);\\n\\u00a0       two_phase_flow_problem.run();\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0 \\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\nAssertThrow#define AssertThrow(cond, exc)Definition exceptions.h:1739\\nUtilities::MPI::n_mpi_processesunsigned int n_mpi_processes(const MPI_Comm mpi_communicator)Definition mpi.cc:92\\n Results\\nThe output of this program is not really much different from that of step-21: it solves the same problem, after all. Of more importance are quantitative metrics such as the accuracy of the solution as well as the time needed to compute it. These are documented in detail in the two publications listed at the top of this page and we won't repeat them here.\\nThat said, no tutorial program is complete without a couple of good pictures, so here is some output of a run in 3d:\\n\\n\\n \\nVelocity vectors of flow through the porous medium with random permeability model. Streaming paths of high permeability and resulting high velocity are clearly visible. \\n\\n \\nStreamlines colored by the saturation along the streamline path. Blue streamlines indicate low saturations, i.e., the flow along these streamlines must be slow or else more fluid would have been transported along them. On the other hand, green paths indicate high velocities since the fluid front has already reached further into the domain. \\n\\n\\n\\n \\nStreamlines with a volume rendering of the saturation, showing how far the fluid front has advanced at this time. \\n\\n \\nSurface of the mesh showing the adaptive refinement along the front. \\n\\n\\n\\n Possibilities for extensions\\nThe primary objection one may have to this program is that it is still too slow: 3d computations on reasonably fine meshes are simply too expensive to be done routinely and with reasonably quick turn-around. This is similar to the situation we were in when we wrote step-31, from which this program has taken much inspiration. The solution is similar as it was there as well: We need to parallelize the program in a way similar to how we derived step-32 out of step-31. In fact, all of the techniques used in step-32 would be transferable to this program as well, making the program run on dozens or hundreds of processors immediately.\\nA different direction is to make the program more relevant to many other porous media applications. Specifically, one avenue is to go to the primary user of porous media flow simulators, namely the oil industry. There, applications in this area are dominated by multiphase flow (i.e., more than the two phases we have here), and the reactions they may have with each other (or any other way phases may exchange mass, such as through dissolution in and bubbling out of gas from the oil phase). Furthermore, the presence of gas often leads to compressibility effects of the fluid. Jointly, these effects are typically formulated in the widely-used \\\"black oil model\\\". True reactions between multiple phases also play a role in oil reservoir modeling when considering controlled burns of oil in the reservoir to raise pressure and temperature. These are much more complex problems, though, and left for future projects.\\nFinally, from a mathematical perspective, we have derived the criterion for re-computing the velocity/pressure solution at a given time step under the assumption that we want to compare the solution we would get at the current time step with that computed the last time we actually solved this system. However, in the program, whenever we did not re-compute the solution, we didn't just use the previously computed solution but instead extrapolated from the previous two times we solved the system. Consequently, the criterion was pessimistically stated: what we should really compare is the solution we would get at the current time step with the extrapolated one. Re-stating the theorem in this regard is left as an exercise.\\nThere are also other ways to extend the mathematical foundation of this program; for example, one may say that it isn't the velocity we care about, but in fact the saturation. Thus, one may ask whether the criterion we use here to decide whether \\\\(\\\\mathbf u\\\\) needs to be recomputed is appropriate; one may, for example, suggest that it is also important to decide whether (and by how much) a wrong velocity field in fact affects the solution of the saturation equation. This would then naturally lead to a sensitivity analysis.\\nFrom an algorithmic viewpoint, we have here used a criterion for refinement that is often used in engineering, namely by looking at the gradient of the solution. However, if you inspect the solution, you will find that it quickly leads to refinement almost everywhere, even in regions where it is clearly not necessary: frequently used therefore does not need to imply that it is a useful criterion to begin with. On the other hand, replacing this criterion by a different and better one should not be very difficult. For example, the KellyErrorEstimator class used in many other programs should certainly be applicable to the current problem as well.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2010 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Authors: Chih-Che Chueh, University of Victoria, 2010\\n *          Wolfgang Bangerth, Texas A&M University, 2010\\n */\\n \\n \\n \\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/utilities.h>\\n#include <deal.II/base/function.h>\\n#include <deal.II/base/tensor_function.h>\\n#include <deal.II/base/index_set.h>\\n \\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/solver_gmres.h>\\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/block_sparsity_pattern.h>\\n#include <deal.II/lac/affine_constraints.h>\\n \\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_tools.h>\\n \\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_renumbering.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_system.h>\\n#include <deal.II/fe/fe_values.h>\\n \\n#include <deal.II/numerics/vector_tools.h>\\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/solution_transfer.h>\\n \\n#include <deal.II/lac/trilinos_sparse_matrix.h>\\n#include <deal.II/lac/trilinos_block_sparse_matrix.h>\\n#include <deal.II/lac/trilinos_vector.h>\\n#include <deal.II/lac/trilinos_parallel_block_vector.h>\\n#include <deal.II/lac/trilinos_precondition.h>\\n \\n#include <iostream>\\n#include <fstream>\\n#include <memory>\\n \\n \\nnamespace Step43\\n{\\n using namespace dealii;\\n \\n \\n \\n template <int dim>\\n class PressureBoundaryValues : public Function<dim>\\n  {\\n public:\\n    PressureBoundaryValues()\\n      : Function<dim>(1)\\n    {}\\n \\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n  };\\n \\n \\n template <int dim>\\n double\\n  PressureBoundaryValues<dim>::value(const Point<dim> &p,\\n const unsigned int /*component*/) const\\n {\\n return 1 - p[0];\\n  }\\n \\n \\n template <int dim>\\n class SaturationBoundaryValues : public Function<dim>\\n  {\\n public:\\n    SaturationBoundaryValues()\\n      : Function<dim>(1)\\n    {}\\n \\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n  };\\n \\n \\n \\n template <int dim>\\n double\\n  SaturationBoundaryValues<dim>::value(const Point<dim> &p,\\n const unsigned int /*component*/) const\\n {\\n if (p[0] == 0)\\n return 1;\\n else\\n return 0;\\n  }\\n \\n \\n template <int dim>\\n class SaturationInitialValues : public Function<dim>\\n  {\\n public:\\n    SaturationInitialValues()\\n      : Function<dim>(1)\\n    {}\\n \\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n \\n virtual void vector_value(const Point<dim> &p,\\n Vector<double>   &value) const override;\\n  };\\n \\n \\n template <int dim>\\n double\\n  SaturationInitialValues<dim>::value(const Point<dim> & /*p*/,\\n const unsigned int /*component*/) const\\n {\\n return 0.2;\\n  }\\n \\n \\n template <int dim>\\n void SaturationInitialValues<dim>::vector_value(const Point<dim> &p,\\n Vector<double> &values) const\\n {\\n for (unsigned int c = 0; c < this->n_components; ++c)\\n      values(c) = SaturationInitialValues<dim>::value(p, c);\\n  }\\n \\n \\n \\n namespace SingleCurvingCrack\\n  {\\n template <int dim>\\n class KInverse : public TensorFunction<2, dim>\\n    {\\n public:\\n      KInverse()\\n        : TensorFunction<2, dim>()\\n      {}\\n \\n virtual void\\n      value_list(const std::vector<Point<dim>> &points,\\n                 std::vector<Tensor<2, dim>>   &values) const override;\\n    };\\n \\n \\n template <int dim>\\n void KInverse<dim>::value_list(const std::vector<Point<dim>> &points,\\n                                   std::vector<Tensor<2, dim>>   &values) const\\n {\\n AssertDimension(points.size(), values.size());\\n \\n for (unsigned int p = 0; p < points.size(); ++p)\\n        {\\n          values[p].clear();\\n \\n const double distance_to_flowline =\\n            std::fabs(points[p][1] - 0.5 - 0.1 * std::sin(10 * points[p][0]));\\n \\n const double permeability =\\n std::max(std::exp(-(distance_to_flowline * distance_to_flowline) /\\n                              (0.1 * 0.1)),\\n                     0.01);\\n \\n for (unsigned int d = 0; d < dim; ++d)\\n            values[p][d][d] = 1. / permeability;\\n        }\\n    }\\n  } // namespace SingleCurvingCrack\\n \\n \\n namespace RandomMedium\\n  {\\n template <int dim>\\n class KInverse : public TensorFunction<2, dim>\\n    {\\n public:\\n      KInverse()\\n        : TensorFunction<2, dim>()\\n      {}\\n \\n virtual void\\n      value_list(const std::vector<Point<dim>> &points,\\n                 std::vector<Tensor<2, dim>>   &values) const override;\\n \\n private:\\n static std::vector<Point<dim>> centers;\\n    };\\n \\n \\n \\n template <int dim>\\n    std::vector<Point<dim>> KInverse<dim>::centers = []() {\\n const unsigned int N =\\n        (dim == 2 ? 40 : (dim == 3 ? 100 : throw ExcNotImplemented()));\\n \\n      std::vector<Point<dim>> centers_list(N);\\n for (unsigned int i = 0; i < N; ++i)\\n for (unsigned int d = 0; d < dim; ++d)\\n          centers_list[i][d] = static_cast<double>(rand()) / RAND_MAX;\\n \\n return centers_list;\\n    }();\\n \\n \\n \\n template <int dim>\\n void KInverse<dim>::value_list(const std::vector<Point<dim>> &points,\\n                                   std::vector<Tensor<2, dim>>   &values) const\\n {\\n AssertDimension(points.size(), values.size());\\n \\n for (unsigned int p = 0; p < points.size(); ++p)\\n        {\\n          values[p].clear();\\n \\n double permeability = 0;\\n for (unsigned int i = 0; i < centers.size(); ++i)\\n            permeability +=\\n std::exp(-(points[p] - centers[i]).norm_square() / (0.05 * 0.05));\\n \\n const double normalized_permeability =\\n std::min(std::max(permeability, 0.01), 4.);\\n \\n for (unsigned int d = 0; d < dim; ++d)\\n            values[p][d][d] = 1. / normalized_permeability;\\n        }\\n    }\\n  } // namespace RandomMedium\\n \\n \\n \\n double mobility_inverse(const double S, const double viscosity)\\n  {\\n return 1.0 / (1.0 / viscosity * S * S + (1 - S) * (1 - S));\\n  }\\n \\n \\n double fractional_flow(const double S, const double viscosity)\\n  {\\n Assert((S >= 0) && (S <= 1),\\n           ExcMessage(\\\"Saturation is outside its physically valid range.\\\"));\\n \\n return S * S / (S * S + viscosity * (1 - S) * (1 - S));\\n  }\\n \\n \\n double fractional_flow_derivative(const double S, const double viscosity)\\n  {\\n Assert((S >= 0) && (S <= 1),\\n           ExcMessage(\\\"Saturation is outside its physically valid range.\\\"));\\n \\n const double temp = (S * S + viscosity * (1 - S) * (1 - S));\\n \\n const double numerator =\\n      2.0 * S * temp - S * S * (2.0 * S - 2.0 * viscosity * (1 - S));\\n const double denominator = Utilities::fixed_power<2>(temp);\\n \\n const double F_prime = numerator / denominator;\\n \\n Assert(F_prime >= 0, ExcInternalError());\\n \\n return F_prime;\\n  }\\n \\n \\n \\n namespace LinearSolvers\\n  {\\n template <class MatrixType, class PreconditionerType>\\n class InverseMatrix : public Subscriptor\\n    {\\n public:\\n      InverseMatrix(const MatrixType         &m,\\n const PreconditionerType &preconditioner);\\n \\n \\n template <typename VectorType>\\n void vmult(VectorType &dst, const VectorType &src) const;\\n \\n private:\\n const SmartPointer<const MatrixType> matrix;\\n const PreconditionerType            &preconditioner;\\n    };\\n \\n \\n template <class MatrixType, class PreconditionerType>\\n    InverseMatrix<MatrixType, PreconditionerType>::InverseMatrix(\\n const MatrixType         &m,\\n const PreconditionerType &preconditioner)\\n      : matrix(&m)\\n      , preconditioner(preconditioner)\\n    {}\\n \\n \\n \\n template <class MatrixType, class PreconditionerType>\\n template <typename VectorType>\\n void InverseMatrix<MatrixType, PreconditionerType>::vmult(\\n      VectorType       &dst,\\n const VectorType &src) const\\n {\\n SolverControl        solver_control(src.size(), 1e-7 * src.l2_norm());\\n SolverCG<VectorType> cg(solver_control);\\n \\n      dst = 0;\\n \\n try\\n        {\\n          cg.solve(*matrix, dst, src, preconditioner);\\n        }\\n catch (std::exception &e)\\n        {\\n Assert(false, ExcMessage(e.what()));\\n        }\\n    }\\n \\n template <class PreconditionerTypeA, class PreconditionerTypeMp>\\n class BlockSchurPreconditioner : public Subscriptor\\n    {\\n public:\\n      BlockSchurPreconditioner(\\n const TrilinosWrappers::BlockSparseMatrix &S,\\n const InverseMatrix<TrilinosWrappers::SparseMatrix,\\n                            PreconditionerTypeMp> &Mpinv,\\n const PreconditionerTypeA                 &Apreconditioner);\\n \\n void vmult(TrilinosWrappers::MPI::BlockVector       &dst,\\n const TrilinosWrappers::MPI::BlockVector &src) const;\\n \\n private:\\n const SmartPointer<const TrilinosWrappers::BlockSparseMatrix>\\n        darcy_matrix;\\n const SmartPointer<const InverseMatrix<TrilinosWrappers::SparseMatrix,\\n                                             PreconditionerTypeMp>>\\n                                 m_inverse;\\n const PreconditionerTypeA &a_preconditioner;\\n \\n mutable TrilinosWrappers::MPI::Vector tmp;\\n    };\\n \\n \\n \\n template <class PreconditionerTypeA, class PreconditionerTypeMp>\\n    BlockSchurPreconditioner<PreconditionerTypeA, PreconditionerTypeMp>::\\n      BlockSchurPreconditioner(\\n const TrilinosWrappers::BlockSparseMatrix &S,\\n const InverseMatrix<TrilinosWrappers::SparseMatrix,\\n                            PreconditionerTypeMp> &Mpinv,\\n const PreconditionerTypeA                 &Apreconditioner)\\n      : darcy_matrix(&S)\\n      , m_inverse(&Mpinv)\\n      , a_preconditioner(Apreconditioner)\\n      , tmp(complete_index_set(darcy_matrix->block(1, 1).m()))\\n    {}\\n \\n \\n template <class PreconditionerTypeA, class PreconditionerTypeMp>\\n void\\n    BlockSchurPreconditioner<PreconditionerTypeA, PreconditionerTypeMp>::vmult(\\n TrilinosWrappers::MPI::BlockVector       &dst,\\n const TrilinosWrappers::MPI::BlockVector &src) const\\n {\\n      a_preconditioner.vmult(dst.block(0), src.block(0));\\n      darcy_matrix->block(1, 0).residual(tmp, dst.block(0), src.block(1));\\n      tmp *= -1;\\n      m_inverse->vmult(dst.block(1), tmp);\\n    }\\n  } // namespace LinearSolvers\\n \\n \\n \\n template <int dim>\\n class TwoPhaseFlowProblem\\n  {\\n public:\\n    TwoPhaseFlowProblem(const unsigned int degree);\\n void run();\\n \\n private:\\n void setup_dofs();\\n void assemble_darcy_preconditioner();\\n void build_darcy_preconditioner();\\n void assemble_darcy_system();\\n void assemble_saturation_system();\\n void assemble_saturation_matrix();\\n void assemble_saturation_rhs();\\n void assemble_saturation_rhs_cell_term(\\n const FEValues<dim>                        &saturation_fe_values,\\n const FEValues<dim>                        &darcy_fe_values,\\n const double                                global_max_u_F_prime,\\n const double                                global_S_variation,\\n const std::vector<types::global_dof_index> &local_dof_indices);\\n void assemble_saturation_rhs_boundary_term(\\n const FEFaceValues<dim>                    &saturation_fe_face_values,\\n const FEFaceValues<dim>                    &darcy_fe_face_values,\\n const std::vector<types::global_dof_index> &local_dof_indices);\\n void solve();\\n void refine_mesh(const unsigned int min_grid_level,\\n const unsigned int max_grid_level);\\n void output_results() const;\\n \\n double                    get_max_u_F_prime() const;\\n    std::pair<double, double> get_extrapolated_saturation_range() const;\\n bool   determine_whether_to_solve_for_pressure_and_velocity() const;\\n void   project_back_saturation();\\n double compute_viscosity(\\n const std::vector<double>         &old_saturation,\\n const std::vector<double>         &old_old_saturation,\\n const std::vector<Tensor<1, dim>> &old_saturation_grads,\\n const std::vector<Tensor<1, dim>> &old_old_saturation_grads,\\n const std::vector<Vector<double>> &present_darcy_values,\\n const double                       global_max_u_F_prime,\\n const double                       global_S_variation,\\n const double                       cell_diameter) const;\\n \\n \\n Triangulation<dim> triangulation;\\n double             global_Omega_diameter;\\n \\n const unsigned int degree;\\n \\n const unsigned int        darcy_degree;\\n const FESystem<dim>       darcy_fe;\\n DoFHandler<dim>           darcy_dof_handler;\\n AffineConstraints<double> darcy_constraints;\\n \\n AffineConstraints<double> darcy_preconditioner_constraints;\\n \\n TrilinosWrappers::BlockSparseMatrix darcy_matrix;\\n TrilinosWrappers::BlockSparseMatrix darcy_preconditioner_matrix;\\n \\n TrilinosWrappers::MPI::BlockVector darcy_solution;\\n TrilinosWrappers::MPI::BlockVector darcy_rhs;\\n \\n TrilinosWrappers::MPI::BlockVector last_computed_darcy_solution;\\n TrilinosWrappers::MPI::BlockVector second_last_computed_darcy_solution;\\n \\n \\n const unsigned int        saturation_degree;\\n const FE_Q<dim>           saturation_fe;\\n DoFHandler<dim>           saturation_dof_handler;\\n AffineConstraints<double> saturation_constraints;\\n \\n TrilinosWrappers::SparseMatrix saturation_matrix;\\n \\n \\n TrilinosWrappers::MPI::Vector saturation_solution;\\n TrilinosWrappers::MPI::Vector old_saturation_solution;\\n TrilinosWrappers::MPI::Vector old_old_saturation_solution;\\n TrilinosWrappers::MPI::Vector saturation_rhs;\\n \\n TrilinosWrappers::MPI::Vector\\n      saturation_matching_last_computed_darcy_solution;\\n \\n const double saturation_refinement_threshold;\\n \\n double       time;\\n const double end_time;\\n \\n double current_macro_time_step;\\n double old_macro_time_step;\\n \\n double       time_step;\\n double       old_time_step;\\n unsigned int timestep_number;\\n \\n const double viscosity;\\n const double porosity;\\n const double AOS_threshold;\\n \\n    std::shared_ptr<TrilinosWrappers::PreconditionIC> top_left_preconditioner;\\n    std::shared_ptr<TrilinosWrappers::PreconditionIC>\\n      bottom_right_preconditioner;\\n \\n bool rebuild_saturation_matrix;\\n \\n const RandomMedium::KInverse<dim> k_inverse;\\n  };\\n \\n \\n \\n template <int dim>\\n  TwoPhaseFlowProblem<dim>::TwoPhaseFlowProblem(const unsigned int degree)\\n    : triangulation(Triangulation<dim>::maximum_smoothing)\\n    , global_Omega_diameter(std::numeric_limits<double>::quiet_NaN())\\n    , degree(degree)\\n    , darcy_degree(degree)\\n    , darcy_fe(FE_Q<dim>(darcy_degree + 1) ^ dim, FE_Q<dim>(darcy_degree))\\n    , darcy_dof_handler(triangulation)\\n    ,\\n \\n    saturation_degree(degree + 1)\\n    , saturation_fe(saturation_degree)\\n    , saturation_dof_handler(triangulation)\\n    ,\\n \\n    saturation_refinement_threshold(0.5)\\n    ,\\n \\n    time(0)\\n    , end_time(10)\\n    ,\\n \\n    current_macro_time_step(0)\\n    , old_macro_time_step(0)\\n    ,\\n \\n    time_step(0)\\n    , old_time_step(0)\\n    , timestep_number(0)\\n    , viscosity(0.2)\\n    , porosity(1.0)\\n    , AOS_threshold(3.0)\\n    ,\\n \\n    rebuild_saturation_matrix(true)\\n  {}\\n \\n \\n \\n template <int dim>\\n void TwoPhaseFlowProblem<dim>::setup_dofs()\\n  {\\n    std::vector<unsigned int> darcy_block_component(dim + 1, 0);\\n    darcy_block_component[dim] = 1;\\n    {\\n      darcy_dof_handler.distribute_dofs(darcy_fe);\\n DoFRenumbering::Cuthill_McKee(darcy_dof_handler);\\n DoFRenumbering::component_wise(darcy_dof_handler, darcy_block_component);\\n \\n      darcy_constraints.clear();\\n DoFTools::make_hanging_node_constraints(darcy_dof_handler,\\n                                              darcy_constraints);\\n      darcy_constraints.close();\\n    }\\n    {\\n      saturation_dof_handler.distribute_dofs(saturation_fe);\\n \\n      saturation_constraints.clear();\\n DoFTools::make_hanging_node_constraints(saturation_dof_handler,\\n                                              saturation_constraints);\\n      saturation_constraints.close();\\n    }\\n    {\\n      darcy_preconditioner_constraints.clear();\\n \\n const FEValuesExtractors::Scalar pressure(dim);\\n \\n DoFTools::make_hanging_node_constraints(darcy_dof_handler,\\n                                              darcy_preconditioner_constraints);\\n DoFTools::make_zero_boundary_constraints(darcy_dof_handler,\\n                                               darcy_preconditioner_constraints,\\n                                               darcy_fe.component_mask(\\n                                                 pressure));\\n \\n      darcy_preconditioner_constraints.close();\\n    }\\n \\n \\n const std::vector<types::global_dof_index> darcy_dofs_per_block =\\n DoFTools::count_dofs_per_fe_block(darcy_dof_handler,\\n                                        darcy_block_component);\\n const types::global_dof_index n_u = darcy_dofs_per_block[0],\\n                                  n_p = darcy_dofs_per_block[1],\\n                                  n_s = saturation_dof_handler.n_dofs();\\n \\n    std::cout << \\\"Number of active cells: \\\" << triangulation.n_active_cells()\\n              << \\\" (on \\\" << triangulation.n_levels() << \\\" levels)\\\" << std::endl\\n              << \\\"Number of degrees of freedom: \\\" << n_u + n_p + n_s << \\\" (\\\"\\n              << n_u << '+' << n_p << '+' << n_s << ')' << std::endl\\n              << std::endl;\\n \\n    {\\n      darcy_matrix.clear();\\n \\n BlockDynamicSparsityPattern dsp(darcy_dofs_per_block,\\n                                      darcy_dofs_per_block);\\n \\n Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);\\n for (unsigned int c = 0; c < dim + 1; ++c)\\n for (unsigned int d = 0; d < dim + 1; ++d)\\n if (!((c == dim) && (d == dim)))\\n            coupling[c][d] = DoFTools::always;\\n else\\n            coupling[c][d] = DoFTools::none;\\n \\n \\n DoFTools::make_sparsity_pattern(\\n        darcy_dof_handler, coupling, dsp, darcy_constraints, false);\\n \\n      darcy_matrix.reinit(dsp);\\n    }\\n \\n    {\\n      top_left_preconditioner.reset();\\n      bottom_right_preconditioner.reset();\\n      darcy_preconditioner_matrix.clear();\\n \\n BlockDynamicSparsityPattern dsp(darcy_dofs_per_block,\\n                                      darcy_dofs_per_block);\\n \\n Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);\\n for (unsigned int c = 0; c < dim + 1; ++c)\\n for (unsigned int d = 0; d < dim + 1; ++d)\\n if (c == d)\\n            coupling[c][d] = DoFTools::always;\\n else\\n            coupling[c][d] = DoFTools::none;\\n \\n DoFTools::make_sparsity_pattern(\\n        darcy_dof_handler, coupling, dsp, darcy_constraints, false);\\n \\n      darcy_preconditioner_matrix.reinit(dsp);\\n    }\\n \\n \\n    {\\n      saturation_matrix.clear();\\n \\n DynamicSparsityPattern dsp(n_s, n_s);\\n \\n DoFTools::make_sparsity_pattern(saturation_dof_handler,\\n                                      dsp,\\n                                      saturation_constraints,\\n false);\\n \\n \\n      saturation_matrix.reinit(dsp);\\n    }\\n \\n const std::vector<IndexSet> darcy_partitioning = {complete_index_set(n_u),\\n complete_index_set(n_p)};\\n \\n    darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD);\\n \\n    last_computed_darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD);\\n \\n    second_last_computed_darcy_solution.reinit(darcy_partitioning,\\n                                               MPI_COMM_WORLD);\\n \\n    darcy_rhs.reinit(darcy_partitioning, MPI_COMM_WORLD);\\n \\n const IndexSet saturation_partitioning = complete_index_set(n_s);\\n    saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);\\n    old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);\\n    old_old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);\\n \\n    saturation_matching_last_computed_darcy_solution.reinit(\\n      saturation_partitioning, MPI_COMM_WORLD);\\n \\n    saturation_rhs.reinit(saturation_partitioning, MPI_COMM_WORLD);\\n  }\\n \\n \\n \\n \\n \\n template <int dim>\\n void TwoPhaseFlowProblem<dim>::assemble_darcy_preconditioner()\\n  {\\n    std::cout << \\\"   Rebuilding darcy preconditioner...\\\" << std::endl;\\n \\n    darcy_preconditioner_matrix = 0;\\n \\n const QGauss<dim> quadrature_formula(darcy_degree + 2);\\n FEValues<dim>     darcy_fe_values(darcy_fe,\\n                                  quadrature_formula,\\n update_JxW_values | update_values |\\n update_gradients |\\n update_quadrature_points);\\n FEValues<dim>     saturation_fe_values(saturation_fe,\\n                                       quadrature_formula,\\n update_values);\\n \\n const unsigned int dofs_per_cell = darcy_fe.n_dofs_per_cell();\\n const unsigned int n_q_points    = quadrature_formula.size();\\n \\n    std::vector<Tensor<2, dim>> k_inverse_values(n_q_points);\\n \\n    std::vector<double> old_saturation_values(n_q_points);\\n \\n FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);\\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n    std::vector<Tensor<1, dim>> phi_u(dofs_per_cell);\\n    std::vector<Tensor<1, dim>> grad_phi_p(dofs_per_cell);\\n \\n const FEValuesExtractors::Vector velocities(0);\\n const FEValuesExtractors::Scalar pressure(dim);\\n \\n auto       cell            = darcy_dof_handler.begin_active();\\n const auto endc            = darcy_dof_handler.end();\\n auto       saturation_cell = saturation_dof_handler.begin_active();\\n \\n for (; cell != endc; ++cell, ++saturation_cell)\\n      {\\n        darcy_fe_values.reinit(cell);\\n        saturation_fe_values.reinit(saturation_cell);\\n \\n        local_matrix = 0;\\n \\n        saturation_fe_values.get_function_values(old_saturation_solution,\\n                                                 old_saturation_values);\\n \\n        k_inverse.value_list(darcy_fe_values.get_quadrature_points(),\\n                             k_inverse_values);\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n          {\\n const double old_s = old_saturation_values[q];\\n \\n const double inverse_mobility = mobility_inverse(old_s, viscosity);\\n const double mobility         = 1.0 / inverse_mobility;\\n const Tensor<2, dim> permeability = invert(k_inverse_values[q]);\\n \\n for (unsigned int k = 0; k < dofs_per_cell; ++k)\\n              {\\n                phi_u[k]      = darcy_fe_values[velocities].value(k, q);\\n                grad_phi_p[k] = darcy_fe_values[pressure].gradient(k, q);\\n              }\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n                {\\n                  local_matrix(i, j) +=\\n                    (k_inverse_values[q] * inverse_mobility * phi_u[i] *\\n                       phi_u[j] +\\n                     permeability * mobility * grad_phi_p[i] * grad_phi_p[j]) *\\n                    darcy_fe_values.JxW(q);\\n                }\\n          }\\n \\n        cell->get_dof_indices(local_dof_indices);\\n        darcy_preconditioner_constraints.distribute_local_to_global(\\n          local_matrix, local_dof_indices, darcy_preconditioner_matrix);\\n      }\\n  }\\n \\n \\n \\n template <int dim>\\n void TwoPhaseFlowProblem<dim>::build_darcy_preconditioner()\\n  {\\n    assemble_darcy_preconditioner();\\n \\n    top_left_preconditioner =\\n      std::make_shared<TrilinosWrappers::PreconditionIC>();\\n    top_left_preconditioner->initialize(\\n      darcy_preconditioner_matrix.block(0, 0));\\n \\n    bottom_right_preconditioner =\\n      std::make_shared<TrilinosWrappers::PreconditionIC>();\\n    bottom_right_preconditioner->initialize(\\n      darcy_preconditioner_matrix.block(1, 1));\\n  }\\n \\n \\n \\n template <int dim>\\n void TwoPhaseFlowProblem<dim>::assemble_darcy_system()\\n  {\\n    darcy_matrix = 0;\\n    darcy_rhs    = 0;\\n \\n const QGauss<dim>     quadrature_formula(darcy_degree + 2);\\n const QGauss<dim - 1> face_quadrature_formula(darcy_degree + 2);\\n \\n FEValues<dim> darcy_fe_values(darcy_fe,\\n                                  quadrature_formula,\\n update_values | update_gradients |\\n update_quadrature_points |\\n update_JxW_values);\\n \\n FEValues<dim> saturation_fe_values(saturation_fe,\\n                                       quadrature_formula,\\n update_values);\\n \\n FEFaceValues<dim> darcy_fe_face_values(darcy_fe,\\n                                           face_quadrature_formula,\\n update_values |\\n update_normal_vectors |\\n update_quadrature_points |\\n update_JxW_values);\\n \\n const unsigned int dofs_per_cell = darcy_fe.n_dofs_per_cell();\\n \\n const unsigned int n_q_points      = quadrature_formula.size();\\n const unsigned int n_face_q_points = face_quadrature_formula.size();\\n \\n FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);\\n Vector<double>     local_rhs(dofs_per_cell);\\n \\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n const Functions::ZeroFunction<dim> pressure_right_hand_side;\\n const PressureBoundaryValues<dim>  pressure_boundary_values;\\n \\n    std::vector<double>         pressure_rhs_values(n_q_points);\\n    std::vector<double>         boundary_values(n_face_q_points);\\n    std::vector<Tensor<2, dim>> k_inverse_values(n_q_points);\\n \\n    std::vector<double> old_saturation_values(n_q_points);\\n \\n    std::vector<Tensor<1, dim>> phi_u(dofs_per_cell);\\n    std::vector<double>         div_phi_u(dofs_per_cell);\\n    std::vector<double>         phi_p(dofs_per_cell);\\n \\n const FEValuesExtractors::Vector velocities(0);\\n const FEValuesExtractors::Scalar pressure(dim);\\n \\n auto       cell            = darcy_dof_handler.begin_active();\\n const auto endc            = darcy_dof_handler.end();\\n auto       saturation_cell = saturation_dof_handler.begin_active();\\n \\n for (; cell != endc; ++cell, ++saturation_cell)\\n      {\\n        darcy_fe_values.reinit(cell);\\n        saturation_fe_values.reinit(saturation_cell);\\n \\n        local_matrix = 0;\\n        local_rhs    = 0;\\n \\n        saturation_fe_values.get_function_values(old_saturation_solution,\\n                                                 old_saturation_values);\\n \\n        pressure_right_hand_side.value_list(\\n          darcy_fe_values.get_quadrature_points(), pressure_rhs_values);\\n        k_inverse.value_list(darcy_fe_values.get_quadrature_points(),\\n                             k_inverse_values);\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n          {\\n for (unsigned int k = 0; k < dofs_per_cell; ++k)\\n              {\\n                phi_u[k]     = darcy_fe_values[velocities].value(k, q);\\n                div_phi_u[k] = darcy_fe_values[velocities].divergence(k, q);\\n                phi_p[k]     = darcy_fe_values[pressure].value(k, q);\\n              }\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n              {\\n const double old_s = old_saturation_values[q];\\n for (unsigned int j = 0; j <= i; ++j)\\n                  {\\n                    local_matrix(i, j) +=\\n                      (phi_u[i] * k_inverse_values[q] *\\n                         mobility_inverse(old_s, viscosity) * phi_u[j] -\\n                       div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *\\n                      darcy_fe_values.JxW(q);\\n                  }\\n \\n                local_rhs(i) +=\\n                  (-phi_p[i] * pressure_rhs_values[q]) * darcy_fe_values.JxW(q);\\n              }\\n          }\\n \\n for (const auto &face : cell->face_iterators())\\n          if (face->at_boundary())\\n            {\\n              darcy_fe_face_values.reinit(cell, face);\\n \\n              pressure_boundary_values.value_list(\\n                darcy_fe_face_values.get_quadrature_points(), boundary_values);\\n \\n for (unsigned int q = 0; q < n_face_q_points; ++q)\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n                  {\\n const Tensor<1, dim> phi_i_u =\\n                      darcy_fe_face_values[velocities].value(i, q);\\n \\n                    local_rhs(i) +=\\n                      -(phi_i_u * darcy_fe_face_values.normal_vector(q) *\\n                        boundary_values[q] * darcy_fe_face_values.JxW(q));\\n                  }\\n            }\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int j = i + 1; j < dofs_per_cell; ++j)\\n            local_matrix(i, j) = local_matrix(j, i);\\n \\n        cell->get_dof_indices(local_dof_indices);\\n \\n        darcy_constraints.distribute_local_to_global(\\n          local_matrix, local_rhs, local_dof_indices, darcy_matrix, darcy_rhs);\\n      }\\n  }\\n \\n \\n \\n template <int dim>\\n void TwoPhaseFlowProblem<dim>::assemble_saturation_system()\\n  {\\n if (rebuild_saturation_matrix == true)\\n      {\\n        saturation_matrix = 0;\\n        assemble_saturation_matrix();\\n      }\\n \\n    saturation_rhs = 0;\\n    assemble_saturation_rhs();\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void TwoPhaseFlowProblem<dim>::assemble_saturation_matrix()\\n  {\\n const QGauss<dim> quadrature_formula(saturation_degree + 2);\\n \\n FEValues<dim> saturation_fe_values(saturation_fe,\\n                                       quadrature_formula,\\n update_values | update_JxW_values);\\n \\n const unsigned int dofs_per_cell = saturation_fe.n_dofs_per_cell();\\n \\n const unsigned int n_q_points = quadrature_formula.size();\\n \\n FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);\\n Vector<double>     local_rhs(dofs_per_cell);\\n \\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n for (const auto &cell : saturation_dof_handler.active_cell_iterators())\\n      {\\n        saturation_fe_values.reinit(cell);\\n        local_matrix = 0;\\n        local_rhs    = 0;\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n            {\\n const double phi_i_s = saturation_fe_values.shape_value(i, q);\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n                {\\n const double phi_j_s = saturation_fe_values.shape_value(j, q);\\n                  local_matrix(i, j) +=\\n                    porosity * phi_i_s * phi_j_s * saturation_fe_values.JxW(q);\\n                }\\n            }\\n        cell->get_dof_indices(local_dof_indices);\\n \\n        saturation_constraints.distribute_local_to_global(local_matrix,\\n                                                          local_dof_indices,\\n                                                          saturation_matrix);\\n      }\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void TwoPhaseFlowProblem<dim>::assemble_saturation_rhs()\\n  {\\n const QGauss<dim>     quadrature_formula(saturation_degree + 2);\\n const QGauss<dim - 1> face_quadrature_formula(saturation_degree + 2);\\n \\n FEValues<dim> saturation_fe_values(saturation_fe,\\n                                       quadrature_formula,\\n update_values | update_gradients |\\n update_quadrature_points |\\n update_JxW_values);\\n FEValues<dim> darcy_fe_values(darcy_fe, quadrature_formula, update_values);\\n FEFaceValues<dim> saturation_fe_face_values(saturation_fe,\\n                                                face_quadrature_formula,\\n update_values |\\n update_normal_vectors |\\n update_quadrature_points |\\n update_JxW_values);\\n FEFaceValues<dim> darcy_fe_face_values(darcy_fe,\\n                                           face_quadrature_formula,\\n update_values);\\n FEFaceValues<dim> saturation_fe_face_values_neighbor(\\n      saturation_fe, face_quadrature_formula, update_values);\\n \\n const unsigned int dofs_per_cell =\\n      saturation_dof_handler.get_fe().n_dofs_per_cell();\\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n const double                    global_max_u_F_prime = get_max_u_F_prime();\\n const std::pair<double, double> global_S_range =\\n      get_extrapolated_saturation_range();\\n const double global_S_variation =\\n      global_S_range.second - global_S_range.first;\\n \\n auto       cell       = saturation_dof_handler.begin_active();\\n const auto endc       = saturation_dof_handler.end();\\n auto       darcy_cell = darcy_dof_handler.begin_active();\\n for (; cell != endc; ++cell, ++darcy_cell)\\n      {\\n        saturation_fe_values.reinit(cell);\\n        darcy_fe_values.reinit(darcy_cell);\\n \\n        cell->get_dof_indices(local_dof_indices);\\n \\n        assemble_saturation_rhs_cell_term(saturation_fe_values,\\n                                          darcy_fe_values,\\n                                          global_max_u_F_prime,\\n                                          global_S_variation,\\n                                          local_dof_indices);\\n \\n for (const auto &face : cell->face_iterators())\\n          if (face->at_boundary())\\n            {\\n              darcy_fe_face_values.reinit(darcy_cell, face);\\n              saturation_fe_face_values.reinit(cell, face);\\n              assemble_saturation_rhs_boundary_term(saturation_fe_face_values,\\n                                                    darcy_fe_face_values,\\n                                                    local_dof_indices);\\n            }\\n      }\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_cell_term(\\n const FEValues<dim>                        &saturation_fe_values,\\n const FEValues<dim>                        &darcy_fe_values,\\n const double                                global_max_u_F_prime,\\n const double                                global_S_variation,\\n const std::vector<types::global_dof_index> &local_dof_indices)\\n  {\\n const unsigned int dofs_per_cell = saturation_fe_values.dofs_per_cell;\\n const unsigned int n_q_points    = saturation_fe_values.n_quadrature_points;\\n \\n    std::vector<double>         old_saturation_solution_values(n_q_points);\\n    std::vector<double>         old_old_saturation_solution_values(n_q_points);\\n    std::vector<Tensor<1, dim>> old_grad_saturation_solution_values(n_q_points);\\n    std::vector<Tensor<1, dim>> old_old_grad_saturation_solution_values(\\n      n_q_points);\\n    std::vector<Vector<double>> present_darcy_solution_values(\\n      n_q_points, Vector<double>(dim + 1));\\n \\n    saturation_fe_values.get_function_values(old_saturation_solution,\\n                                             old_saturation_solution_values);\\n    saturation_fe_values.get_function_values(\\n      old_old_saturation_solution, old_old_saturation_solution_values);\\n    saturation_fe_values.get_function_gradients(\\n      old_saturation_solution, old_grad_saturation_solution_values);\\n    saturation_fe_values.get_function_gradients(\\n      old_old_saturation_solution, old_old_grad_saturation_solution_values);\\n    darcy_fe_values.get_function_values(darcy_solution,\\n                                        present_darcy_solution_values);\\n \\n const double nu =\\n      compute_viscosity(old_saturation_solution_values,\\n                        old_old_saturation_solution_values,\\n                        old_grad_saturation_solution_values,\\n                        old_old_grad_saturation_solution_values,\\n                        present_darcy_solution_values,\\n                        global_max_u_F_prime,\\n                        global_S_variation,\\n                        saturation_fe_values.get_cell()->diameter());\\n \\n Vector<double> local_rhs(dofs_per_cell);\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n        {\\n const double   old_s = old_saturation_solution_values[q];\\n Tensor<1, dim> present_u;\\n for (unsigned int d = 0; d < dim; ++d)\\n            present_u[d] = present_darcy_solution_values[q](d);\\n \\n const double         phi_i_s = saturation_fe_values.shape_value(i, q);\\n const Tensor<1, dim> grad_phi_i_s =\\n            saturation_fe_values.shape_grad(i, q);\\n \\n          local_rhs(i) +=\\n            (time_step * fractional_flow(old_s, viscosity) * present_u *\\n               grad_phi_i_s -\\n             time_step * nu * old_grad_saturation_solution_values[q] *\\n               grad_phi_i_s +\\n             porosity * old_s * phi_i_s) *\\n            saturation_fe_values.JxW(q);\\n        }\\n \\n    saturation_constraints.distribute_local_to_global(local_rhs,\\n                                                      local_dof_indices,\\n                                                      saturation_rhs);\\n  }\\n \\n \\n \\n template <int dim>\\n void TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_boundary_term(\\n const FEFaceValues<dim>                    &saturation_fe_face_values,\\n const FEFaceValues<dim>                    &darcy_fe_face_values,\\n const std::vector<types::global_dof_index> &local_dof_indices)\\n  {\\n const unsigned int dofs_per_cell = saturation_fe_face_values.dofs_per_cell;\\n const unsigned int n_face_q_points =\\n      saturation_fe_face_values.n_quadrature_points;\\n \\n Vector<double> local_rhs(dofs_per_cell);\\n \\n    std::vector<double> old_saturation_solution_values_face(n_face_q_points);\\n    std::vector<Vector<double>> present_darcy_solution_values_face(\\n      n_face_q_points, Vector<double>(dim + 1));\\n    std::vector<double> neighbor_saturation(n_face_q_points);\\n \\n    saturation_fe_face_values.get_function_values(\\n      old_saturation_solution, old_saturation_solution_values_face);\\n    darcy_fe_face_values.get_function_values(\\n      darcy_solution, present_darcy_solution_values_face);\\n \\n    SaturationBoundaryValues<dim> saturation_boundary_values;\\n    saturation_boundary_values.value_list(\\n      saturation_fe_face_values.get_quadrature_points(), neighbor_saturation);\\n \\n for (unsigned int q = 0; q < n_face_q_points; ++q)\\n      {\\n Tensor<1, dim> present_u_face;\\n for (unsigned int d = 0; d < dim; ++d)\\n          present_u_face[d] = present_darcy_solution_values_face[q](d);\\n \\n const double normal_flux =\\n          present_u_face * saturation_fe_face_values.normal_vector(q);\\n \\n const bool is_outflow_q_point = (normal_flux >= 0);\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n          local_rhs(i) -=\\n            time_step * normal_flux *\\n            fractional_flow((is_outflow_q_point == true ?\\n                               old_saturation_solution_values_face[q] :\\n                               neighbor_saturation[q]),\\n                            viscosity) *\\n            saturation_fe_face_values.shape_value(i, q) *\\n            saturation_fe_face_values.JxW(q);\\n      }\\n    saturation_constraints.distribute_local_to_global(local_rhs,\\n                                                      local_dof_indices,\\n                                                      saturation_rhs);\\n  }\\n \\n \\n \\n template <int dim>\\n void TwoPhaseFlowProblem<dim>::solve()\\n  {\\n const bool solve_for_pressure_and_velocity =\\n      determine_whether_to_solve_for_pressure_and_velocity();\\n \\n if (solve_for_pressure_and_velocity == true)\\n      {\\n        std::cout << \\\"   Solving Darcy (pressure-velocity) system...\\\"\\n                  << std::endl;\\n \\n        assemble_darcy_system();\\n        build_darcy_preconditioner();\\n \\n        {\\n const LinearSolvers::InverseMatrix<TrilinosWrappers::SparseMatrix,\\n TrilinosWrappers::PreconditionIC>\\n            mp_inverse(darcy_preconditioner_matrix.block(1, 1),\\n                       *bottom_right_preconditioner);\\n \\n const LinearSolvers::BlockSchurPreconditioner<\\n TrilinosWrappers::PreconditionIC,\\n TrilinosWrappers::PreconditionIC>\\n            preconditioner(darcy_matrix, mp_inverse, *top_left_preconditioner);\\n \\n SolverControl solver_control(darcy_matrix.m(),\\n                                       1e-16 * darcy_rhs.l2_norm());\\n \\n SolverGMRES<TrilinosWrappers::MPI::BlockVector> gmres(\\n            solver_control,\\n SolverGMRES<TrilinosWrappers::MPI::BlockVector>::AdditionalData(\\n              100));\\n \\n for (unsigned int i = 0; i < darcy_solution.size(); ++i)\\n if (darcy_constraints.is_constrained(i))\\n              darcy_solution(i) = 0;\\n \\n          gmres.solve(darcy_matrix, darcy_solution, darcy_rhs, preconditioner);\\n \\n          darcy_constraints.distribute(darcy_solution);\\n \\n          std::cout << \\\"        ...\\\" << solver_control.last_step()\\n                    << \\\" GMRES iterations.\\\" << std::endl;\\n        }\\n \\n        {\\n          second_last_computed_darcy_solution = last_computed_darcy_solution;\\n          last_computed_darcy_solution        = darcy_solution;\\n \\n          saturation_matching_last_computed_darcy_solution =\\n            saturation_solution;\\n        }\\n      }\\n else\\n      {\\n        darcy_solution = last_computed_darcy_solution;\\n        darcy_solution.sadd(1 + current_macro_time_step / old_macro_time_step,\\n                            -current_macro_time_step / old_macro_time_step,\\n                            second_last_computed_darcy_solution);\\n      }\\n \\n \\n    {\\n      old_time_step = time_step;\\n \\n const double max_u_F_prime = get_max_u_F_prime();\\n if (max_u_F_prime > 0)\\n        time_step = porosity * GridTools::minimal_cell_diameter(triangulation) /\\n                    saturation_degree / max_u_F_prime / 50;\\n else\\n        time_step = end_time - time;\\n    }\\n \\n \\n \\n if (solve_for_pressure_and_velocity == true)\\n      {\\n        old_macro_time_step     = current_macro_time_step;\\n        current_macro_time_step = time_step;\\n      }\\n else\\n      current_macro_time_step += time_step;\\n \\n    {\\n      std::cout << \\\"   Solving saturation transport equation...\\\" << std::endl;\\n \\n      assemble_saturation_system();\\n \\n SolverControl solver_control(saturation_matrix.m(),\\n                                   1e-16 * saturation_rhs.l2_norm());\\n SolverCG<TrilinosWrappers::MPI::Vector> cg(solver_control);\\n \\n TrilinosWrappers::PreconditionIC preconditioner;\\n      preconditioner.initialize(saturation_matrix);\\n \\n      cg.solve(saturation_matrix,\\n               saturation_solution,\\n               saturation_rhs,\\n               preconditioner);\\n \\n      saturation_constraints.distribute(saturation_solution);\\n      project_back_saturation();\\n \\n      std::cout << \\\"        ...\\\" << solver_control.last_step()\\n                << \\\" CG iterations.\\\" << std::endl;\\n    }\\n  }\\n \\n \\n \\n template <int dim>\\n void TwoPhaseFlowProblem<dim>::refine_mesh(const unsigned int min_grid_level,\\n const unsigned int max_grid_level)\\n  {\\n Vector<double> refinement_indicators(triangulation.n_active_cells());\\n    {\\n const QMidpoint<dim>        quadrature_formula;\\n FEValues<dim>               fe_values(saturation_fe,\\n                              quadrature_formula,\\n update_gradients);\\n      std::vector<Tensor<1, dim>> grad_saturation(1);\\n \\n TrilinosWrappers::MPI::Vector extrapolated_saturation_solution(\\n        saturation_solution);\\n if (timestep_number != 0)\\n        extrapolated_saturation_solution.sadd((1. + time_step / old_time_step),\\n                                              time_step / old_time_step,\\n                                              old_saturation_solution);\\n \\n for (const auto &cell : saturation_dof_handler.active_cell_iterators())\\n        {\\n const unsigned int cell_no = cell->active_cell_index();\\n          fe_values.reinit(cell);\\n          fe_values.get_function_gradients(extrapolated_saturation_solution,\\n                                           grad_saturation);\\n \\n          refinement_indicators(cell_no) = grad_saturation[0].norm();\\n        }\\n    }\\n \\n    {\\n for (const auto &cell : saturation_dof_handler.active_cell_iterators())\\n        {\\n const unsigned int cell_no = cell->active_cell_index();\\n          cell->clear_coarsen_flag();\\n          cell->clear_refine_flag();\\n \\n if ((static_cast<unsigned int>(cell->level()) < max_grid_level) &&\\n              (std::fabs(refinement_indicators(cell_no)) >\\n               saturation_refinement_threshold))\\n            cell->set_refine_flag();\\n else if ((static_cast<unsigned int>(cell->level()) >\\n                    min_grid_level) &&\\n                   (std::fabs(refinement_indicators(cell_no)) <\\n                    0.5 * saturation_refinement_threshold))\\n            cell->set_coarsen_flag();\\n        }\\n    }\\n \\n triangulation.prepare_coarsening_and_refinement();\\n \\n    {\\n      std::vector<TrilinosWrappers::MPI::Vector> x_saturation(3);\\n      x_saturation[0] = saturation_solution;\\n      x_saturation[1] = old_saturation_solution;\\n      x_saturation[2] = saturation_matching_last_computed_darcy_solution;\\n \\n      std::vector<TrilinosWrappers::MPI::BlockVector> x_darcy(2);\\n      x_darcy[0] = last_computed_darcy_solution;\\n      x_darcy[1] = second_last_computed_darcy_solution;\\n \\n SolutionTransfer<dim, TrilinosWrappers::MPI::Vector> saturation_soltrans(\\n        saturation_dof_handler);\\n \\n SolutionTransfer<dim, TrilinosWrappers::MPI::BlockVector> darcy_soltrans(\\n        darcy_dof_handler);\\n \\n \\n triangulation.prepare_coarsening_and_refinement();\\n      saturation_soltrans.prepare_for_coarsening_and_refinement(x_saturation);\\n \\n      darcy_soltrans.prepare_for_coarsening_and_refinement(x_darcy);\\n \\n triangulation.execute_coarsening_and_refinement();\\n      setup_dofs();\\n \\n      std::vector<TrilinosWrappers::MPI::Vector> tmp_saturation(3);\\n      tmp_saturation[0].reinit(saturation_solution);\\n      tmp_saturation[1].reinit(saturation_solution);\\n      tmp_saturation[2].reinit(saturation_solution);\\n      saturation_soltrans.interpolate(x_saturation, tmp_saturation);\\n \\n      saturation_solution                              = tmp_saturation[0];\\n      old_saturation_solution                          = tmp_saturation[1];\\n      saturation_matching_last_computed_darcy_solution = tmp_saturation[2];\\n \\n      saturation_constraints.distribute(saturation_solution);\\n      saturation_constraints.distribute(old_saturation_solution);\\n      saturation_constraints.distribute(\\n        saturation_matching_last_computed_darcy_solution);\\n \\n      std::vector<TrilinosWrappers::MPI::BlockVector> tmp_darcy(2);\\n      tmp_darcy[0].reinit(darcy_solution);\\n      tmp_darcy[1].reinit(darcy_solution);\\n      darcy_soltrans.interpolate(x_darcy, tmp_darcy);\\n \\n      last_computed_darcy_solution        = tmp_darcy[0];\\n      second_last_computed_darcy_solution = tmp_darcy[1];\\n \\n      darcy_constraints.distribute(last_computed_darcy_solution);\\n      darcy_constraints.distribute(second_last_computed_darcy_solution);\\n \\n      rebuild_saturation_matrix = true;\\n    }\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void TwoPhaseFlowProblem<dim>::output_results() const\\n {\\n const FESystem<dim> joint_fe(darcy_fe, 1, saturation_fe, 1);\\n DoFHandler<dim>     joint_dof_handler(triangulation);\\n    joint_dof_handler.distribute_dofs(joint_fe);\\n Assert(joint_dof_handler.n_dofs() ==\\n             darcy_dof_handler.n_dofs() + saturation_dof_handler.n_dofs(),\\n           ExcInternalError());\\n \\n Vector<double> joint_solution(joint_dof_handler.n_dofs());\\n \\n    {\\n      std::vector<types::global_dof_index> local_joint_dof_indices(\\n        joint_fe.n_dofs_per_cell());\\n      std::vector<types::global_dof_index> local_darcy_dof_indices(\\n        darcy_fe.n_dofs_per_cell());\\n      std::vector<types::global_dof_index> local_saturation_dof_indices(\\n        saturation_fe.n_dofs_per_cell());\\n \\n auto       joint_cell      = joint_dof_handler.begin_active();\\n const auto joint_endc      = joint_dof_handler.end();\\n auto       darcy_cell      = darcy_dof_handler.begin_active();\\n auto       saturation_cell = saturation_dof_handler.begin_active();\\n \\n for (; joint_cell != joint_endc;\\n           ++joint_cell, ++darcy_cell, ++saturation_cell)\\n        {\\n          joint_cell->get_dof_indices(local_joint_dof_indices);\\n          darcy_cell->get_dof_indices(local_darcy_dof_indices);\\n          saturation_cell->get_dof_indices(local_saturation_dof_indices);\\n \\n for (unsigned int i = 0; i < joint_fe.n_dofs_per_cell(); ++i)\\n if (joint_fe.system_to_base_index(i).first.first == 0)\\n              {\\n Assert(joint_fe.system_to_base_index(i).second <\\n                         local_darcy_dof_indices.size(),\\n                       ExcInternalError());\\n                joint_solution(local_joint_dof_indices[i]) = darcy_solution(\\n                  local_darcy_dof_indices[joint_fe.system_to_base_index(i)\\n                                            .second]);\\n              }\\n else\\n              {\\n Assert(joint_fe.system_to_base_index(i).first.first == 1,\\n                       ExcInternalError());\\n Assert(joint_fe.system_to_base_index(i).second <\\n                         local_darcy_dof_indices.size(),\\n                       ExcInternalError());\\n                joint_solution(local_joint_dof_indices[i]) =\\n                  saturation_solution(\\n                    local_saturation_dof_indices\\n                      [joint_fe.system_to_base_index(i).second]);\\n              }\\n        }\\n    }\\n    std::vector<std::string> joint_solution_names(dim, \\\"velocity\\\");\\n    joint_solution_names.emplace_back(\\\"pressure\\\");\\n    joint_solution_names.emplace_back(\\\"saturation\\\");\\n \\n    std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n      data_component_interpretation(\\n        dim, DataComponentInterpretation::component_is_part_of_vector);\\n    data_component_interpretation.push_back(\\n DataComponentInterpretation::component_is_scalar);\\n    data_component_interpretation.push_back(\\n DataComponentInterpretation::component_is_scalar);\\n \\n DataOut<dim> data_out;\\n \\n    data_out.attach_dof_handler(joint_dof_handler);\\n    data_out.add_data_vector(joint_solution,\\n                             joint_solution_names,\\n DataOut<dim>::type_dof_data,\\n                             data_component_interpretation);\\n \\n    data_out.build_patches();\\n \\n    std::string filename =\\n \\\"solution-\\\" + Utilities::int_to_string(timestep_number, 5) + \\\".vtu\\\";\\n    std::ofstream output(filename);\\n    data_out.write_vtu(output);\\n  }\\n \\n \\n \\n \\n \\n template <int dim>\\n bool TwoPhaseFlowProblem<\\n    dim>::determine_whether_to_solve_for_pressure_and_velocity() const\\n {\\n if (timestep_number <= 2)\\n return true;\\n \\n const QGauss<dim>  quadrature_formula(saturation_degree + 2);\\n const unsigned int n_q_points = quadrature_formula.size();\\n \\n FEValues<dim> fe_values(saturation_fe,\\n                            quadrature_formula,\\n update_values | update_quadrature_points);\\n \\n    std::vector<double> old_saturation_after_solving_pressure(n_q_points);\\n    std::vector<double> present_saturation(n_q_points);\\n \\n    std::vector<Tensor<2, dim>> k_inverse_values(n_q_points);\\n \\n double max_global_aop_indicator = 0.0;\\n \\n for (const auto &cell : saturation_dof_handler.active_cell_iterators())\\n      {\\n double max_local_mobility_reciprocal_difference = 0.0;\\n double max_local_permeability_inverse_l1_norm   = 0.0;\\n \\n        fe_values.reinit(cell);\\n        fe_values.get_function_values(\\n          saturation_matching_last_computed_darcy_solution,\\n          old_saturation_after_solving_pressure);\\n        fe_values.get_function_values(saturation_solution, present_saturation);\\n \\n        k_inverse.value_list(fe_values.get_quadrature_points(),\\n                             k_inverse_values);\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n          {\\n const double mobility_reciprocal_difference = std::fabs(\\n              mobility_inverse(present_saturation[q], viscosity) -\\n              mobility_inverse(old_saturation_after_solving_pressure[q],\\n                               viscosity));\\n \\n            max_local_mobility_reciprocal_difference =\\n std::max(max_local_mobility_reciprocal_difference,\\n                       mobility_reciprocal_difference);\\n \\n            max_local_permeability_inverse_l1_norm =\\n std::max(max_local_permeability_inverse_l1_norm,\\n l1_norm(k_inverse_values[q]));\\n          }\\n \\n        max_global_aop_indicator =\\n std::max(max_global_aop_indicator,\\n                   (max_local_mobility_reciprocal_difference *\\n                    max_local_permeability_inverse_l1_norm));\\n      }\\n \\n return (max_global_aop_indicator > AOS_threshold);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void TwoPhaseFlowProblem<dim>::project_back_saturation()\\n  {\\n for (unsigned int i = 0; i < saturation_solution.size(); ++i)\\n if (saturation_solution(i) < 0.2)\\n        saturation_solution(i) = 0.2;\\n else if (saturation_solution(i) > 1)\\n        saturation_solution(i) = 1;\\n  }\\n \\n \\n \\n template <int dim>\\n double TwoPhaseFlowProblem<dim>::get_max_u_F_prime() const\\n {\\n const QGauss<dim>  quadrature_formula(darcy_degree + 2);\\n const unsigned int n_q_points = quadrature_formula.size();\\n \\n FEValues<dim> darcy_fe_values(darcy_fe, quadrature_formula, update_values);\\n FEValues<dim> saturation_fe_values(saturation_fe,\\n                                       quadrature_formula,\\n update_values);\\n \\n    std::vector<Vector<double>> darcy_solution_values(n_q_points,\\n Vector<double>(dim + 1));\\n    std::vector<double>         saturation_values(n_q_points);\\n \\n double max_velocity_times_dF_dS = 0;\\n \\n auto       cell            = darcy_dof_handler.begin_active();\\n const auto endc            = darcy_dof_handler.end();\\n auto       saturation_cell = saturation_dof_handler.begin_active();\\n for (; cell != endc; ++cell, ++saturation_cell)\\n      {\\n        darcy_fe_values.reinit(cell);\\n        saturation_fe_values.reinit(saturation_cell);\\n \\n        darcy_fe_values.get_function_values(darcy_solution,\\n                                            darcy_solution_values);\\n        saturation_fe_values.get_function_values(old_saturation_solution,\\n                                                 saturation_values);\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n          {\\n Tensor<1, dim> velocity;\\n for (unsigned int i = 0; i < dim; ++i)\\n              velocity[i] = darcy_solution_values[q](i);\\n \\n const double dF_dS =\\n              fractional_flow_derivative(saturation_values[q], viscosity);\\n \\n            max_velocity_times_dF_dS =\\n std::max(max_velocity_times_dF_dS, velocity.norm() * dF_dS);\\n          }\\n      }\\n \\n return max_velocity_times_dF_dS;\\n  }\\n \\n \\n template <int dim>\\n  std::pair<double, double>\\n  TwoPhaseFlowProblem<dim>::get_extrapolated_saturation_range() const\\n {\\n const QGauss<dim>  quadrature_formula(saturation_degree + 2);\\n const unsigned int n_q_points = quadrature_formula.size();\\n \\n FEValues<dim> fe_values(saturation_fe, quadrature_formula, update_values);\\n    std::vector<double> old_saturation_values(n_q_points);\\n    std::vector<double> old_old_saturation_values(n_q_points);\\n \\n if (timestep_number != 0)\\n      {\\n double min_saturation = std::numeric_limits<double>::max(),\\n               max_saturation = -std::numeric_limits<double>::max();\\n \\n for (const auto &cell : saturation_dof_handler.active_cell_iterators())\\n          {\\n            fe_values.reinit(cell);\\n            fe_values.get_function_values(old_saturation_solution,\\n                                          old_saturation_values);\\n            fe_values.get_function_values(old_old_saturation_solution,\\n                                          old_old_saturation_values);\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n              {\\n const double saturation =\\n                  (1. + time_step / old_time_step) * old_saturation_values[q] -\\n                  time_step / old_time_step * old_old_saturation_values[q];\\n \\n                min_saturation = std::min(min_saturation, saturation);\\n                max_saturation = std::max(max_saturation, saturation);\\n              }\\n          }\\n \\n return std::make_pair(min_saturation, max_saturation);\\n      }\\n else\\n      {\\n double min_saturation = std::numeric_limits<double>::max(),\\n               max_saturation = -std::numeric_limits<double>::max();\\n \\n for (const auto &cell : saturation_dof_handler.active_cell_iterators())\\n          {\\n            fe_values.reinit(cell);\\n            fe_values.get_function_values(old_saturation_solution,\\n                                          old_saturation_values);\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n              {\\n const double saturation = old_saturation_values[q];\\n \\n                min_saturation = std::min(min_saturation, saturation);\\n                max_saturation = std::max(max_saturation, saturation);\\n              }\\n          }\\n \\n return std::make_pair(min_saturation, max_saturation);\\n      }\\n  }\\n \\n \\n \\n template <int dim>\\n double TwoPhaseFlowProblem<dim>::compute_viscosity(\\n const std::vector<double>         &old_saturation,\\n const std::vector<double>         &old_old_saturation,\\n const std::vector<Tensor<1, dim>> &old_saturation_grads,\\n const std::vector<Tensor<1, dim>> &old_old_saturation_grads,\\n const std::vector<Vector<double>> &present_darcy_values,\\n const double                       global_max_u_F_prime,\\n const double                       global_S_variation,\\n const double                       cell_diameter) const\\n {\\n const double beta  = .4 * dim;\\n const double alpha = 1;\\n \\n if (global_max_u_F_prime == 0)\\n return 5e-3 * cell_diameter;\\n \\n const unsigned int n_q_points = old_saturation.size();\\n \\n double max_residual             = 0;\\n double max_velocity_times_dF_dS = 0;\\n \\n const bool use_dF_dS = true;\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n      {\\n Tensor<1, dim> u;\\n for (unsigned int d = 0; d < dim; ++d)\\n          u[d] = present_darcy_values[q](d);\\n \\n const double dS_dt = porosity *\\n                             (old_saturation[q] - old_old_saturation[q]) /\\n                             old_time_step;\\n \\n const double dF_dS = fractional_flow_derivative(\\n          (old_saturation[q] + old_old_saturation[q]) / 2.0, viscosity);\\n \\n const double u_grad_S =\\n          u * dF_dS * (old_saturation_grads[q] + old_old_saturation_grads[q]) /\\n          2.0;\\n \\n const double residual =\\n std::abs((dS_dt + u_grad_S) *\\n std::pow((old_saturation[q] + old_old_saturation[q]) / 2,\\n                            alpha - 1.));\\n \\n        max_residual = std::max(residual, max_residual);\\n        max_velocity_times_dF_dS =\\n std::max(std::sqrt(u * u) * (use_dF_dS ? std::max(dF_dS, 1.) : 1),\\n                   max_velocity_times_dF_dS);\\n      }\\n \\n const double c_R            = 1.0;\\n const double global_scaling = c_R * porosity *\\n                                  (global_max_u_F_prime)*global_S_variation /\\n std::pow(global_Omega_diameter, alpha - 2.);\\n \\n return (beta *\\n            (max_velocity_times_dF_dS)*std::min(cell_diameter,\\n std::pow(cell_diameter, alpha) *\\n                                                  max_residual /\\n                                                  global_scaling));\\n  }\\n \\n \\n \\n template <int dim>\\n void TwoPhaseFlowProblem<dim>::run()\\n  {\\n const unsigned int initial_refinement     = (dim == 2 ? 5 : 2);\\n const unsigned int n_pre_refinement_steps = (dim == 2 ? 3 : 2);\\n \\n \\n GridGenerator::hyper_cube(triangulation, 0, 1);\\n triangulation.refine_global(initial_refinement);\\n    global_Omega_diameter = GridTools::diameter(triangulation);\\n \\n    setup_dofs();\\n \\n unsigned int pre_refinement_step = 0;\\n \\n  start_time_iteration:\\n \\n VectorTools::project(saturation_dof_handler,\\n                         saturation_constraints,\\n QGauss<dim>(saturation_degree + 2),\\n                         SaturationInitialValues<dim>(),\\n                         old_saturation_solution);\\n \\n    time_step = old_time_step = 0;\\n    current_macro_time_step = old_macro_time_step = 0;\\n \\n    time = 0;\\n \\n do\\n      {\\n        std::cout << \\\"Timestep \\\" << timestep_number << \\\":  t=\\\" << time\\n                  << \\\", dt=\\\" << time_step << std::endl;\\n \\n        solve();\\n \\n        std::cout << std::endl;\\n \\n if (timestep_number % 200 == 0)\\n          output_results();\\n \\n if (timestep_number % 25 == 0)\\n          refine_mesh(initial_refinement,\\n                      initial_refinement + n_pre_refinement_steps);\\n \\n if ((timestep_number == 0) &&\\n            (pre_refinement_step < n_pre_refinement_steps))\\n          {\\n            ++pre_refinement_step;\\n goto start_time_iteration;\\n          }\\n \\n        time += time_step;\\n        ++timestep_number;\\n \\n        old_old_saturation_solution = old_saturation_solution;\\n        old_saturation_solution     = saturation_solution;\\n      }\\n while (time <= end_time);\\n  }\\n} // namespace Step43\\n \\n \\n \\nint main(int argc, char *argv[])\\n{\\n try\\n    {\\n using namespace dealii;\\n using namespace Step43;\\n \\n Utilities::MPI::MPI_InitFinalize mpi_initialization(\\n        argc, argv, numbers::invalid_unsigned_int);\\n \\n AssertThrow(Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) == 1,\\n                  ExcMessage(\\n \\\"This program can only be run in serial, use ./step-43\\\"));\\n \\n      TwoPhaseFlowProblem<2> two_phase_flow_problem(1);\\n      two_phase_flow_problem.run();\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n \\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n \\n return 0;\\n}\\naffine_constraints.h\\nblock_sparsity_pattern.h\\nBlockVectorBase::blockBlockType & block(const unsigned int i)\\nDataOutInterface::write_vtuvoid write_vtu(std::ostream &out) constDefinition data_out_base.cc:7692\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nFEValuesBase::get_cellTriangulation< dim, spacedim >::cell_iterator get_cell() constDefinition fe_values_base.cc:1289\\nFEValuesBase::get_function_valuesvoid get_function_values(const ReadVector< Number > &fe_function, std::vector< Number > &values) constDefinition fe_values_base.cc:716\\nFEValuesBase::get_quadrature_pointsconst std::vector< Point< spacedim > > & get_quadrature_points() const\\nFEValuesBase::dofs_per_cellconst unsigned int dofs_per_cellDefinition fe_values_base.h:192\\nFEValuesBase::normal_vectorconst Tensor< 1, spacedim > & normal_vector(const unsigned int q_point) const\\nFEValuesBase::n_quadrature_pointsconst unsigned int n_quadrature_pointsDefinition fe_values_base.h:174\\nFEValuesBase::get_function_gradientsvoid get_function_gradients(const ReadVector< Number > &fe_function, std::vector< Tensor< 1, spacedim, Number > > &gradients) constDefinition fe_values_base.cc:851\\nFEValuesBase::shape_gradconst Tensor< 1, spacedim > & shape_grad(const unsigned int i, const unsigned int q_point) const\\nFEValuesBase::JxWdouble JxW(const unsigned int q_point) const\\nFEValuesBase::shape_valueconst double & shape_value(const unsigned int i, const unsigned int q_point) const\\nFEValues::reinitvoid reinit(const TriaIterator< DoFCellAccessor< dim, spacedim, level_dof_access > > &cell)\\nFunctions::ConstantFunction::value_listvirtual void value_list(const std::vector< Point< dim > > &points, std::vector< RangeNumberType > &return_values, const unsigned int component=0) const override\\nTensor::normnumbers::NumberTraits< Number >::real_type norm() const\\ndof_handler.h\\ndof_renumbering.h\\ndof_tools.h\\nfe_values.h\\nfe_q.h\\nfe_system.h\\nfull_matrix.h\\nfunction.h\\ntria.h\\ngrid_generator.h\\ngrid_tools.h\\nutilities.h\\nindex_set.h\\nLAPACKSupport::matrix@ matrixContents is actually a matrix.Definition lapack_support.h:57\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\ninternal::EvaluatorQuantity::value@ value\\ndata_out.h\\nsolution_transfer.h\\nquadrature_lib.h\\nsolver_cg.h\\nsolver_gmres.h\\ntensor_function.h\\ntrilinos_block_sparse_matrix.h\\ntrilinos_parallel_block_vector.h\\ntrilinos_precondition.h\\ntrilinos_sparse_matrix.h\\ntrilinos_vector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"