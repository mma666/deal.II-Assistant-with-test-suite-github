"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_39.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-39 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-39 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-39 tutorial program\\n\\n\\nThis tutorial depends on step-12.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\n\\n The commented program\\n\\nThe local integrators\\nThe main class\\n\\n\\n Results\\n\\nLogfile output\\nPostprocessing of the logfile\\n\\n The plain program\\n   \\n\\nIn this program, we use the interior penalty method and Nitsche's weak boundary conditions to solve Poisson's equation. We use multigrid methods on locally refined meshes, which are generated using a bulk criterion and a standard error estimator based on cell and face residuals. All operators are implemented using the MeshWorker interface.\\nLike in step-12, the discretization relies on finite element spaces, which are polynomial inside the mesh cells \\\\(K\\\\in \\\\mathbb T_h\\\\), but have no continuity between cells. Since such functions have two values on each interior face \\\\(F\\\\in \\\\mathbb F_h^i\\\\), one from each side, we define mean value and jump operators as follows: let K1 and K2 be the two cells sharing a face, and let the traces of functions ui and the outer normal vectors ni be labeled accordingly. Then, on the face, we let   \\n\\\\[\\n        \\\\average{ u } = \\\\frac{u_1 + u_2}2\\n\\\\]\\n\\nNote, that if such an expression contains a normal vector, the averaging operator turns into a jump. The interior penalty method for the problem   \\n\\\\[\\n  -\\\\Delta u = f \\\\text{ in }\\\\Omega \\\\qquad u = u^D \\\\text{ on } \\\\partial\\\\Omega\\n\\\\]\\n\\n becomes                 \\n\\\\begin{multline*}\\n  \\\\sum_{K\\\\in \\\\mathbb T_h} (\\\\nabla u, \\\\nabla v)_K\\n  \\\\\\\\\\n  + \\\\sum_{F \\\\in F_h^i} \\\\biggl\\\\{4\\\\sigma_F (\\\\average{ u \\\\mathbf n}, \\\\average{ v \\\\mathbf n })_F\\n  - 2 (\\\\average{ \\\\nabla u },\\\\average{ v\\\\mathbf n })_F\\n  - 2 (\\\\average{ \\\\nabla v },\\\\average{ u\\\\mathbf n })_F\\n  \\\\biggr\\\\}\\n  \\\\\\\\\\n  + \\\\sum_{F \\\\in F_h^b} \\\\biggl\\\\{2\\\\sigma_F (u, v)_F\\n  - (\\\\partial_n u,v)_F\\n  - (\\\\partial_n v,u)_F\\n  \\\\biggr\\\\}\\n  \\\\\\\\\\n  = (f, v)_\\\\Omega + \\\\sum_{F \\\\in F_h^b} \\\\biggl\\\\{\\n  2\\\\sigma_F (u^D, v)_F - (\\\\partial_n v,u^D)_F\\n  \\\\biggr\\\\}.\\n\\\\end{multline*}\\n\\nHere, \\\\(\\\\sigma_F\\\\) is the penalty parameter, which is chosen as follows: for a face F of a cell K, compute the value   \\n\\\\[\\n\\\\sigma_{F,K} = p(p+1) \\\\frac{|F|_{d-1}}{|K|_d},\\n\\\\]\\n\\n where p is the polynomial degree of the finite element functions and \\\\(|\\\\cdot|_d\\\\) and \\\\(|\\\\cdot|_{d-1}\\\\) denote the \\\\(d\\\\) and \\\\(d-1\\\\) dimensional Hausdorff measure of the corresponding object. If the face is at the boundary, choose \\\\(\\\\sigma_F = \\\\sigma_{F,K}\\\\). For an interior face, we take the average of the two values at this face.\\nIn our finite element program, we distinguish three different integrals, corresponding to the sums over cells, interior faces and boundary faces above. Since the MeshWorker::loop organizes the sums for us, we only need to implement the integrals over each mesh element. The class MatrixIntegrator below has these three functions for the left hand side of the formula, the class RHSIntegrator for the right.\\nAs we will see below, even the error estimate is of the same structure, since it can be written as          \\n\\\\begin{align*}\\n  \\\\eta^2 &= \\\\eta_K^2 + \\\\eta_F^2 + \\\\eta_B^2\\n  \\\\\\\\\\n  \\\\eta_K^2 &= \\\\sum_{K\\\\in \\\\mathbb T_h} h^2 \\\\|f + \\\\Delta u_h\\\\|^2\\n  \\\\\\\\\\n  \\\\eta_F^2 &= \\\\sum_{F \\\\in F_h^i} \\\\biggl\\\\{\\n    4 \\\\sigma_F \\\\| \\\\average{u_h\\\\mathbf n} \\\\|^2 + h \\\\|\\\\average{\\\\partial_n u_h}\\\\|^2 \\\\biggr\\\\}\\n  \\\\\\\\\\n  \\\\eta_B^2 &= \\\\sum_{F \\\\in F_h^b} 2\\\\sigma_F \\\\| u_h-u^D \\\\|^2.\\n\\\\end{align*}\\n\\nThus, the functions for assembling matrices, right hand side and error estimates below exhibit that these loops are all generic and can be programmed in the same way.\\nThis program is related to step-12, in that it uses MeshWorker and discontinuous Galerkin methods. There we solved an advection problem, while here it is a diffusion problem. Here, we also use multigrid preconditioning and a theoretically justified error estimator, see Karakashian and Pascal (2003). The multilevel scheme was discussed in detail in Kanschat (2004). The adaptive iteration and its convergence have been discussed (for triangular meshes) in Hoppe, Kanschat, and Warburton (2009).\\n The commented program\\nThe include files for the linear algebra: A regular SparseMatrix, which in turn will include the necessary files for SparsityPattern and Vector classes.\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/solver_cg.h>\\n\\u00a0 #include <deal.II/lac/precondition.h>\\n\\u00a0 #include <deal.II/lac/precondition_block.h>\\n\\u00a0 #include <deal.II/lac/block_vector.h>\\n\\u00a0 \\nInclude files for setting up the mesh\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_refinement.h>\\n\\u00a0 \\nInclude files for FiniteElement classes and DoFHandler.\\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_dgp.h>\\n\\u00a0 #include <deal.II/fe/fe_dgq.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 #include <deal.II/fe/mapping_q1.h>\\n\\u00a0 \\nThe include files for using the MeshWorker framework\\n\\u00a0 #include <deal.II/meshworker/dof_info.h>\\n\\u00a0 #include <deal.II/meshworker/integration_info.h>\\n\\u00a0 #include <deal.II/meshworker/assembler.h>\\n\\u00a0 #include <deal.II/meshworker/loop.h>\\n\\u00a0 \\nThe include file for local integrators associated with the Laplacian\\n\\u00a0 #include <deal.II/integrators/laplace.h>\\n\\u00a0 \\nSupport for multigrid methods\\n\\u00a0 #include <deal.II/multigrid/mg_tools.h>\\n\\u00a0 #include <deal.II/multigrid/multigrid.h>\\n\\u00a0 #include <deal.II/multigrid/mg_matrix.h>\\n\\u00a0 #include <deal.II/multigrid/mg_transfer.h>\\n\\u00a0 #include <deal.II/multigrid/mg_coarse.h>\\n\\u00a0 #include <deal.II/multigrid/mg_smoother.h>\\n\\u00a0 \\nFinally, we take our exact solution from the library as well as quadrature and additional tools.\\n\\u00a0 #include <deal.II/base/function_lib.h>\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 \\n\\u00a0 #include <iostream>\\n\\u00a0 #include <fstream>\\n\\u00a0 \\nAll classes of the deal.II library are in the namespace dealii. In order to save typing, we tell the compiler to search names in there as well.\\n\\u00a0 namespace Step39\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\nThis is the function we use to set the boundary values and also the exact solution we compare to.\\n\\u00a0   Functions::SlitSingularityFunction<2> exact_solution;\\n\\u00a0 \\nFunctions::SlitSingularityFunctionDefinition function_lib.h:508\\n The local integrators\\nThe MeshWorker::loop() function separates what needs to be done for local integration, from the loops over cells and faces. It does this by calling functions that integrate over a cell, a boundary face, or an interior face, and letting them create the local contributions and then in a separate step calling a function that moves these local contributions into the global objects. We will use this approach for computing the matrices, the right hand side, the error estimator, and the actual error computation in the functions below. For each of these operations, we provide a namespace that contains a set of functions for cell, boundary, and interior face contributions.\\nAll the information needed for these local integration is provided by MeshWorker::DoFInfo<dim> and MeshWorker::IntegrationInfo<dim>. In each case, the functions' signatures is fixed: MeshWorker::loop() wants to call functions with a specific set of arguments, so the signature of the functions cannot be changed.\\nThe first namespace defining local integrators is responsible for assembling the global matrix as well as the level matrices. On each cell, we integrate the Dirichlet form as well as the Nitsche boundary conditions and the interior penalty fluxes between cells.\\nThe boundary and flux terms need a penalty parameter, which should be adjusted to the cell size and the polynomial degree. We compute it in two steps: First, we compute on each cell \\\\(K_i\\\\) the value \\\\(P_i = p_i(p_i+1)/h_i\\\\), where \\\\(p_i\\\\) is the polynomial degree on cell \\\\(K_i\\\\) and \\\\(h_i\\\\) is the length of \\\\(K_i\\\\) orthogonal to the current face. Second, if exactly one of the two cells adjacent to the face has children, its penalty is multiplied by two (to account for the fact that the mesh size \\\\(h_i\\\\) there is only half that previously computed); it is possible that both adjacent cells are refined, in which case we are integrating over a non-active face and no adjustment is necessary. Finally, we return the average of the two penalty values.\\n\\u00a0   namespace MatrixIntegrator\\n\\u00a0   {\\n\\u00a0     template <int dim>\\n\\u00a0     double ip_penalty_factor(const MeshWorker::DoFInfo<dim> &dinfo1,\\n\\u00a0                              const MeshWorker::DoFInfo<dim> &dinfo2,\\n\\u00a0                              unsigned int                    deg1,\\n\\u00a0                              unsigned int                    deg2)\\n\\u00a0     {\\n\\u00a0       const unsigned int normal1 =\\n\\u00a0         GeometryInfo<dim>::unit_normal_direction[dinfo1.face_number];\\n\\u00a0       const unsigned int normal2 =\\n\\u00a0         GeometryInfo<dim>::unit_normal_direction[dinfo2.face_number];\\n\\u00a0       const unsigned int deg1sq = (deg1 == 0) ? 1 : deg1 * (deg1 + 1);\\n\\u00a0       const unsigned int deg2sq = (deg2 == 0) ? 1 : deg2 * (deg2 + 1);\\n\\u00a0 \\n\\u00a0       double penalty1 = deg1sq / dinfo1.cell->extent_in_direction(normal1);\\n\\u00a0       double penalty2 = deg2sq / dinfo2.cell->extent_in_direction(normal2);\\n\\u00a0       if (dinfo1.cell->has_children() && !dinfo2.cell->has_children())\\n\\u00a0         penalty1 *= 2;\\n\\u00a0       else if (!dinfo1.cell->has_children() && dinfo2.cell->has_children())\\n\\u00a0         penalty2 *= 2;\\n\\u00a0 \\n\\u00a0       const double penalty = 0.5 * (penalty1 + penalty2);\\n\\u00a0       return penalty;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void cell(MeshWorker::DoFInfo<dim>         &dinfo,\\n\\u00a0               MeshWorker::IntegrationInfo<dim> &info)\\n\\u00a0     {\\n\\u00a0       FullMatrix<double> &M = dinfo.matrix(0, false).matrix;\\n\\u00a0 \\n\\u00a0       for (unsigned int k = 0; k < info.fe_values().n_quadrature_points; ++k)\\n\\u00a0         {\\n\\u00a0           const double dx = info.fe_values().JxW(k);\\n\\u00a0 \\n\\u00a0           for (unsigned int i = 0; i < info.fe_values().dofs_per_cell; ++i)\\n\\u00a0             {\\n\\u00a0               const double Mii = (info.fe_values().shape_grad(i, k) *\\n\\u00a0                                   info.fe_values().shape_grad(i, k) * dx);\\n\\u00a0 \\n\\u00a0               M(i, i) += Mii;\\n\\u00a0 \\n\\u00a0               for (unsigned int j = i + 1; j < info.fe_values().dofs_per_cell;\\n\\u00a0                    ++j)\\n\\u00a0                 {\\n\\u00a0                   const double Mij = info.fe_values().shape_grad(j, k) *\\n\\u00a0                                      info.fe_values().shape_grad(i, k) * dx;\\n\\u00a0 \\n\\u00a0                   M(i, j) += Mij;\\n\\u00a0                   M(j, i) += Mij;\\n\\u00a0                 }\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\nFullMatrixDefinition full_matrix.h:79\\nMatrixBlock::matrixMatrixType matrixDefinition matrix_block.h:315\\nMeshWorker::DoFInfoDefinition dof_info.h:75\\nMeshWorker::DoFInfo::face_numberunsigned int face_numberDefinition dof_info.h:89\\nMeshWorker::DoFInfo::cellTriangulation< dim, spacedim >::cell_iterator cellThe current cell.Definition dof_info.h:78\\nMeshWorker::IntegrationInfoDefinition integration_info.h:77\\nMeshWorker::LocalResults::matrixMatrixBlock< FullMatrix< number > > & matrix(const unsigned int i, const bool external=false)Definition local_results.h:449\\nGeometryInfoDefinition geometry_info.h:1964\\nBoundary faces use the Nitsche method to impose boundary values:\\n\\u00a0     template <int dim>\\n\\u00a0     void boundary(MeshWorker::DoFInfo<dim>         &dinfo,\\n\\u00a0                   MeshWorker::IntegrationInfo<dim> &info)\\n\\u00a0     {\\n\\u00a0       const FEValuesBase<dim> &fe_face_values = info.fe_values(0);\\n\\u00a0 \\n\\u00a0       FullMatrix<double> &M = dinfo.matrix(0, false).matrix;\\n\\u00a0       AssertDimension(M.n(), fe_face_values.dofs_per_cell);\\n\\u00a0       AssertDimension(M.m(), fe_face_values.dofs_per_cell);\\n\\u00a0 \\n\\u00a0       const unsigned int polynomial_degree =\\n\\u00a0         info.fe_values(0).get_fe().tensor_degree();\\n\\u00a0 \\n\\u00a0       const double ip_penalty =\\n\\u00a0         ip_penalty_factor(dinfo, dinfo, polynomial_degree, polynomial_degree);\\n\\u00a0 \\n\\u00a0       for (unsigned int k = 0; k < fe_face_values.n_quadrature_points; ++k)\\n\\u00a0         {\\n\\u00a0           const double          dx = fe_face_values.JxW(k);\\n\\u00a0           const Tensor<1, dim> &n  = fe_face_values.normal_vector(k);\\n\\u00a0 \\n\\u00a0           for (unsigned int i = 0; i < fe_face_values.dofs_per_cell; ++i)\\n\\u00a0             for (unsigned int j = 0; j < fe_face_values.dofs_per_cell; ++j)\\n\\u00a0               M(i, j) += (2. * fe_face_values.shape_value(i, k) * ip_penalty *\\n\\u00a0                             fe_face_values.shape_value(j, k) -\\n\\u00a0                           (n * fe_face_values.shape_grad(i, k)) *\\n\\u00a0                             fe_face_values.shape_value(j, k) -\\n\\u00a0                           (n * fe_face_values.shape_grad(j, k)) *\\n\\u00a0                             fe_face_values.shape_value(i, k)) *\\n\\u00a0                          dx;\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\nFEValuesBaseDefinition fe_values_base.h:155\\nTensorDefinition tensor.h:471\\nAssertDimension#define AssertDimension(dim1, dim2)Definition exceptions.h:1985\\nInterior faces use the interior penalty method:\\n\\u00a0     template <int dim>\\n\\u00a0     void face(MeshWorker::DoFInfo<dim>         &dinfo1,\\n\\u00a0               MeshWorker::DoFInfo<dim>         &dinfo2,\\n\\u00a0               MeshWorker::IntegrationInfo<dim> &info1,\\n\\u00a0               MeshWorker::IntegrationInfo<dim> &info2)\\n\\u00a0     {\\n\\u00a0       const FEValuesBase<dim> &fe_face_values_1 = info1.fe_values(0);\\n\\u00a0       const FEValuesBase<dim> &fe_face_values_2 = info2.fe_values(0);\\n\\u00a0 \\n\\u00a0       FullMatrix<double> &M11 = dinfo1.matrix(0, false).matrix;\\n\\u00a0       FullMatrix<double> &M12 = dinfo1.matrix(0, true).matrix;\\n\\u00a0       FullMatrix<double> &M21 = dinfo2.matrix(0, true).matrix;\\n\\u00a0       FullMatrix<double> &M22 = dinfo2.matrix(0, false).matrix;\\n\\u00a0 \\n\\u00a0       AssertDimension(M11.n(), fe_face_values_1.dofs_per_cell);\\n\\u00a0       AssertDimension(M11.m(), fe_face_values_1.dofs_per_cell);\\n\\u00a0       AssertDimension(M12.n(), fe_face_values_1.dofs_per_cell);\\n\\u00a0       AssertDimension(M12.m(), fe_face_values_1.dofs_per_cell);\\n\\u00a0       AssertDimension(M21.n(), fe_face_values_1.dofs_per_cell);\\n\\u00a0       AssertDimension(M21.m(), fe_face_values_1.dofs_per_cell);\\n\\u00a0       AssertDimension(M22.n(), fe_face_values_1.dofs_per_cell);\\n\\u00a0       AssertDimension(M22.m(), fe_face_values_1.dofs_per_cell);\\n\\u00a0 \\n\\u00a0       const unsigned int polynomial_degree =\\n\\u00a0         info1.fe_values(0).get_fe().tensor_degree();\\n\\u00a0       const double ip_penalty =\\n\\u00a0         ip_penalty_factor(dinfo1, dinfo2, polynomial_degree, polynomial_degree);\\n\\u00a0 \\n\\u00a0       const double nui = 1.;\\n\\u00a0       const double nue = 1.;\\n\\u00a0       const double nu  = .5 * (nui + nue);\\n\\u00a0 \\n\\u00a0       for (unsigned int k = 0; k < fe_face_values_1.n_quadrature_points; ++k)\\n\\u00a0         {\\n\\u00a0           const double          dx = fe_face_values_1.JxW(k);\\n\\u00a0           const Tensor<1, dim> &n  = fe_face_values_1.normal_vector(k);\\n\\u00a0 \\n\\u00a0           for (unsigned int i = 0; i < fe_face_values_1.dofs_per_cell; ++i)\\n\\u00a0             {\\n\\u00a0               for (unsigned int j = 0; j < fe_face_values_1.dofs_per_cell; ++j)\\n\\u00a0                 {\\n\\u00a0                   const double vi   = fe_face_values_1.shape_value(i, k);\\n\\u00a0                   const double dnvi = n * fe_face_values_1.shape_grad(i, k);\\n\\u00a0                   const double ve   = fe_face_values_2.shape_value(i, k);\\n\\u00a0                   const double dnve = n * fe_face_values_2.shape_grad(i, k);\\n\\u00a0                   const double ui   = fe_face_values_1.shape_value(j, k);\\n\\u00a0                   const double dnui = n * fe_face_values_1.shape_grad(j, k);\\n\\u00a0                   const double ue   = fe_face_values_2.shape_value(j, k);\\n\\u00a0                   const double dnue = n * fe_face_values_2.shape_grad(j, k);\\n\\u00a0 \\n\\u00a0                   M11(i, j) += (-.5 * nui * dnvi * ui - .5 * nui * dnui * vi +\\n\\u00a0                                 nu * ip_penalty * ui * vi) *\\n\\u00a0                                dx;\\n\\u00a0                   M12(i, j) += (.5 * nui * dnvi * ue - .5 * nue * dnue * vi -\\n\\u00a0                                 nu * ip_penalty * vi * ue) *\\n\\u00a0                                dx;\\n\\u00a0                   M21(i, j) += (-.5 * nue * dnve * ui + .5 * nui * dnui * ve -\\n\\u00a0                                 nu * ip_penalty * ui * ve) *\\n\\u00a0                                dx;\\n\\u00a0                   M22(i, j) += (.5 * nue * dnve * ue + .5 * nue * dnue * ve +\\n\\u00a0                                 nu * ip_penalty * ue * ve) *\\n\\u00a0                                dx;\\n\\u00a0                 }\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0   } // namespace MatrixIntegrator\\n\\u00a0 \\nThe second set of local integrators builds the right hand side. In our example, the right hand side function is zero, such that only the boundary condition is set here in weak form.\\n\\u00a0   namespace RHSIntegrator\\n\\u00a0   {\\n\\u00a0     template <int dim>\\n\\u00a0     void cell(MeshWorker::DoFInfo<dim> &, MeshWorker::IntegrationInfo<dim> &)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void boundary(MeshWorker::DoFInfo<dim>         &dinfo,\\n\\u00a0                   MeshWorker::IntegrationInfo<dim> &info)\\n\\u00a0     {\\n\\u00a0       const FEValuesBase<dim> &fe           = info.fe_values();\\n\\u00a0       Vector<double>          &local_vector = dinfo.vector(0).block(0);\\n\\u00a0 \\n\\u00a0       std::vector<double> boundary_values(fe.n_quadrature_points);\\n\\u00a0       exact_solution.value_list(fe.get_quadrature_points(), boundary_values);\\n\\u00a0 \\n\\u00a0       const unsigned int degree  = fe.get_fe().tensor_degree();\\n\\u00a0       const double       penalty = 2. * degree * (degree + 1) *\\n\\u00a0                              dinfo.face->measure() / dinfo.cell->measure();\\n\\u00a0 \\n\\u00a0       for (unsigned k = 0; k < fe.n_quadrature_points; ++k)\\n\\u00a0         for (unsigned int i = 0; i < fe.dofs_per_cell; ++i)\\n\\u00a0           local_vector(i) +=\\n\\u00a0             (-penalty * fe.shape_value(i, k) // (-sigma * v_i(x_k)\\n\\u00a0              +\\n\\u00a0              fe.normal_vector(k) * fe.shape_grad(i, k)) // + n * grad v_i(x_k))\\n\\u00a0             * boundary_values[k] * fe.JxW(k);           // u^D(x_k) * dx\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void face(MeshWorker::DoFInfo<dim> &,\\n\\u00a0               MeshWorker::DoFInfo<dim> &,\\n\\u00a0               MeshWorker::IntegrationInfo<dim> &,\\n\\u00a0               MeshWorker::IntegrationInfo<dim> &)\\n\\u00a0     {}\\n\\u00a0   } // namespace RHSIntegrator\\n\\u00a0 \\nBlockVectorBase::blockBlockType & block(const unsigned int i)\\nMeshWorker::DoFInfo::faceTriangulation< dim, spacedim >::face_iterator faceThe current face.Definition dof_info.h:81\\nMeshWorker::LocalResults::vectorBlockVector< number > & vector(const unsigned int i)Definition local_results.h:440\\nVectorDefinition vector.h:120\\nThe third local integrator is responsible for the contributions to the error estimate. This is the standard energy estimator due to Karakashian and Pascal (2003). The cell contribution is the Laplacian of the discrete solution, since the right hand side is zero.\\n\\u00a0   namespace Estimator\\n\\u00a0   {\\n\\u00a0     template <int dim>\\n\\u00a0     void cell(MeshWorker::DoFInfo<dim>         &dinfo,\\n\\u00a0               MeshWorker::IntegrationInfo<dim> &info)\\n\\u00a0     {\\n\\u00a0       const FEValuesBase<dim> &fe = info.fe_values();\\n\\u00a0 \\n\\u00a0       const std::vector<Tensor<2, dim>> &DDuh = info.hessians[0][0];\\n\\u00a0       for (unsigned k = 0; k < fe.n_quadrature_points; ++k)\\n\\u00a0         {\\n\\u00a0           const double t = dinfo.cell->diameter() * trace(DDuh[k]);\\n\\u00a0           dinfo.value(0) += t * t * fe.JxW(k);\\n\\u00a0         }\\n\\u00a0       dinfo.value(0) = std::sqrt(dinfo.value(0));\\n\\u00a0     }\\n\\u00a0 \\nMeshWorker::LocalResults::valuenumber & value(const unsigned int i)Definition local_results.h:431\\nstd::sqrt::VectorizedArray< Number, width > sqrt(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6869\\ntraceDEAL_II_HOST constexpr Number trace(const SymmetricTensor< 2, dim2, Number > &)\\nAt the boundary, we use simply a weighted form of the boundary residual, namely the norm of the difference between the finite element solution and the correct boundary condition.\\n\\u00a0     template <int dim>\\n\\u00a0     void boundary(MeshWorker::DoFInfo<dim>         &dinfo,\\n\\u00a0                   MeshWorker::IntegrationInfo<dim> &info)\\n\\u00a0     {\\n\\u00a0       const FEValuesBase<dim> &fe = info.fe_values();\\n\\u00a0 \\n\\u00a0       std::vector<double> boundary_values(fe.n_quadrature_points);\\n\\u00a0       exact_solution.value_list(fe.get_quadrature_points(), boundary_values);\\n\\u00a0 \\n\\u00a0       const std::vector<double> &uh = info.values[0][0];\\n\\u00a0 \\n\\u00a0       const unsigned int degree  = fe.get_fe().tensor_degree();\\n\\u00a0       const double       penalty = 2. * degree * (degree + 1) *\\n\\u00a0                              dinfo.face->measure() / dinfo.cell->measure();\\n\\u00a0 \\n\\u00a0       for (unsigned k = 0; k < fe.n_quadrature_points; ++k)\\n\\u00a0         {\\n\\u00a0           const double diff = boundary_values[k] - uh[k];\\n\\u00a0           dinfo.value(0) += penalty * diff * diff * fe.JxW(k);\\n\\u00a0         }\\n\\u00a0       dinfo.value(0) = std::sqrt(dinfo.value(0));\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\nFinally, on interior faces, the estimator consists of the jumps of the solution and its normal derivative, weighted appropriately.\\n\\u00a0     template <int dim>\\n\\u00a0     void face(MeshWorker::DoFInfo<dim>         &dinfo1,\\n\\u00a0               MeshWorker::DoFInfo<dim>         &dinfo2,\\n\\u00a0               MeshWorker::IntegrationInfo<dim> &info1,\\n\\u00a0               MeshWorker::IntegrationInfo<dim> &info2)\\n\\u00a0     {\\n\\u00a0       const FEValuesBase<dim>           &fe   = info1.fe_values();\\n\\u00a0       const std::vector<double>         &uh1  = info1.values[0][0];\\n\\u00a0       const std::vector<double>         &uh2  = info2.values[0][0];\\n\\u00a0       const std::vector<Tensor<1, dim>> &Duh1 = info1.gradients[0][0];\\n\\u00a0       const std::vector<Tensor<1, dim>> &Duh2 = info2.gradients[0][0];\\n\\u00a0 \\n\\u00a0       const unsigned int degree = fe.get_fe().tensor_degree();\\n\\u00a0       const double       penalty1 =\\n\\u00a0         degree * (degree + 1) * dinfo1.face->measure() / dinfo1.cell->measure();\\n\\u00a0       const double penalty2 =\\n\\u00a0         degree * (degree + 1) * dinfo2.face->measure() / dinfo2.cell->measure();\\n\\u00a0       const double penalty = penalty1 + penalty2;\\n\\u00a0       const double h       = dinfo1.face->measure();\\n\\u00a0 \\n\\u00a0       for (unsigned k = 0; k < fe.n_quadrature_points; ++k)\\n\\u00a0         {\\n\\u00a0           const double diff1 = uh1[k] - uh2[k];\\n\\u00a0           const double diff2 =\\n\\u00a0             fe.normal_vector(k) * Duh1[k] - fe.normal_vector(k) * Duh2[k];\\n\\u00a0           dinfo1.value(0) +=\\n\\u00a0             (penalty * diff1 * diff1 + h * diff2 * diff2) * fe.JxW(k);\\n\\u00a0         }\\n\\u00a0       dinfo1.value(0) = std::sqrt(dinfo1.value(0));\\n\\u00a0       dinfo2.value(0) = dinfo1.value(0);\\n\\u00a0     }\\n\\u00a0   } // namespace Estimator\\n\\u00a0 \\nFEValuesBase::get_feconst FiniteElement< dim, spacedim > & get_fe() const\\nFiniteElementData::tensor_degreeunsigned int tensor_degree() const\\nFinally we have an integrator for the error. Since the energy norm for discontinuous Galerkin problems not only involves the difference of the gradient inside the cells, but also the jump terms across faces and at the boundary, we cannot just use VectorTools::integrate_difference(). Instead, we use the MeshWorker interface to compute the error ourselves.\\nThere are several different ways to define this energy norm, but all of them are equivalent to each other uniformly with mesh size (some not uniformly with polynomial degree). Here, we choose    \\n\\\\[ \\\\|u\\\\|_{1,h} =\\n   \\\\sum_{K\\\\in \\\\mathbb T_h} \\\\|\\\\nabla u\\\\|_K^2 + \\\\sum_{F \\\\in F_h^i}\\n   4\\\\sigma_F\\\\|\\\\average{ u \\\\mathbf n}\\\\|^2_F + \\\\sum_{F \\\\in F_h^b}\\n   2\\\\sigma_F\\\\|u\\\\|^2_F \\\\]\\n\\nBelow, the first function is, as always, the integration on cells. There is currently no good interface in MeshWorker that would allow us to access values of regular functions in the quadrature points. Thus, we have to create the vectors for the exact function's values and gradients inside the cell integrator. After that, everything is as before and we just add up the squares of the differences.\\nAdditionally to computing the error in the energy norm, we use the capability of the mesh worker to compute two functionals at the same time and compute the L2-error in the same loop. Obviously, this one does not have any jump terms and only appears in the integration on cells.\\n\\u00a0   namespace ErrorIntegrator\\n\\u00a0   {\\n\\u00a0     template <int dim>\\n\\u00a0     void cell(MeshWorker::DoFInfo<dim>         &dinfo,\\n\\u00a0               MeshWorker::IntegrationInfo<dim> &info)\\n\\u00a0     {\\n\\u00a0       const FEValuesBase<dim>    &fe = info.fe_values();\\n\\u00a0       std::vector<Tensor<1, dim>> exact_gradients(fe.n_quadrature_points);\\n\\u00a0       std::vector<double>         exact_values(fe.n_quadrature_points);\\n\\u00a0 \\n\\u00a0       exact_solution.gradient_list(fe.get_quadrature_points(), exact_gradients);\\n\\u00a0       exact_solution.value_list(fe.get_quadrature_points(), exact_values);\\n\\u00a0 \\n\\u00a0       const std::vector<Tensor<1, dim>> &Duh = info.gradients[0][0];\\n\\u00a0       const std::vector<double>         &uh  = info.values[0][0];\\n\\u00a0 \\n\\u00a0       for (unsigned k = 0; k < fe.n_quadrature_points; ++k)\\n\\u00a0         {\\n\\u00a0           double sum = 0;\\n\\u00a0           for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0             {\\n\\u00a0               const double diff = exact_gradients[k][d] - Duh[k][d];\\n\\u00a0               sum += diff * diff;\\n\\u00a0             }\\n\\u00a0           const double diff = exact_values[k] - uh[k];\\n\\u00a0           dinfo.value(0) += sum * fe.JxW(k);\\n\\u00a0           dinfo.value(1) += diff * diff * fe.JxW(k);\\n\\u00a0         }\\n\\u00a0       dinfo.value(0) = std::sqrt(dinfo.value(0));\\n\\u00a0       dinfo.value(1) = std::sqrt(dinfo.value(1));\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void boundary(MeshWorker::DoFInfo<dim>         &dinfo,\\n\\u00a0                   MeshWorker::IntegrationInfo<dim> &info)\\n\\u00a0     {\\n\\u00a0       const FEValuesBase<dim> &fe = info.fe_values();\\n\\u00a0 \\n\\u00a0       std::vector<double> exact_values(fe.n_quadrature_points);\\n\\u00a0       exact_solution.value_list(fe.get_quadrature_points(), exact_values);\\n\\u00a0 \\n\\u00a0       const std::vector<double> &uh = info.values[0][0];\\n\\u00a0 \\n\\u00a0       const unsigned int degree  = fe.get_fe().tensor_degree();\\n\\u00a0       const double       penalty = 2. * degree * (degree + 1) *\\n\\u00a0                              dinfo.face->measure() / dinfo.cell->measure();\\n\\u00a0 \\n\\u00a0       for (unsigned k = 0; k < fe.n_quadrature_points; ++k)\\n\\u00a0         {\\n\\u00a0           const double diff = exact_values[k] - uh[k];\\n\\u00a0           dinfo.value(0) += penalty * diff * diff * fe.JxW(k);\\n\\u00a0         }\\n\\u00a0       dinfo.value(0) = std::sqrt(dinfo.value(0));\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void face(MeshWorker::DoFInfo<dim>         &dinfo1,\\n\\u00a0               MeshWorker::DoFInfo<dim>         &dinfo2,\\n\\u00a0               MeshWorker::IntegrationInfo<dim> &info1,\\n\\u00a0               MeshWorker::IntegrationInfo<dim> &info2)\\n\\u00a0     {\\n\\u00a0       const FEValuesBase<dim>   &fe  = info1.fe_values();\\n\\u00a0       const std::vector<double> &uh1 = info1.values[0][0];\\n\\u00a0       const std::vector<double> &uh2 = info2.values[0][0];\\n\\u00a0 \\n\\u00a0       const unsigned int degree = fe.get_fe().tensor_degree();\\n\\u00a0       const double       penalty1 =\\n\\u00a0         degree * (degree + 1) * dinfo1.face->measure() / dinfo1.cell->measure();\\n\\u00a0       const double penalty2 =\\n\\u00a0         degree * (degree + 1) * dinfo2.face->measure() / dinfo2.cell->measure();\\n\\u00a0       const double penalty = penalty1 + penalty2;\\n\\u00a0 \\n\\u00a0       for (unsigned k = 0; k < fe.n_quadrature_points; ++k)\\n\\u00a0         {\\n\\u00a0           const double diff = uh1[k] - uh2[k];\\n\\u00a0           dinfo1.value(0) += (penalty * diff * diff) * fe.JxW(k);\\n\\u00a0         }\\n\\u00a0       dinfo1.value(0) = std::sqrt(dinfo1.value(0));\\n\\u00a0       dinfo2.value(0) = dinfo1.value(0);\\n\\u00a0     }\\n\\u00a0   } // namespace ErrorIntegrator\\n\\u00a0 \\n\\u00a0 \\n The main class\\nThis class does the main job, like in previous examples. For a description of the functions declared here, please refer to the implementation below.\\n\\u00a0   template <int dim>\\n\\u00a0   class InteriorPenaltyProblem\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     using CellInfo = MeshWorker::IntegrationInfo<dim>;\\n\\u00a0 \\n\\u00a0     InteriorPenaltyProblem();\\n\\u00a0 \\n\\u00a0     void run(unsigned int n_steps);\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void   setup_system();\\n\\u00a0     void   assemble_matrix();\\n\\u00a0     void   assemble_mg_matrix();\\n\\u00a0     void   assemble_right_hand_side();\\n\\u00a0     void   error();\\n\\u00a0     double estimate();\\n\\u00a0     void   solve();\\n\\u00a0     void   output_results(const unsigned int cycle) const;\\n\\u00a0 \\nThe member objects related to the discretization are here.\\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0     const MappingQ1<dim> mapping;\\n\\u00a0     const FE_DGQ<2>      fe;\\n\\u00a0     DoFHandler<dim>      dof_handler;\\n\\u00a0 \\nDoFHandlerDefinition dof_handler.h:317\\nFE_DGQDefinition fe_dgq.h:112\\nMappingQ1Definition mapping_q1.h:55\\nTriangulationDefinition tria.h:1323\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\nThen, we have the matrices and vectors related to the global discrete system.\\n\\u00a0     SparsityPattern      sparsity;\\n\\u00a0     SparseMatrix<double> matrix;\\n\\u00a0     Vector<double>       solution;\\n\\u00a0     Vector<double>       right_hand_side;\\n\\u00a0     BlockVector<double>  estimates;\\n\\u00a0 \\nBlockVectorDefinition block_vector.h:71\\nSparseMatrixDefinition sparse_matrix.h:520\\nSparsityPatternDefinition sparsity_pattern.h:343\\nFinally, we have a group of sparsity patterns and sparse matrices related to the multilevel preconditioner. First, we have a level matrix and its sparsity pattern.\\n\\u00a0     MGLevelObject<SparsityPattern>      mg_sparsity;\\n\\u00a0     MGLevelObject<SparseMatrix<double>> mg_matrix;\\n\\u00a0 \\nMGLevelObjectDefinition mg_level_object.h:49\\nWhen we perform multigrid with local smoothing on locally refined meshes, additional matrices are required; see Kanschat (2004). Here is the sparsity pattern for these edge matrices. We only need one, because the pattern of the up matrix is the transpose of that of the down matrix. Actually, we do not care too much about these details, since the MeshWorker is filling these matrices.\\n\\u00a0     MGLevelObject<SparsityPattern> mg_sparsity_dg_interface;\\nThe flux matrix at the refinement edge, coupling fine level degrees of freedom to coarse level.\\n\\u00a0     MGLevelObject<SparseMatrix<double>> mg_matrix_dg_down;\\nThe transpose of the flux matrix at the refinement edge, coupling coarse level degrees of freedom to fine level.\\n\\u00a0     MGLevelObject<SparseMatrix<double>> mg_matrix_dg_up;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\nThe constructor simply sets up the coarse grid and the DoFHandler.\\n\\u00a0   template <int dim>\\n\\u00a0   InteriorPenaltyProblem<dim>::InteriorPenaltyProblem()\\n\\u00a0     : triangulation(Triangulation<dim>::limit_level_difference_at_vertices)\\n\\u00a0     , mapping()\\n\\u00a0     , fe(3)\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0     , estimates(1)\\n\\u00a0   {\\n\\u00a0     GridGenerator::hyper_cube_slit(triangulation, -1, 1);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nGridGenerator::hyper_cube_slitvoid hyper_cube_slit(Triangulation< dim > &tria, const double left=0., const double right=1., const bool colorize=false)\\nIn this function, we set up the dimension of the linear system and the sparsity patterns for the global matrix as well as the level matrices.\\n\\u00a0   template <int dim>\\n\\u00a0   void InteriorPenaltyProblem<dim>::setup_system()\\n\\u00a0   {\\nFirst, we use the finite element to distribute degrees of freedom over the mesh and number them.\\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0     dof_handler.distribute_mg_dofs();\\n\\u00a0     unsigned int n_dofs = dof_handler.n_dofs();\\nThen, we already know the size of the vectors representing finite element functions.\\n\\u00a0     solution.reinit(n_dofs);\\n\\u00a0     right_hand_side.reinit(n_dofs);\\n\\u00a0 \\nNext, we set up the sparsity pattern for the global matrix. Since we do not know the row sizes in advance, we first fill a temporary DynamicSparsityPattern object and copy it to the regular SparsityPattern once it is complete.\\n\\u00a0     DynamicSparsityPattern dsp(n_dofs);\\n\\u00a0     DoFTools::make_flux_sparsity_pattern(dof_handler, dsp);\\n\\u00a0     sparsity.copy_from(dsp);\\n\\u00a0     matrix.reinit(sparsity);\\n\\u00a0 \\n\\u00a0     const unsigned int n_levels = triangulation.n_levels();\\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nTriangulation::n_levelsunsigned int n_levels() const\\nDoFTools::make_flux_sparsity_patternvoid make_flux_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern)Definition dof_tools_sparsity.cc:697\\nThe global system is set up, now we attend to the level matrices. We resize all matrix objects to hold one matrix per level.\\n\\u00a0     mg_matrix.resize(0, n_levels - 1);\\n\\u00a0     mg_matrix.clear_elements();\\n\\u00a0     mg_matrix_dg_up.resize(0, n_levels - 1);\\n\\u00a0     mg_matrix_dg_up.clear_elements();\\n\\u00a0     mg_matrix_dg_down.resize(0, n_levels - 1);\\n\\u00a0     mg_matrix_dg_down.clear_elements();\\nIt is important to update the sparsity patterns after clear() was called for the level matrices, since the matrices lock the sparsity pattern through the SmartPointer and Subscriptor mechanism.\\n\\u00a0     mg_sparsity.resize(0, n_levels - 1);\\n\\u00a0     mg_sparsity_dg_interface.resize(0, n_levels - 1);\\n\\u00a0 \\nNow all objects are prepared to hold one sparsity pattern or matrix per level. What's left is setting up the sparsity patterns on each level.\\n\\u00a0     for (unsigned int level = mg_sparsity.min_level();\\n\\u00a0          level <= mg_sparsity.max_level();\\n\\u00a0          ++level)\\n\\u00a0       {\\nlevelunsigned int levelDefinition grid_out.cc:4626\\nThese are roughly the same lines as above for the global matrix, now for each level.\\n\\u00a0         DynamicSparsityPattern dsp(dof_handler.n_dofs(level));\\n\\u00a0         MGTools::make_flux_sparsity_pattern(dof_handler, dsp, level);\\n\\u00a0         mg_sparsity[level].copy_from(dsp);\\n\\u00a0         mg_matrix[level].reinit(mg_sparsity[level]);\\n\\u00a0 \\nMGTools::make_flux_sparsity_patternvoid make_flux_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity, const unsigned int level, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true)Definition mg_tools.cc:605\\nAdditionally, we need to initialize the transfer matrices at the refinement edge between levels. They are stored at the index referring to the finer of the two indices, thus there is no such object on level 0.\\n\\u00a0         if (level > 0)\\n\\u00a0           {\\n\\u00a0             DynamicSparsityPattern dsp;\\n\\u00a0             dsp.reinit(dof_handler.n_dofs(level - 1),\\n\\u00a0                        dof_handler.n_dofs(level));\\n\\u00a0             MGTools::make_flux_sparsity_pattern_edge(dof_handler, dsp, level);\\n\\u00a0             mg_sparsity_dg_interface[level].copy_from(dsp);\\n\\u00a0             mg_matrix_dg_up[level].reinit(mg_sparsity_dg_interface[level]);\\n\\u00a0             mg_matrix_dg_down[level].reinit(mg_sparsity_dg_interface[level]);\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nDynamicSparsityPattern::reinitvoid reinit(const size_type m, const size_type n, const IndexSet &rowset=IndexSet())Definition dynamic_sparsity_pattern.cc:290\\nMGTools::make_flux_sparsity_pattern_edgevoid make_flux_sparsity_pattern_edge(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity, const unsigned int level)Definition mg_tools.cc:679\\nIn this function, we assemble the global system matrix, where by global we indicate that this is the matrix of the discrete system we solve and it is covering the whole mesh.\\n\\u00a0   template <int dim>\\n\\u00a0   void InteriorPenaltyProblem<dim>::assemble_matrix()\\n\\u00a0   {\\nFirst, we need t set up the object providing the values we integrate. This object contains all FEValues and FEFaceValues objects needed and also maintains them automatically such that they always point to the current cell. To this end, we need to tell it first, where and what to compute. Since we are not doing anything fancy, we can rely on their standard choice for quadrature rules.\\nSince their default update flags are minimal, we add what we need additionally, namely the values and gradients of shape functions on all objects (cells, boundary and interior faces). Afterwards, we are ready to initialize the container, which will create all necessary FEValuesBase objects for integration.\\n\\u00a0     MeshWorker::IntegrationInfoBox<dim> info_box;\\n\\u00a0     UpdateFlags update_flags = update_values | update_gradients;\\n\\u00a0     info_box.add_update_flags_all(update_flags);\\n\\u00a0     info_box.initialize(fe, mapping);\\n\\u00a0 \\nMeshWorker::IntegrationInfoBoxDefinition integration_info.h:297\\nMeshWorker::IntegrationInfoBox::add_update_flags_allvoid add_update_flags_all(const UpdateFlags flags)Definition integration_info.h:751\\nUpdateFlagsUpdateFlagsDefinition fe_update_flags.h:64\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nThis is the object into which we integrate local data. It is filled by the local integration routines in MatrixIntegrator and then used by the assembler to distribute the information into the global matrix.\\n\\u00a0     MeshWorker::DoFInfo<dim> dof_info(dof_handler);\\n\\u00a0 \\nFurthermore, we need an object that assembles the local matrix into the global matrix. These assembler objects have all the knowledge of the structures of the target object, in this case a SparseMatrix, possible constraints and the mesh structure.\\n\\u00a0     MeshWorker::Assembler::MatrixSimple<SparseMatrix<double>> assembler;\\n\\u00a0     assembler.initialize(matrix);\\n\\u00a0 \\nMeshWorker::Assembler::MatrixSimpleDefinition simple.h:152\\nMeshWorker::Assembler::MatrixSimple::initializevoid initialize(MatrixType &m)Definition simple.h:584\\nNow, we throw everything into a MeshWorker::loop<dim, dim>(), which here traverses all active cells of the mesh, computes cell and face matrices and assembles them into the global matrix. We use the variable dof_handler here in order to use the global numbering of degrees of freedom.\\n\\u00a0     MeshWorker::loop<dim, dim>(dof_handler.begin_active(),\\n\\u00a0                                dof_handler.end(),\\n\\u00a0                                dof_info,\\n\\u00a0                                info_box,\\n\\u00a0                                &MatrixIntegrator::cell<dim>,\\n\\u00a0                                &MatrixIntegrator::boundary<dim>,\\n\\u00a0                                &MatrixIntegrator::face<dim>,\\n\\u00a0                                assembler);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nMeshWorker::loopvoid loop(IteratorType begin, std_cxx20::type_identity_t< IteratorType > end, DOFINFO &dinfo, INFOBOX &info, const std::function< void(std_cxx20::type_identity_t< DOFINFO > &, typename INFOBOX::CellInfo &)> &cell_worker, const std::function< void(std_cxx20::type_identity_t< DOFINFO > &, typename INFOBOX::CellInfo &)> &boundary_worker, const std::function< void(std_cxx20::type_identity_t< DOFINFO > &, std_cxx20::type_identity_t< DOFINFO > &, typename INFOBOX::CellInfo &, typename INFOBOX::CellInfo &)> &face_worker, AssemblerType &assembler, const LoopControl &lctrl=LoopControl())Definition loop.h:564\\nNow, we do the same for the level matrices. Not too surprisingly, this function looks like a twin of the previous one. Indeed, there are only two minor differences.\\n\\u00a0   template <int dim>\\n\\u00a0   void InteriorPenaltyProblem<dim>::assemble_mg_matrix()\\n\\u00a0   {\\n\\u00a0     MeshWorker::IntegrationInfoBox<dim> info_box;\\n\\u00a0     UpdateFlags update_flags = update_values | update_gradients;\\n\\u00a0     info_box.add_update_flags_all(update_flags);\\n\\u00a0     info_box.initialize(fe, mapping);\\n\\u00a0 \\n\\u00a0     MeshWorker::DoFInfo<dim> dof_info(dof_handler);\\n\\u00a0 \\nObviously, the assembler needs to be replaced by one filling level matrices. Note that it automatically fills the edge matrices as well.\\n\\u00a0     MeshWorker::Assembler::MGMatrixSimple<SparseMatrix<double>> assembler;\\n\\u00a0     assembler.initialize(mg_matrix);\\n\\u00a0     assembler.initialize_fluxes(mg_matrix_dg_up, mg_matrix_dg_down);\\n\\u00a0 \\nMeshWorker::Assembler::MGMatrixSimpleDefinition simple.h:254\\nMeshWorker::Assembler::MGMatrixSimple::initializevoid initialize(MGLevelObject< MatrixType > &m)Definition simple.h:767\\nHere is the other difference to the previous function: we run over all cells, not only the active ones. And we use functions ending on _mg since we need the degrees of freedom on each level, not the global numbering.\\n\\u00a0     MeshWorker::loop<dim, dim>(dof_handler.begin_mg(),\\n\\u00a0                                dof_handler.end_mg(),\\n\\u00a0                                dof_info,\\n\\u00a0                                info_box,\\n\\u00a0                                &MatrixIntegrator::cell<dim>,\\n\\u00a0                                &MatrixIntegrator::boundary<dim>,\\n\\u00a0                                &MatrixIntegrator::face<dim>,\\n\\u00a0                                assembler);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nHere we have another clone of the assemble function. The difference to assembling the system matrix consists in that we assemble a vector here.\\n\\u00a0   template <int dim>\\n\\u00a0   void InteriorPenaltyProblem<dim>::assemble_right_hand_side()\\n\\u00a0   {\\n\\u00a0     MeshWorker::IntegrationInfoBox<dim> info_box;\\n\\u00a0     UpdateFlags                         update_flags =\\n\\u00a0       update_quadrature_points | update_values | update_gradients;\\n\\u00a0     info_box.add_update_flags_all(update_flags);\\n\\u00a0     info_box.initialize(fe, mapping);\\n\\u00a0 \\n\\u00a0     MeshWorker::DoFInfo<dim> dof_info(dof_handler);\\n\\u00a0 \\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nSince this assembler allows us to fill several vectors, the interface is a little more complicated as above. The pointers to the vectors have to be stored in an AnyData object. While this seems to cause two extra lines of code here, it actually comes handy in more complex applications.\\n\\u00a0     MeshWorker::Assembler::ResidualSimple<Vector<double>> assembler;\\n\\u00a0     AnyData                                               data;\\n\\u00a0     data.add<Vector<double> *>(&right_hand_side, \\\"RHS\\\");\\n\\u00a0     assembler.initialize(data);\\n\\u00a0 \\n\\u00a0     MeshWorker::loop<dim, dim>(dof_handler.begin_active(),\\n\\u00a0                                dof_handler.end(),\\n\\u00a0                                dof_info,\\n\\u00a0                                info_box,\\n\\u00a0                                &RHSIntegrator::cell<dim>,\\n\\u00a0                                &RHSIntegrator::boundary<dim>,\\n\\u00a0                                &RHSIntegrator::face<dim>,\\n\\u00a0                                assembler);\\n\\u00a0 \\n\\u00a0     right_hand_side *= -1.;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nAnyDataDefinition any_data.h:36\\nAnyData::addvoid add(type entry, const std::string &name)Add a new data object.Definition any_data.h:430\\nMeshWorker::Assembler::ResidualSimpleDefinition simple.h:59\\nNow that we have coded all functions building the discrete linear system, it is about time that we actually solve it.\\n\\u00a0   template <int dim>\\n\\u00a0   void InteriorPenaltyProblem<dim>::solve()\\n\\u00a0   {\\nThe solver of choice is conjugate gradient.\\n\\u00a0     SolverControl            control(1000, 1.e-12);\\n\\u00a0     SolverCG<Vector<double>> solver(control);\\n\\u00a0 \\nSolverCGDefinition solver_cg.h:179\\nSolverControlDefinition solver_control.h:67\\nNow we are setting up the components of the multilevel preconditioner. First, we need transfer between grid levels. The object we are using here generates sparse matrices for these transfers.\\n\\u00a0     MGTransferPrebuilt<Vector<double>> mg_transfer;\\n\\u00a0     mg_transfer.build(dof_handler);\\n\\u00a0 \\nMGTransferPrebuiltDefinition mg_transfer.h:628\\nMGTransferPrebuilt::buildvoid build(const DoFHandler< dim, spacedim > &dof_handler)Definition mg_transfer_prebuilt.cc:151\\nThen, we need an exact solver for the matrix on the coarsest level.\\n\\u00a0     FullMatrix<double> coarse_matrix;\\n\\u00a0     coarse_matrix.copy_from(mg_matrix[0]);\\n\\u00a0     MGCoarseGridHouseholder<double, Vector<double>> mg_coarse;\\n\\u00a0     mg_coarse.initialize(coarse_matrix);\\n\\u00a0 \\nFullMatrix::copy_fromvoid copy_from(const MatrixType &)\\nMGCoarseGridHouseholderDefinition mg_coarse.h:177\\nMGCoarseGridHouseholder::initializevoid initialize(const FullMatrix< number > &A)\\nWhile transfer and coarse grid solver are pretty much generic, more flexibility is offered for the smoother. First, we choose Gauss-Seidel as our smoothing method.\\n\\u00a0     GrowingVectorMemory<Vector<double>> mem;\\n\\u00a0     using RELAXATION = PreconditionSOR<SparseMatrix<double>>;\\n\\u00a0     mg::SmootherRelaxation<RELAXATION, Vector<double>> mg_smoother;\\n\\u00a0     RELAXATION::AdditionalData                         smoother_data(1.);\\n\\u00a0     mg_smoother.initialize(mg_matrix, smoother_data);\\n\\u00a0 \\nGrowingVectorMemoryDefinition vector_memory.h:314\\nPreconditionSORDefinition precondition.h:1726\\nmg::SmootherRelaxationDefinition mg_smoother.h:186\\nDo two smoothing steps on each level.\\n\\u00a0     mg_smoother.set_steps(2);\\nSince the SOR method is not symmetric, but we use conjugate gradient iteration below, here is a trick to make the multilevel preconditioner a symmetric operator even for nonsymmetric smoothers.\\n\\u00a0     mg_smoother.set_symmetric(true);\\nThe smoother class optionally implements the variable V-cycle, which we do not want here.\\n\\u00a0     mg_smoother.set_variable(false);\\n\\u00a0 \\nFinally, we must wrap our matrices in an object having the required multiplication functions.\\n\\u00a0     mg::Matrix<Vector<double>> mgmatrix(mg_matrix);\\n\\u00a0     mg::Matrix<Vector<double>> mgdown(mg_matrix_dg_down);\\n\\u00a0     mg::Matrix<Vector<double>> mgup(mg_matrix_dg_up);\\n\\u00a0 \\nmg::MatrixDefinition mg_matrix.h:46\\nNow, we are ready to set up the V-cycle operator and the multilevel preconditioner.\\n\\u00a0     Multigrid<Vector<double>> mg(\\n\\u00a0       mgmatrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);\\nMultigridDefinition multigrid.h:163\\nmgDefinition mg.h:81\\nLet us not forget the edge matrices needed because of the adaptive refinement.\\n\\u00a0     mg.set_edge_flux_matrices(mgdown, mgup);\\n\\u00a0 \\nAfter all preparations, wrap the Multigrid object into another object, which can be used as a regular preconditioner,\\n\\u00a0     PreconditionMG<dim, Vector<double>, MGTransferPrebuilt<Vector<double>>>\\n\\u00a0       preconditioner(dof_handler, mg, mg_transfer);\\nPreconditionMGDefinition multigrid.h:501\\nand use it to solve the system.\\n\\u00a0     solver.solve(matrix, solution, right_hand_side, preconditioner);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nAnother clone of the assemble function. The big difference to the previous ones is here that we also have an input vector.\\n\\u00a0   template <int dim>\\n\\u00a0   double InteriorPenaltyProblem<dim>::estimate()\\n\\u00a0   {\\nThe results of the estimator are stored in a vector with one entry per cell. Since cells in deal.II are not numbered, we have to create our own numbering in order to use this vector. For the assembler used below the information in which component of a vector the result is stored is transmitted by the user_index variable for each cell. We need to set this numbering up here.\\nOn the other hand, somebody might have used the user indices already. So, let's be good citizens and save them before tampering with them.\\n\\u00a0     std::vector<unsigned int> old_user_indices;\\n\\u00a0     triangulation.save_user_indices(old_user_indices);\\n\\u00a0 \\n\\u00a0     estimates.block(0).reinit(triangulation.n_active_cells());\\n\\u00a0     unsigned int i = 0;\\n\\u00a0     for (const auto &cell : triangulation.active_cell_iterators())\\n\\u00a0       cell->set_user_index(i++);\\n\\u00a0 \\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nTriangulation::save_user_indicesvoid save_user_indices(std::vector< unsigned int > &v) const\\nThis starts like before,\\n\\u00a0     MeshWorker::IntegrationInfoBox<dim> info_box;\\n\\u00a0     const unsigned int                  n_gauss_points =\\n\\u00a0       dof_handler.get_fe().tensor_degree() + 1;\\n\\u00a0     info_box.initialize_gauss_quadrature(n_gauss_points,\\n\\u00a0                                          n_gauss_points + 1,\\n\\u00a0                                          n_gauss_points);\\n\\u00a0 \\nMeshWorker::IntegrationInfoBox::initialize_gauss_quadraturevoid initialize_gauss_quadrature(unsigned int n_cell_points, unsigned int n_boundary_points, unsigned int n_face_points, const bool force=true)Definition integration_info.h:735\\nbut now we need to notify the info box of the finite element function we want to evaluate in the quadrature points. First, we create an AnyData object with this vector, which is the solution we just computed.\\n\\u00a0     AnyData solution_data;\\n\\u00a0     solution_data.add<const Vector<double> *>(&solution, \\\"solution\\\");\\n\\u00a0 \\nThen, we tell the Meshworker::VectorSelector for cells, that we need the second derivatives of this solution (to compute the Laplacian). Therefore, the Boolean arguments selecting function values and first derivatives a false, only the last one selecting second derivatives is true.\\n\\u00a0     info_box.cell_selector.add(\\\"solution\\\", false, false, true);\\nOn interior and boundary faces, we need the function values and the first derivatives, but not second derivatives.\\n\\u00a0     info_box.boundary_selector.add(\\\"solution\\\", true, true, false);\\n\\u00a0     info_box.face_selector.add(\\\"solution\\\", true, true, false);\\n\\u00a0 \\nAnd we continue as before, with the exception that the default update flags are already adjusted to the values and derivatives we requested above.\\n\\u00a0     info_box.add_update_flags_boundary(update_quadrature_points);\\n\\u00a0     info_box.initialize(fe, mapping, solution_data, solution);\\n\\u00a0 \\n\\u00a0     MeshWorker::DoFInfo<dim> dof_info(dof_handler);\\n\\u00a0 \\nThe assembler stores one number per cell, but else this is the same as in the computation of the right hand side.\\n\\u00a0     MeshWorker::Assembler::CellsAndFaces<double> assembler;\\n\\u00a0     AnyData                                      out_data;\\n\\u00a0     out_data.add<BlockVector<double> *>(&estimates, \\\"cells\\\");\\n\\u00a0     assembler.initialize(out_data, false);\\n\\u00a0 \\n\\u00a0     MeshWorker::loop<dim, dim>(dof_handler.begin_active(),\\n\\u00a0                                dof_handler.end(),\\n\\u00a0                                dof_info,\\n\\u00a0                                info_box,\\n\\u00a0                                &Estimator::cell<dim>,\\n\\u00a0                                &Estimator::boundary<dim>,\\n\\u00a0                                &Estimator::face<dim>,\\n\\u00a0                                assembler);\\n\\u00a0 \\nMeshWorker::Assembler::CellsAndFacesDefinition functional.h:106\\nRight before we return the result of the error estimate, we restore the old user indices.\\n\\u00a0     triangulation.load_user_indices(old_user_indices);\\n\\u00a0     return estimates.block(0).l2_norm();\\n\\u00a0   }\\n\\u00a0 \\nTriangulation::load_user_indicesvoid load_user_indices(const std::vector< unsigned int > &v)\\nHere we compare our finite element solution with the (known) exact solution and compute the mean quadratic error of the gradient and the function itself. This function is a clone of the estimation function right above.\\nSince we compute the error in the energy and the L2-norm, respectively, our block vector needs two blocks here.\\n\\u00a0   template <int dim>\\n\\u00a0   void InteriorPenaltyProblem<dim>::error()\\n\\u00a0   {\\n\\u00a0     BlockVector<double> errors(2);\\n\\u00a0     errors.block(0).reinit(triangulation.n_active_cells());\\n\\u00a0     errors.block(1).reinit(triangulation.n_active_cells());\\n\\u00a0 \\n\\u00a0     std::vector<unsigned int> old_user_indices;\\n\\u00a0     triangulation.save_user_indices(old_user_indices);\\n\\u00a0     unsigned int i = 0;\\n\\u00a0     for (const auto &cell : triangulation.active_cell_iterators())\\n\\u00a0       cell->set_user_index(i++);\\n\\u00a0 \\n\\u00a0     MeshWorker::IntegrationInfoBox<dim> info_box;\\n\\u00a0     const unsigned int                  n_gauss_points =\\n\\u00a0       dof_handler.get_fe().tensor_degree() + 1;\\n\\u00a0     info_box.initialize_gauss_quadrature(n_gauss_points,\\n\\u00a0                                          n_gauss_points + 1,\\n\\u00a0                                          n_gauss_points);\\n\\u00a0 \\n\\u00a0     AnyData solution_data;\\n\\u00a0     solution_data.add<Vector<double> *>(&solution, \\\"solution\\\");\\n\\u00a0 \\n\\u00a0     info_box.cell_selector.add(\\\"solution\\\", true, true, false);\\n\\u00a0     info_box.boundary_selector.add(\\\"solution\\\", true, false, false);\\n\\u00a0     info_box.face_selector.add(\\\"solution\\\", true, false, false);\\n\\u00a0 \\n\\u00a0     info_box.add_update_flags_cell(update_quadrature_points);\\n\\u00a0     info_box.add_update_flags_boundary(update_quadrature_points);\\n\\u00a0     info_box.initialize(fe, mapping, solution_data, solution);\\n\\u00a0 \\n\\u00a0     MeshWorker::DoFInfo<dim> dof_info(dof_handler);\\n\\u00a0 \\n\\u00a0     MeshWorker::Assembler::CellsAndFaces<double> assembler;\\n\\u00a0     AnyData                                      out_data;\\n\\u00a0     out_data.add<BlockVector<double> *>(&errors, \\\"cells\\\");\\n\\u00a0     assembler.initialize(out_data, false);\\n\\u00a0 \\n\\u00a0     MeshWorker::loop<dim, dim>(dof_handler.begin_active(),\\n\\u00a0                                dof_handler.end(),\\n\\u00a0                                dof_info,\\n\\u00a0                                info_box,\\n\\u00a0                                &ErrorIntegrator::cell<dim>,\\n\\u00a0                                &ErrorIntegrator::boundary<dim>,\\n\\u00a0                                &ErrorIntegrator::face<dim>,\\n\\u00a0                                assembler);\\n\\u00a0     triangulation.load_user_indices(old_user_indices);\\n\\u00a0 \\n\\u00a0     deallog << \\\"energy-error: \\\" << errors.block(0).l2_norm() << std::endl;\\n\\u00a0     deallog << \\\"L2-error:     \\\" << errors.block(1).l2_norm() << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nVector::addvoid add(const std::vector< size_type > &indices, const std::vector< OtherNumber > &values)\\ndeallogLogStream deallogDefinition logstream.cc:36\\nCreate graphical output. We produce the filename by collating the name from its various components, including the refinement cycle that we output with two digits.\\n\\u00a0   template <int dim>\\n\\u00a0   void\\n\\u00a0   InteriorPenaltyProblem<dim>::output_results(const unsigned int cycle) const\\n\\u00a0   {\\n\\u00a0     const std::string filename =\\n\\u00a0       \\\"sol-\\\" + Utilities::int_to_string(cycle, 2) + \\\".gnuplot\\\";\\n\\u00a0 \\n\\u00a0     deallog << \\\"Writing solution to <\\\" << filename << \\\">...\\\" << std::endl\\n\\u00a0             << std::endl;\\n\\u00a0     std::ofstream gnuplot_output(filename);\\n\\u00a0 \\n\\u00a0     DataOut<dim> data_out;\\n\\u00a0     data_out.attach_dof_handler(dof_handler);\\n\\u00a0     data_out.add_data_vector(solution, \\\"u\\\");\\n\\u00a0     data_out.add_data_vector(estimates.block(0), \\\"est\\\");\\n\\u00a0 \\n\\u00a0     data_out.build_patches();\\n\\u00a0 \\n\\u00a0     data_out.write_gnuplot(gnuplot_output);\\n\\u00a0   }\\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nUtilities::int_to_stringstd::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)Definition utilities.cc:470\\nAnd finally the adaptive loop, more or less like in previous examples.\\n\\u00a0   template <int dim>\\n\\u00a0   void InteriorPenaltyProblem<dim>::run(unsigned int n_steps)\\n\\u00a0   {\\n\\u00a0     deallog << \\\"Element: \\\" << fe.get_name() << std::endl;\\n\\u00a0     for (unsigned int s = 0; s < n_steps; ++s)\\n\\u00a0       {\\n\\u00a0         deallog << \\\"Step \\\" << s << std::endl;\\n\\u00a0         if (estimates.block(0).size() == 0)\\n\\u00a0           triangulation.refine_global(1);\\n\\u00a0         else\\n\\u00a0           {\\n\\u00a0             GridRefinement::refine_and_coarsen_fixed_fraction(\\n\\u00a0               triangulation, estimates.block(0), 0.5, 0.0);\\n\\u00a0             triangulation.execute_coarsening_and_refinement();\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         deallog << \\\"Triangulation \\\" << triangulation.n_active_cells()\\n\\u00a0                 << \\\" cells, \\\" << triangulation.n_levels() << \\\" levels\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0 \\n\\u00a0         setup_system();\\n\\u00a0         deallog << \\\"DoFHandler \\\" << dof_handler.n_dofs() << \\\" dofs, level dofs\\\";\\n\\u00a0         for (unsigned int l = 0; l < triangulation.n_levels(); ++l)\\n\\u00a0           deallog << ' ' << dof_handler.n_dofs(l);\\n\\u00a0         deallog << std::endl;\\n\\u00a0 \\n\\u00a0         deallog << \\\"Assemble matrix\\\" << std::endl;\\n\\u00a0         assemble_matrix();\\n\\u00a0         deallog << \\\"Assemble multilevel matrix\\\" << std::endl;\\n\\u00a0         assemble_mg_matrix();\\n\\u00a0         deallog << \\\"Assemble right hand side\\\" << std::endl;\\n\\u00a0         assemble_right_hand_side();\\n\\u00a0         deallog << \\\"Solve\\\" << std::endl;\\n\\u00a0         solve();\\n\\u00a0         error();\\n\\u00a0         deallog << \\\"Estimate \\\" << estimate() << std::endl;\\n\\u00a0         output_results(s);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 } // namespace Step39\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       using namespace dealii;\\n\\u00a0       using namespace Step39;\\n\\u00a0 \\n\\u00a0       deallog.depth_console(2);\\n\\u00a0       std::ofstream logfile(\\\"deallog\\\");\\n\\u00a0       deallog.attach(logfile);\\n\\u00a0 \\n\\u00a0       InteriorPenaltyProblem<2> test1;\\n\\u00a0       test1.run(12);\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\nLogStream::attachvoid attach(std::ostream &o, const bool print_job_id=true, const std::ios_base::fmtflags flags=std::ios::showpoint|std::ios::left)Definition logstream.cc:218\\nLogStream::depth_consoleunsigned int depth_console(const unsigned int n)Definition logstream.cc:349\\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nparallel::distributed::Triangulation::execute_coarsening_and_refinementvirtual void execute_coarsening_and_refinement() overrideDefinition tria.cc:3320\\nGridRefinement::refine_and_coarsen_fixed_fractionvoid refine_and_coarsen_fixed_fraction(Triangulation< dim, spacedim > &tria, const Vector< Number > &criteria, const double top_fraction, const double bottom_fraction, const unsigned int max_n_cells=std::numeric_limits< unsigned int >::max(), const VectorTools::NormType norm_type=VectorTools::L1_norm)Definition grid_refinement.cc:386\\n Results\\nLogfile output\\nFirst, the program produces the usual logfile here stored in deallog. It reads (with omission of intermediate steps)\\nDEAL::Element: FE_DGQ<2>(3)\\nDEAL::Step 0\\nDEAL::Triangulation 16 cells, 2 levels\\nDEAL::DoFHandler 256 dofs, level dofs 64 256\\nDEAL::Assemble matrix\\nDEAL::Assemble multilevel matrix\\nDEAL::Assemble right hand side\\nDEAL::Solve\\nDEAL:cg::Starting value 37.4071\\nDEAL:cg::Convergence step 13 value 1.64974e-13\\nDEAL::energy-error: 0.297419\\nDEAL::L2-error:     0.00452447\\nDEAL::Estimate 0.990460\\nDEAL::Writing solution to <sol-00.gnuplot>...\\nDEAL::\\nDEAL::Step 1\\nDEAL::Triangulation 25 cells, 3 levels\\nDEAL::DoFHandler 400 dofs, level dofs 64 256 192\\nDEAL::Assemble matrix\\nDEAL::Assemble multilevel matrix\\nDEAL::Assemble right hand side\\nDEAL::Solve\\nDEAL:cg::Starting value 37.4071\\nDEAL:cg::Convergence step 14 value 3.72262e-13\\nDEAL::energy-error: 0.258559\\nDEAL::L2-error:     0.00288510\\nDEAL::Estimate 0.738624\\nDEAL::Writing solution to <sol-01.gnuplot>...\\nDEAL::\\nDEAL::Step 2\\nDEAL::Triangulation 34 cells, 4 levels\\nDEAL::DoFHandler 544 dofs, level dofs 64 256 256 128\\nDEAL::Assemble matrix\\nDEAL::Assemble multilevel matrix\\nDEAL::Assemble right hand side\\nDEAL::Solve\\nDEAL:cg::Starting value 37.4071\\nDEAL:cg::Convergence step 15 value 1.91610e-13\\nDEAL::energy-error: 0.189234\\nDEAL::L2-error:     0.00147954\\nDEAL::Estimate 0.657507\\nDEAL::Writing solution to <sol-02.gnuplot>...\\n \\n...\\n \\nDEAL::Step 10\\nDEAL::Triangulation 232 cells, 11 levels\\nDEAL::DoFHandler 3712 dofs, level dofs 64 256 896 768 768 640 512 256 256 256 256\\nDEAL::Assemble matrix\\nDEAL::Assemble multilevel matrix\\nDEAL::Assemble right hand side\\nDEAL::Solve\\nDEAL:cg::Starting value 51.1571\\nDEAL:cg::Convergence step 15 value 7.19599e-13\\nDEAL::energy-error: 0.0132475\\nDEAL::L2-error:     1.00423e-05\\nDEAL::Estimate 0.0470724\\nDEAL::Writing solution to <sol-10.gnuplot>...\\nDEAL::\\nDEAL::Step 11\\nDEAL::Triangulation 322 cells, 12 levels\\nDEAL::DoFHandler 5152 dofs, level dofs 64 256 1024 1024 896 768 768 640 448 320 320 320\\nDEAL::Assemble matrix\\nDEAL::Assemble multilevel matrix\\nDEAL::Assemble right hand side\\nDEAL::Solve\\nDEAL:cg::Starting value 52.2226\\nDEAL:cg::Convergence step 15 value 8.15195e-13\\nDEAL::energy-error: 0.00934891\\nDEAL::L2-error:     5.41095e-06\\nDEAL::Estimate 0.0329102\\nDEAL::Writing solution to <sol-11.gnuplot>...\\nDEAL::\\nThis log for instance shows that the number of conjugate gradient iteration steps is constant at approximately 15.\\nPostprocessing of the logfile\\n Using the perl script postprocess.pl, we extract relevant data into output.dat, which can be used to plot graphs with gnuplot. The graph above for instance was produced using the gnuplot script plot_errors.gpl via\\n./step-39 | perl postprocess.pl >output.dat\\ngnuplot plot_errors.gpl\\nReference data can be found in output.reference.dat.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2010 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Author: Guido Kanschat, Texas A&M University, 2009\\n */\\n \\n \\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/precondition.h>\\n#include <deal.II/lac/precondition_block.h>\\n#include <deal.II/lac/block_vector.h>\\n \\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_refinement.h>\\n \\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_dgp.h>\\n#include <deal.II/fe/fe_dgq.h>\\n#include <deal.II/dofs/dof_tools.h>\\n#include <deal.II/fe/mapping_q1.h>\\n \\n#include <deal.II/meshworker/dof_info.h>\\n#include <deal.II/meshworker/integration_info.h>\\n#include <deal.II/meshworker/assembler.h>\\n#include <deal.II/meshworker/loop.h>\\n \\n#include <deal.II/integrators/laplace.h>\\n \\n#include <deal.II/multigrid/mg_tools.h>\\n#include <deal.II/multigrid/multigrid.h>\\n#include <deal.II/multigrid/mg_matrix.h>\\n#include <deal.II/multigrid/mg_transfer.h>\\n#include <deal.II/multigrid/mg_coarse.h>\\n#include <deal.II/multigrid/mg_smoother.h>\\n \\n#include <deal.II/base/function_lib.h>\\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/numerics/vector_tools.h>\\n#include <deal.II/numerics/data_out.h>\\n \\n#include <iostream>\\n#include <fstream>\\n \\nnamespace Step39\\n{\\n using namespace dealii;\\n \\n Functions::SlitSingularityFunction<2> exact_solution;\\n \\n \\n \\n namespace MatrixIntegrator\\n  {\\n template <int dim>\\n double ip_penalty_factor(const MeshWorker::DoFInfo<dim> &dinfo1,\\n const MeshWorker::DoFInfo<dim> &dinfo2,\\n unsigned int                    deg1,\\n unsigned int                    deg2)\\n    {\\n const unsigned int normal1 =\\n GeometryInfo<dim>::unit_normal_direction[dinfo1.face_number];\\n const unsigned int normal2 =\\n GeometryInfo<dim>::unit_normal_direction[dinfo2.face_number];\\n const unsigned int deg1sq = (deg1 == 0) ? 1 : deg1 * (deg1 + 1);\\n const unsigned int deg2sq = (deg2 == 0) ? 1 : deg2 * (deg2 + 1);\\n \\n double penalty1 = deg1sq / dinfo1.cell->extent_in_direction(normal1);\\n double penalty2 = deg2sq / dinfo2.cell->extent_in_direction(normal2);\\n if (dinfo1.cell->has_children() && !dinfo2.cell->has_children())\\n        penalty1 *= 2;\\n else if (!dinfo1.cell->has_children() && dinfo2.cell->has_children())\\n        penalty2 *= 2;\\n \\n const double penalty = 0.5 * (penalty1 + penalty2);\\n return penalty;\\n    }\\n \\n \\n template <int dim>\\n void cell(MeshWorker::DoFInfo<dim>         &dinfo,\\n MeshWorker::IntegrationInfo<dim> &info)\\n    {\\n FullMatrix<double> &M = dinfo.matrix(0, false).matrix;\\n \\n for (unsigned int k = 0; k < info.fe_values().n_quadrature_points; ++k)\\n        {\\n const double dx = info.fe_values().JxW(k);\\n \\n for (unsigned int i = 0; i < info.fe_values().dofs_per_cell; ++i)\\n            {\\n const double Mii = (info.fe_values().shape_grad(i, k) *\\n                                  info.fe_values().shape_grad(i, k) * dx);\\n \\n              M(i, i) += Mii;\\n \\n for (unsigned int j = i + 1; j < info.fe_values().dofs_per_cell;\\n                   ++j)\\n                {\\n const double Mij = info.fe_values().shape_grad(j, k) *\\n                                     info.fe_values().shape_grad(i, k) * dx;\\n \\n                  M(i, j) += Mij;\\n                  M(j, i) += Mij;\\n                }\\n            }\\n        }\\n    }\\n \\n \\n template <int dim>\\n void boundary(MeshWorker::DoFInfo<dim>         &dinfo,\\n MeshWorker::IntegrationInfo<dim> &info)\\n    {\\n const FEValuesBase<dim> &fe_face_values = info.fe_values(0);\\n \\n FullMatrix<double> &M = dinfo.matrix(0, false).matrix;\\n AssertDimension(M.n(), fe_face_values.dofs_per_cell);\\n AssertDimension(M.m(), fe_face_values.dofs_per_cell);\\n \\n const unsigned int polynomial_degree =\\n        info.fe_values(0).get_fe().tensor_degree();\\n \\n const double ip_penalty =\\n        ip_penalty_factor(dinfo, dinfo, polynomial_degree, polynomial_degree);\\n \\n for (unsigned int k = 0; k < fe_face_values.n_quadrature_points; ++k)\\n        {\\n const double dx = fe_face_values.JxW(k);\\n const Tensor<1, dim> &n  = fe_face_values.normal_vector(k);\\n \\n for (unsigned int i = 0; i < fe_face_values.dofs_per_cell; ++i)\\n for (unsigned int j = 0; j < fe_face_values.dofs_per_cell; ++j)\\n              M(i, j) += (2. * fe_face_values.shape_value(i, k) * ip_penalty *\\n                            fe_face_values.shape_value(j, k) -\\n                          (n * fe_face_values.shape_grad(i, k)) *\\n                            fe_face_values.shape_value(j, k) -\\n                          (n * fe_face_values.shape_grad(j, k)) *\\n                            fe_face_values.shape_value(i, k)) *\\n                         dx;\\n        }\\n    }\\n \\n template <int dim>\\n void face(MeshWorker::DoFInfo<dim>         &dinfo1,\\n MeshWorker::DoFInfo<dim>         &dinfo2,\\n MeshWorker::IntegrationInfo<dim> &info1,\\n MeshWorker::IntegrationInfo<dim> &info2)\\n    {\\n const FEValuesBase<dim> &fe_face_values_1 = info1.fe_values(0);\\n const FEValuesBase<dim> &fe_face_values_2 = info2.fe_values(0);\\n \\n FullMatrix<double> &M11 = dinfo1.matrix(0, false).matrix;\\n FullMatrix<double> &M12 = dinfo1.matrix(0, true).matrix;\\n FullMatrix<double> &M21 = dinfo2.matrix(0, true).matrix;\\n FullMatrix<double> &M22 = dinfo2.matrix(0, false).matrix;\\n \\n AssertDimension(M11.n(), fe_face_values_1.dofs_per_cell);\\n AssertDimension(M11.m(), fe_face_values_1.dofs_per_cell);\\n AssertDimension(M12.n(), fe_face_values_1.dofs_per_cell);\\n AssertDimension(M12.m(), fe_face_values_1.dofs_per_cell);\\n AssertDimension(M21.n(), fe_face_values_1.dofs_per_cell);\\n AssertDimension(M21.m(), fe_face_values_1.dofs_per_cell);\\n AssertDimension(M22.n(), fe_face_values_1.dofs_per_cell);\\n AssertDimension(M22.m(), fe_face_values_1.dofs_per_cell);\\n \\n const unsigned int polynomial_degree =\\n        info1.fe_values(0).get_fe().tensor_degree();\\n const double ip_penalty =\\n        ip_penalty_factor(dinfo1, dinfo2, polynomial_degree, polynomial_degree);\\n \\n const double nui = 1.;\\n const double nue = 1.;\\n const double nu  = .5 * (nui + nue);\\n \\n for (unsigned int k = 0; k < fe_face_values_1.n_quadrature_points; ++k)\\n        {\\n const double dx = fe_face_values_1.JxW(k);\\n const Tensor<1, dim> &n  = fe_face_values_1.normal_vector(k);\\n \\n for (unsigned int i = 0; i < fe_face_values_1.dofs_per_cell; ++i)\\n            {\\n for (unsigned int j = 0; j < fe_face_values_1.dofs_per_cell; ++j)\\n                {\\n const double vi   = fe_face_values_1.shape_value(i, k);\\n const double dnvi = n * fe_face_values_1.shape_grad(i, k);\\n const double ve   = fe_face_values_2.shape_value(i, k);\\n const double dnve = n * fe_face_values_2.shape_grad(i, k);\\n const double ui   = fe_face_values_1.shape_value(j, k);\\n const double dnui = n * fe_face_values_1.shape_grad(j, k);\\n const double ue   = fe_face_values_2.shape_value(j, k);\\n const double dnue = n * fe_face_values_2.shape_grad(j, k);\\n \\n                  M11(i, j) += (-.5 * nui * dnvi * ui - .5 * nui * dnui * vi +\\n                                nu * ip_penalty * ui * vi) *\\n                               dx;\\n                  M12(i, j) += (.5 * nui * dnvi * ue - .5 * nue * dnue * vi -\\n                                nu * ip_penalty * vi * ue) *\\n                               dx;\\n                  M21(i, j) += (-.5 * nue * dnve * ui + .5 * nui * dnui * ve -\\n                                nu * ip_penalty * ui * ve) *\\n                               dx;\\n                  M22(i, j) += (.5 * nue * dnve * ue + .5 * nue * dnue * ve +\\n                                nu * ip_penalty * ue * ve) *\\n                               dx;\\n                }\\n            }\\n        }\\n    }\\n  } // namespace MatrixIntegrator\\n \\n namespace RHSIntegrator\\n  {\\n template <int dim>\\n void cell(MeshWorker::DoFInfo<dim> &, MeshWorker::IntegrationInfo<dim> &)\\n    {}\\n \\n \\n template <int dim>\\n void boundary(MeshWorker::DoFInfo<dim>         &dinfo,\\n MeshWorker::IntegrationInfo<dim> &info)\\n    {\\n const FEValuesBase<dim> &fe           = info.fe_values();\\n Vector<double>          &local_vector = dinfo.vector(0).block(0);\\n \\n      std::vector<double> boundary_values(fe.n_quadrature_points);\\n      exact_solution.value_list(fe.get_quadrature_points(), boundary_values);\\n \\n const unsigned int degree  = fe.get_fe().tensor_degree();\\n const double       penalty = 2. * degree * (degree + 1) *\\n                             dinfo.face->measure() / dinfo.cell->measure();\\n \\n for (unsigned k = 0; k < fe.n_quadrature_points; ++k)\\n for (unsigned int i = 0; i < fe.dofs_per_cell; ++i)\\n          local_vector(i) +=\\n            (-penalty * fe.shape_value(i, k) // (-sigma * v_i(x_k)\\n             +\\n             fe.normal_vector(k) * fe.shape_grad(i, k)) // + n * grad v_i(x_k))\\n            * boundary_values[k] * fe.JxW(k);           // u^D(x_k) * dx\\n    }\\n \\n \\n template <int dim>\\n void face(MeshWorker::DoFInfo<dim> &,\\n MeshWorker::DoFInfo<dim> &,\\n MeshWorker::IntegrationInfo<dim> &,\\n MeshWorker::IntegrationInfo<dim> &)\\n    {}\\n  } // namespace RHSIntegrator\\n \\n namespace Estimator\\n  {\\n template <int dim>\\n void cell(MeshWorker::DoFInfo<dim>         &dinfo,\\n MeshWorker::IntegrationInfo<dim> &info)\\n    {\\n const FEValuesBase<dim> &fe = info.fe_values();\\n \\n const std::vector<Tensor<2, dim>> &DDuh = info.hessians[0][0];\\n for (unsigned k = 0; k < fe.n_quadrature_points; ++k)\\n        {\\n const double t = dinfo.cell->diameter() * trace(DDuh[k]);\\n          dinfo.value(0) += t * t * fe.JxW(k);\\n        }\\n      dinfo.value(0) = std::sqrt(dinfo.value(0));\\n    }\\n \\n template <int dim>\\n void boundary(MeshWorker::DoFInfo<dim>         &dinfo,\\n MeshWorker::IntegrationInfo<dim> &info)\\n    {\\n const FEValuesBase<dim> &fe = info.fe_values();\\n \\n      std::vector<double> boundary_values(fe.n_quadrature_points);\\n      exact_solution.value_list(fe.get_quadrature_points(), boundary_values);\\n \\n const std::vector<double> &uh = info.values[0][0];\\n \\n const unsigned int degree  = fe.get_fe().tensor_degree();\\n const double       penalty = 2. * degree * (degree + 1) *\\n                             dinfo.face->measure() / dinfo.cell->measure();\\n \\n for (unsigned k = 0; k < fe.n_quadrature_points; ++k)\\n        {\\n const double diff = boundary_values[k] - uh[k];\\n          dinfo.value(0) += penalty * diff * diff * fe.JxW(k);\\n        }\\n      dinfo.value(0) = std::sqrt(dinfo.value(0));\\n    }\\n \\n \\n template <int dim>\\n void face(MeshWorker::DoFInfo<dim>         &dinfo1,\\n MeshWorker::DoFInfo<dim>         &dinfo2,\\n MeshWorker::IntegrationInfo<dim> &info1,\\n MeshWorker::IntegrationInfo<dim> &info2)\\n    {\\n const FEValuesBase<dim>           &fe   = info1.fe_values();\\n const std::vector<double>         &uh1  = info1.values[0][0];\\n const std::vector<double>         &uh2  = info2.values[0][0];\\n const std::vector<Tensor<1, dim>> &Duh1 = info1.gradients[0][0];\\n const std::vector<Tensor<1, dim>> &Duh2 = info2.gradients[0][0];\\n \\n const unsigned int degree = fe.get_fe().tensor_degree();\\n const double       penalty1 =\\n        degree * (degree + 1) * dinfo1.face->measure() / dinfo1.cell->measure();\\n const double penalty2 =\\n        degree * (degree + 1) * dinfo2.face->measure() / dinfo2.cell->measure();\\n const double penalty = penalty1 + penalty2;\\n const double h       = dinfo1.face->measure();\\n \\n for (unsigned k = 0; k < fe.n_quadrature_points; ++k)\\n        {\\n const double diff1 = uh1[k] - uh2[k];\\n const double diff2 =\\n            fe.normal_vector(k) * Duh1[k] - fe.normal_vector(k) * Duh2[k];\\n          dinfo1.value(0) +=\\n            (penalty * diff1 * diff1 + h * diff2 * diff2) * fe.JxW(k);\\n        }\\n      dinfo1.value(0) = std::sqrt(dinfo1.value(0));\\n      dinfo2.value(0) = dinfo1.value(0);\\n    }\\n  } // namespace Estimator\\n \\n \\n \\n \\n namespace ErrorIntegrator\\n  {\\n template <int dim>\\n void cell(MeshWorker::DoFInfo<dim>         &dinfo,\\n MeshWorker::IntegrationInfo<dim> &info)\\n    {\\n const FEValuesBase<dim>    &fe = info.fe_values();\\n      std::vector<Tensor<1, dim>> exact_gradients(fe.n_quadrature_points);\\n      std::vector<double>         exact_values(fe.n_quadrature_points);\\n \\n      exact_solution.gradient_list(fe.get_quadrature_points(), exact_gradients);\\n      exact_solution.value_list(fe.get_quadrature_points(), exact_values);\\n \\n const std::vector<Tensor<1, dim>> &Duh = info.gradients[0][0];\\n const std::vector<double>         &uh  = info.values[0][0];\\n \\n for (unsigned k = 0; k < fe.n_quadrature_points; ++k)\\n        {\\n double sum = 0;\\n for (unsigned int d = 0; d < dim; ++d)\\n            {\\n const double diff = exact_gradients[k][d] - Duh[k][d];\\n sum += diff * diff;\\n            }\\n const double diff = exact_values[k] - uh[k];\\n          dinfo.value(0) += sum * fe.JxW(k);\\n          dinfo.value(1) += diff * diff * fe.JxW(k);\\n        }\\n      dinfo.value(0) = std::sqrt(dinfo.value(0));\\n      dinfo.value(1) = std::sqrt(dinfo.value(1));\\n    }\\n \\n \\n template <int dim>\\n void boundary(MeshWorker::DoFInfo<dim>         &dinfo,\\n MeshWorker::IntegrationInfo<dim> &info)\\n    {\\n const FEValuesBase<dim> &fe = info.fe_values();\\n \\n      std::vector<double> exact_values(fe.n_quadrature_points);\\n      exact_solution.value_list(fe.get_quadrature_points(), exact_values);\\n \\n const std::vector<double> &uh = info.values[0][0];\\n \\n const unsigned int degree  = fe.get_fe().tensor_degree();\\n const double       penalty = 2. * degree * (degree + 1) *\\n                             dinfo.face->measure() / dinfo.cell->measure();\\n \\n for (unsigned k = 0; k < fe.n_quadrature_points; ++k)\\n        {\\n const double diff = exact_values[k] - uh[k];\\n          dinfo.value(0) += penalty * diff * diff * fe.JxW(k);\\n        }\\n      dinfo.value(0) = std::sqrt(dinfo.value(0));\\n    }\\n \\n \\n template <int dim>\\n void face(MeshWorker::DoFInfo<dim>         &dinfo1,\\n MeshWorker::DoFInfo<dim>         &dinfo2,\\n MeshWorker::IntegrationInfo<dim> &info1,\\n MeshWorker::IntegrationInfo<dim> &info2)\\n    {\\n const FEValuesBase<dim>   &fe  = info1.fe_values();\\n const std::vector<double> &uh1 = info1.values[0][0];\\n const std::vector<double> &uh2 = info2.values[0][0];\\n \\n const unsigned int degree = fe.get_fe().tensor_degree();\\n const double       penalty1 =\\n        degree * (degree + 1) * dinfo1.face->measure() / dinfo1.cell->measure();\\n const double penalty2 =\\n        degree * (degree + 1) * dinfo2.face->measure() / dinfo2.cell->measure();\\n const double penalty = penalty1 + penalty2;\\n \\n for (unsigned k = 0; k < fe.n_quadrature_points; ++k)\\n        {\\n const double diff = uh1[k] - uh2[k];\\n          dinfo1.value(0) += (penalty * diff * diff) * fe.JxW(k);\\n        }\\n      dinfo1.value(0) = std::sqrt(dinfo1.value(0));\\n      dinfo2.value(0) = dinfo1.value(0);\\n    }\\n  } // namespace ErrorIntegrator\\n \\n \\n \\n template <int dim>\\n class InteriorPenaltyProblem\\n  {\\n public:\\n using CellInfo = MeshWorker::IntegrationInfo<dim>;\\n \\n    InteriorPenaltyProblem();\\n \\n void run(unsigned int n_steps);\\n \\n private:\\n void   setup_system();\\n void   assemble_matrix();\\n void   assemble_mg_matrix();\\n void   assemble_right_hand_side();\\n void   error();\\n double estimate();\\n void   solve();\\n void   output_results(const unsigned int cycle) const;\\n \\n Triangulation<dim> triangulation;\\n const MappingQ1<dim> mapping;\\n const FE_DGQ<2>      fe;\\n DoFHandler<dim>      dof_handler;\\n \\n SparsityPattern      sparsity;\\n SparseMatrix<double> matrix;\\n Vector<double>       solution;\\n Vector<double>       right_hand_side;\\n BlockVector<double>  estimates;\\n \\n MGLevelObject<SparsityPattern>      mg_sparsity;\\n MGLevelObject<SparseMatrix<double>> mg_matrix;\\n \\n MGLevelObject<SparsityPattern> mg_sparsity_dg_interface;\\n MGLevelObject<SparseMatrix<double>> mg_matrix_dg_down;\\n MGLevelObject<SparseMatrix<double>> mg_matrix_dg_up;\\n  };\\n \\n \\n template <int dim>\\n  InteriorPenaltyProblem<dim>::InteriorPenaltyProblem()\\n    : triangulation(Triangulation<dim>::limit_level_difference_at_vertices)\\n    , mapping()\\n    , fe(3)\\n    , dof_handler(triangulation)\\n    , estimates(1)\\n  {\\n GridGenerator::hyper_cube_slit(triangulation, -1, 1);\\n  }\\n \\n \\n template <int dim>\\n void InteriorPenaltyProblem<dim>::setup_system()\\n  {\\n    dof_handler.distribute_dofs(fe);\\n    dof_handler.distribute_mg_dofs();\\n unsigned int n_dofs = dof_handler.n_dofs();\\n    solution.reinit(n_dofs);\\n    right_hand_side.reinit(n_dofs);\\n \\n DynamicSparsityPattern dsp(n_dofs);\\n DoFTools::make_flux_sparsity_pattern(dof_handler, dsp);\\n    sparsity.copy_from(dsp);\\n matrix.reinit(sparsity);\\n \\n const unsigned int n_levels = triangulation.n_levels();\\n    mg_matrix.resize(0, n_levels - 1);\\n    mg_matrix.clear_elements();\\n    mg_matrix_dg_up.resize(0, n_levels - 1);\\n    mg_matrix_dg_up.clear_elements();\\n    mg_matrix_dg_down.resize(0, n_levels - 1);\\n    mg_matrix_dg_down.clear_elements();\\n    mg_sparsity.resize(0, n_levels - 1);\\n    mg_sparsity_dg_interface.resize(0, n_levels - 1);\\n \\n for (unsigned int level = mg_sparsity.min_level();\\n level <= mg_sparsity.max_level();\\n         ++level)\\n      {\\n DynamicSparsityPattern dsp(dof_handler.n_dofs(level));\\n MGTools::make_flux_sparsity_pattern(dof_handler, dsp, level);\\n        mg_sparsity[level].copy_from(dsp);\\n        mg_matrix[level].reinit(mg_sparsity[level]);\\n \\n if (level > 0)\\n          {\\n DynamicSparsityPattern dsp;\\n            dsp.reinit(dof_handler.n_dofs(level - 1),\\n                       dof_handler.n_dofs(level));\\n MGTools::make_flux_sparsity_pattern_edge(dof_handler, dsp, level);\\n            mg_sparsity_dg_interface[level].copy_from(dsp);\\n            mg_matrix_dg_up[level].reinit(mg_sparsity_dg_interface[level]);\\n            mg_matrix_dg_down[level].reinit(mg_sparsity_dg_interface[level]);\\n          }\\n      }\\n  }\\n \\n \\n template <int dim>\\n void InteriorPenaltyProblem<dim>::assemble_matrix()\\n  {\\n MeshWorker::IntegrationInfoBox<dim> info_box;\\n UpdateFlags update_flags = update_values | update_gradients;\\n    info_box.add_update_flags_all(update_flags);\\n    info_box.initialize(fe, mapping);\\n \\n MeshWorker::DoFInfo<dim> dof_info(dof_handler);\\n \\n MeshWorker::Assembler::MatrixSimple<SparseMatrix<double>> assembler;\\n    assembler.initialize(matrix);\\n \\n MeshWorker::loop<dim, dim>(dof_handler.begin_active(),\\n                               dof_handler.end(),\\n                               dof_info,\\n                               info_box,\\n                               &MatrixIntegrator::cell<dim>,\\n                               &MatrixIntegrator::boundary<dim>,\\n                               &MatrixIntegrator::face<dim>,\\n                               assembler);\\n  }\\n \\n \\n template <int dim>\\n void InteriorPenaltyProblem<dim>::assemble_mg_matrix()\\n  {\\n MeshWorker::IntegrationInfoBox<dim> info_box;\\n UpdateFlags update_flags = update_values | update_gradients;\\n    info_box.add_update_flags_all(update_flags);\\n    info_box.initialize(fe, mapping);\\n \\n MeshWorker::DoFInfo<dim> dof_info(dof_handler);\\n \\n MeshWorker::Assembler::MGMatrixSimple<SparseMatrix<double>> assembler;\\n    assembler.initialize(mg_matrix);\\n    assembler.initialize_fluxes(mg_matrix_dg_up, mg_matrix_dg_down);\\n \\n MeshWorker::loop<dim, dim>(dof_handler.begin_mg(),\\n                               dof_handler.end_mg(),\\n                               dof_info,\\n                               info_box,\\n                               &MatrixIntegrator::cell<dim>,\\n                               &MatrixIntegrator::boundary<dim>,\\n                               &MatrixIntegrator::face<dim>,\\n                               assembler);\\n  }\\n \\n \\n template <int dim>\\n void InteriorPenaltyProblem<dim>::assemble_right_hand_side()\\n  {\\n MeshWorker::IntegrationInfoBox<dim> info_box;\\n UpdateFlags                         update_flags =\\n update_quadrature_points | update_values | update_gradients;\\n    info_box.add_update_flags_all(update_flags);\\n    info_box.initialize(fe, mapping);\\n \\n MeshWorker::DoFInfo<dim> dof_info(dof_handler);\\n \\n MeshWorker::Assembler::ResidualSimple<Vector<double>> assembler;\\n AnyData                                               data;\\n    data.add<Vector<double> *>(&right_hand_side, \\\"RHS\\\");\\n    assembler.initialize(data);\\n \\n MeshWorker::loop<dim, dim>(dof_handler.begin_active(),\\n                               dof_handler.end(),\\n                               dof_info,\\n                               info_box,\\n                               &RHSIntegrator::cell<dim>,\\n                               &RHSIntegrator::boundary<dim>,\\n                               &RHSIntegrator::face<dim>,\\n                               assembler);\\n \\n    right_hand_side *= -1.;\\n  }\\n \\n \\n template <int dim>\\n void InteriorPenaltyProblem<dim>::solve()\\n  {\\n SolverControl            control(1000, 1.e-12);\\n SolverCG<Vector<double>> solver(control);\\n \\n MGTransferPrebuilt<Vector<double>> mg_transfer;\\n    mg_transfer.build(dof_handler);\\n \\n FullMatrix<double> coarse_matrix;\\n    coarse_matrix.copy_from(mg_matrix[0]);\\n MGCoarseGridHouseholder<double, Vector<double>> mg_coarse;\\n    mg_coarse.initialize(coarse_matrix);\\n \\n GrowingVectorMemory<Vector<double>> mem;\\n using RELAXATION = PreconditionSOR<SparseMatrix<double>>;\\n mg::SmootherRelaxation<RELAXATION, Vector<double>> mg_smoother;\\n    RELAXATION::AdditionalData                         smoother_data(1.);\\n    mg_smoother.initialize(mg_matrix, smoother_data);\\n \\n    mg_smoother.set_steps(2);\\n    mg_smoother.set_symmetric(true);\\n    mg_smoother.set_variable(false);\\n \\n mg::Matrix<Vector<double>> mgmatrix(mg_matrix);\\n mg::Matrix<Vector<double>> mgdown(mg_matrix_dg_down);\\n mg::Matrix<Vector<double>> mgup(mg_matrix_dg_up);\\n \\n Multigrid<Vector<double>> mg(\\n      mgmatrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);\\n mg.set_edge_flux_matrices(mgdown, mgup);\\n \\n PreconditionMG<dim, Vector<double>, MGTransferPrebuilt<Vector<double>>>\\n      preconditioner(dof_handler, mg, mg_transfer);\\n    solver.solve(matrix, solution, right_hand_side, preconditioner);\\n  }\\n \\n \\n template <int dim>\\n double InteriorPenaltyProblem<dim>::estimate()\\n  {\\n    std::vector<unsigned int> old_user_indices;\\n triangulation.save_user_indices(old_user_indices);\\n \\n    estimates.block(0).reinit(triangulation.n_active_cells());\\n unsigned int i = 0;\\n for (const auto &cell : triangulation.active_cell_iterators())\\n      cell->set_user_index(i++);\\n \\n MeshWorker::IntegrationInfoBox<dim> info_box;\\n const unsigned int                  n_gauss_points =\\n      dof_handler.get_fe().tensor_degree() + 1;\\n    info_box.initialize_gauss_quadrature(n_gauss_points,\\n                                         n_gauss_points + 1,\\n                                         n_gauss_points);\\n \\n AnyData solution_data;\\n    solution_data.add<const Vector<double> *>(&solution, \\\"solution\\\");\\n \\n    info_box.cell_selector.add(\\\"solution\\\", false, false, true);\\n    info_box.boundary_selector.add(\\\"solution\\\", true, true, false);\\n    info_box.face_selector.add(\\\"solution\\\", true, true, false);\\n \\n    info_box.add_update_flags_boundary(update_quadrature_points);\\n    info_box.initialize(fe, mapping, solution_data, solution);\\n \\n MeshWorker::DoFInfo<dim> dof_info(dof_handler);\\n \\n MeshWorker::Assembler::CellsAndFaces<double> assembler;\\n AnyData                                      out_data;\\n    out_data.add<BlockVector<double> *>(&estimates, \\\"cells\\\");\\n    assembler.initialize(out_data, false);\\n \\n MeshWorker::loop<dim, dim>(dof_handler.begin_active(),\\n                               dof_handler.end(),\\n                               dof_info,\\n                               info_box,\\n                               &Estimator::cell<dim>,\\n                               &Estimator::boundary<dim>,\\n                               &Estimator::face<dim>,\\n                               assembler);\\n \\n triangulation.load_user_indices(old_user_indices);\\n return estimates.block(0).l2_norm();\\n  }\\n \\n \\n template <int dim>\\n void InteriorPenaltyProblem<dim>::error()\\n  {\\n BlockVector<double> errors(2);\\n    errors.block(0).reinit(triangulation.n_active_cells());\\n    errors.block(1).reinit(triangulation.n_active_cells());\\n \\n    std::vector<unsigned int> old_user_indices;\\n triangulation.save_user_indices(old_user_indices);\\n unsigned int i = 0;\\n for (const auto &cell : triangulation.active_cell_iterators())\\n      cell->set_user_index(i++);\\n \\n MeshWorker::IntegrationInfoBox<dim> info_box;\\n const unsigned int                  n_gauss_points =\\n      dof_handler.get_fe().tensor_degree() + 1;\\n    info_box.initialize_gauss_quadrature(n_gauss_points,\\n                                         n_gauss_points + 1,\\n                                         n_gauss_points);\\n \\n AnyData solution_data;\\n    solution_data.add<Vector<double> *>(&solution, \\\"solution\\\");\\n \\n    info_box.cell_selector.add(\\\"solution\\\", true, true, false);\\n    info_box.boundary_selector.add(\\\"solution\\\", true, false, false);\\n    info_box.face_selector.add(\\\"solution\\\", true, false, false);\\n \\n    info_box.add_update_flags_cell(update_quadrature_points);\\n    info_box.add_update_flags_boundary(update_quadrature_points);\\n    info_box.initialize(fe, mapping, solution_data, solution);\\n \\n MeshWorker::DoFInfo<dim> dof_info(dof_handler);\\n \\n MeshWorker::Assembler::CellsAndFaces<double> assembler;\\n AnyData                                      out_data;\\n    out_data.add<BlockVector<double> *>(&errors, \\\"cells\\\");\\n    assembler.initialize(out_data, false);\\n \\n MeshWorker::loop<dim, dim>(dof_handler.begin_active(),\\n                               dof_handler.end(),\\n                               dof_info,\\n                               info_box,\\n                               &ErrorIntegrator::cell<dim>,\\n                               &ErrorIntegrator::boundary<dim>,\\n                               &ErrorIntegrator::face<dim>,\\n                               assembler);\\n triangulation.load_user_indices(old_user_indices);\\n \\n deallog << \\\"energy-error: \\\" << errors.block(0).l2_norm() << std::endl;\\n deallog << \\\"L2-error:     \\\" << errors.block(1).l2_norm() << std::endl;\\n  }\\n \\n \\n template <int dim>\\n void\\n  InteriorPenaltyProblem<dim>::output_results(const unsigned int cycle) const\\n {\\n const std::string filename =\\n \\\"sol-\\\" + Utilities::int_to_string(cycle, 2) + \\\".gnuplot\\\";\\n \\n deallog << \\\"Writing solution to <\\\" << filename << \\\">...\\\" << std::endl\\n            << std::endl;\\n    std::ofstream gnuplot_output(filename);\\n \\n DataOut<dim> data_out;\\n    data_out.attach_dof_handler(dof_handler);\\n    data_out.add_data_vector(solution, \\\"u\\\");\\n    data_out.add_data_vector(estimates.block(0), \\\"est\\\");\\n \\n    data_out.build_patches();\\n \\n    data_out.write_gnuplot(gnuplot_output);\\n  }\\n \\n template <int dim>\\n void InteriorPenaltyProblem<dim>::run(unsigned int n_steps)\\n  {\\n deallog << \\\"Element: \\\" << fe.get_name() << std::endl;\\n for (unsigned int s = 0; s < n_steps; ++s)\\n      {\\n deallog << \\\"Step \\\" << s << std::endl;\\n if (estimates.block(0).size() == 0)\\n triangulation.refine_global(1);\\n else\\n          {\\n GridRefinement::refine_and_coarsen_fixed_fraction(\\n triangulation, estimates.block(0), 0.5, 0.0);\\n triangulation.execute_coarsening_and_refinement();\\n          }\\n \\n deallog << \\\"Triangulation \\\" << triangulation.n_active_cells()\\n                << \\\" cells, \\\" << triangulation.n_levels() << \\\" levels\\\"\\n                << std::endl;\\n \\n        setup_system();\\n deallog << \\\"DoFHandler \\\" << dof_handler.n_dofs() << \\\" dofs, level dofs\\\";\\n for (unsigned int l = 0; l < triangulation.n_levels(); ++l)\\n deallog << ' ' << dof_handler.n_dofs(l);\\n deallog << std::endl;\\n \\n deallog << \\\"Assemble matrix\\\" << std::endl;\\n        assemble_matrix();\\n deallog << \\\"Assemble multilevel matrix\\\" << std::endl;\\n        assemble_mg_matrix();\\n deallog << \\\"Assemble right hand side\\\" << std::endl;\\n        assemble_right_hand_side();\\n deallog << \\\"Solve\\\" << std::endl;\\n        solve();\\n        error();\\n deallog << \\\"Estimate \\\" << estimate() << std::endl;\\n        output_results(s);\\n      }\\n  }\\n} // namespace Step39\\n \\n \\n \\nint main()\\n{\\n try\\n    {\\n using namespace dealii;\\n using namespace Step39;\\n \\n deallog.depth_console(2);\\n      std::ofstream logfile(\\\"deallog\\\");\\n deallog.attach(logfile);\\n \\n      InteriorPenaltyProblem<2> test1;\\n      test1.run(12);\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n \\n return 0;\\n}\\nassembler.h\\nblock_vector.h\\nDataOutInterface::write_gnuplotvoid write_gnuplot(std::ostream &out) constDefinition data_out_base.cc:7616\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nFEValuesBase::get_quadrature_pointsconst std::vector< Point< spacedim > > & get_quadrature_points() const\\nFEValuesBase::dofs_per_cellconst unsigned int dofs_per_cellDefinition fe_values_base.h:192\\nFEValuesBase::normal_vectorconst Tensor< 1, spacedim > & normal_vector(const unsigned int q_point) const\\nFEValuesBase::n_quadrature_pointsconst unsigned int n_quadrature_pointsDefinition fe_values_base.h:174\\nFEValuesBase::shape_gradconst Tensor< 1, spacedim > & shape_grad(const unsigned int i, const unsigned int q_point) const\\nFEValuesBase::JxWdouble JxW(const unsigned int q_point) const\\nFEValuesBase::shape_valueconst double & shape_value(const unsigned int i, const unsigned int q_point) const\\nFullMatrix::nsize_type n() const\\nFullMatrix::msize_type m() const\\nFunctions::SlitSingularityFunction::gradient_listvirtual void gradient_list(const std::vector< Point< dim > > &points, std::vector< Tensor< 1, dim > > &gradients, const unsigned int component=0) const overrideDefinition function_lib.cc:1580\\nFunctions::SlitSingularityFunction::value_listvirtual void value_list(const std::vector< Point< dim > > &points, std::vector< double > &values, const unsigned int component=0) const overrideDefinition function_lib.cc:1487\\nMGSmoother::set_stepsvoid set_steps(const unsigned int)\\nMGSmoother::set_symmetricvoid set_symmetric(const bool)\\nMGSmoother::set_variablevoid set_variable(const bool)\\nMeshWorker::Assembler::CellsAndFaces::initializevoid initialize(AnyData &results, bool separate_faces=true)Definition functional.h:230\\nMeshWorker::Assembler::MGMatrixSimple::initialize_fluxesvoid initialize_fluxes(MGLevelObject< MatrixType > &flux_up, MGLevelObject< MatrixType > &flux_down)Definition simple.h:782\\nMeshWorker::Assembler::ResidualSimple::initializevoid initialize(AnyData &results)Definition simple.h:512\\nMeshWorker::IntegrationInfoBox::initializevoid initialize(const FiniteElement< dim, spacedim > &el, const Mapping< dim, spacedim > &mapping, const BlockInfo *block_info=nullptr)\\nMeshWorker::IntegrationInfoBox::boundary_selectorMeshWorker::VectorSelector boundary_selectorDefinition integration_info.h:494\\nMeshWorker::IntegrationInfoBox::add_update_flags_cellvoid add_update_flags_cell(const UpdateFlags flags)Definition integration_info.h:759\\nMeshWorker::IntegrationInfoBox::face_selectorMeshWorker::VectorSelector face_selectorDefinition integration_info.h:500\\nMeshWorker::IntegrationInfoBox::cell_selectorMeshWorker::VectorSelector cell_selectorDefinition integration_info.h:488\\nMeshWorker::IntegrationInfoBox::add_update_flags_boundaryvoid add_update_flags_boundary(const UpdateFlags flags)Definition integration_info.h:767\\nMeshWorker::IntegrationInfo::hessiansstd::vector< std::vector< std::vector< Tensor< 2, spacedim > > > > hessiansDefinition integration_info.h:188\\nMeshWorker::IntegrationInfo::fe_valuesconst FEValuesBase< dim, spacedim > & fe_values() constAccess to finite element.Definition integration_info.h:676\\nMeshWorker::IntegrationInfo::gradientsstd::vector< std::vector< std::vector< Tensor< 1, spacedim > > > > gradientsDefinition integration_info.h:178\\nMeshWorker::IntegrationInfo::valuesstd::vector< std::vector< std::vector< double > > > valuesDefinition integration_info.h:168\\nMeshWorker::VectorSelector::addvoid add(const std::string &name, const bool values=true, const bool gradients=false, const bool hessians=false)Definition vector_selector.h:416\\nmg::SmootherRelaxation::initializevoid initialize(const MGLevelObject< MatrixType2 > &matrices, const typename RelaxationType::AdditionalData &additional_data=typename RelaxationType::AdditionalData())\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nfe_dgp.h\\nfe_dgq.h\\nfe_q.h\\nfunction_lib.h\\ngrid_refinement.h\\ngrid_generator.h\\nintegration_info.h\\nlaplace.h\\nloop.h\\nmapping_q1.h\\ndof_info.h\\nmg_coarse.h\\nmg_matrix.h\\nmg_smoother.h\\nmg_tools.h\\nmg_transfer.h\\nmultigrid.h\\nDataOutBase::dx@ dxDefinition data_out_base.h:1627\\nLAPACKSupport::matrix@ matrixContents is actually a matrix.Definition lapack_support.h:57\\nPhysics::Elasticity::Kinematics::lTensor< 2, dim, Number > l(const Tensor< 2, dim, Number > &F, const Tensor< 2, dim, Number > &dF_dt)\\nPhysics::Elasticity::Kinematics::dSymmetricTensor< 2, dim, Number > d(const Tensor< 2, dim, Number > &F, const Tensor< 2, dim, Number > &dF_dt)\\nUtilities::MPI::sumT sum(const T &t, const MPI_Comm mpi_communicator)\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\ndata_out.h\\nprecondition.h\\nprecondition_block.h\\nquadrature_lib.h\\nsolver_cg.h\\nsparse_matrix.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"