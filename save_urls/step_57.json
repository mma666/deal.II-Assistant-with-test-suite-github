"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_57.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-57 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-57 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-57 tutorial program\\n\\n\\nThis tutorial depends on step-15, step-22.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\n Navier Stokes Equations \\n Linearization of Navier-Stokes Equations \\n Finding an Initial Guess \\nThe Solver and Preconditioner \\n Test Case \\n\\n The commented program\\n\\nInclude files\\nThe NavierStokesProblem class template\\nBoundary values and right hand side\\nBlockSchurPreconditioner for Navier Stokes equations\\nStationaryNavierStokes class implementation\\n\\nStationaryNavierStokes::StationaryNavierStokes\\nStationaryNavierStokes::setup_dofs\\nStationaryNavierStokes::initialize_system\\nStationaryNavierStokes::assemble\\nStationaryNavierStokes::solve\\nStationaryNavierStokes::refine_mesh\\nStationaryNavierStokes::newton_iteration\\nStationaryNavierStokes::compute_initial_guess\\nStationaryNavierStokes::output_results\\nStationaryNavierStokes::process_solution\\nStationaryNavierStokes::run\\n\\n\\n\\n Results\\n\\n Test case 1: Low Reynolds Number \\n Test case 2: High Reynolds Number \\nPossibilities for extensions\\n\\nCompare to other solvers\\n3d computations\\nParallelization\\n\\n\\n The plain program\\n   \\n\\n\\nThis program was contributed by Liang Zhao and Timo Heister.\\nThis material is based upon work partially supported by National Science Foundation grant DMS1522191 and the Computational Infrastructure in Geodynamics initiative (CIG), through the National Science Foundation under Award No. EAR-0949446 and The University of California-Davis. \\nNoteIf you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation:   \\n Introduction\\nNavier Stokes Equations \\nIn this tutorial we show how to solve the incompressible Navier Stokes equations (NSE) with Newton's method. The flow we consider here is assumed to be steady. In a domain  \\\\(\\\\Omega \\\\subset\\n\\\\mathbb{R}^{d}\\\\), \\\\(d=2,3\\\\), with a piecewise smooth boundary \\\\(\\\\partial \\\\Omega\\\\), and a given force field \\\\(\\\\textbf{f}\\\\), we seek a velocity field \\\\(\\\\textbf{u}\\\\) and a pressure field \\\\(\\\\textbf{p}\\\\) satisfying    \\n\\\\begin{eqnarray*}\\n- \\\\nu \\\\Delta\\\\textbf{u} + (\\\\textbf{u} \\\\cdot \\\\nabla)\\\\textbf{u} + \\\\nabla p &=& \\\\textbf{f}\\\\\\\\\\n- \\\\nabla \\\\cdot \\\\textbf{u} &=& 0.\\n\\\\end{eqnarray*}\\n\\nUnlike the Stokes equations as discussed in step-22, the NSE are a nonlinear system of equations because of the convective term  \\\\((\\\\textbf{u} \\\\cdot\\n\\\\nabla)\\\\textbf{u}\\\\). The first step of computing a numerical solution is to linearize the system and this will be done using Newton's method. A time-dependent problem is discussed in step-35, where the system is linearized using the solution from the last time step and no nonlinear solve is necessary.\\nLinearization of Navier-Stokes Equations \\nWe define a nonlinear function whose root is a solution to the NSE by       \\n\\\\begin{eqnarray*}\\nF(\\\\mathbf{u}, p) =\\n  \\\\begin{pmatrix}\\n    - \\\\nu \\\\Delta\\\\mathbf{u} + (\\\\mathbf{u} \\\\cdot \\\\nabla)\\\\mathbf{u} + \\\\nabla p - \\\\mathbf{f} \\\\\\\\\\n    - \\\\nabla \\\\cdot \\\\mathbf{u}\\n  \\\\end{pmatrix}.\\n\\\\end{eqnarray*}\\n\\nAssuming the initial guess is good enough to guarantee the convergence of Newton's iteration and denoting \\\\(\\\\textbf{x} = (\\\\textbf{u}, p)\\\\), Newton's iteration on a vector function can be defined as   \\n\\\\begin{eqnarray*}\\n  \\\\textbf{x}^{k+1} = \\\\textbf{x}^{k} - (\\\\nabla F(\\\\textbf{x}^{k}))^{-1} F(\\\\textbf{x}^{k}),\\n\\\\end{eqnarray*}\\n\\nwhere \\\\(\\\\textbf{x}^{k+1}\\\\) is the approximate solution in step \\\\(k+1\\\\), \\\\(\\\\textbf{x}^{k}\\\\) represents the solution from the previous step, and  \\\\(\\\\nabla\\nF(\\\\textbf{x}^{k})\\\\) is the Jacobian matrix evaluated at \\\\(\\\\textbf{x}^{k}\\\\). A similar iteration can be found in step-15.\\nThe Newton iteration formula implies the new solution is obtained by adding an update term to the old solution. Instead of evaluating the Jacobian matrix and taking its inverse, we consider the update term as a whole, that is   \\n\\\\begin{eqnarray*}\\n  \\\\delta \\\\textbf{x}^{k} = - (\\\\nabla F(\\\\textbf{x}^{k}))^{-1} F(\\\\textbf{x}^{k}),\\n\\\\end{eqnarray*}\\n\\nwhere \\\\(\\\\textbf{x}^{k+1}=\\\\textbf{x}^{k}+\\\\delta \\\\textbf{x}^{k}\\\\).\\nWe can find the update term by solving the system   \\n\\\\begin{eqnarray*}\\n  \\\\nabla F(\\\\textbf{x}^{k}) \\\\delta \\\\textbf{x}^{k} = -F(\\\\textbf{x}^{k}).\\n\\\\end{eqnarray*}\\n\\nHere, the left of the previous equation represents the directional gradient of \\\\(F(\\\\textbf{x})\\\\) along  \\\\(\\\\delta\\n\\\\textbf{x}^{k}\\\\) at \\\\(\\\\textbf{x}^{k}\\\\). By definition, the directional gradient is given by                            \\n\\\\begin{eqnarray*}\\n  & &\\\\nabla F(\\\\mathbf{u}^{k}, p^{k}) (\\\\delta \\\\mathbf{u}^{k}, \\\\delta p^{k}) \\\\\\\\\\n  \\\\\\\\\\n  &=& \\\\lim_{\\\\epsilon \\\\to 0} \\\\frac{1}{\\\\epsilon}\\n      \\\\left(\\n        F(\\\\mathbf{u}^{k} + \\\\epsilon \\\\delta \\\\mathbf{u}^{k},\\n          p^{k} + \\\\epsilon \\\\nabla \\\\delta p^{k})\\n      - F(\\\\mathbf{u}^{k}, p^{k})\\n      \\\\right)\\\\\\\\\\n  \\\\\\\\\\n  &=& \\\\lim_{\\\\epsilon \\\\to 0} \\\\frac{1}{\\\\epsilon}\\n      \\\\begin{pmatrix}\\n        - \\\\epsilon \\\\nu \\\\Delta \\\\delta \\\\mathbf{u}^{k}\\n        + \\\\epsilon \\\\mathbf{u}^{k} \\\\cdot \\\\nabla \\\\delta \\\\mathbf{u}^{k}\\n        + \\\\epsilon \\\\delta \\\\mathbf{u}^{k} \\\\cdot \\\\nabla \\\\mathbf{u}^{k}\\n        + \\\\epsilon^{2} \\\\delta \\\\mathbf{u}^{k} \\\\cdot \\\\nabla \\\\delta \\\\mathbf{u}^{k}\\n        + \\\\epsilon \\\\nabla \\\\delta p^{k}\\\\\\\\\\n        - \\\\epsilon \\\\nabla \\\\cdot \\\\delta \\\\mathbf{u}^{k}\\n      \\\\end{pmatrix} \\\\\\\\\\n  \\\\\\\\\\n  &=& \\\\begin{pmatrix}\\n        - \\\\nu \\\\Delta \\\\delta \\\\mathbf{u}^{k}\\n        + \\\\mathbf{u}^{k} \\\\cdot \\\\nabla \\\\delta \\\\mathbf{u}^{k}\\n        + \\\\delta \\\\mathbf{u}^{k} \\\\cdot \\\\nabla \\\\mathbf{u}^{k}\\n        + \\\\nabla \\\\delta p^{k}\\\\\\\\\\n        - \\\\nabla \\\\cdot \\\\delta \\\\mathbf{u}^{k}\\n      \\\\end{pmatrix}.\\n\\\\end{eqnarray*}\\n\\nTherefore, we arrive at the linearized system:         \\n\\\\begin{eqnarray*}\\n   -\\\\nu \\\\Delta \\\\delta \\\\mathbf{u}^{k}\\n  + \\\\mathbf{u}^{k} \\\\cdot \\\\nabla \\\\delta \\\\mathbf{u}^{k}\\n  + \\\\delta \\\\mathbf{u}^{k} \\\\cdot \\\\nabla \\\\mathbf{u}^{k}\\n  + \\\\nabla \\\\delta p^{k}\\n  = -F(\\\\mathbf{x}^k), \\\\\\\\\\n   -\\\\nabla \\\\cdot\\\\delta \\\\mathbf{u}^{k}\\n  = \\\\nabla \\\\cdot \\\\mathbf{u}^{k},\\n\\\\end{eqnarray*}\\n\\nwhere \\\\(\\\\textbf{u}^k\\\\) and \\\\(p^k\\\\) are the solutions from the previous iteration. Additionally, the right hand side of the second equation is not zero since the discrete solution is not exactly divergence free (divergence free for the continuous solution). The right hand side here acts as a correction which leads the discrete solution of the velocity to be divergence free along Newton's iteration. In this linear system, the only unknowns are the update terms \\\\(\\\\delta \\\\textbf{u}^{k}\\\\) and \\\\(\\\\delta p^{k}\\\\), and we can use a similar strategy to the one used in step-22 (and derive the weak form in the same way).\\nNow, Newton's iteration can be used to solve for the update terms:\\n\\n\\nInitialization: Initial guess \\\\(u_0\\\\) and \\\\(p_0\\\\), tolerance \\\\(\\\\tau\\\\); \\n\\nLinear solve to compute update term \\\\(\\\\delta\\\\textbf{u}^{k}\\\\) and \\\\(\\\\delta p^k\\\\); \\n\\nUpdate the approximation: \\\\(\\\\textbf{u}^{k+1} = \\\\textbf{u}^{k} + \\\\delta\\\\textbf{u}^{k}\\\\) and \\\\(p^{k+1} = p^{k} + \\\\delta p^{k}\\\\); \\n\\nCheck residual norm: \\\\(E^{k+1} = \\\\|F(\\\\mathbf{u}^{k+1}, p^{k+1})\\\\|\\\\): \\n\\nIf \\\\(E^{k+1} \\\\leq \\\\tau\\\\), STOP. \\n\\nIf \\\\(E^{k+1} > \\\\tau\\\\), back to step 2. \\n\\n\\n\\nFinding an Initial Guess \\nThe initial guess needs to be close enough to the solution for Newton's method to converge; hence, finding a good starting value is crucial to the nonlinear solver.\\nWhen the viscosity \\\\(\\\\nu\\\\) is large, a good initial guess can be obtained by solving the Stokes equation with viscosity \\\\(\\\\nu\\\\). While problem dependent, this works for \\\\(\\\\nu \\\\geq 1/400\\\\) for the test problem considered here.\\nHowever, the convective term \\\\((\\\\mathbf{u}\\\\cdot\\\\nabla)\\\\mathbf{u}\\\\) will be dominant if the viscosity is small, like \\\\(1/7500\\\\) in test case 2. In this situation, we use a continuation method to set up a series of auxiliary NSEs with viscosity approaching the one in the target NSE. Correspondingly, we create a sequence \\\\(\\\\{\\\\nu_{i}\\\\}\\\\) with \\\\(\\\\nu_{n}= \\\\nu\\\\), and accept that the solutions to two NSE with viscosity \\\\(\\\\nu_{i}\\\\) and \\\\(\\\\nu_{i+1}\\\\) are close if  \\\\(|\\\\nu_{i} -\\n\\\\nu_{i+1}|\\\\) is small. Then we use the solution to the NSE with viscosity \\\\(\\\\nu_{i}\\\\) as the initial guess of the NSE with \\\\(\\\\nu_{i+1}\\\\). This can be thought of as a staircase from the Stokes equations to the NSE we want to solve.\\nThat is, we first solve a Stokes problem    \\n\\\\begin{eqnarray*}\\n  -\\\\nu_{1} \\\\Delta \\\\textbf{u} + \\\\nabla p &=& \\\\textbf{f}\\\\\\\\\\n  -\\\\nabla \\\\cdot \\\\textbf{u} &=& 0\\n\\\\end{eqnarray*}\\n\\nto get the initial guess for    \\n\\\\begin{eqnarray*}\\n  -\\\\nu_{1} \\\\Delta \\\\textbf{u} + (\\\\textbf{u} \\\\cdot \\\\nabla)\\\\textbf{u} + \\\\nabla p &=& \\\\textbf{f},\\\\\\\\\\n  -\\\\nabla \\\\cdot \\\\textbf{u} &=& 0,\\n\\\\end{eqnarray*}\\n\\nwhich also acts as the initial guess of the continuation method. Here \\\\(\\\\nu_{1}\\\\) is relatively large so that the solution to the Stokes problem with viscosity \\\\(\\\\nu_{1}\\\\) can be used as an initial guess for the NSE in Newton's iteration.\\nThen the solution to    \\n\\\\begin{eqnarray*}\\n  -\\\\nu_{i} \\\\Delta \\\\textbf{u} + (\\\\textbf{u} \\\\cdot \\\\nabla)\\\\textbf{u} + \\\\nabla p &=& \\\\textbf{f},\\\\\\\\\\n  -\\\\nabla \\\\cdot \\\\textbf{u} &=& 0.\\n\\\\end{eqnarray*}\\n\\nacts as the initial guess for    \\n\\\\begin{eqnarray*}\\n  -\\\\nu_{i+1} \\\\Delta \\\\textbf{u} + (\\\\textbf{u} \\\\cdot \\\\nabla)\\\\textbf{u} + \\\\nabla p &=& \\\\textbf{f},\\\\\\\\\\n  -\\\\nabla \\\\cdot \\\\textbf{u} &=& 0.\\n\\\\end{eqnarray*}\\n\\nThis process is repeated with a sequence of viscosities \\\\(\\\\{\\\\nu_i\\\\}\\\\) that is determined experimentally so that the final solution can used as a starting guess for the Newton iteration.\\nThe Solver and Preconditioner \\nAt each step of Newton's iteration, the problem results in solving a saddle point systems of the form               \\n\\\\begin{eqnarray*}\\n    \\\\begin{pmatrix}\\n      A & B^{T} \\\\\\\\\\n      B & 0\\n    \\\\end{pmatrix}\\n    \\\\begin{pmatrix}\\n      U \\\\\\\\\\n      P\\n    \\\\end{pmatrix}\\n    =\\n    \\\\begin{pmatrix}\\n      F \\\\\\\\\\n      0\\n    \\\\end{pmatrix}.\\n\\\\end{eqnarray*}\\n\\nThis system matrix has the same block structure as the one in step-22. However, the matrix \\\\(A\\\\) at the top left corner is not symmetric because of the nonlinear term. Instead of solving the above system, we can solve the equivalent system               \\n\\\\begin{eqnarray*}\\n    \\\\begin{pmatrix}\\n      A + \\\\gamma B^TW^{-1}B & B^{T} \\\\\\\\\\n      B & 0\\n    \\\\end{pmatrix}\\n    \\\\begin{pmatrix}\\n      U \\\\\\\\\\n      P\\n    \\\\end{pmatrix}\\n    =\\n    \\\\begin{pmatrix}\\n      F \\\\\\\\\\n      0\\n    \\\\end{pmatrix}\\n\\\\end{eqnarray*}\\n\\nwith a parameter \\\\(\\\\gamma\\\\) and an invertible matrix \\\\(W\\\\). Here \\\\(\\\\gamma B^TW^{-1}B\\\\) is the Augmented Lagrangian term; see [26] for details.\\nDenoting the system matrix of the new system by \\\\(G\\\\) and the right-hand side by \\\\(b\\\\), we solve it iteratively with right preconditioning \\\\(P^{-1}\\\\) as \\\\(GP^{-1}y = b\\\\), where       \\n\\\\begin{eqnarray*}\\nP^{-1} =\\n  \\\\begin{pmatrix}\\n    \\\\tilde{A} & B^T \\\\\\\\\\n    0         & \\\\tilde{S}\\n  \\\\end{pmatrix}^{-1}\\n\\\\end{eqnarray*}\\n\\nwith \\\\(\\\\tilde{A} = A + \\\\gamma B^TW^{-1}B\\\\) and \\\\(\\\\tilde{S}\\\\) is the corresponding Schur complement \\\\(\\\\tilde{S} = B^T \\\\tilde{A}^{-1} B\\\\). We let \\\\(W = M_p\\\\) where \\\\(M_p\\\\) is the pressure mass matrix, then \\\\(\\\\tilde{S}^{-1}\\\\) can be approximated by   \\n\\\\begin{eqnarray*}\\n\\\\tilde{S}^{-1} \\\\approx -(\\\\nu+\\\\gamma)M_p^{-1}.\\n\\\\end{eqnarray*}\\n\\nSee [26] for details.\\nWe decompose \\\\(P^{-1}\\\\) as               \\n\\\\begin{eqnarray*}\\nP^{-1} =\\n  \\\\begin{pmatrix}\\n    \\\\tilde{A}^{-1} & 0 \\\\\\\\\\n    0              & I\\n  \\\\end{pmatrix}\\n  \\\\begin{pmatrix}\\n    I & -B^T \\\\\\\\\\n    0 & I\\n  \\\\end{pmatrix}\\n  \\\\begin{pmatrix}\\n    I & 0 \\\\\\\\\\n    0 & \\\\tilde{S}^{-1}\\n  \\\\end{pmatrix}.\\n\\\\end{eqnarray*}\\n\\nHere two inexact solvers will be needed for \\\\(\\\\tilde{A}^{-1}\\\\) and \\\\(\\\\tilde{S}^{-1}\\\\), respectively (see [26]). Since the pressure mass matrix is symmetric and positive definite, CG with ILU as a preconditioner is appropriate to use for \\\\(\\\\tilde{S}^{-1}\\\\). For simplicity, we use the direct solver UMFPACK for \\\\(\\\\tilde{A}^{-1}\\\\). The last ingredient is a sparse matrix-vector product with \\\\(B^T\\\\). Instead of computing the matrix product in the augmented Lagrangian term in \\\\(\\\\tilde{A}\\\\), we assemble Grad-Div stabilization  \\\\((\\\\nabla \\\\cdot \\\\phi _{i}, \\\\nabla \\\\cdot \\\\phi _{j}) \\\\approx (B^T\\nM_p^{-1}B)_{ij}\\\\), as explained in [113].\\nTest Case \\nWe use the lid driven cavity flow as our test case; see this page for details. The computational domain is the unit square and the right-hand side is \\\\(f=0\\\\). The boundary condition is    \\n\\\\begin{eqnarray*}\\n  (u(x, y), v(x,y)) &=& (1,0) \\\\qquad\\\\qquad \\\\textrm{if}\\\\ y = 1 \\\\\\\\\\n  (u(x, y), v(x,y)) &=& (0,0) \\\\qquad\\\\qquad \\\\textrm{otherwise}.\\n\\\\end{eqnarray*}\\n\\nWhen solving this problem, the error consists of the nonlinear error (from Newton's iteration) and the discretization error (dependent on mesh size). The nonlinear part decreases with each Newton iteration and the discretization error reduces with mesh refinement. In this example, the solution from the coarse mesh is transferred to successively finer meshes and used as an initial guess. Therefore, the nonlinear error is always brought below the tolerance of Newton's iteration and the discretization error is reduced with each mesh refinement.\\nInside the loop, we involve three solvers: one for \\\\(\\\\tilde{A}^{-1}\\\\), one for \\\\(M_p^{-1}\\\\) and one for \\\\(Gx=b\\\\). The first two solvers are invoked in the preconditioner and the outer solver gives us the update term. Overall convergence is controlled by the nonlinear residual; as Newton's method does not require an exact Jacobian, we employ FGMRES with a relative tolerance of only 1e-4 for the outer linear solver. In fact, we use the truncated Newton solve for this system. As described in step-22, the inner linear solves are also not required to be done very accurately. Here we use CG with a relative tolerance of 1e-6 for the pressure mass matrix. As expected, we still see convergence of the nonlinear residual down to 1e-14. Also, we use a simple line search algorithm for globalization of the Newton method.\\nThe cavity reference values for \\\\(\\\\mathrm{Re}=400\\\\) and \\\\(\\\\mathrm{Re}=7500\\\\) are from [97] and [83], respectively, where \\\\(\\\\mathrm{Re}\\\\) is the Reynolds number. Here the viscosity is defined by \\\\(1/\\\\mathrm{Re}\\\\). Even though we can still find a solution for \\\\(\\\\mathrm{Re}=10000\\\\) and the papers cited throughout this introduction contain results for comparison, we limit our discussion here to \\\\(\\\\mathrm{Re}=7500\\\\). This is because the solution is no longer stationary starting around \\\\(\\\\mathrm{Re}=8000\\\\) but instead becomes periodic, see [47] for details.\\n The commented program\\n Include files\\nAs usual, we start by including some well-known files:\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/base/utilities.h>\\n\\u00a0 #include <deal.II/base/tensor.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/block_vector.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/block_sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/solver_cg.h>\\n\\u00a0 #include <deal.II/lac/solver_gmres.h>\\n\\u00a0 #include <deal.II/lac/precondition.h>\\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_refinement.h>\\n\\u00a0 #include <deal.II/grid/grid_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_renumbering.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_system.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/error_estimator.h>\\n\\u00a0 \\nTo transfer solutions between meshes, this file is included:\\n\\u00a0 #include <deal.II/numerics/solution_transfer.h>\\n\\u00a0 \\nThis file includes UMFPACK: the direct solver:\\n\\u00a0 #include <deal.II/lac/sparse_direct.h>\\n\\u00a0 \\nAnd the one for ILU preconditioner:\\n\\u00a0 #include <deal.II/lac/sparse_ilu.h>\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 #include <fstream>\\n\\u00a0 #include <iostream>\\n\\u00a0 \\n\\u00a0 namespace Step57\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n The NavierStokesProblem class template\\nThis class manages the matrices and vectors described in the introduction: in particular, we store a BlockVector for the current solution, current Newton update, and the line search update. We also store two AffineConstraints objects: one which enforces the Dirichlet boundary conditions and one that sets all boundary values to zero. The first constrains the solution vector while the second constraints the updates (i.e., we never update boundary values, so we force the relevant update vector values to be zero).\\n\\u00a0   template <int dim>\\n\\u00a0   class StationaryNavierStokes\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     StationaryNavierStokes(const unsigned int degree);\\n\\u00a0     void run(const unsigned int refinement);\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void setup_dofs();\\n\\u00a0 \\n\\u00a0     void initialize_system();\\n\\u00a0 \\n\\u00a0     void assemble(const bool initial_step, const bool assemble_matrix);\\n\\u00a0 \\n\\u00a0     void assemble_system(const bool initial_step);\\n\\u00a0 \\n\\u00a0     void assemble_rhs(const bool initial_step);\\n\\u00a0 \\n\\u00a0     void solve(const bool initial_step);\\n\\u00a0 \\n\\u00a0     void refine_mesh();\\n\\u00a0 \\n\\u00a0     void process_solution(unsigned int refinement);\\n\\u00a0 \\n\\u00a0     void output_results(const unsigned int refinement_cycle) const;\\n\\u00a0 \\n\\u00a0     void newton_iteration(const double       tolerance,\\n\\u00a0                           const unsigned int max_n_line_searches,\\n\\u00a0                           const unsigned int max_n_refinements,\\n\\u00a0                           const bool         is_initial_step,\\n\\u00a0                           const bool         output_result);\\n\\u00a0 \\n\\u00a0     void compute_initial_guess(double step_size);\\n\\u00a0 \\n\\u00a0     double                               viscosity;\\n\\u00a0     double                               gamma;\\n\\u00a0     const unsigned int                   degree;\\n\\u00a0     std::vector<types::global_dof_index> dofs_per_block;\\n\\u00a0 \\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0     const FESystem<dim> fe;\\n\\u00a0     DoFHandler<dim>     dof_handler;\\n\\u00a0 \\n\\u00a0     AffineConstraints<double> zero_constraints;\\n\\u00a0     AffineConstraints<double> nonzero_constraints;\\n\\u00a0 \\n\\u00a0     BlockSparsityPattern      sparsity_pattern;\\n\\u00a0     BlockSparseMatrix<double> system_matrix;\\n\\u00a0     SparseMatrix<double>      pressure_mass_matrix;\\n\\u00a0 \\n\\u00a0     BlockVector<double> present_solution;\\n\\u00a0     BlockVector<double> newton_update;\\n\\u00a0     BlockVector<double> system_rhs;\\n\\u00a0     BlockVector<double> evaluation_point;\\n\\u00a0   };\\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nBlockSparseMatrixDefinition block_sparse_matrix.h:50\\nBlockSparsityPatternDefinition block_sparsity_pattern.h:437\\nBlockVectorDefinition block_vector.h:71\\nDoFHandlerDefinition dof_handler.h:317\\nFESystemDefinition fe_system.h:208\\nSparseMatrixDefinition sparse_matrix.h:520\\nTriangulationDefinition tria.h:1323\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\n Boundary values and right hand side\\nIn this problem we set the velocity along the upper surface of the cavity to be one and zero on the other three walls. The right hand side function is zero so we do not need to set the right hand side function in this tutorial. The number of components of the boundary function is dim+1. We will ultimately use VectorTools::interpolate_boundary_values to set boundary values, which requires the boundary value functions to have the same number of components as the solution, even if all are not used. Put another way: to make this function happy we define boundary values for the pressure even though we will never actually use them.\\n\\u00a0   template <int dim>\\n\\u00a0   class BoundaryValues : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     BoundaryValues()\\n\\u00a0       : Function<dim>(dim + 1)\\n\\u00a0     {}\\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component) const override;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double BoundaryValues<dim>::value(const Point<dim>  &p,\\n\\u00a0                                     const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     Assert(component < this->n_components,\\n\\u00a0            ExcIndexRange(component, 0, this->n_components));\\n\\u00a0     if (component == 0 && std::abs(p[dim - 1] - 1.0) < 1e-10)\\n\\u00a0       return 1.0;\\n\\u00a0 \\n\\u00a0     return 0;\\n\\u00a0   }\\n\\u00a0 \\nFunctionDefinition function.h:152\\nFunction::valuevirtual RangeNumberType value(const Point< dim > &p, const unsigned int component=0) const\\nPointDefinition point.h:111\\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\nstd::abs::VectorizedArray< Number, width > abs(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6927\\n BlockSchurPreconditioner for Navier Stokes equations\\nAs discussed in the introduction, the preconditioner in Krylov iterative methods is implemented as a matrix-vector product operator. In practice, the Schur complement preconditioner is decomposed as a product of three matrices (as presented in the first section). The \\\\(\\\\tilde{A}^{-1}\\\\) in the first factor involves a solve for the linear system \\\\(\\\\tilde{A}x=b\\\\). Here we solve this system via a direct solver for simplicity. The computation involved in the second factor is a simple matrix-vector multiplication. The Schur complement \\\\(\\\\tilde{S}\\\\) can be well approximated by the pressure mass matrix and its inverse can be obtained through an inexact solver. Because the pressure mass matrix is symmetric and positive definite, we can use CG to solve the corresponding linear system.\\n\\u00a0   template <class PreconditionerMp>\\n\\u00a0   class BlockSchurPreconditioner : public Subscriptor\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     BlockSchurPreconditioner(double                           gamma,\\n\\u00a0                              double                           viscosity,\\n\\u00a0                              const BlockSparseMatrix<double> &S,\\n\\u00a0                              const SparseMatrix<double>      &P,\\n\\u00a0                              const PreconditionerMp          &Mppreconditioner);\\n\\u00a0 \\n\\u00a0     void vmult(BlockVector<double> &dst, const BlockVector<double> &src) const;\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     const double                     gamma;\\n\\u00a0     const double                     viscosity;\\n\\u00a0     const BlockSparseMatrix<double> &stokes_matrix;\\n\\u00a0     const SparseMatrix<double>      &pressure_mass_matrix;\\n\\u00a0     const PreconditionerMp          &mp_preconditioner;\\n\\u00a0     SparseDirectUMFPACK              A_inverse;\\n\\u00a0   };\\n\\u00a0 \\nSparseDirectUMFPACKDefinition sparse_direct.h:92\\nSubscriptorDefinition subscriptor.h:60\\nWe can notice that the initialization of the inverse of the matrix at the top left corner is completed in the constructor. If so, every application of the preconditioner then no longer requires the computation of the matrix factors.\\n\\u00a0   template <class PreconditionerMp>\\n\\u00a0   BlockSchurPreconditioner<PreconditionerMp>::BlockSchurPreconditioner(\\n\\u00a0     double                           gamma,\\n\\u00a0     double                           viscosity,\\n\\u00a0     const BlockSparseMatrix<double> &S,\\n\\u00a0     const SparseMatrix<double>      &P,\\n\\u00a0     const PreconditionerMp          &Mppreconditioner)\\n\\u00a0     : gamma(gamma)\\n\\u00a0     , viscosity(viscosity)\\n\\u00a0     , stokes_matrix(S)\\n\\u00a0     , pressure_mass_matrix(P)\\n\\u00a0     , mp_preconditioner(Mppreconditioner)\\n\\u00a0   {\\n\\u00a0     A_inverse.initialize(stokes_matrix.block(0, 0));\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <class PreconditionerMp>\\n\\u00a0   void BlockSchurPreconditioner<PreconditionerMp>::vmult(\\n\\u00a0     BlockVector<double>       &dst,\\n\\u00a0     const BlockVector<double> &src) const\\n\\u00a0   {\\n\\u00a0     Vector<double> utmp(src.block(0));\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       SolverControl solver_control(1000, 1e-6 * src.block(1).l2_norm());\\n\\u00a0       SolverCG<Vector<double>> cg(solver_control);\\n\\u00a0 \\n\\u00a0       dst.block(1) = 0.0;\\n\\u00a0       cg.solve(pressure_mass_matrix,\\n\\u00a0                dst.block(1),\\n\\u00a0                src.block(1),\\n\\u00a0                mp_preconditioner);\\n\\u00a0       dst.block(1) *= -(viscosity + gamma);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       stokes_matrix.block(0, 1).vmult(utmp, dst.block(1));\\n\\u00a0       utmp *= -1.0;\\n\\u00a0       utmp += src.block(0);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     A_inverse.vmult(dst.block(0), utmp);\\n\\u00a0   }\\n\\u00a0 \\nSolverCGDefinition solver_cg.h:179\\nSolverControlDefinition solver_control.h:67\\nVectorDefinition vector.h:120\\n StationaryNavierStokes class implementation\\n StationaryNavierStokes::StationaryNavierStokes\\nThe constructor of this class looks very similar to the one in step-22. The only difference is the viscosity and the Augmented Lagrangian coefficient gamma.\\n\\u00a0   template <int dim>\\n\\u00a0   StationaryNavierStokes<dim>::StationaryNavierStokes(const unsigned int degree)\\n\\u00a0     : viscosity(1.0 / 7500.0)\\n\\u00a0     , gamma(1.0)\\n\\u00a0     , degree(degree)\\n\\u00a0     , triangulation(Triangulation<dim>::maximum_smoothing)\\n\\u00a0     , fe(FE_Q<dim>(degree + 1) ^ dim, FE_Q<dim>(degree))\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0   {}\\n\\u00a0 \\nFE_QDefinition fe_q.h:554\\n StationaryNavierStokes::setup_dofs\\nThis function initializes the DoFHandler enumerating the degrees of freedom and constraints on the current mesh.\\n\\u00a0   template <int dim>\\n\\u00a0   void StationaryNavierStokes<dim>::setup_dofs()\\n\\u00a0   {\\n\\u00a0     system_matrix.clear();\\n\\u00a0     pressure_mass_matrix.clear();\\n\\u00a0 \\nThe first step is to associate DoFs with a given mesh.\\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0 \\nWe renumber the components to have all velocity DoFs come before the pressure DoFs to be able to split the solution vector in two blocks which are separately accessed in the block preconditioner.\\n\\u00a0     std::vector<unsigned int> block_component(dim + 1, 0);\\n\\u00a0     block_component[dim] = 1;\\n\\u00a0     DoFRenumbering::component_wise(dof_handler, block_component);\\n\\u00a0 \\n\\u00a0     dofs_per_block =\\n\\u00a0       DoFTools::count_dofs_per_fe_block(dof_handler, block_component);\\n\\u00a0     unsigned int dof_u = dofs_per_block[0];\\n\\u00a0     unsigned int dof_p = dofs_per_block[1];\\n\\u00a0 \\nDoFRenumbering::component_wisevoid component_wise(DoFHandler< dim, spacedim > &dof_handler, const std::vector< unsigned int > &target_component=std::vector< unsigned int >())Definition dof_renumbering.cc:666\\nDoFTools::count_dofs_per_fe_blockstd::vector< types::global_dof_index > count_dofs_per_fe_block(const DoFHandler< dim, spacedim > &dof, const std::vector< unsigned int > &target_block=std::vector< unsigned int >())Definition dof_tools.cc:2104\\nIn Newton's scheme, we first apply the boundary condition on the solution obtained from the initial step. To make sure the boundary conditions remain satisfied during Newton's iteration, zero boundary conditions are used for the update \\\\(\\\\delta u^k\\\\). Therefore we set up two different constraint objects.\\n\\u00a0     const FEValuesExtractors::Vector velocities(0);\\n\\u00a0     {\\n\\u00a0       nonzero_constraints.clear();\\n\\u00a0 \\n\\u00a0       DoFTools::make_hanging_node_constraints(dof_handler, nonzero_constraints);\\n\\u00a0       VectorTools::interpolate_boundary_values(dof_handler,\\n\\u00a0                                                0,\\n\\u00a0                                                BoundaryValues<dim>(),\\n\\u00a0                                                nonzero_constraints,\\n\\u00a0                                                fe.component_mask(velocities));\\n\\u00a0     }\\n\\u00a0     nonzero_constraints.close();\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       zero_constraints.clear();\\n\\u00a0 \\n\\u00a0       DoFTools::make_hanging_node_constraints(dof_handler, zero_constraints);\\n\\u00a0       VectorTools::interpolate_boundary_values(dof_handler,\\n\\u00a0                                                0,\\n\\u00a0                                                Functions::ZeroFunction<dim>(\\n\\u00a0                                                  dim + 1),\\n\\u00a0                                                zero_constraints,\\n\\u00a0                                                fe.component_mask(velocities));\\n\\u00a0     }\\n\\u00a0     zero_constraints.close();\\n\\u00a0 \\n\\u00a0     std::cout << \\\"Number of active cells: \\\" << triangulation.n_active_cells()\\n\\u00a0               << std::endl\\n\\u00a0               << \\\"Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n\\u00a0               << \\\" (\\\" << dof_u << \\\" + \\\" << dof_p << ')' << std::endl;\\n\\u00a0   }\\n\\u00a0 \\nFunctions::ZeroFunctionDefinition function.h:510\\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nDoFTools::make_hanging_node_constraintsvoid make_hanging_node_constraints(const DoFHandler< dim, spacedim > &dof_handler, AffineConstraints< number > &constraints)Definition dof_tools_constraints.cc:3073\\nVectorTools::interpolate_boundary_valuesvoid interpolate_boundary_values(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const std::map< types::boundary_id, const Function< spacedim, number > * > &function_map, std::map< types::global_dof_index, number > &boundary_values, const ComponentMask &component_mask={})\\nFEValuesExtractors::VectorDefinition fe_values_extractors.h:150\\n StationaryNavierStokes::initialize_system\\nOn each mesh the SparsityPattern and the size of the linear system are different. This function initializes them after mesh refinement.\\n\\u00a0   template <int dim>\\n\\u00a0   void StationaryNavierStokes<dim>::initialize_system()\\n\\u00a0   {\\n\\u00a0     {\\n\\u00a0       BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block);\\n\\u00a0       DoFTools::make_sparsity_pattern(dof_handler, dsp, nonzero_constraints);\\n\\u00a0       sparsity_pattern.copy_from(dsp);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     system_matrix.reinit(sparsity_pattern);\\n\\u00a0 \\n\\u00a0     present_solution.reinit(dofs_per_block);\\n\\u00a0     newton_update.reinit(dofs_per_block);\\n\\u00a0     system_rhs.reinit(dofs_per_block);\\n\\u00a0   }\\n\\u00a0 \\nBlockDynamicSparsityPatternDefinition block_sparsity_pattern.h:549\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\n StationaryNavierStokes::assemble\\nThis function builds the system matrix and right hand side that we currently work on. The initial_step argument is used to determine which set of constraints we apply (nonzero for the initial step and zero for the others). The assemble_matrix argument determines whether to assemble the whole system or only the right hand side vector, respectively.\\n\\u00a0   template <int dim>\\n\\u00a0   void StationaryNavierStokes<dim>::assemble(const bool initial_step,\\n\\u00a0                                              const bool assemble_matrix)\\n\\u00a0   {\\n\\u00a0     if (assemble_matrix)\\n\\u00a0       system_matrix = 0;\\n\\u00a0 \\n\\u00a0     system_rhs = 0;\\n\\u00a0 \\n\\u00a0     const QGauss<dim> quadrature_formula(degree + 2);\\n\\u00a0 \\n\\u00a0     FEValues<dim> fe_values(fe,\\n\\u00a0                             quadrature_formula,\\n\\u00a0                             update_values | update_quadrature_points |\\n\\u00a0                               update_JxW_values | update_gradients);\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n\\u00a0     const unsigned int n_q_points    = quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     const FEValuesExtractors::Vector velocities(0);\\n\\u00a0     const FEValuesExtractors::Scalar pressure(dim);\\n\\u00a0 \\n\\u00a0     FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0     Vector<double>     local_rhs(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\nFEValuesDefinition fe_values.h:63\\nFullMatrixDefinition full_matrix.h:79\\nQGaussDefinition quadrature_lib.h:40\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nFEValuesExtractors::ScalarDefinition fe_values_extractors.h:95\\nFor the linearized system, we create temporary storage for present velocity and gradient, and present pressure. In practice, they are all obtained through their shape functions at quadrature points.\\n\\u00a0     std::vector<Tensor<1, dim>> present_velocity_values(n_q_points);\\n\\u00a0     std::vector<Tensor<2, dim>> present_velocity_gradients(n_q_points);\\n\\u00a0     std::vector<double>         present_pressure_values(n_q_points);\\n\\u00a0 \\n\\u00a0     std::vector<double>         div_phi_u(dofs_per_cell);\\n\\u00a0     std::vector<Tensor<1, dim>> phi_u(dofs_per_cell);\\n\\u00a0     std::vector<Tensor<2, dim>> grad_phi_u(dofs_per_cell);\\n\\u00a0     std::vector<double>         phi_p(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0         local_matrix = 0;\\n\\u00a0         local_rhs    = 0;\\n\\u00a0 \\n\\u00a0         fe_values[velocities].get_function_values(evaluation_point,\\n\\u00a0                                                   present_velocity_values);\\n\\u00a0 \\n\\u00a0         fe_values[velocities].get_function_gradients(\\n\\u00a0           evaluation_point, present_velocity_gradients);\\n\\u00a0 \\n\\u00a0         fe_values[pressure].get_function_values(evaluation_point,\\n\\u00a0                                                 present_pressure_values);\\n\\u00a0 \\nThe assembly is similar to step-22. An additional term with gamma as a coefficient is the Augmented Lagrangian (AL), which is assembled via grad-div stabilization. As we discussed in the introduction, the bottom right block of the system matrix should be zero. Since the pressure mass matrix is used while creating the preconditioner, we assemble it here and then move it into a separate SparseMatrix at the end (same as in step-22).\\n\\u00a0         for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0           {\\n\\u00a0             for (unsigned int k = 0; k < dofs_per_cell; ++k)\\n\\u00a0               {\\n\\u00a0                 div_phi_u[k]  = fe_values[velocities].divergence(k, q);\\n\\u00a0                 grad_phi_u[k] = fe_values[velocities].gradient(k, q);\\n\\u00a0                 phi_u[k]      = fe_values[velocities].value(k, q);\\n\\u00a0                 phi_p[k]      = fe_values[pressure].value(k, q);\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0             for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0               {\\n\\u00a0                 if (assemble_matrix)\\n\\u00a0                   {\\n\\u00a0                     for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0                       {\\n\\u00a0                         local_matrix(i, j) +=\\n\\u00a0                           (viscosity *\\n\\u00a0                              scalar_product(grad_phi_u[i], grad_phi_u[j]) +\\n\\u00a0                            phi_u[i] *\\n\\u00a0                              (present_velocity_gradients[q] * phi_u[j]) +\\n\\u00a0                            phi_u[i] *\\n\\u00a0                              (grad_phi_u[j] * present_velocity_values[q]) -\\n\\u00a0                            div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j] +\\n\\u00a0                            gamma * div_phi_u[i] * div_phi_u[j] +\\n\\u00a0                            phi_p[i] * phi_p[j]) *\\n\\u00a0                           fe_values.JxW(q);\\n\\u00a0                       }\\n\\u00a0                   }\\n\\u00a0 \\n\\u00a0                 double present_velocity_divergence =\\n\\u00a0                   trace(present_velocity_gradients[q]);\\n\\u00a0                 local_rhs(i) +=\\n\\u00a0                   (-viscosity * scalar_product(grad_phi_u[i],\\n\\u00a0                                                present_velocity_gradients[q]) -\\n\\u00a0                    phi_u[i] * (present_velocity_gradients[q] *\\n\\u00a0                                present_velocity_values[q]) +\\n\\u00a0                    div_phi_u[i] * present_pressure_values[q] +\\n\\u00a0                    phi_p[i] * present_velocity_divergence -\\n\\u00a0                    gamma * div_phi_u[i] * present_velocity_divergence) *\\n\\u00a0                   fe_values.JxW(q);\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0 \\n\\u00a0         const AffineConstraints<double> &constraints_used =\\n\\u00a0           initial_step ? nonzero_constraints : zero_constraints;\\n\\u00a0 \\n\\u00a0         if (assemble_matrix)\\n\\u00a0           {\\n\\u00a0             constraints_used.distribute_local_to_global(local_matrix,\\n\\u00a0                                                         local_rhs,\\n\\u00a0                                                         local_dof_indices,\\n\\u00a0                                                         system_matrix,\\n\\u00a0                                                         system_rhs);\\n\\u00a0           }\\n\\u00a0         else\\n\\u00a0           {\\n\\u00a0             constraints_used.distribute_local_to_global(local_rhs,\\n\\u00a0                                                         local_dof_indices,\\n\\u00a0                                                         system_rhs);\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\ntraceDEAL_II_HOST constexpr Number trace(const SymmetricTensor< 2, dim2, Number > &)\\nIf we were asked to assemble the Newton matrix, then we also built a pressure mass matrix in the bottom right block of the matrix. We only need this for the preconditioner, so we need to copy it in into a separate matrix object, followed by zeroing out this block in the Newton matrix.\\nNote that settings this bottom right block to zero is not identical to not assembling anything in this block, because applying boundary values and hanging node constraints (in the constraints_used.distribute_local_to_global() call above) puts entries into this block. As a consequence, setting the \\\\((1,1)\\\\) block to zero below does not result in what would have happened if we had just not assembled a pressure mass matrix in that block to begin with.\\nThe difference is that if we had not assembled anything in this block, dealing with constraint degrees of freedom would have put entries on the diagonal of the \\\\((1,1)\\\\) block whereas the last operation below, zeroing out the entire block, results in a system matrix with rows and columns that are completely empty. In other words, the linear problem is singular. Luckily, however, the FGMRES solver we use appears to handle these rows and columns without any problem.\\n\\u00a0     if (assemble_matrix)\\n\\u00a0       {\\n\\u00a0         pressure_mass_matrix.reinit(sparsity_pattern.block(1, 1));\\n\\u00a0         pressure_mass_matrix.copy_from(system_matrix.block(1, 1));\\n\\u00a0 \\n\\u00a0         system_matrix.block(1, 1) = 0;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void StationaryNavierStokes<dim>::assemble_system(const bool initial_step)\\n\\u00a0   {\\n\\u00a0     assemble(initial_step, true);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void StationaryNavierStokes<dim>::assemble_rhs(const bool initial_step)\\n\\u00a0   {\\n\\u00a0     assemble(initial_step, false);\\n\\u00a0   }\\n\\u00a0 \\ninternal::assemblevoid assemble(const MeshWorker::DoFInfoBox< dim, DOFINFO > &dinfo, A *assembler)Definition loop.h:70\\n StationaryNavierStokes::solve\\nIn this function, we use FGMRES together with the block preconditioner, which is defined at the beginning of the program, to solve the linear system. What we obtain at this step is the solution vector. If this is the initial step, the solution vector gives us an initial guess for the Navier Stokes equations. For the initial step, nonzero constraints are applied in order to make sure boundary conditions are satisfied. In the following steps, we will solve for the Newton update so zero constraints are used.\\n\\u00a0   template <int dim>\\n\\u00a0   void StationaryNavierStokes<dim>::solve(const bool initial_step)\\n\\u00a0   {\\n\\u00a0     const AffineConstraints<double> &constraints_used =\\n\\u00a0       initial_step ? nonzero_constraints : zero_constraints;\\n\\u00a0 \\n\\u00a0     SolverControl solver_control(system_matrix.m(),\\n\\u00a0                                  1e-4 * system_rhs.l2_norm(),\\n\\u00a0                                  true);\\n\\u00a0 \\n\\u00a0     SolverFGMRES<BlockVector<double>> gmres(solver_control);\\n\\u00a0     SparseILU<double>                 pmass_preconditioner;\\n\\u00a0     pmass_preconditioner.initialize(pressure_mass_matrix,\\n\\u00a0                                     SparseILU<double>::AdditionalData());\\n\\u00a0 \\n\\u00a0     const BlockSchurPreconditioner<SparseILU<double>> preconditioner(\\n\\u00a0       gamma,\\n\\u00a0       viscosity,\\n\\u00a0       system_matrix,\\n\\u00a0       pressure_mass_matrix,\\n\\u00a0       pmass_preconditioner);\\n\\u00a0 \\n\\u00a0     gmres.solve(system_matrix, newton_update, system_rhs, preconditioner);\\n\\u00a0     std::cout << \\\"FGMRES steps: \\\" << solver_control.last_step() << std::endl;\\n\\u00a0 \\n\\u00a0     constraints_used.distribute(newton_update);\\n\\u00a0   }\\n\\u00a0 \\nSolverFGMRESDefinition solver_gmres.h:648\\nSparseILUDefinition sparse_ilu.h:60\\nSparseILU::AdditionalDatatypename SparseLUDecomposition< number >::AdditionalData AdditionalDataDefinition sparse_ilu.h:79\\nSparseILU::initializevoid initialize(const SparseMatrix< somenumber > &matrix, const AdditionalData &parameters=AdditionalData())\\n StationaryNavierStokes::refine_mesh\\nAfter finding a good initial guess on the coarse mesh, we hope to decrease the error through refining the mesh. Here we do adaptive refinement similar to step-15 except that we use the Kelly estimator on the velocity only. We also need to transfer the current solution to the next mesh using the SolutionTransfer class.\\n\\u00a0   template <int dim>\\n\\u00a0   void StationaryNavierStokes<dim>::refine_mesh()\\n\\u00a0   {\\n\\u00a0     Vector<float> estimated_error_per_cell(triangulation.n_active_cells());\\n\\u00a0     const FEValuesExtractors::Vector velocity(0);\\n\\u00a0     KellyErrorEstimator<dim>::estimate(\\n\\u00a0       dof_handler,\\n\\u00a0       QGauss<dim - 1>(degree + 1),\\n\\u00a0       std::map<types::boundary_id, const Function<dim> *>(),\\n\\u00a0       present_solution,\\n\\u00a0       estimated_error_per_cell,\\n\\u00a0       fe.component_mask(velocity));\\n\\u00a0 \\n\\u00a0     GridRefinement::refine_and_coarsen_fixed_number(triangulation,\\n\\u00a0                                                     estimated_error_per_cell,\\n\\u00a0                                                     0.3,\\n\\u00a0                                                     0.0);\\n\\u00a0 \\n\\u00a0     triangulation.prepare_coarsening_and_refinement();\\n\\u00a0     SolutionTransfer<dim, BlockVector<double>> solution_transfer(dof_handler);\\n\\u00a0     solution_transfer.prepare_for_coarsening_and_refinement(present_solution);\\n\\u00a0     triangulation.execute_coarsening_and_refinement();\\n\\u00a0 \\nKellyErrorEstimator::estimatestatic void estimate(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const Quadrature< dim - 1 > &quadrature, const std::map< types::boundary_id, const Function< spacedim, Number > * > &neumann_bc, const ReadVector< Number > &solution, Vector< float > &error, const ComponentMask &component_mask={}, const Function< spacedim > *coefficients=nullptr, const unsigned int n_threads=numbers::invalid_unsigned_int, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id, const types::material_id material_id=numbers::invalid_material_id, const Strategy strategy=cell_diameter_over_24)\\nSolutionTransferDefinition solution_transfer.h:337\\nparallel::distributed::Triangulation::execute_coarsening_and_refinementvirtual void execute_coarsening_and_refinement() overrideDefinition tria.cc:3320\\nparallel::distributed::Triangulation::prepare_coarsening_and_refinementvirtual bool prepare_coarsening_and_refinement() overrideDefinition tria.cc:2805\\nunsigned int\\nGridRefinement::refine_and_coarsen_fixed_numbervoid refine_and_coarsen_fixed_number(Triangulation< dim, spacedim > &triangulation, const Vector< Number > &criteria, const double top_fraction_of_cells, const double bottom_fraction_of_cells, const unsigned int max_n_cells=std::numeric_limits< unsigned int >::max())Definition grid_refinement.cc:318\\nFirst the DoFHandler is set up and constraints are generated. Then we create a temporary BlockVector tmp, whose size is according with the solution on the new mesh.\\n\\u00a0     setup_dofs();\\n\\u00a0 \\n\\u00a0     BlockVector<double> tmp(dofs_per_block);\\n\\u00a0 \\nTransfer solution from coarse to fine mesh and apply boundary value constraints to the new transferred solution. Note that present_solution is still a vector corresponding to the old mesh.\\n\\u00a0     solution_transfer.interpolate(present_solution, tmp);\\n\\u00a0     nonzero_constraints.distribute(tmp);\\n\\u00a0 \\nFinally set up matrix and vectors and set the present_solution to the interpolated data.\\n\\u00a0     initialize_system();\\n\\u00a0     present_solution = tmp;\\n\\u00a0   }\\n\\u00a0 \\n StationaryNavierStokes<dim>::newton_iteration\\nThis function implements the Newton iteration with given tolerance, maximum number of iterations, and the number of mesh refinements to do.\\nThe argument is_initial_step tells us whether setup_system is necessary, and which part, system matrix or right hand side vector, should be assembled. If we do a line search, the right hand side is already assembled while checking the residual norm in the last iteration. Therefore, we just need to assemble the system matrix at the current iteration. The last argument output_result determines whether or not graphical output should be produced.\\n\\u00a0   template <int dim>\\n\\u00a0   void StationaryNavierStokes<dim>::newton_iteration(\\n\\u00a0     const double       tolerance,\\n\\u00a0     const unsigned int max_n_line_searches,\\n\\u00a0     const unsigned int max_n_refinements,\\n\\u00a0     const bool         is_initial_step,\\n\\u00a0     const bool         output_result)\\n\\u00a0   {\\n\\u00a0     bool first_step = is_initial_step;\\n\\u00a0 \\n\\u00a0     for (unsigned int refinement_n = 0; refinement_n < max_n_refinements + 1;\\n\\u00a0          ++refinement_n)\\n\\u00a0       {\\n\\u00a0         unsigned int line_search_n = 0;\\n\\u00a0         double       last_res      = 1.0;\\n\\u00a0         double       current_res   = 1.0;\\n\\u00a0         std::cout << \\\"grid refinements: \\\" << refinement_n << std::endl\\n\\u00a0                   << \\\"viscosity: \\\" << viscosity << std::endl;\\n\\u00a0 \\n\\u00a0         while ((first_step || (current_res > tolerance)) &&\\n\\u00a0                line_search_n < max_n_line_searches)\\n\\u00a0           {\\n\\u00a0             if (first_step)\\n\\u00a0               {\\n\\u00a0                 setup_dofs();\\n\\u00a0                 initialize_system();\\n\\u00a0                 evaluation_point = present_solution;\\n\\u00a0                 assemble_system(first_step);\\n\\u00a0                 solve(first_step);\\n\\u00a0                 present_solution = newton_update;\\n\\u00a0                 nonzero_constraints.distribute(present_solution);\\n\\u00a0                 first_step       = false;\\n\\u00a0                 evaluation_point = present_solution;\\n\\u00a0                 assemble_rhs(first_step);\\n\\u00a0                 current_res = system_rhs.l2_norm();\\n\\u00a0                 std::cout << \\\"The residual of initial guess is \\\" << current_res\\n\\u00a0                           << std::endl;\\n\\u00a0                 last_res = current_res;\\n\\u00a0               }\\n\\u00a0             else\\n\\u00a0               {\\n\\u00a0                 evaluation_point = present_solution;\\n\\u00a0                 assemble_system(first_step);\\n\\u00a0                 solve(first_step);\\n\\u00a0 \\nTo make sure our solution is getting close to the exact solution, we let the solution be updated with a weight alpha such that the new residual is smaller than the one of last step, which is done in the following loop. This is the same line search algorithm used in step-15.\\n\\u00a0                 for (double alpha = 1.0; alpha > 1e-5; alpha *= 0.5)\\n\\u00a0                   {\\n\\u00a0                     evaluation_point = present_solution;\\n\\u00a0                     evaluation_point.add(alpha, newton_update);\\n\\u00a0                     nonzero_constraints.distribute(evaluation_point);\\n\\u00a0                     assemble_rhs(first_step);\\n\\u00a0                     current_res = system_rhs.l2_norm();\\n\\u00a0                     std::cout << \\\"  alpha: \\\" << std::setw(10) << alpha\\n\\u00a0                               << std::setw(0) << \\\"  residual: \\\" << current_res\\n\\u00a0                               << std::endl;\\n\\u00a0                     if (current_res < last_res)\\n\\u00a0                       break;\\n\\u00a0                   }\\n\\u00a0                 {\\n\\u00a0                   present_solution = evaluation_point;\\n\\u00a0                   std::cout << \\\"  number of line searches: \\\" << line_search_n\\n\\u00a0                             << \\\"  residual: \\\" << current_res << std::endl;\\n\\u00a0                   last_res = current_res;\\n\\u00a0                 }\\n\\u00a0                 ++line_search_n;\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0             if (output_result)\\n\\u00a0               {\\n\\u00a0                 output_results(max_n_line_searches * refinement_n +\\n\\u00a0                                line_search_n);\\n\\u00a0 \\n\\u00a0                 if (current_res <= tolerance)\\n\\u00a0                   process_solution(refinement_n);\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         if (refinement_n < max_n_refinements)\\n\\u00a0           {\\n\\u00a0             refine_mesh();\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n StationaryNavierStokes::compute_initial_guess\\nThis function will provide us with an initial guess by using a continuation method as we discussed in the introduction. The Reynolds number is increased step-by-step until we reach the target value. By experiment, the solution to Stokes is good enough to be the initial guess of NSE with Reynolds number 1000 so we start there. To make sure the solution from previous problem is close enough to the next one, the step size must be small enough.\\n\\u00a0   template <int dim>\\n\\u00a0   void StationaryNavierStokes<dim>::compute_initial_guess(double step_size)\\n\\u00a0   {\\n\\u00a0     const double target_Re = 1.0 / viscosity;\\n\\u00a0 \\n\\u00a0     bool is_initial_step = true;\\n\\u00a0 \\n\\u00a0     for (double Re = 1000.0; Re < target_Re;\\n\\u00a0          Re        = std::min(Re + step_size, target_Re))\\n\\u00a0       {\\n\\u00a0         viscosity = 1.0 / Re;\\n\\u00a0         std::cout << \\\"Searching for initial guess with Re = \\\" << Re\\n\\u00a0                   << std::endl;\\n\\u00a0         newton_iteration(1e-12, 50, 0, is_initial_step, false);\\n\\u00a0         is_initial_step = false;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\nstd::min::VectorizedArray< Number, width > min(const ::VectorizedArray< Number, width > &, const ::VectorizedArray< Number, width > &)Definition vectorization.h:6960\\n StationaryNavierStokes::output_results\\nThis function is the same as in step-22 except that we choose a name for the output file that also contains the Reynolds number (i.e., the inverse of the viscosity in the current context).\\n\\u00a0   template <int dim>\\n\\u00a0   void StationaryNavierStokes<dim>::output_results(\\n\\u00a0     const unsigned int output_index) const\\n\\u00a0   {\\n\\u00a0     std::vector<std::string> solution_names(dim, \\\"velocity\\\");\\n\\u00a0     solution_names.emplace_back(\\\"pressure\\\");\\n\\u00a0 \\n\\u00a0     std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n\\u00a0       data_component_interpretation(\\n\\u00a0         dim, DataComponentInterpretation::component_is_part_of_vector);\\n\\u00a0     data_component_interpretation.push_back(\\n\\u00a0       DataComponentInterpretation::component_is_scalar);\\n\\u00a0     DataOut<dim> data_out;\\n\\u00a0     data_out.attach_dof_handler(dof_handler);\\n\\u00a0     data_out.add_data_vector(present_solution,\\n\\u00a0                              solution_names,\\n\\u00a0                              DataOut<dim>::type_dof_data,\\n\\u00a0                              data_component_interpretation);\\n\\u00a0     data_out.build_patches();\\n\\u00a0 \\n\\u00a0     std::ofstream output(std::to_string(1.0 / viscosity) + \\\"-solution-\\\" +\\n\\u00a0                          Utilities::int_to_string(output_index, 4) + \\\".vtk\\\");\\n\\u00a0     data_out.write_vtk(output);\\n\\u00a0   }\\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nDataComponentInterpretation::component_is_scalar@ component_is_scalarDefinition data_component_interpretation.h:52\\nDataComponentInterpretation::component_is_part_of_vector@ component_is_part_of_vectorDefinition data_component_interpretation.h:58\\nUtilities::int_to_stringstd::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)Definition utilities.cc:470\\n StationaryNavierStokes::process_solution\\nIn our test case, we do not know the analytical solution. This function outputs the velocity components along \\\\(x=0.5\\\\) and \\\\(0 \\\\leq y \\\\leq 1\\\\) so they can be compared with data from the literature.\\n\\u00a0   template <int dim>\\n\\u00a0   void StationaryNavierStokes<dim>::process_solution(unsigned int refinement)\\n\\u00a0   {\\n\\u00a0     std::ofstream f(std::to_string(1.0 / viscosity) + \\\"-line-\\\" +\\n\\u00a0                     std::to_string(refinement) + \\\".txt\\\");\\n\\u00a0     f << \\\"# y u_x u_y\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     Point<dim> p;\\n\\u00a0     p[0] = 0.5;\\n\\u00a0     p[1] = 0.5;\\n\\u00a0 \\n\\u00a0     f << std::scientific;\\n\\u00a0 \\n\\u00a0     for (unsigned int i = 0; i <= 100; ++i)\\n\\u00a0       {\\n\\u00a0         p[dim - 1] = i / 100.0;\\n\\u00a0 \\n\\u00a0         Vector<double> tmp_vector(dim + 1);\\n\\u00a0         VectorTools::point_value(dof_handler, present_solution, p, tmp_vector);\\n\\u00a0         f << p[dim - 1];\\n\\u00a0 \\n\\u00a0         for (int j = 0; j < dim; ++j)\\n\\u00a0           f << ' ' << tmp_vector(j);\\n\\u00a0         f << std::endl;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\nVectorTools::point_valuevoid point_value(const DoFHandler< dim, spacedim > &dof, const VectorType &fe_function, const Point< spacedim, double > &point, Vector< typename VectorType::value_type > &value)\\n StationaryNavierStokes::run\\nThis is the last step of this program. In this part, we generate the grid and run the other functions respectively. The max refinement can be set by the argument.\\n\\u00a0   template <int dim>\\n\\u00a0   void StationaryNavierStokes<dim>::run(const unsigned int refinement)\\n\\u00a0   {\\n\\u00a0     GridGenerator::hyper_cube(triangulation);\\n\\u00a0     triangulation.refine_global(5);\\n\\u00a0 \\n\\u00a0     const double Re = 1.0 / viscosity;\\n\\u00a0 \\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nGridGenerator::hyper_cubevoid hyper_cube(Triangulation< dim, spacedim > &tria, const double left=0., const double right=1., const bool colorize=false)\\nIf the viscosity is smaller than \\\\(1/1000\\\\), we have to first search for an initial guess via a continuation method. What we should notice is the search is always on the initial mesh, that is the \\\\(8 \\\\times 8\\\\) mesh in this program. After that, we just do the same as we did when viscosity is larger than \\\\(1/1000\\\\): run Newton's iteration, refine the mesh, transfer solutions, and repeat.\\n\\u00a0     if (Re > 1000.0)\\n\\u00a0       {\\n\\u00a0         std::cout << \\\"Searching for initial guess ...\\\" << std::endl;\\n\\u00a0         const double step_size = 2000.0;\\n\\u00a0         compute_initial_guess(step_size);\\n\\u00a0         std::cout << \\\"Found initial guess.\\\" << std::endl;\\n\\u00a0         std::cout << \\\"Computing solution with target Re = \\\" << Re << std::endl;\\n\\u00a0         viscosity = 1.0 / Re;\\n\\u00a0         newton_iteration(1e-12, 50, refinement, false, true);\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       {\\nWhen the viscosity is larger than 1/1000, the solution to Stokes equations is good enough as an initial guess. If so, we do not need to search for the initial guess using a continuation method. Newton's iteration can be started directly.\\n\\u00a0         newton_iteration(1e-12, 50, refinement, true, true);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 } // namespace Step57\\n\\u00a0 \\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       using namespace Step57;\\n\\u00a0 \\n\\u00a0       StationaryNavierStokes<2> flow(/* degree = */ 1);\\n\\u00a0       flow.run(4);\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nNow we use the method we discussed above to solve Navier Stokes equations with viscosity \\\\(1/400\\\\) and \\\\(1/7500\\\\).\\nTest case 1: Low Reynolds Number \\nIn the first test case the viscosity is set to be \\\\(1/400\\\\). As we discussed in the introduction, the initial guess is the solution to the corresponding Stokes problem. In the following table, the residuals at each Newton's iteration on every mesh is shown. The data in the table shows that Newton's iteration converges quadratically.\\n\\n\\n\\\\(\\\\mathrm{Re}=400\\\\) Mesh0 Mesh1 Mesh2 Mesh3 Mesh4  \\n\\nNewton iter  Residual  FGMRES  Residual  FGMRES  Residual  FGMRES  Residual  FGMRES  Residual  FGMRES   \\n\\n1 3.7112e-03 5 6.4189e-03 3 2.4338e-03 3 1.0570e-03 3 4.9499e-04 3  \\n\\n2 7.0849e-04 5 9.9458e-04 5 1.1409e-04 6 1.3544e-05 6 1.4171e-06 6  \\n\\n3 1.9980e-05 5 4.5007e-05 5 2.9020e-08 5 4.4021e-10 6 6.3435e-11 6  \\n\\n4 2.3165e-09 6 1.6891e-07 5 1.2338e-14 7 1.8506e-14 8 8.8563e-15 8  \\n\\n5 1.2585e-13 7 1.4520e-11 6 1.9044e-13 8 \\n\\n6 1.3998e-15 8 \\n\\nThe following figures show the sequence of generated grids. For the case of \\\\(\\\\mathrm{Re}=400\\\\), the initial guess is obtained by solving Stokes on an \\\\(8 \\\\times 8\\\\) mesh, and the mesh is refined adaptively. Between meshes, the solution from the coarse mesh is interpolated to the fine mesh to be used as an initial guess.\\n\\n\\n   \\n\\n  \\n\\nThis picture is the graphical streamline result of lid-driven cavity with \\\\(\\\\mathrm{Re}=400\\\\). \\nThen the solution is compared with a reference solution from [97] and the reference solution data can be found in the file \\\"ref_2d_ghia_u.txt\\\".\\n\\nTest case 2: High Reynolds Number \\nNewton's iteration requires a good initial guess. However, the nonlinear term dominates when the Reynolds number is large, so that the solution to the Stokes equations may be far away from the exact solution. If the Stokes solution acts as the initial guess, the convergence will be lost. The following picture shows that the nonlinear iteration gets stuck and the residual no longer decreases in further iterations.\\n\\nThe initial guess, therefore, has to be obtained via a continuation method which has been discussed in the introduction. Here the step size in the continuation method, that is \\\\(|\\\\nu_{i}-\\\\nu_{i+1}|\\\\), is 2000 and the initial mesh is of size \\\\(32 \\\\times 32\\\\). After obtaining an initial guess, the mesh is refined as in the previous test case. The following picture shows that at each refinement Newton's iteration has quadratic convergence. 52 steps of Newton's iterations are executed for solving this test case.\\n\\nWe also show the residual from each step of Newton's iteration on every mesh. The quadratic convergence is clearly visible in the table.\\n\\n\\n\\\\(\\\\mathrm{Re}=7500\\\\) Mesh0 Mesh1 Mesh2 Mesh3 Mesh4  \\n\\nNewton iter  Residual  FGMRES  Residual  FGMRES  Residual  FGMRES  Residual  FGMRES  Residual  FGMRES   \\n\\n1 1.8922e-06 6 4.2506e-03 3 1.4299e-03 3 4.8793e-04 2 1.8998e-04 2  \\n\\n2 3.1644e-09 8 1.3732e-03 7 4.1506e-04 7 9.1119e-05 8 1.3555e-05 8  \\n\\n3 1.7611e-14 9 2.1946e-04 6 1.7881e-05 6 5.2678e-07 7 9.3739e-09 7  \\n\\n4 8.8269e-06 6 6.8210e-09 7 2.2770e-11 8 1.2588e-13 9  \\n\\n5 1.2974e-07 7 1.2515e-13 9 1.7801e-14 1 \\n\\n6 4.4352e-11 7 \\n\\n7 6.2863e-15 9 \\n\\nThe sequence of generated grids looks like this: \\n\\n   \\n\\n  \\n\\nWe compare our solution with the reference solution from [83] .  The following picture presents the graphical result. \\nFurthermore, the error consists of the nonlinear error, which decreases as we perform Newton iterations, and the discretization error, which depends on the mesh size. That is why we have to refine the mesh and repeat Newton's iteration on the next finer mesh. From the table above, we can see that the final residual (nonlinear error) is below \\\\(10^{-12}\\\\) on each mesh, but the following picture shows us the difference between solutions on subsequently finer meshes:\\n\\n\\nPossibilities for extensions\\nCompare to other solvers\\nIt is easy to compare the currently implemented linear solver to just using UMFPACK for the whole linear system. You need to remove the nullspace containing the constant pressures and it is done in step-56. More interesting is the comparison to other state of the art preconditioners like PCD. It turns out that the preconditioner here is very competitive, as can be seen in the paper [113].\\nThe following table shows the timing results between our iterative approach (FGMRES) compared to a direct solver (UMFPACK) for the whole system with viscosity set to 1/400. Even though we use the same direct solver for the velocity block in the iterative solver, it is considerably faster and consumes less memory. This will be even more pronounced in 3d.\\n\\n\\nRefinement Cycle DoFs Iterative: Total/s (Setup/s) Direct: Total/s (Setup/s)  \\n\\n5 9539 0.10 (0.06) 0.13 (0.12)  \\n\\n6 37507 0.58 (0.37) 1.03 (0.97)  \\n\\n7 148739 3.59 (2.73) 7.78 (7.53)  \\n\\n8 592387 29.17 (24.94) (>4GB RAM)  \\n\\n3d computations\\nThe code is set up to also run in 3d. Of course the reference values are different, see [210] for example. High resolution computations are not doable with this example as is, because a direct solver for the velocity block does not work well in 3d. Rather, a parallel solver based on algebraic or geometric multigrid is needed \\u2013 see below.\\nParallelization\\nFor larger computations, especially in 3d, it is necessary to implement MPI parallel solvers and preconditioners. A good starting point would be step-55, which uses algebraic multigrid for the velocity block for the Stokes equations. Another option would be to take a look at the list of codes in the deal.II code gallery, which already contains parallel Navier-Stokes solvers.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2017 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Author: Liang Zhao and Timo Heister, Clemson University, 2016\\n */\\n \\n \\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/function.h>\\n#include <deal.II/base/utilities.h>\\n#include <deal.II/base/tensor.h>\\n \\n#include <deal.II/lac/block_vector.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/block_sparse_matrix.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/solver_gmres.h>\\n#include <deal.II/lac/precondition.h>\\n#include <deal.II/lac/affine_constraints.h>\\n \\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_refinement.h>\\n#include <deal.II/grid/grid_tools.h>\\n \\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_renumbering.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_system.h>\\n#include <deal.II/fe/fe_values.h>\\n \\n#include <deal.II/numerics/vector_tools.h>\\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/error_estimator.h>\\n \\n#include <deal.II/numerics/solution_transfer.h>\\n \\n#include <deal.II/lac/sparse_direct.h>\\n \\n#include <deal.II/lac/sparse_ilu.h>\\n \\n \\n#include <fstream>\\n#include <iostream>\\n \\nnamespace Step57\\n{\\n using namespace dealii;\\n \\n \\n template <int dim>\\n class StationaryNavierStokes\\n  {\\n public:\\n    StationaryNavierStokes(const unsigned int degree);\\n void run(const unsigned int refinement);\\n \\n private:\\n void setup_dofs();\\n \\n void initialize_system();\\n \\n void assemble(const bool initial_step, const bool assemble_matrix);\\n \\n void assemble_system(const bool initial_step);\\n \\n void assemble_rhs(const bool initial_step);\\n \\n void solve(const bool initial_step);\\n \\n void refine_mesh();\\n \\n void process_solution(unsigned int refinement);\\n \\n void output_results(const unsigned int refinement_cycle) const;\\n \\n void newton_iteration(const double       tolerance,\\n const unsigned int max_n_line_searches,\\n const unsigned int max_n_refinements,\\n const bool         is_initial_step,\\n const bool         output_result);\\n \\n void compute_initial_guess(double step_size);\\n \\n double                               viscosity;\\n double                               gamma;\\n const unsigned int                   degree;\\n    std::vector<types::global_dof_index> dofs_per_block;\\n \\n Triangulation<dim> triangulation;\\n const FESystem<dim> fe;\\n DoFHandler<dim>     dof_handler;\\n \\n AffineConstraints<double> zero_constraints;\\n AffineConstraints<double> nonzero_constraints;\\n \\n BlockSparsityPattern      sparsity_pattern;\\n BlockSparseMatrix<double> system_matrix;\\n SparseMatrix<double>      pressure_mass_matrix;\\n \\n BlockVector<double> present_solution;\\n BlockVector<double> newton_update;\\n BlockVector<double> system_rhs;\\n BlockVector<double> evaluation_point;\\n  };\\n \\n \\n template <int dim>\\n class BoundaryValues : public Function<dim>\\n  {\\n public:\\n    BoundaryValues()\\n      : Function<dim>(dim + 1)\\n    {}\\n virtual double value(const Point<dim>  &p,\\n const unsigned int component) const override;\\n  };\\n \\n template <int dim>\\n double BoundaryValues<dim>::value(const Point<dim>  &p,\\n const unsigned int component) const\\n {\\n Assert(component < this->n_components,\\n           ExcIndexRange(component, 0, this->n_components));\\n if (component == 0 && std::abs(p[dim - 1] - 1.0) < 1e-10)\\n return 1.0;\\n \\n return 0;\\n  }\\n \\n template <class PreconditionerMp>\\n class BlockSchurPreconditioner : public Subscriptor\\n  {\\n public:\\n    BlockSchurPreconditioner(double                           gamma,\\n double                           viscosity,\\n const BlockSparseMatrix<double> &S,\\n const SparseMatrix<double>      &P,\\n const PreconditionerMp          &Mppreconditioner);\\n \\n void vmult(BlockVector<double> &dst, const BlockVector<double> &src) const;\\n \\n private:\\n const double gamma;\\n const double                     viscosity;\\n const BlockSparseMatrix<double> &stokes_matrix;\\n const SparseMatrix<double>      &pressure_mass_matrix;\\n const PreconditionerMp          &mp_preconditioner;\\n SparseDirectUMFPACK              A_inverse;\\n  };\\n \\n \\n template <class PreconditionerMp>\\n  BlockSchurPreconditioner<PreconditionerMp>::BlockSchurPreconditioner(\\n double                           gamma,\\n double                           viscosity,\\n const BlockSparseMatrix<double> &S,\\n const SparseMatrix<double>      &P,\\n const PreconditionerMp          &Mppreconditioner)\\n    : gamma(gamma)\\n    , viscosity(viscosity)\\n    , stokes_matrix(S)\\n    , pressure_mass_matrix(P)\\n    , mp_preconditioner(Mppreconditioner)\\n  {\\n    A_inverse.initialize(stokes_matrix.block(0, 0));\\n  }\\n \\n template <class PreconditionerMp>\\n void BlockSchurPreconditioner<PreconditionerMp>::vmult(\\n BlockVector<double>       &dst,\\n const BlockVector<double> &src) const\\n {\\n Vector<double> utmp(src.block(0));\\n \\n    {\\n SolverControl solver_control(1000, 1e-6 * src.block(1).l2_norm());\\n SolverCG<Vector<double>> cg(solver_control);\\n \\n      dst.block(1) = 0.0;\\n      cg.solve(pressure_mass_matrix,\\n               dst.block(1),\\n               src.block(1),\\n               mp_preconditioner);\\n      dst.block(1) *= -(viscosity + gamma);\\n    }\\n \\n    {\\n      stokes_matrix.block(0, 1).vmult(utmp, dst.block(1));\\n      utmp *= -1.0;\\n      utmp += src.block(0);\\n    }\\n \\n    A_inverse.vmult(dst.block(0), utmp);\\n  }\\n \\n template <int dim>\\n  StationaryNavierStokes<dim>::StationaryNavierStokes(const unsigned int degree)\\n    : viscosity(1.0 / 7500.0)\\n    , gamma(1.0)\\n    , degree(degree)\\n    , triangulation(Triangulation<dim>::maximum_smoothing)\\n    , fe(FE_Q<dim>(degree + 1) ^ dim, FE_Q<dim>(degree))\\n    , dof_handler(triangulation)\\n  {}\\n \\n template <int dim>\\n void StationaryNavierStokes<dim>::setup_dofs()\\n  {\\n    system_matrix.clear();\\n    pressure_mass_matrix.clear();\\n \\n    dof_handler.distribute_dofs(fe);\\n \\n    std::vector<unsigned int> block_component(dim + 1, 0);\\n    block_component[dim] = 1;\\n DoFRenumbering::component_wise(dof_handler, block_component);\\n \\n    dofs_per_block =\\n DoFTools::count_dofs_per_fe_block(dof_handler, block_component);\\n unsigned int dof_u = dofs_per_block[0];\\n unsigned int dof_p = dofs_per_block[1];\\n \\n const FEValuesExtractors::Vector velocities(0);\\n    {\\n      nonzero_constraints.clear();\\n \\n DoFTools::make_hanging_node_constraints(dof_handler, nonzero_constraints);\\n VectorTools::interpolate_boundary_values(dof_handler,\\n                                               0,\\n                                               BoundaryValues<dim>(),\\n                                               nonzero_constraints,\\n                                               fe.component_mask(velocities));\\n    }\\n    nonzero_constraints.close();\\n \\n    {\\n      zero_constraints.clear();\\n \\n DoFTools::make_hanging_node_constraints(dof_handler, zero_constraints);\\n VectorTools::interpolate_boundary_values(dof_handler,\\n                                               0,\\n Functions::ZeroFunction<dim>(\\n                                                 dim + 1),\\n                                               zero_constraints,\\n                                               fe.component_mask(velocities));\\n    }\\n    zero_constraints.close();\\n \\n    std::cout << \\\"Number of active cells: \\\" << triangulation.n_active_cells()\\n              << std::endl\\n              << \\\"Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n              << \\\" (\\\" << dof_u << \\\" + \\\" << dof_p << ')' << std::endl;\\n  }\\n \\n template <int dim>\\n void StationaryNavierStokes<dim>::initialize_system()\\n  {\\n    {\\n BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block);\\n DoFTools::make_sparsity_pattern(dof_handler, dsp, nonzero_constraints);\\n      sparsity_pattern.copy_from(dsp);\\n    }\\n \\n    system_matrix.reinit(sparsity_pattern);\\n \\n    present_solution.reinit(dofs_per_block);\\n    newton_update.reinit(dofs_per_block);\\n    system_rhs.reinit(dofs_per_block);\\n  }\\n \\n template <int dim>\\n void StationaryNavierStokes<dim>::assemble(const bool initial_step,\\n const bool assemble_matrix)\\n  {\\n if (assemble_matrix)\\n      system_matrix = 0;\\n \\n    system_rhs = 0;\\n \\n const QGauss<dim> quadrature_formula(degree + 2);\\n \\n FEValues<dim> fe_values(fe,\\n                            quadrature_formula,\\n update_values | update_quadrature_points |\\n update_JxW_values | update_gradients);\\n \\n const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n const unsigned int n_q_points    = quadrature_formula.size();\\n \\n const FEValuesExtractors::Vector velocities(0);\\n const FEValuesExtractors::Scalar pressure(dim);\\n \\n FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);\\n Vector<double>     local_rhs(dofs_per_cell);\\n \\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n \\n    std::vector<Tensor<1, dim>> present_velocity_values(n_q_points);\\n    std::vector<Tensor<2, dim>> present_velocity_gradients(n_q_points);\\n    std::vector<double>         present_pressure_values(n_q_points);\\n \\n    std::vector<double>         div_phi_u(dofs_per_cell);\\n    std::vector<Tensor<1, dim>> phi_u(dofs_per_cell);\\n    std::vector<Tensor<2, dim>> grad_phi_u(dofs_per_cell);\\n    std::vector<double>         phi_p(dofs_per_cell);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n        fe_values.reinit(cell);\\n \\n        local_matrix = 0;\\n        local_rhs    = 0;\\n \\n        fe_values[velocities].get_function_values(evaluation_point,\\n                                                  present_velocity_values);\\n \\n        fe_values[velocities].get_function_gradients(\\n          evaluation_point, present_velocity_gradients);\\n \\n        fe_values[pressure].get_function_values(evaluation_point,\\n                                                present_pressure_values);\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n          {\\n for (unsigned int k = 0; k < dofs_per_cell; ++k)\\n              {\\n                div_phi_u[k]  = fe_values[velocities].divergence(k, q);\\n                grad_phi_u[k] = fe_values[velocities].gradient(k, q);\\n                phi_u[k]      = fe_values[velocities].value(k, q);\\n                phi_p[k]      = fe_values[pressure].value(k, q);\\n              }\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n              {\\n if (assemble_matrix)\\n                  {\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n                      {\\n                        local_matrix(i, j) +=\\n                          (viscosity *\\n                             scalar_product(grad_phi_u[i], grad_phi_u[j]) +\\n                           phi_u[i] *\\n                             (present_velocity_gradients[q] * phi_u[j]) +\\n                           phi_u[i] *\\n                             (grad_phi_u[j] * present_velocity_values[q]) -\\n                           div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j] +\\n gamma * div_phi_u[i] * div_phi_u[j] +\\n                           phi_p[i] * phi_p[j]) *\\n                          fe_values.JxW(q);\\n                      }\\n                  }\\n \\n double present_velocity_divergence =\\n trace(present_velocity_gradients[q]);\\n                local_rhs(i) +=\\n                  (-viscosity * scalar_product(grad_phi_u[i],\\n                                               present_velocity_gradients[q]) -\\n                   phi_u[i] * (present_velocity_gradients[q] *\\n                               present_velocity_values[q]) +\\n                   div_phi_u[i] * present_pressure_values[q] +\\n                   phi_p[i] * present_velocity_divergence -\\n                   gamma * div_phi_u[i] * present_velocity_divergence) *\\n                  fe_values.JxW(q);\\n              }\\n          }\\n \\n        cell->get_dof_indices(local_dof_indices);\\n \\n const AffineConstraints<double> &constraints_used =\\n          initial_step ? nonzero_constraints : zero_constraints;\\n \\n if (assemble_matrix)\\n          {\\n            constraints_used.distribute_local_to_global(local_matrix,\\n                                                        local_rhs,\\n                                                        local_dof_indices,\\n                                                        system_matrix,\\n                                                        system_rhs);\\n          }\\n else\\n          {\\n            constraints_used.distribute_local_to_global(local_rhs,\\n                                                        local_dof_indices,\\n                                                        system_rhs);\\n          }\\n      }\\n \\n if (assemble_matrix)\\n      {\\n        pressure_mass_matrix.reinit(sparsity_pattern.block(1, 1));\\n        pressure_mass_matrix.copy_from(system_matrix.block(1, 1));\\n \\n        system_matrix.block(1, 1) = 0;\\n      }\\n  }\\n \\n template <int dim>\\n void StationaryNavierStokes<dim>::assemble_system(const bool initial_step)\\n  {\\n assemble(initial_step, true);\\n  }\\n \\n template <int dim>\\n void StationaryNavierStokes<dim>::assemble_rhs(const bool initial_step)\\n  {\\n assemble(initial_step, false);\\n  }\\n \\n template <int dim>\\n void StationaryNavierStokes<dim>::solve(const bool initial_step)\\n  {\\n const AffineConstraints<double> &constraints_used =\\n      initial_step ? nonzero_constraints : zero_constraints;\\n \\n SolverControl solver_control(system_matrix.m(),\\n                                 1e-4 * system_rhs.l2_norm(),\\n true);\\n \\n SolverFGMRES<BlockVector<double>> gmres(solver_control);\\n SparseILU<double>                 pmass_preconditioner;\\n    pmass_preconditioner.initialize(pressure_mass_matrix,\\n SparseILU<double>::AdditionalData());\\n \\n const BlockSchurPreconditioner<SparseILU<double>> preconditioner(\\n      gamma,\\n      viscosity,\\n      system_matrix,\\n      pressure_mass_matrix,\\n      pmass_preconditioner);\\n \\n    gmres.solve(system_matrix, newton_update, system_rhs, preconditioner);\\n    std::cout << \\\"FGMRES steps: \\\" << solver_control.last_step() << std::endl;\\n \\n    constraints_used.distribute(newton_update);\\n  }\\n \\n template <int dim>\\n void StationaryNavierStokes<dim>::refine_mesh()\\n  {\\n Vector<float> estimated_error_per_cell(triangulation.n_active_cells());\\n const FEValuesExtractors::Vector velocity(0);\\n KellyErrorEstimator<dim>::estimate(\\n      dof_handler,\\n QGauss<dim - 1>(degree + 1),\\n      std::map<types::boundary_id, const Function<dim> *>(),\\n      present_solution,\\n      estimated_error_per_cell,\\n      fe.component_mask(velocity));\\n \\n GridRefinement::refine_and_coarsen_fixed_number(triangulation,\\n                                                    estimated_error_per_cell,\\n                                                    0.3,\\n                                                    0.0);\\n \\n triangulation.prepare_coarsening_and_refinement();\\n SolutionTransfer<dim, BlockVector<double>> solution_transfer(dof_handler);\\n    solution_transfer.prepare_for_coarsening_and_refinement(present_solution);\\n triangulation.execute_coarsening_and_refinement();\\n \\n    setup_dofs();\\n \\n BlockVector<double> tmp(dofs_per_block);\\n \\n    solution_transfer.interpolate(present_solution, tmp);\\n    nonzero_constraints.distribute(tmp);\\n \\n    initialize_system();\\n    present_solution = tmp;\\n  }\\n \\n template <int dim>\\n void StationaryNavierStokes<dim>::newton_iteration(\\n const double       tolerance,\\n const unsigned int max_n_line_searches,\\n const unsigned int max_n_refinements,\\n const bool         is_initial_step,\\n const bool         output_result)\\n  {\\n bool first_step = is_initial_step;\\n \\n for (unsigned int refinement_n = 0; refinement_n < max_n_refinements + 1;\\n         ++refinement_n)\\n      {\\n unsigned int line_search_n = 0;\\n double       last_res      = 1.0;\\n double       current_res   = 1.0;\\n        std::cout << \\\"grid refinements: \\\" << refinement_n << std::endl\\n                  << \\\"viscosity: \\\" << viscosity << std::endl;\\n \\n while ((first_step || (current_res > tolerance)) &&\\n               line_search_n < max_n_line_searches)\\n          {\\n if (first_step)\\n              {\\n                setup_dofs();\\n                initialize_system();\\n                evaluation_point = present_solution;\\n                assemble_system(first_step);\\n                solve(first_step);\\n                present_solution = newton_update;\\n                nonzero_constraints.distribute(present_solution);\\n                first_step       = false;\\n                evaluation_point = present_solution;\\n                assemble_rhs(first_step);\\n                current_res = system_rhs.l2_norm();\\n                std::cout << \\\"The residual of initial guess is \\\" << current_res\\n                          << std::endl;\\n                last_res = current_res;\\n              }\\n else\\n              {\\n                evaluation_point = present_solution;\\n                assemble_system(first_step);\\n                solve(first_step);\\n \\n for (double alpha = 1.0; alpha > 1e-5; alpha *= 0.5)\\n                  {\\n                    evaluation_point = present_solution;\\n                    evaluation_point.add(alpha, newton_update);\\n                    nonzero_constraints.distribute(evaluation_point);\\n                    assemble_rhs(first_step);\\n                    current_res = system_rhs.l2_norm();\\n                    std::cout << \\\"  alpha: \\\" << std::setw(10) << alpha\\n                              << std::setw(0) << \\\"  residual: \\\" << current_res\\n                              << std::endl;\\n if (current_res < last_res)\\n break;\\n                  }\\n                {\\n                  present_solution = evaluation_point;\\n                  std::cout << \\\"  number of line searches: \\\" << line_search_n\\n                            << \\\"  residual: \\\" << current_res << std::endl;\\n                  last_res = current_res;\\n                }\\n                ++line_search_n;\\n              }\\n \\n if (output_result)\\n              {\\n                output_results(max_n_line_searches * refinement_n +\\n                               line_search_n);\\n \\n if (current_res <= tolerance)\\n                  process_solution(refinement_n);\\n              }\\n          }\\n \\n if (refinement_n < max_n_refinements)\\n          {\\n            refine_mesh();\\n          }\\n      }\\n  }\\n \\n template <int dim>\\n void StationaryNavierStokes<dim>::compute_initial_guess(double step_size)\\n  {\\n const double target_Re = 1.0 / viscosity;\\n \\n bool is_initial_step = true;\\n \\n for (double Re = 1000.0; Re < target_Re;\\n         Re        = std::min(Re + step_size, target_Re))\\n      {\\n        viscosity = 1.0 / Re;\\n        std::cout << \\\"Searching for initial guess with Re = \\\" << Re\\n                  << std::endl;\\n        newton_iteration(1e-12, 50, 0, is_initial_step, false);\\n        is_initial_step = false;\\n      }\\n  }\\n \\n template <int dim>\\n void StationaryNavierStokes<dim>::output_results(\\n const unsigned int output_index) const\\n {\\n    std::vector<std::string> solution_names(dim, \\\"velocity\\\");\\n    solution_names.emplace_back(\\\"pressure\\\");\\n \\n    std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n      data_component_interpretation(\\n        dim, DataComponentInterpretation::component_is_part_of_vector);\\n    data_component_interpretation.push_back(\\n DataComponentInterpretation::component_is_scalar);\\n DataOut<dim> data_out;\\n    data_out.attach_dof_handler(dof_handler);\\n    data_out.add_data_vector(present_solution,\\n                             solution_names,\\n DataOut<dim>::type_dof_data,\\n                             data_component_interpretation);\\n    data_out.build_patches();\\n \\n    std::ofstream output(std::to_string(1.0 / viscosity) + \\\"-solution-\\\" +\\n Utilities::int_to_string(output_index, 4) + \\\".vtk\\\");\\n    data_out.write_vtk(output);\\n  }\\n \\n template <int dim>\\n void StationaryNavierStokes<dim>::process_solution(unsigned int refinement)\\n  {\\n    std::ofstream f(std::to_string(1.0 / viscosity) + \\\"-line-\\\" +\\n                    std::to_string(refinement) + \\\".txt\\\");\\n    f << \\\"# y u_x u_y\\\" << std::endl;\\n \\n Point<dim> p;\\n    p[0] = 0.5;\\n    p[1] = 0.5;\\n \\n    f << std::scientific;\\n \\n for (unsigned int i = 0; i <= 100; ++i)\\n      {\\n        p[dim - 1] = i / 100.0;\\n \\n Vector<double> tmp_vector(dim + 1);\\n VectorTools::point_value(dof_handler, present_solution, p, tmp_vector);\\n        f << p[dim - 1];\\n \\n for (int j = 0; j < dim; ++j)\\n          f << ' ' << tmp_vector(j);\\n        f << std::endl;\\n      }\\n  }\\n \\n template <int dim>\\n void StationaryNavierStokes<dim>::run(const unsigned int refinement)\\n  {\\n GridGenerator::hyper_cube(triangulation);\\n triangulation.refine_global(5);\\n \\n const double Re = 1.0 / viscosity;\\n \\n if (Re > 1000.0)\\n      {\\n        std::cout << \\\"Searching for initial guess ...\\\" << std::endl;\\n const double step_size = 2000.0;\\n        compute_initial_guess(step_size);\\n        std::cout << \\\"Found initial guess.\\\" << std::endl;\\n        std::cout << \\\"Computing solution with target Re = \\\" << Re << std::endl;\\n        viscosity = 1.0 / Re;\\n        newton_iteration(1e-12, 50, refinement, false, true);\\n      }\\n else\\n      {\\n \\n        newton_iteration(1e-12, 50, refinement, true, true);\\n      }\\n  }\\n} // namespace Step57\\n \\nint main()\\n{\\n try\\n    {\\n using namespace Step57;\\n \\n      StationaryNavierStokes<2> flow(/* degree = */ 1);\\n      flow.run(4);\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n return 0;\\n}\\naffine_constraints.h\\nblock_sparse_matrix.h\\nblock_vector.h\\nAffineConstraints::distribute_local_to_globalvoid distribute_local_to_global(const InVector &local_vector, const std::vector< size_type > &local_dof_indices, OutVector &global_vector) constDefinition affine_constraints.h:2651\\nAffineConstraints::distributevoid distribute(VectorType &vec) const\\nBlockVectorBase::blockBlockType & block(const unsigned int i)\\nDataOutInterface::write_vtkvoid write_vtk(std::ostream &out) constDefinition data_out_base.cc:7681\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nparallel::distributed::Triangulation::clearvirtual void clear() overrideDefinition tria.cc:1864\\ndof_handler.h\\ndof_renumbering.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nerror_estimator.h\\nfe_values.h\\nfe_q.h\\nfe_system.h\\nfull_matrix.h\\nfunction.h\\ngrid_refinement.h\\ntria.h\\ngrid_generator.h\\ngrid_tools.h\\nutilities.h\\nPhysics::Elasticity::Kinematics::eSymmetricTensor< 2, dim, Number > e(const Tensor< 2, dim, Number > &F)\\ninternal::QGaussLobatto::gammalong double gamma(const unsigned int n)Definition quadrature_lib.cc:103\\ninternal::EvaluatorQuantity::value@ value\\ndata_out.h\\nsolution_transfer.h\\nprecondition.h\\nquadrature_lib.h\\nsolver_cg.h\\nsolver_gmres.h\\nsparse_direct.h\\nsparse_ilu.h\\ntensor.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"