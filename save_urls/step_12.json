"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_12.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-12 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-12 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-12 tutorial program\\n\\n\\nThis tutorial depends on step-7.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nOverview\\nThe equation\\nThe test problem\\n\\n The commented program\\n\\nEquation data\\nThe ScratchData and CopyData classes\\nThe AdvectionProblem class\\n\\nThe assemble_system function\\n\\nAll the rest\\n\\n\\n Results\\n\\nWhy use discontinuous elements\\nPossibilities for extensions\\n\\n The plain program\\n   \\n\\n\\n An example of an advection problem using the Discountinuous Galerkin method\\nOverview\\nThis example is devoted to the discontinuous Galerkin method, or in short, the DG method. It includes the following topics. \\n\\nDiscretization of the linear advection equation with the DG method. \\n\\nAssembling of jump terms and other expressions on the interface between cells using FEInterfaceValues. \\n\\nAssembling of the system matrix using the MeshWorker::mesh_loop(). \\n\\nThe particular concern of this program are the loops of DG methods. These turn out to be especially complex, primarily because for the face terms, we have to distinguish the cases of boundary, regular interior faces and interior faces with hanging nodes, respectively. The MeshWorker::mesh_loop() handles the complexity on iterating over cells and faces and allows specifying \\\"workers\\\" for the different cell and face terms. The integration of face terms itself, including on adaptively refined faces, is done using the FEInterfaceValues class.\\nThe equation\\nThe model problem solved in this example is the linear advection equation   \\n\\\\[\\n  \\\\nabla\\\\cdot \\\\left({\\\\mathbf \\\\beta} u\\\\right)=0 \\\\qquad\\\\mbox{in }\\\\Omega,\\n\\\\]\\n\\n subject to the boundary conditions   \\n\\\\[\\nu=g\\\\quad\\\\mbox{on }\\\\Gamma_-,\\n\\\\]\\n\\n on the inflow part \\\\(\\\\Gamma_-\\\\) of the boundary \\\\(\\\\Gamma=\\\\partial\\\\Omega\\\\) of the domain. Here, \\\\({\\\\mathbf \\\\beta}={\\\\mathbf \\\\beta}({\\\\bf x})\\\\) denotes a vector field, \\\\(u\\\\) the (scalar) solution function, \\\\(g\\\\) a boundary value function,   \\n\\\\[\\n\\\\Gamma_- \\\\dealcoloneq \\\\{{\\\\bf x}\\\\in\\\\Gamma, {\\\\mathbf \\\\beta}({\\\\bf x})\\\\cdot{\\\\bf n}({\\\\bf x})<0\\\\}\\n\\\\]\\n\\n the inflow part of the boundary of the domain and \\\\({\\\\bf n}\\\\) denotes the unit outward normal to the boundary \\\\(\\\\Gamma\\\\). This equation is the conservative version of the advection equation already considered in step-9 of this tutorial.\\nOn each cell \\\\(T\\\\), we multiply by a test function \\\\(v_h\\\\) from the left and integrate by parts to get:    \\n\\\\[\\n  \\\\left( v_h, \\\\nabla \\\\cdot (\\\\beta u_h) \\\\right)_T\\n= -(\\\\nabla v_h, \\\\beta u_h) + \\\\int_{\\\\partial T} v_h u_h \\\\beta \\\\cdot n\\n\\\\]\\n\\n When summing this expression over all cells \\\\(T\\\\), the boundary integral is done over all internal and external faces and as such there are three cases: \\n\\nouter boundary on the inflow (we replace \\\\(u_h\\\\) by given \\\\(g\\\\)): \\\\(\\\\int_{\\\\Gamma_-} v_h g \\\\beta \\\\cdot n\\\\) \\n\\nouter boundary on the outflow: \\\\(\\\\int_{\\\\Gamma_+} v_h u_h \\\\beta \\\\cdot n\\\\) \\n\\ninner faces (integral from two sides turns into jump, we use the upwind velocity): \\\\(\\\\int_F [v_h] u_h^{\\\\text{upwind}} \\\\beta \\\\cdot n\\\\) \\n\\nHere, the jump is defined as \\\\([v] = v^+ - v^-\\\\), where the superscripts refer to the left ('+') and right ('-') values at the face. The upwind value \\\\(u^{\\\\text{upwind}}\\\\) is defined to be \\\\(u^+\\\\) if \\\\(\\\\beta \\\\cdot n>0\\\\) and \\\\(u^-\\\\) otherwise.\\nAs a result, the mesh-dependent weak form reads:      \\n\\\\[\\n\\\\sum_{T\\\\in \\\\mathbb T_h} -\\\\bigl(\\\\nabla \\\\phi_i,{\\\\mathbf \\\\beta} \\\\phi_j \\\\bigr)_T +\\n\\\\sum_{F\\\\in\\\\mathbb F_h^i} \\\\bigl< [\\\\phi_i], \\\\phi_j^{upwind} \\\\beta\\\\cdot \\\\mathbf n\\\\bigr>_{F} +\\n\\\\bigl<\\\\phi_i, \\\\phi_j \\\\beta\\\\cdot \\\\mathbf n\\\\bigr>_{\\\\Gamma_+}\\n= -\\\\bigl<\\\\phi_i, g \\\\beta\\\\cdot\\\\mathbf n\\\\bigr>_{\\\\Gamma_-}.\\n\\\\]\\n\\n Here, \\\\(\\\\mathbb T_h\\\\) is the set of all active cells of the triangulation and \\\\(\\\\mathbb F_h^i\\\\) is the set of all active interior faces. This formulation is known as the upwind discontinuous Galerkin method.\\nIn order to implement this bilinear form, we need to compute the cell terms (first sum) using the usual way to achieve integration on a cell, the interface terms (second sum) using FEInterfaceValues, and the boundary terms (the other two terms). The summation of all those is done by MeshWorker::mesh_loop().\\nThe test problem\\nWe solve the advection equation on \\\\(\\\\Omega=[0,1]^2\\\\) with \\\\({\\\\mathbf \\\\beta}=\\\\frac{1}{|x|}(-x_2, x_1)\\\\) representing a circular counterclockwise flow field, and \\\\(g=1\\\\) on \\\\({\\\\bf x}\\\\in\\\\Gamma_-^1 := [0,0.5]\\\\times\\\\{0\\\\}\\\\) and \\\\(g=0\\\\) on  \\\\({\\\\bf x}\\\\in\\n\\\\Gamma_-\\\\setminus \\\\Gamma_-^1\\\\).\\nWe solve on a sequence of meshes by refining the mesh adaptively by estimating the norm of the gradient on each cell. After solving on each mesh, we output the solution in vtk format and compute the \\\\(L^\\\\infty\\\\) norm of the solution. As the exact solution is either 0 or 1, we can measure the magnitude of the overshoot of the numerical solution with this.\\n The commented program\\nThe first few files have already been covered in previous examples and will thus not be further commented on:\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_out.h>\\n\\u00a0 #include <deal.II/grid/grid_refinement.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 #include <deal.II/fe/mapping_q1.h>\\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/fe/mapping_q1.h>\\nHere the discontinuous finite elements are defined. They are used in the same way as all other finite elements, though \\u2013 as you have seen in previous tutorial programs \\u2013 there isn't much user interaction with finite element classes at all: they are passed to DoFHandler and FEValues objects, and that is about it.\\n\\u00a0 #include <deal.II/fe/fe_dgq.h>\\nThis header is needed for FEInterfaceValues to compute integrals on interfaces:\\n\\u00a0 #include <deal.II/fe/fe_interface_values.h>\\nWe are going to use a standard solver, called Generalized minimal residual method (GMRES). It is an iterative solver which is applicable to arbitrary invertible matrices. This, in combination with a block SSOR preconditioner (defined in precondition_block.h), that uses the special block matrix structure of system matrices arising from DG discretizations.\\n\\u00a0 #include <deal.II/lac/solver_gmres.h>\\n\\u00a0 #include <deal.II/lac/precondition_block.h>\\nWe are going to use gradients as refinement indicator.\\n\\u00a0 #include <deal.II/numerics/derivative_approximation.h>\\n\\u00a0 \\nFinally, the new include file for using the mesh_loop from the MeshWorker framework\\n\\u00a0 #include <deal.II/meshworker/mesh_loop.h>\\n\\u00a0 \\nLike in all programs, we finish this section by including the needed C++ headers and declaring we want to use objects in the dealii namespace without prefix.\\n\\u00a0 #include <iostream>\\n\\u00a0 #include <fstream>\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 namespace Step12\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n Equation data\\nFirst, we define a class describing the inhomogeneous boundary data. Since only its values are used, we implement value_list(), but leave all other functions of Function undefined.\\n\\u00a0   template <int dim>\\n\\u00a0   class BoundaryValues : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     BoundaryValues() = default;\\n\\u00a0     virtual void value_list(const std::vector<Point<dim>> &points,\\n\\u00a0                             std::vector<double>           &values,\\n\\u00a0                             const unsigned int component = 0) const override;\\n\\u00a0   };\\n\\u00a0 \\nFunctionDefinition function.h:152\\nFunction::value_listvirtual void value_list(const std::vector< Point< dim > > &points, std::vector< RangeNumberType > &values, const unsigned int component=0) const\\nPointDefinition point.h:111\\nGiven the flow direction, the inflow boundary of the unit square \\\\([0,1]^2\\\\) are the right and the lower boundaries. We prescribe discontinuous boundary values 1 and 0 on the x-axis and value 0 on the right boundary. The values of this function on the outflow boundaries will not be used within the DG scheme.\\n\\u00a0   template <int dim>\\n\\u00a0   void BoundaryValues<dim>::value_list(const std::vector<Point<dim>> &points,\\n\\u00a0                                        std::vector<double>           &values,\\n\\u00a0                                        const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     (void)component;\\n\\u00a0     AssertIndexRange(component, 1);\\n\\u00a0     AssertDimension(values.size(), points.size());\\n\\u00a0 \\n\\u00a0     for (unsigned int i = 0; i < values.size(); ++i)\\n\\u00a0       {\\n\\u00a0         if (points[i][0] < 0.5)\\n\\u00a0           values[i] = 1.;\\n\\u00a0         else\\n\\u00a0           values[i] = 0.;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nAssertDimension#define AssertDimension(dim1, dim2)Definition exceptions.h:1985\\nAssertIndexRange#define AssertIndexRange(index, range)Definition exceptions.h:2053\\nFinally, a function that computes and returns the wind field \\\\(\\\\beta=\\\\beta(\\\\mathbf x)\\\\). As explained in the introduction, we will use a rotational field around the origin in 2d. In 3d, we simply leave the \\\\(z\\\\)-component unset (i.e., at zero), whereas the function can not be used in 1d in its current implementation:\\n\\u00a0   template <int dim>\\n\\u00a0   Tensor<1, dim> beta(const Point<dim> &p)\\n\\u00a0   {\\n\\u00a0     Assert(dim >= 2, ExcNotImplemented());\\n\\u00a0 \\n\\u00a0     Tensor<1, dim> wind_field;\\n\\u00a0     wind_field[0] = -p[1];\\n\\u00a0     wind_field[1] = p[0];\\n\\u00a0 \\n\\u00a0     if (wind_field.norm() > 1e-10)\\n\\u00a0       wind_field /= wind_field.norm();\\n\\u00a0 \\n\\u00a0     return wind_field;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nTensorDefinition tensor.h:471\\nTensor::normnumbers::NumberTraits< Number >::real_type norm() const\\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\n The ScratchData and CopyData classes\\nThe following objects are the scratch and copy objects we use in the call to MeshWorker::mesh_loop(). The new object is the FEInterfaceValues object, that works similar to FEValues or FEFaceValues, except that it acts on an interface between two cells and allows us to assemble the interface terms in our weak form.\\n\\u00a0   template <int dim>\\n\\u00a0   struct ScratchData\\n\\u00a0   {\\n\\u00a0     ScratchData(const Mapping<dim>        &mapping,\\n\\u00a0                 const FiniteElement<dim>  &fe,\\n\\u00a0                 const Quadrature<dim>     &quadrature,\\n\\u00a0                 const Quadrature<dim - 1> &quadrature_face,\\n\\u00a0                 const UpdateFlags          update_flags = update_values |\\n\\u00a0                                                  update_gradients |\\n\\u00a0                                                  update_quadrature_points |\\n\\u00a0                                                  update_JxW_values,\\n\\u00a0                 const UpdateFlags interface_update_flags =\\n\\u00a0                   update_values | update_gradients | update_quadrature_points |\\n\\u00a0                   update_JxW_values | update_normal_vectors)\\n\\u00a0       : fe_values(mapping, fe, quadrature, update_flags)\\n\\u00a0       , fe_interface_values(mapping,\\n\\u00a0                             fe,\\n\\u00a0                             quadrature_face,\\n\\u00a0                             interface_update_flags)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     ScratchData(const ScratchData<dim> &scratch_data)\\n\\u00a0       : fe_values(scratch_data.fe_values.get_mapping(),\\n\\u00a0                   scratch_data.fe_values.get_fe(),\\n\\u00a0                   scratch_data.fe_values.get_quadrature(),\\n\\u00a0                   scratch_data.fe_values.get_update_flags())\\n\\u00a0       , fe_interface_values(scratch_data.fe_interface_values.get_mapping(),\\n\\u00a0                             scratch_data.fe_interface_values.get_fe(),\\n\\u00a0                             scratch_data.fe_interface_values.get_quadrature(),\\n\\u00a0                             scratch_data.fe_interface_values.get_update_flags())\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     FEValues<dim>          fe_values;\\n\\u00a0     FEInterfaceValues<dim> fe_interface_values;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   struct CopyDataFace\\n\\u00a0   {\\n\\u00a0     FullMatrix<double>                   cell_matrix;\\n\\u00a0     std::vector<types::global_dof_index> joint_dof_indices;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   struct CopyData\\n\\u00a0   {\\n\\u00a0     FullMatrix<double> cell_matrix;\\n\\u00a0     Vector<double>                       cell_rhs;\\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices;\\n\\u00a0     std::vector<CopyDataFace>            face_data;\\n\\u00a0 \\n\\u00a0     template <class Iterator>\\n\\u00a0     void reinit(const Iterator &cell, unsigned int dofs_per_cell)\\n\\u00a0     {\\n\\u00a0       cell_matrix.reinit(dofs_per_cell, dofs_per_cell);\\n\\u00a0       cell_rhs.reinit(dofs_per_cell);\\n\\u00a0 \\n\\u00a0       local_dof_indices.resize(dofs_per_cell);\\n\\u00a0       cell->get_dof_indices(local_dof_indices);\\n\\u00a0     }\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\nFEInterfaceValuesDefinition fe_interface_values.h:1277\\nFEValuesDefinition fe_values.h:63\\nFiniteElementDefinition fe.h:655\\nFullMatrixDefinition full_matrix.h:79\\nMappingAbstract base class for mapping classes.Definition mapping.h:318\\nQuadratureDefinition quadrature.h:123\\nVectorDefinition vector.h:120\\nUpdateFlagsUpdateFlagsDefinition fe_update_flags.h:64\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_normal_vectors@ update_normal_vectorsNormal vectors.Definition fe_update_flags.h:141\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\ninternal::reinitvoid reinit(MatrixBlock< MatrixType > &v, const BlockSparsityPattern &p)Definition matrix_block.h:617\\n The AdvectionProblem class\\nAfter this preparations, we proceed with the main class of this program, called AdvectionProblem.\\nThis should all be pretty familiar to you. Interesting details will only come up in the implementation of the assemble function.\\n\\u00a0   template <int dim>\\n\\u00a0   class AdvectionProblem\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     AdvectionProblem();\\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void setup_system();\\n\\u00a0     void assemble_system();\\n\\u00a0     void solve();\\n\\u00a0     void refine_grid();\\n\\u00a0     void output_results(const unsigned int cycle) const;\\n\\u00a0 \\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0     const MappingQ1<dim> mapping;\\n\\u00a0 \\nMappingQ1Definition mapping_q1.h:55\\nTriangulationDefinition tria.h:1323\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\nFurthermore we want to use DG elements.\\n\\u00a0     const FE_DGQ<dim> fe;\\n\\u00a0     DoFHandler<dim>   dof_handler;\\n\\u00a0 \\n\\u00a0     const QGauss<dim>     quadrature;\\n\\u00a0     const QGauss<dim - 1> quadrature_face;\\n\\u00a0 \\nDoFHandlerDefinition dof_handler.h:317\\nFE_DGQDefinition fe_dgq.h:112\\nQGaussDefinition quadrature_lib.h:40\\nThe next four members represent the linear system to be solved. system_matrix and right_hand_side are generated by assemble_system(), the solution is computed in solve(). The sparsity_pattern is used to determine the location of nonzero elements in system_matrix.\\n\\u00a0     SparsityPattern      sparsity_pattern;\\n\\u00a0     SparseMatrix<double> system_matrix;\\n\\u00a0 \\n\\u00a0     Vector<double> solution;\\n\\u00a0     Vector<double> right_hand_side;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\nSparseMatrixDefinition sparse_matrix.h:520\\nSparsityPatternDefinition sparsity_pattern.h:343\\nWe start with the constructor. The 1 in the constructor call of fe is the polynomial degree.\\n\\u00a0   template <int dim>\\n\\u00a0   AdvectionProblem<dim>::AdvectionProblem()\\n\\u00a0     : mapping()\\n\\u00a0     , fe(1)\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0     , quadrature(fe.tensor_degree() + 1)\\n\\u00a0     , quadrature_face(fe.tensor_degree() + 1)\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void AdvectionProblem<dim>::setup_system()\\n\\u00a0   {\\nIn the function that sets up the usual finite element data structures, we first need to distribute the DoFs.\\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0 \\nWe start by generating the sparsity pattern. To this end, we first fill an intermediate object of type DynamicSparsityPattern with the couplings appearing in the system. After building the pattern, this object is copied to sparsity_pattern and can be discarded.\\nTo build the sparsity pattern for DG discretizations, we can call the function analogue to DoFTools::make_sparsity_pattern, which is called DoFTools::make_flux_sparsity_pattern:\\n\\u00a0     DynamicSparsityPattern dsp(dof_handler.n_dofs());\\n\\u00a0     DoFTools::make_flux_sparsity_pattern(dof_handler, dsp);\\n\\u00a0     sparsity_pattern.copy_from(dsp);\\n\\u00a0 \\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nDoFTools::make_flux_sparsity_patternvoid make_flux_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern)Definition dof_tools_sparsity.cc:697\\nFinally, we set up the structure of all components of the linear system.\\n\\u00a0     system_matrix.reinit(sparsity_pattern);\\n\\u00a0     solution.reinit(dof_handler.n_dofs());\\n\\u00a0     right_hand_side.reinit(dof_handler.n_dofs());\\n\\u00a0   }\\n\\u00a0 \\n The assemble_system function\\nHere we see the major difference to assembling by hand. Instead of writing loops over cells and faces, the logic is contained in the call to MeshWorker::mesh_loop() and we only need to specify what should happen on each cell, each boundary face, and each interior face. These three tasks are handled by the lambda functions inside the function below.\\n\\u00a0   template <int dim>\\n\\u00a0   void AdvectionProblem<dim>::assemble_system()\\n\\u00a0   {\\n\\u00a0     using Iterator = typename DoFHandler<dim>::active_cell_iterator;\\n\\u00a0     const BoundaryValues<dim> boundary_function;\\n\\u00a0 \\nDoFHandler::active_cell_iteratortypename ActiveSelector::active_cell_iterator active_cell_iteratorDefinition dof_handler.h:440\\nThis is the function that will be executed for each cell.\\n\\u00a0     const auto cell_worker = [&](const Iterator   &cell,\\n\\u00a0                                  ScratchData<dim> &scratch_data,\\n\\u00a0                                  CopyData         &copy_data) {\\n\\u00a0       const unsigned int n_dofs =\\n\\u00a0         scratch_data.fe_values.get_fe().n_dofs_per_cell();\\n\\u00a0       copy_data.reinit(cell, n_dofs);\\n\\u00a0       scratch_data.fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0       const auto &q_points = scratch_data.fe_values.get_quadrature_points();\\n\\u00a0 \\n\\u00a0       const FEValues<dim>       &fe_v = scratch_data.fe_values;\\n\\u00a0       const std::vector<double> &JxW  = fe_v.get_JxW_values();\\n\\u00a0 \\nFEValuesBase::get_JxW_valuesconst std::vector< double > & get_JxW_values() const\\nWe solve a homogeneous equation, thus no right hand side shows up in the cell term. What's left is integrating the matrix entries.\\n\\u00a0       for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point)\\n\\u00a0         {\\n\\u00a0           auto beta_q = beta(q_points[point]);\\n\\u00a0           for (unsigned int i = 0; i < n_dofs; ++i)\\n\\u00a0             for (unsigned int j = 0; j < n_dofs; ++j)\\n\\u00a0               {\\n\\u00a0                 copy_data.cell_matrix(i, j) +=\\n\\u00a0                   -beta_q                      // -\\\\beta\\n\\u00a0                   * fe_v.shape_grad(i, point)  // \\\\nabla \\\\phi_i\\n\\u00a0                   * fe_v.shape_value(j, point) // \\\\phi_j\\n\\u00a0                   * JxW[point];                // dx\\n\\u00a0               }\\n\\u00a0         }\\n\\u00a0     };\\n\\u00a0 \\nThis is the function called for boundary faces and consists of a normal integration using FEFaceValues. New is the logic to decide if the term goes into the system matrix (outflow) or the right-hand side (inflow).\\n\\u00a0     const auto boundary_worker = [&](const Iterator     &cell,\\n\\u00a0                                      const unsigned int &face_no,\\n\\u00a0                                      ScratchData<dim>   &scratch_data,\\n\\u00a0                                      CopyData           &copy_data) {\\n\\u00a0       scratch_data.fe_interface_values.reinit(cell, face_no);\\n\\u00a0       const FEFaceValuesBase<dim> &fe_face =\\n\\u00a0         scratch_data.fe_interface_values.get_fe_face_values(0);\\n\\u00a0 \\n\\u00a0       const auto &q_points = fe_face.get_quadrature_points();\\n\\u00a0 \\n\\u00a0       const unsigned int n_facet_dofs = fe_face.get_fe().n_dofs_per_cell();\\n\\u00a0       const std::vector<double>         &JxW     = fe_face.get_JxW_values();\\n\\u00a0       const std::vector<Tensor<1, dim>> &normals = fe_face.get_normal_vectors();\\n\\u00a0 \\n\\u00a0       std::vector<double> g(q_points.size());\\n\\u00a0       boundary_function.value_list(q_points, g);\\n\\u00a0 \\n\\u00a0       for (unsigned int point = 0; point < q_points.size(); ++point)\\n\\u00a0         {\\n\\u00a0           const double beta_dot_n = beta(q_points[point]) * normals[point];\\n\\u00a0 \\n\\u00a0           if (beta_dot_n > 0)\\n\\u00a0             {\\n\\u00a0               for (unsigned int i = 0; i < n_facet_dofs; ++i)\\n\\u00a0                 for (unsigned int j = 0; j < n_facet_dofs; ++j)\\n\\u00a0                   copy_data.cell_matrix(i, j) +=\\n\\u00a0                     fe_face.shape_value(i, point)   // \\\\phi_i\\n\\u00a0                     * fe_face.shape_value(j, point) // \\\\phi_j\\n\\u00a0                     * beta_dot_n                    // \\\\beta . n\\n\\u00a0                     * JxW[point];                   // dx\\n\\u00a0             }\\n\\u00a0           else\\n\\u00a0             for (unsigned int i = 0; i < n_facet_dofs; ++i)\\n\\u00a0               copy_data.cell_rhs(i) += -fe_face.shape_value(i, point) // \\\\phi_i\\n\\u00a0                                        * g[point]                     // g\\n\\u00a0                                        * beta_dot_n  // \\\\beta . n\\n\\u00a0                                        * JxW[point]; // dx\\n\\u00a0         }\\n\\u00a0     };\\n\\u00a0 \\nFEFaceValuesBaseDefinition fe_values.h:202\\nFEValuesBase::get_quadrature_pointsconst std::vector< Point< spacedim > > & get_quadrature_points() const\\nThis is the function called on interior faces. The arguments specify cells, face and subface indices (for adaptive refinement). We just pass them along to the reinit() function of FEInterfaceValues.\\n\\u00a0     const auto face_worker = [&](const Iterator     &cell,\\n\\u00a0                                  const unsigned int &f,\\n\\u00a0                                  const unsigned int &sf,\\n\\u00a0                                  const Iterator     &ncell,\\n\\u00a0                                  const unsigned int &nf,\\n\\u00a0                                  const unsigned int &nsf,\\n\\u00a0                                  ScratchData<dim>   &scratch_data,\\n\\u00a0                                  CopyData           &copy_data) {\\n\\u00a0       FEInterfaceValues<dim> &fe_iv = scratch_data.fe_interface_values;\\n\\u00a0       fe_iv.reinit(cell, f, sf, ncell, nf, nsf);\\n\\u00a0       const auto &q_points = fe_iv.get_quadrature_points();\\n\\u00a0 \\n\\u00a0       copy_data.face_data.emplace_back();\\n\\u00a0       CopyDataFace &copy_data_face = copy_data.face_data.back();\\n\\u00a0 \\n\\u00a0       const unsigned int n_dofs        = fe_iv.n_current_interface_dofs();\\n\\u00a0       copy_data_face.joint_dof_indices = fe_iv.get_interface_dof_indices();\\n\\u00a0 \\n\\u00a0       copy_data_face.cell_matrix.reinit(n_dofs, n_dofs);\\n\\u00a0 \\n\\u00a0       const std::vector<double>         &JxW     = fe_iv.get_JxW_values();\\n\\u00a0       const std::vector<Tensor<1, dim>> &normals = fe_iv.get_normal_vectors();\\n\\u00a0 \\n\\u00a0       for (unsigned int qpoint = 0; qpoint < q_points.size(); ++qpoint)\\n\\u00a0         {\\n\\u00a0           const double beta_dot_n = beta(q_points[qpoint]) * normals[qpoint];\\n\\u00a0           for (unsigned int i = 0; i < n_dofs; ++i)\\n\\u00a0             for (unsigned int j = 0; j < n_dofs; ++j)\\n\\u00a0               copy_data_face.cell_matrix(i, j) +=\\n\\u00a0                 fe_iv.jump_in_shape_values(i, qpoint) // [\\\\phi_i]\\n\\u00a0                 *\\n\\u00a0                 fe_iv.shape_value((beta_dot_n > 0), j, qpoint) // phi_j^{upwind}\\n\\u00a0                 * beta_dot_n                                   // (\\\\beta . n)\\n\\u00a0                 * JxW[qpoint];                                 // dx\\n\\u00a0         }\\n\\u00a0     };\\n\\u00a0 \\nFEInterfaceValues::reinitvoid reinit(const CellIteratorType &cell, const unsigned int face_no, const unsigned int sub_face_no, const CellNeighborIteratorType &cell_neighbor, const unsigned int face_no_neighbor, const unsigned int sub_face_no_neighbor, const unsigned int q_index=numbers::invalid_unsigned_int, const unsigned int mapping_index=numbers::invalid_unsigned_int, const unsigned int fe_index=numbers::invalid_unsigned_int, const unsigned int fe_index_neighbor=numbers::invalid_unsigned_int)\\nThe following lambda function will handle copying the data from the cell and face assembly into the global matrix and right-hand side.\\nWhile we would not need an AffineConstraints object, because there are no hanging node constraints in DG discretizations, we use an empty object here as this allows us to use its copy_local_to_global functionality.\\n\\u00a0     const AffineConstraints<double> constraints;\\n\\u00a0 \\n\\u00a0     const auto copier = [&](const CopyData &c) {\\n\\u00a0       constraints.distribute_local_to_global(c.cell_matrix,\\n\\u00a0                                              c.cell_rhs,\\n\\u00a0                                              c.local_dof_indices,\\n\\u00a0                                              system_matrix,\\n\\u00a0                                              right_hand_side);\\n\\u00a0 \\n\\u00a0       for (const auto &cdf : c.face_data)\\n\\u00a0         {\\n\\u00a0           constraints.distribute_local_to_global(cdf.cell_matrix,\\n\\u00a0                                                  cdf.joint_dof_indices,\\n\\u00a0                                                  system_matrix);\\n\\u00a0         }\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     ScratchData<dim> scratch_data(mapping, fe, quadrature, quadrature_face);\\n\\u00a0     CopyData         copy_data;\\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nAffineConstraints::distribute_local_to_globalvoid distribute_local_to_global(const InVector &local_vector, const std::vector< size_type > &local_dof_indices, OutVector &global_vector) constDefinition affine_constraints.h:2651\\nHere, we finally handle the assembly. We pass in ScratchData and CopyData objects, the lambda functions from above, an specify that we want to assemble interior faces once.\\n\\u00a0     MeshWorker::mesh_loop(dof_handler.begin_active(),\\n\\u00a0                           dof_handler.end(),\\n\\u00a0                           cell_worker,\\n\\u00a0                           copier,\\n\\u00a0                           scratch_data,\\n\\u00a0                           copy_data,\\n\\u00a0                           MeshWorker::assemble_own_cells |\\n\\u00a0                             MeshWorker::assemble_boundary_faces |\\n\\u00a0                             MeshWorker::assemble_own_interior_faces_once,\\n\\u00a0                           boundary_worker,\\n\\u00a0                           face_worker);\\n\\u00a0   }\\n\\u00a0 \\nMeshWorker::mesh_loopvoid mesh_loop(const CellIteratorType &begin, const CellIteratorType &end, const CellWorkerFunctionType &cell_worker, const CopierType &copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const AssembleFlags flags=assemble_own_cells, const BoundaryWorkerFunctionType &boundary_worker=BoundaryWorkerFunctionType(), const FaceWorkerFunctionType &face_worker=FaceWorkerFunctionType(), const unsigned int queue_length=2 *MultithreadInfo::n_threads(), const unsigned int chunk_size=8)Definition mesh_loop.h:281\\nMeshWorker::assemble_boundary_faces@ assemble_boundary_facesDefinition assemble_flags.h:80\\nMeshWorker::assemble_own_cells@ assemble_own_cellsDefinition assemble_flags.h:49\\nMeshWorker::assemble_own_interior_faces_once@ assemble_own_interior_faces_onceDefinition assemble_flags.h:58\\n All the rest\\nFor this simple problem we use a standard iterative solver, called GMRES, that creates approximate solutions minimizing the residual in each iterations by adding a new basis vector to the Krylov subspace. This, in combination with a block SSOR preconditioner, that uses the special block matrix structure of system matrices arising from DG discretizations. The size of these blocks are the number of DoFs per cell. Here, we use a SSOR preconditioning as we have not renumbered the DoFs according to the flow field. If the DoFs are renumbered in the downstream direction of the flow, then a block Gauss-Seidel preconditioner (see the PreconditionBlockSOR class with relaxation=1) does a much better job.\\nWe create an additional data object for the GMRES solver to increase the maximum number of basis vectors of the Krylov subspace. When this number is reached the GMRES algorithm is restarted using the solution of the previous iteration as the starting approximation. The choice of the number of basis vectors is a trade-off between memory consumption and convergence speed, since a longer basis means minimization over a larger space.\\n\\u00a0   template <int dim>\\n\\u00a0   void AdvectionProblem<dim>::solve()\\n\\u00a0   {\\n\\u00a0     SolverControl solver_control(1000, 1e-6 * right_hand_side.l2_norm());\\n\\u00a0 \\n\\u00a0     SolverGMRES<Vector<double>>::AdditionalData additional_data;\\n\\u00a0     additional_data.max_basis_size = 100;\\n\\u00a0     SolverGMRES<Vector<double>> solver(solver_control, additional_data);\\n\\u00a0 \\nSolverControlDefinition solver_control.h:67\\nSolverGMRESDefinition solver_gmres.h:353\\nHere we create the preconditioner,\\n\\u00a0     PreconditionBlockSSOR<SparseMatrix<double>> preconditioner;\\n\\u00a0 \\nPreconditionBlockSSORDefinition precondition_block.h:821\\nthen assign the matrix to it and set the right block size:\\n\\u00a0     preconditioner.initialize(system_matrix, fe.n_dofs_per_cell());\\n\\u00a0 \\nAfter these preparations we are ready to start the linear solver.\\n\\u00a0     solver.solve(system_matrix, solution, right_hand_side, preconditioner);\\n\\u00a0 \\n\\u00a0     std::cout << \\\"  Solver converged in \\\" << solver_control.last_step()\\n\\u00a0               << \\\" iterations.\\\" << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nWe refine the grid according to a very simple refinement criterion, namely an approximation to the gradient of the solution. As here we consider the DG(1) method (i.e. we use piecewise bilinear shape functions) we could simply compute the gradients on each cell. But we do not want to base our refinement indicator on the gradients on each cell only, but want to base them also on jumps of the discontinuous solution function over faces between neighboring cells. The simplest way of doing that is to compute approximative gradients by difference quotients including the cell under consideration and its neighbors. This is done by the DerivativeApproximation class that computes the approximate gradients in a way similar to the GradientEstimation described in step-9 of this tutorial. In fact, the DerivativeApproximation class was developed following the GradientEstimation class of step-9. Relating to the discussion in step-9, here we consider \\\\(h^{1+d/2}|\\\\nabla_h u_h|\\\\). Furthermore we note that we do not consider approximate second derivatives because solutions to the linear advection equation are in general not in \\\\(H^2\\\\) but only in \\\\(H^1\\\\) (or, to be more precise: in \\\\(H^1_\\\\beta\\\\), i.e., the space of functions whose derivatives in direction \\\\(\\\\beta\\\\) are square integrable).\\n\\u00a0   template <int dim>\\n\\u00a0   void AdvectionProblem<dim>::refine_grid()\\n\\u00a0   {\\nThe DerivativeApproximation class computes the gradients to float precision. This is sufficient as they are approximate and serve as refinement indicators only.\\n\\u00a0     Vector<float> gradient_indicator(triangulation.n_active_cells());\\n\\u00a0 \\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nNow the approximate gradients are computed\\n\\u00a0     DerivativeApproximation::approximate_gradient(mapping,\\n\\u00a0                                                   dof_handler,\\n\\u00a0                                                   solution,\\n\\u00a0                                                   gradient_indicator);\\n\\u00a0 \\nDerivativeApproximation::approximate_gradientvoid approximate_gradient(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const InputVector &solution, Vector< float > &derivative_norm, const unsigned int component=0)Definition derivative_approximation.cc:1016\\nand they are cell-wise scaled by the factor \\\\(h^{1+d/2}\\\\)\\n\\u00a0     unsigned int cell_no = 0;\\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       gradient_indicator(cell_no++) *=\\n\\u00a0         std::pow(cell->diameter(), 1 + 1.0 * dim / 2);\\n\\u00a0 \\nstdSTL namespace.\\nFinally they serve as refinement indicator.\\n\\u00a0     GridRefinement::refine_and_coarsen_fixed_number(triangulation,\\n\\u00a0                                                     gradient_indicator,\\n\\u00a0                                                     0.3,\\n\\u00a0                                                     0.1);\\n\\u00a0 \\n\\u00a0     triangulation.execute_coarsening_and_refinement();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nparallel::distributed::Triangulation::execute_coarsening_and_refinementvirtual void execute_coarsening_and_refinement() overrideDefinition tria.cc:3320\\nGridRefinement::refine_and_coarsen_fixed_numbervoid refine_and_coarsen_fixed_number(Triangulation< dim, spacedim > &triangulation, const Vector< Number > &criteria, const double top_fraction_of_cells, const double bottom_fraction_of_cells, const unsigned int max_n_cells=std::numeric_limits< unsigned int >::max())Definition grid_refinement.cc:318\\nThe output of this program consists of a vtk file of the adaptively refined grids and the numerical solutions. Finally, we also compute the L-infinity norm of the solution using VectorTools::integrate_difference().\\n\\u00a0   template <int dim>\\n\\u00a0   void AdvectionProblem<dim>::output_results(const unsigned int cycle) const\\n\\u00a0   {\\n\\u00a0     const std::string filename = \\\"solution-\\\" + std::to_string(cycle) + \\\".vtk\\\";\\n\\u00a0     std::cout << \\\"  Writing solution to <\\\" << filename << '>' << std::endl;\\n\\u00a0     std::ofstream output(filename);\\n\\u00a0 \\n\\u00a0     DataOut<dim> data_out;\\n\\u00a0     data_out.attach_dof_handler(dof_handler);\\n\\u00a0     data_out.add_data_vector(solution, \\\"u\\\", DataOut<dim>::type_dof_data);\\n\\u00a0 \\n\\u00a0     data_out.build_patches(mapping);\\n\\u00a0 \\n\\u00a0     data_out.write_vtk(output);\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       Vector<float> values(triangulation.n_active_cells());\\n\\u00a0       VectorTools::integrate_difference(mapping,\\n\\u00a0                                         dof_handler,\\n\\u00a0                                         solution,\\n\\u00a0                                         Functions::ZeroFunction<dim>(),\\n\\u00a0                                         values,\\n\\u00a0                                         quadrature,\\n\\u00a0                                         VectorTools::Linfty_norm);\\n\\u00a0       const double l_infty =\\n\\u00a0         VectorTools::compute_global_error(triangulation,\\n\\u00a0                                           values,\\n\\u00a0                                           VectorTools::Linfty_norm);\\n\\u00a0       std::cout << \\\"  L-infinity norm: \\\" << l_infty << std::endl;\\n\\u00a0     }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nFunctions::ZeroFunctionDefinition function.h:510\\nVectorTools::compute_global_errordouble compute_global_error(const Triangulation< dim, spacedim > &tria, const InVector &cellwise_error, const NormType &norm, const double exponent=2.)\\nVectorTools::Linfty_norm@ Linfty_normDefinition vector_tools_common.h:147\\nVectorTools::integrate_differencevoid integrate_difference(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const ReadVector< Number > &fe_function, const Function< spacedim, Number > &exact_solution, OutVector &difference, const Quadrature< dim > &q, const NormType &norm, const Function< spacedim, double > *weight=nullptr, const double exponent=2.)\\nThe following run function is similar to previous examples.\\n\\u00a0   template <int dim>\\n\\u00a0   void AdvectionProblem<dim>::run()\\n\\u00a0   {\\n\\u00a0     for (unsigned int cycle = 0; cycle < 6; ++cycle)\\n\\u00a0       {\\n\\u00a0         std::cout << \\\"Cycle \\\" << cycle << std::endl;\\n\\u00a0 \\n\\u00a0         if (cycle == 0)\\n\\u00a0           {\\n\\u00a0             GridGenerator::hyper_cube(triangulation);\\n\\u00a0             triangulation.refine_global(3);\\n\\u00a0           }\\n\\u00a0         else\\n\\u00a0           refine_grid();\\n\\u00a0 \\n\\u00a0         std::cout << \\\"  Number of active cells:       \\\"\\n\\u00a0                   << triangulation.n_active_cells() << std::endl;\\n\\u00a0 \\n\\u00a0         setup_system();\\n\\u00a0 \\n\\u00a0         std::cout << \\\"  Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n\\u00a0                   << std::endl;\\n\\u00a0 \\n\\u00a0         assemble_system();\\n\\u00a0         solve();\\n\\u00a0 \\n\\u00a0         output_results(cycle);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 } // namespace Step12\\n\\u00a0 \\n\\u00a0 \\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nGridGenerator::hyper_cubevoid hyper_cube(Triangulation< dim, spacedim > &tria, const double left=0., const double right=1., const bool colorize=false)\\nThe following main function is similar to previous examples as well, and need not be commented on.\\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       Step12::AdvectionProblem<2> dgmethod;\\n\\u00a0       dgmethod.run();\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nThe output of this program consist of the console output and solutions in vtk format: Cycle 0\\n  Number of active cells:       64\\n  Number of degrees of freedom: 256\\n  Solver converged in 4 iterations.\\n  Writing solution to <solution-0.vtk>\\n  L-infinity norm: 1.09057\\nCycle 1\\n  Number of active cells:       112\\n  Number of degrees of freedom: 448\\n  Solver converged in 9 iterations.\\n  Writing solution to <solution-1.vtk>\\n  L-infinity norm: 1.10402\\nCycle 2\\n  Number of active cells:       214\\n  Number of degrees of freedom: 856\\n  Solver converged in 16 iterations.\\n  Writing solution to <solution-2.vtk>\\n  L-infinity norm: 1.09813\\nCycle 3\\n  Number of active cells:       415\\n  Number of degrees of freedom: 1660\\n  Solver converged in 26 iterations.\\n  Writing solution to <solution-3.vtk>\\n  L-infinity norm: 1.09579\\nCycle 4\\n  Number of active cells:       796\\n  Number of degrees of freedom: 3184\\n  Solver converged in 44 iterations.\\n  Writing solution to <solution-4.vtk>\\n  L-infinity norm: 1.09612\\nCycle 5\\n  Number of active cells:       1561\\n  Number of degrees of freedom: 6244\\n  Solver converged in 81 iterations.\\n  Writing solution to <solution-5.vtk>\\nWe show the solutions on the initial mesh, the mesh after two and after five adaptive refinement steps.\\n  \\nAnd finally we show a plot of a 3d computation.\\n\\n Why use discontinuous elements\\nIn this program we have used discontinuous elements. It is a legitimate question to ask why not simply use the normal, continuous ones. Of course, to everyone with a background in numerical methods, the answer is obvious: the continuous Galerkin (cG) method is not stable for the transport equation, unless one specifically adds stabilization terms. The DG method, however, is stable. Illustrating this with the current program is not very difficult; in fact, only the following minor modifications are necessary:\\nChange the element to FE_Q instead of FE_DGQ.\\nAdd handling of hanging node constraints in exactly the same way as step-6.\\nWe need a different solver; the direct solver in step-29 is a convenient choice. An experienced deal.II user will be able to do this in less than 10 minutes.\\n\\nWhile the 2d solution has been shown above, containing a number of small spikes at the interface that are, however, stable in height under mesh refinement, results look much different when using a continuous element:\\n\\n\\n0 \\u00a0   1 \\u00a0   \\n\\n2 \\u00a0   3 \\u00a0   \\n\\n4 \\u00a0   5 \\u00a0   \\n\\nIn refinement iteration 5, the image can't be plotted in a reasonable way any more as a 3d plot. We thus show a color plot with a range of \\\\([-1,2]\\\\) (the solution values of the exact solution lie in \\\\([0,1]\\\\), of course). In any case, it is clear that the continuous Galerkin solution exhibits oscillatory behavior that gets worse and worse as the mesh is refined more and more.\\nThere are a number of strategies to stabilize the cG method, if one wants to use continuous elements for some reason. Discussing these methods is beyond the scope of this tutorial program; an interested reader could, for example, take a look at step-31.\\n Possibilities for extensions\\nGiven that the exact solution is known in this case, one interesting avenue for further extensions would be to confirm the order of convergence for this program. In the current case, the solution is non-smooth, and so we can not expect to get a particularly high order of convergence, even if we used higher order elements. But even if the solution is smooth, the equation is not elliptic and so it is not immediately clear that we should obtain a convergence order that equals that of the optimal interpolation estimates (i.e. for example that we would get \\\\(h^3\\\\) convergence in the \\\\(L^2\\\\) norm by using quadratic elements).\\nIn fact, for hyperbolic equations, theoretical predictions often indicate that the best one can hope for is an order one half below the interpolation estimate. For example, for the streamline diffusion method (an alternative method to the DG method used here to stabilize the solution of the transport equation), one can prove that for elements of degree \\\\(p\\\\), the order of convergence is \\\\(p+\\\\frac 12\\\\) on arbitrary meshes. While the observed order is frequently \\\\(p+1\\\\) on uniformly refined meshes, one can construct so-called Peterson meshes on which the worse theoretical bound is actually attained. This should be relatively simple to verify, for example using the VectorTools::integrate_difference function.\\nA different direction is to observe that the solution of transport problems often has discontinuities and that therefore a mesh in which we bisect every cell in every coordinate direction may not be optimal. Rather, a better strategy would be to only cut cells in the direction parallel to the discontinuity. This is called anisotropic mesh refinement and is the subject of step-30.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2009 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Authors: Guido Kanschat, Texas A&M University, 2009\\n *          Timo Heister, Clemson University, 2019\\n */\\n \\n \\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/function.h>\\n#include <deal.II/lac/vector.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_out.h>\\n#include <deal.II/grid/grid_refinement.h>\\n#include <deal.II/fe/fe_values.h>\\n#include <deal.II/fe/mapping_q1.h>\\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/numerics/vector_tools.h>\\n#include <deal.II/dofs/dof_tools.h>\\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/fe/mapping_q1.h>\\n#include <deal.II/fe/fe_dgq.h>\\n#include <deal.II/fe/fe_interface_values.h>\\n#include <deal.II/lac/solver_gmres.h>\\n#include <deal.II/lac/precondition_block.h>\\n#include <deal.II/numerics/derivative_approximation.h>\\n \\n#include <deal.II/meshworker/mesh_loop.h>\\n \\n#include <iostream>\\n#include <fstream>\\n \\n \\nnamespace Step12\\n{\\n using namespace dealii;\\n \\n template <int dim>\\n class BoundaryValues : public Function<dim>\\n  {\\n public:\\n    BoundaryValues() = default;\\n virtual void value_list(const std::vector<Point<dim>> &points,\\n                            std::vector<double>           &values,\\n const unsigned int component = 0) const override;\\n  };\\n \\n template <int dim>\\n void BoundaryValues<dim>::value_list(const std::vector<Point<dim>> &points,\\n                                       std::vector<double>           &values,\\n const unsigned int component) const\\n {\\n    (void)component;\\n AssertIndexRange(component, 1);\\n AssertDimension(values.size(), points.size());\\n \\n for (unsigned int i = 0; i < values.size(); ++i)\\n      {\\n if (points[i][0] < 0.5)\\n          values[i] = 1.;\\n else\\n          values[i] = 0.;\\n      }\\n  }\\n \\n \\n template <int dim>\\n Tensor<1, dim> beta(const Point<dim> &p)\\n  {\\n Assert(dim >= 2, ExcNotImplemented());\\n \\n Tensor<1, dim> wind_field;\\n    wind_field[0] = -p[1];\\n    wind_field[1] = p[0];\\n \\n if (wind_field.norm() > 1e-10)\\n      wind_field /= wind_field.norm();\\n \\n return wind_field;\\n  }\\n \\n \\n \\n template <int dim>\\n struct ScratchData\\n  {\\n    ScratchData(const Mapping<dim>        &mapping,\\n const FiniteElement<dim>  &fe,\\n const Quadrature<dim>     &quadrature,\\n const Quadrature<dim - 1> &quadrature_face,\\n const UpdateFlags          update_flags = update_values |\\n update_gradients |\\n update_quadrature_points |\\n update_JxW_values,\\n const UpdateFlags interface_update_flags =\\n update_values | update_gradients | update_quadrature_points |\\n update_JxW_values | update_normal_vectors)\\n      : fe_values(mapping, fe, quadrature, update_flags)\\n      , fe_interface_values(mapping,\\n                            fe,\\n                            quadrature_face,\\n                            interface_update_flags)\\n    {}\\n \\n \\n    ScratchData(const ScratchData<dim> &scratch_data)\\n      : fe_values(scratch_data.fe_values.get_mapping(),\\n                  scratch_data.fe_values.get_fe(),\\n                  scratch_data.fe_values.get_quadrature(),\\n                  scratch_data.fe_values.get_update_flags())\\n      , fe_interface_values(scratch_data.fe_interface_values.get_mapping(),\\n                            scratch_data.fe_interface_values.get_fe(),\\n                            scratch_data.fe_interface_values.get_quadrature(),\\n                            scratch_data.fe_interface_values.get_update_flags())\\n    {}\\n \\n FEValues<dim>          fe_values;\\n FEInterfaceValues<dim> fe_interface_values;\\n  };\\n \\n \\n \\n struct CopyDataFace\\n  {\\n FullMatrix<double> cell_matrix;\\n    std::vector<types::global_dof_index> joint_dof_indices;\\n  };\\n \\n \\n \\n struct CopyData\\n  {\\n FullMatrix<double> cell_matrix;\\n Vector<double>                       cell_rhs;\\n    std::vector<types::global_dof_index> local_dof_indices;\\n    std::vector<CopyDataFace>            face_data;\\n \\n template <class Iterator>\\n void reinit(const Iterator &cell, unsigned int dofs_per_cell)\\n    {\\n cell_matrix.reinit(dofs_per_cell, dofs_per_cell);\\n      cell_rhs.reinit(dofs_per_cell);\\n \\n      local_dof_indices.resize(dofs_per_cell);\\n      cell->get_dof_indices(local_dof_indices);\\n    }\\n  };\\n \\n \\n template <int dim>\\n class AdvectionProblem\\n  {\\n public:\\n    AdvectionProblem();\\n void run();\\n \\n private:\\n void setup_system();\\n void assemble_system();\\n void solve();\\n void refine_grid();\\n void output_results(const unsigned int cycle) const;\\n \\n Triangulation<dim> triangulation;\\n const MappingQ1<dim> mapping;\\n \\n const FE_DGQ<dim> fe;\\n DoFHandler<dim>   dof_handler;\\n \\n const QGauss<dim>     quadrature;\\n const QGauss<dim - 1> quadrature_face;\\n \\n SparsityPattern      sparsity_pattern;\\n SparseMatrix<double> system_matrix;\\n \\n Vector<double> solution;\\n Vector<double> right_hand_side;\\n  };\\n \\n \\n template <int dim>\\n  AdvectionProblem<dim>::AdvectionProblem()\\n    : mapping()\\n    , fe(1)\\n    , dof_handler(triangulation)\\n    , quadrature(fe.tensor_degree() + 1)\\n    , quadrature_face(fe.tensor_degree() + 1)\\n  {}\\n \\n \\n template <int dim>\\n void AdvectionProblem<dim>::setup_system()\\n  {\\n    dof_handler.distribute_dofs(fe);\\n \\n \\n DynamicSparsityPattern dsp(dof_handler.n_dofs());\\n DoFTools::make_flux_sparsity_pattern(dof_handler, dsp);\\n    sparsity_pattern.copy_from(dsp);\\n \\n    system_matrix.reinit(sparsity_pattern);\\n    solution.reinit(dof_handler.n_dofs());\\n    right_hand_side.reinit(dof_handler.n_dofs());\\n  }\\n \\n \\n \\n template <int dim>\\n void AdvectionProblem<dim>::assemble_system()\\n  {\\n using Iterator = typename DoFHandler<dim>::active_cell_iterator;\\n const BoundaryValues<dim> boundary_function;\\n \\n const auto cell_worker = [&](const Iterator   &cell,\\n                                 ScratchData<dim> &scratch_data,\\n                                 CopyData         &copy_data) {\\n const unsigned int n_dofs =\\n        scratch_data.fe_values.get_fe().n_dofs_per_cell();\\n      copy_data.reinit(cell, n_dofs);\\n      scratch_data.fe_values.reinit(cell);\\n \\n const auto &q_points = scratch_data.fe_values.get_quadrature_points();\\n \\n const FEValues<dim>       &fe_v = scratch_data.fe_values;\\n const std::vector<double> &JxW  = fe_v.get_JxW_values();\\n \\n for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point)\\n        {\\n auto beta_q = beta(q_points[point]);\\n for (unsigned int i = 0; i < n_dofs; ++i)\\n for (unsigned int j = 0; j < n_dofs; ++j)\\n              {\\n                copy_data.cell_matrix(i, j) +=\\n                  -beta_q                      // -\\\\beta\\n                  * fe_v.shape_grad(i, point)  // \\\\nabla \\\\phi_i\\n                  * fe_v.shape_value(j, point) // \\\\phi_j\\n                  * JxW[point];                // dx\\n              }\\n        }\\n    };\\n \\n const auto boundary_worker = [&](const Iterator     &cell,\\n const unsigned int &face_no,\\n                                     ScratchData<dim>   &scratch_data,\\n                                     CopyData           &copy_data) {\\n      scratch_data.fe_interface_values.reinit(cell, face_no);\\n const FEFaceValuesBase<dim> &fe_face =\\n        scratch_data.fe_interface_values.get_fe_face_values(0);\\n \\n const auto &q_points = fe_face.get_quadrature_points();\\n \\n const unsigned int n_facet_dofs = fe_face.get_fe().n_dofs_per_cell();\\n const std::vector<double>         &JxW     = fe_face.get_JxW_values();\\n const std::vector<Tensor<1, dim>> &normals = fe_face.get_normal_vectors();\\n \\n      std::vector<double> g(q_points.size());\\n      boundary_function.value_list(q_points, g);\\n \\n for (unsigned int point = 0; point < q_points.size(); ++point)\\n        {\\n const double beta_dot_n = beta(q_points[point]) * normals[point];\\n \\n if (beta_dot_n > 0)\\n            {\\n for (unsigned int i = 0; i < n_facet_dofs; ++i)\\n for (unsigned int j = 0; j < n_facet_dofs; ++j)\\n                  copy_data.cell_matrix(i, j) +=\\n                    fe_face.shape_value(i, point)   // \\\\phi_i\\n                    * fe_face.shape_value(j, point) // \\\\phi_j\\n                    * beta_dot_n                    // \\\\beta . n\\n                    * JxW[point];                   // dx\\n            }\\n else\\n for (unsigned int i = 0; i < n_facet_dofs; ++i)\\n              copy_data.cell_rhs(i) += -fe_face.shape_value(i, point) // \\\\phi_i\\n                                       * g[point]                     // g\\n                                       * beta_dot_n  // \\\\beta . n\\n                                       * JxW[point]; // dx\\n        }\\n    };\\n \\n const auto face_worker = [&](const Iterator     &cell,\\n const unsigned int &f,\\n const unsigned int &sf,\\n const Iterator     &ncell,\\n const unsigned int &nf,\\n const unsigned int &nsf,\\n                                 ScratchData<dim>   &scratch_data,\\n                                 CopyData           &copy_data) {\\n FEInterfaceValues<dim> &fe_iv = scratch_data.fe_interface_values;\\n      fe_iv.reinit(cell, f, sf, ncell, nf, nsf);\\n const auto &q_points = fe_iv.get_quadrature_points();\\n \\n      copy_data.face_data.emplace_back();\\n      CopyDataFace &copy_data_face = copy_data.face_data.back();\\n \\n const unsigned int n_dofs        = fe_iv.n_current_interface_dofs();\\n      copy_data_face.joint_dof_indices = fe_iv.get_interface_dof_indices();\\n \\n      copy_data_face.cell_matrix.reinit(n_dofs, n_dofs);\\n \\n const std::vector<double>         &JxW     = fe_iv.get_JxW_values();\\n const std::vector<Tensor<1, dim>> &normals = fe_iv.get_normal_vectors();\\n \\n for (unsigned int qpoint = 0; qpoint < q_points.size(); ++qpoint)\\n        {\\n const double beta_dot_n = beta(q_points[qpoint]) * normals[qpoint];\\n for (unsigned int i = 0; i < n_dofs; ++i)\\n for (unsigned int j = 0; j < n_dofs; ++j)\\n              copy_data_face.cell_matrix(i, j) +=\\n                fe_iv.jump_in_shape_values(i, qpoint) // [\\\\phi_i]\\n                *\\n                fe_iv.shape_value((beta_dot_n > 0), j, qpoint) // phi_j^{upwind}\\n                * beta_dot_n                                   // (\\\\beta . n)\\n                * JxW[qpoint];                                 // dx\\n        }\\n    };\\n \\n const AffineConstraints<double> constraints;\\n \\n const auto copier = [&](const CopyData &c) {\\n      constraints.distribute_local_to_global(c.cell_matrix,\\n                                             c.cell_rhs,\\n                                             c.local_dof_indices,\\n                                             system_matrix,\\n                                             right_hand_side);\\n \\n for (const auto &cdf : c.face_data)\\n        {\\n          constraints.distribute_local_to_global(cdf.cell_matrix,\\n                                                 cdf.joint_dof_indices,\\n                                                 system_matrix);\\n        }\\n    };\\n \\n    ScratchData<dim> scratch_data(mapping, fe, quadrature, quadrature_face);\\n    CopyData         copy_data;\\n \\n MeshWorker::mesh_loop(dof_handler.begin_active(),\\n                          dof_handler.end(),\\n                          cell_worker,\\n                          copier,\\n                          scratch_data,\\n                          copy_data,\\n MeshWorker::assemble_own_cells |\\n MeshWorker::assemble_boundary_faces |\\n MeshWorker::assemble_own_interior_faces_once,\\n                          boundary_worker,\\n                          face_worker);\\n  }\\n \\n \\n template <int dim>\\n void AdvectionProblem<dim>::solve()\\n  {\\n SolverControl solver_control(1000, 1e-6 * right_hand_side.l2_norm());\\n \\n SolverGMRES<Vector<double>>::AdditionalData additional_data;\\n    additional_data.max_basis_size = 100;\\n SolverGMRES<Vector<double>> solver(solver_control, additional_data);\\n \\n PreconditionBlockSSOR<SparseMatrix<double>> preconditioner;\\n \\n    preconditioner.initialize(system_matrix, fe.n_dofs_per_cell());\\n \\n    solver.solve(system_matrix, solution, right_hand_side, preconditioner);\\n \\n    std::cout << \\\"  Solver converged in \\\" << solver_control.last_step()\\n              << \\\" iterations.\\\" << std::endl;\\n  }\\n \\n \\n template <int dim>\\n void AdvectionProblem<dim>::refine_grid()\\n  {\\n Vector<float> gradient_indicator(triangulation.n_active_cells());\\n \\n DerivativeApproximation::approximate_gradient(mapping,\\n                                                  dof_handler,\\n                                                  solution,\\n                                                  gradient_indicator);\\n \\n unsigned int cell_no = 0;\\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      gradient_indicator(cell_no++) *=\\n std::pow(cell->diameter(), 1 + 1.0 * dim / 2);\\n \\n GridRefinement::refine_and_coarsen_fixed_number(triangulation,\\n                                                    gradient_indicator,\\n                                                    0.3,\\n                                                    0.1);\\n \\n triangulation.execute_coarsening_and_refinement();\\n  }\\n \\n \\n template <int dim>\\n void AdvectionProblem<dim>::output_results(const unsigned int cycle) const\\n {\\n const std::string filename = \\\"solution-\\\" + std::to_string(cycle) + \\\".vtk\\\";\\n    std::cout << \\\"  Writing solution to <\\\" << filename << '>' << std::endl;\\n    std::ofstream output(filename);\\n \\n DataOut<dim> data_out;\\n    data_out.attach_dof_handler(dof_handler);\\n    data_out.add_data_vector(solution, \\\"u\\\", DataOut<dim>::type_dof_data);\\n \\n    data_out.build_patches(mapping);\\n \\n    data_out.write_vtk(output);\\n \\n    {\\n Vector<float> values(triangulation.n_active_cells());\\n VectorTools::integrate_difference(mapping,\\n                                        dof_handler,\\n                                        solution,\\n Functions::ZeroFunction<dim>(),\\n                                        values,\\n                                        quadrature,\\n VectorTools::Linfty_norm);\\n const double l_infty =\\n VectorTools::compute_global_error(triangulation,\\n                                          values,\\n VectorTools::Linfty_norm);\\n      std::cout << \\\"  L-infinity norm: \\\" << l_infty << std::endl;\\n    }\\n  }\\n \\n \\n template <int dim>\\n void AdvectionProblem<dim>::run()\\n  {\\n for (unsigned int cycle = 0; cycle < 6; ++cycle)\\n      {\\n        std::cout << \\\"Cycle \\\" << cycle << std::endl;\\n \\n if (cycle == 0)\\n          {\\n GridGenerator::hyper_cube(triangulation);\\n triangulation.refine_global(3);\\n          }\\n else\\n          refine_grid();\\n \\n        std::cout << \\\"  Number of active cells:       \\\"\\n                  << triangulation.n_active_cells() << std::endl;\\n \\n        setup_system();\\n \\n        std::cout << \\\"  Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n                  << std::endl;\\n \\n        assemble_system();\\n        solve();\\n \\n        output_results(cycle);\\n      }\\n  }\\n} // namespace Step12\\n \\n \\nint main()\\n{\\n try\\n    {\\n      Step12::AdvectionProblem<2> dgmethod;\\n      dgmethod.run();\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n \\n return 0;\\n}\\nDataOutInterface::write_vtkvoid write_vtk(std::ostream &out) constDefinition data_out_base.cc:7681\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nFEInterfaceValues::get_JxW_valuesconst std::vector< double > & get_JxW_values() const\\nFEInterfaceValues::n_current_interface_dofsunsigned n_current_interface_dofs() const\\nFEInterfaceValues::get_normal_vectorsconst std::vector< Tensor< 1, spacedim > > & get_normal_vectors() const\\nFEInterfaceValues::get_quadrature_pointsconst std::vector< Point< spacedim > > & get_quadrature_points() const\\nFEInterfaceValues::shape_valuedouble shape_value(const bool here_or_there, const unsigned int interface_dof_index, const unsigned int q_point, const unsigned int component=0) const\\nFEInterfaceValues::jump_in_shape_valuesdouble jump_in_shape_values(const unsigned int interface_dof_index, const unsigned int q_point, const unsigned int component=0) const\\nFEInterfaceValues::get_interface_dof_indicesstd::vector< types::global_dof_index > get_interface_dof_indices() const\\nFEValuesBase::n_quadrature_pointsconst unsigned int n_quadrature_pointsDefinition fe_values_base.h:174\\nFEValuesBase::get_normal_vectorsconst std::vector< Tensor< 1, spacedim > > & get_normal_vectors() constDefinition fe_values_base.cc:1298\\nFEValuesBase::shape_gradconst Tensor< 1, spacedim > & shape_grad(const unsigned int i, const unsigned int q_point) const\\nFEValuesBase::get_feconst FiniteElement< dim, spacedim > & get_fe() const\\nFEValuesBase::shape_valueconst double & shape_value(const unsigned int i, const unsigned int q_point) const\\nFiniteElementData::n_dofs_per_cellunsigned int n_dofs_per_cell() const\\nPreconditionBlock::initializevoid initialize(const MatrixType &A, const AdditionalData parameters)\\nVector::reinitvirtual void reinit(const size_type N, const bool omit_zeroing_entries=false)\\nderivative_approximation.h\\ndof_handler.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nfe_values.h\\nfe_dgq.h\\nfe_interface_values.h\\nfunction.h\\ngrid_refinement.h\\ntria.h\\ngrid_generator.h\\ngrid_out.h\\nmapping_q1.h\\nmesh_loop.h\\nGridTools::diameterdouble diameter(const Triangulation< dim, spacedim > &tria)Definition grid_tools_geometry.cc:43\\nOpenCASCADE::pointPoint< spacedim > point(const gp_Pnt &p, const double tolerance=1e-10)Definition utilities.cc:191\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\nstd::pow::VectorizedArray< Number, width > pow(const ::VectorizedArray< Number, width > &, const Number p)Definition vectorization.h:6885\\ndata_out.h\\nprecondition_block.h\\nquadrature_lib.h\\nsolver_gmres.h\\nsparse_matrix.h\\nvector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"