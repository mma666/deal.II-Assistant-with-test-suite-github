"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_44.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-44 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-44 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-44 tutorial program\\n\\n\\nThis tutorial depends on step-18.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nList of references\\n Notation \\nKinematics\\nKinetics\\n Push-forward and pull-back operators \\nHyperelastic materials\\n\\n Neo-Hookean materials \\n\\nElasticity tensors\\nPrinciple of stationary potential energy and the three-field formulation\\n Discretization of governing equations \\n The material class \\n Numerical example \\n\\n The commented program\\n\\nRun-time parameters\\n\\nFinite Element system\\nGeometry\\nMaterials\\nLinear solver\\nNonlinear solver\\nTime\\nAll parameters\\n\\nTime class\\nCompressible neo-Hookean material within a three-field formulation\\nQuadrature point history\\nQuasi-static quasi-incompressible finite-strain solid\\nImplementation of the Solid class\\n\\nPublic interface\\n\\nPrivate interface\\n\\nThreading-building-blocks structures\\nSolid::make_grid\\nSolid::system_setup\\nSolid::determine_component_extractors\\nSolid::setup_qph\\nSolid::update_qph_incremental\\nSolid::solve_nonlinear_timestep\\nSolid::print_conv_header and Solid::print_conv_footer\\nSolid::get_error_dilation\\nSolid::get_error_residual\\nSolid::get_error_update\\nSolid::get_total_solution\\nSolid::assemble_system\\nSolid::make_constraints\\nSolid::assemble_sc\\nSolid::solve_linear_system\\nSolid::output_results\\n\\nMain function\\n\\n\\n Results\\n\\nPossibilities for extensions\\n\\n The plain program\\n   \\n\\n\\nThis program was contributed by Jean-Paul Pelteret and Andrew McBride. \\n This material is based upon work supported by the German Science Foundation (Deutsche Forschungsgemeinschaft, DFG), grant STE 544/39-1, and the National Research Foundation of South Africa. \\nNoteIf you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation:   \\n Introduction\\nThe subject of this tutorial is nonlinear solid mechanics. Classical single-field approaches (see e.g. step-18) can not correctly describe the response of quasi-incompressible materials. The response is overly stiff; a phenomenon known as locking. Locking problems can be circumvented using a variety of alternative strategies. One such strategy is the three-field formulation. It is used here to model the three-dimensional, fully-nonlinear (geometrical and material) response of an isotropic continuum body. The material response is approximated as hyperelastic. Additionally, the three-field formulation employed is valid for quasi-incompressible as well as compressible materials.\\nThe objective of this presentation is to provide a basis for using deal.II for problems in nonlinear solid mechanics. The linear problem was addressed in step-8. A non-standard, hypoelastic-type form of the geometrically nonlinear problem was partially considered in step-18: a rate form of the linearised constitutive relations is used and the problem domain evolves with the motion. Important concepts surrounding the nonlinear kinematics are absent in the theory and implementation. step-18 does, however, describe many of the key concepts to implement elasticity within the framework of deal.II.\\nWe begin with a crash-course in nonlinear kinematics. For the sake of simplicity, we restrict our attention to the quasi-static problem. Thereafter, various key stress measures are introduced and the constitutive model described. We then describe the three-field formulation in detail prior to explaining the structure of the class used to manage the material. The setup of the example problem is then presented.\\nNoteThis tutorial has been developed (and is described in the introduction) for the problem of elasticity in three dimensions. While the space dimension could be changed in the main() routine, care needs to be taken. Two-dimensional elasticity problems, in general, exist only as idealizations of three-dimensional ones. That is, they are either plane strain or plane stress. The assumptions that follow either of these choices needs to be consistently imposed. For more information see the note in step-8.\\nList of references\\nThe three-field formulation implemented here was pioneered by Simo et al. (1985) and is known as the mixed Jacobian-pressure formulation. Important related contributions include those by Simo and Taylor (1991), and Miehe (1994). The notation adopted here draws heavily on the excellent overview of the theoretical aspects of nonlinear solid mechanics by Holzapfel (2001). A nice overview of issues pertaining to incompressible elasticity (at small strains) is given in Hughes (2000).\\n\\n\\nJ.C. Simo, R.L. Taylor and K.S. Pister (1985), Variational and projection methods for the volume constraint in finite deformation elasto-plasticity,  Computer Methods in Applied Mechanics and Engineering ,  51 , 1-3, 177-208. DOI: 10.1016/0045-7825(85)90033-7; \\n\\nJ.C. Simo and R.L. Taylor (1991), Quasi-incompressible finite elasticity in principal stretches. Continuum basis and numerical algorithms,  Computer Methods in Applied Mechanics and Engineering ,  85 , 3, 273-310. DOI: 10.1016/0045-7825(91)90100-K; \\n\\nC. Miehe (1994), Aspects of the formulation and finite element implementation of large strain isotropic elasticity  International Journal for Numerical Methods in Engineering   37 , 12, 1981-2004. DOI: 10.1002/nme.1620371202; \\n\\nG.A. Holzapfel (2001), Nonlinear Solid Mechanics. A Continuum Approach for Engineering, John Wiley & Sons. ISBN: 0-471-82304-X; \\n\\nT.J.R. Hughes (2000), The Finite Element Method: Linear Static and Dynamic Finite Element Analysis, Dover. ISBN: 978-0486411811 \\n\\nAn example where this three-field formulation is used in a coupled problem is documented in \\n\\nJ-P. V. Pelteret, D. Davydov, A. McBride, D. K. Vu, and P. Steinmann (2016), Computational electro- and magneto-elasticity for quasi-incompressible media immersed in free space,  International Journal for Numerical Methods in Engineering . DOI: 10.1002/nme.5254 \\n\\nNotation \\nOne can think of fourth-order tensors as linear operators mapping second-order tensors (matrices) onto themselves in much the same way as matrices map vectors onto vectors. There are various fourth-order unit tensors that will be required in the forthcoming presentation. The fourth-order unit tensors \\\\(\\\\mathcal{I}\\\\) and \\\\(\\\\overline{\\\\mathcal{I}}\\\\) are defined by     \\n\\\\[\\n        \\\\mathbf{A} = \\\\mathcal{I}:\\\\mathbf{A}\\n                \\\\qquad \\\\text{and} \\\\qquad\\n        \\\\mathbf{A}^T = \\\\overline{\\\\mathcal{I}}:\\\\mathbf{A} \\\\, .\\n\\\\]\\n\\n Note \\\\(\\\\mathcal{I} \\\\neq \\\\overline{\\\\mathcal{I}}^T\\\\). Furthermore, we define the symmetric and skew-symmetric fourth-order unit tensors by     \\n\\\\[\\n        \\\\mathcal{S} \\\\dealcoloneq \\\\dfrac{1}{2}[\\\\mathcal{I} + \\\\overline{\\\\mathcal{I}}]\\n                \\\\qquad \\\\text{and} \\\\qquad\\n        \\\\mathcal{W} \\\\dealcoloneq \\\\dfrac{1}{2}[\\\\mathcal{I} - \\\\overline{\\\\mathcal{I}}] \\\\, ,\\n\\\\]\\n\\n such that     \\n\\\\[\\n        \\\\dfrac{1}{2}[\\\\mathbf{A} + \\\\mathbf{A}^T] = \\\\mathcal{S}:\\\\mathbf{A}\\n                \\\\qquad \\\\text{and} \\\\qquad\\n        \\\\dfrac{1}{2}[\\\\mathbf{A} - \\\\mathbf{A}^T] = \\\\mathcal{W}:\\\\mathbf{A} \\\\, .\\n\\\\]\\n\\n The fourth-order SymmetricTensor returned by identity_tensor() is \\\\(\\\\mathcal{S}\\\\).\\nKinematics\\nLet the time domain be denoted \\\\(\\\\mathbb{T} = [0,T_{\\\\textrm{end}}]\\\\), where \\\\(t \\\\in \\\\mathbb{T}\\\\) and \\\\(T_{\\\\textrm{end}}\\\\) is the total problem duration. Consider a continuum body that occupies the reference configuration \\\\(\\\\Omega_0\\\\) at time \\\\(t=0\\\\). Particles in the reference configuration are identified by the position vector \\\\(\\\\mathbf{X}\\\\). The configuration of the body at a later time \\\\(t>0\\\\) is termed the current configuration, denoted \\\\(\\\\Omega\\\\), with particles identified by the vector \\\\(\\\\mathbf{x}\\\\). The nonlinear map between the reference and current configurations, denoted \\\\(\\\\boldsymbol{\\\\varphi}\\\\), acts as follows:   \\n\\\\[\\n        \\\\mathbf{x} = \\\\boldsymbol{\\\\varphi}(\\\\mathbf{X},t) \\\\, .\\n\\\\]\\n\\n The material description of the displacement of a particle is defined by   \\n\\\\[\\n        \\\\mathbf{U}(\\\\mathbf{X},t) = \\\\mathbf{x}(\\\\mathbf{X},t) - \\\\mathbf{X} \\\\, .\\n\\\\]\\n\\nThe deformation gradient \\\\(\\\\mathbf{F}\\\\) is defined as the material gradient of the motion:      \\n\\\\[\\n        \\\\mathbf{F}(\\\\mathbf{X},t)\\n                \\\\dealcoloneq \\\\dfrac{\\\\partial \\\\boldsymbol{\\\\varphi}(\\\\mathbf{X},t)}{\\\\partial \\\\mathbf{X}}\\n                = \\\\textrm{Grad}\\\\ \\\\mathbf{x}(\\\\mathbf{X},t)\\n                = \\\\mathbf{I} + \\\\textrm{Grad}\\\\ \\\\mathbf{U} \\\\, .\\n\\\\]\\n\\n The determinant of the of the deformation gradient \\\\(J(\\\\mathbf{X},t) \\\\dealcoloneq \\\\textrm{det}\\\\ \\\\mathbf{F}(\\\\mathbf{X},t) > 0\\\\) maps corresponding volume elements in the reference and current configurations, denoted \\\\(\\\\textrm{d}V\\\\) and \\\\(\\\\textrm{d}v\\\\), respectively, as   \\n\\\\[\\n        \\\\textrm{d}v = J(\\\\mathbf{X},t)\\\\; \\\\textrm{d}V \\\\, .\\n\\\\]\\n\\nTwo important measures of the deformation in terms of the spatial and material coordinates are the left and right Cauchy-Green tensors, respectively, and denoted \\\\(\\\\mathbf{b} \\\\dealcoloneq \\\\mathbf{F}\\\\mathbf{F}^T\\\\) and \\\\(\\\\mathbf{C} \\\\dealcoloneq \\\\mathbf{F}^T\\\\mathbf{F}\\\\). They are both symmetric and positive definite.\\nThe Green-Lagrange strain tensor is defined by     \\n\\\\[\\n        \\\\mathbf{E} \\\\dealcoloneq \\\\frac{1}{2}[\\\\mathbf{C} - \\\\mathbf{I} ]\\n                = \\\\underbrace{\\\\frac{1}{2}[\\\\textrm{Grad}^T \\\\mathbf{U} +  \\\\textrm{Grad}\\\\mathbf{U}]}_{\\\\boldsymbol{\\\\varepsilon}}\\n                        + \\\\frac{1}{2}[\\\\textrm{Grad}^T\\\\ \\\\mathbf{U}][\\\\textrm{Grad}\\\\ \\\\mathbf{U}] \\\\, .\\n\\\\]\\n\\n If the assumption of infinitesimal deformations is made, then the second term on the right can be neglected, and \\\\(\\\\boldsymbol{\\\\varepsilon}\\\\) (the linearised strain tensor) is the only component of the strain tensor. This assumption is, looking at the setup of the problem, not valid in step-18, making the use of the linearized \\\\(\\\\boldsymbol{\\\\varepsilon}\\\\) as the strain measure in that tutorial program questionable.\\nIn order to handle the different response that materials exhibit when subjected to bulk and shear type deformations we consider the following decomposition of the deformation gradient \\\\(\\\\mathbf{F}\\\\) and the left Cauchy-Green tensor \\\\(\\\\mathbf{b}\\\\) into volume-changing (volumetric) and volume-preserving (isochoric) parts:        \\n\\\\[\\n        \\\\mathbf{F}\\n                = (J^{1/3}\\\\mathbf{I})\\\\overline{\\\\mathbf{F}}\\n        \\\\qquad \\\\text{and} \\\\qquad\\n        \\\\mathbf{b}\\n        = (J^{2/3}\\\\mathbf{I})\\\\overline{\\\\mathbf{F}}\\\\,\\\\overline{\\\\mathbf{F}}^T\\n                =  (J^{2/3}\\\\mathbf{I})\\\\overline{\\\\mathbf{b}} \\\\, .\\n\\\\]\\n\\n Clearly, \\\\(\\\\textrm{det}\\\\ \\\\mathbf{F} = \\\\textrm{det}\\\\ (J^{1/3}\\\\mathbf{I}) = J\\\\).\\nThe spatial velocity field is denoted \\\\(\\\\mathbf{v}(\\\\mathbf{x},t)\\\\). The derivative of the spatial velocity field with respect to the spatial coordinates gives the spatial velocity gradient \\\\(\\\\mathbf{l}(\\\\mathbf{x},t)\\\\), that is     \\n\\\\[\\n        \\\\mathbf{l}(\\\\mathbf{x},t)\\n                \\\\dealcoloneq \\\\dfrac{\\\\partial \\\\mathbf{v}(\\\\mathbf{x},t)}{\\\\partial \\\\mathbf{x}}\\n                = \\\\textrm{grad}\\\\ \\\\mathbf{v}(\\\\mathbf{x},t) \\\\, ,\\n\\\\]\\n\\n where    \\\\(\\\\textrm{grad} \\\\{\\\\bullet \\\\}\\n= \\\\frac{\\\\partial \\\\{ \\\\bullet \\\\} }{ \\\\partial \\\\mathbf{x}}\\n= \\\\frac{\\\\partial \\\\{ \\\\bullet \\\\} }{ \\\\partial \\\\mathbf{X}}\\\\frac{\\\\partial \\\\mathbf{X} }{ \\\\partial \\\\mathbf{x}}\\n= \\\\textrm{Grad} \\\\{ \\\\bullet \\\\} \\\\mathbf{F}^{-1}\\\\).\\nKinetics\\nCauchy's stress theorem equates the Cauchy traction \\\\(\\\\mathbf{t}\\\\) acting on an infinitesimal surface element in the current configuration \\\\(\\\\mathrm{d}a\\\\) to the product of the Cauchy stress tensor \\\\(\\\\boldsymbol{\\\\sigma}\\\\) (a spatial quantity) and the outward unit normal to the surface \\\\(\\\\mathbf{n}\\\\) as   \\n\\\\[\\n        \\\\mathbf{t}(\\\\mathbf{x},t, \\\\mathbf{n}) = \\\\boldsymbol{\\\\sigma}\\\\mathbf{n} \\\\, .\\n\\\\]\\n\\n The Cauchy stress is symmetric. Similarly, the first Piola-Kirchhoff traction \\\\(\\\\mathbf{T}\\\\) which acts on an infinitesimal surface element in the reference configuration \\\\(\\\\mathrm{d}A\\\\) is the product of the first Piola-Kirchhoff stress tensor \\\\(\\\\mathbf{P}\\\\) (a two-point tensor) and the outward unit normal to the surface \\\\(\\\\mathbf{N}\\\\) as   \\n\\\\[\\n        \\\\mathbf{T}(\\\\mathbf{X},t, \\\\mathbf{N}) = \\\\mathbf{P}\\\\mathbf{N} \\\\, .\\n\\\\]\\n\\n The Cauchy traction \\\\(\\\\mathbf{t}\\\\) and the first Piola-Kirchhoff traction \\\\(\\\\mathbf{T}\\\\) are related as   \\n\\\\[\\n        \\\\mathbf{t}\\\\mathrm{d}a = \\\\mathbf{T}\\\\mathrm{d}A \\\\, .\\n\\\\]\\n\\n This can be demonstrated using Nanson's formula.\\nThe first Piola-Kirchhoff stress tensor is related to the Cauchy stress as   \\n\\\\[\\n        \\\\mathbf{P} = J \\\\boldsymbol{\\\\sigma}\\\\mathbf{F}^{-T} \\\\, .\\n\\\\]\\n\\n Further important stress measures are the (spatial) Kirchhoff stress \\\\(\\\\boldsymbol{\\\\tau} = J \\\\boldsymbol{\\\\sigma}\\\\) and the (referential) second Piola-Kirchhoff stress \\\\(\\\\mathbf{S} = {\\\\mathbf{F}}^{-1} \\\\boldsymbol{\\\\tau} {\\\\mathbf{F}}^{-T}\\\\).\\nPush-forward and pull-back operators \\nPush-forward and pull-back operators allow one to transform various measures between the material and spatial settings. The stress measures used here are contravariant, while the strain measures are covariant.\\nThe push-forward and-pull back operations for second-order covariant tensors \\\\((\\\\bullet)^{\\\\text{cov}}\\\\) are respectively given by:     \\n\\\\[\\n        \\\\chi_{*}(\\\\bullet)^{\\\\text{cov}} \\\\dealcoloneq \\\\mathbf{F}^{-T} (\\\\bullet)^{\\\\text{cov}} \\\\mathbf{F}^{-1}\\n        \\\\qquad \\\\text{and} \\\\qquad\\n        \\\\chi^{-1}_{*}(\\\\bullet)^{\\\\text{cov}} \\\\dealcoloneq \\\\mathbf{F}^{T} (\\\\bullet)^{\\\\text{cov}} \\\\mathbf{F} \\\\, .\\n\\\\]\\n\\nThe push-forward and pull back operations for second-order contravariant tensors \\\\((\\\\bullet)^{\\\\text{con}}\\\\) are respectively given by:     \\n\\\\[\\n        \\\\chi_{*}(\\\\bullet)^{\\\\text{con}} \\\\dealcoloneq \\\\mathbf{F} (\\\\bullet)^{\\\\text{con}} \\\\mathbf{F}^T\\n        \\\\qquad \\\\text{and} \\\\qquad\\n        \\\\chi^{-1}_{*}(\\\\bullet)^{\\\\text{con}} \\\\dealcoloneq \\\\mathbf{F}^{-1} (\\\\bullet)^{\\\\text{con}} \\\\mathbf{F}^{-T} \\\\, .\\n\\\\]\\n\\n For example \\\\(\\\\boldsymbol{\\\\tau} = \\\\chi_{*}(\\\\mathbf{S})\\\\).\\nHyperelastic materials\\nA hyperelastic material response is governed by a Helmholtz free energy function \\\\(\\\\Psi = \\\\Psi(\\\\mathbf{F}) = \\\\Psi(\\\\mathbf{C}) = \\\\Psi(\\\\mathbf{b})\\\\) which serves as a potential for the stress. For example, if the Helmholtz free energy depends on the right Cauchy-Green tensor \\\\(\\\\mathbf{C}\\\\) then the isotropic hyperelastic response is    \\n\\\\[\\n        \\\\mathbf{S}\\n                = 2 \\\\dfrac{\\\\partial \\\\Psi(\\\\mathbf{C})}{\\\\partial \\\\mathbf{C}} \\\\, .\\n\\\\]\\n\\n If the Helmholtz free energy depends on the left Cauchy-Green tensor \\\\(\\\\mathbf{b}\\\\) then the isotropic hyperelastic response is     \\n\\\\[\\n        \\\\boldsymbol{\\\\tau}\\n                = 2 \\\\dfrac{\\\\partial \\\\Psi(\\\\mathbf{b})}{\\\\partial \\\\mathbf{b}} \\\\mathbf{b}\\n                =  2 \\\\mathbf{b} \\\\dfrac{\\\\partial \\\\Psi(\\\\mathbf{b})}{\\\\partial \\\\mathbf{b}} \\\\, .\\n\\\\]\\n\\nFollowing the multiplicative decomposition of the deformation gradient, the Helmholtz free energy can be decomposed as   \\n\\\\[\\n        \\\\Psi(\\\\mathbf{b}) = \\\\Psi_{\\\\text{vol}}(J) + \\\\Psi_{\\\\text{iso}}(\\\\overline{\\\\mathbf{b}}) \\\\, .\\n\\\\]\\n\\n Similarly, the Kirchhoff stress can be decomposed into volumetric and isochoric parts as \\\\(\\\\boldsymbol{\\\\tau} = \\\\boldsymbol{\\\\tau}_{\\\\text{vol}} + \\\\boldsymbol{\\\\tau}_{\\\\text{iso}}\\\\) where:           \\n\\\\begin{align*}\\n        \\\\boldsymbol{\\\\tau}_{\\\\text{vol}} &=\\n                2 \\\\mathbf{b} \\\\dfrac{\\\\partial \\\\Psi_{\\\\textrm{vol}}(J)}{\\\\partial \\\\mathbf{b}}\\n                \\\\\\\\\\n                &= p J\\\\mathbf{I} \\\\, ,\\n                \\\\\\\\\\n        \\\\boldsymbol{\\\\tau}_{\\\\text{iso}} &=\\n                2 \\\\mathbf{b} \\\\dfrac{\\\\partial \\\\Psi_{\\\\textrm{iso}} (\\\\overline{\\\\mathbf{b}})}{\\\\partial \\\\mathbf{b}}\\n                \\\\\\\\\\n                &= \\\\underbrace{( \\\\mathcal{S} - \\\\dfrac{1}{3} \\\\mathbf{I} \\\\otimes \\\\mathbf{I})}_{\\\\mathbb{P}} : \\\\overline{\\\\boldsymbol{\\\\tau}} \\\\, ,\\n\\\\end{align*}\\n\\n where \\\\(p \\\\dealcoloneq \\\\dfrac{\\\\partial \\\\Psi_{\\\\text{vol}}(J)}{\\\\partial J}\\\\) is the pressure response. \\\\(\\\\mathbb{P}\\\\) is the projection tensor which provides the deviatoric operator in the Eulerian setting. The fictitious Kirchhoff stress tensor \\\\(\\\\overline{\\\\boldsymbol{\\\\tau}}\\\\) is defined by    \\n\\\\[\\n        \\\\overline{\\\\boldsymbol{\\\\tau}}\\n                \\\\dealcoloneq 2 \\\\overline{\\\\mathbf{b}} \\\\dfrac{\\\\partial \\\\Psi_{\\\\textrm{iso}}(\\\\overline{\\\\mathbf{b}})}{\\\\partial \\\\overline{\\\\mathbf{b}}} \\\\, .\\n\\\\]\\n\\nNoteThe pressure response as defined above differs from the widely-used definition of the pressure in solid mechanics as \\\\(p = - 1/3 \\\\textrm{tr} \\\\boldsymbol{\\\\sigma} = - 1/3 J^{-1} \\\\textrm{tr} \\\\boldsymbol{\\\\tau}\\\\). Here \\\\(p\\\\) is the hydrostatic pressure. We make use of the pressure response throughout this tutorial (although we refer to it as the pressure).\\nNeo-Hookean materials \\nThe Helmholtz free energy corresponding to a compressible neo-Hookean material is given by     \\n\\\\[\\n    \\\\Psi \\\\equiv\\n        \\\\underbrace{\\\\kappa [ \\\\mathcal{G}(J) ] }_{\\\\Psi_{\\\\textrm{vol}}(J)}\\n        + \\\\underbrace{\\\\bigl[c_1 [ \\\\overline{I}_1 - 3] \\\\bigr]}_{\\\\Psi_{\\\\text{iso}}(\\\\overline{\\\\mathbf{b}})} \\\\, ,\\n\\\\]\\n\\n where \\\\(\\\\kappa \\\\dealcoloneq \\\\lambda + 2/3 \\\\mu\\\\) is the bulk modulus ( \\\\(\\\\lambda\\\\) and \\\\(\\\\mu\\\\) are the Lam\\u00e9 parameters) and \\\\(\\\\overline{I}_1 \\\\dealcoloneq \\\\textrm{tr}\\\\ \\\\overline{\\\\mathbf{b}}\\\\). The function \\\\(\\\\mathcal{G}(J)\\\\) is required to be strictly convex and satisfy the condition \\\\(\\\\mathcal{G}(1) = 0\\\\), among others, see Holzapfel (2001) for further details. In this work \\\\(\\\\mathcal{G} \\\\dealcoloneq \\\\frac{1}{4} [ J^2 - 1 - 2\\\\textrm{ln}J ]\\\\).\\nIncompressibility imposes the isochoric constraint that \\\\(J=1\\\\) for all motions \\\\(\\\\boldsymbol{\\\\varphi}\\\\). The Helmholtz free energy corresponding to an incompressible neo-Hookean material is given by    \\n\\\\[\\n    \\\\Psi \\\\equiv\\n        \\\\underbrace{\\\\bigl[ c_1 [ I_1 - 3] \\\\bigr] }_{\\\\Psi_{\\\\textrm{iso}}(\\\\mathbf{b})} \\\\, ,\\n\\\\]\\n\\n where \\\\( I_1 \\\\dealcoloneq \\\\textrm{tr}\\\\mathbf{b} \\\\). Thus, the incompressible response is obtained by removing the volumetric component from the compressible free energy and enforcing \\\\(J=1\\\\).\\nElasticity tensors\\nWe will use a Newton-Raphson strategy to solve the nonlinear boundary value problem. Thus, we will need to linearise the constitutive relations.\\nThe fourth-order elasticity tensor in the material description is defined by     \\n\\\\[\\n        \\\\mathfrak{C}\\n                = 2\\\\dfrac{\\\\partial \\\\mathbf{S}(\\\\mathbf{C})}{\\\\partial \\\\mathbf{C}}\\n                = 4\\\\dfrac{\\\\partial^2 \\\\Psi(\\\\mathbf{C})}{\\\\partial \\\\mathbf{C} \\\\partial \\\\mathbf{C}} \\\\, .\\n\\\\]\\n\\n The fourth-order elasticity tensor in the spatial description \\\\(\\\\mathfrak{c}\\\\) is obtained from the push-forward of \\\\(\\\\mathfrak{C}\\\\) as     \\n\\\\[\\n        \\\\mathfrak{c} = J^{-1} \\\\chi_{*}(\\\\mathfrak{C})\\n                \\\\qquad \\\\text{and thus} \\\\qquad\\n        J\\\\mathfrak{c} = 4 \\\\mathbf{b} \\\\dfrac{\\\\partial^2 \\\\Psi(\\\\mathbf{b})} {\\\\partial \\\\mathbf{b} \\\\partial \\\\mathbf{b}} \\\\mathbf{b}   \\\\, .\\n\\\\]\\n\\n This tensor (for hyperelastic materials) possesses both major and minor symmetries, and it can be written in the following decoupled form:   \\n\\\\[\\n        \\\\mathfrak{c} = \\\\mathfrak{c}_{\\\\text{vol}} + \\\\mathfrak{c}_{\\\\text{iso}} \\\\, ,\\n\\\\]\\n\\n where                \\n\\\\begin{align*}\\n        J \\\\mathfrak{c}_{\\\\text{vol}}\\n                &= 4 \\\\mathbf{b} \\\\dfrac{\\\\partial^2 \\\\Psi_{\\\\text{vol}}(J)} {\\\\partial \\\\mathbf{b} \\\\partial \\\\mathbf{b}} \\\\mathbf{b}\\n                \\\\\\\\\\n                &= J[\\\\widehat{p}\\\\, \\\\mathbf{I} \\\\otimes \\\\mathbf{I} - 2p \\\\mathcal{S}]\\n                        \\\\qquad \\\\text{where} \\\\qquad\\n                \\\\widehat{p} \\\\dealcoloneq p + \\\\dfrac{\\\\textrm{d} p}{\\\\textrm{d}J} \\\\, ,\\n                \\\\\\\\\\n        J \\\\mathfrak{c}_{\\\\text{iso}}\\n                &=  4 \\\\mathbf{b} \\\\dfrac{\\\\partial^2 \\\\Psi_{\\\\text{iso}}(\\\\overline{\\\\mathbf{b}})} {\\\\partial \\\\mathbf{b} \\\\partial \\\\mathbf{b}} \\\\mathbf{b}\\n                \\\\\\\\\\n                &= \\\\mathbb{P} : \\\\mathfrak{\\\\overline{c}} : \\\\mathbb{P}\\n                        + \\\\dfrac{2}{3}[\\\\overline{\\\\boldsymbol{\\\\tau}}:\\\\mathbf{I}]\\\\mathbb{P}\\n                        - \\\\dfrac{2}{3}[ \\\\mathbf{I}\\\\otimes\\\\boldsymbol{\\\\tau}_{\\\\text{iso}}\\n                                + \\\\boldsymbol{\\\\tau}_{\\\\text{iso}} \\\\otimes \\\\mathbf{I} ] \\\\, ,\\n\\\\end{align*}\\n\\n where the fictitious elasticity tensor \\\\(\\\\overline{\\\\mathfrak{c}}\\\\) in the spatial description is defined by    \\n\\\\[\\n        \\\\overline{\\\\mathfrak{c}}\\n                = 4 \\\\overline{\\\\mathbf{b}} \\\\dfrac{ \\\\partial^2 \\\\Psi_{\\\\textrm{iso}}(\\\\overline{\\\\mathbf{b}})} {\\\\partial \\\\overline{\\\\mathbf{b}} \\\\partial \\\\overline{\\\\mathbf{b}}} \\\\overline{\\\\mathbf{b}} \\\\, .\\n\\\\]\\n\\nPrinciple of stationary potential energy and the three-field formulation\\nThe total potential energy of the system \\\\(\\\\Pi\\\\) is the sum of the internal and external potential energies, denoted \\\\(\\\\Pi_{\\\\textrm{int}}\\\\) and \\\\(\\\\Pi_{\\\\textrm{ext}}\\\\), respectively. We wish to find the equilibrium configuration by minimising the potential energy.\\nAs mentioned above, we adopt a three-field formulation. We denote the set of primary unknowns by \\\\(\\\\mathbf{\\\\Xi} \\\\dealcoloneq \\\\{ \\\\mathbf{u}, \\\\widetilde{p}, \\\\widetilde{J} \\\\}\\\\). The independent kinematic variable \\\\(\\\\widetilde{J}\\\\) enters the formulation as a constraint on \\\\(J\\\\) enforced by the Lagrange multiplier \\\\(\\\\widetilde{p}\\\\) (the pressure, as we shall see).\\nThe three-field variational principle used here is given by        \\n\\\\[\\n        \\\\Pi(\\\\mathbf{\\\\Xi}) \\\\dealcoloneq \\\\int_\\\\Omega \\\\bigl[\\n                \\\\Psi_{\\\\textrm{vol}}(\\\\widetilde{J})\\n                + \\\\widetilde{p}\\\\,[J(\\\\mathbf{u}) - \\\\widetilde{J}]\\n                + \\\\Psi_{\\\\textrm{iso}}(\\\\overline{\\\\mathbf{b}}(\\\\mathbf{u}))\\n                \\\\bigr] \\\\textrm{d}v\\n        +       \\\\Pi_{\\\\textrm{ext}} \\\\, ,\\n\\\\]\\n\\n where the external potential is defined by     \\n\\\\[\\n        \\\\Pi_{\\\\textrm{ext}}\\n                = - \\\\int_\\\\Omega \\\\mathbf{b}^\\\\text{p} \\\\cdot \\\\mathbf{u}~\\\\textrm{d}v\\n                        - \\\\int_{\\\\partial \\\\Omega_{\\\\sigma}} \\\\mathbf{t}^\\\\text{p} \\\\cdot \\\\mathbf{u}~\\\\textrm{d}a \\\\, .\\n\\\\]\\n\\n The boundary of the current configuration \\\\(\\\\partial \\\\Omega\\\\) is composed into two parts as \\\\(\\\\partial \\\\Omega = \\\\partial \\\\Omega_{\\\\mathbf{u}} \\\\cup \\\\partial \\\\Omega_{\\\\sigma}\\\\), where \\\\(\\\\partial \\\\Omega_{\\\\mathbf{u}} \\\\cap \\\\partial \\\\Omega_{\\\\boldsymbol{\\\\sigma}} = \\\\emptyset\\\\). The prescribed Cauchy traction, denoted \\\\(\\\\mathbf{t}^\\\\text{p}\\\\), is applied to \\\\( \\\\partial \\\\Omega_{\\\\boldsymbol{\\\\sigma}}\\\\) while the motion is prescribed on the remaining portion of the boundary \\\\(\\\\partial \\\\Omega_{\\\\mathbf{u}}\\\\). The body force per unit current volume is denoted \\\\(\\\\mathbf{b}^\\\\text{p}\\\\).\\nThe stationarity of the potential follows as                     \\n\\\\begin{align*}\\n        R(\\\\mathbf\\\\Xi;\\\\delta \\\\mathbf{\\\\Xi})\\n                &= D_{\\\\delta \\\\mathbf{\\\\Xi}}\\\\Pi(\\\\mathbf{\\\\Xi})\\n                \\\\\\\\\\n                &= \\\\dfrac{\\\\partial \\\\Pi(\\\\mathbf{\\\\Xi})}{\\\\partial \\\\mathbf{u}} \\\\cdot \\\\delta \\\\mathbf{u}\\n                        + \\\\dfrac{\\\\partial \\\\Pi(\\\\mathbf{\\\\Xi})}{\\\\partial \\\\widetilde{p}} \\\\delta \\\\widetilde{p}\\n                        + \\\\dfrac{\\\\partial \\\\Pi(\\\\mathbf{\\\\Xi})}{\\\\partial \\\\widetilde{J}} \\\\delta \\\\tilde{J}\\n                        \\\\\\\\\\n                &= \\\\int_{\\\\Omega_0}  \\\\left[\\n                        \\\\textrm{grad}\\\\ \\\\delta\\\\mathbf{u} : [ \\\\underbrace{[\\\\widetilde{p} J \\\\mathbf{I}]}_{\\\\equiv \\\\boldsymbol{\\\\tau}_{\\\\textrm{vol}}}\\n            +  \\\\boldsymbol{\\\\tau}_{\\\\textrm{iso}}]\\n                        + \\\\delta \\\\widetilde{p}\\\\, [ J(\\\\mathbf{u}) - \\\\widetilde{J}]\\n                        + \\\\delta \\\\widetilde{J}\\\\left[ \\\\dfrac{\\\\textrm{d} \\\\Psi_{\\\\textrm{vol}}(\\\\widetilde{J})}{\\\\textrm{d} \\\\widetilde{J}}\\n            -\\\\widetilde{p}\\\\right]\\n                        \\\\right]~\\\\textrm{d}V\\n                        \\\\\\\\\\n                &\\\\quad - \\\\int_{\\\\Omega_0} \\\\delta \\\\mathbf{u} \\\\cdot \\\\mathbf{B}^\\\\text{p}~\\\\textrm{d}V\\n                        - \\\\int_{\\\\partial \\\\Omega_{0,\\\\boldsymbol{\\\\sigma}}} \\\\delta \\\\mathbf{u} \\\\cdot \\\\mathbf{T}^\\\\text{p}~\\\\textrm{d}A\\n                        \\\\\\\\\\n                &=0 \\\\, ,\\n\\\\end{align*}\\n\\n for all virtual displacements \\\\(\\\\delta \\\\mathbf{u} \\\\in H^1(\\\\Omega)\\\\) subject to the constraint that \\\\(\\\\delta \\\\mathbf{u} = \\\\mathbf{0}\\\\) on \\\\(\\\\partial \\\\Omega_{\\\\mathbf{u}}\\\\), and all virtual pressures \\\\(\\\\delta \\\\widetilde{p} \\\\in L^2(\\\\Omega)\\\\) and virtual dilatations \\\\(\\\\delta \\\\widetilde{J} \\\\in L^2(\\\\Omega)\\\\).\\nOne should note that the definitions of the volumetric Kirchhoff stress in the three field formulation \\\\(\\\\boldsymbol{\\\\tau}_{\\\\textrm{vol}} \\\\equiv \\\\widetilde{p} J \\\\mathbf{I}\\\\) and the subsequent volumetric tangent differs slightly from the general form given in the section on hyperelastic materials where \\\\(\\\\boldsymbol{\\\\tau}_{\\\\textrm{vol}} \\\\equiv p J\\\\mathbf{I}\\\\). This is because the pressure \\\\(\\\\widetilde{p}\\\\) is now a primary field as opposed to a constitutively derived quantity. One needs to carefully distinguish between the primary fields and those obtained from the constitutive relations.\\nNoteAlthough the variables are all expressed in terms of spatial quantities, the domain of integration is the initial configuration. This approach is called a  total-Lagrangian formulation . The approach given in step-18, where the domain of integration is the current configuration, could be called an  updated Lagrangian formulation . The various merits of these two approaches are discussed widely in the literature. It should be noted however that they are equivalent.\\nThe Euler-Lagrange equations corresponding to the residual are:       \\n\\\\begin{align*}\\n        &\\\\textrm{div}\\\\ \\\\boldsymbol{\\\\sigma} + \\\\mathbf{b}^\\\\text{p} = \\\\mathbf{0} && \\\\textrm{[equilibrium]}\\n                \\\\\\\\\\n        &J(\\\\mathbf{u}) = \\\\widetilde{J}          && \\\\textrm{[dilatation]}\\n                \\\\\\\\\\n        &\\\\widetilde{p} = \\\\dfrac{\\\\textrm{d} \\\\Psi_{\\\\textrm{vol}}(\\\\widetilde{J})}{\\\\textrm{d} \\\\widetilde{J}} && \\\\textrm{[pressure]} \\\\, .\\n\\\\end{align*}\\n\\n The first equation is the (quasi-static) equilibrium equation in the spatial setting. The second is the constraint that \\\\(J(\\\\mathbf{u}) = \\\\widetilde{J}\\\\). The third is the definition of the pressure \\\\(\\\\widetilde{p}\\\\).\\nNoteThe simplified single-field derivation ( \\\\(\\\\mathbf{u}\\\\) is the only primary variable) below makes it clear how we transform the limits of integration to the reference domain:                  \\n\\\\begin{align*}\\n\\\\int_{\\\\Omega}\\\\delta \\\\mathbf{u} \\\\cdot [\\\\textrm{div}\\\\ \\\\boldsymbol{\\\\sigma} + \\\\mathbf{b}^\\\\text{p}]~\\\\mathrm{d}v\\n&=\\n\\\\int_{\\\\Omega} [-\\\\mathrm{grad}\\\\delta \\\\mathbf{u}:\\\\boldsymbol{\\\\sigma} + \\\\delta \\\\mathbf{u} \\\\cdot\\\\mathbf{b}^\\\\text{p}]~\\\\mathrm{d}v\\n  + \\\\int_{\\\\partial \\\\Omega} \\\\delta \\\\mathbf{u} \\\\cdot \\\\mathbf{t}^\\\\text{p}~\\\\mathrm{d}a \\\\\\\\\\n&=\\n- \\\\int_{\\\\Omega_0} \\\\mathrm{grad}\\\\delta \\\\mathbf{u}:\\\\boldsymbol{\\\\tau}~\\\\mathrm{d}V\\n+ \\\\int_{\\\\Omega_0} \\\\delta \\\\mathbf{u} \\\\cdot J\\\\mathbf{b}^\\\\text{p}~\\\\mathrm{d}V\\n + \\\\int_{\\\\partial \\\\Omega_0} \\\\delta \\\\mathbf{u} \\\\cdot \\\\mathbf{T}^\\\\text{p}~\\\\mathrm{d}A \\\\\\\\\\n&=\\n- \\\\int_{\\\\Omega_0} \\\\mathrm{grad}\\\\delta \\\\mathbf{u}:\\\\boldsymbol{\\\\tau}~\\\\mathrm{d}V\\n+ \\\\int_{\\\\Omega_0} \\\\delta \\\\mathbf{u} \\\\cdot \\\\mathbf{B}^\\\\text{p}~\\\\mathrm{d}V\\n + \\\\int_{\\\\partial \\\\Omega_{0,\\\\sigma}} \\\\delta \\\\mathbf{u} \\\\cdot \\\\mathbf{T}^\\\\text{p}~\\\\mathrm{d}A \\\\\\\\\\n&=\\n- \\\\int_{\\\\Omega_0} [\\\\mathrm{grad}\\\\delta\\\\mathbf{u}]^{\\\\text{sym}} :\\\\boldsymbol{\\\\tau}~\\\\mathrm{d}V\\n+ \\\\int_{\\\\Omega_0} \\\\delta \\\\mathbf{u} \\\\cdot \\\\mathbf{B}^\\\\text{p}~\\\\mathrm{d}V\\n + \\\\int_{\\\\partial \\\\Omega_{0,\\\\sigma}} \\\\delta \\\\mathbf{u} \\\\cdot \\\\mathbf{T}^\\\\text{p}~\\\\mathrm{d}A \\\\, ,\\n\\\\end{align*}\\n\\n where \\\\([\\\\mathrm{grad}\\\\delta\\\\mathbf{u}]^{\\\\text{sym}} = 1/2[ \\\\mathrm{grad}\\\\delta\\\\mathbf{u} + [\\\\mathrm{grad}\\\\delta\\\\mathbf{u}]^T] \\\\).\\nWe will use an iterative Newton-Raphson method to solve the nonlinear residual equation \\\\(R\\\\). For the sake of simplicity we assume dead loading, i.e. the loading does not change due to the deformation.\\nThe change in a quantity between the known state at \\\\(t_{\\\\textrm{n}-1}\\\\) and the currently unknown state at \\\\(t_{\\\\textrm{n}}\\\\) is denoted \\\\(\\\\varDelta \\\\{ \\\\bullet \\\\} = { \\\\{ \\\\bullet \\\\} }^{\\\\textrm{n}} - { \\\\{ \\\\bullet \\\\} }^{\\\\textrm{n-1}}\\\\). The value of a quantity at the current iteration \\\\(\\\\textrm{i}\\\\) is denoted \\\\({ \\\\{ \\\\bullet \\\\} }^{\\\\textrm{n}}_{\\\\textrm{i}} = { \\\\{ \\\\bullet \\\\} }_{\\\\textrm{i}}\\\\). The incremental change between iterations \\\\(\\\\textrm{i}\\\\) and \\\\(\\\\textrm{i}+1\\\\) is denoted \\\\(d \\\\{ \\\\bullet \\\\} \\\\dealcoloneq \\\\{ \\\\bullet \\\\}_{\\\\textrm{i}+1} - \\\\{ \\\\bullet \\\\}_{\\\\textrm{i}}\\\\).\\nAssume that the state of the system is known for some iteration \\\\(\\\\textrm{i}\\\\). The linearised approximation to nonlinear governing equations to be solved using the Newton-Raphson method is: Find \\\\(d \\\\mathbf{\\\\Xi}\\\\) such that     \\n\\\\[\\n        R(\\\\mathbf{\\\\Xi}_{\\\\mathsf{i}+1}) =\\n                R(\\\\mathbf{\\\\Xi}_{\\\\mathsf{i}})\\n                + D^2_{d \\\\mathbf{\\\\Xi}, \\\\delta \\\\mathbf{\\\\Xi}} \\\\Pi(\\\\mathbf{\\\\Xi_{\\\\mathsf{i}}}) \\\\cdot d \\\\mathbf{\\\\Xi} \\\\equiv 0 \\\\, ,\\n\\\\]\\n\\n then set  \\\\(\\\\mathbf{\\\\Xi}_{\\\\textrm{i}+1} = \\\\mathbf{\\\\Xi}_{\\\\textrm{i}}\\n+ d \\\\mathbf{\\\\Xi}\\\\). The tangent is given by\\n\\n\\\\[\\n        D^2_{d \\\\mathbf{\\\\Xi}, \\\\delta \\\\mathbf{\\\\Xi}} \\\\Pi( \\\\mathbf{\\\\Xi}_{\\\\mathsf{i}} )\\n                = D_{d \\\\mathbf{\\\\Xi}} R( \\\\mathbf{\\\\Xi}_{\\\\mathsf{i}}; \\\\delta \\\\mathbf{\\\\Xi})\\n                =: K(\\\\mathbf{\\\\Xi}_{\\\\mathsf{i}}; d \\\\mathbf{\\\\Xi}, \\\\delta \\\\mathbf{\\\\Xi}) \\\\, .\\n\\\\]\\n\\n Thus,           \\n\\\\begin{align*}\\n        K(\\\\mathbf{\\\\Xi}_{\\\\mathsf{i}}; d \\\\mathbf{\\\\Xi}, \\\\delta \\\\mathbf{\\\\Xi})\\n                &=\\n                        D_{d \\\\mathbf{u}} R( \\\\mathbf{\\\\Xi}_{\\\\mathsf{i}}; \\\\delta \\\\mathbf{\\\\Xi}) \\\\cdot d \\\\mathbf{u}\\n                        \\\\\\\\\\n                                &\\\\quad +\\n                                D_{d \\\\widetilde{p}} R( \\\\mathbf{\\\\Xi}_{\\\\mathsf{i}}; \\\\delta \\\\mathbf{\\\\Xi})  d \\\\widetilde{p}\\n                         \\\\\\\\\\n                                &\\\\quad +\\n                          D_{d \\\\widetilde{J}} R( \\\\mathbf{\\\\Xi}_{\\\\mathsf{i}}; \\\\delta \\\\mathbf{\\\\Xi})  d \\\\widetilde{J} \\\\, ,\\n\\\\end{align*}\\n\\n where                     \\n\\\\begin{align*}\\n        D_{d \\\\mathbf{u}} R( \\\\mathbf{\\\\Xi}; \\\\delta \\\\mathbf{\\\\Xi})\\n        &=\\n        \\\\int_{\\\\Omega_0} \\\\bigl[ \\\\textrm{grad}\\\\ \\\\delta \\\\mathbf{u} :\\n                        \\\\textrm{grad}\\\\ d \\\\mathbf{u} [\\\\boldsymbol{\\\\tau}_{\\\\textrm{iso}} + \\\\boldsymbol{\\\\tau}_{\\\\textrm{vol}}]\\n                        + \\\\textrm{grad}\\\\ \\\\delta \\\\mathbf{u} :[\\n             \\\\underbrace{[\\\\widetilde{p}J[\\\\mathbf{I}\\\\otimes\\\\mathbf{I} - 2 \\\\mathcal{I}]}_{\\\\equiv J\\\\mathfrak{c}_{\\\\textrm{vol}}} +\\n             J\\\\mathfrak{c}_{\\\\textrm{iso}}] :\\\\textrm{grad} d \\\\mathbf{u}\\n                \\\\bigr]~\\\\textrm{d}V \\\\, ,\\n                \\\\\\\\\\n        &\\\\quad + \\\\int_{\\\\Omega_0} \\\\delta \\\\widetilde{p} J \\\\mathbf{I} : \\\\textrm{grad}\\\\ d \\\\mathbf{u} ~\\\\textrm{d}V\\n        \\\\\\\\\\n        D_{d \\\\widetilde{p}} R( \\\\mathbf{\\\\Xi}; \\\\delta \\\\mathbf{\\\\Xi})\\n        &=\\n        \\\\int_{\\\\Omega_0} \\\\textrm{grad}\\\\ \\\\delta \\\\mathbf{u} : J \\\\mathbf{I} d \\\\widetilde{p} ~\\\\textrm{d}V\\n                -  \\\\int_{\\\\Omega_0} \\\\delta \\\\widetilde{J} d \\\\widetilde{p}  ~\\\\textrm{d}V \\\\, ,\\n        \\\\\\\\\\n        D_{d \\\\widetilde{J}} R( \\\\mathbf{\\\\Xi}; \\\\delta \\\\mathbf{\\\\Xi})\\n        &=  -\\\\int_{\\\\Omega_0} \\\\delta \\\\widetilde{p} d \\\\widetilde{J}~\\\\textrm{d}V\\n         + \\\\int_{\\\\Omega_0} \\\\delta \\\\widetilde{J}  \\\\dfrac{\\\\textrm{d}^2 \\\\Psi_{\\\\textrm{vol}}(\\\\widetilde{J})}{\\\\textrm{d} \\\\widetilde{J}\\\\textrm{d}\\\\widetilde{J}} d \\\\widetilde{J} ~\\\\textrm{d}V \\\\, .\\n\\\\end{align*}\\n\\nNote that the following terms are termed the geometrical stress and the material contributions to the tangent matrix:          \\n\\\\begin{align*}\\n& \\\\int_{\\\\Omega_0} \\\\textrm{grad}\\\\ \\\\delta \\\\mathbf{u} :\\n                        \\\\textrm{grad}\\\\ d \\\\mathbf{u} [\\\\boldsymbol{\\\\tau}_{\\\\textrm{iso}} +  \\\\boldsymbol{\\\\tau}_{\\\\textrm{vol}}]~\\\\textrm{d}V\\n                        && \\\\quad {[\\\\textrm{Geometrical stress}]} \\\\, ,\\n                \\\\\\\\\\n& \\\\int_{\\\\Omega_0} \\\\textrm{grad} \\\\delta \\\\mathbf{u} :\\n                        [J\\\\mathfrak{c}_{\\\\textrm{vol}} + J\\\\mathfrak{c}_{\\\\textrm{iso}}] :\\\\textrm{grad}\\\\ d \\\\mathbf{u}\\n                ~\\\\textrm{d}V\\n                && \\\\quad {[\\\\textrm{Material}]} \\\\, .\\n\\\\end{align*}\\n\\nDiscretization of governing equations \\nThe three-field formulation used here is effective for quasi-incompressible materials, that is where \\\\(\\\\nu \\\\rightarrow 0.5\\\\) (where \\\\(\\\\nu\\\\) is Poisson's ratio), subject to a good choice of the interpolation fields for \\\\(\\\\mathbf{u},~\\\\widetilde{p}\\\\) and \\\\(\\\\widetilde{J}\\\\). Typically a choice of \\\\(Q_n \\\\times DGPM_{n-1} \\\\times DGPM_{n-1}\\\\) is made. Here \\\\(DGPM\\\\) is the FE_DGPMonomial class. A popular choice is \\\\(Q_1 \\\\times DGPM_0 \\\\times DGPM_0\\\\) which is known as the mean dilatation method (see Hughes (2000) for an intuitive discussion). This code can accommodate a \\\\(Q_n \\\\times DGPM_{n-1} \\\\times DGPM_{n-1}\\\\) formulation. The discontinuous approximation allows \\\\(\\\\widetilde{p}\\\\) and \\\\(\\\\widetilde{J}\\\\) to be condensed out and a classical displacement based method is recovered.\\nFor fully-incompressible materials \\\\(\\\\nu = 0.5\\\\) and the three-field formulation will still exhibit locking behavior. This can be overcome by introducing an additional constraint into the free energy of the form \\\\(\\\\int_{\\\\Omega_0} \\\\Lambda [ \\\\widetilde{J} - 1]~\\\\textrm{d}V\\\\). Here \\\\(\\\\Lambda\\\\) is a Lagrange multiplier to enforce the isochoric constraint. For further details see Miehe (1994).\\nThe linearised problem can be written as     \\n\\\\[\\n        \\\\mathbf{\\\\mathsf{K}}( \\\\mathbf{\\\\Xi}_{\\\\textrm{i}}) d\\\\mathbf{\\\\Xi}\\n        =\\n        \\\\mathbf{ \\\\mathsf{F}}(\\\\mathbf{\\\\Xi}_{\\\\textrm{i}})\\n\\\\]\\n\\n where                          \\n\\\\begin{align*}\\n                \\\\underbrace{\\\\begin{bmatrix}\\n                        \\\\mathbf{\\\\mathsf{K}}_{uu}        &       \\\\mathbf{\\\\mathsf{K}}_{u\\\\widetilde{p}}    & \\\\mathbf{0}\\n                        \\\\\\\\\\n                        \\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{p}u}    &       \\\\mathbf{0}      &       \\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{p}\\\\widetilde{J}}\\n                        \\\\\\\\\\n                        \\\\mathbf{0}      &       \\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{J}\\\\widetilde{p}}                & \\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{J}\\\\widetilde{J}}\\n                \\\\end{bmatrix}}_{\\\\mathbf{\\\\mathsf{K}}(\\\\mathbf{\\\\Xi}_{\\\\textrm{i}})}\\n                \\\\underbrace{\\\\begin{bmatrix}\\n                        d \\\\mathbf{\\\\mathsf{u}}\\\\\\\\\\n            d \\\\widetilde{\\\\mathbf{\\\\mathsf{p}}} \\\\\\\\\\n            d \\\\widetilde{\\\\mathbf{\\\\mathsf{J}}}\\n                \\\\end{bmatrix}}_{d \\\\mathbf{\\\\Xi}}\\n        =\\n        \\\\underbrace{\\\\begin{bmatrix}\\n                        -\\\\mathbf{\\\\mathsf{R}}_{u}(\\\\mathbf{u}_{\\\\textrm{i}}) \\\\\\\\\\n            -\\\\mathbf{\\\\mathsf{R}}_{\\\\widetilde{p}}(\\\\widetilde{p}_{\\\\textrm{i}}) \\\\\\\\\\n           -\\\\mathbf{\\\\mathsf{R}}_{\\\\widetilde{J}}(\\\\widetilde{J}_{\\\\textrm{i}})\\n                \\\\end{bmatrix}}_{ -\\\\mathbf{\\\\mathsf{R}}(\\\\mathbf{\\\\Xi}_{\\\\textrm{i}}) }\\n=\\n        \\\\underbrace{\\\\begin{bmatrix}\\n                        \\\\mathbf{\\\\mathsf{F}}_{u}(\\\\mathbf{u}_{\\\\textrm{i}}) \\\\\\\\\\n            \\\\mathbf{\\\\mathsf{F}}_{\\\\widetilde{p}}(\\\\widetilde{p}_{\\\\textrm{i}}) \\\\\\\\\\n           \\\\mathbf{\\\\mathsf{F}}_{\\\\widetilde{J}}(\\\\widetilde{J}_{\\\\textrm{i}})\\n                \\\\end{bmatrix}}_{ \\\\mathbf{\\\\mathsf{F}}(\\\\mathbf{\\\\Xi}_{\\\\textrm{i}}) } \\\\, .\\n\\\\end{align*}\\n\\nThere are no derivatives of the pressure and dilatation (primary) variables present in the formulation. Thus the discontinuous finite element interpolation of the pressure and dilatation yields a block diagonal matrix for \\\\(\\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{p}\\\\widetilde{J}}\\\\), \\\\(\\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{J}\\\\widetilde{p}}\\\\) and \\\\(\\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{J}\\\\widetilde{J}}\\\\). Therefore we can easily express the fields \\\\(\\\\widetilde{p}\\\\) and \\\\(\\\\widetilde{J}\\\\) on each cell simply by inverting a local matrix and multiplying it by the local right hand side. We can then insert the result into the remaining equations and recover a classical displacement-based method. In order to condense out the pressure and dilatation contributions at the element level we need the following results:                  \\n\\\\begin{align*}\\n                d \\\\widetilde{\\\\mathbf{\\\\mathsf{p}}}\\n                & = \\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{J}\\\\widetilde{p}}^{-1} \\\\bigl[\\n                         \\\\mathbf{\\\\mathsf{F}}_{\\\\widetilde{J}}\\n                         - \\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{J}\\\\widetilde{J}} d \\\\widetilde{\\\\mathbf{\\\\mathsf{J}}} \\\\bigr]\\n                        \\\\\\\\\\n                d \\\\widetilde{\\\\mathbf{\\\\mathsf{J}}}\\n                & = \\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{p}\\\\widetilde{J}}^{-1} \\\\bigl[\\n                        \\\\mathbf{\\\\mathsf{F}}_{\\\\widetilde{p}}\\n                        - \\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{p}u} d \\\\mathbf{\\\\mathsf{u}}\\n                        \\\\bigr]\\n                \\\\\\\\\\n                 \\\\Rightarrow d \\\\widetilde{\\\\mathbf{\\\\mathsf{p}}}\\n                &=  \\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{J}\\\\widetilde{p}}^{-1} \\\\mathbf{\\\\mathsf{F}}_{\\\\widetilde{J}}\\n                - \\\\underbrace{\\\\bigl[\\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{J}\\\\widetilde{p}}^{-1} \\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{J}\\\\widetilde{J}}\\n                \\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{p}\\\\widetilde{J}}^{-1}\\\\bigr]}_{\\\\overline{\\\\mathbf{\\\\mathsf{K}}}}\\\\bigl[ \\\\mathbf{\\\\mathsf{F}}_{\\\\widetilde{p}}\\n                - \\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{p}u} d \\\\mathbf{\\\\mathsf{u}} \\\\bigr]\\n\\\\end{align*}\\n\\n and thus           \\n\\\\[\\n                \\\\underbrace{\\\\bigl[ \\\\mathbf{\\\\mathsf{K}}_{uu} + \\\\overline{\\\\overline{\\\\mathbf{\\\\mathsf{K}}}}~ \\\\bigr]\\n                }_{\\\\mathbf{\\\\mathsf{K}}_{\\\\textrm{con}}} d \\\\mathbf{\\\\mathsf{u}}\\n                =\\n        \\\\underbrace{\\n                \\\\Bigl[\\n                \\\\mathbf{\\\\mathsf{F}}_{u}\\n                        - \\\\mathbf{\\\\mathsf{K}}_{u\\\\widetilde{p}} \\\\bigl[ \\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{J}\\\\widetilde{p}}^{-1} \\\\mathbf{\\\\mathsf{F}}_{\\\\widetilde{J}}\\n                        - \\\\overline{\\\\mathbf{\\\\mathsf{K}}}\\\\mathbf{\\\\mathsf{F}}_{\\\\widetilde{p}} \\\\bigr]\\n                \\\\Bigr]}_{\\\\mathbf{\\\\mathsf{F}}_{\\\\textrm{con}}}\\n\\\\]\\n\\n where    \\n\\\\[\\n                \\\\overline{\\\\overline{\\\\mathbf{\\\\mathsf{K}}}} \\\\dealcoloneq\\n                        \\\\mathbf{\\\\mathsf{K}}_{u\\\\widetilde{p}} \\\\overline{\\\\mathbf{\\\\mathsf{K}}} \\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{p}u} \\\\, .\\n\\\\]\\n\\n Note that due to the choice of \\\\(\\\\widetilde{p}\\\\) and \\\\(\\\\widetilde{J}\\\\) as discontinuous at the element level, all matrices that need to be inverted are defined at the element level.\\nThe procedure to construct the various contributions is as follows:\\nConstruct \\\\(\\\\mathbf{\\\\mathsf{K}}\\\\).\\nForm \\\\(\\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{p}\\\\widetilde{J}}^{-1}\\\\) for element and store where \\\\(\\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{p}\\\\widetilde{J}}\\\\) was stored in \\\\(\\\\mathbf{\\\\mathsf{K}}\\\\).\\nForm \\\\(\\\\overline{\\\\overline{\\\\mathbf{\\\\mathsf{K}}}}\\\\) and add to \\\\(\\\\mathbf{\\\\mathsf{K}}_{uu}\\\\) to get \\\\(\\\\mathbf{\\\\mathsf{K}}_{\\\\textrm{con}}\\\\)\\nThe modified system matrix is called \\\\({\\\\mathbf{\\\\mathsf{K}}}_{\\\\textrm{store}}\\\\). That is           \\n\\\\[\\n        \\\\mathbf{\\\\mathsf{K}}_{\\\\textrm{store}}\\n\\\\dealcoloneq\\n        \\\\begin{bmatrix}\\n                        \\\\mathbf{\\\\mathsf{K}}_{\\\\textrm{con}}      &       \\\\mathbf{\\\\mathsf{K}}_{u\\\\widetilde{p}}    & \\\\mathbf{0}\\n                        \\\\\\\\\\n                        \\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{p}u}    &       \\\\mathbf{0}      &       \\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{p}\\\\widetilde{J}}^{-1}\\n                        \\\\\\\\\\n                        \\\\mathbf{0}      &       \\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{J}\\\\widetilde{p}}                & \\\\mathbf{\\\\mathsf{K}}_{\\\\widetilde{J}\\\\widetilde{J}}\\n                \\\\end{bmatrix} \\\\, .\\n  \\\\]\\n\\n\\n\\nThe material class \\nA good object-oriented design of a Material class would facilitate the extension of this tutorial to a wide range of material types. In this tutorial we simply have one Material class named Material_Compressible_Neo_Hook_Three_Field. Ideally this class would derive from a class HyperelasticMaterial which would derive from the base class Material. The three-field nature of the formulation used here also complicates the matter.\\nThe Helmholtz free energy function for the three field formulation is \\\\(\\\\Psi = \\\\Psi_\\\\text{vol}(\\\\widetilde{J}) + \\\\Psi_\\\\text{iso}(\\\\overline{\\\\mathbf{b}})\\\\). The isochoric part of the Kirchhoff stress \\\\({\\\\boldsymbol{\\\\tau}}_{\\\\text{iso}}(\\\\overline{\\\\mathbf{b}})\\\\) is identical to that obtained using a one-field formulation for a hyperelastic material. However, the volumetric part of the free energy is now a function of the primary variable \\\\(\\\\widetilde{J}\\\\). Thus, for a three field formulation the constitutive response for the volumetric part of the Kirchhoff stress \\\\({\\\\boldsymbol{\\\\tau}}_{\\\\text{vol}}\\\\) (and the tangent) is not given by the hyperelastic constitutive law as in a one-field formulation. One can label the term \\\\(\\\\boldsymbol{\\\\tau}_{\\\\textrm{vol}} \\\\equiv \\\\widetilde{p} J \\\\mathbf{I}\\\\) as the volumetric Kirchhoff stress, but the pressure \\\\(\\\\widetilde{p}\\\\) is not derived from the free energy; it is a primary field.\\nIn order to have a flexible approach, it was decided that the Material_Compressible_Neo_Hook_Three_Field would still be able to calculate and return a volumetric Kirchhoff stress and tangent. In order to do this, we choose to store the interpolated primary fields \\\\(\\\\widetilde{p}\\\\) and \\\\(\\\\widetilde{J}\\\\) in the Material_Compressible_Neo_Hook_Three_Field class associated with the quadrature point. This decision should be revisited at a later stage when the tutorial is extended to account for other materials.\\nNumerical example \\nThe numerical example considered here is a nearly-incompressible block under compression. This benchmark problem is taken from\\nS. Reese, P. Wriggers, B.D. Reddy (2000), A new locking-free brick element technique for large deformation problems in elasticity,  Computers and Structures ,  75 , 291-304. DOI: 10.1016/S0045-7949(99)00137-6\\n\\n\\n\\nThe material is quasi-incompressible neo-Hookean with shear modulus \\\\(\\\\mu = 80.194e6\\\\) and \\\\(\\\\nu = 0.4999\\\\). For such a choice of material properties a conventional single-field \\\\(Q_1\\\\) approach would lock. That is, the response would be overly stiff. The initial and final configurations are shown in the image above. Using symmetry, we solve for only one quarter of the geometry (i.e. a cube with dimension \\\\(0.001\\\\)). The inner-quarter of the upper surface of the domain is subject to a load of \\\\(p_0\\\\).\\n The commented program\\nWe start by including all the necessary deal.II header files and some C++ related ones. They have been discussed in detail in previous tutorial programs, so you need only refer to past tutorials for details.\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/base/parameter_handler.h>\\n\\u00a0 #include <deal.II/base/point.h>\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/symmetric_tensor.h>\\n\\u00a0 #include <deal.II/base/tensor.h>\\n\\u00a0 #include <deal.II/base/timer.h>\\n\\u00a0 #include <deal.II/base/work_stream.h>\\n\\u00a0 #include <deal.II/dofs/dof_renumbering.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\nThis header gives us the functionality to store data at quadrature points\\n\\u00a0 #include <deal.II/base/quadrature_point_data.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_tools.h>\\n\\u00a0 #include <deal.II/grid/grid_in.h>\\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_dgp.h>\\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_system.h>\\n\\u00a0 #include <deal.II/fe/fe_tools.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 #include <deal.II/fe/mapping_q_eulerian.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/block_sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/block_vector.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/precondition_selector.h>\\n\\u00a0 #include <deal.II/lac/solver_cg.h>\\n\\u00a0 #include <deal.II/lac/solver_selector.h>\\n\\u00a0 #include <deal.II/lac/sparse_direct.h>\\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 \\nHere are the headers necessary to use the LinearOperator class. These are also all conveniently packaged into a single header file, namely <deal.II/lac/linear_operator_tools.h> but we list those specifically required here for the sake of transparency.\\n\\u00a0 #include <deal.II/lac/linear_operator.h>\\n\\u00a0 #include <deal.II/lac/packaged_operation.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 \\nlinear_operatorLinearOperator< Range, Domain, Payload > linear_operator(const OperatorExemplar &, const Matrix &)Definition linear_operator.h:1427\\nDefined in these two headers are some operations that are pertinent to finite strain elasticity. The first will help us compute some kinematic quantities, and the second provides some standard tensor definitions.\\n\\u00a0 #include <deal.II/physics/elasticity/kinematics.h>\\n\\u00a0 #include <deal.II/physics/elasticity/standard_tensors.h>\\n\\u00a0 \\n\\u00a0 #include <iostream>\\n\\u00a0 #include <fstream>\\n\\u00a0 \\n\\u00a0 \\nWe then stick everything that relates to this tutorial program into a namespace of its own, and import all the deal.II function and class names into it:\\n\\u00a0 namespace Step44\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n Run-time parameters\\nThere are several parameters that can be set in the code so we set up a ParameterHandler object to read in the choices at run-time.\\n\\u00a0   namespace Parameters\\n\\u00a0   {\\n Finite Element system\\nAs mentioned in the introduction, a different order interpolation should be used for the displacement \\\\(\\\\mathbf{u}\\\\) than for the pressure \\\\(\\\\widetilde{p}\\\\) and the dilatation \\\\(\\\\widetilde{J}\\\\). Choosing \\\\(\\\\widetilde{p}\\\\) and \\\\(\\\\widetilde{J}\\\\) as discontinuous (constant) functions at the element level leads to the mean-dilatation method. The discontinuous approximation allows \\\\(\\\\widetilde{p}\\\\) and \\\\(\\\\widetilde{J}\\\\) to be condensed out and a classical displacement based method is recovered. Here we specify the polynomial order used to approximate the solution. The quadrature order should be adjusted accordingly.\\n\\u00a0     struct FESystem\\n\\u00a0     {\\n\\u00a0       unsigned int poly_degree;\\n\\u00a0       unsigned int quad_order;\\n\\u00a0 \\n\\u00a0       static void declare_parameters(ParameterHandler &prm);\\n\\u00a0 \\n\\u00a0       void parse_parameters(ParameterHandler &prm);\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     void FESystem::declare_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       prm.enter_subsection(\\\"Finite element system\\\");\\n\\u00a0       {\\n\\u00a0         prm.declare_entry(\\\"Polynomial degree\\\",\\n\\u00a0                           \\\"2\\\",\\n\\u00a0                           Patterns::Integer(0),\\n\\u00a0                           \\\"Displacement system polynomial order\\\");\\n\\u00a0 \\n\\u00a0         prm.declare_entry(\\\"Quadrature order\\\",\\n\\u00a0                           \\\"3\\\",\\n\\u00a0                           Patterns::Integer(0),\\n\\u00a0                           \\\"Gauss quadrature order\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     void FESystem::parse_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       prm.enter_subsection(\\\"Finite element system\\\");\\n\\u00a0       {\\n\\u00a0         poly_degree = prm.get_integer(\\\"Polynomial degree\\\");\\n\\u00a0         quad_order  = prm.get_integer(\\\"Quadrature order\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0     }\\n\\u00a0 \\nFESystemDefinition fe_system.h:208\\nParameterHandlerDefinition parameter_handler.h:855\\nParameterHandler::enter_subsectionvoid enter_subsection(const std::string &subsection, const bool create_path_if_needed=true)Definition parameter_handler.cc:991\\nParameterHandler::leave_subsectionvoid leave_subsection()Definition parameter_handler.cc:1015\\nParameterHandler::get_integerlong int get_integer(const std::string &entry_string) constDefinition parameter_handler.cc:1087\\nParameterHandler::declare_entryvoid declare_entry(const std::string &entry, const std::string &default_value, const Patterns::PatternBase &pattern=Patterns::Anything(), const std::string &documentation=\\\"\\\", const bool has_to_be_set=false)Definition parameter_handler.cc:846\\nPatterns::IntegerDefinition patterns.h:188\\n Geometry\\nMake adjustments to the problem geometry and the applied load. Since the problem modelled here is quite specific, the load scale can be altered to specific values to compare with the results given in the literature.\\n\\u00a0     struct Geometry\\n\\u00a0     {\\n\\u00a0       unsigned int global_refinement;\\n\\u00a0       double       scale;\\n\\u00a0       double       p_p0;\\n\\u00a0 \\n\\u00a0       static void declare_parameters(ParameterHandler &prm);\\n\\u00a0 \\n\\u00a0       void parse_parameters(ParameterHandler &prm);\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     void Geometry::declare_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       prm.enter_subsection(\\\"Geometry\\\");\\n\\u00a0       {\\n\\u00a0         prm.declare_entry(\\\"Global refinement\\\",\\n\\u00a0                           \\\"2\\\",\\n\\u00a0                           Patterns::Integer(0),\\n\\u00a0                           \\\"Global refinement level\\\");\\n\\u00a0 \\n\\u00a0         prm.declare_entry(\\\"Grid scale\\\",\\n\\u00a0                           \\\"1e-3\\\",\\n\\u00a0                           Patterns::Double(0.0),\\n\\u00a0                           \\\"Global grid scaling factor\\\");\\n\\u00a0 \\n\\u00a0         prm.declare_entry(\\\"Pressure ratio p/p0\\\",\\n\\u00a0                           \\\"100\\\",\\n\\u00a0                           Patterns::Selection(\\\"20|40|60|80|100\\\"),\\n\\u00a0                           \\\"Ratio of applied pressure to reference pressure\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     void Geometry::parse_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       prm.enter_subsection(\\\"Geometry\\\");\\n\\u00a0       {\\n\\u00a0         global_refinement = prm.get_integer(\\\"Global refinement\\\");\\n\\u00a0         scale             = prm.get_double(\\\"Grid scale\\\");\\n\\u00a0         p_p0              = prm.get_double(\\\"Pressure ratio p/p0\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0     }\\n\\u00a0 \\nParameterHandler::get_doubledouble get_double(const std::string &entry_name) constDefinition parameter_handler.cc:1130\\nPatterns::DoubleDefinition patterns.h:291\\nPatterns::SelectionDefinition patterns.h:381\\nGridTools::scalevoid scale(const double scaling_factor, Triangulation< dim, spacedim > &triangulation)Definition grid_tools.cc:256\\n Materials\\nWe also need the shear modulus \\\\( \\\\mu \\\\) and Poisson ration \\\\( \\\\nu \\\\) for the neo-Hookean material.\\n\\u00a0     struct Materials\\n\\u00a0     {\\n\\u00a0       double nu;\\n\\u00a0       double mu;\\n\\u00a0 \\n\\u00a0       static void declare_parameters(ParameterHandler &prm);\\n\\u00a0 \\n\\u00a0       void parse_parameters(ParameterHandler &prm);\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     void Materials::declare_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       prm.enter_subsection(\\\"Material properties\\\");\\n\\u00a0       {\\n\\u00a0         prm.declare_entry(\\\"Poisson's ratio\\\",\\n\\u00a0                           \\\"0.4999\\\",\\n\\u00a0                           Patterns::Double(-1.0, 0.5),\\n\\u00a0                           \\\"Poisson's ratio\\\");\\n\\u00a0 \\n\\u00a0         prm.declare_entry(\\\"Shear modulus\\\",\\n\\u00a0                           \\\"80.194e6\\\",\\n\\u00a0                           Patterns::Double(),\\n\\u00a0                           \\\"Shear modulus\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     void Materials::parse_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       prm.enter_subsection(\\\"Material properties\\\");\\n\\u00a0       {\\n\\u00a0         nu = prm.get_double(\\\"Poisson's ratio\\\");\\n\\u00a0         mu = prm.get_double(\\\"Shear modulus\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0     }\\n\\u00a0 \\n Linear solver\\nNext, we choose both solver and preconditioner settings. The use of an effective preconditioner is critical to ensure convergence when a large nonlinear motion occurs within a Newton increment.\\n\\u00a0     struct LinearSolver\\n\\u00a0     {\\n\\u00a0       std::string type_lin;\\n\\u00a0       double      tol_lin;\\n\\u00a0       double      max_iterations_lin;\\n\\u00a0       bool        use_static_condensation;\\n\\u00a0       std::string preconditioner_type;\\n\\u00a0       double      preconditioner_relaxation;\\n\\u00a0 \\n\\u00a0       static void declare_parameters(ParameterHandler &prm);\\n\\u00a0 \\n\\u00a0       void parse_parameters(ParameterHandler &prm);\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     void LinearSolver::declare_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       prm.enter_subsection(\\\"Linear solver\\\");\\n\\u00a0       {\\n\\u00a0         prm.declare_entry(\\\"Solver type\\\",\\n\\u00a0                           \\\"CG\\\",\\n\\u00a0                           Patterns::Selection(\\\"CG|Direct\\\"),\\n\\u00a0                           \\\"Type of solver used to solve the linear system\\\");\\n\\u00a0 \\n\\u00a0         prm.declare_entry(\\\"Residual\\\",\\n\\u00a0                           \\\"1e-6\\\",\\n\\u00a0                           Patterns::Double(0.0),\\n\\u00a0                           \\\"Linear solver residual (scaled by residual norm)\\\");\\n\\u00a0 \\n\\u00a0         prm.declare_entry(\\n\\u00a0           \\\"Max iteration multiplier\\\",\\n\\u00a0           \\\"1\\\",\\n\\u00a0           Patterns::Double(0.0),\\n\\u00a0           \\\"Linear solver iterations (multiples of the system matrix size)\\\");\\n\\u00a0 \\n\\u00a0         prm.declare_entry(\\\"Use static condensation\\\",\\n\\u00a0                           \\\"true\\\",\\n\\u00a0                           Patterns::Bool(),\\n\\u00a0                           \\\"Solve the full block system or a reduced problem\\\");\\n\\u00a0 \\n\\u00a0         prm.declare_entry(\\\"Preconditioner type\\\",\\n\\u00a0                           \\\"ssor\\\",\\n\\u00a0                           Patterns::Selection(\\\"jacobi|ssor\\\"),\\n\\u00a0                           \\\"Type of preconditioner\\\");\\n\\u00a0 \\n\\u00a0         prm.declare_entry(\\\"Preconditioner relaxation\\\",\\n\\u00a0                           \\\"0.65\\\",\\n\\u00a0                           Patterns::Double(0.0),\\n\\u00a0                           \\\"Preconditioner relaxation value\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     void LinearSolver::parse_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       prm.enter_subsection(\\\"Linear solver\\\");\\n\\u00a0       {\\n\\u00a0         type_lin                  = prm.get(\\\"Solver type\\\");\\n\\u00a0         tol_lin                   = prm.get_double(\\\"Residual\\\");\\n\\u00a0         max_iterations_lin        = prm.get_double(\\\"Max iteration multiplier\\\");\\n\\u00a0         use_static_condensation   = prm.get_bool(\\\"Use static condensation\\\");\\n\\u00a0         preconditioner_type       = prm.get(\\\"Preconditioner type\\\");\\n\\u00a0         preconditioner_relaxation = prm.get_double(\\\"Preconditioner relaxation\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0     }\\n\\u00a0 \\nParameterHandler::get_boolbool get_bool(const std::string &entry_name) constDefinition parameter_handler.cc:1175\\nParameterHandler::getstd::string get(const std::string &entry_string) constDefinition parameter_handler.cc:1049\\nPatterns::BoolDefinition patterns.h:980\\n Nonlinear solver\\nA Newton-Raphson scheme is used to solve the nonlinear system of governing equations. We now define the tolerances and the maximum number of iterations for the Newton-Raphson nonlinear solver.\\n\\u00a0     struct NonlinearSolver\\n\\u00a0     {\\n\\u00a0       unsigned int max_iterations_NR;\\n\\u00a0       double       tol_f;\\n\\u00a0       double       tol_u;\\n\\u00a0 \\n\\u00a0       static void declare_parameters(ParameterHandler &prm);\\n\\u00a0 \\n\\u00a0       void parse_parameters(ParameterHandler &prm);\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     void NonlinearSolver::declare_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       prm.enter_subsection(\\\"Nonlinear solver\\\");\\n\\u00a0       {\\n\\u00a0         prm.declare_entry(\\\"Max iterations Newton-Raphson\\\",\\n\\u00a0                           \\\"10\\\",\\n\\u00a0                           Patterns::Integer(0),\\n\\u00a0                           \\\"Number of Newton-Raphson iterations allowed\\\");\\n\\u00a0 \\n\\u00a0         prm.declare_entry(\\\"Tolerance force\\\",\\n\\u00a0                           \\\"1.0e-9\\\",\\n\\u00a0                           Patterns::Double(0.0),\\n\\u00a0                           \\\"Force residual tolerance\\\");\\n\\u00a0 \\n\\u00a0         prm.declare_entry(\\\"Tolerance displacement\\\",\\n\\u00a0                           \\\"1.0e-6\\\",\\n\\u00a0                           Patterns::Double(0.0),\\n\\u00a0                           \\\"Displacement error tolerance\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     void NonlinearSolver::parse_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       prm.enter_subsection(\\\"Nonlinear solver\\\");\\n\\u00a0       {\\n\\u00a0         max_iterations_NR = prm.get_integer(\\\"Max iterations Newton-Raphson\\\");\\n\\u00a0         tol_f             = prm.get_double(\\\"Tolerance force\\\");\\n\\u00a0         tol_u             = prm.get_double(\\\"Tolerance displacement\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0     }\\n\\u00a0 \\n Time\\nSet the timestep size \\\\( \\\\varDelta t \\\\) and the simulation end-time.\\n\\u00a0     struct Time\\n\\u00a0     {\\n\\u00a0       double delta_t;\\n\\u00a0       double end_time;\\n\\u00a0 \\n\\u00a0       static void declare_parameters(ParameterHandler &prm);\\n\\u00a0 \\n\\u00a0       void parse_parameters(ParameterHandler &prm);\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     void Time::declare_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       prm.enter_subsection(\\\"Time\\\");\\n\\u00a0       {\\n\\u00a0         prm.declare_entry(\\\"End time\\\", \\\"1\\\", Patterns::Double(), \\\"End time\\\");\\n\\u00a0 \\n\\u00a0         prm.declare_entry(\\\"Time step size\\\",\\n\\u00a0                           \\\"0.1\\\",\\n\\u00a0                           Patterns::Double(),\\n\\u00a0                           \\\"Time step size\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     void Time::parse_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       prm.enter_subsection(\\\"Time\\\");\\n\\u00a0       {\\n\\u00a0         end_time = prm.get_double(\\\"End time\\\");\\n\\u00a0         delta_t  = prm.get_double(\\\"Time step size\\\");\\n\\u00a0       }\\n\\u00a0       prm.leave_subsection();\\n\\u00a0     }\\n\\u00a0 \\n All parameters\\nFinally we consolidate all of the above structures into a single container that holds all of our run-time selections.\\n\\u00a0     struct AllParameters : public FESystem,\\n\\u00a0                            public Geometry,\\n\\u00a0                            public Materials,\\n\\u00a0                            public LinearSolver,\\n\\u00a0                            public NonlinearSolver,\\n\\u00a0                            public Time\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       AllParameters(const std::string &input_file);\\n\\u00a0 \\n\\u00a0       static void declare_parameters(ParameterHandler &prm);\\n\\u00a0 \\n\\u00a0       void parse_parameters(ParameterHandler &prm);\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     AllParameters::AllParameters(const std::string &input_file)\\n\\u00a0     {\\n\\u00a0       ParameterHandler prm;\\n\\u00a0       declare_parameters(prm);\\n\\u00a0       prm.parse_input(input_file);\\n\\u00a0       parse_parameters(prm);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     void AllParameters::declare_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       FESystem::declare_parameters(prm);\\n\\u00a0       Geometry::declare_parameters(prm);\\n\\u00a0       Materials::declare_parameters(prm);\\n\\u00a0       LinearSolver::declare_parameters(prm);\\n\\u00a0       NonlinearSolver::declare_parameters(prm);\\n\\u00a0       Time::declare_parameters(prm);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     void AllParameters::parse_parameters(ParameterHandler &prm)\\n\\u00a0     {\\n\\u00a0       FESystem::parse_parameters(prm);\\n\\u00a0       Geometry::parse_parameters(prm);\\n\\u00a0       Materials::parse_parameters(prm);\\n\\u00a0       LinearSolver::parse_parameters(prm);\\n\\u00a0       NonlinearSolver::parse_parameters(prm);\\n\\u00a0       Time::parse_parameters(prm);\\n\\u00a0     }\\n\\u00a0   } // namespace Parameters\\n\\u00a0 \\n Time class\\nA simple class to store time data. Its functioning is transparent so no discussion is necessary. For simplicity we assume a constant time step size.\\n\\u00a0   class Time\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     Time(const double time_end, const double delta_t)\\n\\u00a0       : timestep(0)\\n\\u00a0       , time_current(0.0)\\n\\u00a0       , time_end(time_end)\\n\\u00a0       , delta_t(delta_t)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     virtual ~Time() = default;\\n\\u00a0 \\n\\u00a0     double current() const\\n\\u00a0     {\\n\\u00a0       return time_current;\\n\\u00a0     }\\n\\u00a0     double end() const\\n\\u00a0     {\\n\\u00a0       return time_end;\\n\\u00a0     }\\n\\u00a0     double get_delta_t() const\\n\\u00a0     {\\n\\u00a0       return delta_t;\\n\\u00a0     }\\n\\u00a0     unsigned int get_timestep() const\\n\\u00a0     {\\n\\u00a0       return timestep;\\n\\u00a0     }\\n\\u00a0     void increment()\\n\\u00a0     {\\n\\u00a0       time_current += delta_t;\\n\\u00a0       ++timestep;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     unsigned int timestep;\\n\\u00a0     double       time_current;\\n\\u00a0     const double time_end;\\n\\u00a0     const double delta_t;\\n\\u00a0   };\\n\\u00a0 \\n Compressible neo-Hookean material within a three-field formulation\\nAs discussed in the Introduction, Neo-Hookean materials are a type of hyperelastic materials. The entire domain is assumed to be composed of a compressible neo-Hookean material. This class defines the behavior of this material within a three-field formulation. Compressible neo-Hookean materials can be described by a strain-energy function (SEF)   \\\\( \\\\Psi =\\n   \\\\Psi_{\\\\text{iso}}(\\\\overline{\\\\mathbf{b}}) + \\\\Psi_{\\\\text{vol}}(\\\\widetilde{J})\\n   \\\\).\\nThe isochoric response is given by  \\\\(\\n   \\\\Psi_{\\\\text{iso}}(\\\\overline{\\\\mathbf{b}}) = c_{1} [\\\\overline{I}_{1} - 3] \\\\) where \\\\( c_{1} = \\\\frac{\\\\mu}{2} \\\\) and \\\\(\\\\overline{I}_{1}\\\\) is the first invariant of the left- or right-isochoric Cauchy-Green deformation tensors. That is \\\\(\\\\overline{I}_1 \\\\dealcoloneq \\\\textrm{tr}(\\\\overline{\\\\mathbf{b}})\\\\). In this example the SEF that governs the volumetric response is defined as  \\\\( \\\\Psi_{\\\\text{vol}}(\\\\widetilde{J}) = \\\\kappa \\\\frac{1}{4} [ \\\\widetilde{J}^2 -\\n   1 - 2\\\\textrm{ln}\\\\; \\\\widetilde{J} ]\\\\), where  \\\\(\\\\kappa \\\\dealcoloneq \\\\lambda +\\n   2/3 \\\\mu\\\\) is the bulk modulus and \\\\(\\\\lambda\\\\) is Lam\\u00e9's first parameter.\\nThe following class will be used to characterize the material we work with, and provides a central point that one would need to modify if one were to implement a different material model. For it to work, we will store one object of this type per quadrature point, and in each of these objects store the current state (characterized by the values or measures of the three fields) so that we can compute the elastic coefficients linearized around the current state.\\n\\u00a0   template <int dim>\\n\\u00a0   class Material_Compressible_Neo_Hook_Three_Field\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     Material_Compressible_Neo_Hook_Three_Field(const double mu, const double nu)\\n\\u00a0       : kappa((2.0 * mu * (1.0 + nu)) / (3.0 * (1.0 - 2.0 * nu)))\\n\\u00a0       , c_1(mu / 2.0)\\n\\u00a0       , det_F(1.0)\\n\\u00a0       , p_tilde(0.0)\\n\\u00a0       , J_tilde(1.0)\\n\\u00a0       , b_bar(Physics::Elasticity::StandardTensors<dim>::I)\\n\\u00a0     {\\n\\u00a0       Assert(kappa > 0, ExcInternalError());\\n\\u00a0     }\\n\\u00a0 \\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\nPhysicsDefinition physics.h:28\\nWe update the material model with various deformation dependent data based on \\\\(F\\\\) and the pressure \\\\(\\\\widetilde{p}\\\\) and dilatation \\\\(\\\\widetilde{J}\\\\), and at the end of the function include a physical check for internal consistency:\\n\\u00a0     void update_material_data(const Tensor<2, dim> &F,\\n\\u00a0                               const double          p_tilde_in,\\n\\u00a0                               const double          J_tilde_in)\\n\\u00a0     {\\n\\u00a0       det_F                      = determinant(F);\\n\\u00a0       const Tensor<2, dim> F_bar = Physics::Elasticity::Kinematics::F_iso(F);\\n\\u00a0       b_bar                      = Physics::Elasticity::Kinematics::b(F_bar);\\n\\u00a0       p_tilde                    = p_tilde_in;\\n\\u00a0       J_tilde                    = J_tilde_in;\\n\\u00a0 \\n\\u00a0       Assert(det_F > 0, ExcInternalError());\\n\\u00a0     }\\n\\u00a0 \\nTensorDefinition tensor.h:471\\nPhysics::Elasticity::Kinematics::F_isoTensor< 2, dim, Number > F_iso(const Tensor< 2, dim, Number > &F)\\nPhysics::Elasticity::Kinematics::bSymmetricTensor< 2, dim, Number > b(const Tensor< 2, dim, Number > &F)\\ndeterminantDEAL_II_HOST constexpr Number determinant(const SymmetricTensor< 2, dim, Number > &)Definition symmetric_tensor.h:2724\\nThe second function determines the Kirchhoff stress  \\\\(\\\\boldsymbol{\\\\tau}\\n   = \\\\boldsymbol{\\\\tau}_{\\\\textrm{iso}} + \\\\boldsymbol{\\\\tau}_{\\\\textrm{vol}}\\\\)\\n\\u00a0     SymmetricTensor<2, dim> get_tau()\\n\\u00a0     {\\n\\u00a0       return get_tau_iso() + get_tau_vol();\\n\\u00a0     }\\n\\u00a0 \\nSymmetricTensorDefinition symmetric_tensor.h:719\\nThe fourth-order elasticity tensor in the spatial setting \\\\(\\\\mathfrak{c}\\\\) is calculated from the SEF \\\\(\\\\Psi\\\\) as  \\\\( J\\n   \\\\mathfrak{c}_{ijkl} = F_{iA} F_{jB} \\\\mathfrak{C}_{ABCD} F_{kC} F_{lD}\\\\) where  \\\\( \\\\mathfrak{C} = 4 \\\\frac{\\\\partial^2 \\\\Psi(\\\\mathbf{C})}{\\\\partial\\n   \\\\mathbf{C} \\\\partial \\\\mathbf{C}}\\\\)\\n\\u00a0     SymmetricTensor<4, dim> get_Jc() const\\n\\u00a0     {\\n\\u00a0       return get_Jc_vol() + get_Jc_iso();\\n\\u00a0     }\\n\\u00a0 \\nDerivative of the volumetric free energy with respect to \\\\(\\\\widetilde{J}\\\\) return  \\\\(\\\\frac{\\\\partial\\n   \\\\Psi_{\\\\text{vol}}(\\\\widetilde{J})}{\\\\partial \\\\widetilde{J}}\\\\)\\n\\u00a0     double get_dPsi_vol_dJ() const\\n\\u00a0     {\\n\\u00a0       return (kappa / 2.0) * (J_tilde - 1.0 / J_tilde);\\n\\u00a0     }\\n\\u00a0 \\nSecond derivative of the volumetric free energy wrt \\\\(\\\\widetilde{J}\\\\). We need the following computation explicitly in the tangent so we make it public. We calculate   \\\\(\\\\frac{\\\\partial^2\\n   \\\\Psi_{\\\\textrm{vol}}(\\\\widetilde{J})}{\\\\partial \\\\widetilde{J} \\\\partial\\n   \\\\widetilde{J}}\\\\)\\n\\u00a0     double get_d2Psi_vol_dJ2() const\\n\\u00a0     {\\n\\u00a0       return ((kappa / 2.0) * (1.0 + 1.0 / (J_tilde * J_tilde)));\\n\\u00a0     }\\n\\u00a0 \\nThe next few functions return various data that we choose to store with the material:\\n\\u00a0     double get_det_F() const\\n\\u00a0     {\\n\\u00a0       return det_F;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     double get_p_tilde() const\\n\\u00a0     {\\n\\u00a0       return p_tilde;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     double get_J_tilde() const\\n\\u00a0     {\\n\\u00a0       return J_tilde;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   protected:\\nDefine constitutive model parameters \\\\(\\\\kappa\\\\) (bulk modulus) and the neo-Hookean model parameter \\\\(c_1\\\\):\\n\\u00a0     const double kappa;\\n\\u00a0     const double c_1;\\n\\u00a0 \\nModel specific data that is convenient to store with the material:\\n\\u00a0     double                  det_F;\\n\\u00a0     double                  p_tilde;\\n\\u00a0     double                  J_tilde;\\n\\u00a0     SymmetricTensor<2, dim> b_bar;\\n\\u00a0 \\nThe following functions are used internally in determining the result of some of the public functions above. The first one determines the volumetric Kirchhoff stress \\\\(\\\\boldsymbol{\\\\tau}_{\\\\textrm{vol}}\\\\):\\n\\u00a0     SymmetricTensor<2, dim> get_tau_vol() const\\n\\u00a0     {\\n\\u00a0       return p_tilde * det_F * Physics::Elasticity::StandardTensors<dim>::I;\\n\\u00a0     }\\n\\u00a0 \\nPhysics::Elasticity::StandardTensorsDefinition standard_tensors.h:45\\nNext, determine the isochoric Kirchhoff stress  \\\\(\\\\boldsymbol{\\\\tau}_{\\\\textrm{iso}} =\\n   \\\\mathcal{P}:\\\\overline{\\\\boldsymbol{\\\\tau}}\\\\):\\n\\u00a0     SymmetricTensor<2, dim> get_tau_iso() const\\n\\u00a0     {\\n\\u00a0       return Physics::Elasticity::StandardTensors<dim>::dev_P * get_tau_bar();\\n\\u00a0     }\\n\\u00a0 \\nThen, determine the fictitious Kirchhoff stress \\\\(\\\\overline{\\\\boldsymbol{\\\\tau}}\\\\):\\n\\u00a0     SymmetricTensor<2, dim> get_tau_bar() const\\n\\u00a0     {\\n\\u00a0       return 2.0 * c_1 * b_bar;\\n\\u00a0     }\\n\\u00a0 \\nCalculate the volumetric part of the tangent  \\\\(J\\n   \\\\mathfrak{c}_\\\\textrm{vol}\\\\):\\n\\u00a0     SymmetricTensor<4, dim> get_Jc_vol() const\\n\\u00a0     {\\n\\u00a0       return p_tilde * det_F *\\n\\u00a0              (Physics::Elasticity::StandardTensors<dim>::IxI -\\n\\u00a0               (2.0 * Physics::Elasticity::StandardTensors<dim>::S));\\n\\u00a0     }\\n\\u00a0 \\nCalculate the isochoric part of the tangent  \\\\(J\\n   \\\\mathfrak{c}_\\\\textrm{iso}\\\\):\\n\\u00a0     SymmetricTensor<4, dim> get_Jc_iso() const\\n\\u00a0     {\\n\\u00a0       const SymmetricTensor<2, dim> tau_bar = get_tau_bar();\\n\\u00a0       const SymmetricTensor<2, dim> tau_iso = get_tau_iso();\\n\\u00a0       const SymmetricTensor<4, dim> tau_iso_x_I =\\n\\u00a0         outer_product(tau_iso, Physics::Elasticity::StandardTensors<dim>::I);\\n\\u00a0       const SymmetricTensor<4, dim> I_x_tau_iso =\\n\\u00a0         outer_product(Physics::Elasticity::StandardTensors<dim>::I, tau_iso);\\n\\u00a0       const SymmetricTensor<4, dim> c_bar = get_c_bar();\\n\\u00a0 \\n\\u00a0       return (2.0 / dim) * trace(tau_bar) *\\n\\u00a0                Physics::Elasticity::StandardTensors<dim>::dev_P -\\n\\u00a0              (2.0 / dim) * (tau_iso_x_I + I_x_tau_iso) +\\n\\u00a0              Physics::Elasticity::StandardTensors<dim>::dev_P * c_bar *\\n\\u00a0                Physics::Elasticity::StandardTensors<dim>::dev_P;\\n\\u00a0     }\\n\\u00a0 \\nouter_productDEAL_II_HOST constexpr SymmetricTensor< 4, dim, Number > outer_product(const SymmetricTensor< 2, dim, Number > &t1, const SymmetricTensor< 2, dim, Number > &t2)Definition symmetric_tensor.h:3301\\ntraceDEAL_II_HOST constexpr Number trace(const SymmetricTensor< 2, dim2, Number > &)\\nCalculate the fictitious elasticity tensor \\\\(\\\\overline{\\\\mathfrak{c}}\\\\). For the material model chosen this is simply zero:\\n\\u00a0     SymmetricTensor<4, dim> get_c_bar() const\\n\\u00a0     {\\n\\u00a0       return SymmetricTensor<4, dim>();\\n\\u00a0     }\\n\\u00a0   };\\n\\u00a0 \\n Quadrature point history\\nAs seen in step-18, the  PointHistory  class offers a method for storing data at the quadrature points. Here each quadrature point holds a pointer to a material description. Thus, different material models can be used in different regions of the domain. Among other data, we choose to store the Kirchhoff stress \\\\(\\\\boldsymbol{\\\\tau}\\\\) and the tangent \\\\(J\\\\mathfrak{c}\\\\) for the quadrature points.\\n\\u00a0   template <int dim>\\n\\u00a0   class PointHistory\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     PointHistory()\\n\\u00a0       : F_inv(Physics::Elasticity::StandardTensors<dim>::I)\\n\\u00a0       , tau(SymmetricTensor<2, dim>())\\n\\u00a0       , d2Psi_vol_dJ2(0.0)\\n\\u00a0       , dPsi_vol_dJ(0.0)\\n\\u00a0       , Jc(SymmetricTensor<4, dim>())\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     virtual ~PointHistory() = default;\\n\\u00a0 \\nThe first function is used to create a material object and to initialize all tensors correctly: The second one updates the stored values and stresses based on the current deformation measure \\\\(\\\\textrm{Grad}\\\\mathbf{u}_{\\\\textrm{n}}\\\\), pressure \\\\(\\\\widetilde{p}\\\\) and dilation \\\\(\\\\widetilde{J}\\\\) field values.\\n\\u00a0     void setup_lqp(const Parameters::AllParameters &parameters)\\n\\u00a0     {\\n\\u00a0       material =\\n\\u00a0         std::make_shared<Material_Compressible_Neo_Hook_Three_Field<dim>>(\\n\\u00a0           parameters.mu, parameters.nu);\\n\\u00a0       update_values(Tensor<2, dim>(), 0.0, 1.0);\\n\\u00a0     }\\n\\u00a0 \\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nTo this end, we calculate the deformation gradient \\\\(\\\\mathbf{F}\\\\) from the displacement gradient \\\\(\\\\textrm{Grad}\\\\ \\\\mathbf{u}\\\\), i.e. \\\\(\\\\mathbf{F}(\\\\mathbf{u}) = \\\\mathbf{I} + \\\\textrm{Grad}\\\\ \\\\mathbf{u}\\\\) and then let the material model associated with this quadrature point update itself. When computing the deformation gradient, we have to take care with which data types we compare the sum  \\\\(\\\\mathbf{I} +\\n   \\\\textrm{Grad}\\\\ \\\\mathbf{u}\\\\): Since \\\\(I\\\\) has data type SymmetricTensor, just writing I + Grad_u_n would convert the second argument to a symmetric tensor, perform the sum, and then cast the result to a Tensor (i.e., the type of a possibly nonsymmetric tensor). However, since Grad_u_n is nonsymmetric in general, the conversion to SymmetricTensor will fail. We can avoid this back and forth by converting \\\\(I\\\\) to Tensor first, and then performing the addition as between nonsymmetric tensors:\\n\\u00a0     void update_values(const Tensor<2, dim> &Grad_u_n,\\n\\u00a0                        const double          p_tilde,\\n\\u00a0                        const double          J_tilde)\\n\\u00a0     {\\n\\u00a0       const Tensor<2, dim> F = Physics::Elasticity::Kinematics::F(Grad_u_n);\\n\\u00a0       material->update_material_data(F, p_tilde, J_tilde);\\n\\u00a0 \\nPhysics::Elasticity::Kinematics::FTensor< 2, dim, Number > F(const Tensor< 2, dim, Number > &Grad_u)\\nThe material has been updated so we now calculate the Kirchhoff stress \\\\(\\\\mathbf{\\\\tau}\\\\), the tangent \\\\(J\\\\mathfrak{c}\\\\) and the first and second derivatives of the volumetric free energy.\\nWe also store the inverse of the deformation gradient since we frequently use it:\\n\\u00a0       F_inv         = invert(F);\\n\\u00a0       tau           = material->get_tau();\\n\\u00a0       Jc            = material->get_Jc();\\n\\u00a0       dPsi_vol_dJ   = material->get_dPsi_vol_dJ();\\n\\u00a0       d2Psi_vol_dJ2 = material->get_d2Psi_vol_dJ2();\\n\\u00a0     }\\n\\u00a0 \\ninvertDEAL_II_HOST constexpr SymmetricTensor< 2, dim, Number > invert(const SymmetricTensor< 2, dim, Number > &)Definition symmetric_tensor.h:3250\\nWe offer an interface to retrieve certain data. Here are the kinematic variables:\\n\\u00a0     double get_J_tilde() const\\n\\u00a0     {\\n\\u00a0       return material->get_J_tilde();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     double get_det_F() const\\n\\u00a0     {\\n\\u00a0       return material->get_det_F();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     const Tensor<2, dim> &get_F_inv() const\\n\\u00a0     {\\n\\u00a0       return F_inv;\\n\\u00a0     }\\n\\u00a0 \\n...and the kinetic variables. These are used in the material and global tangent matrix and residual assembly operations:\\n\\u00a0     double get_p_tilde() const\\n\\u00a0     {\\n\\u00a0       return material->get_p_tilde();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     const SymmetricTensor<2, dim> &get_tau() const\\n\\u00a0     {\\n\\u00a0       return tau;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     double get_dPsi_vol_dJ() const\\n\\u00a0     {\\n\\u00a0       return dPsi_vol_dJ;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     double get_d2Psi_vol_dJ2() const\\n\\u00a0     {\\n\\u00a0       return d2Psi_vol_dJ2;\\n\\u00a0     }\\n\\u00a0 \\nAnd finally the tangent:\\n\\u00a0     const SymmetricTensor<4, dim> &get_Jc() const\\n\\u00a0     {\\n\\u00a0       return Jc;\\n\\u00a0     }\\n\\u00a0 \\nIn terms of member functions, this class stores for the quadrature point it represents a copy of a material type in case different materials are used in different regions of the domain, as well as the inverse of the deformation gradient...\\n\\u00a0   private:\\n\\u00a0     std::shared_ptr<Material_Compressible_Neo_Hook_Three_Field<dim>> material;\\n\\u00a0 \\n\\u00a0     Tensor<2, dim> F_inv;\\n\\u00a0 \\n... and stress-type variables along with the tangent \\\\(J\\\\mathfrak{c}\\\\):\\n\\u00a0     SymmetricTensor<2, dim> tau;\\n\\u00a0     double                  d2Psi_vol_dJ2;\\n\\u00a0     double                  dPsi_vol_dJ;\\n\\u00a0 \\n\\u00a0     SymmetricTensor<4, dim> Jc;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n Quasi-static quasi-incompressible finite-strain solid\\nThe Solid class is the central class in that it represents the problem at hand. It follows the usual scheme in that all it really has is a constructor, destructor and a run() function that dispatches all the work to private functions of this class:\\n\\u00a0   template <int dim>\\n\\u00a0   class Solid\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     Solid(const std::string &input_file);\\n\\u00a0 \\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\nIn the private section of this class, we first forward declare a number of objects that are used in parallelizing work using the WorkStream object (see the Parallel computing with multiple processors accessing shared memory topic for more information on this).\\nWe declare such structures for the computation of tangent (stiffness) matrix and right hand side vector, static condensation, and for updating quadrature points:\\n\\u00a0     struct PerTaskData_ASM;\\n\\u00a0     struct ScratchData_ASM;\\n\\u00a0 \\n\\u00a0     struct PerTaskData_SC;\\n\\u00a0     struct ScratchData_SC;\\n\\u00a0 \\n\\u00a0     struct PerTaskData_UQPH;\\n\\u00a0     struct ScratchData_UQPH;\\n\\u00a0 \\nWe start the collection of member functions with one that builds the grid:\\n\\u00a0     void make_grid();\\n\\u00a0 \\nSet up the finite element system to be solved:\\n\\u00a0     void system_setup();\\n\\u00a0 \\n\\u00a0     void determine_component_extractors();\\n\\u00a0 \\nCreate Dirichlet constraints for the incremental displacement field:\\n\\u00a0     void make_constraints(const int it_nr);\\n\\u00a0 \\nSeveral functions to assemble the system and right hand side matrices using multithreading. Each of them comes as a wrapper function, one that is executed to do the work in the WorkStream model on one cell, and one that copies the work done on this one cell into the global object that represents it:\\n\\u00a0     void assemble_system();\\n\\u00a0 \\n\\u00a0     void assemble_system_one_cell(\\n\\u00a0       const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0       ScratchData_ASM                                      &scratch,\\n\\u00a0       PerTaskData_ASM                                      &data) const;\\n\\u00a0 \\nDoFHandler::active_cell_iteratortypename ActiveSelector::active_cell_iterator active_cell_iteratorDefinition dof_handler.h:440\\nAnd similar to perform global static condensation:\\n\\u00a0     void assemble_sc();\\n\\u00a0 \\n\\u00a0     void assemble_sc_one_cell(\\n\\u00a0       const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0       ScratchData_SC                                       &scratch,\\n\\u00a0       PerTaskData_SC                                       &data);\\n\\u00a0 \\n\\u00a0     void copy_local_to_global_sc(const PerTaskData_SC &data);\\n\\u00a0 \\nCreate and update the quadrature points. Here, no data needs to be copied into a global object, so the copy_local_to_global function is empty:\\n\\u00a0     void setup_qph();\\n\\u00a0 \\n\\u00a0     void update_qph_incremental(const BlockVector<double> &solution_delta);\\n\\u00a0 \\n\\u00a0     void update_qph_incremental_one_cell(\\n\\u00a0       const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0       ScratchData_UQPH                                     &scratch,\\n\\u00a0       PerTaskData_UQPH                                     &data);\\n\\u00a0 \\n\\u00a0     void copy_local_to_global_UQPH(const PerTaskData_UQPH & /*data*/)\\n\\u00a0     {}\\n\\u00a0 \\nBlockVectorDefinition block_vector.h:71\\nSolve for the displacement using a Newton-Raphson method. We break this function into the nonlinear loop and the function that solves the linearized Newton-Raphson step:\\n\\u00a0     void solve_nonlinear_timestep(BlockVector<double> &solution_delta);\\n\\u00a0 \\n\\u00a0     std::pair<unsigned int, double>\\n\\u00a0     solve_linear_system(BlockVector<double> &newton_update);\\n\\u00a0 \\nSolution retrieval as well as post-processing and writing data to file :\\n\\u00a0     BlockVector<double>\\n\\u00a0     get_total_solution(const BlockVector<double> &solution_delta) const;\\n\\u00a0 \\n\\u00a0     void output_results() const;\\n\\u00a0 \\nFinally, some member variables that describe the current state: A collection of the parameters used to describe the problem setup...\\n\\u00a0     Parameters::AllParameters parameters;\\n\\u00a0 \\n...the volume of the reference configuration...\\n\\u00a0     double vol_reference;\\n\\u00a0 \\n...and description of the geometry on which the problem is solved:\\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0 \\nTriangulationDefinition tria.h:1323\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\nAlso, keep track of the current time and the time spent evaluating certain functions\\n\\u00a0     Time                time;\\n\\u00a0     mutable TimerOutput timer;\\n\\u00a0 \\nTimerOutputDefinition timer.h:549\\nA storage object for quadrature point information. As opposed to step-18, deal.II's native quadrature point data manager is employed here.\\n\\u00a0     CellDataStorage<typename Triangulation<dim>::cell_iterator,\\n\\u00a0                     PointHistory<dim>>\\n\\u00a0       quadrature_point_history;\\n\\u00a0 \\nCellDataStorageDefinition quadrature_point_data.h:64\\nA description of the finite-element system including the displacement polynomial degree, the degree-of-freedom handler, number of DoFs per cell and the extractor objects used to retrieve information from the solution vectors:\\n\\u00a0     const unsigned int               degree;\\n\\u00a0     const FESystem<dim>              fe;\\n\\u00a0     DoFHandler<dim>                  dof_handler;\\n\\u00a0     const unsigned int               dofs_per_cell;\\n\\u00a0     const FEValuesExtractors::Vector u_fe;\\n\\u00a0     const FEValuesExtractors::Scalar p_fe;\\n\\u00a0     const FEValuesExtractors::Scalar J_fe;\\n\\u00a0 \\nDoFHandlerDefinition dof_handler.h:317\\nFEValuesExtractors::ScalarDefinition fe_values_extractors.h:95\\nFEValuesExtractors::VectorDefinition fe_values_extractors.h:150\\nDescription of how the block-system is arranged. There are 3 blocks, the first contains a vector DOF \\\\(\\\\mathbf{u}\\\\) while the other two describe scalar DOFs, \\\\(\\\\widetilde{p}\\\\) and \\\\(\\\\widetilde{J}\\\\).\\n\\u00a0     static const unsigned int n_blocks          = 3;\\n\\u00a0     static const unsigned int n_components      = dim + 2;\\n\\u00a0     static const unsigned int first_u_component = 0;\\n\\u00a0     static const unsigned int p_component       = dim;\\n\\u00a0     static const unsigned int J_component       = dim + 1;\\n\\u00a0 \\n\\u00a0     enum\\n\\u00a0     {\\n\\u00a0       u_dof = 0,\\n\\u00a0       p_dof = 1,\\n\\u00a0       J_dof = 2\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> dofs_per_block;\\n\\u00a0     std::vector<types::global_dof_index> element_indices_u;\\n\\u00a0     std::vector<types::global_dof_index> element_indices_p;\\n\\u00a0     std::vector<types::global_dof_index> element_indices_J;\\n\\u00a0 \\nRules for Gauss-quadrature on both the cell and faces. The number of quadrature points on both cells and faces is recorded.\\n\\u00a0     const QGauss<dim>     qf_cell;\\n\\u00a0     const QGauss<dim - 1> qf_face;\\n\\u00a0     const unsigned int    n_q_points;\\n\\u00a0     const unsigned int    n_q_points_f;\\n\\u00a0 \\nQGaussDefinition quadrature_lib.h:40\\nObjects that store the converged solution and right-hand side vectors, as well as the tangent matrix. There is an AffineConstraints object used to keep track of constraints. We make use of a sparsity pattern designed for a block system.\\n\\u00a0     AffineConstraints<double> constraints;\\n\\u00a0     BlockSparsityPattern      sparsity_pattern;\\n\\u00a0     BlockSparseMatrix<double> tangent_matrix;\\n\\u00a0     BlockVector<double>       system_rhs;\\n\\u00a0     BlockVector<double>       solution_n;\\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nBlockSparseMatrixDefinition block_sparse_matrix.h:50\\nBlockSparsityPatternDefinition block_sparsity_pattern.h:437\\nThen define a number of variables to store norms and update norms and normalization factors.\\n\\u00a0     struct Errors\\n\\u00a0     {\\n\\u00a0       Errors()\\n\\u00a0         : norm(1.0)\\n\\u00a0         , u(1.0)\\n\\u00a0         , p(1.0)\\n\\u00a0         , J(1.0)\\n\\u00a0       {}\\n\\u00a0 \\n\\u00a0       void reset()\\n\\u00a0       {\\n\\u00a0         norm = 1.0;\\n\\u00a0         u    = 1.0;\\n\\u00a0         p    = 1.0;\\n\\u00a0         J    = 1.0;\\n\\u00a0       }\\n\\u00a0       void normalize(const Errors &rhs)\\n\\u00a0       {\\n\\u00a0         if (rhs.norm != 0.0)\\n\\u00a0           norm /= rhs.norm;\\n\\u00a0         if (rhs.u != 0.0)\\n\\u00a0           u /= rhs.u;\\n\\u00a0         if (rhs.p != 0.0)\\n\\u00a0           p /= rhs.p;\\n\\u00a0         if (rhs.J != 0.0)\\n\\u00a0           J /= rhs.J;\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0       double norm, u, p, J;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     Errors error_residual, error_residual_0, error_residual_norm, error_update,\\n\\u00a0       error_update_0, error_update_norm;\\n\\u00a0 \\nLocalIntegrators::Divergence::normdouble norm(const FEValuesBase< dim > &fe, const ArrayView< const std::vector< Tensor< 1, dim > > > &Du)Definition divergence.h:471\\nMethods to calculate error measures\\n\\u00a0     void get_error_residual(Errors &error_residual);\\n\\u00a0 \\n\\u00a0     void get_error_update(const BlockVector<double> &newton_update,\\n\\u00a0                           Errors                    &error_update);\\n\\u00a0 \\n\\u00a0     std::pair<double, double> get_error_dilation() const;\\n\\u00a0 \\nCompute the volume in the spatial configuration\\n\\u00a0     double compute_vol_current() const;\\n\\u00a0 \\nPrint information to screen in a pleasing way...\\n\\u00a0     static void print_conv_header();\\n\\u00a0 \\n\\u00a0     void print_conv_footer();\\n\\u00a0   };\\n\\u00a0 \\n Implementation of the Solid class\\n Public interface\\nWe initialize the Solid class using data extracted from the parameter file.\\n\\u00a0   template <int dim>\\n\\u00a0   Solid<dim>::Solid(const std::string &input_file)\\n\\u00a0     : parameters(input_file)\\n\\u00a0     , vol_reference(0.)\\n\\u00a0     , triangulation(Triangulation<dim>::maximum_smoothing)\\n\\u00a0     , time(parameters.end_time, parameters.delta_t)\\n\\u00a0     , timer(std::cout, TimerOutput::summary, TimerOutput::wall_times)\\n\\u00a0     , degree(parameters.poly_degree)\\n\\u00a0     ,\\nstdSTL namespace.\\nThe Finite Element System is composed of dim continuous displacement DOFs, and discontinuous pressure and dilatation DOFs. In an attempt to satisfy the Babuska-Brezzi or LBB stability conditions (see Hughes (2000)), we set up a \\\\(Q_n \\\\times DGP_{n-1} \\\\times DGP_{n-1}\\\\) system. \\\\(Q_2 \\\\times DGP_1 \\\\times DGP_1\\\\) elements satisfy this condition, while \\\\(Q_1 \\\\times DGP_0 \\\\times DGP_0\\\\) elements do not. However, it has been shown that the latter demonstrate good convergence characteristics nonetheless.\\n\\u00a0     fe(FE_Q<dim>(parameters.poly_degree) ^ dim, // displacement\\n\\u00a0        FE_DGP<dim>(parameters.poly_degree - 1), // pressure\\n\\u00a0        FE_DGP<dim>(parameters.poly_degree - 1)) // dilatation\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0     , dofs_per_cell(fe.n_dofs_per_cell())\\n\\u00a0     , u_fe(first_u_component)\\n\\u00a0     , p_fe(p_component)\\n\\u00a0     , J_fe(J_component)\\n\\u00a0     , dofs_per_block(n_blocks)\\n\\u00a0     , qf_cell(parameters.quad_order)\\n\\u00a0     , qf_face(parameters.quad_order)\\n\\u00a0     , n_q_points(qf_cell.size())\\n\\u00a0     , n_q_points_f(qf_face.size())\\n\\u00a0   {\\n\\u00a0     Assert(dim == 2 || dim == 3,\\n\\u00a0            ExcMessage(\\\"This problem only works in 2 or 3 space dimensions.\\\"));\\n\\u00a0     determine_component_extractors();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nFE_DGPDefinition fe_dgp.h:311\\nFE_QDefinition fe_q.h:554\\nIn solving the quasi-static problem, the time becomes a loading parameter, i.e. we increasing the loading linearly with time, making the two concepts interchangeable. We choose to increment time linearly using a constant time step size.\\nWe start the function with preprocessing, setting the initial dilatation values, and then output the initial grid before starting the simulation proper with the first time (and loading) increment.\\nCare must be taken (or at least some thought given) when imposing the constraint \\\\(\\\\widetilde{J}=1\\\\) on the initial solution field. The constraint corresponds to the determinant of the deformation gradient in the undeformed configuration, which is the identity tensor. We use FE_DGP bases to interpolate the dilatation field, thus we can't simply set the corresponding dof to unity as they correspond to the coefficients of a truncated Legendre polynomial. Thus we use the VectorTools::project function to do the work for us. The VectorTools::project function requires an argument indicating the hanging node constraints. We have none in this program So we have to create a constraint object. In its original state, constraint objects are unsorted, and have to be sorted (using the AffineConstraints::close function) before they can be used. Have a look at step-21 for more information. We only need to enforce the initial condition on the dilatation. In order to do this, we make use of a ComponentSelectFunction which acts as a mask and sets the J_component of n_components to 1. This is exactly what we want. Have a look at its usage in step-20 for more information.\\n\\u00a0   template <int dim>\\n\\u00a0   void Solid<dim>::run()\\n\\u00a0   {\\n\\u00a0     make_grid();\\n\\u00a0     system_setup();\\n\\u00a0     {\\n\\u00a0       AffineConstraints<double> constraints;\\n\\u00a0       constraints.close();\\n\\u00a0 \\n\\u00a0       const ComponentSelectFunction<dim> J_mask(J_component, n_components);\\n\\u00a0 \\n\\u00a0       VectorTools::project(\\n\\u00a0         dof_handler, constraints, QGauss<dim>(degree + 2), J_mask, solution_n);\\n\\u00a0     }\\n\\u00a0     output_results();\\n\\u00a0     time.increment();\\n\\u00a0 \\nAffineConstraints::closevoid close()\\nComponentSelectFunctionDefinition function.h:582\\nVectorTools::projectvoid project(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const AffineConstraints< typename VectorType::value_type > &constraints, const Quadrature< dim > &quadrature, const Function< spacedim, typename VectorType::value_type > &function, VectorType &vec, const bool enforce_zero_boundary=false, const Quadrature< dim - 1 > &q_boundary=(dim > 1 ? QGauss< dim - 1 >(2) :Quadrature< dim - 1 >()), const bool project_to_boundary_first=false)\\nWe then declare the incremental solution update   \\\\(\\\\varDelta\\n   \\\\mathbf{\\\\Xi} \\\\dealcoloneq \\\\{\\\\varDelta \\\\mathbf{u},\\\\varDelta \\\\widetilde{p},\\n   \\\\varDelta \\\\widetilde{J} \\\\}\\\\) and start the loop over the time domain.\\nAt the beginning, we reset the solution update for this time step...\\n\\u00a0     BlockVector<double> solution_delta(dofs_per_block);\\n\\u00a0     while (time.current() < time.end())\\n\\u00a0       {\\n\\u00a0         solution_delta = 0.0;\\n\\u00a0 \\n...solve the current time step and update total solution vector  \\\\(\\\\mathbf{\\\\Xi}_{\\\\textrm{n}} = \\\\mathbf{\\\\Xi}_{\\\\textrm{n-1}} +\\n   \\\\varDelta \\\\mathbf{\\\\Xi}\\\\)...\\n\\u00a0         solve_nonlinear_timestep(solution_delta);\\n\\u00a0         solution_n += solution_delta;\\n\\u00a0 \\n...and plot the results before moving on happily to the next time step:\\n\\u00a0         output_results();\\n\\u00a0         time.increment();\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n Private interface\\n Threading-building-blocks structures\\nThe first group of private member functions is related to parallelization. We use the Threading Building Blocks library (TBB) to perform as many computationally intensive distributed tasks as possible. In particular, we assemble the tangent matrix and right hand side vector, the static condensation contributions, and update data stored at the quadrature points using TBB. Our main tool for this is the WorkStream class (see the Parallel computing with multiple processors accessing shared memory topic for more information).\\nFirstly we deal with the tangent matrix and right-hand side assembly structures. The PerTaskData object stores local contributions to the global system.\\n\\u00a0   template <int dim>\\n\\u00a0   struct Solid<dim>::PerTaskData_ASM\\n\\u00a0   {\\n\\u00a0     FullMatrix<double>                   cell_matrix;\\n\\u00a0     Vector<double>                       cell_rhs;\\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices;\\n\\u00a0 \\n\\u00a0     PerTaskData_ASM(const unsigned int dofs_per_cell)\\n\\u00a0       : cell_matrix(dofs_per_cell, dofs_per_cell)\\n\\u00a0       , cell_rhs(dofs_per_cell)\\n\\u00a0       , local_dof_indices(dofs_per_cell)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     void reset()\\n\\u00a0     {\\n\\u00a0       cell_matrix = 0.0;\\n\\u00a0       cell_rhs    = 0.0;\\n\\u00a0     }\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\nFullMatrixDefinition full_matrix.h:79\\nVectorDefinition vector.h:120\\nOn the other hand, the ScratchData object stores the larger objects such as the shape-function values array (Nx) and a shape function gradient and symmetric gradient vector which we will use during the assembly.\\n\\u00a0   template <int dim>\\n\\u00a0   struct Solid<dim>::ScratchData_ASM\\n\\u00a0   {\\n\\u00a0     FEValues<dim>     fe_values;\\n\\u00a0     FEFaceValues<dim> fe_face_values;\\n\\u00a0 \\n\\u00a0     std::vector<std::vector<double>>                  Nx;\\n\\u00a0     std::vector<std::vector<Tensor<2, dim>>>          grad_Nx;\\n\\u00a0     std::vector<std::vector<SymmetricTensor<2, dim>>> symm_grad_Nx;\\n\\u00a0 \\n\\u00a0     ScratchData_ASM(const FiniteElement<dim> &fe_cell,\\n\\u00a0                     const QGauss<dim>        &qf_cell,\\n\\u00a0                     const UpdateFlags         uf_cell,\\n\\u00a0                     const QGauss<dim - 1>    &qf_face,\\n\\u00a0                     const UpdateFlags         uf_face)\\n\\u00a0       : fe_values(fe_cell, qf_cell, uf_cell)\\n\\u00a0       , fe_face_values(fe_cell, qf_face, uf_face)\\n\\u00a0       , Nx(qf_cell.size(), std::vector<double>(fe_cell.n_dofs_per_cell()))\\n\\u00a0       , grad_Nx(qf_cell.size(),\\n\\u00a0                 std::vector<Tensor<2, dim>>(fe_cell.n_dofs_per_cell()))\\n\\u00a0       , symm_grad_Nx(qf_cell.size(),\\n\\u00a0                      std::vector<SymmetricTensor<2, dim>>(\\n\\u00a0                        fe_cell.n_dofs_per_cell()))\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     ScratchData_ASM(const ScratchData_ASM &rhs)\\n\\u00a0       : fe_values(rhs.fe_values.get_fe(),\\n\\u00a0                   rhs.fe_values.get_quadrature(),\\n\\u00a0                   rhs.fe_values.get_update_flags())\\n\\u00a0       , fe_face_values(rhs.fe_face_values.get_fe(),\\n\\u00a0                        rhs.fe_face_values.get_quadrature(),\\n\\u00a0                        rhs.fe_face_values.get_update_flags())\\n\\u00a0       , Nx(rhs.Nx)\\n\\u00a0       , grad_Nx(rhs.grad_Nx)\\n\\u00a0       , symm_grad_Nx(rhs.symm_grad_Nx)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     void reset()\\n\\u00a0     {\\n\\u00a0       const unsigned int n_q_points      = Nx.size();\\n\\u00a0       const unsigned int n_dofs_per_cell = Nx[0].size();\\n\\u00a0       for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n\\u00a0         {\\n\\u00a0           Assert(Nx[q_point].size() == n_dofs_per_cell, ExcInternalError());\\n\\u00a0           Assert(grad_Nx[q_point].size() == n_dofs_per_cell,\\n\\u00a0                  ExcInternalError());\\n\\u00a0           Assert(symm_grad_Nx[q_point].size() == n_dofs_per_cell,\\n\\u00a0                  ExcInternalError());\\n\\u00a0           for (unsigned int k = 0; k < n_dofs_per_cell; ++k)\\n\\u00a0             {\\n\\u00a0               Nx[q_point][k]           = 0.0;\\n\\u00a0               grad_Nx[q_point][k]      = 0.0;\\n\\u00a0               symm_grad_Nx[q_point][k] = 0.0;\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\nFEFaceValuesDefinition fe_values.h:322\\nFEValuesDefinition fe_values.h:63\\nFiniteElementDefinition fe.h:655\\nint\\nUpdateFlagsUpdateFlagsDefinition fe_update_flags.h:64\\nThen we define structures to assemble the statically condensed tangent matrix. Recall that we wish to solve for a displacement-based formulation. We do the condensation at the element level as the \\\\(\\\\widetilde{p}\\\\) and \\\\(\\\\widetilde{J}\\\\) fields are element-wise discontinuous. As these operations are matrix-based, we need to set up a number of matrices to store the local contributions from a number of the tangent matrix sub-blocks. We place these in the PerTaskData struct.\\nWe choose not to reset any data in the reset() function as the matrix extraction and replacement tools will take care of this\\n\\u00a0   template <int dim>\\n\\u00a0   struct Solid<dim>::PerTaskData_SC\\n\\u00a0   {\\n\\u00a0     FullMatrix<double>                   cell_matrix;\\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices;\\n\\u00a0 \\n\\u00a0     FullMatrix<double> k_orig;\\n\\u00a0     FullMatrix<double> k_pu;\\n\\u00a0     FullMatrix<double> k_pJ;\\n\\u00a0     FullMatrix<double> k_JJ;\\n\\u00a0     FullMatrix<double> k_pJ_inv;\\n\\u00a0     FullMatrix<double> k_bbar;\\n\\u00a0     FullMatrix<double> A;\\n\\u00a0     FullMatrix<double> B;\\n\\u00a0     FullMatrix<double> C;\\n\\u00a0 \\n\\u00a0     PerTaskData_SC(const unsigned int dofs_per_cell,\\n\\u00a0                    const unsigned int n_u,\\n\\u00a0                    const unsigned int n_p,\\n\\u00a0                    const unsigned int n_J)\\n\\u00a0       : cell_matrix(dofs_per_cell, dofs_per_cell)\\n\\u00a0       , local_dof_indices(dofs_per_cell)\\n\\u00a0       , k_orig(dofs_per_cell, dofs_per_cell)\\n\\u00a0       , k_pu(n_p, n_u)\\n\\u00a0       , k_pJ(n_p, n_J)\\n\\u00a0       , k_JJ(n_J, n_J)\\n\\u00a0       , k_pJ_inv(n_p, n_J)\\n\\u00a0       , k_bbar(n_u, n_u)\\n\\u00a0       , A(n_J, n_u)\\n\\u00a0       , B(n_J, n_u)\\n\\u00a0       , C(n_p, n_u)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     void reset()\\n\\u00a0     {}\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\nThe ScratchData object for the operations we wish to perform here is empty since we need no temporary data, but it still needs to be defined for the current implementation of TBB in deal.II. So we create a dummy struct for this purpose.\\n\\u00a0   template <int dim>\\n\\u00a0   struct Solid<dim>::ScratchData_SC\\n\\u00a0   {\\n\\u00a0     void reset()\\n\\u00a0     {}\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\nAnd finally we define the structures to assist with updating the quadrature point information. Similar to the SC assembly process, we do not need the PerTaskData object (since there is nothing to store here) but must define one nonetheless. Note that this is because for the operation that we have here \\u2013 updating the data on quadrature points \\u2013 the operation is purely local: the things we do on every cell get consumed on every cell, without any global aggregation operation as is usually the case when using the WorkStream class. The fact that we still have to define a per-task data structure points to the fact that the WorkStream class may be ill-suited to this operation (we could, in principle simply create a new task using Threads::new_task for each cell) but there is not much harm done to doing it this way anyway. Furthermore, should there be different material models associated with a quadrature point, requiring varying levels of computational expense, then the method used here could be advantageous.\\n\\u00a0   template <int dim>\\n\\u00a0   struct Solid<dim>::PerTaskData_UQPH\\n\\u00a0   {\\n\\u00a0     void reset()\\n\\u00a0     {}\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\nThe ScratchData object will be used to store an alias for the solution vector so that we don't have to copy this large data structure. We then define a number of vectors to extract the solution values and gradients at the quadrature points.\\n\\u00a0   template <int dim>\\n\\u00a0   struct Solid<dim>::ScratchData_UQPH\\n\\u00a0   {\\n\\u00a0     const BlockVector<double> &solution_total;\\n\\u00a0 \\n\\u00a0     std::vector<Tensor<2, dim>> solution_grads_u_total;\\n\\u00a0     std::vector<double>         solution_values_p_total;\\n\\u00a0     std::vector<double>         solution_values_J_total;\\n\\u00a0 \\n\\u00a0     FEValues<dim> fe_values;\\n\\u00a0 \\n\\u00a0     ScratchData_UQPH(const FiniteElement<dim>  &fe_cell,\\n\\u00a0                      const QGauss<dim>         &qf_cell,\\n\\u00a0                      const UpdateFlags          uf_cell,\\n\\u00a0                      const BlockVector<double> &solution_total)\\n\\u00a0       : solution_total(solution_total)\\n\\u00a0       , solution_grads_u_total(qf_cell.size())\\n\\u00a0       , solution_values_p_total(qf_cell.size())\\n\\u00a0       , solution_values_J_total(qf_cell.size())\\n\\u00a0       , fe_values(fe_cell, qf_cell, uf_cell)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     ScratchData_UQPH(const ScratchData_UQPH &rhs)\\n\\u00a0       : solution_total(rhs.solution_total)\\n\\u00a0       , solution_grads_u_total(rhs.solution_grads_u_total)\\n\\u00a0       , solution_values_p_total(rhs.solution_values_p_total)\\n\\u00a0       , solution_values_J_total(rhs.solution_values_J_total)\\n\\u00a0       , fe_values(rhs.fe_values.get_fe(),\\n\\u00a0                   rhs.fe_values.get_quadrature(),\\n\\u00a0                   rhs.fe_values.get_update_flags())\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     void reset()\\n\\u00a0     {\\n\\u00a0       const unsigned int n_q_points = solution_grads_u_total.size();\\n\\u00a0       for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0         {\\n\\u00a0           solution_grads_u_total[q]  = 0.0;\\n\\u00a0           solution_values_p_total[q] = 0.0;\\n\\u00a0           solution_values_J_total[q] = 0.0;\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n Solid::make_grid\\nOn to the first of the private member functions. Here we create the triangulation of the domain, for which we choose the scaled cube with each face given a boundary ID number. The grid must be refined at least once for the indentation problem.\\nWe then determine the volume of the reference configuration and print it for comparison:\\n\\u00a0   template <int dim>\\n\\u00a0   void Solid<dim>::make_grid()\\n\\u00a0   {\\n\\u00a0     GridGenerator::hyper_rectangle(\\n\\u00a0       triangulation,\\n\\u00a0       (dim == 3 ? Point<dim>(0.0, 0.0, 0.0) : Point<dim>(0.0, 0.0)),\\n\\u00a0       (dim == 3 ? Point<dim>(1.0, 1.0, 1.0) : Point<dim>(1.0, 1.0)),\\n\\u00a0       true);\\n\\u00a0     GridTools::scale(parameters.scale, triangulation);\\n\\u00a0     triangulation.refine_global(std::max(1U, parameters.global_refinement));\\n\\u00a0 \\n\\u00a0     vol_reference = GridTools::volume(triangulation);\\n\\u00a0     std::cout << \\\"Grid:\\\\n\\\\t Reference volume: \\\" << vol_reference << std::endl;\\n\\u00a0 \\nPointDefinition point.h:111\\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nGridGenerator::hyper_rectanglevoid hyper_rectangle(Triangulation< dim, spacedim > &tria, const Point< dim > &p1, const Point< dim > &p2, const bool colorize=false)\\nGridTools::volumedouble volume(const Triangulation< dim, spacedim > &tria)Definition grid_tools_geometry.cc:98\\nstd::max::VectorizedArray< Number, width > max(const ::VectorizedArray< Number, width > &, const ::VectorizedArray< Number, width > &)Definition vectorization.h:6943\\nSince we wish to apply a Neumann BC to a patch on the top surface, we must find the cell faces in this part of the domain and mark them with a distinct boundary ID number. The faces we are looking for are on the +y surface and will get boundary ID 6 (zero through five are already used when creating the six faces of the cube domain):\\n\\u00a0     for (const auto &cell : triangulation.active_cell_iterators())\\n\\u00a0       for (const auto &face : cell->face_iterators())\\n\\u00a0         {\\n\\u00a0           if (face->at_boundary() == true &&\\n\\u00a0               face->center()[1] == 1.0 * parameters.scale)\\n\\u00a0             {\\n\\u00a0               if (dim == 3)\\n\\u00a0                 {\\n\\u00a0                   if (face->center()[0] < 0.5 * parameters.scale &&\\n\\u00a0                       face->center()[2] < 0.5 * parameters.scale)\\n\\u00a0                     face->set_boundary_id(6);\\n\\u00a0                 }\\n\\u00a0               else\\n\\u00a0                 {\\n\\u00a0                   if (face->center()[0] < 0.5 * parameters.scale)\\n\\u00a0                     face->set_boundary_id(6);\\n\\u00a0                 }\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\ncenterPoint< 3 > centerDefinition data_out_base.cc:267\\n Solid::system_setup\\nNext we describe how the FE system is setup. We first determine the number of components per block. Since the displacement is a vector component, the first dim components belong to it, while the next two describe scalar pressure and dilatation DOFs.\\n\\u00a0   template <int dim>\\n\\u00a0   void Solid<dim>::system_setup()\\n\\u00a0   {\\n\\u00a0     timer.enter_subsection(\\\"Setup system\\\");\\n\\u00a0 \\n\\u00a0     std::vector<unsigned int> block_component(n_components,\\n\\u00a0                                               u_dof); // Displacement\\n\\u00a0     block_component[p_component] = p_dof;             // Pressure\\n\\u00a0     block_component[J_component] = J_dof;             // Dilatation\\n\\u00a0 \\nThe DOF handler is then initialized and we renumber the grid in an efficient manner. We also record the number of DOFs per block.\\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0     DoFRenumbering::Cuthill_McKee(dof_handler);\\n\\u00a0     DoFRenumbering::component_wise(dof_handler, block_component);\\n\\u00a0 \\n\\u00a0     dofs_per_block =\\n\\u00a0       DoFTools::count_dofs_per_fe_block(dof_handler, block_component);\\n\\u00a0 \\n\\u00a0     std::cout << \\\"Triangulation:\\\"\\n\\u00a0               << \\\"\\\\n\\\\t Number of active cells: \\\"\\n\\u00a0               << triangulation.n_active_cells()\\n\\u00a0               << \\\"\\\\n\\\\t Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n\\u00a0               << std::endl;\\n\\u00a0 \\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nDoFRenumbering::component_wisevoid component_wise(DoFHandler< dim, spacedim > &dof_handler, const std::vector< unsigned int > &target_component=std::vector< unsigned int >())Definition dof_renumbering.cc:666\\nDoFRenumbering::Cuthill_McKeevoid Cuthill_McKee(DoFHandler< dim, spacedim > &dof_handler, const bool reversed_numbering=false, const bool use_constraints=false, const std::vector< types::global_dof_index > &starting_indices=std::vector< types::global_dof_index >())Definition dof_renumbering.cc:366\\nDoFTools::count_dofs_per_fe_blockstd::vector< types::global_dof_index > count_dofs_per_fe_block(const DoFHandler< dim, spacedim > &dof, const std::vector< unsigned int > &target_block=std::vector< unsigned int >())Definition dof_tools.cc:2104\\nSetup the sparsity pattern and tangent matrix\\n\\u00a0     tangent_matrix.clear();\\n\\u00a0     {\\n\\u00a0       BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block);\\n\\u00a0 \\nBlockDynamicSparsityPatternDefinition block_sparsity_pattern.h:549\\nThe global system matrix initially has the following structure                     \\n\\\\begin{align*}\\n   \\\\underbrace{\\\\begin{bmatrix}\\n   \\\\mathsf{\\\\mathbf{K}}_{uu}  & \\\\mathsf{\\\\mathbf{K}}_{u\\\\widetilde{p}} &\\n   \\\\mathbf{0}\\n   \\\\\\\\ \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{p}u} & \\\\mathbf{0} &\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{p}\\\\widetilde{J}}\\n   \\\\\\\\ \\\\mathbf{0} & \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J}\\\\widetilde{p}} &\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J}\\\\widetilde{J}}\\n   \\\\end{bmatrix}}_{\\\\mathsf{\\\\mathbf{K}}(\\\\mathbf{\\\\Xi}_{\\\\textrm{i}})}\\n   \\\\underbrace{\\\\begin{bmatrix}\\n   d \\\\mathsf{u}\\n   \\\\\\\\  d \\\\widetilde{\\\\mathsf{\\\\mathbf{p}}}\\n   \\\\\\\\  d \\\\widetilde{\\\\mathsf{\\\\mathbf{J}}}\\n   \\\\end{bmatrix}}_{d \\\\mathbf{\\\\Xi}}\\n   =\\n   \\\\underbrace{\\\\begin{bmatrix}\\n   \\\\mathsf{\\\\mathbf{F}}_{u}(\\\\mathbf{u}_{\\\\textrm{i}})\\n   \\\\\\\\ \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{p}}(\\\\widetilde{p}_{\\\\textrm{i}})\\n   \\\\\\\\ \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{J}}(\\\\widetilde{J}_{\\\\textrm{i}})\\n   \\\\end{bmatrix}}_{ \\\\mathsf{\\\\mathbf{F}}(\\\\mathbf{\\\\Xi}_{\\\\textrm{i}}) } \\\\, .\\n   \\\\end{align*}\\n\\n We optimize the sparsity pattern to reflect this structure and prevent unnecessary data creation for the right-diagonal block components.\\n\\u00a0       Table<2, DoFTools::Coupling> coupling(n_components, n_components);\\n\\u00a0       for (unsigned int ii = 0; ii < n_components; ++ii)\\n\\u00a0         for (unsigned int jj = 0; jj < n_components; ++jj)\\n\\u00a0           if (((ii < p_component) && (jj == J_component)) ||\\n\\u00a0               ((ii == J_component) && (jj < p_component)) ||\\n\\u00a0               ((ii == p_component) && (jj == p_component)))\\n\\u00a0             coupling[ii][jj] = DoFTools::none;\\n\\u00a0           else\\n\\u00a0             coupling[ii][jj] = DoFTools::always;\\n\\u00a0       DoFTools::make_sparsity_pattern(\\n\\u00a0         dof_handler, coupling, dsp, constraints, false);\\n\\u00a0       sparsity_pattern.copy_from(dsp);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     tangent_matrix.reinit(sparsity_pattern);\\n\\u00a0 \\nTableDefinition array_view.h:39\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nDoFTools::none@ noneDefinition dof_tools.h:243\\nDoFTools::always@ alwaysDefinition dof_tools.h:247\\nWe then set up storage vectors\\n\\u00a0     system_rhs.reinit(dofs_per_block);\\n\\u00a0     solution_n.reinit(dofs_per_block);\\n\\u00a0 \\n...and finally set up the quadrature point history:\\n\\u00a0     setup_qph();\\n\\u00a0 \\n\\u00a0     timer.leave_subsection();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n Solid::determine_component_extractors\\nNext we compute some information from the FE system that describes which local element DOFs are attached to which block component. This is used later to extract sub-blocks from the global matrix.\\nIn essence, all we need is for the FESystem object to indicate to which block component a DOF on the reference cell is attached to. Currently, the interpolation fields are setup such that 0 indicates a displacement DOF, 1 a pressure DOF and 2 a dilatation DOF.\\n\\u00a0   template <int dim>\\n\\u00a0   void Solid<dim>::determine_component_extractors()\\n\\u00a0   {\\n\\u00a0     element_indices_u.clear();\\n\\u00a0     element_indices_p.clear();\\n\\u00a0     element_indices_J.clear();\\n\\u00a0 \\n\\u00a0     for (unsigned int k = 0; k < fe.n_dofs_per_cell(); ++k)\\n\\u00a0       {\\n\\u00a0         const unsigned int k_group = fe.system_to_base_index(k).first.first;\\n\\u00a0         if (k_group == u_dof)\\n\\u00a0           element_indices_u.push_back(k);\\n\\u00a0         else if (k_group == p_dof)\\n\\u00a0           element_indices_p.push_back(k);\\n\\u00a0         else if (k_group == J_dof)\\n\\u00a0           element_indices_J.push_back(k);\\n\\u00a0         else\\n\\u00a0           {\\n\\u00a0             Assert(k_group <= J_dof, ExcInternalError());\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n Solid::setup_qph\\nThe method used to store quadrature information is already described in step-18. Here we implement a similar setup for a SMP machine.\\nFirstly the actual QPH data objects are created. This must be done only once the grid is refined to its finest level.\\n\\u00a0   template <int dim>\\n\\u00a0   void Solid<dim>::setup_qph()\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"    Setting up quadrature point data...\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     quadrature_point_history.initialize(triangulation.begin_active(),\\n\\u00a0                                         triangulation.end(),\\n\\u00a0                                         n_q_points);\\n\\u00a0 \\nTriangulation::endcell_iterator end() const\\nTriangulation::begin_activeactive_cell_iterator begin_active(const unsigned int level=0) const\\nNext we set up the initial quadrature point data. Note that when the quadrature point data is retrieved, it is returned as a vector of smart pointers.\\n\\u00a0     for (const auto &cell : triangulation.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         const std::vector<std::shared_ptr<PointHistory<dim>>> lqph =\\n\\u00a0           quadrature_point_history.get_data(cell);\\n\\u00a0         Assert(lqph.size() == n_q_points, ExcInternalError());\\n\\u00a0 \\n\\u00a0         for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n\\u00a0           lqph[q_point]->setup_lqp(parameters);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n Solid::update_qph_incremental\\nAs the update of QP information occurs frequently and involves a number of expensive operations, we define a multithreaded approach to distributing the task across a number of CPU cores.\\nTo start this, we first we need to obtain the total solution as it stands at this Newton increment and then create the initial copy of the scratch and copy data objects:\\n\\u00a0   template <int dim>\\n\\u00a0   void\\n\\u00a0   Solid<dim>::update_qph_incremental(const BlockVector<double> &solution_delta)\\n\\u00a0   {\\n\\u00a0     timer.enter_subsection(\\\"Update QPH data\\\");\\n\\u00a0     std::cout << \\\" UQPH \\\" << std::flush;\\n\\u00a0 \\n\\u00a0     const BlockVector<double> solution_total(\\n\\u00a0       get_total_solution(solution_delta));\\n\\u00a0 \\n\\u00a0     const UpdateFlags uf_UQPH(update_values | update_gradients);\\n\\u00a0     PerTaskData_UQPH  per_task_data_UQPH;\\n\\u00a0     ScratchData_UQPH  scratch_data_UQPH(fe, qf_cell, uf_UQPH, solution_total);\\n\\u00a0 \\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nWe then pass them and the one-cell update function to the WorkStream to be processed:\\n\\u00a0     WorkStream::run(dof_handler.active_cell_iterators(),\\n\\u00a0                     *this,\\n\\u00a0                     &Solid::update_qph_incremental_one_cell,\\n\\u00a0                     &Solid::copy_local_to_global_UQPH,\\n\\u00a0                     scratch_data_UQPH,\\n\\u00a0                     per_task_data_UQPH);\\n\\u00a0 \\n\\u00a0     timer.leave_subsection();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nWorkStream::runvoid run(const std::vector< std::vector< Iterator > > &colored_iterators, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length=2 *MultithreadInfo::n_threads(), const unsigned int chunk_size=8)Definition work_stream.h:1272\\nNow we describe how we extract data from the solution vector and pass it along to each QP storage object for processing.\\n\\u00a0   template <int dim>\\n\\u00a0   void Solid<dim>::update_qph_incremental_one_cell(\\n\\u00a0     const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0     ScratchData_UQPH                                     &scratch,\\n\\u00a0     PerTaskData_UQPH & /*data*/)\\n\\u00a0   {\\n\\u00a0     const std::vector<std::shared_ptr<PointHistory<dim>>> lqph =\\n\\u00a0       quadrature_point_history.get_data(cell);\\n\\u00a0     Assert(lqph.size() == n_q_points, ExcInternalError());\\n\\u00a0 \\n\\u00a0     Assert(scratch.solution_grads_u_total.size() == n_q_points,\\n\\u00a0            ExcInternalError());\\n\\u00a0     Assert(scratch.solution_values_p_total.size() == n_q_points,\\n\\u00a0            ExcInternalError());\\n\\u00a0     Assert(scratch.solution_values_J_total.size() == n_q_points,\\n\\u00a0            ExcInternalError());\\n\\u00a0 \\n\\u00a0     scratch.reset();\\n\\u00a0 \\nWe first need to find the values and gradients at quadrature points inside the current cell and then we update each local QP using the displacement gradient and total pressure and dilatation solution values:\\n\\u00a0     scratch.fe_values.reinit(cell);\\n\\u00a0     scratch.fe_values[u_fe].get_function_gradients(\\n\\u00a0       scratch.solution_total, scratch.solution_grads_u_total);\\n\\u00a0     scratch.fe_values[p_fe].get_function_values(\\n\\u00a0       scratch.solution_total, scratch.solution_values_p_total);\\n\\u00a0     scratch.fe_values[J_fe].get_function_values(\\n\\u00a0       scratch.solution_total, scratch.solution_values_J_total);\\n\\u00a0 \\n\\u00a0     for (const unsigned int q_point :\\n\\u00a0          scratch.fe_values.quadrature_point_indices())\\n\\u00a0       lqph[q_point]->update_values(scratch.solution_grads_u_total[q_point],\\n\\u00a0                                    scratch.solution_values_p_total[q_point],\\n\\u00a0                                    scratch.solution_values_J_total[q_point]);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n Solid::solve_nonlinear_timestep\\nThe next function is the driver method for the Newton-Raphson scheme. At its top we create a new vector to store the current Newton update step, reset the error storage objects and print solver header.\\n\\u00a0   template <int dim>\\n\\u00a0   void Solid<dim>::solve_nonlinear_timestep(BlockVector<double> &solution_delta)\\n\\u00a0   {\\n\\u00a0     std::cout << std::endl\\n\\u00a0               << \\\"Timestep \\\" << time.get_timestep() << \\\" @ \\\" << time.current()\\n\\u00a0               << 's' << std::endl;\\n\\u00a0 \\n\\u00a0     BlockVector<double> newton_update(dofs_per_block);\\n\\u00a0 \\n\\u00a0     error_residual.reset();\\n\\u00a0     error_residual_0.reset();\\n\\u00a0     error_residual_norm.reset();\\n\\u00a0     error_update.reset();\\n\\u00a0     error_update_0.reset();\\n\\u00a0     error_update_norm.reset();\\n\\u00a0 \\n\\u00a0     print_conv_header();\\n\\u00a0 \\nWe now perform a number of Newton iterations to iteratively solve the nonlinear problem. Since the problem is fully nonlinear and we are using a full Newton method, the data stored in the tangent matrix and right-hand side vector is not reusable and must be cleared at each Newton step. We then initially build the linear system and check for convergence (and store this value in the first iteration). The unconstrained DOFs of the rhs vector hold the out-of-balance forces, and collectively determine whether or not the equilibrium solution has been attained.\\nAlthough for this particular problem we could potentially construct the RHS vector before assembling the system matrix, for the sake of extensibility we choose not to do so. The benefit to assembling the RHS vector and system matrix separately is that the latter is an expensive operation and we can potentially avoid an extra assembly process by not assembling the tangent matrix when convergence is attained. However, this makes parallelizing the code using MPI more difficult. Furthermore, when extending the problem to the transient case additional contributions to the RHS may result from the time discretization and application of constraints for the velocity and acceleration fields.\\n\\u00a0     unsigned int newton_iteration = 0;\\n\\u00a0     for (; newton_iteration < parameters.max_iterations_NR; ++newton_iteration)\\n\\u00a0       {\\n\\u00a0         std::cout << ' ' << std::setw(2) << newton_iteration << ' '\\n\\u00a0                   << std::flush;\\n\\u00a0 \\nWe construct the linear system, but hold off on solving it (a step that should be significantly more expensive than assembly):\\n\\u00a0         make_constraints(newton_iteration);\\n\\u00a0         assemble_system();\\n\\u00a0 \\nWe can now determine the normalized residual error and check for solution convergence:\\n\\u00a0         get_error_residual(error_residual);\\n\\u00a0         if (newton_iteration == 0)\\n\\u00a0           error_residual_0 = error_residual;\\n\\u00a0 \\n\\u00a0         error_residual_norm = error_residual;\\n\\u00a0         error_residual_norm.normalize(error_residual_0);\\n\\u00a0 \\n\\u00a0         if (newton_iteration > 0 && error_update_norm.u <= parameters.tol_u &&\\n\\u00a0             error_residual_norm.u <= parameters.tol_f)\\n\\u00a0           {\\n\\u00a0             std::cout << \\\" CONVERGED! \\\" << std::endl;\\n\\u00a0             print_conv_footer();\\n\\u00a0 \\n\\u00a0             break;\\n\\u00a0           }\\n\\u00a0 \\nIf we have decided that we want to continue with the iteration, we solve the linearized system:\\n\\u00a0         const std::pair<unsigned int, double> lin_solver_output =\\n\\u00a0           solve_linear_system(newton_update);\\n\\u00a0 \\nWe can now determine the normalized Newton update error:\\n\\u00a0         get_error_update(newton_update, error_update);\\n\\u00a0         if (newton_iteration == 0)\\n\\u00a0           error_update_0 = error_update;\\n\\u00a0 \\n\\u00a0         error_update_norm = error_update;\\n\\u00a0         error_update_norm.normalize(error_update_0);\\n\\u00a0 \\nLastly, since we implicitly accept the solution step we can perform the actual update of the solution increment for the current time step, update all quadrature point information pertaining to this new displacement and stress state and continue iterating:\\n\\u00a0         solution_delta += newton_update;\\n\\u00a0         update_qph_incremental(solution_delta);\\n\\u00a0 \\n\\u00a0         std::cout << \\\" | \\\" << std::fixed << std::setprecision(3) << std::setw(7)\\n\\u00a0                   << std::scientific << lin_solver_output.first << \\\"  \\\"\\n\\u00a0                   << lin_solver_output.second << \\\"  \\\"\\n\\u00a0                   << error_residual_norm.norm << \\\"  \\\" << error_residual_norm.u\\n\\u00a0                   << \\\"  \\\" << error_residual_norm.p << \\\"  \\\"\\n\\u00a0                   << error_residual_norm.J << \\\"  \\\" << error_update_norm.norm\\n\\u00a0                   << \\\"  \\\" << error_update_norm.u << \\\"  \\\" << error_update_norm.p\\n\\u00a0                   << \\\"  \\\" << error_update_norm.J << \\\"  \\\" << std::endl;\\n\\u00a0       }\\n\\u00a0 \\nsecondPoint< 2 > secondDefinition grid_out.cc:4624\\nfirstPoint< 2 > firstDefinition grid_out.cc:4623\\nAt the end, if it turns out that we have in fact done more iterations than the parameter file allowed, we raise an exception that can be caught in the main() function. The call AssertThrow(condition,\\n   exc_object) is in essence equivalent to if (!cond) throw exc_object; but the former form fills certain fields in the exception object that identify the location (filename and line number) where the exception was raised to make it simpler to identify where the problem happened.\\n\\u00a0     AssertThrow(newton_iteration < parameters.max_iterations_NR,\\n\\u00a0                 ExcMessage(\\\"No convergence in nonlinear solver!\\\"));\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nAssertThrow#define AssertThrow(cond, exc)Definition exceptions.h:1739\\n Solid::print_conv_header and Solid::print_conv_footer\\nThis program prints out data in a nice table that is updated on a per-iteration basis. The next two functions set up the table header and footer:\\n\\u00a0   template <int dim>\\n\\u00a0   void Solid<dim>::print_conv_header()\\n\\u00a0   {\\n\\u00a0     static const unsigned int l_width = 150;\\n\\u00a0 \\n\\u00a0     for (unsigned int i = 0; i < l_width; ++i)\\n\\u00a0       std::cout << '_';\\n\\u00a0     std::cout << std::endl;\\n\\u00a0 \\n\\u00a0     std::cout << \\\"               SOLVER STEP               \\\"\\n\\u00a0               << \\\" |  LIN_IT   LIN_RES    RES_NORM    \\\"\\n\\u00a0               << \\\" RES_U     RES_P      RES_J     NU_NORM     \\\"\\n\\u00a0               << \\\" NU_U       NU_P       NU_J \\\" << std::endl;\\n\\u00a0 \\n\\u00a0     for (unsigned int i = 0; i < l_width; ++i)\\n\\u00a0       std::cout << '_';\\n\\u00a0     std::cout << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void Solid<dim>::print_conv_footer()\\n\\u00a0   {\\n\\u00a0     static const unsigned int l_width = 150;\\n\\u00a0 \\n\\u00a0     for (unsigned int i = 0; i < l_width; ++i)\\n\\u00a0       std::cout << '_';\\n\\u00a0     std::cout << std::endl;\\n\\u00a0 \\n\\u00a0     const std::pair<double, double> error_dil = get_error_dilation();\\n\\u00a0 \\n\\u00a0     std::cout << \\\"Relative errors:\\\" << std::endl\\n\\u00a0               << \\\"Displacement:\\\\t\\\" << error_update.u / error_update_0.u\\n\\u00a0               << std::endl\\n\\u00a0               << \\\"Force: \\\\t\\\\t\\\" << error_residual.u / error_residual_0.u\\n\\u00a0               << std::endl\\n\\u00a0               << \\\"Dilatation:\\\\t\\\" << error_dil.first << std::endl\\n\\u00a0               << \\\"v / V_0:\\\\t\\\" << error_dil.second * vol_reference << \\\" / \\\"\\n\\u00a0               << vol_reference << \\\" = \\\" << error_dil.second << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n Solid::get_error_dilation\\nCalculate the volume of the domain in the spatial configuration\\n\\u00a0   template <int dim>\\n\\u00a0   double Solid<dim>::compute_vol_current() const\\n\\u00a0   {\\n\\u00a0     double vol_current = 0.0;\\n\\u00a0 \\n\\u00a0     FEValues<dim> fe_values(fe, qf_cell, update_JxW_values);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : triangulation.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0 \\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nIn contrast to that which was previously called for, in this instance the quadrature point data is specifically non-modifiable since we will only be accessing data. We ensure that the right get_data function is called by marking this update function as constant.\\n\\u00a0         const std::vector<std::shared_ptr<const PointHistory<dim>>> lqph =\\n\\u00a0           quadrature_point_history.get_data(cell);\\n\\u00a0         Assert(lqph.size() == n_q_points, ExcInternalError());\\n\\u00a0 \\n\\u00a0         for (const unsigned int q_point : fe_values.quadrature_point_indices())\\n\\u00a0           {\\n\\u00a0             const double det_F_qp = lqph[q_point]->get_det_F();\\n\\u00a0             const double JxW      = fe_values.JxW(q_point);\\n\\u00a0 \\n\\u00a0             vol_current += det_F_qp * JxW;\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0     Assert(vol_current > 0.0, ExcInternalError());\\n\\u00a0     return vol_current;\\n\\u00a0   }\\n\\u00a0 \\nCalculate how well the dilatation \\\\(\\\\widetilde{J}\\\\) agrees with  \\\\(J\\n   \\\\dealcoloneq \\\\textrm{det}\\\\ \\\\mathbf{F}\\\\) from the \\\\(L^2\\\\) error  \\\\( \\\\bigl[\\n   \\\\int_{\\\\Omega_0} {[ J - \\\\widetilde{J}]}^{2}\\\\textrm{d}V \\\\bigr]^{1/2}\\\\). We also return the ratio of the current volume of the domain to the reference volume. This is of interest for incompressible media where we want to check how well the isochoric constraint has been enforced.\\n\\u00a0   template <int dim>\\n\\u00a0   std::pair<double, double> Solid<dim>::get_error_dilation() const\\n\\u00a0   {\\n\\u00a0     double dil_L2_error = 0.0;\\n\\u00a0 \\n\\u00a0     FEValues<dim> fe_values(fe, qf_cell, update_JxW_values);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : triangulation.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0         const std::vector<std::shared_ptr<const PointHistory<dim>>> lqph =\\n\\u00a0           quadrature_point_history.get_data(cell);\\n\\u00a0         Assert(lqph.size() == n_q_points, ExcInternalError());\\n\\u00a0 \\n\\u00a0         for (const unsigned int q_point : fe_values.quadrature_point_indices())\\n\\u00a0           {\\n\\u00a0             const double det_F_qp   = lqph[q_point]->get_det_F();\\n\\u00a0             const double J_tilde_qp = lqph[q_point]->get_J_tilde();\\n\\u00a0             const double the_error_qp_squared =\\n\\u00a0               Utilities::fixed_power<2>((det_F_qp - J_tilde_qp));\\n\\u00a0             const double JxW = fe_values.JxW(q_point);\\n\\u00a0 \\n\\u00a0             dil_L2_error += the_error_qp_squared * JxW;\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     return std::make_pair(std::sqrt(dil_L2_error),\\n\\u00a0                           compute_vol_current() / vol_reference);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nUtilities::fixed_powerconstexpr T fixed_power(const T t)Definition utilities.h:942\\nstd::sqrt::VectorizedArray< Number, width > sqrt(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6869\\n Solid::get_error_residual\\nDetermine the true residual error for the problem. That is, determine the error in the residual for the unconstrained degrees of freedom. Note that to do so, we need to ignore constrained DOFs by setting the residual in these vector components to zero.\\n\\u00a0   template <int dim>\\n\\u00a0   void Solid<dim>::get_error_residual(Errors &error_residual)\\n\\u00a0   {\\n\\u00a0     BlockVector<double> error_res(dofs_per_block);\\n\\u00a0 \\n\\u00a0     for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)\\n\\u00a0       if (!constraints.is_constrained(i))\\n\\u00a0         error_res(i) = system_rhs(i);\\n\\u00a0 \\n\\u00a0     error_residual.norm = error_res.l2_norm();\\n\\u00a0     error_residual.u    = error_res.block(u_dof).l2_norm();\\n\\u00a0     error_residual.p    = error_res.block(p_dof).l2_norm();\\n\\u00a0     error_residual.J    = error_res.block(J_dof).l2_norm();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n Solid::get_error_update\\nDetermine the true Newton update error for the problem\\n\\u00a0   template <int dim>\\n\\u00a0   void Solid<dim>::get_error_update(const BlockVector<double> &newton_update,\\n\\u00a0                                     Errors                    &error_update)\\n\\u00a0   {\\n\\u00a0     BlockVector<double> error_ud(dofs_per_block);\\n\\u00a0     for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)\\n\\u00a0       if (!constraints.is_constrained(i))\\n\\u00a0         error_ud(i) = newton_update(i);\\n\\u00a0 \\n\\u00a0     error_update.norm = error_ud.l2_norm();\\n\\u00a0     error_update.u    = error_ud.block(u_dof).l2_norm();\\n\\u00a0     error_update.p    = error_ud.block(p_dof).l2_norm();\\n\\u00a0     error_update.J    = error_ud.block(J_dof).l2_norm();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n Solid::get_total_solution\\nThis function provides the total solution, which is valid at any Newton step. This is required as, to reduce computational error, the total solution is only updated at the end of the timestep.\\n\\u00a0   template <int dim>\\n\\u00a0   BlockVector<double> Solid<dim>::get_total_solution(\\n\\u00a0     const BlockVector<double> &solution_delta) const\\n\\u00a0   {\\n\\u00a0     BlockVector<double> solution_total(solution_n);\\n\\u00a0     solution_total += solution_delta;\\n\\u00a0     return solution_total;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n Solid::assemble_system\\nSince we use TBB for assembly, we simply setup a copy of the data structures required for the process and pass them, along with the assembly functions to the WorkStream object for processing. Note that we must ensure that the matrix and RHS vector are reset before any assembly operations can occur. Furthermore, since we are describing a problem with Neumann BCs, we will need the face normals and so must specify this in the face update flags.\\n\\u00a0   template <int dim>\\n\\u00a0   void Solid<dim>::assemble_system()\\n\\u00a0   {\\n\\u00a0     timer.enter_subsection(\\\"Assemble system\\\");\\n\\u00a0     std::cout << \\\" ASM_SYS \\\" << std::flush;\\n\\u00a0 \\n\\u00a0     tangent_matrix = 0.0;\\n\\u00a0     system_rhs     = 0.0;\\n\\u00a0 \\n\\u00a0     const UpdateFlags uf_cell(update_values | update_gradients |\\n\\u00a0                               update_JxW_values);\\n\\u00a0     const UpdateFlags uf_face(update_values | update_normal_vectors |\\n\\u00a0                               update_JxW_values);\\n\\u00a0 \\n\\u00a0     PerTaskData_ASM per_task_data(dofs_per_cell);\\n\\u00a0     ScratchData_ASM scratch_data(fe, qf_cell, uf_cell, qf_face, uf_face);\\n\\u00a0 \\nupdate_normal_vectors@ update_normal_vectorsNormal vectors.Definition fe_update_flags.h:141\\nThe syntax used here to pass data to the WorkStream class is discussed in step-13.\\n\\u00a0     WorkStream::run(\\n\\u00a0       dof_handler.active_cell_iterators(),\\n\\u00a0       [this](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0              ScratchData_ASM                                      &scratch,\\n\\u00a0              PerTaskData_ASM                                      &data) {\\n\\u00a0         this->assemble_system_one_cell(cell, scratch, data);\\n\\u00a0       },\\n\\u00a0       [this](const PerTaskData_ASM &data) {\\n\\u00a0         this->constraints.distribute_local_to_global(data.cell_matrix,\\n\\u00a0                                                      data.cell_rhs,\\n\\u00a0                                                      data.local_dof_indices,\\n\\u00a0                                                      tangent_matrix,\\n\\u00a0                                                      system_rhs);\\n\\u00a0       },\\n\\u00a0       scratch_data,\\n\\u00a0       per_task_data);\\n\\u00a0 \\n\\u00a0     timer.leave_subsection();\\n\\u00a0   }\\n\\u00a0 \\nOf course, we still have to define how we assemble the tangent matrix contribution for a single cell. We first need to reset and initialize some of the scratch data structures and retrieve some basic information regarding the DOF numbering on this cell. We can precalculate the cell shape function values and gradients. Note that the shape function gradients are defined with regard to the current configuration. That is  \\\\(\\\\textrm{grad}\\\\ \\\\boldsymbol{\\\\varphi} = \\\\textrm{Grad}\\\\ \\\\boldsymbol{\\\\varphi}\\n   \\\\ \\\\mathbf{F}^{-1}\\\\).\\n\\u00a0   template <int dim>\\n\\u00a0   void Solid<dim>::assemble_system_one_cell(\\n\\u00a0     const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0     ScratchData_ASM                                      &scratch,\\n\\u00a0     PerTaskData_ASM                                      &data) const\\n\\u00a0   {\\n\\u00a0     data.reset();\\n\\u00a0     scratch.reset();\\n\\u00a0     scratch.fe_values.reinit(cell);\\n\\u00a0     cell->get_dof_indices(data.local_dof_indices);\\n\\u00a0 \\n\\u00a0     const std::vector<std::shared_ptr<const PointHistory<dim>>> lqph =\\n\\u00a0       quadrature_point_history.get_data(cell);\\n\\u00a0     Assert(lqph.size() == n_q_points, ExcInternalError());\\n\\u00a0 \\n\\u00a0     for (const unsigned int q_point :\\n\\u00a0          scratch.fe_values.quadrature_point_indices())\\n\\u00a0       {\\n\\u00a0         const Tensor<2, dim> F_inv = lqph[q_point]->get_F_inv();\\n\\u00a0         for (const unsigned int k : scratch.fe_values.dof_indices())\\n\\u00a0           {\\n\\u00a0             const unsigned int k_group = fe.system_to_base_index(k).first.first;\\n\\u00a0 \\n\\u00a0             if (k_group == u_dof)\\n\\u00a0               {\\n\\u00a0                 scratch.grad_Nx[q_point][k] =\\n\\u00a0                   scratch.fe_values[u_fe].gradient(k, q_point) * F_inv;\\n\\u00a0                 scratch.symm_grad_Nx[q_point][k] =\\n\\u00a0                   symmetrize(scratch.grad_Nx[q_point][k]);\\n\\u00a0               }\\n\\u00a0             else if (k_group == p_dof)\\n\\u00a0               scratch.Nx[q_point][k] =\\n\\u00a0                 scratch.fe_values[p_fe].value(k, q_point);\\n\\u00a0             else if (k_group == J_dof)\\n\\u00a0               scratch.Nx[q_point][k] =\\n\\u00a0                 scratch.fe_values[J_fe].value(k, q_point);\\n\\u00a0             else\\n\\u00a0               Assert(k_group <= J_dof, ExcInternalError());\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\nsymmetrizeDEAL_II_HOST constexpr SymmetricTensor< 2, dim, Number > symmetrize(const Tensor< 2, dim, Number > &t)Definition symmetric_tensor.h:3534\\nNow we build the local cell stiffness matrix and RHS vector. Since the global and local system matrices are symmetric, we can exploit this property by building only the lower half of the local matrix and copying the values to the upper half. So we only assemble half of the \\\\(\\\\mathsf{\\\\mathbf{k}}_{uu}\\\\),  \\\\(\\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{p}\\n   \\\\widetilde{p}} = \\\\mathbf{0}\\\\),  \\\\(\\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{J}\\n   \\\\widetilde{J}}\\\\) blocks, while the whole \\\\(\\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{p} \\\\widetilde{J}}\\\\), \\\\(\\\\mathsf{\\\\mathbf{k}}_{u \\\\widetilde{J}} = \\\\mathbf{0}\\\\), \\\\(\\\\mathsf{\\\\mathbf{k}}_{u \\\\widetilde{p}}\\\\) blocks are built.\\nIn doing so, we first extract some configuration dependent variables from our quadrature history objects for the current quadrature point.\\n\\u00a0     for (const unsigned int q_point :\\n\\u00a0          scratch.fe_values.quadrature_point_indices())\\n\\u00a0       {\\n\\u00a0         const SymmetricTensor<2, dim> tau     = lqph[q_point]->get_tau();\\n\\u00a0         const Tensor<2, dim>          tau_ns  = lqph[q_point]->get_tau();\\n\\u00a0         const SymmetricTensor<4, dim> Jc      = lqph[q_point]->get_Jc();\\n\\u00a0         const double                  det_F   = lqph[q_point]->get_det_F();\\n\\u00a0         const double                  p_tilde = lqph[q_point]->get_p_tilde();\\n\\u00a0         const double                  J_tilde = lqph[q_point]->get_J_tilde();\\n\\u00a0         const double dPsi_vol_dJ   = lqph[q_point]->get_dPsi_vol_dJ();\\n\\u00a0         const double d2Psi_vol_dJ2 = lqph[q_point]->get_d2Psi_vol_dJ2();\\n\\u00a0         const SymmetricTensor<2, dim> &I =\\n\\u00a0           Physics::Elasticity::StandardTensors<dim>::I;\\n\\u00a0 \\nThese two tensors store some precomputed data. Their use will explained shortly.\\n\\u00a0         SymmetricTensor<2, dim> symm_grad_Nx_i_x_Jc;\\n\\u00a0         Tensor<1, dim>          grad_Nx_i_comp_i_x_tau;\\n\\u00a0 \\nNext we define some aliases to make the assembly process easier to follow.\\n\\u00a0         const std::vector<double>                  &N = scratch.Nx[q_point];\\n\\u00a0         const std::vector<SymmetricTensor<2, dim>> &symm_grad_Nx =\\n\\u00a0           scratch.symm_grad_Nx[q_point];\\n\\u00a0         const std::vector<Tensor<2, dim>> &grad_Nx = scratch.grad_Nx[q_point];\\n\\u00a0         const double                       JxW = scratch.fe_values.JxW(q_point);\\n\\u00a0 \\n\\u00a0         for (const unsigned int i : scratch.fe_values.dof_indices())\\n\\u00a0           {\\n\\u00a0             const unsigned int component_i =\\n\\u00a0               fe.system_to_component_index(i).first;\\n\\u00a0             const unsigned int i_group = fe.system_to_base_index(i).first.first;\\n\\u00a0 \\nWe first compute the contributions from the internal forces. Note, by definition of the rhs as the negative of the residual, these contributions are subtracted.\\n\\u00a0             if (i_group == u_dof)\\n\\u00a0               data.cell_rhs(i) -= (symm_grad_Nx[i] * tau) * JxW;\\n\\u00a0             else if (i_group == p_dof)\\n\\u00a0               data.cell_rhs(i) -= N[i] * (det_F - J_tilde) * JxW;\\n\\u00a0             else if (i_group == J_dof)\\n\\u00a0               data.cell_rhs(i) -= N[i] * (dPsi_vol_dJ - p_tilde) * JxW;\\n\\u00a0             else\\n\\u00a0               Assert(i_group <= J_dof, ExcInternalError());\\n\\u00a0 \\nBefore we go into the inner loop, we have one final chance to introduce some optimizations. We've already taken into account the symmetry of the system, and we can now precompute some common terms that are repeatedly applied in the inner loop. We won't be excessive here, but will rather focus on expensive operations, namely those involving the rank-4 material stiffness tensor and the rank-2 stress tensor.\\nWhat we may observe is that both of these tensors are contracted with shape function gradients indexed on the \\\"i\\\" DoF. This implies that this particular operation remains constant as we loop over the \\\"j\\\" DoF. For that reason, we can extract this from the inner loop and save the many operations that, for each quadrature point and DoF index \\\"i\\\" and repeated over index \\\"j\\\" are required to double contract a rank-2 symmetric tensor with a rank-4 symmetric tensor, and a rank-1 tensor with a rank-2 tensor.\\nAt the loss of some readability, this small change will reduce the assembly time of the symmetrized system by about half when using the simulation default parameters, and becomes more significant as the h-refinement level increases.\\n\\u00a0             if (i_group == u_dof)\\n\\u00a0               {\\n\\u00a0                 symm_grad_Nx_i_x_Jc    = symm_grad_Nx[i] * Jc;\\n\\u00a0                 grad_Nx_i_comp_i_x_tau = grad_Nx[i][component_i] * tau_ns;\\n\\u00a0               }\\n\\u00a0 \\nNow we're prepared to compute the tangent matrix contributions:\\n\\u00a0             for (const unsigned int j :\\n\\u00a0                  scratch.fe_values.dof_indices_ending_at(i))\\n\\u00a0               {\\n\\u00a0                 const unsigned int component_j =\\n\\u00a0                   fe.system_to_component_index(j).first;\\n\\u00a0                 const unsigned int j_group =\\n\\u00a0                   fe.system_to_base_index(j).first.first;\\n\\u00a0 \\nThis is the \\\\(\\\\mathsf{\\\\mathbf{k}}_{uu}\\\\) contribution. It comprises a material contribution, and a geometrical stress contribution which is only added along the local matrix diagonals:\\n\\u00a0                 if ((i_group == j_group) && (i_group == u_dof))\\n\\u00a0                   {\\nThe material contribution:\\n\\u00a0                     data.cell_matrix(i, j) += symm_grad_Nx_i_x_Jc *  \\n\\u00a0                                               symm_grad_Nx[j] * JxW; \\n\\u00a0 \\nThe geometrical stress contribution:\\n\\u00a0                     if (component_i == component_j)\\n\\u00a0                       data.cell_matrix(i, j) +=\\n\\u00a0                         grad_Nx_i_comp_i_x_tau * grad_Nx[j][component_j] * JxW;\\n\\u00a0                   }\\nNext is the \\\\(\\\\mathsf{\\\\mathbf{k}}_{ \\\\widetilde{p} u}\\\\) contribution\\n\\u00a0                 else if ((i_group == p_dof) && (j_group == u_dof))\\n\\u00a0                   {\\n\\u00a0                     data.cell_matrix(i, j) += N[i] * det_F *               \\n\\u00a0                                               (symm_grad_Nx[j] * I) * JxW; \\n\\u00a0                   }\\nand lastly the  \\\\(\\\\mathsf{\\\\mathbf{k}}_{ \\\\widetilde{J}\\n   \\\\widetilde{p}}\\\\) and  \\\\(\\\\mathsf{\\\\mathbf{k}}_{ \\\\widetilde{J}\\n   \\\\widetilde{J}}\\\\) contributions:\\n\\u00a0                 else if ((i_group == J_dof) && (j_group == p_dof))\\n\\u00a0                   data.cell_matrix(i, j) -= N[i] * N[j] * JxW;\\n\\u00a0                 else if ((i_group == j_group) && (i_group == J_dof))\\n\\u00a0                   data.cell_matrix(i, j) += N[i] * d2Psi_vol_dJ2 * N[j] * JxW;\\n\\u00a0                 else\\n\\u00a0                   Assert((i_group <= J_dof) && (j_group <= J_dof),\\n\\u00a0                          ExcInternalError());\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\nNext we assemble the Neumann contribution. We first check to see it the cell face exists on a boundary on which a traction is applied and add the contribution if this is the case.\\n\\u00a0     for (const auto &face : cell->face_iterators())\\n\\u00a0       if (face->at_boundary() && face->boundary_id() == 6)\\n\\u00a0         {\\n\\u00a0           scratch.fe_face_values.reinit(cell, face);\\n\\u00a0 \\n\\u00a0           for (const unsigned int f_q_point :\\n\\u00a0                scratch.fe_face_values.quadrature_point_indices())\\n\\u00a0             {\\n\\u00a0               const Tensor<1, dim> &N =\\n\\u00a0                 scratch.fe_face_values.normal_vector(f_q_point);\\n\\u00a0 \\nUsing the face normal at this quadrature point we specify the traction in reference configuration. For this problem, a defined pressure is applied in the reference configuration. The direction of the applied traction is assumed not to evolve with the deformation of the domain. The traction is defined using the first Piola-Kirchhoff stress is simply  \\\\(\\\\mathbf{t} = \\\\mathbf{P}\\\\mathbf{N} = [p_0 \\\\mathbf{I}]\\n   \\\\mathbf{N} = p_0 \\\\mathbf{N}\\\\) We use the time variable to linearly ramp up the pressure load.\\nNote that the contributions to the right hand side vector we compute here only exist in the displacement components of the vector.\\n\\u00a0               static const double p0 =\\n\\u00a0                 -4.0 / (parameters.scale * parameters.scale);\\n\\u00a0               const double         time_ramp = (time.current() / time.end());\\n\\u00a0               const double         pressure  = p0 * parameters.p_p0 * time_ramp;\\n\\u00a0               const Tensor<1, dim> traction  = pressure * N;\\n\\u00a0 \\n\\u00a0               for (const unsigned int i : scratch.fe_values.dof_indices())\\n\\u00a0                 {\\n\\u00a0                   const unsigned int i_group =\\n\\u00a0                     fe.system_to_base_index(i).first.first;\\n\\u00a0 \\n\\u00a0                   if (i_group == u_dof)\\n\\u00a0                     {\\n\\u00a0                       const unsigned int component_i =\\n\\u00a0                         fe.system_to_component_index(i).first;\\n\\u00a0                       const double Ni =\\n\\u00a0                         scratch.fe_face_values.shape_value(i, f_q_point);\\n\\u00a0                       const double JxW = scratch.fe_face_values.JxW(f_q_point);\\n\\u00a0 \\n\\u00a0                       data.cell_rhs(i) += (Ni * traction[component_i]) * JxW;\\n\\u00a0                     }\\n\\u00a0                 }\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0 \\nFinally, we need to copy the lower half of the local matrix into the upper half:\\n\\u00a0     for (const unsigned int i : scratch.fe_values.dof_indices())\\n\\u00a0       for (const unsigned int j :\\n\\u00a0            scratch.fe_values.dof_indices_starting_at(i + 1))\\n\\u00a0         data.cell_matrix(i, j) = data.cell_matrix(j, i);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n Solid::make_constraints\\nThe constraints for this problem are simple to describe. In this particular example, the boundary values will be calculated for the two first iterations of Newton's algorithm. In general, one would build non-homogeneous constraints in the zeroth iteration (that is, when apply_dirichlet_bc == true in the code block that follows) and build only the corresponding homogeneous constraints in the following step. While the current example has only homogeneous constraints, previous experiences have shown that a common error is forgetting to add the extra condition when refactoring the code to specific uses. This could lead to errors that are hard to debug. In this spirit, we choose to make the code more verbose in terms of what operations are performed at each Newton step.\\n\\u00a0   template <int dim>\\n\\u00a0   void Solid<dim>::make_constraints(const int it_nr)\\n\\u00a0   {\\nSince we (a) are dealing with an iterative Newton method, (b) are using an incremental formulation for the displacement, and (c) apply the constraints to the incremental displacement field, any non-homogeneous constraints on the displacement update should only be specified at the zeroth iteration. No subsequent contributions are to be made since the constraints will be exactly satisfied after that iteration.\\n\\u00a0     const bool apply_dirichlet_bc = (it_nr == 0);\\n\\u00a0 \\nFurthermore, after the first Newton iteration within a timestep, the constraints remain the same and we do not need to modify or rebuild them so long as we do not clear the constraints object.\\n\\u00a0     if (it_nr > 1)\\n\\u00a0       {\\n\\u00a0         std::cout << \\\" --- \\\" << std::flush;\\n\\u00a0         return;\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     std::cout << \\\" CST \\\" << std::flush;\\n\\u00a0 \\n\\u00a0     if (apply_dirichlet_bc)\\n\\u00a0       {\\nAt the zeroth Newton iteration we wish to apply the full set of non-homogeneous and homogeneous constraints that represent the boundary conditions on the displacement increment. Since in general the constraints may be different at each time step, we need to clear the constraints matrix and completely rebuild it. An example case would be if a surface is accelerating; in such a scenario the change in displacement is non-constant between each time step.\\n\\u00a0         constraints.clear();\\n\\u00a0 \\nThe boundary conditions for the indentation problem in 3d are as follows: On the -x, -y and -z faces (IDs 0,2,4) we set up a symmetry condition to allow only planar movement while the +x and +z faces (IDs 1,5) are traction free. In this contrived problem, part of the +y face (ID 3) is set to have no motion in the x- and z-component. Finally, as described earlier, the other part of the +y face has an the applied pressure but is also constrained in the x- and z-directions.\\nIn the following, we will have to tell the function interpolation boundary values which components of the solution vector should be constrained (i.e., whether it's the x-, y-, z-displacements or combinations thereof). This is done using ComponentMask objects (see GlossComponentMask) which we can get from the finite element if we provide it with an extractor object for the component we wish to select. To this end we first set up such extractor objects and later use it when generating the relevant component masks:\\n\\u00a0         const FEValuesExtractors::Scalar x_displacement(0);\\n\\u00a0         const FEValuesExtractors::Scalar y_displacement(1);\\n\\u00a0 \\n\\u00a0         {\\n\\u00a0           const int boundary_id = 0;\\n\\u00a0 \\n\\u00a0           VectorTools::interpolate_boundary_values(\\n\\u00a0             dof_handler,\\n\\u00a0             boundary_id,\\n\\u00a0             Functions::ZeroFunction<dim>(n_components),\\n\\u00a0             constraints,\\n\\u00a0             fe.component_mask(x_displacement));\\n\\u00a0         }\\n\\u00a0         {\\n\\u00a0           const int boundary_id = 2;\\n\\u00a0 \\n\\u00a0           VectorTools::interpolate_boundary_values(\\n\\u00a0             dof_handler,\\n\\u00a0             boundary_id,\\n\\u00a0             Functions::ZeroFunction<dim>(n_components),\\n\\u00a0             constraints,\\n\\u00a0             fe.component_mask(y_displacement));\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0         if (dim == 3)\\n\\u00a0           {\\n\\u00a0             const FEValuesExtractors::Scalar z_displacement(2);\\n\\u00a0 \\n\\u00a0             {\\n\\u00a0               const int boundary_id = 3;\\n\\u00a0 \\n\\u00a0               VectorTools::interpolate_boundary_values(\\n\\u00a0                 dof_handler,\\n\\u00a0                 boundary_id,\\n\\u00a0                 Functions::ZeroFunction<dim>(n_components),\\n\\u00a0                 constraints,\\n\\u00a0                 (fe.component_mask(x_displacement) |\\n\\u00a0                  fe.component_mask(z_displacement)));\\n\\u00a0             }\\n\\u00a0             {\\n\\u00a0               const int boundary_id = 4;\\n\\u00a0 \\n\\u00a0               VectorTools::interpolate_boundary_values(\\n\\u00a0                 dof_handler,\\n\\u00a0                 boundary_id,\\n\\u00a0                 Functions::ZeroFunction<dim>(n_components),\\n\\u00a0                 constraints,\\n\\u00a0                 fe.component_mask(z_displacement));\\n\\u00a0             }\\n\\u00a0 \\n\\u00a0             {\\n\\u00a0               const int boundary_id = 6;\\n\\u00a0 \\n\\u00a0               VectorTools::interpolate_boundary_values(\\n\\u00a0                 dof_handler,\\n\\u00a0                 boundary_id,\\n\\u00a0                 Functions::ZeroFunction<dim>(n_components),\\n\\u00a0                 constraints,\\n\\u00a0                 (fe.component_mask(x_displacement) |\\n\\u00a0                  fe.component_mask(z_displacement)));\\n\\u00a0             }\\n\\u00a0           }\\n\\u00a0         else\\n\\u00a0           {\\n\\u00a0             {\\n\\u00a0               const int boundary_id = 3;\\n\\u00a0 \\n\\u00a0               VectorTools::interpolate_boundary_values(\\n\\u00a0                 dof_handler,\\n\\u00a0                 boundary_id,\\n\\u00a0                 Functions::ZeroFunction<dim>(n_components),\\n\\u00a0                 constraints,\\n\\u00a0                 (fe.component_mask(x_displacement)));\\n\\u00a0             }\\n\\u00a0             {\\n\\u00a0               const int boundary_id = 6;\\n\\u00a0 \\n\\u00a0               VectorTools::interpolate_boundary_values(\\n\\u00a0                 dof_handler,\\n\\u00a0                 boundary_id,\\n\\u00a0                 Functions::ZeroFunction<dim>(n_components),\\n\\u00a0                 constraints,\\n\\u00a0                 (fe.component_mask(x_displacement)));\\n\\u00a0             }\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       {\\nFunctions::ZeroFunctionDefinition function.h:510\\nVectorTools::interpolate_boundary_valuesvoid interpolate_boundary_values(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const std::map< types::boundary_id, const Function< spacedim, number > * > &function_map, std::map< types::global_dof_index, number > &boundary_values, const ComponentMask &component_mask={})\\ntypes::boundary_idunsigned int boundary_idDefinition types.h:144\\nAs all Dirichlet constraints are fulfilled exactly after the zeroth Newton iteration, we want to ensure that no further modification are made to those entries. This implies that we want to convert all non-homogeneous Dirichlet constraints into homogeneous ones.\\nIn this example the procedure to do this is quite straightforward, and in fact we can (and will) circumvent any unnecessary operations when only homogeneous boundary conditions are applied. In a more general problem one should be mindful of hanging node and periodic constraints, which may also introduce some inhomogeneities. It might then be advantageous to keep disparate objects for the different types of constraints, and merge them together once the homogeneous Dirichlet constraints have been constructed.\\n\\u00a0         if (constraints.has_inhomogeneities())\\n\\u00a0           {\\nSince the affine constraints were finalized at the previous Newton iteration, they may not be modified directly. So we need to copy them to another temporary object and make modification there. Once we're done, we'll transfer them back to the main constraints object.\\n\\u00a0             AffineConstraints<double> homogeneous_constraints(constraints);\\n\\u00a0             for (unsigned int dof = 0; dof != dof_handler.n_dofs(); ++dof)\\n\\u00a0               if (homogeneous_constraints.is_inhomogeneously_constrained(dof))\\n\\u00a0                 homogeneous_constraints.set_inhomogeneity(dof, 0.0);\\n\\u00a0 \\n\\u00a0             constraints.clear();\\n\\u00a0             constraints.copy_from(homogeneous_constraints);\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     constraints.close();\\n\\u00a0   }\\n\\u00a0 \\n Solid::assemble_sc\\nSolving the entire block system is a bit problematic as there are no contributions to the \\\\(\\\\mathsf{\\\\mathbf{K}}_{ \\\\widetilde{J} \\\\widetilde{J}}\\\\) block, rendering it noninvertible (when using an iterative solver). Since the pressure and dilatation variables DOFs are discontinuous, we can condense them out to form a smaller displacement-only system which we will then solve and subsequently post-process to retrieve the pressure and dilatation solutions.\\nThe static condensation process could be performed at a global level but we need the inverse of one of the blocks. However, since the pressure and dilatation variables are discontinuous, the static condensation (SC) operation can also be done on a per-cell basis and we can produce the inverse of the block-diagonal \\\\(\\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{p}\\\\widetilde{J}}\\\\) block by inverting the local blocks. We can again use TBB to do this since each operation will be independent of one another.\\nUsing the TBB via the WorkStream class, we assemble the contributions to form     \\\\(\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\textrm{con}}\\n   = \\\\bigl[ \\\\mathsf{\\\\mathbf{K}}_{uu} +\\n   \\\\overline{\\\\overline{\\\\mathsf{\\\\mathbf{K}}}}~ \\\\bigr]\\n   \\\\) from each element's contributions. These contributions are then added to the global stiffness matrix. Given this description, the following two functions should be clear:\\n\\u00a0   template <int dim>\\n\\u00a0   void Solid<dim>::assemble_sc()\\n\\u00a0   {\\n\\u00a0     timer.enter_subsection(\\\"Perform static condensation\\\");\\n\\u00a0     std::cout << \\\" ASM_SC \\\" << std::flush;\\n\\u00a0 \\n\\u00a0     PerTaskData_SC per_task_data(dofs_per_cell,\\n\\u00a0                                  element_indices_u.size(),\\n\\u00a0                                  element_indices_p.size(),\\n\\u00a0                                  element_indices_J.size());\\n\\u00a0     ScratchData_SC scratch_data;\\n\\u00a0 \\n\\u00a0     WorkStream::run(dof_handler.active_cell_iterators(),\\n\\u00a0                     *this,\\n\\u00a0                     &Solid::assemble_sc_one_cell,\\n\\u00a0                     &Solid::copy_local_to_global_sc,\\n\\u00a0                     scratch_data,\\n\\u00a0                     per_task_data);\\n\\u00a0 \\n\\u00a0     timer.leave_subsection();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void Solid<dim>::copy_local_to_global_sc(const PerTaskData_SC &data)\\n\\u00a0   {\\n\\u00a0     for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0       for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0         tangent_matrix.add(data.local_dof_indices[i],\\n\\u00a0                            data.local_dof_indices[j],\\n\\u00a0                            data.cell_matrix(i, j));\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nNow we describe the static condensation process. As per usual, we must first find out which global numbers the degrees of freedom on this cell have and reset some data structures:\\n\\u00a0   template <int dim>\\n\\u00a0   void Solid<dim>::assemble_sc_one_cell(\\n\\u00a0     const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0     ScratchData_SC                                       &scratch,\\n\\u00a0     PerTaskData_SC                                       &data)\\n\\u00a0   {\\n\\u00a0     data.reset();\\n\\u00a0     scratch.reset();\\n\\u00a0     cell->get_dof_indices(data.local_dof_indices);\\n\\u00a0 \\nWe now extract the contribution of the dofs associated with the current cell to the global stiffness matrix. The discontinuous nature of the \\\\(\\\\widetilde{p}\\\\) and \\\\(\\\\widetilde{J}\\\\) interpolations mean that their is no coupling of the local contributions at the global level. This is not the case with the \\\\(\\\\mathbf{u}\\\\) dof. In other words, \\\\(\\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{J} \\\\widetilde{p}}\\\\), \\\\(\\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{p} \\\\widetilde{p}}\\\\) and \\\\(\\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{J} \\\\widetilde{p}}\\\\), when extracted from the global stiffness matrix are the element contributions. This is not the case for \\\\(\\\\mathsf{\\\\mathbf{k}}_{uu}\\\\).\\nNote: A lower-case symbol is used to denote element stiffness matrices.\\nCurrently the matrix corresponding to the dof associated with the current element (denoted somewhat loosely as \\\\(\\\\mathsf{\\\\mathbf{k}}\\\\)) is of the form:         \\n\\\\begin{align*}\\n   \\\\begin{bmatrix}\\n   \\\\mathsf{\\\\mathbf{k}}_{uu}  &  \\\\mathsf{\\\\mathbf{k}}_{u\\\\widetilde{p}}\\n   & \\\\mathbf{0}\\n   \\\\\\\\ \\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{p}u} & \\\\mathbf{0}  &\\n   \\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{p}\\\\widetilde{J}}\\n   \\\\\\\\ \\\\mathbf{0}  &  \\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{J}\\\\widetilde{p}}  &\\n   \\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{J}\\\\widetilde{J}} \\\\end{bmatrix}\\n   \\\\end{align*}\\n\\nWe now need to modify it such that it appear as         \\n\\\\begin{align*}\\n   \\\\begin{bmatrix}\\n   \\\\mathsf{\\\\mathbf{k}}_{\\\\textrm{con}}   &\\n   \\\\mathsf{\\\\mathbf{k}}_{u\\\\widetilde{p}}    & \\\\mathbf{0}\\n   \\\\\\\\ \\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{p}u} & \\\\mathbf{0} &\\n   \\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{p}\\\\widetilde{J}}^{-1}\\n   \\\\\\\\ \\\\mathbf{0} & \\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{J}\\\\widetilde{p}} &\\n   \\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{J}\\\\widetilde{J}} \\\\end{bmatrix}\\n   \\\\end{align*}\\n\\n with   \\\\(\\\\mathsf{\\\\mathbf{k}}_{\\\\textrm{con}} = \\\\bigl[\\n   \\\\mathsf{\\\\mathbf{k}}_{uu} +\\\\overline{\\\\overline{\\\\mathsf{\\\\mathbf{k}}}}~\\n   \\\\bigr]\\\\) where    \\\\(               \\\\overline{\\\\overline{\\\\mathsf{\\\\mathbf{k}}}}\\n   \\\\dealcoloneq \\\\mathsf{\\\\mathbf{k}}_{u\\\\widetilde{p}}\\n   \\\\overline{\\\\mathsf{\\\\mathbf{k}}} \\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{p}u}\\n   \\\\) and      \\\\(\\n   \\\\overline{\\\\mathsf{\\\\mathbf{k}}} =\\n   \\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{J}\\\\widetilde{p}}^{-1}\\n   \\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{J}\\\\widetilde{J}}\\n   \\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{p}\\\\widetilde{J}}^{-1}\\n   \\\\).\\nAt this point, we need to take note of the fact that global data already exists in the \\\\(\\\\mathsf{\\\\mathbf{K}}_{uu}\\\\), \\\\(\\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{p} \\\\widetilde{J}}\\\\) and \\\\(\\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J} \\\\widetilde{p}}\\\\) sub-blocks. So if we are to modify them, we must account for the data that is already there (i.e. simply add to it or remove it if necessary). Since the copy_local_to_global operation is a \\\"+=\\\" operation, we need to take this into account\\nFor the \\\\(\\\\mathsf{\\\\mathbf{K}}_{uu}\\\\) block in particular, this means that contributions have been added from the surrounding cells, so we need to be careful when we manipulate this block. We can't just erase the sub-blocks.\\nThis is the strategy we will employ to get the sub-blocks we want:\\n\\n\\\\( {\\\\mathsf{\\\\mathbf{k}}}_{\\\\textrm{store}}\\\\): Since we don't have access to \\\\(\\\\mathsf{\\\\mathbf{k}}_{uu}\\\\), but we know its contribution is added to the global \\\\(\\\\mathsf{\\\\mathbf{K}}_{uu}\\\\) matrix, we just want to add the element wise static-condensation \\\\(\\\\overline{\\\\overline{\\\\mathsf{\\\\mathbf{k}}}}\\\\).\\n\\\\(\\\\mathsf{\\\\mathbf{k}}^{-1}_{\\\\widetilde{p} \\\\widetilde{J}}\\\\): Similarly,  \\\\(\\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{p}\\n   \\\\widetilde{J}}\\\\) exists in the subblock. Since the copy operation is a += operation, we need to subtract the existing \\\\(\\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{p} \\\\widetilde{J}}\\\\) submatrix in addition to \\\"adding\\\" that which we wish to replace it with.\\n\\\\(\\\\mathsf{\\\\mathbf{k}}^{-1}_{\\\\widetilde{J} \\\\widetilde{p}}\\\\): Since the global matrix is symmetric, this block is the same as the one above and we can simply use \\\\(\\\\mathsf{\\\\mathbf{k}}^{-1}_{\\\\widetilde{p} \\\\widetilde{J}}\\\\) as a substitute for this one.\\n\\nWe first extract element data from the system matrix. So first we get the entire subblock for the cell, then extract \\\\(\\\\mathsf{\\\\mathbf{k}}\\\\) for the dofs associated with the current element\\n\\u00a0     data.k_orig.extract_submatrix_from(tangent_matrix,\\n\\u00a0                                        data.local_dof_indices,\\n\\u00a0                                        data.local_dof_indices);\\nand next the local matrices for \\\\(\\\\mathsf{\\\\mathbf{k}}_{ \\\\widetilde{p} u}\\\\) \\\\(\\\\mathsf{\\\\mathbf{k}}_{ \\\\widetilde{p} \\\\widetilde{J}}\\\\) and \\\\(\\\\mathsf{\\\\mathbf{k}}_{ \\\\widetilde{J} \\\\widetilde{J}}\\\\):\\n\\u00a0     data.k_pu.extract_submatrix_from(data.k_orig,\\n\\u00a0                                      element_indices_p,\\n\\u00a0                                      element_indices_u);\\n\\u00a0     data.k_pJ.extract_submatrix_from(data.k_orig,\\n\\u00a0                                      element_indices_p,\\n\\u00a0                                      element_indices_J);\\n\\u00a0     data.k_JJ.extract_submatrix_from(data.k_orig,\\n\\u00a0                                      element_indices_J,\\n\\u00a0                                      element_indices_J);\\n\\u00a0 \\nTo get the inverse of  \\\\(\\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{p}\\n   \\\\widetilde{J}}\\\\), we invert it directly. This operation is relatively inexpensive since \\\\(\\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{p} \\\\widetilde{J}}\\\\) since block-diagonal.\\n\\u00a0     data.k_pJ_inv.invert(data.k_pJ);\\n\\u00a0 \\nNow we can make condensation terms to add to the \\\\(\\\\mathsf{\\\\mathbf{k}}_{uu}\\\\) block and put them in the cell local matrix      \\\\(\\n   \\\\mathsf{\\\\mathbf{A}}\\n   =\\n   \\\\mathsf{\\\\mathbf{k}}^{-1}_{\\\\widetilde{p} \\\\widetilde{J}}\\n   \\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{p} u}\\n   \\\\):\\n\\u00a0     data.k_pJ_inv.mmult(data.A, data.k_pu);\\n\\\\(\\n   \\\\mathsf{\\\\mathbf{B}}\\n   =\\n   \\\\mathsf{\\\\mathbf{k}}^{-1}_{\\\\widetilde{J} \\\\widetilde{J}}\\n   \\\\mathsf{\\\\mathbf{k}}^{-1}_{\\\\widetilde{p} \\\\widetilde{J}}\\n   \\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{p} u}\\n   \\\\)\\n\\u00a0     data.k_JJ.mmult(data.B, data.A);\\n\\\\(\\n   \\\\mathsf{\\\\mathbf{C}}\\n   =\\n   \\\\mathsf{\\\\mathbf{k}}^{-1}_{\\\\widetilde{J} \\\\widetilde{p}}\\n   \\\\mathsf{\\\\mathbf{k}}^{-1}_{\\\\widetilde{J} \\\\widetilde{J}}\\n   \\\\mathsf{\\\\mathbf{k}}^{-1}_{\\\\widetilde{p} \\\\widetilde{J}}\\n   \\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{p} u}\\n   \\\\)\\n\\u00a0     data.k_pJ_inv.Tmmult(data.C, data.B);\\n\\\\(\\n   \\\\overline{\\\\overline{\\\\mathsf{\\\\mathbf{k}}}}\\n   =\\n   \\\\mathsf{\\\\mathbf{k}}_{u \\\\widetilde{p}}\\n   \\\\mathsf{\\\\mathbf{k}}^{-1}_{\\\\widetilde{J} \\\\widetilde{p}}\\n   \\\\mathsf{\\\\mathbf{k}}^{-1}_{\\\\widetilde{J} \\\\widetilde{J}}\\n   \\\\mathsf{\\\\mathbf{k}}^{-1}_{\\\\widetilde{p} \\\\widetilde{J}}\\n   \\\\mathsf{\\\\mathbf{k}}_{\\\\widetilde{p} u}\\n   \\\\)\\n\\u00a0     data.k_pu.Tmmult(data.k_bbar, data.C);\\n\\u00a0     data.k_bbar.scatter_matrix_to(element_indices_u,\\n\\u00a0                                   element_indices_u,\\n\\u00a0                                   data.cell_matrix);\\n\\u00a0 \\nNext we place \\\\(\\\\mathsf{\\\\mathbf{k}}^{-1}_{ \\\\widetilde{p} \\\\widetilde{J}}\\\\) in the \\\\(\\\\mathsf{\\\\mathbf{k}}_{ \\\\widetilde{p} \\\\widetilde{J}}\\\\) block for post-processing. Note again that we need to remove the contribution that already exists there.\\n\\u00a0     data.k_pJ_inv.add(-1.0, data.k_pJ);\\n\\u00a0     data.k_pJ_inv.scatter_matrix_to(element_indices_p,\\n\\u00a0                                     element_indices_J,\\n\\u00a0                                     data.cell_matrix);\\n\\u00a0   }\\n\\u00a0 \\n Solid::solve_linear_system\\nWe now have all of the necessary components to use one of two possible methods to solve the linearised system. The first is to perform static condensation on an element level, which requires some alterations to the tangent matrix and RHS vector. Alternatively, the full block system can be solved by performing condensation on a global level. Below we implement both approaches.\\n\\u00a0   template <int dim>\\n\\u00a0   std::pair<unsigned int, double>\\n\\u00a0   Solid<dim>::solve_linear_system(BlockVector<double> &newton_update)\\n\\u00a0   {\\n\\u00a0     unsigned int lin_it  = 0;\\n\\u00a0     double       lin_res = 0.0;\\n\\u00a0 \\n\\u00a0     if (parameters.use_static_condensation == true)\\n\\u00a0       {\\nFirstly, here is the approach using the (permanent) augmentation of the tangent matrix. For the following, recall that            \\n\\\\begin{align*}\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\textrm{store}}\\n   \\\\dealcoloneq\\n   \\\\begin{bmatrix}\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\textrm{con}}      &\\n   \\\\mathsf{\\\\mathbf{K}}_{u\\\\widetilde{p}}    & \\\\mathbf{0}\\n   \\\\\\\\  \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{p}u}    &       \\\\mathbf{0} &\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{p}\\\\widetilde{J}}^{-1}\\n   \\\\\\\\  \\\\mathbf{0}      &\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J}\\\\widetilde{p}}                &\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J}\\\\widetilde{J}} \\\\end{bmatrix} \\\\, .\\n   \\\\end{align*}\\n\\n and                           \\n\\\\begin{align*}\\n   d \\\\widetilde{\\\\mathsf{\\\\mathbf{p}}}\\n   & =\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J}\\\\widetilde{p}}^{-1}\\n   \\\\bigl[\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{J}}\\n   -\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J}\\\\widetilde{J}}\\n   d \\\\widetilde{\\\\mathsf{\\\\mathbf{J}}} \\\\bigr]\\n   \\\\\\\\ d \\\\widetilde{\\\\mathsf{\\\\mathbf{J}}}\\n   & =\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{p}\\\\widetilde{J}}^{-1}\\n   \\\\bigl[\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{p}}\\n   - \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{p}u} d\\n   \\\\mathsf{\\\\mathbf{u}} \\\\bigr]\\n   \\\\\\\\ \\\\Rightarrow d \\\\widetilde{\\\\mathsf{\\\\mathbf{p}}}\\n   &= \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J}\\\\widetilde{p}}^{-1}\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{J}}\\n   -\\n   \\\\underbrace{\\\\bigl[\\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J}\\\\widetilde{p}}^{-1}\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J}\\\\widetilde{J}}\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{p}\\\\widetilde{J}}^{-1}\\\\bigr]}_{\\\\overline{\\\\mathsf{\\\\mathbf{K}}}}\\\\bigl[\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{p}}\\n   - \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{p}u} d\\n   \\\\mathsf{\\\\mathbf{u}} \\\\bigr]\\n   \\\\end{align*}\\n\\n and thus                 \\n\\\\[\\n   \\\\underbrace{\\\\bigl[ \\\\mathsf{\\\\mathbf{K}}_{uu} +\\n   \\\\overline{\\\\overline{\\\\mathsf{\\\\mathbf{K}}}}~ \\\\bigr]\\n   }_{\\\\mathsf{\\\\mathbf{K}}_{\\\\textrm{con}}} d\\n   \\\\mathsf{\\\\mathbf{u}}\\n   =\\n   \\\\underbrace{\\n   \\\\Bigl[\\n   \\\\mathsf{\\\\mathbf{F}}_{u}\\n   - \\\\mathsf{\\\\mathbf{K}}_{u\\\\widetilde{p}} \\\\bigl[\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J}\\\\widetilde{p}}^{-1}\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{J}}\\n   -\\n   \\\\overline{\\\\mathsf{\\\\mathbf{K}}}\\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{p}}\\n   \\\\bigr]\\n   \\\\Bigr]}_{\\\\mathsf{\\\\mathbf{F}}_{\\\\textrm{con}}}\\n   \\\\]\\n\\n where      \\n\\\\[\\n   \\\\overline{\\\\overline{\\\\mathsf{\\\\mathbf{K}}}} \\\\dealcoloneq\\n   \\\\mathsf{\\\\mathbf{K}}_{u\\\\widetilde{p}}\\n   \\\\overline{\\\\mathsf{\\\\mathbf{K}}}\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{p}u} \\\\, .\\n   \\\\]\\n\\nAt the top, we allocate two temporary vectors to help with the static condensation, and variables to store the number of linear solver iterations and the (hopefully converged) residual.\\n\\u00a0         BlockVector<double> A(dofs_per_block);\\n\\u00a0         BlockVector<double> B(dofs_per_block);\\n\\u00a0 \\n\\u00a0 \\nIn the first step of this function, we solve for the incremental displacement \\\\(d\\\\mathbf{u}\\\\). To this end, we perform static condensation to make   \\\\(\\\\mathsf{\\\\mathbf{K}}_{\\\\textrm{con}}\\n   = \\\\bigl[ \\\\mathsf{\\\\mathbf{K}}_{uu} +\\n   \\\\overline{\\\\overline{\\\\mathsf{\\\\mathbf{K}}}}~ \\\\bigr]\\\\) and put \\\\(\\\\mathsf{\\\\mathbf{K}}^{-1}_{\\\\widetilde{p} \\\\widetilde{J}}\\\\) in the original \\\\(\\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{p} \\\\widetilde{J}}\\\\) block. That is, we make \\\\(\\\\mathsf{\\\\mathbf{K}}_{\\\\textrm{store}}\\\\).\\n\\u00a0         {\\n\\u00a0           assemble_sc();\\n\\u00a0 \\n\\\\(\\n   \\\\mathsf{\\\\mathbf{A}}_{\\\\widetilde{J}}\\n   =\\n   \\\\mathsf{\\\\mathbf{K}}^{-1}_{\\\\widetilde{p} \\\\widetilde{J}}\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{p}}\\n   \\\\)\\n\\u00a0           tangent_matrix.block(p_dof, J_dof)\\n\\u00a0             .vmult(A.block(J_dof), system_rhs.block(p_dof));\\n\\\\(\\n   \\\\mathsf{\\\\mathbf{B}}_{\\\\widetilde{J}}\\n   =\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J} \\\\widetilde{J}}\\n   \\\\mathsf{\\\\mathbf{K}}^{-1}_{\\\\widetilde{p} \\\\widetilde{J}}\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{p}}\\n   \\\\)\\n\\u00a0           tangent_matrix.block(J_dof, J_dof)\\n\\u00a0             .vmult(B.block(J_dof), A.block(J_dof));\\n\\\\(\\n   \\\\mathsf{\\\\mathbf{A}}_{\\\\widetilde{J}}\\n   =\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{J}}\\n   -\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J} \\\\widetilde{J}}\\n   \\\\mathsf{\\\\mathbf{K}}^{-1}_{\\\\widetilde{p} \\\\widetilde{J}}\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{p}}\\n   \\\\)\\n\\u00a0           A.block(J_dof) = system_rhs.block(J_dof);\\n\\u00a0           A.block(J_dof) -= B.block(J_dof);\\n\\\\(\\n   \\\\mathsf{\\\\mathbf{A}}_{\\\\widetilde{J}}\\n   =\\n   \\\\mathsf{\\\\mathbf{K}}^{-1}_{\\\\widetilde{J} \\\\widetilde{p}}\\n   [\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{J}}\\n   -\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J} \\\\widetilde{J}}\\n   \\\\mathsf{\\\\mathbf{K}}^{-1}_{\\\\widetilde{p} \\\\widetilde{J}}\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{p}}\\n   ]\\n   \\\\)\\n\\u00a0           tangent_matrix.block(p_dof, J_dof)\\n\\u00a0             .Tvmult(A.block(p_dof), A.block(J_dof));\\n\\\\(\\n   \\\\mathsf{\\\\mathbf{A}}_{u}\\n   =\\n   \\\\mathsf{\\\\mathbf{K}}_{u \\\\widetilde{p}}\\n   \\\\mathsf{\\\\mathbf{K}}^{-1}_{\\\\widetilde{J} \\\\widetilde{p}}\\n   [\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{J}}\\n   -\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J} \\\\widetilde{J}}\\n   \\\\mathsf{\\\\mathbf{K}}^{-1}_{\\\\widetilde{p} \\\\widetilde{J}}\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{p}}\\n   ]\\n   \\\\)\\n\\u00a0           tangent_matrix.block(u_dof, p_dof)\\n\\u00a0             .vmult(A.block(u_dof), A.block(p_dof));\\n\\\\(\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\text{con}}\\n   =\\n   \\\\mathsf{\\\\mathbf{F}}_{u}\\n   -\\n   \\\\mathsf{\\\\mathbf{K}}_{u \\\\widetilde{p}}\\n   \\\\mathsf{\\\\mathbf{K}}^{-1}_{\\\\widetilde{J} \\\\widetilde{p}}\\n   [\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{J}}\\n   -\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J} \\\\widetilde{J}}\\n   \\\\mathsf{\\\\mathbf{K}}^{-1}_{\\\\widetilde{p} \\\\widetilde{J}}\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{p}}\\n   ]\\n   \\\\)\\n\\u00a0           system_rhs.block(u_dof) -= A.block(u_dof);\\n\\u00a0 \\n\\u00a0           timer.enter_subsection(\\\"Linear solver\\\");\\n\\u00a0           std::cout << \\\" SLV \\\" << std::flush;\\n\\u00a0           if (parameters.type_lin == \\\"CG\\\")\\n\\u00a0             {\\n\\u00a0               const auto solver_its = static_cast<unsigned int>(\\n\\u00a0                 tangent_matrix.block(u_dof, u_dof).m() *\\n\\u00a0                 parameters.max_iterations_lin);\\n\\u00a0               const double tol_sol =\\n\\u00a0                 parameters.tol_lin * system_rhs.block(u_dof).l2_norm();\\n\\u00a0 \\n\\u00a0               SolverControl solver_control(solver_its, tol_sol);\\n\\u00a0 \\n\\u00a0               GrowingVectorMemory<Vector<double>> GVM;\\n\\u00a0               SolverCG<Vector<double>> solver_CG(solver_control, GVM);\\n\\u00a0 \\nGrowingVectorMemoryDefinition vector_memory.h:314\\nSolverCGDefinition solver_cg.h:179\\nSolverControlDefinition solver_control.h:67\\nWe've chosen by default a SSOR preconditioner as it appears to provide the fastest solver convergence characteristics for this problem on a single-thread machine. However, this might not be true for different problem sizes.\\n\\u00a0               PreconditionSelector<SparseMatrix<double>, Vector<double>>\\n\\u00a0                 preconditioner(parameters.preconditioner_type,\\n\\u00a0                                parameters.preconditioner_relaxation);\\n\\u00a0               preconditioner.use_matrix(tangent_matrix.block(u_dof, u_dof));\\n\\u00a0 \\n\\u00a0               solver_CG.solve(tangent_matrix.block(u_dof, u_dof),\\n\\u00a0                               newton_update.block(u_dof),\\n\\u00a0                               system_rhs.block(u_dof),\\n\\u00a0                               preconditioner);\\n\\u00a0 \\n\\u00a0               lin_it  = solver_control.last_step();\\n\\u00a0               lin_res = solver_control.last_value();\\n\\u00a0             }\\n\\u00a0           else if (parameters.type_lin == \\\"Direct\\\")\\n\\u00a0             {\\nBlockVectorBase::blockBlockType & block(const unsigned int i)\\nPreconditionSelectorDefinition precondition_selector.h:101\\nOtherwise if the problem is small enough, a direct solver can be utilised.\\n\\u00a0               SparseDirectUMFPACK A_direct;\\n\\u00a0               A_direct.initialize(tangent_matrix.block(u_dof, u_dof));\\n\\u00a0               A_direct.vmult(newton_update.block(u_dof),\\n\\u00a0                              system_rhs.block(u_dof));\\n\\u00a0 \\n\\u00a0               lin_it  = 1;\\n\\u00a0               lin_res = 0.0;\\n\\u00a0             }\\n\\u00a0           else\\n\\u00a0             Assert(false, ExcMessage(\\\"Linear solver type not implemented\\\"));\\n\\u00a0 \\n\\u00a0           timer.leave_subsection();\\n\\u00a0         }\\n\\u00a0 \\nSparseDirectUMFPACKDefinition sparse_direct.h:92\\nSparseDirectUMFPACK::initializevoid initialize(const SparsityPattern &sparsity_pattern)Definition sparse_direct.cc:67\\nNow that we have the displacement update, distribute the constraints back to the Newton update:\\n\\u00a0         constraints.distribute(newton_update);\\n\\u00a0 \\n\\u00a0         timer.enter_subsection(\\\"Linear solver postprocessing\\\");\\n\\u00a0         std::cout << \\\" PP \\\" << std::flush;\\n\\u00a0 \\nThe next step after solving the displacement problem is to post-process to get the dilatation solution from the substitution:       \\\\(\\n   d \\\\widetilde{\\\\mathsf{\\\\mathbf{J}}}\\n   = \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{p}\\\\widetilde{J}}^{-1} \\\\bigl[\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{p}}\\n   - \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{p}u} d \\\\mathsf{\\\\mathbf{u}}\\n   \\\\bigr]\\n   \\\\)\\n\\u00a0         {\\n\\\\(\\n   \\\\mathsf{\\\\mathbf{A}}_{\\\\widetilde{p}}\\n   =\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{p}u} d \\\\mathsf{\\\\mathbf{u}}\\n   \\\\)\\n\\u00a0           tangent_matrix.block(p_dof, u_dof)\\n\\u00a0             .vmult(A.block(p_dof), newton_update.block(u_dof));\\n\\\\(\\n   \\\\mathsf{\\\\mathbf{A}}_{\\\\widetilde{p}}\\n   =\\n   -\\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{p}u} d \\\\mathsf{\\\\mathbf{u}}\\n   \\\\)\\n\\u00a0           A.block(p_dof) *= -1.0;\\n\\\\(\\n   \\\\mathsf{\\\\mathbf{A}}_{\\\\widetilde{p}}\\n   =\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{p}}\\n   -\\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{p}u} d \\\\mathsf{\\\\mathbf{u}}\\n   \\\\)\\n\\u00a0           A.block(p_dof) += system_rhs.block(p_dof);\\n\\\\(\\n   d\\\\mathsf{\\\\mathbf{\\\\widetilde{J}}}\\n   =\\n   \\\\mathsf{\\\\mathbf{K}}^{-1}_{\\\\widetilde{p}\\\\widetilde{J}}\\n   [\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{p}}\\n   -\\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{p}u} d \\\\mathsf{\\\\mathbf{u}}\\n   ]\\n   \\\\)\\n\\u00a0           tangent_matrix.block(p_dof, J_dof)\\n\\u00a0             .vmult(newton_update.block(J_dof), A.block(p_dof));\\n\\u00a0         }\\n\\u00a0 \\nwe ensure here that any Dirichlet constraints are distributed on the updated solution:\\n\\u00a0         constraints.distribute(newton_update);\\n\\u00a0 \\nFinally we solve for the pressure update with the substitution:          \\\\(\\n   d \\\\widetilde{\\\\mathsf{\\\\mathbf{p}}}\\n   =\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J}\\\\widetilde{p}}^{-1}\\n   \\\\bigl[\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{J}}\\n   - \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J}\\\\widetilde{J}}\\n   d \\\\widetilde{\\\\mathsf{\\\\mathbf{J}}}\\n   \\\\bigr]\\n   \\\\)\\n\\u00a0         {\\n\\\\(\\n   \\\\mathsf{\\\\mathbf{A}}_{\\\\widetilde{J}}\\n   =\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J}\\\\widetilde{J}}\\n   d \\\\widetilde{\\\\mathsf{\\\\mathbf{J}}}\\n   \\\\)\\n\\u00a0           tangent_matrix.block(J_dof, J_dof)\\n\\u00a0             .vmult(A.block(J_dof), newton_update.block(J_dof));\\n\\\\(\\n   \\\\mathsf{\\\\mathbf{A}}_{\\\\widetilde{J}}\\n   =\\n   -\\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J}\\\\widetilde{J}}\\n   d \\\\widetilde{\\\\mathsf{\\\\mathbf{J}}}\\n   \\\\)\\n\\u00a0           A.block(J_dof) *= -1.0;\\n\\\\(\\n   \\\\mathsf{\\\\mathbf{A}}_{\\\\widetilde{J}}\\n   =\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{J}}\\n   -\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J}\\\\widetilde{J}}\\n   d \\\\widetilde{\\\\mathsf{\\\\mathbf{J}}}\\n   \\\\)\\n\\u00a0           A.block(J_dof) += system_rhs.block(J_dof);\\nand finally....          \\\\(\\n   d \\\\widetilde{\\\\mathsf{\\\\mathbf{p}}}\\n   =\\n   \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J}\\\\widetilde{p}}^{-1}\\n   \\\\bigl[\\n   \\\\mathsf{\\\\mathbf{F}}_{\\\\widetilde{J}}\\n   - \\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J}\\\\widetilde{J}}\\n   d \\\\widetilde{\\\\mathsf{\\\\mathbf{J}}}\\n   \\\\bigr]\\n   \\\\)\\n\\u00a0           tangent_matrix.block(p_dof, J_dof)\\n\\u00a0             .Tvmult(newton_update.block(p_dof), A.block(J_dof));\\n\\u00a0         }\\n\\u00a0 \\nWe are now at the end, so we distribute all constrained dofs back to the Newton update:\\n\\u00a0         constraints.distribute(newton_update);\\n\\u00a0 \\n\\u00a0         timer.leave_subsection();\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       {\\n\\u00a0         std::cout << \\\" ------ \\\" << std::flush;\\n\\u00a0 \\n\\u00a0         timer.enter_subsection(\\\"Linear solver\\\");\\n\\u00a0         std::cout << \\\" SLV \\\" << std::flush;\\n\\u00a0 \\n\\u00a0         if (parameters.type_lin == \\\"CG\\\")\\n\\u00a0           {\\nManual condensation of the dilatation and pressure fields on a local level, and subsequent post-processing, took quite a bit of effort to achieve. To recap, we had to produce the inverse matrix \\\\(\\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{p}\\\\widetilde{J}}^{-1}\\\\), which was permanently written into the global tangent matrix. We then permanently modified \\\\(\\\\mathsf{\\\\mathbf{K}}_{uu}\\\\) to produce \\\\(\\\\mathsf{\\\\mathbf{K}}_{\\\\textrm{con}}\\\\). This involved the extraction and manipulation of local sub-blocks of the tangent matrix. After solving for the displacement, the individual matrix-vector operations required to solve for dilatation and pressure were carefully implemented. Contrast these many sequence of steps to the much simpler and transparent implementation using functionality provided by the LinearOperator class.\\nFor ease of later use, we define some aliases for blocks in the RHS vector\\n\\u00a0             const Vector<double> &f_u = system_rhs.block(u_dof);\\n\\u00a0             const Vector<double> &f_p = system_rhs.block(p_dof);\\n\\u00a0             const Vector<double> &f_J = system_rhs.block(J_dof);\\n\\u00a0 \\n... and for blocks in the Newton update vector.\\n\\u00a0             Vector<double> &d_u = newton_update.block(u_dof);\\n\\u00a0             Vector<double> &d_p = newton_update.block(p_dof);\\n\\u00a0             Vector<double> &d_J = newton_update.block(J_dof);\\n\\u00a0 \\nWe next define some linear operators for the tangent matrix sub-blocks We will exploit the symmetry of the system, so not all blocks are required.\\n\\u00a0             const auto K_uu =\\n\\u00a0               linear_operator(tangent_matrix.block(u_dof, u_dof));\\n\\u00a0             const auto K_up =\\n\\u00a0               linear_operator(tangent_matrix.block(u_dof, p_dof));\\n\\u00a0             const auto K_pu =\\n\\u00a0               linear_operator(tangent_matrix.block(p_dof, u_dof));\\n\\u00a0             const auto K_Jp =\\n\\u00a0               linear_operator(tangent_matrix.block(J_dof, p_dof));\\n\\u00a0             const auto K_JJ =\\n\\u00a0               linear_operator(tangent_matrix.block(J_dof, J_dof));\\n\\u00a0 \\nWe then construct a LinearOperator that represents the inverse of (square block) \\\\(\\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J}\\\\widetilde{p}}\\\\). Since it is diagonal (or, when a higher order ansatz it used, nearly diagonal), a Jacobi preconditioner is suitable.\\n\\u00a0             PreconditionSelector<SparseMatrix<double>, Vector<double>>\\n\\u00a0               preconditioner_K_Jp_inv(\\\"jacobi\\\");\\n\\u00a0             preconditioner_K_Jp_inv.use_matrix(\\n\\u00a0               tangent_matrix.block(J_dof, p_dof));\\n\\u00a0             ReductionControl solver_control_K_Jp_inv(\\n\\u00a0               static_cast<unsigned int>(tangent_matrix.block(J_dof, p_dof).m() *\\n\\u00a0                                         parameters.max_iterations_lin),\\n\\u00a0               1.0e-30,\\n\\u00a0               parameters.tol_lin);\\n\\u00a0             SolverSelector<Vector<double>> solver_K_Jp_inv;\\n\\u00a0             solver_K_Jp_inv.select(\\\"cg\\\");\\n\\u00a0             solver_K_Jp_inv.set_control(solver_control_K_Jp_inv);\\n\\u00a0             const auto K_Jp_inv =\\n\\u00a0               inverse_operator(K_Jp, solver_K_Jp_inv, preconditioner_K_Jp_inv);\\n\\u00a0 \\nReductionControlDefinition solver_control.h:424\\nSolverSelectorDefinition solver_selector.h:93\\nSolverSelector::selectvoid select(const std::string &name)Definition solver_selector.h:264\\ninverse_operatorLinearOperator< Domain, Range, Payload > inverse_operator(const LinearOperator< Range, Domain, Payload > &op, Solver &solver, const Preconditioner &preconditioner)Definition linear_operator.h:720\\nNow we can construct that transpose of \\\\(\\\\mathsf{\\\\mathbf{K}}_{\\\\widetilde{J}\\\\widetilde{p}}^{-1}\\\\) and a linear operator that represents the condensed operations \\\\(\\\\overline{\\\\mathsf{\\\\mathbf{K}}}\\\\) and \\\\(\\\\overline{\\\\overline{\\\\mathsf{\\\\mathbf{K}}}}\\\\) and the final augmented matrix \\\\(\\\\mathsf{\\\\mathbf{K}}_{\\\\textrm{con}}\\\\). Note that the schur_complement() operator could also be of use here, but for clarity and the purpose of demonstrating the similarities between the formulation and implementation of the linear solution scheme, we will perform these operations manually.\\n\\u00a0             const auto K_pJ_inv     = transpose_operator(K_Jp_inv);\\n\\u00a0             const auto K_pp_bar     = K_Jp_inv * K_JJ * K_pJ_inv;\\n\\u00a0             const auto K_uu_bar_bar = K_up * K_pp_bar * K_pu;\\n\\u00a0             const auto K_uu_con     = K_uu + K_uu_bar_bar;\\n\\u00a0 \\ntranspose_operatorLinearOperator< Domain, Range, Payload > transpose_operator(const LinearOperator< Range, Domain, Payload > &op)Definition linear_operator.h:679\\nLastly, we define an operator for inverse of augmented stiffness matrix, namely \\\\(\\\\mathsf{\\\\mathbf{K}}_{\\\\textrm{con}}^{-1}\\\\). Note that the preconditioner for the augmented stiffness matrix is different to the case when we use static condensation. In this instance, the preconditioner is based on a non-modified \\\\(\\\\mathsf{\\\\mathbf{K}}_{uu}\\\\), while with the first approach we actually modified the entries of this sub-block. However, since \\\\(\\\\mathsf{\\\\mathbf{K}}_{\\\\textrm{con}}\\\\) and \\\\(\\\\mathsf{\\\\mathbf{K}}_{uu}\\\\) operate on the same space, it remains adequate for this problem.\\n\\u00a0             PreconditionSelector<SparseMatrix<double>, Vector<double>>\\n\\u00a0               preconditioner_K_con_inv(parameters.preconditioner_type,\\n\\u00a0                                        parameters.preconditioner_relaxation);\\n\\u00a0             preconditioner_K_con_inv.use_matrix(\\n\\u00a0               tangent_matrix.block(u_dof, u_dof));\\n\\u00a0             ReductionControl solver_control_K_con_inv(\\n\\u00a0               static_cast<unsigned int>(tangent_matrix.block(u_dof, u_dof).m() *\\n\\u00a0                                         parameters.max_iterations_lin),\\n\\u00a0               1.0e-30,\\n\\u00a0               parameters.tol_lin);\\n\\u00a0             SolverSelector<Vector<double>> solver_K_con_inv;\\n\\u00a0             solver_K_con_inv.select(\\\"cg\\\");\\n\\u00a0             solver_K_con_inv.set_control(solver_control_K_con_inv);\\n\\u00a0             const auto K_uu_con_inv =\\n\\u00a0               inverse_operator(K_uu_con,\\n\\u00a0                                solver_K_con_inv,\\n\\u00a0                                preconditioner_K_con_inv);\\n\\u00a0 \\nNow we are in a position to solve for the displacement field. We can nest the linear operations, and the result is immediately written to the Newton update vector. It is clear that the implementation closely mimics the derivation stated in the introduction.\\n\\u00a0             d_u =\\n\\u00a0               K_uu_con_inv * (f_u - K_up * (K_Jp_inv * f_J - K_pp_bar * f_p));\\n\\u00a0 \\n\\u00a0             timer.leave_subsection();\\n\\u00a0 \\nThe operations need to post-process for the dilatation and pressure fields are just as easy to express.\\n\\u00a0             timer.enter_subsection(\\\"Linear solver postprocessing\\\");\\n\\u00a0             std::cout << \\\" PP \\\" << std::flush;\\n\\u00a0 \\n\\u00a0             d_J = K_pJ_inv * (f_p - K_pu * d_u);\\n\\u00a0             d_p = K_Jp_inv * (f_J - K_JJ * d_J);\\n\\u00a0 \\n\\u00a0             lin_it  = solver_control_K_con_inv.last_step();\\n\\u00a0             lin_res = solver_control_K_con_inv.last_value();\\n\\u00a0           }\\n\\u00a0         else if (parameters.type_lin == \\\"Direct\\\")\\n\\u00a0           {\\nSolve the full block system with a direct solver. As it is relatively robust, it may be immune to problem arising from the presence of the zero \\\\(\\\\mathsf{\\\\mathbf{K}}_{ \\\\widetilde{J} \\\\widetilde{J}}\\\\) block.\\n\\u00a0             SparseDirectUMFPACK A_direct;\\n\\u00a0             A_direct.initialize(tangent_matrix);\\n\\u00a0             A_direct.vmult(newton_update, system_rhs);\\n\\u00a0 \\n\\u00a0             lin_it  = 1;\\n\\u00a0             lin_res = 0.0;\\n\\u00a0 \\n\\u00a0             std::cout << \\\" -- \\\" << std::flush;\\n\\u00a0           }\\n\\u00a0         else\\n\\u00a0           Assert(false, ExcMessage(\\\"Linear solver type not implemented\\\"));\\n\\u00a0 \\n\\u00a0         timer.leave_subsection();\\n\\u00a0 \\nFinally, we again ensure here that any Dirichlet constraints are distributed on the updated solution:\\n\\u00a0         constraints.distribute(newton_update);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     return std::make_pair(lin_it, lin_res);\\n\\u00a0   }\\n\\u00a0 \\n Solid::output_results\\nHere we present how the results are written to file to be viewed using ParaView or VisIt. The method is similar to that shown in previous tutorials so will not be discussed in detail.\\nNoteAs of 2023, Visit 3.3.3 can still not deal with higher-order cells. Rather, it simply reports that there is no data to show. To view the results of this program with Visit, you will want to comment out the line that sets output_flags.write_higher_order_cells = true;. On the other hand, Paraview is able to understand VTU files with higher order cells just fine.\\n\\u00a0   template <int dim>\\n\\u00a0   void Solid<dim>::output_results() const\\n\\u00a0   {\\n\\u00a0     DataOut<dim> data_out;\\n\\u00a0     std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n\\u00a0       data_component_interpretation(\\n\\u00a0         dim, DataComponentInterpretation::component_is_part_of_vector);\\n\\u00a0     data_component_interpretation.push_back(\\n\\u00a0       DataComponentInterpretation::component_is_scalar);\\n\\u00a0     data_component_interpretation.push_back(\\n\\u00a0       DataComponentInterpretation::component_is_scalar);\\n\\u00a0 \\n\\u00a0     std::vector<std::string> solution_name(dim, \\\"displacement\\\");\\n\\u00a0     solution_name.emplace_back(\\\"pressure\\\");\\n\\u00a0     solution_name.emplace_back(\\\"dilatation\\\");\\n\\u00a0 \\n\\u00a0     DataOutBase::VtkFlags output_flags;\\n\\u00a0     output_flags.write_higher_order_cells       = true;\\n\\u00a0     output_flags.physical_units[\\\"displacement\\\"] = \\\"m\\\";\\n\\u00a0     data_out.set_flags(output_flags);\\n\\u00a0 \\n\\u00a0     data_out.attach_dof_handler(dof_handler);\\n\\u00a0     data_out.add_data_vector(solution_n,\\n\\u00a0                              solution_name,\\n\\u00a0                              DataOut<dim>::type_dof_data,\\n\\u00a0                              data_component_interpretation);\\n\\u00a0 \\nDataOutDefinition data_out.h:147\\nDataComponentInterpretation::component_is_scalar@ component_is_scalarDefinition data_component_interpretation.h:52\\nDataComponentInterpretation::component_is_part_of_vector@ component_is_part_of_vectorDefinition data_component_interpretation.h:58\\nDataOutBase::VtkFlagsDefinition data_out_base.h:1127\\nDataOutBase::VtkFlags::write_higher_order_cellsbool write_higher_order_cellsDefinition data_out_base.h:1201\\nSince we are dealing with a large deformation problem, it would be nice to display the result on a displaced grid! The MappingQEulerian class linked with the DataOut class provides an interface through which this can be achieved without physically moving the grid points in the Triangulation object ourselves. We first need to copy the solution to a temporary vector and then create the Eulerian mapping. We also specify the polynomial degree to the DataOut object in order to produce a more refined output data set when higher order polynomials are used.\\n\\u00a0     Vector<double> soln(solution_n.size());\\n\\u00a0     for (unsigned int i = 0; i < soln.size(); ++i)\\n\\u00a0       soln(i) = solution_n(i);\\n\\u00a0     MappingQEulerian<dim> q_mapping(degree, dof_handler, soln);\\n\\u00a0     data_out.build_patches(q_mapping, degree);\\n\\u00a0 \\n\\u00a0     std::ofstream output(\\\"solution-\\\" + std::to_string(dim) + \\\"d-\\\" +\\n\\u00a0                          std::to_string(time.get_timestep()) + \\\".vtu\\\");\\n\\u00a0     data_out.write_vtu(output);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 } // namespace Step44\\n\\u00a0 \\n\\u00a0 \\nMappingQEulerianDefinition mapping_q_eulerian.h:95\\n Main function\\nLastly we provide the main driver function which appears no different to the other tutorials.\\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   using namespace Step44;\\n\\u00a0 \\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       const unsigned int dim = 3;\\n\\u00a0       Solid<dim>         solid(\\\"parameters.prm\\\");\\n\\u00a0       solid.run();\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0 \\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nFirstly, we present a comparison of a series of 3-d results with those in the literature (see Reese et al (2000)) to demonstrate that the program works as expected.\\nWe begin with a comparison of the convergence with mesh refinement for the \\\\(Q_1-DGPM_0-DGPM_0\\\\) and \\\\(Q_2-DGPM_1-DGPM_1\\\\) formulations, as summarised in the figure below. The vertical displacement of the midpoint of the upper surface of the block is used to assess convergence. Both schemes demonstrate good convergence properties for varying values of the load parameter \\\\(p/p_0\\\\). The results agree with those in the literature. The lower-order formulation typically overestimates the displacement for low levels of refinement, while the higher-order interpolation scheme underestimates it, but be a lesser degree. This benchmark, and a series of others not shown here, give us confidence that the code is working as it should.\\n\\n\\n \\nConvergence of the \\\\(Q_1-DGPM_0-DGPM_0\\\\) formulation in 3-d. \\n\\n \\nConvergence of the \\\\(Q_2-DGPM_1-DGPM_1\\\\) formulation in 3-d. \\n\\n\\n\\nA typical screen output generated by running the problem is shown below. The particular case demonstrated is that of the \\\\(Q_2-DGPM_1-DGPM_1\\\\) formulation. It is clear that, using the Newton-Raphson method, quadratic convergence of the solution is obtained. Solution convergence is achieved within 5 Newton increments for all time-steps. The converged displacement's \\\\(L_2\\\\)-norm is several orders of magnitude less than the geometry scale.\\nGrid:\\n         Reference volume: 1e-09\\nTriangulation:\\n         Number of active cells: 64\\n         Number of degrees of freedom: 2699\\n    Setting up quadrature point data...\\n \\nTimestep 1 @ 0.1s\\n___________________________________________________________________________________________________________________________________________________________\\n                 SOLVER STEP                   |  LIN_IT   LIN_RES    RES_NORM     RES_U     RES_P      RES_J     NU_NORM      NU_U       NU_P       NU_J\\n___________________________________________________________________________________________________________________________________________________________\\n  0  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     786  2.118e-06  1.000e+00  1.000e+00  0.000e+00  0.000e+00  1.000e+00  1.000e+00  1.000e+00  1.000e+00\\n  1  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     552  1.031e-03  8.563e-02  8.563e-02  9.200e-13  3.929e-08  1.060e-01  3.816e-02  1.060e-01  1.060e-01\\n  2  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     667  5.602e-06  2.482e-03  2.482e-03  3.373e-15  2.982e-10  2.936e-03  2.053e-04  2.936e-03  2.936e-03\\n  3  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     856  6.469e-10  2.129e-06  2.129e-06  2.245e-19  1.244e-13  1.887e-06  7.289e-07  1.887e-06  1.887e-06\\n  4  ASM_R  CONVERGED!\\n___________________________________________________________________________________________________________________________________________________________\\nRelative errors:\\nDisplacement:   7.289e-07\\nForce:          2.451e-10\\nDilatation:     1.353e-07\\nv / V_0:        1.000e-09 / 1.000e-09 = 1.000e+00\\n \\n \\n[...]\\n \\nTimestep 10 @ 1.000e+00s\\n___________________________________________________________________________________________________________________________________________________________\\n                 SOLVER STEP                   |  LIN_IT   LIN_RES    RES_NORM     RES_U     RES_P      RES_J     NU_NORM      NU_U       NU_P       NU_J\\n___________________________________________________________________________________________________________________________________________________________\\n  0  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     874  2.358e-06  1.000e+00  1.000e+00  1.000e+00  1.000e+00  1.000e+00  1.000e+00  1.000e+00  1.000e+00\\n  1  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     658  2.942e-04  1.544e-01  1.544e-01  1.208e+13  1.855e+06  6.014e-02  7.398e-02  6.014e-02  6.014e-02\\n  2  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     790  2.206e-06  2.908e-03  2.908e-03  7.302e+10  2.067e+03  2.716e-03  1.433e-03  2.716e-03  2.717e-03\\n  3  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     893  2.374e-09  1.919e-06  1.919e-06  4.527e+07  4.100e+00  1.672e-06  6.842e-07  1.672e-06  1.672e-06\\n  4  ASM_R  CONVERGED!\\n___________________________________________________________________________________________________________________________________________________________\\nRelative errors:\\nDisplacement:   6.842e-07\\nForce:          8.995e-10\\nDilatation:     1.528e-06\\nv / V_0:        1.000e-09 / 1.000e-09 = 1.000e+00\\nUsing the Timer class, we can discern which parts of the code require the highest computational expense. For a case with a large number of degrees-of-freedom (i.e. a high level of refinement), a typical output of the Timer is given below. Much of the code in the tutorial has been developed based on the optimizations described, discussed and demonstrated in step-18 and others. With over 93% of the time being spent in the linear solver, it is obvious that it may be necessary to invest in a better solver for large three-dimensional problems. The SSOR preconditioner is not multithreaded but is effective for this class of solid problems. It may be beneficial to investigate the use of another solver such as those available through the Trilinos library.\\n+---------------------------------------------+------------+------------+\\n| Total wallclock time elapsed since start    | 9.874e+02s |            |\\n|                                             |            |            |\\n| Section                         | no. calls |  wall time | % of total |\\n+---------------------------------+-----------+------------+------------+\\n| Assemble system right-hand side |        53 | 1.727e+00s |  1.75e-01% |\\n| Assemble tangent matrix         |        43 | 2.707e+01s |  2.74e+00% |\\n| Linear solver                   |        43 | 9.248e+02s |  9.37e+01% |\\n| Linear solver postprocessing    |        43 | 2.743e-02s |  2.78e-03% |\\n| Perform static condensation     |        43 | 1.437e+01s |  1.46e+00% |\\n| Setup system                    |         1 | 3.897e-01s |  3.95e-02% |\\n| Update QPH data                 |        43 | 5.770e-01s |  5.84e-02% |\\n+---------------------------------+-----------+------------+------------+\\nWe then used ParaView to visualize the results for two cases. The first was for the coarsest grid and the lowest-order interpolation method: \\\\(Q_1-DGPM_0-DGPM_0\\\\). The second was on a refined grid using a \\\\(Q_2-DGPM_1-DGPM_1\\\\) formulation. The vertical component of the displacement, the pressure \\\\(\\\\widetilde{p}\\\\) and the dilatation \\\\(\\\\widetilde{J}\\\\) fields are shown below.\\nFor the first case it is clear that the coarse spatial discretization coupled with large displacements leads to a low quality solution (the loading ratio is \\\\(p/p_0=80\\\\)). Additionally, the pressure difference between elements is very large. The constant pressure field on the element means that the large pressure gradient is not captured. However, it should be noted that locking, which would be present in a standard \\\\(Q_1\\\\) displacement formulation does not arise even in this poorly discretised case. The final vertical displacement of the tracked node on the top surface of the block is still within 12.5% of the converged solution. The pressure solution is very coarse and has large jumps between adjacent cells. It is clear that the volume nearest to the applied traction undergoes compression while the outer extents of the domain are in a state of expansion. The dilatation solution field and pressure field are clearly linked, with positive dilatation indicating regions of positive pressure and negative showing regions placed in compression. As discussed in the Introduction, a compressive pressure has a negative sign while an expansive pressure takes a positive sign. This stems from the definition of the volumetric strain energy function and is opposite to the physically realistic interpretation of pressure.\\n\\n\\n \\nZ-displacement solution for the 3-d problem. \\n\\n \\nDiscontinuous piece-wise constant pressure field. \\n\\n \\nDiscontinuous piece-wise constant dilatation field. \\n\\n\\n\\nCombining spatial refinement and a higher-order interpolation scheme results in a high-quality solution. Three grid refinements coupled with a \\\\(Q_2-DGPM_1-DGPM_1\\\\) formulation produces a result that clearly captures the mechanics of the problem. The deformation of the traction surface is well resolved. We can now observe the actual extent of the applied traction, with the maximum force being applied at the central point of the surface causing the largest compression. Even though very high strains are experienced in the domain, especially at the boundary of the region of applied traction, the solution remains accurate. The pressure field is captured in far greater detail than before. There is a clear distinction and transition between regions of compression and expansion, and the linear approximation of the pressure field allows a refined visualization of the pressure at the sub-element scale. It should however be noted that the pressure field remains discontinuous and could be smoothed on a continuous grid for the post-processing purposes.\\n\\n\\n \\nZ-displacement solution for the 3-d problem. \\n\\n \\nDiscontinuous linear pressure field. \\n\\n \\nDiscontinuous linear dilatation field. \\n\\n\\n\\nThis brief analysis of the results demonstrates that the three-field formulation is effective in circumventing volumetric locking for highly-incompressible media. The mixed formulation is able to accurately simulate the displacement of a near-incompressible block under compression. The command-line output indicates that the volumetric change under extreme compression resulted in less than 0.01% volume change for a Poisson's ratio of 0.4999.\\nIn terms of run-time, the \\\\(Q_2-DGPM_1-DGPM_1\\\\) formulation tends to be more computationally expensive than the \\\\(Q_1-DGPM_0-DGPM_0\\\\) for a similar number of degrees-of-freedom (produced by adding an extra grid refinement level for the lower-order interpolation). This is shown in the graph below for a batch of tests run consecutively on a single 4-core (8-thread) machine. The increase in computational time for the higher-order method is likely due to the increased band-width required for the higher-order elements. As previously mentioned, the use of a better solver and preconditioner may mitigate the expense of using a higher-order formulation. It was observed that for the given problem using the multithreaded Jacobi preconditioner can reduce the computational runtime by up to 72% (for the worst case being a higher-order formulation with a large number of degrees-of-freedom) in comparison to the single-thread SSOR preconditioner. However, it is the author's experience that the Jacobi method of preconditioning may not be suitable for some finite-strain problems involving alternative constitutive models.\\n\\n\\n \\nRuntime on a 4-core machine, normalised against the lowest grid resolution \\\\(Q_1-DGPM_0-DGPM_0\\\\) solution that utilised a SSOR preconditioner. \\n\\n\\n\\nLastly, results for the displacement solution for the 2-d problem are showcased below for two different levels of grid refinement. It is clear that due to the extra constraints imposed by simulating in 2-d that the resulting displacement field, although qualitatively similar, is different to that of the 3-d case.\\n\\n\\n \\nY-displacement solution in 2-d for 2 global grid refinement levels. \\n\\n \\nY-displacement solution in 2-d for 5 global grid refinement levels. \\n\\n\\n\\n Possibilities for extensions\\nThere are a number of obvious extensions for this work:\\n\\nFirstly, an additional constraint could be added to the free-energy function in order to enforce a high degree of incompressibility in materials. An additional Lagrange multiplier would be introduced, but this could most easily be dealt with using the principle of augmented Lagrange multipliers. This is demonstrated in Simo and Taylor (1991) .\\nThe constitutive relationship used in this model is relatively basic. It may be beneficial to split the material class into two separate classes, one dealing with the volumetric response and the other the isochoric response, and produce a generic materials class (i.e. having abstract virtual functions that derived classes have to implement) that would allow for the addition of more complex material models. Such models could include other hyperelastic materials, plasticity and viscoelastic materials and others.\\nThe program has been developed for solving problems on single-node multicore machines. With a little effort, the program could be extended to a large-scale computing environment through the use of PETSc or Trilinos, using a similar technique to that demonstrated in step-40. This would mostly involve changes to the setup, assembly, PointHistory and linear solver routines.\\nAs this program assumes quasi-static equilibrium, extensions to include dynamic effects would be necessary to study problems where inertial effects are important, e.g. problems involving impact.\\nLoad and solution limiting procedures may be necessary for highly nonlinear problems. It is possible to add a linesearch algorithm to limit the step size within a Newton increment to ensure optimum convergence. It may also be necessary to use a load limiting method, such as the Riks method, to solve unstable problems involving geometric instability such as buckling and snap-through.\\nMany physical problems involve contact. It is possible to include the effect of frictional or frictionless contact between objects into this program. This would involve the addition of an extra term in the free-energy functional and therefore an addition to the assembly routine. One would also need to manage the contact problem (detection and stress calculations) itself. An alternative to additional penalty terms in the free-energy functional would be to use active set methods such as the one used in step-41.\\nThe complete condensation procedure using LinearOperators has been coded into the linear solver routine. This could also have been achieved through the application of the schur_complement() operator to condense out one or more of the fields in a more automated manner.\\nFinally, adaptive mesh refinement, as demonstrated in step-6 and step-18, could provide additional solution accuracy.\\n\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2011 - 2024 by the deal.II authors and\\n *                              & Jean-Paul Pelteret and Andrew McBride\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Authors: Jean-Paul Pelteret, University of Cape Town,\\n *          Andrew McBride, University of Erlangen-Nuremberg, 2010\\n */\\n \\n \\n#include <deal.II/base/function.h>\\n#include <deal.II/base/parameter_handler.h>\\n#include <deal.II/base/point.h>\\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/symmetric_tensor.h>\\n#include <deal.II/base/tensor.h>\\n#include <deal.II/base/timer.h>\\n#include <deal.II/base/work_stream.h>\\n#include <deal.II/dofs/dof_renumbering.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/base/quadrature_point_data.h>\\n \\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_tools.h>\\n#include <deal.II/grid/grid_in.h>\\n#include <deal.II/grid/tria.h>\\n \\n#include <deal.II/fe/fe_dgp.h>\\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_system.h>\\n#include <deal.II/fe/fe_tools.h>\\n#include <deal.II/fe/fe_values.h>\\n#include <deal.II/fe/mapping_q_eulerian.h>\\n \\n#include <deal.II/lac/block_sparse_matrix.h>\\n#include <deal.II/lac/block_vector.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/precondition_selector.h>\\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/solver_selector.h>\\n#include <deal.II/lac/sparse_direct.h>\\n#include <deal.II/lac/affine_constraints.h>\\n \\n#include <deal.II/lac/linear_operator.h>\\n#include <deal.II/lac/packaged_operation.h>\\n \\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/vector_tools.h>\\n \\n#include <deal.II/physics/elasticity/kinematics.h>\\n#include <deal.II/physics/elasticity/standard_tensors.h>\\n \\n#include <iostream>\\n#include <fstream>\\n \\n \\nnamespace Step44\\n{\\n using namespace dealii;\\n \\n namespace Parameters\\n  {\\n \\n struct FESystem\\n    {\\n unsigned int poly_degree;\\n unsigned int quad_order;\\n \\n static void declare_parameters(ParameterHandler &prm);\\n \\n void parse_parameters(ParameterHandler &prm);\\n    };\\n \\n \\n void FESystem::declare_parameters(ParameterHandler &prm)\\n    {\\n      prm.enter_subsection(\\\"Finite element system\\\");\\n      {\\n        prm.declare_entry(\\\"Polynomial degree\\\",\\n \\\"2\\\",\\n Patterns::Integer(0),\\n \\\"Displacement system polynomial order\\\");\\n \\n        prm.declare_entry(\\\"Quadrature order\\\",\\n \\\"3\\\",\\n Patterns::Integer(0),\\n \\\"Gauss quadrature order\\\");\\n      }\\n      prm.leave_subsection();\\n    }\\n \\n void FESystem::parse_parameters(ParameterHandler &prm)\\n    {\\n      prm.enter_subsection(\\\"Finite element system\\\");\\n      {\\n        poly_degree = prm.get_integer(\\\"Polynomial degree\\\");\\n        quad_order  = prm.get_integer(\\\"Quadrature order\\\");\\n      }\\n      prm.leave_subsection();\\n    }\\n \\n \\n struct Geometry\\n    {\\n unsigned int global_refinement;\\n double scale;\\n double       p_p0;\\n \\n static void declare_parameters(ParameterHandler &prm);\\n \\n void parse_parameters(ParameterHandler &prm);\\n    };\\n \\n void Geometry::declare_parameters(ParameterHandler &prm)\\n    {\\n      prm.enter_subsection(\\\"Geometry\\\");\\n      {\\n        prm.declare_entry(\\\"Global refinement\\\",\\n \\\"2\\\",\\n Patterns::Integer(0),\\n \\\"Global refinement level\\\");\\n \\n        prm.declare_entry(\\\"Grid scale\\\",\\n \\\"1e-3\\\",\\n Patterns::Double(0.0),\\n \\\"Global grid scaling factor\\\");\\n \\n        prm.declare_entry(\\\"Pressure ratio p/p0\\\",\\n \\\"100\\\",\\n Patterns::Selection(\\\"20|40|60|80|100\\\"),\\n \\\"Ratio of applied pressure to reference pressure\\\");\\n      }\\n      prm.leave_subsection();\\n    }\\n \\n void Geometry::parse_parameters(ParameterHandler &prm)\\n    {\\n      prm.enter_subsection(\\\"Geometry\\\");\\n      {\\n        global_refinement = prm.get_integer(\\\"Global refinement\\\");\\n scale             = prm.get_double(\\\"Grid scale\\\");\\n        p_p0              = prm.get_double(\\\"Pressure ratio p/p0\\\");\\n      }\\n      prm.leave_subsection();\\n    }\\n \\n \\n struct Materials\\n    {\\n double nu;\\n double mu;\\n \\n static void declare_parameters(ParameterHandler &prm);\\n \\n void parse_parameters(ParameterHandler &prm);\\n    };\\n \\n void Materials::declare_parameters(ParameterHandler &prm)\\n    {\\n      prm.enter_subsection(\\\"Material properties\\\");\\n      {\\n        prm.declare_entry(\\\"Poisson's ratio\\\",\\n \\\"0.4999\\\",\\n Patterns::Double(-1.0, 0.5),\\n \\\"Poisson's ratio\\\");\\n \\n        prm.declare_entry(\\\"Shear modulus\\\",\\n \\\"80.194e6\\\",\\n Patterns::Double(),\\n \\\"Shear modulus\\\");\\n      }\\n      prm.leave_subsection();\\n    }\\n \\n void Materials::parse_parameters(ParameterHandler &prm)\\n    {\\n      prm.enter_subsection(\\\"Material properties\\\");\\n      {\\n        nu = prm.get_double(\\\"Poisson's ratio\\\");\\n        mu = prm.get_double(\\\"Shear modulus\\\");\\n      }\\n      prm.leave_subsection();\\n    }\\n \\n \\n struct LinearSolver\\n    {\\n      std::string type_lin;\\n double      tol_lin;\\n double      max_iterations_lin;\\n bool        use_static_condensation;\\n      std::string preconditioner_type;\\n double      preconditioner_relaxation;\\n \\n static void declare_parameters(ParameterHandler &prm);\\n \\n void parse_parameters(ParameterHandler &prm);\\n    };\\n \\n void LinearSolver::declare_parameters(ParameterHandler &prm)\\n    {\\n      prm.enter_subsection(\\\"Linear solver\\\");\\n      {\\n        prm.declare_entry(\\\"Solver type\\\",\\n \\\"CG\\\",\\n Patterns::Selection(\\\"CG|Direct\\\"),\\n \\\"Type of solver used to solve the linear system\\\");\\n \\n        prm.declare_entry(\\\"Residual\\\",\\n \\\"1e-6\\\",\\n Patterns::Double(0.0),\\n \\\"Linear solver residual (scaled by residual norm)\\\");\\n \\n        prm.declare_entry(\\n \\\"Max iteration multiplier\\\",\\n \\\"1\\\",\\n Patterns::Double(0.0),\\n \\\"Linear solver iterations (multiples of the system matrix size)\\\");\\n \\n        prm.declare_entry(\\\"Use static condensation\\\",\\n \\\"true\\\",\\n Patterns::Bool(),\\n \\\"Solve the full block system or a reduced problem\\\");\\n \\n        prm.declare_entry(\\\"Preconditioner type\\\",\\n \\\"ssor\\\",\\n Patterns::Selection(\\\"jacobi|ssor\\\"),\\n \\\"Type of preconditioner\\\");\\n \\n        prm.declare_entry(\\\"Preconditioner relaxation\\\",\\n \\\"0.65\\\",\\n Patterns::Double(0.0),\\n \\\"Preconditioner relaxation value\\\");\\n      }\\n      prm.leave_subsection();\\n    }\\n \\n void LinearSolver::parse_parameters(ParameterHandler &prm)\\n    {\\n      prm.enter_subsection(\\\"Linear solver\\\");\\n      {\\n        type_lin                  = prm.get(\\\"Solver type\\\");\\n        tol_lin                   = prm.get_double(\\\"Residual\\\");\\n        max_iterations_lin        = prm.get_double(\\\"Max iteration multiplier\\\");\\n        use_static_condensation   = prm.get_bool(\\\"Use static condensation\\\");\\n        preconditioner_type       = prm.get(\\\"Preconditioner type\\\");\\n        preconditioner_relaxation = prm.get_double(\\\"Preconditioner relaxation\\\");\\n      }\\n      prm.leave_subsection();\\n    }\\n \\n \\n struct NonlinearSolver\\n    {\\n unsigned int max_iterations_NR;\\n double       tol_f;\\n double       tol_u;\\n \\n static void declare_parameters(ParameterHandler &prm);\\n \\n void parse_parameters(ParameterHandler &prm);\\n    };\\n \\n void NonlinearSolver::declare_parameters(ParameterHandler &prm)\\n    {\\n      prm.enter_subsection(\\\"Nonlinear solver\\\");\\n      {\\n        prm.declare_entry(\\\"Max iterations Newton-Raphson\\\",\\n \\\"10\\\",\\n Patterns::Integer(0),\\n \\\"Number of Newton-Raphson iterations allowed\\\");\\n \\n        prm.declare_entry(\\\"Tolerance force\\\",\\n \\\"1.0e-9\\\",\\n Patterns::Double(0.0),\\n \\\"Force residual tolerance\\\");\\n \\n        prm.declare_entry(\\\"Tolerance displacement\\\",\\n \\\"1.0e-6\\\",\\n Patterns::Double(0.0),\\n \\\"Displacement error tolerance\\\");\\n      }\\n      prm.leave_subsection();\\n    }\\n \\n void NonlinearSolver::parse_parameters(ParameterHandler &prm)\\n    {\\n      prm.enter_subsection(\\\"Nonlinear solver\\\");\\n      {\\n        max_iterations_NR = prm.get_integer(\\\"Max iterations Newton-Raphson\\\");\\n        tol_f             = prm.get_double(\\\"Tolerance force\\\");\\n        tol_u             = prm.get_double(\\\"Tolerance displacement\\\");\\n      }\\n      prm.leave_subsection();\\n    }\\n \\n \\n struct Time\\n    {\\n double delta_t;\\n double end_time;\\n \\n static void declare_parameters(ParameterHandler &prm);\\n \\n void parse_parameters(ParameterHandler &prm);\\n    };\\n \\n void Time::declare_parameters(ParameterHandler &prm)\\n    {\\n      prm.enter_subsection(\\\"Time\\\");\\n      {\\n        prm.declare_entry(\\\"End time\\\", \\\"1\\\", Patterns::Double(), \\\"End time\\\");\\n \\n        prm.declare_entry(\\\"Time step size\\\",\\n \\\"0.1\\\",\\n Patterns::Double(),\\n \\\"Time step size\\\");\\n      }\\n      prm.leave_subsection();\\n    }\\n \\n void Time::parse_parameters(ParameterHandler &prm)\\n    {\\n      prm.enter_subsection(\\\"Time\\\");\\n      {\\n        end_time = prm.get_double(\\\"End time\\\");\\n        delta_t  = prm.get_double(\\\"Time step size\\\");\\n      }\\n      prm.leave_subsection();\\n    }\\n \\n \\n struct AllParameters : public FESystem,\\n public Geometry,\\n public Materials,\\n public LinearSolver,\\n public NonlinearSolver,\\n public Time\\n \\n    {\\n      AllParameters(const std::string &input_file);\\n \\n static void declare_parameters(ParameterHandler &prm);\\n \\n void parse_parameters(ParameterHandler &prm);\\n    };\\n \\n    AllParameters::AllParameters(const std::string &input_file)\\n    {\\n ParameterHandler prm;\\n      declare_parameters(prm);\\n      prm.parse_input(input_file);\\n      parse_parameters(prm);\\n    }\\n \\n void AllParameters::declare_parameters(ParameterHandler &prm)\\n    {\\n      FESystem::declare_parameters(prm);\\n      Geometry::declare_parameters(prm);\\n      Materials::declare_parameters(prm);\\n      LinearSolver::declare_parameters(prm);\\n      NonlinearSolver::declare_parameters(prm);\\n      Time::declare_parameters(prm);\\n    }\\n \\n void AllParameters::parse_parameters(ParameterHandler &prm)\\n    {\\n      FESystem::parse_parameters(prm);\\n      Geometry::parse_parameters(prm);\\n      Materials::parse_parameters(prm);\\n      LinearSolver::parse_parameters(prm);\\n      NonlinearSolver::parse_parameters(prm);\\n      Time::parse_parameters(prm);\\n    }\\n  } // namespace Parameters\\n \\n \\n class Time\\n  {\\n public:\\n    Time(const double time_end, const double delta_t)\\n      : timestep(0)\\n      , time_current(0.0)\\n      , time_end(time_end)\\n      , delta_t(delta_t)\\n    {}\\n \\n virtual ~Time() = default;\\n \\n double current() const\\n {\\n return time_current;\\n    }\\n double end() const\\n {\\n return time_end;\\n    }\\n double get_delta_t() const\\n {\\n return delta_t;\\n    }\\n unsigned int get_timestep() const\\n {\\n return timestep;\\n    }\\n void increment()\\n    {\\n      time_current += delta_t;\\n      ++timestep;\\n    }\\n \\n private:\\n unsigned int timestep;\\n double       time_current;\\n const double time_end;\\n const double delta_t;\\n  };\\n \\n \\n template <int dim>\\n class Material_Compressible_Neo_Hook_Three_Field\\n  {\\n public:\\n    Material_Compressible_Neo_Hook_Three_Field(const double mu, const double nu)\\n      : kappa((2.0 * mu * (1.0 + nu)) / (3.0 * (1.0 - 2.0 * nu)))\\n      , c_1(mu / 2.0)\\n      , det_F(1.0)\\n      , p_tilde(0.0)\\n      , J_tilde(1.0)\\n      , b_bar(Physics::Elasticity::StandardTensors<dim>::I)\\n    {\\n Assert(kappa > 0, ExcInternalError());\\n    }\\n \\n void update_material_data(const Tensor<2, dim> &F,\\n const double          p_tilde_in,\\n const double          J_tilde_in)\\n    {\\n      det_F                      = determinant(F);\\n const Tensor<2, dim> F_bar = Physics::Elasticity::Kinematics::F_iso(F);\\n      b_bar                      = Physics::Elasticity::Kinematics::b(F_bar);\\n      p_tilde                    = p_tilde_in;\\n      J_tilde                    = J_tilde_in;\\n \\n Assert(det_F > 0, ExcInternalError());\\n    }\\n \\n SymmetricTensor<2, dim> get_tau()\\n    {\\n return get_tau_iso() + get_tau_vol();\\n    }\\n \\n SymmetricTensor<4, dim> get_Jc() const\\n {\\n return get_Jc_vol() + get_Jc_iso();\\n    }\\n \\n double get_dPsi_vol_dJ() const\\n {\\n return (kappa / 2.0) * (J_tilde - 1.0 / J_tilde);\\n    }\\n \\n double get_d2Psi_vol_dJ2() const\\n {\\n return ((kappa / 2.0) * (1.0 + 1.0 / (J_tilde * J_tilde)));\\n    }\\n \\n double get_det_F() const\\n {\\n return det_F;\\n    }\\n \\n double get_p_tilde() const\\n {\\n return p_tilde;\\n    }\\n \\n double get_J_tilde() const\\n {\\n return J_tilde;\\n    }\\n \\n protected:\\n const double kappa;\\n const double c_1;\\n \\n double                  det_F;\\n double                  p_tilde;\\n double                  J_tilde;\\n SymmetricTensor<2, dim> b_bar;\\n \\n SymmetricTensor<2, dim> get_tau_vol() const\\n {\\n return p_tilde * det_F * Physics::Elasticity::StandardTensors<dim>::I;\\n    }\\n \\n SymmetricTensor<2, dim> get_tau_iso() const\\n {\\n return Physics::Elasticity::StandardTensors<dim>::dev_P * get_tau_bar();\\n    }\\n \\n SymmetricTensor<2, dim> get_tau_bar() const\\n {\\n return 2.0 * c_1 * b_bar;\\n    }\\n \\n SymmetricTensor<4, dim> get_Jc_vol() const\\n {\\n return p_tilde * det_F *\\n             (Physics::Elasticity::StandardTensors<dim>::IxI -\\n              (2.0 * Physics::Elasticity::StandardTensors<dim>::S));\\n    }\\n \\n SymmetricTensor<4, dim> get_Jc_iso() const\\n {\\n const SymmetricTensor<2, dim> tau_bar = get_tau_bar();\\n const SymmetricTensor<2, dim> tau_iso = get_tau_iso();\\n const SymmetricTensor<4, dim> tau_iso_x_I =\\n outer_product(tau_iso, Physics::Elasticity::StandardTensors<dim>::I);\\n const SymmetricTensor<4, dim> I_x_tau_iso =\\n outer_product(Physics::Elasticity::StandardTensors<dim>::I, tau_iso);\\n const SymmetricTensor<4, dim> c_bar = get_c_bar();\\n \\n return (2.0 / dim) * trace(tau_bar) *\\n Physics::Elasticity::StandardTensors<dim>::dev_P -\\n             (2.0 / dim) * (tau_iso_x_I + I_x_tau_iso) +\\n Physics::Elasticity::StandardTensors<dim>::dev_P * c_bar *\\n Physics::Elasticity::StandardTensors<dim>::dev_P;\\n    }\\n \\n SymmetricTensor<4, dim> get_c_bar() const\\n {\\n return SymmetricTensor<4, dim>();\\n    }\\n  };\\n \\n \\n template <int dim>\\n class PointHistory\\n  {\\n public:\\n    PointHistory()\\n      : F_inv(Physics::Elasticity::StandardTensors<dim>::I)\\n      , tau(SymmetricTensor<2, dim>())\\n      , d2Psi_vol_dJ2(0.0)\\n      , dPsi_vol_dJ(0.0)\\n      , Jc(SymmetricTensor<4, dim>())\\n    {}\\n \\n virtual ~PointHistory() = default;\\n \\n void setup_lqp(const Parameters::AllParameters &parameters)\\n    {\\n      material =\\n        std::make_shared<Material_Compressible_Neo_Hook_Three_Field<dim>>(\\n          parameters.mu, parameters.nu);\\n update_values(Tensor<2, dim>(), 0.0, 1.0);\\n    }\\n \\n void update_values(const Tensor<2, dim> &Grad_u_n,\\n const double          p_tilde,\\n const double          J_tilde)\\n    {\\n const Tensor<2, dim> F = Physics::Elasticity::Kinematics::F(Grad_u_n);\\n      material->update_material_data(F, p_tilde, J_tilde);\\n \\n      F_inv         = invert(F);\\n      tau           = material->get_tau();\\n      Jc            = material->get_Jc();\\n      dPsi_vol_dJ   = material->get_dPsi_vol_dJ();\\n      d2Psi_vol_dJ2 = material->get_d2Psi_vol_dJ2();\\n    }\\n \\n double get_J_tilde() const\\n {\\n return material->get_J_tilde();\\n    }\\n \\n double get_det_F() const\\n {\\n return material->get_det_F();\\n    }\\n \\n const Tensor<2, dim> &get_F_inv() const\\n {\\n return F_inv;\\n    }\\n \\n double get_p_tilde() const\\n {\\n return material->get_p_tilde();\\n    }\\n \\n const SymmetricTensor<2, dim> &get_tau() const\\n {\\n return tau;\\n    }\\n \\n double get_dPsi_vol_dJ() const\\n {\\n return dPsi_vol_dJ;\\n    }\\n \\n double get_d2Psi_vol_dJ2() const\\n {\\n return d2Psi_vol_dJ2;\\n    }\\n \\n const SymmetricTensor<4, dim> &get_Jc() const\\n {\\n return Jc;\\n    }\\n \\n private:\\n    std::shared_ptr<Material_Compressible_Neo_Hook_Three_Field<dim>> material;\\n \\n Tensor<2, dim> F_inv;\\n \\n SymmetricTensor<2, dim> tau;\\n double                  d2Psi_vol_dJ2;\\n double                  dPsi_vol_dJ;\\n \\n SymmetricTensor<4, dim> Jc;\\n  };\\n \\n \\n \\n template <int dim>\\n class Solid\\n  {\\n public:\\n    Solid(const std::string &input_file);\\n \\n void run();\\n \\n private:\\n struct PerTaskData_ASM;\\n struct ScratchData_ASM;\\n \\n struct PerTaskData_SC;\\n struct ScratchData_SC;\\n \\n struct PerTaskData_UQPH;\\n struct ScratchData_UQPH;\\n \\n void make_grid();\\n \\n void system_setup();\\n \\n void determine_component_extractors();\\n \\n void make_constraints(const int it_nr);\\n \\n void assemble_system();\\n \\n void assemble_system_one_cell(\\n const typename DoFHandler<dim>::active_cell_iterator &cell,\\n      ScratchData_ASM                                      &scratch,\\n      PerTaskData_ASM                                      &data) const;\\n \\n void assemble_sc();\\n \\n void assemble_sc_one_cell(\\n const typename DoFHandler<dim>::active_cell_iterator &cell,\\n      ScratchData_SC                                       &scratch,\\n      PerTaskData_SC                                       &data);\\n \\n void copy_local_to_global_sc(const PerTaskData_SC &data);\\n \\n void setup_qph();\\n \\n void update_qph_incremental(const BlockVector<double> &solution_delta);\\n \\n void update_qph_incremental_one_cell(\\n const typename DoFHandler<dim>::active_cell_iterator &cell,\\n      ScratchData_UQPH                                     &scratch,\\n      PerTaskData_UQPH                                     &data);\\n \\n void copy_local_to_global_UQPH(const PerTaskData_UQPH & /*data*/)\\n    {}\\n \\n void solve_nonlinear_timestep(BlockVector<double> &solution_delta);\\n \\n    std::pair<unsigned int, double>\\n    solve_linear_system(BlockVector<double> &newton_update);\\n \\n BlockVector<double>\\n    get_total_solution(const BlockVector<double> &solution_delta) const;\\n \\n void output_results() const;\\n \\n    Parameters::AllParameters parameters;\\n \\n double vol_reference;\\n \\n Triangulation<dim> triangulation;\\n \\n    Time                time;\\n mutable TimerOutput timer;\\n \\n CellDataStorage<typename Triangulation<dim>::cell_iterator,\\n                    PointHistory<dim>>\\n      quadrature_point_history;\\n \\n const unsigned int               degree;\\n const FESystem<dim>              fe;\\n DoFHandler<dim>                  dof_handler;\\n const unsigned int               dofs_per_cell;\\n const FEValuesExtractors::Vector u_fe;\\n const FEValuesExtractors::Scalar p_fe;\\n const FEValuesExtractors::Scalar J_fe;\\n \\n static const unsigned int n_blocks          = 3;\\n static const unsigned int n_components      = dim + 2;\\n static const unsigned int first_u_component = 0;\\n static const unsigned int p_component       = dim;\\n static const unsigned int J_component       = dim + 1;\\n \\n enum\\n    {\\n      u_dof = 0,\\n      p_dof = 1,\\n      J_dof = 2\\n    };\\n \\n    std::vector<types::global_dof_index> dofs_per_block;\\n    std::vector<types::global_dof_index> element_indices_u;\\n    std::vector<types::global_dof_index> element_indices_p;\\n    std::vector<types::global_dof_index> element_indices_J;\\n \\n const QGauss<dim>     qf_cell;\\n const QGauss<dim - 1> qf_face;\\n const unsigned int    n_q_points;\\n const unsigned int    n_q_points_f;\\n \\n AffineConstraints<double> constraints;\\n BlockSparsityPattern      sparsity_pattern;\\n BlockSparseMatrix<double> tangent_matrix;\\n BlockVector<double>       system_rhs;\\n BlockVector<double>       solution_n;\\n \\n struct Errors\\n    {\\n      Errors()\\n        : norm(1.0)\\n        , u(1.0)\\n        , p(1.0)\\n        , J(1.0)\\n      {}\\n \\n void reset()\\n      {\\n norm = 1.0;\\n        u    = 1.0;\\n        p    = 1.0;\\n        J    = 1.0;\\n      }\\n void normalize(const Errors &rhs)\\n      {\\n if (rhs.norm != 0.0)\\n norm /= rhs.norm;\\n if (rhs.u != 0.0)\\n          u /= rhs.u;\\n if (rhs.p != 0.0)\\n          p /= rhs.p;\\n if (rhs.J != 0.0)\\n          J /= rhs.J;\\n      }\\n \\n double norm, u, p, J;\\n    };\\n \\n    Errors error_residual, error_residual_0, error_residual_norm, error_update,\\n      error_update_0, error_update_norm;\\n \\n void get_error_residual(Errors &error_residual);\\n \\n void get_error_update(const BlockVector<double> &newton_update,\\n                          Errors                    &error_update);\\n \\n    std::pair<double, double> get_error_dilation() const;\\n \\n double compute_vol_current() const;\\n \\n static void print_conv_header();\\n \\n void print_conv_footer();\\n  };\\n \\n \\n \\n template <int dim>\\n  Solid<dim>::Solid(const std::string &input_file)\\n    : parameters(input_file)\\n    , vol_reference(0.)\\n    , triangulation(Triangulation<dim>::maximum_smoothing)\\n    , time(parameters.end_time, parameters.delta_t)\\n    , timer(std::cout, TimerOutput::summary, TimerOutput::wall_times)\\n    , degree(parameters.poly_degree)\\n    ,\\n    fe(FE_Q<dim>(parameters.poly_degree) ^ dim, // displacement\\n FE_DGP<dim>(parameters.poly_degree - 1), // pressure\\n FE_DGP<dim>(parameters.poly_degree - 1)) // dilatation\\n    , dof_handler(triangulation)\\n    , dofs_per_cell(fe.n_dofs_per_cell())\\n    , u_fe(first_u_component)\\n    , p_fe(p_component)\\n    , J_fe(J_component)\\n    , dofs_per_block(n_blocks)\\n    , qf_cell(parameters.quad_order)\\n    , qf_face(parameters.quad_order)\\n    , n_q_points(qf_cell.size())\\n    , n_q_points_f(qf_face.size())\\n  {\\n Assert(dim == 2 || dim == 3,\\n           ExcMessage(\\\"This problem only works in 2 or 3 space dimensions.\\\"));\\n    determine_component_extractors();\\n  }\\n \\n \\n template <int dim>\\n void Solid<dim>::run()\\n  {\\n    make_grid();\\n    system_setup();\\n    {\\n AffineConstraints<double> constraints;\\n      constraints.close();\\n \\n const ComponentSelectFunction<dim> J_mask(J_component, n_components);\\n \\n VectorTools::project(\\n        dof_handler, constraints, QGauss<dim>(degree + 2), J_mask, solution_n);\\n    }\\n    output_results();\\n    time.increment();\\n \\n BlockVector<double> solution_delta(dofs_per_block);\\n while (time.current() < time.end())\\n      {\\n        solution_delta = 0.0;\\n \\n        solve_nonlinear_timestep(solution_delta);\\n        solution_n += solution_delta;\\n \\n        output_results();\\n        time.increment();\\n      }\\n  }\\n \\n \\n \\n \\n \\n template <int dim>\\n struct Solid<dim>::PerTaskData_ASM\\n  {\\n FullMatrix<double> cell_matrix;\\n Vector<double>                       cell_rhs;\\n    std::vector<types::global_dof_index> local_dof_indices;\\n \\n    PerTaskData_ASM(const unsigned int dofs_per_cell)\\n      : cell_matrix(dofs_per_cell, dofs_per_cell)\\n      , cell_rhs(dofs_per_cell)\\n      , local_dof_indices(dofs_per_cell)\\n    {}\\n \\n void reset()\\n    {\\n cell_matrix = 0.0;\\n      cell_rhs    = 0.0;\\n    }\\n  };\\n \\n \\n template <int dim>\\n struct Solid<dim>::ScratchData_ASM\\n  {\\n FEValues<dim>     fe_values;\\n FEFaceValues<dim> fe_face_values;\\n \\n    std::vector<std::vector<double>>                  Nx;\\n    std::vector<std::vector<Tensor<2, dim>>>          grad_Nx;\\n    std::vector<std::vector<SymmetricTensor<2, dim>>> symm_grad_Nx;\\n \\n    ScratchData_ASM(const FiniteElement<dim> &fe_cell,\\n const QGauss<dim>        &qf_cell,\\n const UpdateFlags         uf_cell,\\n const QGauss<dim - 1>    &qf_face,\\n const UpdateFlags         uf_face)\\n      : fe_values(fe_cell, qf_cell, uf_cell)\\n      , fe_face_values(fe_cell, qf_face, uf_face)\\n      , Nx(qf_cell.size(), std::vector<double>(fe_cell.n_dofs_per_cell()))\\n      , grad_Nx(qf_cell.size(),\\n std::vector<Tensor<2, dim>>(fe_cell.n_dofs_per_cell()))\\n      , symm_grad_Nx(qf_cell.size(),\\n std::vector<SymmetricTensor<2, dim>>(\\n                       fe_cell.n_dofs_per_cell()))\\n    {}\\n \\n    ScratchData_ASM(const ScratchData_ASM &rhs)\\n      : fe_values(rhs.fe_values.get_fe(),\\n                  rhs.fe_values.get_quadrature(),\\n                  rhs.fe_values.get_update_flags())\\n      , fe_face_values(rhs.fe_face_values.get_fe(),\\n                       rhs.fe_face_values.get_quadrature(),\\n                       rhs.fe_face_values.get_update_flags())\\n      , Nx(rhs.Nx)\\n      , grad_Nx(rhs.grad_Nx)\\n      , symm_grad_Nx(rhs.symm_grad_Nx)\\n    {}\\n \\n void reset()\\n    {\\n const unsigned int n_q_points      = Nx.size();\\n const unsigned int n_dofs_per_cell = Nx[0].size();\\n for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n        {\\n Assert(Nx[q_point].size() == n_dofs_per_cell, ExcInternalError());\\n Assert(grad_Nx[q_point].size() == n_dofs_per_cell,\\n                 ExcInternalError());\\n Assert(symm_grad_Nx[q_point].size() == n_dofs_per_cell,\\n                 ExcInternalError());\\n for (unsigned int k = 0; k < n_dofs_per_cell; ++k)\\n            {\\n              Nx[q_point][k]           = 0.0;\\n              grad_Nx[q_point][k]      = 0.0;\\n              symm_grad_Nx[q_point][k] = 0.0;\\n            }\\n        }\\n    }\\n  };\\n \\n \\n template <int dim>\\n struct Solid<dim>::PerTaskData_SC\\n  {\\n FullMatrix<double> cell_matrix;\\n    std::vector<types::global_dof_index> local_dof_indices;\\n \\n FullMatrix<double> k_orig;\\n FullMatrix<double> k_pu;\\n FullMatrix<double> k_pJ;\\n FullMatrix<double> k_JJ;\\n FullMatrix<double> k_pJ_inv;\\n FullMatrix<double> k_bbar;\\n FullMatrix<double> A;\\n FullMatrix<double> B;\\n FullMatrix<double> C;\\n \\n    PerTaskData_SC(const unsigned int dofs_per_cell,\\n const unsigned int n_u,\\n const unsigned int n_p,\\n const unsigned int n_J)\\n      : cell_matrix(dofs_per_cell, dofs_per_cell)\\n      , local_dof_indices(dofs_per_cell)\\n      , k_orig(dofs_per_cell, dofs_per_cell)\\n      , k_pu(n_p, n_u)\\n      , k_pJ(n_p, n_J)\\n      , k_JJ(n_J, n_J)\\n      , k_pJ_inv(n_p, n_J)\\n      , k_bbar(n_u, n_u)\\n      , A(n_J, n_u)\\n      , B(n_J, n_u)\\n      , C(n_p, n_u)\\n    {}\\n \\n void reset()\\n    {}\\n  };\\n \\n \\n template <int dim>\\n struct Solid<dim>::ScratchData_SC\\n  {\\n void reset()\\n    {}\\n  };\\n \\n \\n template <int dim>\\n struct Solid<dim>::PerTaskData_UQPH\\n  {\\n void reset()\\n    {}\\n  };\\n \\n \\n template <int dim>\\n struct Solid<dim>::ScratchData_UQPH\\n  {\\n const BlockVector<double> &solution_total;\\n \\n    std::vector<Tensor<2, dim>> solution_grads_u_total;\\n    std::vector<double>         solution_values_p_total;\\n    std::vector<double>         solution_values_J_total;\\n \\n FEValues<dim> fe_values;\\n \\n    ScratchData_UQPH(const FiniteElement<dim>  &fe_cell,\\n const QGauss<dim>         &qf_cell,\\n const UpdateFlags          uf_cell,\\n const BlockVector<double> &solution_total)\\n      : solution_total(solution_total)\\n      , solution_grads_u_total(qf_cell.size())\\n      , solution_values_p_total(qf_cell.size())\\n      , solution_values_J_total(qf_cell.size())\\n      , fe_values(fe_cell, qf_cell, uf_cell)\\n    {}\\n \\n    ScratchData_UQPH(const ScratchData_UQPH &rhs)\\n      : solution_total(rhs.solution_total)\\n      , solution_grads_u_total(rhs.solution_grads_u_total)\\n      , solution_values_p_total(rhs.solution_values_p_total)\\n      , solution_values_J_total(rhs.solution_values_J_total)\\n      , fe_values(rhs.fe_values.get_fe(),\\n                  rhs.fe_values.get_quadrature(),\\n                  rhs.fe_values.get_update_flags())\\n    {}\\n \\n void reset()\\n    {\\n const unsigned int n_q_points = solution_grads_u_total.size();\\n for (unsigned int q = 0; q < n_q_points; ++q)\\n        {\\n          solution_grads_u_total[q]  = 0.0;\\n          solution_values_p_total[q] = 0.0;\\n          solution_values_J_total[q] = 0.0;\\n        }\\n    }\\n  };\\n \\n \\n \\n template <int dim>\\n void Solid<dim>::make_grid()\\n  {\\n GridGenerator::hyper_rectangle(\\n triangulation,\\n      (dim == 3 ? Point<dim>(0.0, 0.0, 0.0) : Point<dim>(0.0, 0.0)),\\n      (dim == 3 ? Point<dim>(1.0, 1.0, 1.0) : Point<dim>(1.0, 1.0)),\\n      true);\\n GridTools::scale(parameters.scale, triangulation);\\n triangulation.refine_global(std::max(1U, parameters.global_refinement));\\n \\n    vol_reference = GridTools::volume(triangulation);\\n    std::cout << \\\"Grid:\\\\n\\\\t Reference volume: \\\" << vol_reference << std::endl;\\n \\n for (const auto &cell : triangulation.active_cell_iterators())\\n      for (const auto &face : cell->face_iterators())\\n        {\\n if (face->at_boundary() == true &&\\n              face->center()[1] == 1.0 * parameters.scale)\\n            {\\n if (dim == 3)\\n                {\\n if (face->center()[0] < 0.5 * parameters.scale &&\\n                      face->center()[2] < 0.5 * parameters.scale)\\n                    face->set_boundary_id(6);\\n                }\\n else\\n                {\\n if (face->center()[0] < 0.5 * parameters.scale)\\n                    face->set_boundary_id(6);\\n                }\\n            }\\n        }\\n  }\\n \\n \\n \\n template <int dim>\\n void Solid<dim>::system_setup()\\n  {\\n    timer.enter_subsection(\\\"Setup system\\\");\\n \\n    std::vector<unsigned int> block_component(n_components,\\n                                              u_dof); // Displacement\\n    block_component[p_component] = p_dof;             // Pressure\\n    block_component[J_component] = J_dof;             // Dilatation\\n \\n    dof_handler.distribute_dofs(fe);\\n DoFRenumbering::Cuthill_McKee(dof_handler);\\n DoFRenumbering::component_wise(dof_handler, block_component);\\n \\n    dofs_per_block =\\n DoFTools::count_dofs_per_fe_block(dof_handler, block_component);\\n \\n    std::cout << \\\"Triangulation:\\\"\\n              << \\\"\\\\n\\\\t Number of active cells: \\\"\\n              << triangulation.n_active_cells()\\n              << \\\"\\\\n\\\\t Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n              << std::endl;\\n \\n    tangent_matrix.clear();\\n    {\\n BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block);\\n \\n Table<2, DoFTools::Coupling> coupling(n_components, n_components);\\n for (unsigned int ii = 0; ii < n_components; ++ii)\\n for (unsigned int jj = 0; jj < n_components; ++jj)\\n if (((ii < p_component) && (jj == J_component)) ||\\n              ((ii == J_component) && (jj < p_component)) ||\\n              ((ii == p_component) && (jj == p_component)))\\n            coupling[ii][jj] = DoFTools::none;\\n else\\n            coupling[ii][jj] = DoFTools::always;\\n DoFTools::make_sparsity_pattern(\\n        dof_handler, coupling, dsp, constraints, false);\\n      sparsity_pattern.copy_from(dsp);\\n    }\\n \\n    tangent_matrix.reinit(sparsity_pattern);\\n \\n    system_rhs.reinit(dofs_per_block);\\n    solution_n.reinit(dofs_per_block);\\n \\n    setup_qph();\\n \\n    timer.leave_subsection();\\n  }\\n \\n \\n template <int dim>\\n void Solid<dim>::determine_component_extractors()\\n  {\\n    element_indices_u.clear();\\n    element_indices_p.clear();\\n    element_indices_J.clear();\\n \\n for (unsigned int k = 0; k < fe.n_dofs_per_cell(); ++k)\\n      {\\n const unsigned int k_group = fe.system_to_base_index(k).first.first;\\n if (k_group == u_dof)\\n          element_indices_u.push_back(k);\\n else if (k_group == p_dof)\\n          element_indices_p.push_back(k);\\n else if (k_group == J_dof)\\n          element_indices_J.push_back(k);\\n else\\n          {\\n Assert(k_group <= J_dof, ExcInternalError());\\n          }\\n      }\\n  }\\n \\n template <int dim>\\n void Solid<dim>::setup_qph()\\n  {\\n    std::cout << \\\"    Setting up quadrature point data...\\\" << std::endl;\\n \\n    quadrature_point_history.initialize(triangulation.begin_active(),\\n triangulation.end(),\\n                                        n_q_points);\\n \\n for (const auto &cell : triangulation.active_cell_iterators())\\n      {\\n const std::vector<std::shared_ptr<PointHistory<dim>>> lqph =\\n          quadrature_point_history.get_data(cell);\\n Assert(lqph.size() == n_q_points, ExcInternalError());\\n \\n for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n          lqph[q_point]->setup_lqp(parameters);\\n      }\\n  }\\n \\n template <int dim>\\n void\\n  Solid<dim>::update_qph_incremental(const BlockVector<double> &solution_delta)\\n  {\\n    timer.enter_subsection(\\\"Update QPH data\\\");\\n    std::cout << \\\" UQPH \\\" << std::flush;\\n \\n const BlockVector<double> solution_total(\\n      get_total_solution(solution_delta));\\n \\n const UpdateFlags uf_UQPH(update_values | update_gradients);\\n    PerTaskData_UQPH  per_task_data_UQPH;\\n    ScratchData_UQPH  scratch_data_UQPH(fe, qf_cell, uf_UQPH, solution_total);\\n \\n WorkStream::run(dof_handler.active_cell_iterators(),\\n                    *this,\\n                    &Solid::update_qph_incremental_one_cell,\\n                    &Solid::copy_local_to_global_UQPH,\\n                    scratch_data_UQPH,\\n                    per_task_data_UQPH);\\n \\n    timer.leave_subsection();\\n  }\\n \\n \\n template <int dim>\\n void Solid<dim>::update_qph_incremental_one_cell(\\n const typename DoFHandler<dim>::active_cell_iterator &cell,\\n    ScratchData_UQPH                                     &scratch,\\n    PerTaskData_UQPH & /*data*/)\\n  {\\n const std::vector<std::shared_ptr<PointHistory<dim>>> lqph =\\n      quadrature_point_history.get_data(cell);\\n Assert(lqph.size() == n_q_points, ExcInternalError());\\n \\n Assert(scratch.solution_grads_u_total.size() == n_q_points,\\n           ExcInternalError());\\n Assert(scratch.solution_values_p_total.size() == n_q_points,\\n           ExcInternalError());\\n Assert(scratch.solution_values_J_total.size() == n_q_points,\\n           ExcInternalError());\\n \\n    scratch.reset();\\n \\n    scratch.fe_values.reinit(cell);\\n    scratch.fe_values[u_fe].get_function_gradients(\\n      scratch.solution_total, scratch.solution_grads_u_total);\\n    scratch.fe_values[p_fe].get_function_values(\\n      scratch.solution_total, scratch.solution_values_p_total);\\n    scratch.fe_values[J_fe].get_function_values(\\n      scratch.solution_total, scratch.solution_values_J_total);\\n \\n for (const unsigned int q_point :\\n         scratch.fe_values.quadrature_point_indices())\\n      lqph[q_point]->update_values(scratch.solution_grads_u_total[q_point],\\n                                   scratch.solution_values_p_total[q_point],\\n                                   scratch.solution_values_J_total[q_point]);\\n  }\\n \\n \\n \\n template <int dim>\\n void Solid<dim>::solve_nonlinear_timestep(BlockVector<double> &solution_delta)\\n  {\\n    std::cout << std::endl\\n              << \\\"Timestep \\\" << time.get_timestep() << \\\" @ \\\" << time.current()\\n              << 's' << std::endl;\\n \\n BlockVector<double> newton_update(dofs_per_block);\\n \\n    error_residual.reset();\\n    error_residual_0.reset();\\n    error_residual_norm.reset();\\n    error_update.reset();\\n    error_update_0.reset();\\n    error_update_norm.reset();\\n \\n    print_conv_header();\\n \\n unsigned int newton_iteration = 0;\\n for (; newton_iteration < parameters.max_iterations_NR; ++newton_iteration)\\n      {\\n        std::cout << ' ' << std::setw(2) << newton_iteration << ' '\\n                  << std::flush;\\n \\n        make_constraints(newton_iteration);\\n        assemble_system();\\n \\n        get_error_residual(error_residual);\\n if (newton_iteration == 0)\\n          error_residual_0 = error_residual;\\n \\n        error_residual_norm = error_residual;\\n        error_residual_norm.normalize(error_residual_0);\\n \\n if (newton_iteration > 0 && error_update_norm.u <= parameters.tol_u &&\\n            error_residual_norm.u <= parameters.tol_f)\\n          {\\n            std::cout << \\\" CONVERGED! \\\" << std::endl;\\n            print_conv_footer();\\n \\n break;\\n          }\\n \\n const std::pair<unsigned int, double> lin_solver_output =\\n          solve_linear_system(newton_update);\\n \\n        get_error_update(newton_update, error_update);\\n if (newton_iteration == 0)\\n          error_update_0 = error_update;\\n \\n        error_update_norm = error_update;\\n        error_update_norm.normalize(error_update_0);\\n \\n        solution_delta += newton_update;\\n        update_qph_incremental(solution_delta);\\n \\n        std::cout << \\\" | \\\" << std::fixed << std::setprecision(3) << std::setw(7)\\n                  << std::scientific << lin_solver_output.first << \\\"  \\\"\\n                  << lin_solver_output.second << \\\"  \\\"\\n                  << error_residual_norm.norm << \\\"  \\\" << error_residual_norm.u\\n                  << \\\"  \\\" << error_residual_norm.p << \\\"  \\\"\\n                  << error_residual_norm.J << \\\"  \\\" << error_update_norm.norm\\n                  << \\\"  \\\" << error_update_norm.u << \\\"  \\\" << error_update_norm.p\\n                  << \\\"  \\\" << error_update_norm.J << \\\"  \\\" << std::endl;\\n      }\\n \\n AssertThrow(newton_iteration < parameters.max_iterations_NR,\\n                ExcMessage(\\\"No convergence in nonlinear solver!\\\"));\\n  }\\n \\n \\n \\n template <int dim>\\n void Solid<dim>::print_conv_header()\\n  {\\n static const unsigned int l_width = 150;\\n \\n for (unsigned int i = 0; i < l_width; ++i)\\n      std::cout << '_';\\n    std::cout << std::endl;\\n \\n    std::cout << \\\"               SOLVER STEP               \\\"\\n              << \\\" |  LIN_IT   LIN_RES    RES_NORM    \\\"\\n              << \\\" RES_U     RES_P      RES_J     NU_NORM     \\\"\\n              << \\\" NU_U       NU_P       NU_J \\\" << std::endl;\\n \\n for (unsigned int i = 0; i < l_width; ++i)\\n      std::cout << '_';\\n    std::cout << std::endl;\\n  }\\n \\n \\n \\n template <int dim>\\n void Solid<dim>::print_conv_footer()\\n  {\\n static const unsigned int l_width = 150;\\n \\n for (unsigned int i = 0; i < l_width; ++i)\\n      std::cout << '_';\\n    std::cout << std::endl;\\n \\n const std::pair<double, double> error_dil = get_error_dilation();\\n \\n    std::cout << \\\"Relative errors:\\\" << std::endl\\n              << \\\"Displacement:\\\\t\\\" << error_update.u / error_update_0.u\\n              << std::endl\\n              << \\\"Force: \\\\t\\\\t\\\" << error_residual.u / error_residual_0.u\\n              << std::endl\\n              << \\\"Dilatation:\\\\t\\\" << error_dil.first << std::endl\\n              << \\\"v / V_0:\\\\t\\\" << error_dil.second * vol_reference << \\\" / \\\"\\n              << vol_reference << \\\" = \\\" << error_dil.second << std::endl;\\n  }\\n \\n \\n \\n template <int dim>\\n double Solid<dim>::compute_vol_current() const\\n {\\n double vol_current = 0.0;\\n \\n FEValues<dim> fe_values(fe, qf_cell, update_JxW_values);\\n \\n for (const auto &cell : triangulation.active_cell_iterators())\\n      {\\n        fe_values.reinit(cell);\\n \\n const std::vector<std::shared_ptr<const PointHistory<dim>>> lqph =\\n          quadrature_point_history.get_data(cell);\\n Assert(lqph.size() == n_q_points, ExcInternalError());\\n \\n for (const unsigned int q_point : fe_values.quadrature_point_indices())\\n          {\\n const double det_F_qp = lqph[q_point]->get_det_F();\\n const double JxW      = fe_values.JxW(q_point);\\n \\n            vol_current += det_F_qp * JxW;\\n          }\\n      }\\n Assert(vol_current > 0.0, ExcInternalError());\\n return vol_current;\\n  }\\n \\n template <int dim>\\n  std::pair<double, double> Solid<dim>::get_error_dilation() const\\n {\\n double dil_L2_error = 0.0;\\n \\n FEValues<dim> fe_values(fe, qf_cell, update_JxW_values);\\n \\n for (const auto &cell : triangulation.active_cell_iterators())\\n      {\\n        fe_values.reinit(cell);\\n \\n const std::vector<std::shared_ptr<const PointHistory<dim>>> lqph =\\n          quadrature_point_history.get_data(cell);\\n Assert(lqph.size() == n_q_points, ExcInternalError());\\n \\n for (const unsigned int q_point : fe_values.quadrature_point_indices())\\n          {\\n const double det_F_qp   = lqph[q_point]->get_det_F();\\n const double J_tilde_qp = lqph[q_point]->get_J_tilde();\\n const double the_error_qp_squared =\\n Utilities::fixed_power<2>((det_F_qp - J_tilde_qp));\\n const double JxW = fe_values.JxW(q_point);\\n \\n            dil_L2_error += the_error_qp_squared * JxW;\\n          }\\n      }\\n \\n return std::make_pair(std::sqrt(dil_L2_error),\\n                          compute_vol_current() / vol_reference);\\n  }\\n \\n \\n \\n template <int dim>\\n void Solid<dim>::get_error_residual(Errors &error_residual)\\n  {\\n BlockVector<double> error_res(dofs_per_block);\\n \\n for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)\\n if (!constraints.is_constrained(i))\\n        error_res(i) = system_rhs(i);\\n \\n    error_residual.norm = error_res.l2_norm();\\n    error_residual.u    = error_res.block(u_dof).l2_norm();\\n    error_residual.p    = error_res.block(p_dof).l2_norm();\\n    error_residual.J    = error_res.block(J_dof).l2_norm();\\n  }\\n \\n \\n \\n template <int dim>\\n void Solid<dim>::get_error_update(const BlockVector<double> &newton_update,\\n                                    Errors                    &error_update)\\n  {\\n BlockVector<double> error_ud(dofs_per_block);\\n for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)\\n if (!constraints.is_constrained(i))\\n        error_ud(i) = newton_update(i);\\n \\n    error_update.norm = error_ud.l2_norm();\\n    error_update.u    = error_ud.block(u_dof).l2_norm();\\n    error_update.p    = error_ud.block(p_dof).l2_norm();\\n    error_update.J    = error_ud.block(J_dof).l2_norm();\\n  }\\n \\n \\n \\n \\n template <int dim>\\n BlockVector<double> Solid<dim>::get_total_solution(\\n const BlockVector<double> &solution_delta) const\\n {\\n BlockVector<double> solution_total(solution_n);\\n    solution_total += solution_delta;\\n return solution_total;\\n  }\\n \\n \\n \\n template <int dim>\\n void Solid<dim>::assemble_system()\\n  {\\n    timer.enter_subsection(\\\"Assemble system\\\");\\n    std::cout << \\\" ASM_SYS \\\" << std::flush;\\n \\n    tangent_matrix = 0.0;\\n    system_rhs     = 0.0;\\n \\n const UpdateFlags uf_cell(update_values | update_gradients |\\n update_JxW_values);\\n const UpdateFlags uf_face(update_values | update_normal_vectors |\\n update_JxW_values);\\n \\n    PerTaskData_ASM per_task_data(dofs_per_cell);\\n    ScratchData_ASM scratch_data(fe, qf_cell, uf_cell, qf_face, uf_face);\\n \\n WorkStream::run(\\n      dof_handler.active_cell_iterators(),\\n      [this](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n             ScratchData_ASM                                      &scratch,\\n             PerTaskData_ASM                                      &data) {\\n        this->assemble_system_one_cell(cell, scratch, data);\\n      },\\n      [this](const PerTaskData_ASM &data) {\\n        this->constraints.distribute_local_to_global(data.cell_matrix,\\n                                                     data.cell_rhs,\\n                                                     data.local_dof_indices,\\n                                                     tangent_matrix,\\n                                                     system_rhs);\\n      },\\n      scratch_data,\\n      per_task_data);\\n \\n    timer.leave_subsection();\\n  }\\n \\n template <int dim>\\n void Solid<dim>::assemble_system_one_cell(\\n const typename DoFHandler<dim>::active_cell_iterator &cell,\\n    ScratchData_ASM                                      &scratch,\\n    PerTaskData_ASM                                      &data) const\\n {\\n    data.reset();\\n    scratch.reset();\\n    scratch.fe_values.reinit(cell);\\n    cell->get_dof_indices(data.local_dof_indices);\\n \\n const std::vector<std::shared_ptr<const PointHistory<dim>>> lqph =\\n      quadrature_point_history.get_data(cell);\\n Assert(lqph.size() == n_q_points, ExcInternalError());\\n \\n for (const unsigned int q_point :\\n         scratch.fe_values.quadrature_point_indices())\\n      {\\n const Tensor<2, dim> F_inv = lqph[q_point]->get_F_inv();\\n for (const unsigned int k : scratch.fe_values.dof_indices())\\n          {\\n const unsigned int k_group = fe.system_to_base_index(k).first.first;\\n \\n if (k_group == u_dof)\\n              {\\n                scratch.grad_Nx[q_point][k] =\\n                  scratch.fe_values[u_fe].gradient(k, q_point) * F_inv;\\n                scratch.symm_grad_Nx[q_point][k] =\\n symmetrize(scratch.grad_Nx[q_point][k]);\\n              }\\n else if (k_group == p_dof)\\n              scratch.Nx[q_point][k] =\\n                scratch.fe_values[p_fe].value(k, q_point);\\n else if (k_group == J_dof)\\n              scratch.Nx[q_point][k] =\\n                scratch.fe_values[J_fe].value(k, q_point);\\n else\\n Assert(k_group <= J_dof, ExcInternalError());\\n          }\\n      }\\n \\n for (const unsigned int q_point :\\n         scratch.fe_values.quadrature_point_indices())\\n      {\\n const SymmetricTensor<2, dim> tau     = lqph[q_point]->get_tau();\\n const Tensor<2, dim>          tau_ns  = lqph[q_point]->get_tau();\\n const SymmetricTensor<4, dim> Jc      = lqph[q_point]->get_Jc();\\n const double                  det_F   = lqph[q_point]->get_det_F();\\n const double                  p_tilde = lqph[q_point]->get_p_tilde();\\n const double                  J_tilde = lqph[q_point]->get_J_tilde();\\n const double dPsi_vol_dJ   = lqph[q_point]->get_dPsi_vol_dJ();\\n const double d2Psi_vol_dJ2 = lqph[q_point]->get_d2Psi_vol_dJ2();\\n const SymmetricTensor<2, dim> &I =\\n Physics::Elasticity::StandardTensors<dim>::I;\\n \\n SymmetricTensor<2, dim> symm_grad_Nx_i_x_Jc;\\n Tensor<1, dim>          grad_Nx_i_comp_i_x_tau;\\n \\n const std::vector<double>                  &N = scratch.Nx[q_point];\\n const std::vector<SymmetricTensor<2, dim>> &symm_grad_Nx =\\n          scratch.symm_grad_Nx[q_point];\\n const std::vector<Tensor<2, dim>> &grad_Nx = scratch.grad_Nx[q_point];\\n const double                       JxW = scratch.fe_values.JxW(q_point);\\n \\n for (const unsigned int i : scratch.fe_values.dof_indices())\\n          {\\n const unsigned int component_i =\\n              fe.system_to_component_index(i).first;\\n const unsigned int i_group = fe.system_to_base_index(i).first.first;\\n \\n if (i_group == u_dof)\\n              data.cell_rhs(i) -= (symm_grad_Nx[i] * tau) * JxW;\\n else if (i_group == p_dof)\\n              data.cell_rhs(i) -= N[i] * (det_F - J_tilde) * JxW;\\n else if (i_group == J_dof)\\n              data.cell_rhs(i) -= N[i] * (dPsi_vol_dJ - p_tilde) * JxW;\\n else\\n Assert(i_group <= J_dof, ExcInternalError());\\n \\n if (i_group == u_dof)\\n              {\\n                symm_grad_Nx_i_x_Jc    = symm_grad_Nx[i] * Jc;\\n                grad_Nx_i_comp_i_x_tau = grad_Nx[i][component_i] * tau_ns;\\n              }\\n \\n for (const unsigned int j :\\n                 scratch.fe_values.dof_indices_ending_at(i))\\n              {\\n const unsigned int component_j =\\n                  fe.system_to_component_index(j).first;\\n const unsigned int j_group =\\n                  fe.system_to_base_index(j).first.first;\\n \\n if ((i_group == j_group) && (i_group == u_dof))\\n                  {\\n                    data.cell_matrix(i, j) += symm_grad_Nx_i_x_Jc *  \\n                                              symm_grad_Nx[j] * JxW; \\n \\n if (component_i == component_j)\\n                      data.cell_matrix(i, j) +=\\n                        grad_Nx_i_comp_i_x_tau * grad_Nx[j][component_j] * JxW;\\n                  }\\n else if ((i_group == p_dof) && (j_group == u_dof))\\n                  {\\n                    data.cell_matrix(i, j) += N[i] * det_F *               \\n                                              (symm_grad_Nx[j] * I) * JxW; \\n                  }\\n else if ((i_group == J_dof) && (j_group == p_dof))\\n                  data.cell_matrix(i, j) -= N[i] * N[j] * JxW;\\n else if ((i_group == j_group) && (i_group == J_dof))\\n                  data.cell_matrix(i, j) += N[i] * d2Psi_vol_dJ2 * N[j] * JxW;\\n else\\n Assert((i_group <= J_dof) && (j_group <= J_dof),\\n                         ExcInternalError());\\n              }\\n          }\\n      }\\n \\n for (const auto &face : cell->face_iterators())\\n      if (face->at_boundary() && face->boundary_id() == 6)\\n        {\\n          scratch.fe_face_values.reinit(cell, face);\\n \\n for (const unsigned int f_q_point :\\n               scratch.fe_face_values.quadrature_point_indices())\\n            {\\n const Tensor<1, dim> &N =\\n                scratch.fe_face_values.normal_vector(f_q_point);\\n \\n static const double p0 =\\n                -4.0 / (parameters.scale * parameters.scale);\\n const double         time_ramp = (time.current() / time.end());\\n const double         pressure  = p0 * parameters.p_p0 * time_ramp;\\n const Tensor<1, dim> traction  = pressure * N;\\n \\n for (const unsigned int i : scratch.fe_values.dof_indices())\\n                {\\n const unsigned int i_group =\\n                    fe.system_to_base_index(i).first.first;\\n \\n if (i_group == u_dof)\\n                    {\\n const unsigned int component_i =\\n                        fe.system_to_component_index(i).first;\\n const double Ni =\\n                        scratch.fe_face_values.shape_value(i, f_q_point);\\n const double JxW = scratch.fe_face_values.JxW(f_q_point);\\n \\n                      data.cell_rhs(i) += (Ni * traction[component_i]) * JxW;\\n                    }\\n                }\\n            }\\n        }\\n \\n for (const unsigned int i : scratch.fe_values.dof_indices())\\n      for (const unsigned int j :\\n           scratch.fe_values.dof_indices_starting_at(i + 1))\\n        data.cell_matrix(i, j) = data.cell_matrix(j, i);\\n  }\\n \\n \\n \\n template <int dim>\\n void Solid<dim>::make_constraints(const int it_nr)\\n  {\\n const bool apply_dirichlet_bc = (it_nr == 0);\\n \\n if (it_nr > 1)\\n      {\\n        std::cout << \\\" --- \\\" << std::flush;\\n return;\\n      }\\n \\n    std::cout << \\\" CST \\\" << std::flush;\\n \\n if (apply_dirichlet_bc)\\n      {\\n        constraints.clear();\\n \\n const FEValuesExtractors::Scalar x_displacement(0);\\n const FEValuesExtractors::Scalar y_displacement(1);\\n \\n        {\\n const int boundary_id = 0;\\n \\n VectorTools::interpolate_boundary_values(\\n            dof_handler,\\n            boundary_id,\\n Functions::ZeroFunction<dim>(n_components),\\n            constraints,\\n            fe.component_mask(x_displacement));\\n        }\\n        {\\n const int boundary_id = 2;\\n \\n VectorTools::interpolate_boundary_values(\\n            dof_handler,\\n            boundary_id,\\n Functions::ZeroFunction<dim>(n_components),\\n            constraints,\\n            fe.component_mask(y_displacement));\\n        }\\n \\n if (dim == 3)\\n          {\\n const FEValuesExtractors::Scalar z_displacement(2);\\n \\n            {\\n const int boundary_id = 3;\\n \\n VectorTools::interpolate_boundary_values(\\n                dof_handler,\\n                boundary_id,\\n Functions::ZeroFunction<dim>(n_components),\\n                constraints,\\n                (fe.component_mask(x_displacement) |\\n                 fe.component_mask(z_displacement)));\\n            }\\n            {\\n const int boundary_id = 4;\\n \\n VectorTools::interpolate_boundary_values(\\n                dof_handler,\\n                boundary_id,\\n Functions::ZeroFunction<dim>(n_components),\\n                constraints,\\n                fe.component_mask(z_displacement));\\n            }\\n \\n            {\\n const int boundary_id = 6;\\n \\n VectorTools::interpolate_boundary_values(\\n                dof_handler,\\n                boundary_id,\\n Functions::ZeroFunction<dim>(n_components),\\n                constraints,\\n                (fe.component_mask(x_displacement) |\\n                 fe.component_mask(z_displacement)));\\n            }\\n          }\\n else\\n          {\\n            {\\n const int boundary_id = 3;\\n \\n VectorTools::interpolate_boundary_values(\\n                dof_handler,\\n                boundary_id,\\n Functions::ZeroFunction<dim>(n_components),\\n                constraints,\\n                (fe.component_mask(x_displacement)));\\n            }\\n            {\\n const int boundary_id = 6;\\n \\n VectorTools::interpolate_boundary_values(\\n                dof_handler,\\n                boundary_id,\\n Functions::ZeroFunction<dim>(n_components),\\n                constraints,\\n                (fe.component_mask(x_displacement)));\\n            }\\n          }\\n      }\\n else\\n      {\\n if (constraints.has_inhomogeneities())\\n          {\\n AffineConstraints<double> homogeneous_constraints(constraints);\\n for (unsigned int dof = 0; dof != dof_handler.n_dofs(); ++dof)\\n if (homogeneous_constraints.is_inhomogeneously_constrained(dof))\\n                homogeneous_constraints.set_inhomogeneity(dof, 0.0);\\n \\n            constraints.clear();\\n            constraints.copy_from(homogeneous_constraints);\\n          }\\n      }\\n \\n    constraints.close();\\n  }\\n \\n \\n template <int dim>\\n void Solid<dim>::assemble_sc()\\n  {\\n    timer.enter_subsection(\\\"Perform static condensation\\\");\\n    std::cout << \\\" ASM_SC \\\" << std::flush;\\n \\n    PerTaskData_SC per_task_data(dofs_per_cell,\\n                                 element_indices_u.size(),\\n                                 element_indices_p.size(),\\n                                 element_indices_J.size());\\n    ScratchData_SC scratch_data;\\n \\n WorkStream::run(dof_handler.active_cell_iterators(),\\n                    *this,\\n                    &Solid::assemble_sc_one_cell,\\n                    &Solid::copy_local_to_global_sc,\\n                    scratch_data,\\n                    per_task_data);\\n \\n    timer.leave_subsection();\\n  }\\n \\n \\n template <int dim>\\n void Solid<dim>::copy_local_to_global_sc(const PerTaskData_SC &data)\\n  {\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n        tangent_matrix.add(data.local_dof_indices[i],\\n                           data.local_dof_indices[j],\\n                           data.cell_matrix(i, j));\\n  }\\n \\n \\n template <int dim>\\n void Solid<dim>::assemble_sc_one_cell(\\n const typename DoFHandler<dim>::active_cell_iterator &cell,\\n    ScratchData_SC                                       &scratch,\\n    PerTaskData_SC                                       &data)\\n  {\\n    data.reset();\\n    scratch.reset();\\n    cell->get_dof_indices(data.local_dof_indices);\\n \\n \\n    data.k_orig.extract_submatrix_from(tangent_matrix,\\n                                       data.local_dof_indices,\\n                                       data.local_dof_indices);\\n    data.k_pu.extract_submatrix_from(data.k_orig,\\n                                     element_indices_p,\\n                                     element_indices_u);\\n    data.k_pJ.extract_submatrix_from(data.k_orig,\\n                                     element_indices_p,\\n                                     element_indices_J);\\n    data.k_JJ.extract_submatrix_from(data.k_orig,\\n                                     element_indices_J,\\n                                     element_indices_J);\\n \\n    data.k_pJ_inv.invert(data.k_pJ);\\n \\n    data.k_pJ_inv.mmult(data.A, data.k_pu);\\n    data.k_JJ.mmult(data.B, data.A);\\n    data.k_pJ_inv.Tmmult(data.C, data.B);\\n    data.k_pu.Tmmult(data.k_bbar, data.C);\\n    data.k_bbar.scatter_matrix_to(element_indices_u,\\n                                  element_indices_u,\\n                                  data.cell_matrix);\\n \\n    data.k_pJ_inv.add(-1.0, data.k_pJ);\\n    data.k_pJ_inv.scatter_matrix_to(element_indices_p,\\n                                    element_indices_J,\\n                                    data.cell_matrix);\\n  }\\n \\n template <int dim>\\n  std::pair<unsigned int, double>\\n  Solid<dim>::solve_linear_system(BlockVector<double> &newton_update)\\n  {\\n unsigned int lin_it  = 0;\\n double       lin_res = 0.0;\\n \\n if (parameters.use_static_condensation == true)\\n      {\\n \\n BlockVector<double> A(dofs_per_block);\\n BlockVector<double> B(dofs_per_block);\\n \\n \\n        {\\n          assemble_sc();\\n \\n          tangent_matrix.block(p_dof, J_dof)\\n            .vmult(A.block(J_dof), system_rhs.block(p_dof));\\n          tangent_matrix.block(J_dof, J_dof)\\n            .vmult(B.block(J_dof), A.block(J_dof));\\n          A.block(J_dof) = system_rhs.block(J_dof);\\n          A.block(J_dof) -= B.block(J_dof);\\n          tangent_matrix.block(p_dof, J_dof)\\n            .Tvmult(A.block(p_dof), A.block(J_dof));\\n          tangent_matrix.block(u_dof, p_dof)\\n            .vmult(A.block(u_dof), A.block(p_dof));\\n          system_rhs.block(u_dof) -= A.block(u_dof);\\n \\n          timer.enter_subsection(\\\"Linear solver\\\");\\n          std::cout << \\\" SLV \\\" << std::flush;\\n if (parameters.type_lin == \\\"CG\\\")\\n            {\\n const auto solver_its = static_cast<unsigned int>(\\n                tangent_matrix.block(u_dof, u_dof).m() *\\n                parameters.max_iterations_lin);\\n const double tol_sol =\\n                parameters.tol_lin * system_rhs.block(u_dof).l2_norm();\\n \\n SolverControl solver_control(solver_its, tol_sol);\\n \\n GrowingVectorMemory<Vector<double>> GVM;\\n SolverCG<Vector<double>> solver_CG(solver_control, GVM);\\n \\n PreconditionSelector<SparseMatrix<double>, Vector<double>>\\n                preconditioner(parameters.preconditioner_type,\\n                               parameters.preconditioner_relaxation);\\n              preconditioner.use_matrix(tangent_matrix.block(u_dof, u_dof));\\n \\n              solver_CG.solve(tangent_matrix.block(u_dof, u_dof),\\n                              newton_update.block(u_dof),\\n                              system_rhs.block(u_dof),\\n                              preconditioner);\\n \\n              lin_it  = solver_control.last_step();\\n              lin_res = solver_control.last_value();\\n            }\\n else if (parameters.type_lin == \\\"Direct\\\")\\n            {\\n SparseDirectUMFPACK A_direct;\\n              A_direct.initialize(tangent_matrix.block(u_dof, u_dof));\\n              A_direct.vmult(newton_update.block(u_dof),\\n                             system_rhs.block(u_dof));\\n \\n              lin_it  = 1;\\n              lin_res = 0.0;\\n            }\\n else\\n Assert(false, ExcMessage(\\\"Linear solver type not implemented\\\"));\\n \\n          timer.leave_subsection();\\n        }\\n \\n        constraints.distribute(newton_update);\\n \\n        timer.enter_subsection(\\\"Linear solver postprocessing\\\");\\n        std::cout << \\\" PP \\\" << std::flush;\\n \\n        {\\n          tangent_matrix.block(p_dof, u_dof)\\n            .vmult(A.block(p_dof), newton_update.block(u_dof));\\n          A.block(p_dof) *= -1.0;\\n          A.block(p_dof) += system_rhs.block(p_dof);\\n          tangent_matrix.block(p_dof, J_dof)\\n            .vmult(newton_update.block(J_dof), A.block(p_dof));\\n        }\\n \\n        constraints.distribute(newton_update);\\n \\n        {\\n          tangent_matrix.block(J_dof, J_dof)\\n            .vmult(A.block(J_dof), newton_update.block(J_dof));\\n          A.block(J_dof) *= -1.0;\\n          A.block(J_dof) += system_rhs.block(J_dof);\\n          tangent_matrix.block(p_dof, J_dof)\\n            .Tvmult(newton_update.block(p_dof), A.block(J_dof));\\n        }\\n \\n        constraints.distribute(newton_update);\\n \\n        timer.leave_subsection();\\n      }\\n else\\n      {\\n        std::cout << \\\" ------ \\\" << std::flush;\\n \\n        timer.enter_subsection(\\\"Linear solver\\\");\\n        std::cout << \\\" SLV \\\" << std::flush;\\n \\n if (parameters.type_lin == \\\"CG\\\")\\n          {\\n \\n const Vector<double> &f_u = system_rhs.block(u_dof);\\n const Vector<double> &f_p = system_rhs.block(p_dof);\\n const Vector<double> &f_J = system_rhs.block(J_dof);\\n \\n Vector<double> &d_u = newton_update.block(u_dof);\\n Vector<double> &d_p = newton_update.block(p_dof);\\n Vector<double> &d_J = newton_update.block(J_dof);\\n \\n const auto K_uu =\\n linear_operator(tangent_matrix.block(u_dof, u_dof));\\n const auto K_up =\\n linear_operator(tangent_matrix.block(u_dof, p_dof));\\n const auto K_pu =\\n linear_operator(tangent_matrix.block(p_dof, u_dof));\\n const auto K_Jp =\\n linear_operator(tangent_matrix.block(J_dof, p_dof));\\n const auto K_JJ =\\n linear_operator(tangent_matrix.block(J_dof, J_dof));\\n \\n PreconditionSelector<SparseMatrix<double>, Vector<double>>\\n              preconditioner_K_Jp_inv(\\\"jacobi\\\");\\n            preconditioner_K_Jp_inv.use_matrix(\\n              tangent_matrix.block(J_dof, p_dof));\\n ReductionControl solver_control_K_Jp_inv(\\n static_cast<unsigned int>(tangent_matrix.block(J_dof, p_dof).m() *\\n                                        parameters.max_iterations_lin),\\n              1.0e-30,\\n              parameters.tol_lin);\\n SolverSelector<Vector<double>> solver_K_Jp_inv;\\n            solver_K_Jp_inv.select(\\\"cg\\\");\\n            solver_K_Jp_inv.set_control(solver_control_K_Jp_inv);\\n const auto K_Jp_inv =\\n inverse_operator(K_Jp, solver_K_Jp_inv, preconditioner_K_Jp_inv);\\n \\n const auto K_pJ_inv     = transpose_operator(K_Jp_inv);\\n const auto K_pp_bar     = K_Jp_inv * K_JJ * K_pJ_inv;\\n const auto K_uu_bar_bar = K_up * K_pp_bar * K_pu;\\n const auto K_uu_con     = K_uu + K_uu_bar_bar;\\n \\n PreconditionSelector<SparseMatrix<double>, Vector<double>>\\n              preconditioner_K_con_inv(parameters.preconditioner_type,\\n                                       parameters.preconditioner_relaxation);\\n            preconditioner_K_con_inv.use_matrix(\\n              tangent_matrix.block(u_dof, u_dof));\\n ReductionControl solver_control_K_con_inv(\\n static_cast<unsigned int>(tangent_matrix.block(u_dof, u_dof).m() *\\n                                        parameters.max_iterations_lin),\\n              1.0e-30,\\n              parameters.tol_lin);\\n SolverSelector<Vector<double>> solver_K_con_inv;\\n            solver_K_con_inv.select(\\\"cg\\\");\\n            solver_K_con_inv.set_control(solver_control_K_con_inv);\\n const auto K_uu_con_inv =\\n inverse_operator(K_uu_con,\\n                               solver_K_con_inv,\\n                               preconditioner_K_con_inv);\\n \\n            d_u =\\n              K_uu_con_inv * (f_u - K_up * (K_Jp_inv * f_J - K_pp_bar * f_p));\\n \\n            timer.leave_subsection();\\n \\n            timer.enter_subsection(\\\"Linear solver postprocessing\\\");\\n            std::cout << \\\" PP \\\" << std::flush;\\n \\n            d_J = K_pJ_inv * (f_p - K_pu * d_u);\\n            d_p = K_Jp_inv * (f_J - K_JJ * d_J);\\n \\n            lin_it  = solver_control_K_con_inv.last_step();\\n            lin_res = solver_control_K_con_inv.last_value();\\n          }\\n else if (parameters.type_lin == \\\"Direct\\\")\\n          {\\n SparseDirectUMFPACK A_direct;\\n            A_direct.initialize(tangent_matrix);\\n            A_direct.vmult(newton_update, system_rhs);\\n \\n            lin_it  = 1;\\n            lin_res = 0.0;\\n \\n            std::cout << \\\" -- \\\" << std::flush;\\n          }\\n else\\n Assert(false, ExcMessage(\\\"Linear solver type not implemented\\\"));\\n \\n        timer.leave_subsection();\\n \\n        constraints.distribute(newton_update);\\n      }\\n \\n return std::make_pair(lin_it, lin_res);\\n  }\\n \\n template <int dim>\\n void Solid<dim>::output_results() const\\n {\\n DataOut<dim> data_out;\\n    std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n      data_component_interpretation(\\n        dim, DataComponentInterpretation::component_is_part_of_vector);\\n    data_component_interpretation.push_back(\\n DataComponentInterpretation::component_is_scalar);\\n    data_component_interpretation.push_back(\\n DataComponentInterpretation::component_is_scalar);\\n \\n    std::vector<std::string> solution_name(dim, \\\"displacement\\\");\\n    solution_name.emplace_back(\\\"pressure\\\");\\n    solution_name.emplace_back(\\\"dilatation\\\");\\n \\n DataOutBase::VtkFlags output_flags;\\n    output_flags.write_higher_order_cells       = true;\\n    output_flags.physical_units[\\\"displacement\\\"] = \\\"m\\\";\\n    data_out.set_flags(output_flags);\\n \\n    data_out.attach_dof_handler(dof_handler);\\n    data_out.add_data_vector(solution_n,\\n                             solution_name,\\n DataOut<dim>::type_dof_data,\\n                             data_component_interpretation);\\n \\n Vector<double> soln(solution_n.size());\\n for (unsigned int i = 0; i < soln.size(); ++i)\\n      soln(i) = solution_n(i);\\n MappingQEulerian<dim> q_mapping(degree, dof_handler, soln);\\n    data_out.build_patches(q_mapping, degree);\\n \\n    std::ofstream output(\\\"solution-\\\" + std::to_string(dim) + \\\"d-\\\" +\\n                         std::to_string(time.get_timestep()) + \\\".vtu\\\");\\n    data_out.write_vtu(output);\\n  }\\n \\n} // namespace Step44\\n \\n \\nint main()\\n{\\n using namespace Step44;\\n \\n try\\n    {\\n const unsigned int dim = 3;\\n      Solid<dim>         solid(\\\"parameters.prm\\\");\\n      solid.run();\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n \\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n \\n return 0;\\n}\\naffine_constraints.h\\npoint.h\\nblock_sparse_matrix.h\\nblock_vector.h\\nAffineConstraints::has_inhomogeneitiesbool has_inhomogeneities() const\\nAffineConstraints::distributevoid distribute(VectorType &vec) const\\nAffineConstraints::is_constrainedbool is_constrained(const size_type line_n) constDefinition affine_constraints.h:2493\\nAffineConstraints::copy_fromvoid copy_from(const AffineConstraints< other_number > &other)Definition affine_constraints.h:2778\\nAffineConstraints::clearvoid clear()\\nBlockMatrixBase::blockBlockType & block(const unsigned int row, const unsigned int column)\\nBlockMatrixBase::addvoid add(const size_type i, const size_type j, const value_type value)\\nBlockSparseMatrix::reinitvirtual void reinit(const BlockSparsityPattern &sparsity)\\nBlockSparseMatrix::clearvoid clear()\\nBlockSparsityPattern::copy_fromvoid copy_from(const BlockDynamicSparsityPattern &dsp)Definition block_sparsity_pattern.cc:424\\nBlockVectorBase::sizevirtual size_type size() const override\\nBlockVector::reinitvoid reinit(const unsigned int n_blocks, const size_type block_size=0, const bool omit_zeroing_entries=false)\\nCellDataStorage::initializevoid initialize(const CellIteratorType &cell, const unsigned int number_of_data_points_per_cell)\\nCellDataStorage::get_datastd::vector< std::shared_ptr< T > > get_data(const CellIteratorType &cell)\\nDataOutInterface::write_vtuvoid write_vtu(std::ostream &out) constDefinition data_out_base.cc:7692\\nDataOutInterface::set_flagsvoid set_flags(const FlagType &flags)Definition data_out_base.cc:8863\\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nDoFHandler::distribute_dofsvoid distribute_dofs(const FiniteElement< dim, spacedim > &fe)\\nDoFHandler::n_dofstypes::global_dof_index n_dofs() const\\nFEValuesBase::JxWdouble JxW(const unsigned int q_point) const\\nFEValues::reinitvoid reinit(const TriaIterator< DoFCellAccessor< dim, spacedim, level_dof_access > > &cell)\\nFiniteElementData::n_dofs_per_cellunsigned int n_dofs_per_cell() const\\nFiniteElement::component_maskComponentMask component_mask(const FEValuesExtractors::Scalar &scalar) const\\nFiniteElement::system_to_component_indexstd::pair< unsigned int, unsigned int > system_to_component_index(const unsigned int index) const\\nFiniteElement::system_to_base_indexstd::pair< std::pair< unsigned int, unsigned int >, unsigned int > system_to_base_index(const unsigned int index) const\\nParameterHandler::parse_inputvirtual void parse_input(std::istream &input, const std::string &filename=\\\"input file\\\", const std::string &last_line=\\\"\\\", const bool skip_undefined=false)Definition parameter_handler.cc:433\\nSolverSelector::set_controlvoid set_control(SolverControl &ctrl)Definition solver_selector.h:320\\nSparseDirectUMFPACK::vmultvoid vmult(Vector< double > &dst, const Vector< double > &src) constDefinition sparse_direct.cc:795\\nTimerOutput::leave_subsectionvoid leave_subsection(const std::string &section_name=\\\"\\\")Definition timer.cc:443\\nTimerOutput::enter_subsectionvoid enter_subsection(const std::string &section_name)Definition timer.cc:401\\ndof_renumbering.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nfe_values.h\\nfe_dgp.h\\nfe_q.h\\nfe_system.h\\nfe_tools.h\\nfull_matrix.h\\nfunction.h\\ntria.h\\ngrid_generator.h\\ngrid_in.h\\ngrid_tools.h\\nDoFHandler::active_cell_iteratorsIteratorRange< active_cell_iterator > active_cell_iterators() const\\nkinematics.h\\nlinear_operator.h\\nmapping_q_eulerian.h\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\nMatrixFreeOperators::BlockHelper::n_blocksstd::enable_if_t< IsBlockVector< VectorType >::value, unsigned int > n_blocks(const VectorType &vector)Definition operators.h:49\\nPhysics::Elasticity::Kinematics::CSymmetricTensor< 2, dim, Number > C(const Tensor< 2, dim, Number > &F)\\nTrilinosWrappers::internal::endVectorType::value_type * end(VectorType &V)Definition trilinos_sparse_matrix.cc:64\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\ndata_out.h\\npackaged_operation.h\\nparameter_handler.h\\nprecondition_selector.h\\nquadrature_lib.h\\nquadrature_point_data.h\\nsolver_cg.h\\nsolver_selector.h\\nsparse_direct.h\\nstandard_tensors.h\\nDataOutBase::VtkFlags::physical_unitsstd::map< std::string, std::string > physical_unitsDefinition data_out_base.h:1224\\nsymmetric_tensor.h\\ntensor.h\\ntimer.h\\nvector_tools.h\\nwork_stream.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"