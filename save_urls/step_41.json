"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_41.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-41 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-41 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-41 tutorial program\\n\\n\\nThis tutorial depends on step-15.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nIntroduction\\nClassical formulation\\nDerivation of the variational inequality\\nFormulation as a saddle point problem\\nActive Set methods to solve the saddle point problem\\nThe primal-dual active set algorithm\\nImplementation\\n\\n The commented program\\n\\nInclude files\\nThe ObstacleProblem class template\\nRight hand side, boundary values, and the obstacle\\nImplementation of the ObstacleProblem class\\n\\nObstacleProblem::ObstacleProblem\\nObstacleProblem::make_grid\\nObstacleProblem::setup_system\\nObstacleProblem::assemble_system\\nObstacleProblem::assemble_mass_matrix_diagonal\\nObstacleProblem::update_solution_and_constraints\\nObstacleProblem::solve\\nObstacleProblem::output_results\\nObstacleProblem::run\\n\\nThe main function\\n\\n\\n Results\\n\\nPossibilities for extensions\\n\\n The plain program\\n   \\n\\n\\nThis program was contributed by J\\u00f6rg Frohne (University of Siegen, Germany) while on a long-term visit to Texas A&M University. \\n This material is based upon work partly supported by ThyssenKrupp Steel Europe. \\n Introduction\\nThis example is based on the Laplace equation in 2d and deals with the question what happens if a membrane is deflected by some external force but is also constrained by an obstacle. In other words, think of a elastic membrane clamped at the boundary to a rectangular frame (we choose  \\\\(\\\\Omega =\\n\\\\left[-1,1\\\\right]^2\\\\)) and that sags through due to gravity acting on it. What happens now if there is an obstacle under the membrane that prevents it from reaching its equilibrium position if gravity was the only existing force? In the current example program, we will consider that under the membrane is a stair step obstacle against which gravity pushes the membrane.\\nThis problem is typically called the \\\"obstacle problem\\\" (see also this Wikipedia article), and it results in a variational inequality, rather than a variational equation when put into the weak form. We will below derive it from the classical formulation, but before we go on to discuss the mathematics let us show how the solution of the problem we will consider in this tutorial program looks to gain some intuition of what we should expect:\\n\\n\\n  \\n\\nHere, at the left, we see the displacement of the membrane. The shape of the obstacle underneath is clearly visible. On the right, we overlay which parts of the membrane are in contact with the obstacle. We will later call this set of points the \\\"active set\\\" to indicate that an inequality constraint is active there.\\nClassical formulation\\nThe classical formulation of the problem possesses the following form:       \\n\\\\begin{align*}\\n -\\\\textrm{div}\\\\ \\\\sigma &\\\\geq f & &\\\\quad\\\\text{in } \\\\Omega,\\\\\\\\\\n \\\\sigma &= \\\\nabla u & &\\\\quad\\\\text{in } \\\\Omega,\\\\\\\\\\n u(\\\\mathbf x) &= 0 & &\\\\quad\\\\text{on }\\\\partial\\\\Omega,\\\\\\\\\\n(-\\\\Delta u - f)(u - g) &= 0 & &\\\\quad\\\\text{in } \\\\Omega,\\\\\\\\\\n u(\\\\mathbf x) &\\\\geq g(\\\\mathbf x) & &\\\\quad\\\\text{in } \\\\Omega,\\n\\\\end{align*}\\n\\n where \\\\(u\\\\) is a scalar valued function that denotes the vertical displacement of the membrane. The first equation is called equilibrium condition with a force of areal density \\\\(f\\\\). Here, we will consider this force to be gravity. The second one is known as Hooke's Law that says that the stresses \\\\(\\\\sigma\\\\) are proportional to the gradient of the displacements \\\\(u\\\\) (the proportionality constant, often denoted by \\\\(E\\\\), has been set to one here, without loss of generality; if it is constant, it can be put into the right hand side function). At the boundary we have zero Dirichlet conditions. Obviously, the first two equations can be combined to yield \\\\(-\\\\Delta u \\\\ge f\\\\).\\nIntuitively, gravity acts downward and so \\\\(f(\\\\mathbf x)\\\\) is a negative function (we choose \\\\(f=-10\\\\) in this program). The first condition then means that the total force acting on the membrane is gravity plus something positive: namely the upward force that the obstacle exerts on the membrane at those places where the two of them are in contact. How big is this additional force? We don't know yet (and neither do we know \\\"where\\\" it actually acts) but it must be so that the membrane doesn't penetrate the obstacle.\\nThe fourth equality above together with the last inequality forms the obstacle condition which has to hold at every point of the whole domain. The latter of these two means that the membrane must be above the obstacle \\\\(g(\\\\mathbf x)\\\\) everywhere. The second to last equation, often called the \\\"complementarity\\ncondition\\\" says that where the membrane is not in contact with the obstacle (i.e., those \\\\(\\\\mathbf x\\\\) where \\\\(u(\\\\mathbf x) - g(\\\\mathbf x) \\\\neq 0\\\\)), then \\\\(-\\\\Delta u=f\\\\) at these locations; in other words, no additional forces act there, as expected. On the other hand, where \\\\(u=g\\\\) we can have  \\\\(-\\\\Delta u-f\\n\\\\neq 0\\\\), i.e., there can be additional forces (though there don't have to be: it is possible for the membrane to just touch, not press against, the obstacle).\\nDerivation of the variational inequality\\nAn obvious way to obtain the variational formulation of the obstacle problem is to consider the total potential energy:   \\n\\\\begin{equation*}\\n E(u) \\\\dealcoloneq \\\\dfrac{1}{2}\\\\int\\\\limits_{\\\\Omega} \\\\nabla u \\\\cdot \\\\nabla u - \\\\int\\\\limits_{\\\\Omega} fu.\\n\\\\end{equation*}\\n\\n We have to find a solution \\\\(u\\\\in G\\\\) of the following minimization problem:   \\n\\\\begin{equation*}\\n E(u)\\\\leq E(v)\\\\quad \\\\forall v\\\\in G,\\n\\\\end{equation*}\\n\\n with the convex set of admissible displacements:   \\n\\\\begin{equation*}\\n G \\\\dealcoloneq \\\\lbrace v\\\\in V: v\\\\geq g \\\\text{ a.e. in } \\\\Omega\\\\rbrace,\\\\quad V\\\\dealcoloneq H^1_0(\\\\Omega).\\n\\\\end{equation*}\\n\\n This set takes care of the third and fifth conditions above (the boundary values and the complementarity condition).\\nConsider now the minimizer \\\\(u\\\\in G\\\\) of \\\\(E\\\\) and any other function  \\\\(v\\\\in\\nG\\\\). Then the function   \\n\\\\begin{equation*}\\n F(\\\\varepsilon) \\\\dealcoloneq E(u+\\\\varepsilon(v-u)),\\\\quad\\\\varepsilon\\\\in\\\\left[0,1\\\\right],\\n\\\\end{equation*}\\n\\n takes its minimum at \\\\(\\\\varepsilon = 0\\\\) (because \\\\(u\\\\) is a minimizer of the energy functional \\\\(E(\\\\cdot)\\\\)), so that \\\\(F'(0)\\\\geq 0\\\\) for any choice of \\\\(v\\\\). Note that \\\\(u+\\\\varepsilon(v-u) = (1-\\\\varepsilon)u+\\\\varepsilon v\\\\in G\\\\) because of the convexity of \\\\(G\\\\). If we compute \\\\(F'(\\\\varepsilon)\\\\vert_{\\\\varepsilon=0}\\\\) it yields the variational formulation we are searching for:\\nFind a function \\\\(u\\\\in G\\\\) with \\n\\\\begin{equation*}\\n \\\\left(\\\\nabla u, \\\\nabla(v-u)\\\\right) \\\\geq \\\\left(f,v-u\\\\right) \\\\quad \\\\forall v\\\\in G.\\n\\\\end{equation*}\\n\\nThis is the typical form of variational inequalities, where not just \\\\(v\\\\) appears in the bilinear form but in fact \\\\(v-u\\\\). The reason is this: if \\\\(u\\\\) is not constrained, then we can find test functions \\\\(v\\\\) in \\\\(G\\\\) so that \\\\(v-u\\\\) can have any sign. By choosing test functions \\\\(v_1,v_2\\\\) so that \\\\(v_1-u = -(v_2-u)\\\\) it follows that the inequality can only hold for both \\\\(v_1\\\\) and \\\\(v_2\\\\) if the two sides are in fact equal, i.e., we obtain a variational equality.\\nOn the other hand, if \\\\(u=g\\\\) then \\\\(G\\\\) only allows test functions \\\\(v\\\\) so that in fact \\\\(v-u\\\\ge 0\\\\). This means that we can't test the equation with both \\\\(v-u\\\\) and \\\\(-(v-u)\\\\) as above, and so we can no longer conclude that the two sides are in fact equal. Thus, this mimics the way we have discussed the complementarity condition above.\\nFormulation as a saddle point problem\\nThe variational inequality above is awkward to work with. We would therefore like to reformulate it as an equivalent saddle point problem. We introduce a Lagrange multiplier \\\\(\\\\lambda\\\\) and the convex cone \\\\(K\\\\subset V'\\\\), \\\\(V'\\\\) dual space of \\\\(V\\\\),  \\\\(K \\\\dealcoloneq \\\\{\\\\mu\\\\in V': \\\\langle\\\\mu,v\\\\rangle\\\\geq 0,\\\\quad \\\\forall\\nv\\\\in V, v \\\\le 0 \\\\}\\\\) of Lagrange multipliers, where \\\\(\\\\langle\\\\cdot,\\\\cdot\\\\rangle\\\\) denotes the duality pairing between \\\\(V'\\\\) and \\\\(V\\\\). Intuitively, \\\\(K\\\\) is the cone of all \\\"non-positive\\nfunctions\\\", except that \\\\(K\\\\subset (H_0^1)'\\\\) and so contains other objects besides regular functions as well. This yields:\\nFind \\\\(u\\\\in V\\\\) and \\\\(\\\\lambda\\\\in K\\\\) such that \\n\\\\begin{align*}\\n a(u,v) + b(v,\\\\lambda) &= f(v),\\\\quad &&v\\\\in V\\\\\\\\\\n b(u,\\\\mu - \\\\lambda) &\\\\leq \\\\langle g,\\\\mu - \\\\lambda\\\\rangle,\\\\quad&&\\\\mu\\\\in K,\\n\\\\end{align*}\\n\\n with \\n\\\\begin{align*}\\n a(u,v) &\\\\dealcoloneq \\\\left(\\\\nabla u, \\\\nabla v\\\\right),\\\\quad &&u,v\\\\in V\\\\\\\\\\n b(u,\\\\mu) &\\\\dealcoloneq \\\\langle u,\\\\mu\\\\rangle,\\\\quad &&u\\\\in V,\\\\quad\\\\mu\\\\in V'.\\n\\\\end{align*}\\n\\n In other words, we can consider \\\\(\\\\lambda\\\\) as the negative of the additional, positive force that the obstacle exerts on the membrane. The inequality in the second line of the statement above only appears to have the wrong sign because we have \\\\(\\\\mu-\\\\lambda<0\\\\) at points where \\\\(\\\\lambda=0\\\\), given the definition of \\\\(K\\\\).\\nThe existence and uniqueness of \\\\((u,\\\\lambda)\\\\in V\\\\times K\\\\) of this saddle point problem has been stated in Glowinski, Lions and Tr\\u00e9moli\\u00e8res: Numerical Analysis of Variational Inequalities, North-Holland, 1981.\\nActive Set methods to solve the saddle point problem\\nThere are different methods to solve the variational inequality. As one possibility you can understand the saddle point problem as a convex quadratic program (QP) with inequality constraints.\\nTo get there, let us assume that we discretize both \\\\(u\\\\) and \\\\(\\\\lambda\\\\) with the same finite element space, for example the usual \\\\(Q_k\\\\) spaces. We would then get the equations     \\n\\\\begin{eqnarray*}\\n &A U + B\\\\Lambda = F,&\\\\\\\\\\n &[BU-G]_i \\\\geq 0, \\\\quad \\\\Lambda_i \\\\leq 0,\\\\quad \\\\Lambda_i[BU-G]_i = 0\\n\\\\qquad \\\\forall i.&\\n\\\\end{eqnarray*}\\n\\n where \\\\(B\\\\) is the mass matrix on the chosen finite element space and the indices \\\\(i\\\\) above are for all degrees of freedom in the set \\\\(\\\\cal S\\\\) of degrees of freedom located in the interior of the domain (we have Dirichlet conditions on the perimeter). However, we can make our life simpler if we use a particular quadrature rule when assembling all terms that yield this mass matrix, namely a quadrature formula where quadrature points are only located at the interpolation points at which shape functions are defined; since all but one shape function are zero at these locations, we get a diagonal mass matrix with     \\n\\\\begin{align*}\\n  B_{ii} = \\\\int_\\\\Omega \\\\varphi_i(\\\\mathbf x)^2\\\\ \\\\textrm{d}x,\\n  \\\\qquad\\n  B_{ij}=0 \\\\ \\\\text{for } i\\\\neq j.\\n\\\\end{align*}\\n\\n To define \\\\(G\\\\) we use the same technique as for \\\\(B\\\\). In other words, we define   \\n\\\\begin{align*}\\n  G_{i} = \\\\int_\\\\Omega g_h(x) \\\\varphi_i(\\\\mathbf x)\\\\ \\\\textrm{d}x,\\n\\\\end{align*}\\n\\n where \\\\(g_h\\\\) is a suitable approximation of \\\\(g\\\\). The integral in the definition of \\\\(B_{ii}\\\\) and \\\\(G_i\\\\) are then approximated by the trapezoidal rule. With this, the equations above can be restated as     \\n\\\\begin{eqnarray*}\\n &A U + B\\\\Lambda = F,&\\\\\\\\\\n &U_i-B_{ii}^{-1}G_i \\\\ge 0, \\\\quad \\\\Lambda_i \\\\leq 0,\\\\quad \\\\Lambda_i[U_i-B_{ii}^{-1}G_i] = 0\\n\\\\qquad \\\\forall i\\\\in{\\\\cal S}.&\\n\\\\end{eqnarray*}\\n\\nNow we define for each degree of freedom \\\\(i\\\\) the function   \\n\\\\begin{equation*}\\n C([BU]_i,\\\\Lambda_i) \\\\dealcoloneq -\\\\Lambda_i + \\\\min\\\\lbrace 0, \\\\Lambda_i + c([BU]_i - G_i) \\\\rbrace,\\n\\\\end{equation*}\\n\\n with some \\\\(c>0\\\\). (In this program we choose \\\\(c = 100\\\\). It is a kind of a penalty parameter which depends on the problem itself and needs to be chosen large enough; for example there is no convergence for \\\\(c = 1\\\\) using the current program if we use 7 global refinements.)\\nAfter some head-scratching one can then convince oneself that the inequalities above can equivalently be rewritten as   \\n\\\\begin{equation*}\\n C([BU]_i,\\\\Lambda_i) = 0, \\\\qquad \\\\forall i\\\\in{\\\\cal S}.\\n\\\\end{equation*}\\n\\n The primal-dual active set strategy we will use here is an iterative scheme which is based on this condition to predict the next active and inactive sets \\\\(\\\\mathcal{A}_k\\\\) and \\\\(\\\\mathcal{F}_k\\\\) (that is, those complementary sets of indices \\\\(i\\\\) for which \\\\(U_i\\\\) is either equal to or not equal to the value of the obstacle \\\\(B^{-1}G\\\\)). For a more in depth treatment of this approach, see Hintermueller, Ito, Kunisch: The primal-dual active set strategy as a semismooth newton method, SIAM J. OPTIM., 2003, Vol. 13, No. 3, pp. 865-888.\\nThe primal-dual active set algorithm\\nThe algorithm for the primal-dual active set method works as follows (NOTE: \\\\(B = B^T\\\\)):\\n\\nInitialize \\\\(\\\\mathcal{A}_k\\\\) and \\\\(\\\\mathcal{F}_k\\\\), such that \\\\(\\\\mathcal{S}=\\\\mathcal{A}_k\\\\cup\\\\mathcal{F}_k\\\\) and \\\\(\\\\mathcal{A}_k\\\\cap\\\\mathcal{F}_k=\\\\emptyset\\\\) and set \\\\(k=1\\\\).\\nFind the primal-dual pair \\\\((U^k,\\\\Lambda^k)\\\\) that satisfies     \\n\\\\begin{align*}\\n  AU^k + B\\\\Lambda^k &= F,\\\\\\\\\\n  [BU^k]_i &= G_i\\\\quad&&\\\\forall i\\\\in\\\\mathcal{A}_k,\\\\\\\\\\n  \\\\Lambda_i^k &= 0\\\\quad&&\\\\forall i\\\\in\\\\mathcal{F}_k.\\n \\\\end{align*}\\n\\n Note that the second and third conditions imply that exactly \\\\(|S|\\\\) unknowns are fixed, with the first condition yielding the remaining \\\\(|S|\\\\) equations necessary to determine both \\\\(U\\\\) and \\\\(\\\\Lambda\\\\).\\nDefine the new active and inactive sets by      \\n\\\\begin{equation*}\\n \\\\begin{split}\\n  \\\\mathcal{A}_{k+1} \\\\dealcoloneq \\\\lbrace i\\\\in\\\\mathcal{S}:\\\\Lambda^k_i + c([BU^k]_i - G_i)< 0\\\\rbrace,\\\\\\\\\\n  \\\\mathcal{F}_{k+1} \\\\dealcoloneq \\\\lbrace i\\\\in\\\\mathcal{S}:\\\\Lambda^k_i + c([BU^k]_i - G_i)\\\\geq 0\\\\rbrace.\\n \\\\end{split}\\n \\\\end{equation*}\\n\\n\\nIf \\\\(\\\\mathcal{A}_{k+1}=\\\\mathcal{A}_k\\\\) (and then, obviously, also \\\\(\\\\mathcal{F}_{k+1}=\\\\mathcal{F}_k\\\\)) then stop, else set \\\\(k=k+1\\\\) and go to step (2).\\n\\nThe method is called \\\"primal-dual\\\" because it uses both primal (the displacement \\\\(U\\\\)) as well as dual variables (the Lagrange multiplier \\\\(\\\\Lambda\\\\)) to determine the next active set.\\nAt the end of this section, let us add two observations. First, for any primal-dual pair \\\\((U^k,\\\\Lambda^k)\\\\) that satisfies these condition, we can distinguish the following cases:\\n\\n\\\\(\\\\Lambda^k_i + c([BU^k]_i - G_i) < 0\\\\) (i active): \\n Then either \\\\([BU^k]_i<G_i\\\\) and \\\\(\\\\Lambda^k_i=0\\\\) (penetration) or \\\\(\\\\Lambda^k_i<0\\\\) and \\\\([BU^k]_i=G_i\\\\) (pressing load).\\n\\\\(\\\\Lambda^k_i + c([BU^k]_i - G_i)\\\\geq 0\\\\) (i inactive): \\n Then either \\\\([BU^k]_i\\\\geq G_i\\\\) and \\\\(\\\\Lambda^k_i=0\\\\) (no contact) or \\\\(\\\\Lambda^k_i\\\\geq0\\\\) and \\\\([BU^k]_i=G_i\\\\) (unpressing load).\\n\\nSecond, the method above appears intuitively correct and useful but a bit ad hoc. However, it can be derived in a concisely in the following way. To this end, note that we'd like to solve the nonlinear system     \\n\\\\begin{eqnarray*}\\n &A U + B\\\\Lambda = F,&\\\\\\\\\\n &C([BU-G]_i, \\\\Lambda_i) = 0,\\n\\\\qquad \\\\forall i.&\\n\\\\end{eqnarray*}\\n\\n We can iteratively solve this by always linearizing around the previous iterate (i.e., applying a Newton method), but for this we need to linearize the function \\\\(C(\\\\cdot,\\\\cdot)\\\\) that is not differentiable. That said, it is slantly differentiable, and in fact we have      \\n\\\\begin{equation*}\\n \\\\dfrac{\\\\partial}{\\\\partial U^k_i}C([BU^k]_i,\\\\Lambda^k_i) = \\\\begin{cases}\\n                                   cB_{ii},& \\\\text{if}\\\\ \\\\Lambda^k_i + c([BU^k]_i - G_i)< 0\\\\\\\\\\n                                   0,& \\\\text{if}\\\\ \\\\Lambda^k_i + c([BU^k]_i - G_i)\\\\geq 0.\\n                                  \\\\end{cases}\\n\\\\end{equation*}\\n\\n\\n\\\\begin{equation*}\\n \\\\dfrac{\\\\partial}{\\\\partial\\\\Lambda^k_i}C([BU^k]_i,\\\\Lambda^k_i) = \\\\begin{cases}\\n                                   0,& \\\\text{if}\\\\ \\\\Lambda^k_i + c([BU^k]_i - G_i)< 0\\\\\\\\\\n                                   -1,& \\\\text{if}\\\\ \\\\Lambda^k_i + c([BU^k]_i - G_i)\\\\geq 0.\\n                                  \\\\end{cases}\\n\\\\end{equation*}\\n\\n This suggest a semismooth Newton step of the form               \\n\\\\begin{equation*}\\n \\\\begin{pmatrix}\\n A_{\\\\mathcal{F}_k\\\\mathcal{F}_k} & A_{\\\\mathcal{F}_k\\\\mathcal{A}_k} & B_{\\\\mathcal{F}_k} & 0\\\\\\\\\\n A_{\\\\mathcal{A}_k\\\\mathcal{F}_k} & A_{\\\\mathcal{A}_k\\\\mathcal{A}_k} & 0 & B_{\\\\mathcal{A}_k}\\\\\\\\\\n 0 & 0 & -Id_{\\\\mathcal{F}_k} & 0\\\\\\\\\\n 0 & cB_{\\\\mathcal{A}_k} & 0 & 0\\n\\\\end{pmatrix}\\n\\\\begin{pmatrix}\\n \\\\delta U^k_{\\\\mathcal{F}_k}\\\\\\\\ \\\\delta U^k_{\\\\mathcal{A}_k}\\\\\\\\ \\\\delta \\\\Lambda^k_{\\\\mathcal{F}_k}\\\\\\\\ \\\\delta \\\\Lambda^k_{\\\\mathcal{A}_k}\\n\\\\end{pmatrix}\\n=\\n-\\\\begin{pmatrix}\\n (AU^k + B\\\\Lambda^k - F)_{\\\\mathcal{F}_k}\\\\\\\\ (AU^k + B\\\\Lambda^k - F)_{\\\\mathcal{A}_k}\\\\\\\\ -\\\\Lambda^k_{\\\\mathcal{F}_k}\\\\\\\\ c(B_{\\\\mathcal{A}_k} U^k - G)_{\\\\mathcal{A}_k}\\n\\\\end{pmatrix},\\n\\\\end{equation*}\\n\\n where we have split matrices \\\\(A,B\\\\) as well as vectors in the natural way into rows and columns whose indices belong to either the active set \\\\({\\\\mathcal{A}_k}\\\\) or the inactive set \\\\({\\\\mathcal{F}_k}\\\\).\\nRather than solving for updates \\\\(\\\\delta U, \\\\delta \\\\Lambda\\\\), we can also solve for the variables we are interested in right away by setting  \\\\(\\\\delta U^k \\\\dealcoloneq\\nU^{k+1} - U^k\\\\) and \\\\(\\\\delta \\\\Lambda^k \\\\dealcoloneq \\\\Lambda^{k+1} - \\\\Lambda^k\\\\) and bringing all known terms to the right hand side. This yields               \\n\\\\begin{equation*}\\n\\\\begin{pmatrix}\\n A_{\\\\mathcal{F}_k\\\\mathcal{F}_k} & A_{\\\\mathcal{F}_k\\\\mathcal{A}_k} & B_{\\\\mathcal{F}_k} & 0\\\\\\\\\\n A_{\\\\mathcal{A}_k\\\\mathcal{F}_k} & A_{\\\\mathcal{A}_k\\\\mathcal{A}_k} & 0 & B_{\\\\mathcal{A}_k}\\\\\\\\\\n 0 & 0 & Id_{\\\\mathcal{F}_k} & 0\\\\\\\\\\n 0 & B_{\\\\mathcal{A}_k} & 0 & 0\\n\\\\end{pmatrix}\\n\\\\begin{pmatrix}\\n U^k_{\\\\mathcal{F}_k}\\\\\\\\ U^k_{\\\\mathcal{A}_k}\\\\\\\\ \\\\Lambda^k_{\\\\mathcal{F}_k}\\\\\\\\ \\\\Lambda^k_{\\\\mathcal{A}_k}\\n\\\\end{pmatrix}\\n=\\n\\\\begin{pmatrix}\\n F_{\\\\mathcal{F}_k}\\\\\\\\ F_{\\\\mathcal{A}_k}\\\\\\\\ 0\\\\\\\\ G_{\\\\mathcal{A}_k}\\n\\\\end{pmatrix}.\\n\\\\end{equation*}\\n\\n These are the equations outlined above in the description of the basic algorithm.\\nWe could even drive this a bit further. It's easy to see that we can eliminate the third row and the third column because it implies \\\\(\\\\Lambda_{\\\\mathcal{F}_k} = 0\\\\):              \\n\\\\begin{equation*}\\n\\\\begin{pmatrix}\\n A_{\\\\mathcal{F}_k\\\\mathcal{F}_k} & A_{\\\\mathcal{F}_k\\\\mathcal{A}_k} & 0\\\\\\\\\\n A_{\\\\mathcal{A}_k\\\\mathcal{F}_k} & A_{\\\\mathcal{A}_k\\\\mathcal{A}_k} & B_{\\\\mathcal{A}_k}\\\\\\\\\\n 0 & B_{\\\\mathcal{A}_k} & 0\\n\\\\end{pmatrix}\\n\\\\begin{pmatrix}\\n U^k_{\\\\mathcal{F}_k}\\\\\\\\ U^k_{\\\\mathcal{A}_k}\\\\\\\\ \\\\Lambda^k_{\\\\mathcal{A}_k}\\n\\\\end{pmatrix}\\n=\\n\\\\begin{pmatrix}\\n F_{\\\\mathcal{F}_k}\\\\\\\\ F_{\\\\mathcal{A}_k}\\\\\\\\ G_{\\\\mathcal{A}_k}\\n\\\\end{pmatrix}.\\n\\\\end{equation*}\\n\\n This shows that one in fact only needs to solve for the Lagrange multipliers located on the active set. By considering the second row one would then recover the full Lagrange multiplier vector through   \\n\\\\begin{equation*}\\n \\\\Lambda^k_S = B^{-1}\\\\left(f_{\\\\mathcal{S}} - A_{\\\\mathcal{S}}U^k_{\\\\mathcal{S}}\\\\right).\\n\\\\end{equation*}\\n\\n Because of the third row and the fact that \\\\(B_{\\\\mathcal{A}_k}\\\\) is a diagonal matrix we are able to calculate \\\\(U^k_{\\\\mathcal{A}_k}=B^{-1}_{\\\\mathcal{A}_k}G_{\\\\mathcal{A}_k}\\\\) directly. We can therefore also write the linear system as follows:               \\n\\\\begin{equation*}\\n\\\\begin{pmatrix}\\n A_{\\\\mathcal{F}_k\\\\mathcal{F}_k} & 0\\\\\\\\\\n 0 & Id_{\\\\mathcal{A}_k} \\\\\\\\\\n\\\\end{pmatrix}\\n\\\\begin{pmatrix}\\n U^k_{\\\\mathcal{F}_k}\\\\\\\\ U^k_{\\\\mathcal{A}_k}\\n\\\\end{pmatrix}\\n=\\n\\\\begin{pmatrix}\\n F_{\\\\mathcal{F}_k} - A_{\\\\mathcal{F}_k\\\\mathcal{A}_k}B^{-1}_{\\\\mathcal{A}_k}G_{\\\\mathcal{A}_k}\\n \\\\\\\\\\n B_{\\\\mathcal{A}_k}^{-1}G_{\\\\mathcal{A}_k}\\n\\\\end{pmatrix}.\\n\\\\end{equation*}\\n\\n Fortunately, this form is easy to arrive at: we simply build the usual Laplace linear system             \\n\\\\begin{equation*}\\n\\\\begin{pmatrix}\\n A_{\\\\mathcal{F}_k\\\\mathcal{F}_k} & A_{\\\\mathcal{F}_k\\\\mathcal{A}_k} \\\\\\\\\\n A_{\\\\mathcal{A}_k\\\\mathcal{F}_k} & A_{\\\\mathcal{A}_k\\\\mathcal{A}_k}\\n\\\\end{pmatrix}\\n\\\\begin{pmatrix}\\n U^k_{\\\\mathcal{F}_k}\\\\\\\\ U^k_{\\\\mathcal{A}_k}\\n\\\\end{pmatrix}\\n=\\n\\\\begin{pmatrix}\\n F_{\\\\mathcal{F}_k}\\\\\\\\ F_{\\\\mathcal{A}_k}\\n\\\\end{pmatrix},\\n\\\\end{equation*}\\n\\n and then let the AffineConstraints class eliminate all constrained degrees of freedom, namely \\\\(U^k_{\\\\mathcal{A}_k}=B^{-1}_{\\\\mathcal{A}_k}G_{\\\\mathcal{A}_k}\\\\), in the same way as if the dofs in \\\\(\\\\mathcal{A}_k\\\\) were Dirichlet data. The result linear system (the second to last one above) is symmetric and positive definite and we solve it with a CG-method and the AMG preconditioner from Trilinos.\\nImplementation\\nThis tutorial is quite similar to step-4. The general structure of the program follows step-4 with minor differences:\\nWe need two new methods, assemble_mass_matrix_diagonal and update_solution_and_constraints.\\nWe need new member variables that denote the constraints we have here.\\nWe change the preconditioner for the solver.\\n\\nYou may want to read up on step-4 if you want to understand the current program.\\n The commented program\\n Include files\\nAs usual, at the beginning we include all the header files we need in here. With the exception of the various files that provide interfaces to the Trilinos library, there are no surprises:\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/base/index_set.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/solver_cg.h>\\n\\u00a0 #include <deal.II/lac/trilinos_sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/trilinos_vector.h>\\n\\u00a0 #include <deal.II/lac/trilinos_precondition.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 \\n\\u00a0 #include <fstream>\\n\\u00a0 #include <iostream>\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 namespace Step41\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n The ObstacleProblem class template\\nThis class supplies all function and variables needed to describe the obstacle problem. It is close to what we had to do in step-4, and so relatively simple. The only real new components are the update_solution_and_constraints function that computes the active set and a number of variables that are necessary to describe the original (unconstrained) form of the linear system (complete_system_matrix and complete_system_rhs) as well as the active set itself and the diagonal of the mass matrix \\\\(B\\\\) used in scaling Lagrange multipliers in the active set formulation. The rest is as in step-4:\\n\\u00a0   template <int dim>\\n\\u00a0   class ObstacleProblem\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     ObstacleProblem();\\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void make_grid();\\n\\u00a0     void setup_system();\\n\\u00a0     void assemble_system();\\n\\u00a0     void\\n\\u00a0     assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &mass_matrix);\\n\\u00a0     void update_solution_and_constraints();\\n\\u00a0     void solve();\\n\\u00a0     void output_results(const unsigned int iteration) const;\\n\\u00a0 \\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0     const FE_Q<dim>           fe;\\n\\u00a0     DoFHandler<dim>           dof_handler;\\n\\u00a0     AffineConstraints<double> constraints;\\n\\u00a0     IndexSet                  active_set;\\n\\u00a0 \\n\\u00a0     TrilinosWrappers::SparseMatrix system_matrix;\\n\\u00a0     TrilinosWrappers::SparseMatrix complete_system_matrix;\\n\\u00a0 \\n\\u00a0     TrilinosWrappers::MPI::Vector solution;\\n\\u00a0     TrilinosWrappers::MPI::Vector system_rhs;\\n\\u00a0     TrilinosWrappers::MPI::Vector complete_system_rhs;\\n\\u00a0     TrilinosWrappers::MPI::Vector diagonal_of_mass_matrix;\\n\\u00a0     TrilinosWrappers::MPI::Vector contact_force;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nDoFHandlerDefinition dof_handler.h:317\\nFE_QDefinition fe_q.h:554\\nIndexSetDefinition index_set.h:70\\nTriangulationDefinition tria.h:1323\\nTrilinosWrappers::MPI::VectorDefinition trilinos_vector.h:405\\nTrilinosWrappers::SparseMatrixDefinition trilinos_sparse_matrix.h:550\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\n Right hand side, boundary values, and the obstacle\\nIn the following, we define classes that describe the right hand side function, the Dirichlet boundary values, and the height of the obstacle as a function of \\\\(\\\\mathbf x\\\\). In all three cases, we derive these classes from Function<dim>, although in the case of RightHandSide and Obstacle this is more out of convention than necessity since we never pass such objects to the library. In any case, the definition of the right hand side and boundary values classes is obvious given our choice of \\\\(f=-10\\\\), \\\\(u|_{\\\\partial\\\\Omega}=0\\\\):\\n\\u00a0   template <int dim>\\n\\u00a0   class RightHandSide : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     virtual double value(const Point<dim> & /*p*/,\\n\\u00a0                          const unsigned int component = 0) const override\\n\\u00a0     {\\n\\u00a0       (void)component;\\n\\u00a0       AssertIndexRange(component, 1);\\n\\u00a0 \\n\\u00a0       return -10;\\n\\u00a0     }\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   class BoundaryValues : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     virtual double value(const Point<dim> & /*p*/,\\n\\u00a0                          const unsigned int component = 0) const override\\n\\u00a0     {\\n\\u00a0       (void)component;\\n\\u00a0       AssertIndexRange(component, 1);\\n\\u00a0 \\n\\u00a0       return 0;\\n\\u00a0     }\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFunctionDefinition function.h:152\\nFunction::valuevirtual RangeNumberType value(const Point< dim > &p, const unsigned int component=0) const\\nPointDefinition point.h:111\\nAssertIndexRange#define AssertIndexRange(index, range)Definition exceptions.h:2053\\nWe describe the obstacle function by a cascaded barrier (think: stair steps):\\n\\u00a0   template <int dim>\\n\\u00a0   class Obstacle : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component = 0) const override\\n\\u00a0     {\\n\\u00a0       (void)component;\\n\\u00a0       Assert(component == 0, ExcIndexRange(component, 0, 1));\\n\\u00a0 \\n\\u00a0       if (p[0] < -0.5)\\n\\u00a0         return -0.2;\\n\\u00a0       else if (p[0] >= -0.5 && p[0] < 0.0)\\n\\u00a0         return -0.4;\\n\\u00a0       else if (p[0] >= 0.0 && p[0] < 0.5)\\n\\u00a0         return -0.6;\\n\\u00a0       else\\n\\u00a0         return -0.8;\\n\\u00a0     }\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\nStandardExceptions::ExcIndexRangestatic ::ExceptionBase & ExcIndexRange(std::size_t arg1, std::size_t arg2, std::size_t arg3)\\n Implementation of the ObstacleProblem class\\n ObstacleProblem::ObstacleProblem\\nTo everyone who has taken a look at the first few tutorial programs, the constructor is completely obvious:\\n\\u00a0   template <int dim>\\n\\u00a0   ObstacleProblem<dim>::ObstacleProblem()\\n\\u00a0     : fe(1)\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n ObstacleProblem::make_grid\\nWe solve our obstacle problem on the square \\\\([-1,1]\\\\times [-1,1]\\\\) in 2d. This function therefore just sets up one of the simplest possible meshes.\\n\\u00a0   template <int dim>\\n\\u00a0   void ObstacleProblem<dim>::make_grid()\\n\\u00a0   {\\n\\u00a0     GridGenerator::hyper_cube(triangulation, -1, 1);\\n\\u00a0     triangulation.refine_global(7);\\n\\u00a0 \\n\\u00a0     std::cout << \\\"Number of active cells: \\\" << triangulation.n_active_cells()\\n\\u00a0               << std::endl\\n\\u00a0               << \\\"Total number of cells: \\\" << triangulation.n_cells()\\n\\u00a0               << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nTriangulation::n_cellsunsigned int n_cells() const\\nGridGenerator::hyper_cubevoid hyper_cube(Triangulation< dim, spacedim > &tria, const double left=0., const double right=1., const bool colorize=false)\\n ObstacleProblem::setup_system\\nIn this first function of note, we set up the degrees of freedom handler, resize vectors and matrices, and deal with the constraints. Initially, the constraints are, of course, only given by boundary values, so we interpolate them towards the top of the function.\\n\\u00a0   template <int dim>\\n\\u00a0   void ObstacleProblem<dim>::setup_system()\\n\\u00a0   {\\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0     active_set.set_size(dof_handler.n_dofs());\\n\\u00a0 \\n\\u00a0     std::cout << \\\"Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n\\u00a0               << std::endl\\n\\u00a0               << std::endl;\\n\\u00a0 \\n\\u00a0     VectorTools::interpolate_boundary_values(dof_handler,\\n\\u00a0                                              0,\\n\\u00a0                                              BoundaryValues<dim>(),\\n\\u00a0                                              constraints);\\n\\u00a0     constraints.close();\\n\\u00a0 \\n\\u00a0     DynamicSparsityPattern dsp(dof_handler.n_dofs());\\n\\u00a0     DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false);\\n\\u00a0 \\n\\u00a0     system_matrix.reinit(dsp);\\n\\u00a0     complete_system_matrix.reinit(dsp);\\n\\u00a0 \\n\\u00a0     IndexSet solution_index_set = dof_handler.locally_owned_dofs();\\n\\u00a0     solution.reinit(solution_index_set, MPI_COMM_WORLD);\\n\\u00a0     system_rhs.reinit(solution_index_set, MPI_COMM_WORLD);\\n\\u00a0     complete_system_rhs.reinit(solution_index_set, MPI_COMM_WORLD);\\n\\u00a0     contact_force.reinit(solution_index_set, MPI_COMM_WORLD);\\n\\u00a0 \\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nVectorTools::interpolate_boundary_valuesvoid interpolate_boundary_values(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const std::map< types::boundary_id, const Function< spacedim, number > * > &function_map, std::map< types::global_dof_index, number > &boundary_values, const ComponentMask &component_mask={})\\nThe only other thing to do here is to compute the factors in the \\\\(B\\\\) matrix which is used to scale the residual. As discussed in the introduction, we'll use a little trick to make this mass matrix diagonal, and in the following then first compute all of this as a matrix and then extract the diagonal elements for later use:\\n\\u00a0     TrilinosWrappers::SparseMatrix mass_matrix;\\n\\u00a0     mass_matrix.reinit(dsp);\\n\\u00a0     assemble_mass_matrix_diagonal(mass_matrix);\\n\\u00a0     diagonal_of_mass_matrix.reinit(solution_index_set);\\n\\u00a0     for (unsigned int j = 0; j < solution.size(); ++j)\\n\\u00a0       diagonal_of_mass_matrix(j) = mass_matrix.diag_element(j);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n ObstacleProblem::assemble_system\\nThis function at once assembles the system matrix and right-hand-side and applied the constraints (both due to the active set as well as from boundary values) to our system. Otherwise, it is functionally equivalent to the corresponding function in, for example, step-4.\\n\\u00a0   template <int dim>\\n\\u00a0   void ObstacleProblem<dim>::assemble_system()\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"   Assembling system...\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     system_matrix = 0;\\n\\u00a0     system_rhs    = 0;\\n\\u00a0 \\n\\u00a0     const QGauss<dim>  quadrature_formula(fe.degree + 1);\\n\\u00a0     RightHandSide<dim> right_hand_side;\\n\\u00a0 \\n\\u00a0     FEValues<dim> fe_values(fe,\\n\\u00a0                             quadrature_formula,\\n\\u00a0                             update_values | update_gradients |\\n\\u00a0                               update_quadrature_points | update_JxW_values);\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n\\u00a0     const unsigned int n_q_points    = quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0     Vector<double>     cell_rhs(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0         cell_matrix = 0;\\n\\u00a0         cell_rhs    = 0;\\n\\u00a0 \\n\\u00a0         for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n\\u00a0           for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0             {\\n\\u00a0               for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0                 cell_matrix(i, j) +=\\n\\u00a0                   (fe_values.shape_grad(i, q_point) *\\n\\u00a0                    fe_values.shape_grad(j, q_point) * fe_values.JxW(q_point));\\n\\u00a0 \\n\\u00a0               cell_rhs(i) +=\\n\\u00a0                 (fe_values.shape_value(i, q_point) *\\n\\u00a0                  right_hand_side.value(fe_values.quadrature_point(q_point)) *\\n\\u00a0                  fe_values.JxW(q_point));\\n\\u00a0             }\\n\\u00a0 \\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0 \\n\\u00a0         constraints.distribute_local_to_global(cell_matrix,\\n\\u00a0                                                cell_rhs,\\n\\u00a0                                                local_dof_indices,\\n\\u00a0                                                system_matrix,\\n\\u00a0                                                system_rhs,\\n\\u00a0                                                true);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFEValuesDefinition fe_values.h:63\\nFullMatrixDefinition full_matrix.h:79\\nQGaussDefinition quadrature_lib.h:40\\nVectorDefinition vector.h:120\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\n ObstacleProblem::assemble_mass_matrix_diagonal\\nThe next function is used in the computation of the diagonal mass matrix \\\\(B\\\\) used to scale variables in the active set method. As discussed in the introduction, we get the mass matrix to be diagonal by choosing the trapezoidal rule for quadrature. Doing so we don't really need the triple loop over quadrature points, indices \\\\(i\\\\) and indices \\\\(j\\\\) any more and can, instead, just use a double loop. The rest of the function is obvious given what we have discussed in many of the previous tutorial programs.\\nNote that at the time this function is called, the constraints object only contains boundary value constraints; we therefore do not have to pay attention in the last copy-local-to-global step to preserve the values of matrix entries that may later on be constrained by the active set.\\nNote also that the trick with the trapezoidal rule only works if we have in fact \\\\(Q_1\\\\) elements. For higher order elements, one would need to use a quadrature formula that has quadrature points at all the support points of the finite element. Constructing such a quadrature formula isn't really difficult, but not the point here, and so we simply assert at the top of the function that our implicit assumption about the finite element is in fact satisfied.\\n\\u00a0   template <int dim>\\n\\u00a0   void ObstacleProblem<dim>::assemble_mass_matrix_diagonal(\\n\\u00a0     TrilinosWrappers::SparseMatrix &mass_matrix)\\n\\u00a0   {\\n\\u00a0     Assert(fe.degree == 1, ExcNotImplemented());\\n\\u00a0 \\n\\u00a0     const QTrapezoid<dim> quadrature_formula;\\n\\u00a0     FEValues<dim>         fe_values(fe,\\n\\u00a0                             quadrature_formula,\\n\\u00a0                             update_values | update_JxW_values);\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n\\u00a0     const unsigned int n_q_points    = quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0         cell_matrix = 0;\\n\\u00a0 \\n\\u00a0         for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n\\u00a0           for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0             cell_matrix(i, i) +=\\n\\u00a0               (fe_values.shape_value(i, q_point) *\\n\\u00a0                fe_values.shape_value(i, q_point) * fe_values.JxW(q_point));\\n\\u00a0 \\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0 \\n\\u00a0         constraints.distribute_local_to_global(cell_matrix,\\n\\u00a0                                                local_dof_indices,\\n\\u00a0                                                mass_matrix);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nQTrapezoidDefinition quadrature_lib.h:191\\n ObstacleProblem::update_solution_and_constraints\\nIn a sense, this is the central function of this program. It updates the active set of constrained degrees of freedom as discussed in the introduction and computes an AffineConstraints object from it that can then be used to eliminate constrained degrees of freedom from the solution of the next iteration. At the same time we set the constrained degrees of freedom of the solution to the correct value, namely the height of the obstacle.\\nFundamentally, the function is rather simple: We have to loop over all degrees of freedom and check the sign of the function  \\\\(\\\\Lambda^k_i +\\n   c([BU^k]_i - G_i) = \\\\Lambda^k_i + cB_i(U^k_i - [g_h]_i)\\\\) because in our case \\\\(G_i = B_i[g_h]_i\\\\). To this end, we use the formula given in the introduction by which we can compute the Lagrange multiplier as the residual of the original linear system (given via the variables complete_system_matrix and complete_system_rhs. At the top of this function, we compute this residual using a function that is part of the matrix classes.\\n\\u00a0   template <int dim>\\n\\u00a0   void ObstacleProblem<dim>::update_solution_and_constraints()\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"   Updating active set...\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     const double penalty_parameter = 100.0;\\n\\u00a0 \\n\\u00a0     TrilinosWrappers::MPI::Vector lambda(\\n\\u00a0       complete_index_set(dof_handler.n_dofs()));\\n\\u00a0     complete_system_matrix.residual(lambda, solution, complete_system_rhs);\\n\\u00a0 \\ncomplete_index_setIndexSet complete_index_set(const IndexSet::size_type N)Definition index_set.h:1204\\ncompute contact_force[i] = - lambda[i] * diagonal_of_mass_matrix[i]\\n\\u00a0     contact_force = lambda;\\n\\u00a0     contact_force.scale(diagonal_of_mass_matrix);\\n\\u00a0     contact_force *= -1;\\n\\u00a0 \\nThe next step is to reset the active set and constraints objects and to start the loop over all degrees of freedom. This is made slightly more complicated by the fact that we can't just loop over all elements of the solution vector since there is no way for us then to find out what location a DoF is associated with; however, we need this location to test whether the displacement of a DoF is larger or smaller than the height of the obstacle at this location.\\nWe work around this by looping over all cells and DoFs defined on each of these cells. We use here that the displacement is described using a \\\\(Q_1\\\\) function for which degrees of freedom are always located on the vertices of the cell; thus, we can get the index of each degree of freedom and its location by asking the vertex for this information. On the other hand, this clearly wouldn't work for higher order elements, and so we add an assertion that makes sure that we only deal with elements for which all degrees of freedom are located in vertices to avoid tripping ourselves with non-functional code in case someone wants to play with increasing the polynomial degree of the solution.\\nThe price to pay for having to loop over cells rather than DoFs is that we may encounter some degrees of freedom more than once, namely each time we visit one of the cells adjacent to a given vertex. We will therefore have to keep track which vertices we have already touched and which we haven't so far. We do so by using an array of flags dof_touched:\\n\\u00a0     constraints.clear();\\n\\u00a0     active_set.clear();\\n\\u00a0 \\n\\u00a0     const Obstacle<dim> obstacle;\\n\\u00a0     std::vector<bool>   dof_touched(dof_handler.n_dofs(), false);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       for (const auto v : cell->vertex_indices())\\n\\u00a0         {\\n\\u00a0           Assert(dof_handler.get_fe().n_dofs_per_cell() == cell->n_vertices(),\\n\\u00a0                  ExcNotImplemented());\\n\\u00a0 \\n\\u00a0           const unsigned int dof_index = cell->vertex_dof_index(v, 0);\\n\\u00a0 \\n\\u00a0           if (dof_touched[dof_index] == false)\\n\\u00a0             dof_touched[dof_index] = true;\\n\\u00a0           else\\n\\u00a0             continue;\\n\\u00a0 \\nvertex_indicesunsigned int vertex_indices[2]Definition grid_tools_topology.cc:947\\nNow that we know that we haven't touched this DoF yet, let's get the value of the displacement function there as well as the value of the obstacle function and use this to decide whether the current DoF belongs to the active set. For that we use the function given above and in the introduction.\\nIf we decide that the DoF should be part of the active set, we add its index to the active set, introduce an inhomogeneous equality constraint in the AffineConstraints object, and reset the solution value to the height of the obstacle. Finally, the residual of the non-contact part of the system serves as an additional control (the residual equals the remaining, unaccounted forces, and should be zero outside the contact zone), so we zero out the components of the residual vector (i.e., the Lagrange multiplier lambda) that correspond to the area where the body is in contact; at the end of the loop over all cells, the residual will therefore only consist of the residual in the non-contact zone. We output the norm of this residual along with the size of the active set after the loop.\\n\\u00a0           const double obstacle_value = obstacle.value(cell->vertex(v));\\n\\u00a0           const double solution_value = solution(dof_index);\\n\\u00a0 \\n\\u00a0           if (lambda(dof_index) + penalty_parameter *\\n\\u00a0                                     diagonal_of_mass_matrix(dof_index) *\\n\\u00a0                                     (solution_value - obstacle_value) <\\n\\u00a0               0)\\n\\u00a0             {\\n\\u00a0               active_set.add_index(dof_index);\\n\\u00a0               constraints.add_constraint(dof_index, {}, obstacle_value);\\n\\u00a0 \\n\\u00a0               solution(dof_index) = obstacle_value;\\n\\u00a0 \\n\\u00a0               lambda(dof_index) = 0;\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0     std::cout << \\\"      Size of active set: \\\" << active_set.n_elements()\\n\\u00a0               << std::endl;\\n\\u00a0 \\n\\u00a0     std::cout << \\\"   Residual of the non-contact part of the system: \\\"\\n\\u00a0               << lambda.l2_norm() << std::endl;\\n\\u00a0 \\nDifferentiation::SD::OptimizerType::lambda@ lambda\\nIn a final step, we add to the set of constraints on DoFs we have so far from the active set those that result from Dirichlet boundary values, and close the constraints object:\\n\\u00a0     VectorTools::interpolate_boundary_values(dof_handler,\\n\\u00a0                                              0,\\n\\u00a0                                              BoundaryValues<dim>(),\\n\\u00a0                                              constraints);\\n\\u00a0     constraints.close();\\n\\u00a0   }\\n\\u00a0 \\n ObstacleProblem::solve\\nThere is nothing to say really about the solve function. In the context of a Newton method, we are not typically interested in very high accuracy (why ask for a highly accurate solution of a linear problem that we know only gives us an approximation of the solution of the nonlinear problem), and so we use the ReductionControl class that stops iterations when either an absolute tolerance is reached (for which we choose \\\\(10^{-12}\\\\)) or when the residual is reduced by a certain factor (here, \\\\(10^{-3}\\\\)).\\n\\u00a0   template <int dim>\\n\\u00a0   void ObstacleProblem<dim>::solve()\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"   Solving system...\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     ReductionControl                        reduction_control(100, 1e-12, 1e-3);\\n\\u00a0     SolverCG<TrilinosWrappers::MPI::Vector> solver(reduction_control);\\n\\u00a0     TrilinosWrappers::PreconditionAMG       precondition;\\n\\u00a0     precondition.initialize(system_matrix);\\n\\u00a0 \\n\\u00a0     solver.solve(system_matrix, solution, system_rhs, precondition);\\n\\u00a0     constraints.distribute(solution);\\n\\u00a0 \\n\\u00a0     std::cout << \\\"      Error: \\\" << reduction_control.initial_value() << \\\" -> \\\"\\n\\u00a0               << reduction_control.last_value() << \\\" in \\\"\\n\\u00a0               << reduction_control.last_step() << \\\" CG iterations.\\\"\\n\\u00a0               << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nReductionControlDefinition solver_control.h:424\\nSolverCGDefinition solver_cg.h:179\\nTrilinosWrappers::PreconditionAMGDefinition trilinos_precondition.h:1321\\nTrilinosWrappers::PreconditionAMG::initializevoid initialize(const SparseMatrix &matrix, const AdditionalData &additional_data=AdditionalData())Definition trilinos_precondition_ml.cc:221\\n ObstacleProblem::output_results\\nWe use the vtk-format for the output. The file contains the displacement and a numerical representation of the active set.\\n\\u00a0   template <int dim>\\n\\u00a0   void ObstacleProblem<dim>::output_results(const unsigned int iteration) const\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"   Writing graphical output...\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     TrilinosWrappers::MPI::Vector active_set_vector(\\n\\u00a0       dof_handler.locally_owned_dofs(), MPI_COMM_WORLD);\\n\\u00a0     for (const auto index : active_set)\\n\\u00a0       active_set_vector[index] = 1.;\\n\\u00a0 \\n\\u00a0     DataOut<dim> data_out;\\n\\u00a0 \\n\\u00a0     data_out.attach_dof_handler(dof_handler);\\n\\u00a0     data_out.add_data_vector(solution, \\\"displacement\\\");\\n\\u00a0     data_out.add_data_vector(active_set_vector, \\\"active_set\\\");\\n\\u00a0     data_out.add_data_vector(contact_force, \\\"lambda\\\");\\n\\u00a0 \\n\\u00a0     data_out.build_patches();\\n\\u00a0 \\n\\u00a0     std::ofstream output_vtk(\\\"output_\\\" +\\n\\u00a0                              Utilities::int_to_string(iteration, 3) + \\\".vtk\\\");\\n\\u00a0     data_out.write_vtk(output_vtk);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nUtilities::int_to_stringstd::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)Definition utilities.cc:470\\n ObstacleProblem::run\\nThis is the function which has the top-level control over everything. It is not very long, and in fact rather straightforward: in every iteration of the active set method, we assemble the linear system, solve it, update the active set and project the solution back to the feasible set, and then output the results. The iteration is terminated whenever the active set has not changed in the previous iteration.\\nThe only trickier part is that we have to save the linear system (i.e., the matrix and right hand side) after assembling it in the first iteration. The reason is that this is the only step where we can access the linear system as built without any of the contact constraints active. We need this to compute the residual of the solution at other iterations, but in other iterations that linear system we form has the rows and columns that correspond to constrained degrees of freedom eliminated, and so we can no longer access the full residual of the original equation.\\n\\u00a0   template <int dim>\\n\\u00a0   void ObstacleProblem<dim>::run()\\n\\u00a0   {\\n\\u00a0     make_grid();\\n\\u00a0     setup_system();\\n\\u00a0 \\n\\u00a0     IndexSet active_set_old(active_set);\\n\\u00a0     for (unsigned int iteration = 0; iteration <= solution.size(); ++iteration)\\n\\u00a0       {\\n\\u00a0         std::cout << \\\"Newton iteration \\\" << iteration << std::endl;\\n\\u00a0 \\n\\u00a0         assemble_system();\\n\\u00a0 \\n\\u00a0         if (iteration == 0)\\n\\u00a0           {\\n\\u00a0             complete_system_matrix.copy_from(system_matrix);\\n\\u00a0             complete_system_rhs = system_rhs;\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         solve();\\n\\u00a0         update_solution_and_constraints();\\n\\u00a0         output_results(iteration);\\n\\u00a0 \\n\\u00a0         if (active_set == active_set_old)\\n\\u00a0           break;\\n\\u00a0 \\n\\u00a0         active_set_old = active_set;\\n\\u00a0 \\n\\u00a0         std::cout << std::endl;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 } // namespace Step41\\n\\u00a0 \\n\\u00a0 \\n The main function\\nAnd this is the main function. It follows the pattern of all other main functions. The call to initialize MPI exists because the Trilinos library upon which we build our linear solvers in this program requires it.\\n\\u00a0 int main(int argc, char *argv[])\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       using namespace dealii;\\n\\u00a0       using namespace Step41;\\n\\u00a0 \\n\\u00a0       Utilities::MPI::MPI_InitFinalize mpi_initialization(\\n\\u00a0         argc, argv, numbers::invalid_unsigned_int);\\n\\u00a0 \\nUtilities::MPI::MPI_InitFinalizeDefinition mpi.h:1081\\nnumbers::invalid_unsigned_intstatic const unsigned int invalid_unsigned_intDefinition types.h:220\\nThis program can only be run in serial. Otherwise, throw an exception.\\n\\u00a0       AssertThrow(Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) == 1,\\n\\u00a0                   ExcMessage(\\n\\u00a0                     \\\"This program can only be run in serial, use ./step-41\\\"));\\n\\u00a0 \\n\\u00a0       ObstacleProblem<2> obstacle_problem;\\n\\u00a0       obstacle_problem.run();\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0 \\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\nAssertThrow#define AssertThrow(cond, exc)Definition exceptions.h:1739\\nUtilities::MPI::n_mpi_processesunsigned int n_mpi_processes(const MPI_Comm mpi_communicator)Definition mpi.cc:92\\n Results\\nRunning the program produces output like this: Number of active cells: 16384\\nTotal number of cells: 21845\\nNumber of degrees of freedom: 16641\\n \\nNewton iteration 0\\n   Assembling system...\\n   Solving system...\\n      Error: 0.310059 -> 5.16619e-05 in 5 CG iterations.\\n   Updating active set...\\n      Size of active set: 13164\\n   Residual of the non-contact part of the system: 1.61863e-05\\n   Writing graphical output...\\n \\nNewton iteration 1\\n   Assembling system...\\n   Solving system...\\n      Error: 1.11987 -> 0.00109377 in 6 CG iterations.\\n   Updating active set...\\n      Size of active set: 12363\\n   Residual of the non-contact part of the system: 3.9373\\n   Writing graphical output...\\n \\n...\\n \\nNewton iteration 17\\n   Assembling system...\\n   Solving system...\\n      Error: 0.00713308 -> 2.29249e-06 in 4 CG iterations.\\n   Updating active set...\\n      Size of active set: 5399\\n   Residual of the non-contact part of the system: 0.000957525\\n   Writing graphical output...\\n \\nNewton iteration 18\\n   Assembling system...\\n   Solving system...\\n      Error: 0.000957525 -> 2.8033e-07 in 4 CG iterations.\\n   Updating active set...\\n      Size of active set: 5399\\n   Residual of the non-contact part of the system: 2.8033e-07\\n   Writing graphical output...\\nThe iterations end once the active set doesn't change any more (it has 5,399 constrained degrees of freedom at that point). The algebraic precondition is apparently working nicely since we only need 4-6 CG iterations to solve the linear system (although this also has a lot to do with the fact that we are not asking for very high accuracy of the linear solver).\\nMore revealing is to look at a sequence of graphical output files (every third step is shown, with the number of the iteration in the leftmost column):\\n\\n\\n0 \\u00a0     \\n\\n3 \\u00a0     \\n\\n6 \\u00a0     \\n\\n9 \\u00a0     \\n\\n12 \\u00a0     \\n\\n15 \\u00a0     \\n\\n18 \\u00a0     \\n\\nThe pictures show that in the first step, the solution (which has been computed without any of the constraints active) bends through so much that pretty much every interior point has to be bounced back to the stairstep function, producing a discontinuous solution. Over the course of the active set iterations, this unphysical membrane shape is smoothed out, the contact with the lower-most stair step disappears, and the solution stabilizes.\\nIn addition to this, the program also outputs the values of the Lagrange multipliers. Remember that these are the contact forces and so should only be positive on the contact set, and zero outside. If, on the other hand, a Lagrange multiplier is negative in the active set, then this degree of freedom must be removed from the active set. The following pictures show the multipliers in iterations 1, 9 and 18, where we use red and browns to indicate positive values, and blue for negative values.\\n\\n\\n   \\n\\nIteration 1  Iteration 9  Iteration 18   \\n\\nIt is easy to see that the positive values converge nicely to moderate values in the interior of the contact set and large upward forces at the edges of the steps, as one would expect (to support the large curvature of the membrane there); at the fringes of the active set, multipliers are initially negative, causing the set to shrink until, in iteration 18, there are no more negative multipliers and the algorithm has converged.\\n Possibilities for extensions\\nAs with any of the programs of this tutorial, there are a number of obvious possibilities for extensions and experiments. The first one is clear: introduce adaptivity. Contact problems are prime candidates for adaptive meshes because the solution has lines along which it is less regular (the places where contact is established between membrane and obstacle) and other areas where the solution is very smooth (or, in the present context, constant wherever it is in contact with the obstacle). Adding this to the current program should not pose too many difficulties, but it is not trivial to find a good error estimator for that purpose.\\nA more challenging task would be an extension to 3d. The problem here is not so much to simply make everything run in 3d. Rather, it is that when a 3d body is deformed and gets into contact with an obstacle, then the obstacle does not act as a constraining body force within the domain as is the case here. Rather, the contact force only acts on the boundary of the object. The inequality then is not in the differential equation but in fact in the (Neumann-type) boundary conditions, though this leads to a similar kind of variational inequality. Mathematically, this means that the Lagrange multiplier only lives on the surface, though it can of course be extended by zero into the domain if that is convenient. As in the current program, one does not need to form and store this Lagrange multiplier explicitly.\\nA further interesting problem for the 3d case is to consider contact problems with friction. In almost every mechanical process friction has a big influence. For the modelling we have to take into account tangential stresses at the contact surface. Also we have to observe that friction adds another nonlinearity to our problem.\\nAnother nontrivial modification is to implement a more complex constitutive law like nonlinear elasticity or elasto-plastic material behavior. The difficulty here is to handle the additional nonlinearity arising through the nonlinear constitutive law.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2011 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Authors: Joerg Frohne, Texas A&M University and\\n *                        University of Siegen, 2011, 2012\\n *          Wolfgang Bangerth, Texas A&M University, 2012\\n */\\n \\n \\n \\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/function.h>\\n#include <deal.II/base/index_set.h>\\n \\n#include <deal.II/lac/affine_constraints.h>\\n#include <deal.II/lac/vector.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/trilinos_sparse_matrix.h>\\n#include <deal.II/lac/trilinos_vector.h>\\n#include <deal.II/lac/trilinos_precondition.h>\\n \\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_generator.h>\\n \\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_values.h>\\n \\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/numerics/vector_tools.h>\\n#include <deal.II/numerics/data_out.h>\\n \\n#include <fstream>\\n#include <iostream>\\n \\n \\nnamespace Step41\\n{\\n using namespace dealii;\\n \\n \\n template <int dim>\\n class ObstacleProblem\\n  {\\n public:\\n    ObstacleProblem();\\n void run();\\n \\n private:\\n void make_grid();\\n void setup_system();\\n void assemble_system();\\n void\\n    assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &mass_matrix);\\n void update_solution_and_constraints();\\n void solve();\\n void output_results(const unsigned int iteration) const;\\n \\n Triangulation<dim> triangulation;\\n const FE_Q<dim>           fe;\\n DoFHandler<dim>           dof_handler;\\n AffineConstraints<double> constraints;\\n IndexSet                  active_set;\\n \\n TrilinosWrappers::SparseMatrix system_matrix;\\n TrilinosWrappers::SparseMatrix complete_system_matrix;\\n \\n TrilinosWrappers::MPI::Vector solution;\\n TrilinosWrappers::MPI::Vector system_rhs;\\n TrilinosWrappers::MPI::Vector complete_system_rhs;\\n TrilinosWrappers::MPI::Vector diagonal_of_mass_matrix;\\n TrilinosWrappers::MPI::Vector contact_force;\\n  };\\n \\n \\n \\n template <int dim>\\n class RightHandSide : public Function<dim>\\n  {\\n public:\\n virtual double value(const Point<dim> & /*p*/,\\n const unsigned int component = 0) const override\\n {\\n      (void)component;\\n AssertIndexRange(component, 1);\\n \\n return -10;\\n    }\\n  };\\n \\n \\n \\n template <int dim>\\n class BoundaryValues : public Function<dim>\\n  {\\n public:\\n virtual double value(const Point<dim> & /*p*/,\\n const unsigned int component = 0) const override\\n {\\n      (void)component;\\n AssertIndexRange(component, 1);\\n \\n return 0;\\n    }\\n  };\\n \\n \\n \\n template <int dim>\\n class Obstacle : public Function<dim>\\n  {\\n public:\\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override\\n {\\n      (void)component;\\n Assert(component == 0, ExcIndexRange(component, 0, 1));\\n \\n if (p[0] < -0.5)\\n return -0.2;\\n else if (p[0] >= -0.5 && p[0] < 0.0)\\n return -0.4;\\n else if (p[0] >= 0.0 && p[0] < 0.5)\\n return -0.6;\\n else\\n return -0.8;\\n    }\\n  };\\n \\n \\n \\n \\n \\n \\n template <int dim>\\n  ObstacleProblem<dim>::ObstacleProblem()\\n    : fe(1)\\n    , dof_handler(triangulation)\\n  {}\\n \\n \\n \\n template <int dim>\\n void ObstacleProblem<dim>::make_grid()\\n  {\\n GridGenerator::hyper_cube(triangulation, -1, 1);\\n triangulation.refine_global(7);\\n \\n    std::cout << \\\"Number of active cells: \\\" << triangulation.n_active_cells()\\n              << std::endl\\n              << \\\"Total number of cells: \\\" << triangulation.n_cells()\\n              << std::endl;\\n  }\\n \\n \\n \\n template <int dim>\\n void ObstacleProblem<dim>::setup_system()\\n  {\\n    dof_handler.distribute_dofs(fe);\\n    active_set.set_size(dof_handler.n_dofs());\\n \\n    std::cout << \\\"Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n              << std::endl\\n              << std::endl;\\n \\n VectorTools::interpolate_boundary_values(dof_handler,\\n                                             0,\\n                                             BoundaryValues<dim>(),\\n                                             constraints);\\n    constraints.close();\\n \\n DynamicSparsityPattern dsp(dof_handler.n_dofs());\\n DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false);\\n \\n    system_matrix.reinit(dsp);\\n    complete_system_matrix.reinit(dsp);\\n \\n IndexSet solution_index_set = dof_handler.locally_owned_dofs();\\n    solution.reinit(solution_index_set, MPI_COMM_WORLD);\\n    system_rhs.reinit(solution_index_set, MPI_COMM_WORLD);\\n    complete_system_rhs.reinit(solution_index_set, MPI_COMM_WORLD);\\n    contact_force.reinit(solution_index_set, MPI_COMM_WORLD);\\n \\n TrilinosWrappers::SparseMatrix mass_matrix;\\n mass_matrix.reinit(dsp);\\n    assemble_mass_matrix_diagonal(mass_matrix);\\n    diagonal_of_mass_matrix.reinit(solution_index_set);\\n for (unsigned int j = 0; j < solution.size(); ++j)\\n      diagonal_of_mass_matrix(j) = mass_matrix.diag_element(j);\\n  }\\n \\n \\n \\n template <int dim>\\n void ObstacleProblem<dim>::assemble_system()\\n  {\\n    std::cout << \\\"   Assembling system...\\\" << std::endl;\\n \\n    system_matrix = 0;\\n    system_rhs    = 0;\\n \\n const QGauss<dim>  quadrature_formula(fe.degree + 1);\\n    RightHandSide<dim> right_hand_side;\\n \\n FEValues<dim> fe_values(fe,\\n                            quadrature_formula,\\n update_values | update_gradients |\\n update_quadrature_points | update_JxW_values);\\n \\n const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n const unsigned int n_q_points    = quadrature_formula.size();\\n \\n FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n Vector<double>     cell_rhs(dofs_per_cell);\\n \\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n        fe_values.reinit(cell);\\n cell_matrix = 0;\\n        cell_rhs    = 0;\\n \\n for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n            {\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n cell_matrix(i, j) +=\\n                  (fe_values.shape_grad(i, q_point) *\\n                   fe_values.shape_grad(j, q_point) * fe_values.JxW(q_point));\\n \\n              cell_rhs(i) +=\\n                (fe_values.shape_value(i, q_point) *\\n                 right_hand_side.value(fe_values.quadrature_point(q_point)) *\\n                 fe_values.JxW(q_point));\\n            }\\n \\n        cell->get_dof_indices(local_dof_indices);\\n \\n        constraints.distribute_local_to_global(cell_matrix,\\n                                               cell_rhs,\\n                                               local_dof_indices,\\n                                               system_matrix,\\n                                               system_rhs,\\n true);\\n      }\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void ObstacleProblem<dim>::assemble_mass_matrix_diagonal(\\n TrilinosWrappers::SparseMatrix &mass_matrix)\\n  {\\n Assert(fe.degree == 1, ExcNotImplemented());\\n \\n const QTrapezoid<dim> quadrature_formula;\\n FEValues<dim>         fe_values(fe,\\n                            quadrature_formula,\\n update_values | update_JxW_values);\\n \\n const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n const unsigned int n_q_points    = quadrature_formula.size();\\n \\n FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n        fe_values.reinit(cell);\\n cell_matrix = 0;\\n \\n for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n cell_matrix(i, i) +=\\n              (fe_values.shape_value(i, q_point) *\\n               fe_values.shape_value(i, q_point) * fe_values.JxW(q_point));\\n \\n        cell->get_dof_indices(local_dof_indices);\\n \\n        constraints.distribute_local_to_global(cell_matrix,\\n                                               local_dof_indices,\\n                                               mass_matrix);\\n      }\\n  }\\n \\n \\n \\n template <int dim>\\n void ObstacleProblem<dim>::update_solution_and_constraints()\\n  {\\n    std::cout << \\\"   Updating active set...\\\" << std::endl;\\n \\n const double penalty_parameter = 100.0;\\n \\n TrilinosWrappers::MPI::Vector lambda(\\n complete_index_set(dof_handler.n_dofs()));\\n    complete_system_matrix.residual(lambda, solution, complete_system_rhs);\\n \\n    contact_force = lambda;\\n    contact_force.scale(diagonal_of_mass_matrix);\\n    contact_force *= -1;\\n \\n    constraints.clear();\\n    active_set.clear();\\n \\n const Obstacle<dim> obstacle;\\n    std::vector<bool>   dof_touched(dof_handler.n_dofs(), false);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      for (const auto v : cell->vertex_indices())\\n        {\\n Assert(dof_handler.get_fe().n_dofs_per_cell() == cell->n_vertices(),\\n                 ExcNotImplemented());\\n \\n const unsigned int dof_index = cell->vertex_dof_index(v, 0);\\n \\n if (dof_touched[dof_index] == false)\\n            dof_touched[dof_index] = true;\\n else\\n continue;\\n \\n const double obstacle_value = obstacle.value(cell->vertex(v));\\n const double solution_value = solution(dof_index);\\n \\n if (lambda(dof_index) + penalty_parameter *\\n                                    diagonal_of_mass_matrix(dof_index) *\\n                                    (solution_value - obstacle_value) <\\n              0)\\n            {\\n              active_set.add_index(dof_index);\\n              constraints.add_constraint(dof_index, {}, obstacle_value);\\n \\n              solution(dof_index) = obstacle_value;\\n \\n lambda(dof_index) = 0;\\n            }\\n        }\\n    std::cout << \\\"      Size of active set: \\\" << active_set.n_elements()\\n              << std::endl;\\n \\n    std::cout << \\\"   Residual of the non-contact part of the system: \\\"\\n              << lambda.l2_norm() << std::endl;\\n \\n VectorTools::interpolate_boundary_values(dof_handler,\\n                                             0,\\n                                             BoundaryValues<dim>(),\\n                                             constraints);\\n    constraints.close();\\n  }\\n \\n \\n template <int dim>\\n void ObstacleProblem<dim>::solve()\\n  {\\n    std::cout << \\\"   Solving system...\\\" << std::endl;\\n \\n ReductionControl                        reduction_control(100, 1e-12, 1e-3);\\n SolverCG<TrilinosWrappers::MPI::Vector> solver(reduction_control);\\n TrilinosWrappers::PreconditionAMG       precondition;\\n    precondition.initialize(system_matrix);\\n \\n    solver.solve(system_matrix, solution, system_rhs, precondition);\\n    constraints.distribute(solution);\\n \\n    std::cout << \\\"      Error: \\\" << reduction_control.initial_value() << \\\" -> \\\"\\n              << reduction_control.last_value() << \\\" in \\\"\\n              << reduction_control.last_step() << \\\" CG iterations.\\\"\\n              << std::endl;\\n  }\\n \\n \\n \\n template <int dim>\\n void ObstacleProblem<dim>::output_results(const unsigned int iteration) const\\n {\\n    std::cout << \\\"   Writing graphical output...\\\" << std::endl;\\n \\n TrilinosWrappers::MPI::Vector active_set_vector(\\n      dof_handler.locally_owned_dofs(), MPI_COMM_WORLD);\\n for (const auto index : active_set)\\n      active_set_vector[index] = 1.;\\n \\n DataOut<dim> data_out;\\n \\n    data_out.attach_dof_handler(dof_handler);\\n    data_out.add_data_vector(solution, \\\"displacement\\\");\\n    data_out.add_data_vector(active_set_vector, \\\"active_set\\\");\\n    data_out.add_data_vector(contact_force, \\\"lambda\\\");\\n \\n    data_out.build_patches();\\n \\n    std::ofstream output_vtk(\\\"output_\\\" +\\n Utilities::int_to_string(iteration, 3) + \\\".vtk\\\");\\n    data_out.write_vtk(output_vtk);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void ObstacleProblem<dim>::run()\\n  {\\n    make_grid();\\n    setup_system();\\n \\n IndexSet active_set_old(active_set);\\n for (unsigned int iteration = 0; iteration <= solution.size(); ++iteration)\\n      {\\n        std::cout << \\\"Newton iteration \\\" << iteration << std::endl;\\n \\n        assemble_system();\\n \\n if (iteration == 0)\\n          {\\n            complete_system_matrix.copy_from(system_matrix);\\n            complete_system_rhs = system_rhs;\\n          }\\n \\n        solve();\\n        update_solution_and_constraints();\\n        output_results(iteration);\\n \\n if (active_set == active_set_old)\\n break;\\n \\n        active_set_old = active_set;\\n \\n        std::cout << std::endl;\\n      }\\n  }\\n} // namespace Step41\\n \\n \\n \\nint main(int argc, char *argv[])\\n{\\n try\\n    {\\n using namespace dealii;\\n using namespace Step41;\\n \\n Utilities::MPI::MPI_InitFinalize mpi_initialization(\\n        argc, argv, numbers::invalid_unsigned_int);\\n \\n AssertThrow(Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) == 1,\\n                  ExcMessage(\\n \\\"This program can only be run in serial, use ./step-41\\\"));\\n \\n      ObstacleProblem<2> obstacle_problem;\\n      obstacle_problem.run();\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n \\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n \\n return 0;\\n}\\naffine_constraints.h\\nDataOutInterface::write_vtkvoid write_vtk(std::ostream &out) constDefinition data_out_base.cc:7681\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\ndof_handler.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nfe_values.h\\nfe_q.h\\nfull_matrix.h\\nfunction.h\\ntria.h\\ngrid_generator.h\\nindex_set.h\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\nLocalIntegrators::L2::mass_matrixvoid mass_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const double factor=1.)Definition l2.h:57\\ninternal::VectorizationTypes::index@ index\\ninternal::EvaluatorQuantity::value@ value\\ndata_out.h\\nquadrature_lib.h\\nsolver_cg.h\\ntrilinos_precondition.h\\ntrilinos_sparse_matrix.h\\ntrilinos_vector.h\\nvector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"