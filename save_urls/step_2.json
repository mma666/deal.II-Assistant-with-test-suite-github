"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_2.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-2 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-2 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-2 tutorial program\\n\\n\\nThis tutorial depends on step-1.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\n Enumerating degrees of freedom \\n Sparsity \\n How degrees of freedom are enumerated \\n\\n The commented program\\n\\nMesh generation\\nOutputting the location of degrees of freedom\\nCreation of a DoFHandler\\nRenumbering of DoFs\\nThe main function\\n\\n\\n Results\\n\\n Possibilities for extensions \\n\\n The plain program\\n   \\n Introduction\\nNoteThe material presented here is also discussed in video lecture 9. (All video lectures are also available here.)\\nThe finite element method is based on approximating the solution \\\\(u\\\\) of a differential equation such as \\\\(-\\\\Delta u=f\\\\) by a function \\\\(u_h\\\\) that is \\\"piecewise\\\" polynomial; that is, we subdivide the domain \\\\(\\\\Omega\\\\) on which the equation is posed into small cells that in the documentation we will generally denote by the symbol \\\\(K\\\\). On each cell \\\\(K\\\\), the approximating function \\\\(u_h\\\\) we seek is then a polynomial. (Or, strictly speaking, a function that is the image of a polynomial from a \\\"reference cell\\\", but let us not make things more complicated than necessary for now.)\\nIn the previous tutorial program (in step-1), we showed how we should think of the subdivision of the domain into cells as a \\\"mesh\\\" represented by the Triangulation class, and how this looks like in code. In the current tutorial program, we now show how one represents piecewise polynomial functions through the concept of degrees of freedom defined on this mesh. For this example, we will use the lowest order ( \\\\(Q_1\\\\)) finite elements, that is the approximating function \\\\(u_h\\\\) we are looking for will be \\\"bi-linear\\\" on each quadrilateral cell \\\\(K\\\\) of the mesh. (They would be linear if we would work on triangles.)\\nIn practice, we represent the function as a linear combination of shape functions \\\\(\\\\varphi_j(\\\\mathbf x)\\\\) with multipliers \\\\(U_j\\\\) that we call the \\\"degrees of freedom\\\". For the bi-linear functions we consider here, each of these shape functions and degrees of freedom is associated with a vertex of the mesh. Later examples will demonstrate higher order elements where degrees of freedom are not necessarily associated with vertices any more, but can be associated with edges, faces, or cells.\\nThe term \\\"degree of freedom\\\" is commonly used in the finite element community to indicate two slightly different, but related things. The first is that we'd like to represent the finite element solution as a linear combination of shape functions, in the form  \\\\(u_h(\\\\mathbf x) = \\\\sum_{j=0}^{N-1} U_j \\\\varphi_j(\\\\mathbf\\nx)\\\\). Here, \\\\(U_j\\\\) is a vector of expansion coefficients. Because we don't know their values yet (we will compute them as the solution of a linear or nonlinear system), they are called \\\"unknowns\\\" or \\\"degrees of freedom\\\". The second meaning of the term can be explained as follows: A mathematical description of finite element problems is often to say that we are looking for a finite dimensional function \\\\(u_h \\\\in V_h\\\\) that satisfies some set of equations (e.g. \\\\(a(u_h,\\\\varphi_h)=(f,\\\\varphi_h)\\\\) for all test functions  \\\\(\\\\varphi_h\\\\in\\nV_h\\\\)). In other words, all we say here is that the solution needs to lie in some space \\\\(V_h\\\\). However, to actually solve this problem on a computer we need to choose a basis of this space; this is the set of shape functions \\\\(\\\\varphi_j(\\\\mathbf x)\\\\) we have used above in the expansion of \\\\(u_h(\\\\mathbf x)\\\\) with coefficients \\\\(U_j\\\\). There are of course many bases of the space \\\\(V_h\\\\), but we will specifically choose the one that is described by the finite element functions that are traditionally defined locally on the cells of the mesh.\\nEnumerating degrees of freedom \\nDescribing \\\"degrees of freedom\\\" in this context requires us to simply enumerate the basis functions of the space \\\\(V_h\\\\). For \\\\(Q_1\\\\) elements this means simply enumerating the vertices of the mesh in some way, but for higher order elements, one also has to enumerate the shape functions that are associated with edges, faces, or cell interiors of the mesh. In other words, the enumeration of degrees of freedom is an entirely separate thing from the indices we use for vertices. The class that provides this enumeration of the basis functions of \\\\(V_h\\\\) is called DoFHandler.\\nDefining degrees of freedom (\\\"DoF\\\"s in short) on a mesh is, in practice, a rather simple task, since the library does all the work for you. Essentially, all you have to do is create a finite element object (from one of the many finite element classes deal.II already has, see for example the Finite element space descriptions documentation) and give it to a DoFHandler object through the DoFHandler::distribute_dofs() function (\\\"distributing DoFs\\\" is the term we use to describe the process of enumerating the basis functions as discussed above). The DoFHandler is a class that knows which degrees of freedom live where, i.e., it can answer questions like \\\"how many degrees of freedom are there globally\\\" and \\\"on this cell, give me the global indices of the shape functions that\\nlive here\\\". This is the sort of information you need when determining how big your system matrix should be, and when copying the contributions of a single cell into the global matrix.\\nThe first task of the current program is therefore to take a mesh and a finite element, and enumerate the degrees of freedom. In the current context, this means simply giving each vertex of the mesh a DoF index. Once that has happened, we will output in a picture which vertex ended up with which DoF index. You can find the corresponding pictures in the results section of this tutorial.\\nIt is probably worth pointing out that where each DoF is geometrically located is not a question we typically ask in finite element codes. Most often, we only care about the fact that there is an enumeration of all degrees of freedom, but not which DoF is where. (We will also come back to this below where we talk about renumbering degrees of freedom.) At the same time, it is probably instructive to see this once, and so this program shows such a figure.\\nSparsity \\nThe next step would then be to compute a matrix and right hand side corresponding to a particular differential equation using this finite element and mesh. We will keep this step for the step-3 program and rather talk about one practical aspect of a finite element program, namely that finite element matrices are always very sparse: almost all entries in these matrices are zero.\\nTo be more precise, we say that a matrix is sparse if the number of nonzero entries per row in the matrix is bounded by a number that is independent of the overall number of degrees of freedom. For example, the simple 5-point stencil of a finite difference approximation of the Laplace equation leads to a sparse matrix since the number of nonzero entries per row is five, and therefore independent of the total size of the matrix. For more complicated problems \\u2013 say, the Stokes problem of step-22 \\u2013 and in particular in 3d, the number of entries per row may be several hundred. But the important point is that this number is independent of the overall size of the problem: If you refine the mesh, the maximal number of unknowns per row remains the same.\\nSparsity is one of the distinguishing features of the finite element method compared to, say, approximating the solution of a partial differential equation using a Taylor expansion and matching coefficients, or using a Fourier basis.\\nIn practical terms, it is the sparsity of matrices that enables us to solve problems with millions or billions of unknowns. To understand this, note that a matrix with \\\\(N\\\\) rows, each with a fixed upper bound for the number of nonzero entries, requires \\\\({\\\\cal O}(N)\\\\) memory locations for storage, and a matrix-vector multiplication also requires only \\\\({\\\\cal O}(N)\\\\) operations. Consequently, if we had a linear solver that requires only a fixed number of matrix-vector multiplications to come up with the solution of a linear system with this matrix, then we would have a solver that can find the values of all \\\\(N\\\\) unknowns with optimal complexity, i.e., with a total of \\\\({\\\\cal O}(N)\\\\) operations. It is clear that this wouldn't be possible if the matrix were not sparse (because then the number of entries in the matrix would have to be \\\\({\\\\cal O}(N^s)\\\\) with some \\\\(s>1\\\\), and doing a fixed number of matrix-vector products would take \\\\({\\\\cal O}(N^s)\\\\) operations), but it also requires very specialized solvers such as multigrid methods to satisfy the requirement that the solution requires only a fixed number of matrix-vector multiplications. We will frequently look at the question of what solver to use in the remaining programs of this tutorial.\\nThe sparsity is generated by the fact that finite element shape functions are defined locally on individual cells, rather than globally, and that the local differential operators in the bilinear form only couple shape functions whose support overlaps. (The \\\"support\\\" of a function is the area where it is nonzero. For the finite element method, the support of a shape function is generally the cells adjacent to the vertex, edge, or face it is defined on.) In other words, degrees of freedom \\\\(i\\\\) and \\\\(j\\\\) that are not defined on the same cell do not overlap, and consequently the matrix entry \\\\(A_{ij}\\\\) will be zero. (In some cases such as the Discontinuous Galerkin method, shape functions may also connect to neighboring cells through face integrals. But finite element methods do not generally couple shape functions beyond the immediate neighbors of a cell on which the function is defined.)\\nHow degrees of freedom are enumerated \\nBy default, the DoFHandler class enumerates degrees of freedom on a mesh using an algorithm that is difficult to describe and leads to results that do look right if you know what it is doing but otherwise appears rather random; consequently, the sparsity pattern is also not optimized for any particular purpose. To show this, the code below will demonstrate a simple way to output the \\\"sparsity pattern\\\" that corresponds to a DoFHandler, i.e., an object that represents all of the potentially nonzero elements of a matrix one may build when discretizing a partial differential equation on a mesh and its DoFHandler. This lack of structure in the sparsity pattern will be apparent from the pictures we show below.\\nFor most applications and algorithms, the exact way in which degrees of freedom are numbered does not matter. For example, the Conjugate Gradient method we use to solve linear systems does not care. On the other hand, some algorithms do care: in particular, some preconditioners such as SSOR will work better if they can walk through degrees of freedom in a particular order, and it would be nice if we could just sort them in such a way that SSOR can iterate through them from zero to \\\\(N\\\\) in this order. Other examples include computing incomplete LU or Cholesky factorizations, or if we care about the block structure of matrices (see step-20 for an example). deal.II therefore has algorithms that can re-enumerate degrees of freedom in particular ways in namespace DoFRenumbering. Renumbering can be thought of as choosing a different, permuted basis of the finite element space. The sparsity pattern and matrices that result from this renumbering are therefore also simply a permutation of rows and columns compared to the ones we would get without explicit renumbering.\\nIn the program below, we will use the algorithm of Cuthill and McKee to do so. We will show the sparsity pattern for both the original enumeration of degrees of freedom and of the renumbered version below, in the results section.\\n The commented program\\nThe first few includes are just like in the previous program, so do not require additional comments:\\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_out.h>\\n\\u00a0 \\nHowever, the next file is new. We need this include file for the association of degrees of freedom (\\\"DoF\\\"s) to vertices, lines, and cells:\\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 \\nThe following include contains the description of the bilinear finite element, including the facts that it has one degree of freedom on each vertex of the triangulation, but none on faces and none in the interior of the cells.\\n(In fact, the file contains the description of Lagrange elements in general, i.e. also the quadratic, cubic, etc versions, and not only for 2d but also 1d and 3d.)\\n\\u00a0 #include <deal.II/fe/fe_q.h>\\nIn the following file, several tools for manipulating degrees of freedom can be found, and the one after it is necessary to call one of the functions imported from dof_tools.h:\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 #include <deal.II/fe/mapping_q1.h>\\n\\u00a0 \\nWe will use a sparse matrix to visualize the pattern of nonzero entries resulting from the distribution of degrees of freedom on the grid. That class can be found here:\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\nWe will also need to use an intermediate sparsity pattern structure, which is found in this file :\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 \\nWe will want to use a special algorithm to renumber degrees of freedom. It is declared here:\\n\\u00a0 #include <deal.II/dofs/dof_renumbering.h>\\n\\u00a0 \\nAnd this is again needed for C++ output:\\n\\u00a0 #include <fstream>\\n\\u00a0 \\nFinally, as in step-1, we import the deal.II namespace into the global scope:\\n\\u00a0 using namespace dealii;\\n\\u00a0 \\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n Mesh generation\\nThis is the function that produced the circular grid in the previous step-1 example program with fewer refinements steps. The sole difference is that it returns the grid it produces via its argument.\\nAt the end of the function, we also output this mesh into a file. We will use this as one piece of information when visualizing the location of degrees of freedom. To output a mesh, we use the GridOut class that you have already seen in step-1; the difference is only that we use gnuplot rather than SVG format, because gnuplot is the program we will use to visualize DoF locations.\\n\\u00a0 void make_grid(Triangulation<2> &triangulation)\\n\\u00a0 {\\n\\u00a0   const Point<2> center(1, 0);\\n\\u00a0   const double   inner_radius = 0.5, outer_radius = 1.0;\\n\\u00a0   GridGenerator::hyper_shell(\\n\\u00a0     triangulation, center, inner_radius, outer_radius, 5);\\n\\u00a0 \\n\\u00a0   for (unsigned int step = 0; step < 3; ++step)\\n\\u00a0     {\\n\\u00a0       for (const auto &cell : triangulation.active_cell_iterators())\\n\\u00a0         for (const auto v : cell->vertex_indices())\\n\\u00a0           {\\n\\u00a0             const double distance_from_center =\\n\\u00a0               center.distance(cell->vertex(v));\\n\\u00a0 \\n\\u00a0             if (std::fabs(distance_from_center - inner_radius) <=\\n\\u00a0                 1e-6 * inner_radius)\\n\\u00a0               {\\n\\u00a0                 cell->set_refine_flag();\\n\\u00a0                 break;\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0       triangulation.execute_coarsening_and_refinement();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   std::ofstream mesh_file(\\\"mesh.gnuplot\\\");\\n\\u00a0   GridOut().write_gnuplot(triangulation, mesh_file);\\n\\u00a0 }\\n\\u00a0 \\n\\u00a0 \\nGridOutDefinition grid_out.h:993\\nGridOut::write_gnuplotvoid write_gnuplot(const Triangulation< dim, spacedim > &tria, std::ostream &out, const Mapping< dim, spacedim > *mapping=nullptr) constDefinition grid_out.cc:4608\\nPointDefinition point.h:111\\nTriangulationDefinition tria.h:1323\\nparallel::distributed::Triangulation::execute_coarsening_and_refinementvirtual void execute_coarsening_and_refinement() overrideDefinition tria.cc:3320\\ncenterPoint< 3 > centerDefinition data_out_base.cc:267\\nvertex_indicesunsigned int vertex_indices[2]Definition grid_tools_topology.cc:947\\nGridGenerator::hyper_shellvoid hyper_shell(Triangulation< dim, spacedim > &tria, const Point< spacedim > &center, const double inner_radius, const double outer_radius, const unsigned int n_cells=0, bool colorize=false)\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\n Outputting the location of degrees of freedom\\nThe next function outputs the locations of degrees of freedom for later visualization. Where each DoF is located is something the DoFHandler object knows, so that is one of the arguments to this function. Since we want to do all of this twice (once for the original enumeration and once for the renumbered set of degrees of freedom), the function also takes as a second argument the name of the file into which we want the output to be written.\\nIn order to learn deal.II, it is probably not terribly important to understand exactly what this function does, and you can skip over it. But if you would like to know anyway: We want to call the function DoFTools::map_dofs_to_support_points() that returns a list of locations. It does so in the form of a map through which we can query (in a statement such as dof_location_map[42]) where the DoF is located (in the example, where the 42nd DoF is). It puts this information into the dof_location_map object.\\nWe then use the function DoFTools::write_gnuplot_dof_support_point_info() to write this information into a file in a format that is understandable to the gnuplot program that we will use for visualization in the results section.\\n\\u00a0 void write_dof_locations(const DoFHandler<2> &dof_handler,\\n\\u00a0                          const std::string   &filename)\\n\\u00a0 {\\n\\u00a0   const std::map<types::global_dof_index, Point<2>> dof_location_map =\\n\\u00a0     DoFTools::map_dofs_to_support_points(MappingQ1<2>(), dof_handler);\\n\\u00a0 \\n\\u00a0   std::ofstream dof_location_file(filename);\\n\\u00a0   DoFTools::write_gnuplot_dof_support_point_info(dof_location_file,\\n\\u00a0                                                  dof_location_map);\\n\\u00a0 }\\n\\u00a0 \\n\\u00a0 \\nDoFHandlerDefinition dof_handler.h:317\\nMappingQ1Definition mapping_q1.h:55\\nDoFTools::map_dofs_to_support_pointsvoid map_dofs_to_support_points(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof_handler, std::vector< Point< spacedim > > &support_points, const ComponentMask &mask={})Definition dof_tools.cc:2380\\nDoFTools::write_gnuplot_dof_support_point_infovoid write_gnuplot_dof_support_point_info(std::ostream &out, const std::map< types::global_dof_index, Point< spacedim > > &support_points)Definition dof_tools.cc:2495\\n Creation of a DoFHandler\\nUp to now, we only have a grid, i.e. some geometrical (the position of the vertices) and some topological information (how vertices are connected to lines, and lines to cells, as well as which cells neighbor which other cells). To use numerical algorithms, one needs some logic information in addition to that: we would like to associate degree of freedom numbers to each vertex (or line, or cell, in case we were using higher order elements) to later generate matrices and vectors which describe a finite element field on the triangulation.\\nThis function shows how to do this. The object to consider is the DoFHandler class template. Before we do so, however, we first need something that describes how many degrees of freedom are to be associated to each of these objects. Since this is one aspect of the definition of a finite element space, the finite element base class stores this information. In the present context, we therefore create an object of the derived class FE_Q that describes Lagrange elements. Its constructor takes one argument that states the polynomial degree of the element, which here is one (indicating a bi-linear element); this then corresponds to one degree of freedom for each vertex, while there are none on lines and inside the quadrilateral. A value of, say, three given to the constructor would instead give us a bi-cubic element with one degree of freedom per vertex, two per line, and four inside the cell. In general, FE_Q denotes the family of continuous elements with complete polynomials (i.e. tensor-product polynomials) up to the specified order.\\nWe first need to create an object of this class and then pass it on to the DoFHandler object to allocate storage for the degrees of freedom (in deal.II lingo: we distribute degrees of freedom).\\n\\u00a0 void distribute_dofs(DoFHandler<2> &dof_handler)\\n\\u00a0 {\\n\\u00a0   const FE_Q<2> finite_element(1);\\n\\u00a0   dof_handler.distribute_dofs(finite_element);\\n\\u00a0 \\nDoFHandler::distribute_dofsvoid distribute_dofs(const FiniteElement< dim, spacedim > &fe)\\nFE_QDefinition fe_q.h:554\\nNow that we have associated a degree of freedom with a global number to each vertex, Let us output this information using the function above:\\n\\u00a0   write_dof_locations(dof_handler, \\\"dof-locations-1.gnuplot\\\");\\n\\u00a0 \\nIn practice, we do not often care about where a degree of freedom is geometrically located, and so other than seeing it once via the call above is not practically useful. But where two degrees of freedom are in relation to each other matters in other ways.\\nAssociated with each vertex of the triangulation is a shape function. Assume we want to solve something like Laplace's equation, then the different matrix entries will be the integrals over the gradient of each pair of such shape functions. Obviously, since the shape functions are nonzero only on the cells adjacent to the vertex they are associated with, matrix entries will be nonzero only if the supports of the shape functions associated to that column and row numbers intersect. This is only the case for adjacent shape functions, and therefore only for adjacent vertices. Now, since the vertices are numbered more or less randomly by the above function (DoFHandler::distribute_dofs), the pattern of nonzero entries in the matrix will be somewhat ragged, and we will take a look at it now.\\nFirst we have to create a structure which we use to store the places of nonzero elements. This can then later be used by one or more sparse matrix objects that store the values of the entries in the locations stored by this sparsity pattern. The class that stores the locations is the SparsityPattern class. As it turns out, however, this class has some drawbacks when we try to fill it right away: its data structures are set up in such a way that we need to have an estimate for the maximal number of entries we may wish to have in each row. In two space dimensions, reasonable values for this estimate are available through the DoFHandler::max_couplings_between_dofs() function, but in three dimensions the function almost always severely overestimates the true number, leading to a lot of wasted memory, sometimes too much for the machine used, even if the unused memory can be released immediately after computing the sparsity pattern. In order to avoid this, we use an intermediate object of type DynamicSparsityPattern that uses a different internal data structure and that we can later copy into the SparsityPattern object without much overhead. (Some more information on these data structures can be found in the Sparsity patterns topic.) In order to initialize this intermediate data structure, we have to give it the size of the matrix, which in our case will be square with as many rows and columns as there are degrees of freedom on the grid:\\n\\u00a0   DynamicSparsityPattern dynamic_sparsity_pattern(dof_handler.n_dofs(),\\n\\u00a0                                                   dof_handler.n_dofs());\\n\\u00a0 \\nDoFHandler::n_dofstypes::global_dof_index n_dofs() const\\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nWe then fill this object with the places where nonzero elements will be located given the present numbering of degrees of freedom:\\n\\u00a0   DoFTools::make_sparsity_pattern(dof_handler, dynamic_sparsity_pattern);\\n\\u00a0 \\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nNow we are ready to create the actual sparsity pattern that we could later use for our matrix. It will just contain the data already assembled in the DynamicSparsityPattern.\\n\\u00a0   SparsityPattern sparsity_pattern;\\n\\u00a0   sparsity_pattern.copy_from(dynamic_sparsity_pattern);\\n\\u00a0 \\nSparsityPatternDefinition sparsity_pattern.h:343\\nSparsityPattern::copy_fromvoid copy_from(const size_type n_rows, const size_type n_cols, const ForwardIterator begin, const ForwardIterator end)\\nWith this, we can now write the results to a file :\\n\\u00a0   std::ofstream out(\\\"sparsity-pattern-1.svg\\\");\\n\\u00a0   sparsity_pattern.print_svg(out);\\nThe result is stored in an .svg file, where each nonzero entry in the matrix corresponds with a red square in the image. The output will be shown below.\\nIf you look at it, you will note that the sparsity pattern is symmetric. This should not come as a surprise, since we have not given the DoFTools::make_sparsity_pattern any information that would indicate that our bilinear form may couple shape functions in a non-symmetric way. You will also note that it has several distinct region, which stem from the fact that the numbering starts from the coarsest cells and moves on to the finer ones; since they are all distributed symmetrically around the origin, this shows up again in the sparsity pattern.\\n\\u00a0 }\\n\\u00a0 \\n\\u00a0 \\n Renumbering of DoFs\\nIn the sparsity pattern produced above, the nonzero entries extended quite far off from the diagonal. For some algorithms, for example for incomplete LU decompositions or Gauss-Seidel preconditioners, this is unfavorable, and we will show a simple way how to improve this situation.\\nRemember that for an entry \\\\((i,j)\\\\) in the matrix to be nonzero, the supports of the shape functions i and j needed to intersect (otherwise in the integral, the integrand would be zero everywhere since either the one or the other shape function is zero at some point). However, the supports of shape functions intersected only if they were adjacent to each other, so in order to have the nonzero entries clustered around the diagonal (where \\\\(i\\\\) equals \\\\(j\\\\)), we would like to have adjacent shape functions to be numbered with indices (DoF numbers) that differ not too much.\\nThis can be accomplished by a simple front marching algorithm, where one starts at a given vertex and gives it the index zero. Then, its neighbors are numbered successively, making their indices close to the original one. Then, their neighbors, if not yet numbered, are numbered, and so on.\\nOne algorithm that adds a little bit of sophistication along these lines is the one by Cuthill and McKee. We will use it in the following function to renumber the degrees of freedom such that the resulting sparsity pattern is more localized around the diagonal. The only interesting part of the function is the first call to DoFRenumbering::Cuthill_McKee, the rest is essentially as before:\\n\\u00a0 void renumber_dofs(DoFHandler<2> &dof_handler)\\n\\u00a0 {\\n\\u00a0   DoFRenumbering::Cuthill_McKee(dof_handler);\\n\\u00a0 \\n\\u00a0   write_dof_locations(dof_handler, \\\"dof-locations-2.gnuplot\\\");\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   DynamicSparsityPattern dynamic_sparsity_pattern(dof_handler.n_dofs(),\\n\\u00a0                                                   dof_handler.n_dofs());\\n\\u00a0   DoFTools::make_sparsity_pattern(dof_handler, dynamic_sparsity_pattern);\\n\\u00a0 \\n\\u00a0   SparsityPattern sparsity_pattern;\\n\\u00a0   sparsity_pattern.copy_from(dynamic_sparsity_pattern);\\n\\u00a0 \\n\\u00a0   std::ofstream out(\\\"sparsity-pattern-2.svg\\\");\\n\\u00a0   sparsity_pattern.print_svg(out);\\n\\u00a0 }\\n\\u00a0 \\nDoFRenumbering::Cuthill_McKeevoid Cuthill_McKee(DoFHandler< dim, spacedim > &dof_handler, const bool reversed_numbering=false, const bool use_constraints=false, const std::vector< types::global_dof_index > &starting_indices=std::vector< types::global_dof_index >())Definition dof_renumbering.cc:366\\nAgain, the output is shown below. Note that the nonzero entries are clustered far better around the diagonal than before. This effect is even more distinguished for larger matrices (the present one has 1260 rows and columns, but large matrices often have several 100,000s).\\nIt is worth noting that the DoFRenumbering class offers a number of other algorithms as well to renumber degrees of freedom. For example, it would of course be ideal if all couplings were in the lower or upper triangular part of a matrix, since then solving the linear system would amount to only forward or backward substitution. This is of course unachievable for symmetric sparsity patterns, but in some special situations involving transport equations, this is possible by enumerating degrees of freedom from the inflow boundary along streamlines to the outflow boundary. Not surprisingly, DoFRenumbering also has algorithms for this.\\n The main function\\nFinally, this is the main program. The only thing it does is to allocate and create the triangulation, then create a DoFHandler object and associate it to the triangulation, and finally call above two functions on it:\\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   Triangulation<2> triangulation;\\n\\u00a0   make_grid(triangulation);\\n\\u00a0 \\n\\u00a0   DoFHandler<2> dof_handler(triangulation);\\n\\u00a0 \\n\\u00a0   distribute_dofs(dof_handler);\\n\\u00a0   renumber_dofs(dof_handler);\\n\\u00a0 }\\n Results\\nThe program has, after having been run, produced two files of DoF locations and sparsity patterns each (once for the original numbering and once after renumbering), along with one mesh file.\\nLet us start with the DoF locations. There is no particularly convenient program to visualize this kind of information, but we can resort to GNUPLOT (one of the simpler visualization programs; maybe not the easiest to use since it is command line driven, but also universally available on all Linux and other Unix-like systems). The command that produces the following pictures reads as follows: plot [-0.1:2.1][-1.1:1.1] \\\"mesh.gnuplot\\\" with lines, \\\"dof-locations-1.gnuplot\\\" using 1:2:3 with labels point offset .3,.2 font \\\"4,6\\\"\\n This may be cryptic, but what exactly this does is also not particularly important and you shouldn't spend too much time understanding what it does. Rather, the important part is to look at what we get as output: \\n\\n  \\n\\nWhat these figures show is (i) a numeric label attached to each vertex \\u2013 the DoF index, and (ii) that the original enumeration on the left differs from the renumbered one on the right. Which of the two is \\\"better\\\" is of course a different question (with the answer depending on what we want to do with these degrees of freedom); the important point is that for the same mesh, one can come up with many different enumerations of the degrees of freedom.\\nAs for the sparsity patterns, we can visualize these by opening the .svg files in a web browser. The pictures below represent the matrix, and every red square denotes an entry which might be nonzero. (Whether the entry actually is zero or not depends on the equation under consideration, but the indicated positions in the matrix tell us which shape functions can and which can't couple when discretizing a local, i.e. differential, equation.) \\n\\n  \\n\\nThe different regions in the left picture, indicated by kinks in the lines and single dots on the left and top, represent the degrees of freedom on the different refinement levels of the triangulation. As can be seen in the right picture, the sparsity pattern is much better clustered around the main diagonal of the matrix after renumbering. Although this might not be apparent, the number of nonzero entries is the same in both pictures, of course.\\nPossibilities for extensions \\nJust as with step-1, you may want to play with the program a bit to familiarize yourself with deal.II. For example, in the distribute_dofs function, we use linear finite elements (that's what the argument \\\"1\\\" to the FE_Q object is). Explore how the sparsity pattern changes if you use higher order elements, for example cubic or quintic ones (by using 3 and 5 as the respective arguments). You might also want to see where DoFs are now located \\u2013 but for that you likely want to work with a mesh with fewer cells because DoFs are now also located on edges and in the interior of cells.\\nYou could also explore how the sparsity pattern changes by refining the mesh. You will see that not only the size of the matrix changes, but also its bandwidth (the distance from the diagonal of those nonzero elements of the matrix that are farthest away from the diagonal), though the ratio of bandwidth to size typically shrinks, i.e. the matrix clusters more around the diagonal.\\nAnother idea of experiments would be to try other renumbering strategies than Cuthill-McKee from the DoFRenumbering namespace and see how they affect the sparsity pattern.\\nYou can also visualize the output using GNUPLOT (which we have already used above) by changing from print_svg() to print_gnuplot() in distribute_dofs() and renumber_dofs() (and using the file ending .gnuplot instead of .svg): examples/step-2> gnuplot\\n \\n        G N U P L O T\\n        Version 3.7 patchlevel 3\\n        last modified Thu Dec 12 13:00:00 GMT 2002\\n        System: Linux 2.6.11.4-21.10-default\\n \\n        Copyright(C) 1986 - 1993, 1998 - 2002\\n        Thomas Williams, Colin Kelley and many others\\n \\n        Type `help` to access the on-line reference manual\\n        The gnuplot FAQ is available from\\n        http://www.gnuplot.info/gnuplot-faq.html\\n \\n        Send comments and requests for help to <info-gnuplot@dartmouth.edu>\\n        Send bugs, suggestions and mods to <bug-gnuplot@dartmouth.edu>\\n \\n \\nTerminal type set to 'x11'\\ngnuplot> set style data points\\ngnuplot> plot \\\"sparsity-pattern-1.gnuplot\\\"\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 1999 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n */\\n \\n \\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_out.h>\\n \\n#include <deal.II/dofs/dof_handler.h>\\n \\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/dofs/dof_tools.h>\\n#include <deal.II/fe/mapping_q1.h>\\n \\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n \\n#include <deal.II/dofs/dof_renumbering.h>\\n \\n#include <fstream>\\n \\nusing namespace dealii;\\n \\n \\n \\nvoid make_grid(Triangulation<2> &triangulation)\\n{\\n const Point<2> center(1, 0);\\n const double   inner_radius = 0.5, outer_radius = 1.0;\\n GridGenerator::hyper_shell(\\n triangulation, center, inner_radius, outer_radius, 5);\\n \\n for (unsigned int step = 0; step < 3; ++step)\\n    {\\n for (const auto &cell : triangulation.active_cell_iterators())\\n        for (const auto v : cell->vertex_indices())\\n          {\\n const double distance_from_center =\\n center.distance(cell->vertex(v));\\n \\n if (std::fabs(distance_from_center - inner_radius) <=\\n                1e-6 * inner_radius)\\n              {\\n                cell->set_refine_flag();\\n break;\\n              }\\n          }\\n \\n triangulation.execute_coarsening_and_refinement();\\n    }\\n \\n  std::ofstream mesh_file(\\\"mesh.gnuplot\\\");\\n GridOut().write_gnuplot(triangulation, mesh_file);\\n}\\n \\n \\n \\nvoid write_dof_locations(const DoFHandler<2> &dof_handler,\\n const std::string   &filename)\\n{\\n const std::map<types::global_dof_index, Point<2>> dof_location_map =\\n DoFTools::map_dofs_to_support_points(MappingQ1<2>(), dof_handler);\\n \\n  std::ofstream dof_location_file(filename);\\n DoFTools::write_gnuplot_dof_support_point_info(dof_location_file,\\n                                                 dof_location_map);\\n}\\n \\n \\n \\nvoid distribute_dofs(DoFHandler<2> &dof_handler)\\n{\\n const FE_Q<2> finite_element(1);\\n  dof_handler.distribute_dofs(finite_element);\\n \\n  write_dof_locations(dof_handler, \\\"dof-locations-1.gnuplot\\\");\\n \\n DynamicSparsityPattern dynamic_sparsity_pattern(dof_handler.n_dofs(),\\n                                                  dof_handler.n_dofs());\\n \\n DoFTools::make_sparsity_pattern(dof_handler, dynamic_sparsity_pattern);\\n \\n SparsityPattern sparsity_pattern;\\n  sparsity_pattern.copy_from(dynamic_sparsity_pattern);\\n \\n  std::ofstream out(\\\"sparsity-pattern-1.svg\\\");\\n  sparsity_pattern.print_svg(out);\\n}\\n \\n \\n \\nvoid renumber_dofs(DoFHandler<2> &dof_handler)\\n{\\n DoFRenumbering::Cuthill_McKee(dof_handler);\\n \\n  write_dof_locations(dof_handler, \\\"dof-locations-2.gnuplot\\\");\\n \\n \\n DynamicSparsityPattern dynamic_sparsity_pattern(dof_handler.n_dofs(),\\n                                                  dof_handler.n_dofs());\\n DoFTools::make_sparsity_pattern(dof_handler, dynamic_sparsity_pattern);\\n \\n SparsityPattern sparsity_pattern;\\n  sparsity_pattern.copy_from(dynamic_sparsity_pattern);\\n \\n  std::ofstream out(\\\"sparsity-pattern-2.svg\\\");\\n  sparsity_pattern.print_svg(out);\\n}\\n \\n \\n \\n \\n \\nint main()\\n{\\n Triangulation<2> triangulation;\\n  make_grid(triangulation);\\n \\n DoFHandler<2> dof_handler(triangulation);\\n \\n  distribute_dofs(dof_handler);\\n  renumber_dofs(dof_handler);\\n}\\nPoint::distancenumbers::NumberTraits< Number >::real_type distance(const Point< dim, Number > &p) const\\nSparsityPattern::print_svgvoid print_svg(std::ostream &out) constDefinition sparsity_pattern.cc:934\\ndof_handler.h\\ndof_renumbering.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nfe_q.h\\ntria.h\\ngrid_generator.h\\ngrid_out.h\\nmapping_q1.h\\nsparse_matrix.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"