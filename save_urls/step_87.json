"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_87.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-87 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-87 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-87 tutorial program\\n\\n\\nThis tutorial depends on step-40.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nPoint evaluation\\nSetup and communication\\nImplementation: Utilities::MPI::RemotePointEvaluation\\nMotivation: two-phase flow\\nOverview\\n\\n The commented program\\n\\nInclude files\\nUtility functions (declaration)\\nMini example 0: Evaluation at given points for a serial mesh\\nMini example 1: Evaluation at given points on a distributed mesh\\nMini example 2: Closest-point evaluation on a distributed mesh\\nMini example 3: Sharp interface method on the example of surface tension for front tracking\\nUtility functions (definition)\\nDriver\\n\\n\\n Results\\n\\nMini example 0\\nMini example 1\\nMini example 2\\nMini example 3\\nPossibilities for extension\\n\\n The plain program\\n   \\n\\n\\n This program was contributed by Magdalena Schreter-Fleischhacker and Peter Munch. Many ideas presented here are the result of common code development with Maximilian Bergbauer, Marco Feder, Niklas Fehn, Johannes Heinz, Luca Heltai, Martin Kronbichler, Nils Much, and Judith Pauen.\\nThis tutorial is loosely based on chapter 3.4 of the submitted PhD thesis \\\"Matrix-free finite element computations at extreme scale and for\\nchallenging applications\\\" by Peter Munch. Magdalena Schreter-Fleischhacker is funded by the Austrian Science Fund (FWF) Schr\\u00f6dinger Fellowship (J4577). \\nNoteIf you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation:   \\nIntroduction\\nThis tutorial presents the advanced point-evaluation functionalities of deal.II, specifically useful for evaluating finite element solutions at arbitrary points. The underlying finite element mesh can be distributed among processes, which makes the operations more involved due to communication. In the examples discussed in this tutorial, we focus on point evaluation for MPI-parallel computations, like parallel::distributed::Triangulation. Nevertheless, the application to non-distributed meshes is also possible.\\nPoint evaluation\\nIn the context of the finite element method (FEM), it is a common task to query the solution \\\\(u\\\\) at an arbitrary point \\\\(\\\\boldsymbol{x}_q\\\\) in the domain of interest \\\\(\\\\Omega\\\\)    \\n\\\\[\\nu(\\\\boldsymbol{x}_q) = \\\\sum_{i} N_i(\\\\boldsymbol{x}_q) u_i  \\\\quad\\\\text{with}\\\\quad\\ni\\\\in[0,n_{\\\\text{dofs}}),\\n\\\\]\\n\\n by evaluating the shape functions \\\\(N_i\\\\) at this point together with the corresponding solution coefficients \\\\(u_i\\\\). After identifying the cell \\\\(K\\\\) where the point \\\\(\\\\boldsymbol{x}_q\\\\) resides, the transformation between \\\\(\\\\boldsymbol{x}_q\\\\) and the corresponding coordinates in the reference cell \\\\(\\\\hat{\\\\boldsymbol{x}}_q\\\\) is obtained by the mapping \\\\(\\\\boldsymbol{x}_q=\\\\boldsymbol{F}_K(\\\\hat{\\\\boldsymbol{x}}_q)\\\\). In this setting, the evaluation of the solution at an arbitrary point boils down to a cell-local evaluation    \\n\\\\[\\nu(\\\\boldsymbol{x}_q) = \\\\sum_{i} \\\\hat{N}^K_i(\\\\hat{\\\\boldsymbol{x}}_q) u_i^K\\n\\\\quad\\\\text{with}\\\\quad i\\\\in[0,n_{\\\\text{dofs\\\\_per\\\\_cell}}),\\n\\\\]\\n\\n with \\\\(\\\\hat{N}^K_i\\\\) being the shape functions defined on the reference cell and \\\\(u_i^{K}\\\\) the solution coefficients restricted to the cell \\\\(K\\\\).\\nAlternatively to point evaluation, evaluating weak-form (integration) operations of the type           \\n\\\\[\\nu_i\\n=\\n\\\\left(N_i(\\\\boldsymbol{x}), u(\\\\boldsymbol{x})\\\\right)_\\\\Omega\\n=\\n\\\\int_{\\\\Omega} N_i(\\\\boldsymbol{x}) u(\\\\boldsymbol{x}) dx\\n=\\n\\\\sum_q N_i\\\\left(\\\\boldsymbol{x}_q\\\\right) u\\\\left(\\\\boldsymbol{x}_q\\\\right) |J\\\\left(\\n\\\\boldsymbol{x}_q\\\\right)| w\\\\left(\\\\boldsymbol{x}_q\\\\right) \\\\quad\\\\text{with}\\\\quad\\ni\\\\in[0,n_{\\\\text{dofs}})\\n\\\\]\\n\\n is possible, with \\\\(\\\\boldsymbol{x}_q\\\\) being quadrature points at arbitrary positions. After the values at the quadrature points have been multiplied by the integration weights, this operation can be interpreted as the transpose of the evaluation. Not surprisingly, such an operation can be also implemented as a cell loop.\\nSetup and communication\\nTo determine the cell \\\\(K\\\\) and the reference position \\\\(\\\\hat{\\\\boldsymbol x}_q\\\\) within the cell for a given point \\\\(\\\\boldsymbol{x}_q\\\\) on distributed meshes, deal.II performs a two-level-search approach. First, all processes whose portion of the global mesh might contain the point are determined (\\\"coarse search\\\"). For this purpose, e.g., a distributed tree based on bounding boxes around locally owned domains using \\\"ArborX\\\" [141] is applied. After the potentially owning processes have been determined and the points have been sent to them as a request, one can start to find the cells that surround the points among locally owned cells (\\\"fine search\\\"). In order to accelerate this search, an R-tree from \\\"boost::geometry\\\" built around the vertices of the mesh is used.\\nOnce the cell \\\\(K\\\\) that surrounds point \\\\(\\\\boldsymbol{x}_q\\\\) has been found, the reference position \\\\(\\\\hat{\\\\boldsymbol{x}}_q\\\\) is obtained by performing the minimization:        \\n\\\\[\\n\\\\min_{\\\\hat{\\\\boldsymbol{x}}_q}(| \\\\boldsymbol{F}_K(\\\\hat{\\\\boldsymbol{x}}_q)\\n- {\\\\boldsymbol{x}_q}|)\\n\\\\quad\\n\\\\text{with}\\n\\\\quad\\n\\\\hat{\\\\boldsymbol{x}}_q\\\\in[0,1]^{dim}.\\n\\\\]\\n\\n With the determined pieces of information, the desired evaluation can be performed by the process that owns the cell. The result can now be communicated to the requesting process.\\nIn summary, the coarse search determines, for each point, a list of processes that might own it. The subsequent fine search by each process determines whether the processes actually own these points by the sequence of request (\\\"Does the process own the point?\\\") and answer (\\\"Yes.\\\"/\\\"No.\\\"). Processes might post any number of point requests and communicate with any process. We propose to collect the point requests to a process to use the dynamic, sparse, scalable consensus-based communication algorithms [118], and to consider the obtained information to set up point-to-point communication patterns.\\nImplementation: Utilities::MPI::RemotePointEvaluation\\nThe algorithm described above is implemented in Utilities::MPI::RemotePointEvaluation (short: \\\"rpe\\\") and related classes/functions. In this section, basic functionalities are briefly summarized. Their advanced capabilities will be shown subsequently based on concrete application cases.\\nThe following code snippet shows the setup steps for the communication pattern: std::vector<Point<dim>> points; // ... (filling of points not shown)\\n \\nRemotePointEvaluation<dim> rpe;\\nrpe.reinit(points, triangulation, mapping);\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\nAll what is needed is a list of evaluation points and the mesh with a mapping.\\nThe following code snippet shows the evaluation steps: const std::function<void(const ArrayView<T> &, const CellData &)>\\n  evaluation_function;\\n \\nstd::vector<T> output;\\nrpe.evaluate_and_process(output, evaluation_function);\\nArrayViewDefinition array_view.h:88\\nCellDataDefinition tria_description.h:79\\nThe user provides a function that processes the locally owned points. These values are communicated by Utilities::MPI::RemotePointEvaluation.\\nThe relevant class during the local evaluation is Utilities::MPI::RemotePointEvaluation::CellData. It allows to loop over cells that surround the points. On these cells, a cell iterator and the positions in the reference cell of the requested points can be queried. Furthermore, this class provides controlled access to the output vector of the Utilities::MPI::RemotePointEvaluation::evaluate_and_process() function. for (const auto cell_index : cell_data.cell_indices())\\n  {\\n const auto cell         = cell_data.get_active_cell_iterator(cell_index);\\n const auto unit_points  = cell_data.get_unit_points(cell_index);\\n const auto local_output = cell_data.get_data_view(cell_index, output);\\n  }\\ncell_indexunsigned int cell_indexDefinition grid_tools_topology.cc:783\\nThe functions const auto evaluated_values =\\n VectorTools::point_values<n_components>(rpe, dof_handler, vector);\\n \\nconst auto evaluated_gradients =\\n VectorTools::point_gradients<n_components>(rpe, dof_handler, vector);\\nVectorTools::point_valuesstd::vector< typename FEPointEvaluation< n_components, dim, spacedim, typename VectorType::value_type >::value_type > point_values(const Mapping< dim > &mapping, const MeshType< dim, spacedim > &mesh, const VectorType &vector, const std::vector< Point< spacedim > > &evaluation_points, Utilities::MPI::RemotePointEvaluation< dim, spacedim > &cache, const EvaluationFlags::EvaluationFlags flags=EvaluationFlags::avg, const unsigned int first_selected_component=0)\\nVectorTools::point_gradientsstd::vector< typename FEPointEvaluation< n_components, dim, spacedim, typename VectorType::value_type >::gradient_type > point_gradients(const Mapping< dim > &mapping, const MeshType< dim, spacedim > &mesh, const VectorType &vector, const std::vector< Point< spacedim > > &evaluation_points, Utilities::MPI::RemotePointEvaluation< dim, spacedim > &cache, const EvaluationFlags::EvaluationFlags flags=EvaluationFlags::avg, const unsigned int first_selected_component=0)\\nevaluate the values and gradients of a solution defined by DoFHandler and a vector at the requested points. Internally, a lambda function is passed to Utilities::MPI::RemotePointEvaluation. Additionally it handles the special case if points belong to multiple cells by taking, e.g., the average, the minimum, or the maximum via an optional argument of type EvaluationFlags::EvaluationFlags. This occurs when a point lies on a cell boundary or within a small tolerance around it and might be relevant for discontinuous solution quantities, such as values of discontinuous Galerkin methods or gradients in continuous finite element methods.\\nMotivation: two-phase flow\\nThe minimal code examples (short \\\"mini examples\\\") presented in this tutorial are motivated by the application of two-phase-flow simulations formulated in a one-fluid setting using a Eulerian framework. In diffuse interface methods, the two phases may be implicitly described by a level-set function, here chosen as a signed distance function \\\\(\\\\phi(\\\\boldsymbol{ x})\\\\) in \\\\(\\\\Omega\\\\) and illustrated for a popular benchmark case of a rising bubble in the following figure.\\n\\n\\n\\n\\n\\n\\n\\nThe discrete interface \\\\(\\\\Gamma\\\\) is represented implicitly through a certain isosurface of the level-set function e.g. for the signed-distance function  \\\\(\\\\Gamma=\\\\{\\\\boldsymbol x \\\\in \\\\Omega~|~\\\\phi\\n(\\\\boldsymbol{x})=0\\\\}\\\\). We would like to note that deal.II provides a set of analytical signed distance functions for simple geometries in the Functions::SignedDistance namespace. Those can be combined via Boolean operations to describe more complex geometries [52]. The temporal evolution of the level-set field is obtained by the transport equation    \\n\\\\[\\n        \\\\frac{\\\\partial \\\\, \\\\phi}{\\\\partial \\\\, t} + \\\\boldsymbol{u}\\\\vert_\\\\Gamma \\\\cdot\\n  \\\\nabla \\\\phi = 0\\n\\\\]\\n\\n with the transport velocity at the interface \\\\(\\\\boldsymbol{u}\\\\vert_\\\\Gamma\\\\), which might be approximated by the local fluid velocity  \\\\(\\\\boldsymbol{u}\\n\\\\vert_\\\\Gamma\\\\approx\\\\boldsymbol{u}(\\\\boldsymbol{x})\\\\). To reobtain the signed-distance property of the level-set field throughout the numerical solution procedure, PDE-based or, alternatively, also geometric reinitialization methods are used. For the latter, an algorithm for computing the distance from the support points to the discrete interface, e.g., via closest-point point projection [116], is needed. This will be part of one of the mini examples, where we describe how to obtain the closest point \\\\(\\\\boldsymbol{x}^*\\\\) to the interface \\\\(\\\\Gamma\\\\) for an arbitrary point \\\\(\\\\boldsymbol{x}\\\\). For the simplest case, the former can be computed from the following equation    \\n\\\\[\\n        \\\\boldsymbol{x}^{*} = \\\\boldsymbol{x} - \\\\boldsymbol{n}(\\\\boldsymbol{x})\\n  \\\\phi(\\\\boldsymbol{x}),\\n\\\\]\\n\\n assuming that the interface normal vector \\\\(\\\\boldsymbol{n}(\\\\boldsymbol{x})\\\\) and \\\\(\\\\phi(\\\\boldsymbol{x})\\\\) represent exact quantities. Typically, this projection is only performed for points located within a narrow band region around the interface, indicated in the right panel of the figure above.\\nAlternatively to the implicit representation of the interface, in sharp interface methods, e.g., via front tracking, the interface \\\\(\\\\Gamma\\\\) is explicitly represented by a surface mesh. The latter is immersed into a background mesh, from which the local velocity at the support points of the surface mesh is extracted and leads to a movement of the support points of the immersed mesh as     \\n\\\\[\\n        \\\\boldsymbol{x}_q^{(i + 1)} = \\\\boldsymbol{x}_q^{(i)} +  \\\\Delta t \\\\cdot\\n  \\\\boldsymbol{u}(\\\\boldsymbol{x}_q^{(i)}) \\\\quad \\\\text{ for } \\\\boldsymbol{x}_q\\n  \\\\in \\\\Gamma\\n\\\\]\\n\\n which considers an explicit Euler time integration scheme from time step \\\\(i\\\\) to \\\\(i+1\\\\) with time step-size \\\\(\\\\Delta t\\\\).\\nFor a two-phase-flow model considering the incompressible Navier-Stokes equations, the two phases are usually coupled by a singular surface-tension force \\\\(\\\\boldsymbol{F}_S\\\\), which results, together with the difference in fluid properties, in discontinuities across the interface:    \\n\\\\[\\n        \\\\boldsymbol{F}_S(\\\\boldsymbol{x})= \\\\sigma \\\\kappa(\\\\boldsymbol{x})\\n  \\\\boldsymbol{n}(\\\\boldsymbol{x}) \\\\delta_{\\\\Gamma}(\\\\boldsymbol{x}).\\n\\\\]\\n\\n Here \\\\(\\\\sigma\\\\) represents the surface-tension coefficient, \\\\(\\\\boldsymbol{n}(\\\\boldsymbol{x})\\\\) the interface normal vector and \\\\(\\\\kappa(\\\\boldsymbol{x})\\\\) the interface mean curvature field. The singularity at the interface is imposed by the Dirac delta function     \\n\\\\[\\n\\\\delta_{\\\\Gamma}(\\\\boldsymbol{x}) = \\\\begin{cases}\\n1 & \\\\text{on } \\\\Gamma \\\\\\\\\\n0 & \\\\text{else}\\\\end{cases}\\n\\\\]\\n\\n with support on the interface \\\\(\\\\Gamma\\\\). In a finite element context, the weak form of the surface-tension force is needed. The latter can be applied as a sharp surface-tension force model    \\n\\\\[\\n        (\\\\boldsymbol v, \\\\boldsymbol F_S)_{\\\\Omega} = \\\\left( \\\\boldsymbol{v}, \\\\sigma\\n  \\\\kappa \\\\boldsymbol{n} \\\\right)_\\\\Gamma,\\n\\\\]\\n\\n exploiting the property of the Dirac delta function for any smooth function \\\\(v\\\\), i.e., \\\\(\\\\int_\\\\Omega\\\\delta_{\\\\Gamma}\\\\,v\\\\,\\\\text{d}x=\\\\int_\\\\Gamma v\\\\,\\\\text{d}y\\\\). For front-tracking methods, the curvature and the normal vector are directly computed from the surface mesh.\\nAlternatively, in regularized surface-tension-force models [40] [169] [140], the Dirac delta function is approximated by a smooth ansatz    \\n\\\\[\\n(\\\\boldsymbol v, \\\\boldsymbol F_S)_{\\\\Omega} \\\\approx \\\\left(\\\\boldsymbol v, \\\\sigma\\n\\\\kappa \\\\boldsymbol{n} \\\\|\\\\nabla H\\\\|  \\\\right)_\\\\Omega\\n\\\\]\\n\\n considering the absolute value of the gradient of a regularized indicator function \\\\(\\\\|\\\\nabla H\\\\|\\\\), which is related to the level-set field. In such models, the interface normal vector   \\n\\\\[\\n        \\\\boldsymbol{n}(\\\\boldsymbol{x}) = \\\\nabla \\\\phi(\\\\boldsymbol{x}),\\n\\\\]\\n\\n and the interface curvature field    \\n\\\\[\\n        \\\\kappa(\\\\boldsymbol{x}) = \\\\nabla \\\\cdot \\\\boldsymbol{n}(\\\\boldsymbol{x})=\\n  \\\\Delta \\\\phi(\\\\boldsymbol{x}) \\\\,.\\n\\\\]\\n\\n are derived from the level-set function.\\nOverview\\nIn the following, we present three simple use cases of Utilities::MPI::RemotePointEvaluation. We start with discussing a serial code in mini example 0. In the subsequent mini examples, advanced problems are solved on distributed meshes: \\n\\nmini example 1: we evaluate values and user quantities along a line; \\n\\nmini example 2: we perform a closest-point projection within a narrow band, based on a level-set function, use the information to update the distance and to perform an extrapolation from the interface; \\n\\nmini example 3: we compute the surface-tension term sharply with the interface given by an codim-1 mesh, which is advected by the velocity from the background mesh (front tracking; solution transfer between a background mesh and an immersed surface mesh). \\n\\n The commented program\\n Include files\\nThe program starts with including all the relevant header files.\\n\\u00a0 #include <deal.II/base/conditional_ostream.h>\\n\\u00a0 #include <deal.II/base/function_lib.h>\\n\\u00a0 #include <deal.II/base/function_signed_distance.h>\\n\\u00a0 #include <deal.II/base/mpi.h>\\n\\u00a0 #include <deal.II/base/mpi.templates.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/distributed/tria.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_renumbering.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_nothing.h>\\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_system.h>\\n\\u00a0 #include <deal.II/fe/mapping_q1.h>\\n\\u00a0 #include <deal.II/fe/mapping_q_cache.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/generic_linear_algebra.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 \\n\\u00a0 #include <iostream>\\n\\u00a0 #include <fstream>\\n\\u00a0 \\nThe files most relevant for this tutorial are the ones that contain Utilities::MPI::RemotePointEvaluation and the distributed evaluation functions in the VectorTools namespace, which use Utilities::MPI::RemotePointEvaluation.\\n\\u00a0 #include <deal.II/base/mpi_remote_point_evaluation.h>\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 \\nThe following header file provides the class FEPointEvaluation, which allows us to evaluate values of a local solution vector at arbitrary unit points of a cell.\\n\\u00a0 #include <deal.II/matrix_free/fe_point_evaluation.h>\\n\\u00a0 \\nWe pack everything that is specific for this program into a namespace of its own.\\n\\u00a0 namespace Step87\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n Utility functions (declaration)\\nIn the following, we declare utility functions that are used in the mini examples below. You find the definitions at the end of the tutorial.\\nThe minimum requirement of this tutorial is MPI. If deal.II is built with p4est, we use parallel::distributed::Triangulation as distributed mesh. The class parallel::shared::Triangulation is used if deal.II is built without p4est or if the dimension of the triangulation is 1D, e.g., in the case of codim-1 meshes.\\n\\u00a0 #ifdef DEAL_II_WITH_P4EST\\n\\u00a0   template <int dim, int spacedim = dim>\\n\\u00a0   using DistributedTriangulation = typename std::conditional_t<\\n\\u00a0     dim == 1,\\n\\u00a0     parallel::shared::Triangulation<dim, spacedim>,\\n\\u00a0     parallel::distributed::Triangulation<dim, spacedim>>;\\n\\u00a0 #else\\n\\u00a0   template <int dim, int spacedim = dim>\\n\\u00a0   using DistributedTriangulation =\\n\\u00a0     parallel::shared::Triangulation<dim, spacedim>;\\n\\u00a0 #endif\\n\\u00a0 \\nparallel::distributed::TriangulationDefinition tria.h:268\\nparallel::shared::TriangulationDefinition shared_tria.h:110\\nA list of points along a line is created by definition of a start point p0, an end point p1, and the number of subdivisions n_subdivisions.\\n\\u00a0   template <int spacedim>\\n\\u00a0   std::vector<Point<spacedim>>\\n\\u00a0   create_points_along_line(const Point<spacedim> &p0,\\n\\u00a0                            const Point<spacedim> &p1,\\n\\u00a0                            const unsigned int     n_subdivisions);\\n\\u00a0 \\nPointDefinition point.h:111\\nA given list of points and the corresponding values values_0 and values_1 (optional) are printed column-wise to a file file_name. In addition, the first column represents the distance of the points from the first point.\\n\\u00a0   template <int spacedim, typename T0, typename T1 = int>\\n\\u00a0   void print_along_line(const std::string                  &file_name,\\n\\u00a0                         const std::vector<Point<spacedim>> &points,\\n\\u00a0                         const std::vector<T0>              &values_0,\\n\\u00a0                         const std::vector<T1>              &values_1 = {});\\n\\u00a0 \\nCreate a unique list of the real coordinates of support points into support_points from the provided Mapping mapping and the DoFHandler dof_handler.\\n\\u00a0   template <int dim, int spacedim>\\n\\u00a0   void collect_support_points(\\n\\u00a0     const Mapping<dim, spacedim>               &mapping,\\n\\u00a0     const DoFHandler<dim, spacedim>            &dof_handler,\\n\\u00a0     LinearAlgebra::distributed::Vector<double> &support_points);\\n\\u00a0 \\nDoFHandlerDefinition dof_handler.h:317\\nLinearAlgebra::distributed::VectorDefinition la_parallel_vector.h:250\\nMappingAbstract base class for mapping classes.Definition mapping.h:318\\nFrom the provided Mapping mapping and the DoFHandler dof_handler collect the global DoF indices and corresponding support points within a narrow band around the zero-level-set isosurface. Thereto, the value of the finite element function signed_distance corresponding to the DoFHandler dof_handler_support_points is evaluated at each support point. A support point is only collected if the absolute value is below the value for the narrow_band_threshold.\\n\\u00a0   template <int dim, int spacedim, typename T>\\n\\u00a0   std::tuple<std::vector<Point<spacedim>>, std::vector<types::global_dof_index>>\\n\\u00a0   collect_support_points_with_narrow_band(\\n\\u00a0     const Mapping<dim, spacedim>                &mapping,\\n\\u00a0     const DoFHandler<dim, spacedim>             &dof_handler_signed_distance,\\n\\u00a0     const LinearAlgebra::distributed::Vector<T> &signed_distance,\\n\\u00a0     const DoFHandler<dim, spacedim>             &dof_handler_support_points,\\n\\u00a0     const double                                 narrow_band_threshold);\\n\\u00a0 \\nConvert a distributed vector of support points (support_points_unrolled) with a sequential order of the coordinates per point into a list of points.\\n\\u00a0   template <int spacedim>\\n\\u00a0   std::vector<Point<spacedim>> convert(\\n\\u00a0     const LinearAlgebra::distributed::Vector<double> &support_points_unrolled);\\n\\u00a0 \\n Mini example 0: Evaluation at given points for a serial mesh\\nIn this introductory example, we demonstrate basic functionalities available in deal.II to evaluate solution quantities at arbitrary points on a serial mesh. The same functionalities are used directly or indirecly in the distributed case to evaluate solution on locally owned cells. This, however, needs to be augmented by communication, as presented in following examples.\\nWe first create the typical objects needed for a finite element discretization (defined by mapping, triangulation, and finite element) and a vector containing finite element solution coefficients.\\n\\u00a0   void example_0()\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"Running: example 0\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     constexpr unsigned int dim       = 2;\\n\\u00a0     constexpr unsigned int fe_degree = 3;\\n\\u00a0 \\n\\u00a0     MappingQ1<dim>     mapping;\\n\\u00a0     Triangulation<dim> tria;\\n\\u00a0     GridGenerator::subdivided_hyper_cube(tria, 7);\\n\\u00a0 \\n\\u00a0     const FE_Q<dim> fe(fe_degree);\\n\\u00a0     DoFHandler<dim> dof_handler(tria);\\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0 \\n\\u00a0     Vector<double> vector(dof_handler.n_dofs());\\n\\u00a0     VectorTools::interpolate(mapping,\\n\\u00a0                              dof_handler,\\n\\u00a0                              Functions::SignedDistance::Sphere<dim>(\\n\\u00a0                                (dim == 1) ? Point<dim>(0.5) :\\n\\u00a0                                (dim == 2) ? Point<dim>(0.5, 0.5) :\\n\\u00a0                                             Point<dim>(0.5, 0.5, 0.5),\\n\\u00a0                                0.25),\\n\\u00a0                              vector);\\n\\u00a0 \\nFE_QDefinition fe_q.h:554\\nFunctions::SignedDistance::SphereDefinition function_signed_distance.h:49\\nMappingQ1Definition mapping_q1.h:55\\nTriangulationDefinition tria.h:1323\\nVectorDefinition vector.h:120\\nGridGenerator::subdivided_hyper_cubevoid subdivided_hyper_cube(Triangulation< dim, spacedim > &tria, const unsigned int repetitions, const double left=0., const double right=1., const bool colorize=false)\\nVectorTools::interpolatevoid interpolate(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const Function< spacedim, typename VectorType::value_type > &function, VectorType &vec, const ComponentMask &component_mask={})\\nWe create a list of points inside the domain at which we would like to evaluate the finite element interpolant.\\n\\u00a0     const auto points_line =\\n\\u00a0       create_points_along_line((dim == 1) ? Point<dim>(0.0) :\\n\\u00a0                                (dim == 2) ? Point<dim>(0.0, 0.5) :\\n\\u00a0                                             Point<dim>(0.0, 0.5, 0.5),\\n\\u00a0                                (dim == 1) ? Point<dim>(1.0) :\\n\\u00a0                                (dim == 2) ? Point<dim>(1.0, 0.5) :\\n\\u00a0                                             Point<dim>(1.0, 0.5, 0.5),\\n\\u00a0                                20);\\n\\u00a0 \\nNow, we loop over all evaluation points. In the first step, we determine via GridTools::find_active_cell_around_point() the cell \\\\(K\\\\) that surrounds the point and translate the given real coordinate \\\\(\\\\boldsymbol{x}\\\\) to the corresponding coordinate on the unit cell \\\\(\\\\hat{\\\\boldsymbol{x}}_K\\\\) according to the provided mapping. The resulting information is printed to the screen.\\n\\u00a0     std::vector<double> values_line;\\n\\u00a0     values_line.reserve(points_line.size());\\n\\u00a0 \\n\\u00a0     for (const auto &p_real : points_line)\\n\\u00a0       {\\n\\u00a0         const auto [cell, p_unit] =\\n\\u00a0           GridTools::find_active_cell_around_point(mapping,\\n\\u00a0                                                    dof_handler,\\n\\u00a0                                                    p_real);\\n\\u00a0 \\n\\u00a0         {\\n\\u00a0           AssertThrow(cell != dof_handler.end(), ExcInternalError());\\n\\u00a0           std::cout << \\\" - Found point with real coordinates: \\\" << p_real\\n\\u00a0                     << std::endl;\\n\\u00a0           std::cout << \\\"   - in cell with vertices:\\\";\\n\\u00a0           for (const auto &v : cell->vertex_indices())\\n\\u00a0             std::cout << \\\" (\\\" << cell->vertex(v) << \\\")\\\";\\n\\u00a0           std::cout << std::endl;\\n\\u00a0           std::cout << \\\"   - with coordinates on the unit cell: (\\\" << p_unit\\n\\u00a0                     << \\\")\\\" << std::endl;\\n\\u00a0         }\\n\\u00a0 \\nvertex_indicesunsigned int vertex_indices[2]Definition grid_tools_topology.cc:947\\nAssertThrow#define AssertThrow(cond, exc)Definition exceptions.h:1739\\nGridToolsDefinition mpi_remote_point_evaluation.h:29\\nstdSTL namespace.\\nHaving determined \\\\(K\\\\) and \\\\(\\\\hat{\\\\boldsymbol{x}}_K\\\\), we can perform the evaluation of the finite element solution at this point. In the following, we show three approaches for this purpose. In the first approach, we follow a traditional technique by using FEValues based on a cell-specific quadrature rule consisting of the unit point.\\n\\u00a0         std::cout << \\\" - Values at point:\\\" << std::endl;\\n\\u00a0 \\n\\u00a0         {\\n\\u00a0           FEValues<dim> fe_values(mapping,\\n\\u00a0                                   fe,\\n\\u00a0                                   Quadrature<dim>(p_unit),\\n\\u00a0                                   update_values);\\n\\u00a0           fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0           std::vector<double> quad_values(1);\\n\\u00a0           fe_values.get_function_values(vector, quad_values);\\n\\u00a0           const double value_0 = quad_values[0];\\n\\u00a0           std::cout << \\\"  - \\\" << value_0 << \\\" (w. FEValues)\\\" << std::endl;\\n\\u00a0           values_line.push_back(value_0);\\n\\u00a0         }\\n\\u00a0 \\nFEValuesDefinition fe_values.h:63\\nQuadratureDefinition quadrature.h:123\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nThe second approach considers FEPointEvaluation, which directly takes a list of unit points for the subsequent evaluation. The class FEPointEvaluation is a class optimized for the evaluation on cell level at arbitrary points and should be favored for such tasks.\\n\\u00a0         {\\n\\u00a0           std::vector<double> cell_vector(fe.n_dofs_per_cell());\\n\\u00a0           cell->get_dof_values(vector, cell_vector.begin(), cell_vector.end());\\n\\u00a0 \\n\\u00a0           FEPointEvaluation<1, dim> fe_point(mapping, fe, update_values);\\n\\u00a0           fe_point.reinit(cell, ArrayView<const Point<dim>>(p_unit));\\n\\u00a0           fe_point.evaluate(cell_vector, EvaluationFlags::values);\\n\\u00a0           const auto value_1 = fe_point.get_value(0);\\n\\u00a0           std::cout << \\\"  - \\\" << value_1 << \\\" (w. FEPointEvaluation)\\\"\\n\\u00a0                     << std::endl;\\n\\u00a0         }\\n\\u00a0 \\nFEPointEvaluationDefinition fe_point_evaluation.h:1126\\nEvaluationFlags::values@ valuesDefinition evaluation_flags.h:50\\nFinally, in the third approach, the function VectorTools::point_value() is considered. It performs both the search of the surrounding cell and the evaluation at the requested point. However, its application is limited to a serial run of the code.\\n\\u00a0         {\\n\\u00a0           const auto value_2 =\\n\\u00a0             VectorTools::point_value(dof_handler, vector, p_real);\\n\\u00a0           std::cout << \\\"  - \\\" << value_2 << \\\" (w. VectorTools::point_value())\\\"\\n\\u00a0                     << std::endl;\\n\\u00a0           std::cout << std::endl;\\n\\u00a0         }\\n\\u00a0       }\\n\\u00a0 \\nVectorTools::point_valuevoid point_value(const DoFHandler< dim, spacedim > &dof, const VectorType &fe_function, const Point< spacedim, double > &point, Vector< typename VectorType::value_type > &value)\\nWe output the requested points together with the corresponding evaluated solution to a CSV file.\\n\\u00a0     std::cout << \\\" - writing csv file\\\" << std::endl;\\n\\u00a0     print_along_line(\\\"example_0_profile.csv\\\", points_line, values_line);\\n\\u00a0   }\\n\\u00a0 \\nObviously, the code above cannot work for distributed meshes, since the search (which might require communication) is called within a for-loop with loop bounds possibly different on each process. In the following code examples, we present the usage of arbitrary point evaluation in a parallel computation.\\n Mini example 1: Evaluation at given points on a distributed mesh\\nJust like in the introductory example, we evaluate the solution along a line, however, on a distributed mesh. We again start with setting up the objects needed for a finite element discretization.\\n\\u00a0   void example_1()\\n\\u00a0   {\\n\\u00a0     constexpr unsigned int dim       = 2;\\n\\u00a0     constexpr unsigned int fe_degree = 3;\\n\\u00a0 \\n\\u00a0     ConditionalOStream pcout(std::cout,\\n\\u00a0                              Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) ==\\n\\u00a0                                0);\\n\\u00a0 \\n\\u00a0     pcout << \\\"Running: example 1\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     MappingQ1<dim>                mapping;\\n\\u00a0     DistributedTriangulation<dim> tria(MPI_COMM_WORLD);\\n\\u00a0     GridGenerator::subdivided_hyper_cube(tria, 7);\\n\\u00a0 \\n\\u00a0     const FE_Q<dim> fe(fe_degree);\\n\\u00a0     DoFHandler<dim> dof_handler(tria);\\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0 \\nConditionalOStreamDefinition conditional_ostream.h:80\\nUtilities::MPI::this_mpi_processunsigned int this_mpi_process(const MPI_Comm mpi_communicator)Definition mpi.cc:107\\nWe determine a finite element solution representing implicitly the geometry of a sphere with a radius of \\\\(r=0.25\\\\) and the center at \\\\((0.5,0.5)\\\\) via a signed distance function.\\n\\u00a0     LinearAlgebra::distributed::Vector<double> signed_distance;\\n\\u00a0     signed_distance.reinit(dof_handler.locally_owned_dofs(),\\n\\u00a0                            DoFTools::extract_locally_active_dofs(dof_handler),\\n\\u00a0                            MPI_COMM_WORLD);\\n\\u00a0 \\n\\u00a0     VectorTools::interpolate(mapping,\\n\\u00a0                              dof_handler,\\n\\u00a0                              Functions::SignedDistance::Sphere<dim>(\\n\\u00a0                                (dim == 1) ? Point<dim>(0.5) :\\n\\u00a0                                (dim == 2) ? Point<dim>(0.5, 0.5) :\\n\\u00a0                                             Point<dim>(0.5, 0.5, 0.5),\\n\\u00a0                                0.25),\\n\\u00a0                              signed_distance);\\n\\u00a0 \\nLinearAlgebra::distributed::Vector::reinitvoid reinit(const size_type size, const bool omit_zeroing_entries=false)\\nDoFTools::extract_locally_active_dofsIndexSet extract_locally_active_dofs(const DoFHandler< dim, spacedim > &dof_handler)Definition dof_tools.cc:1072\\nNext, we fill a vector from an arbitrary function that should represent a possible finite element solution, which we would like to evaluate.\\n\\u00a0     LinearAlgebra::distributed::Vector<double> solution;\\n\\u00a0     solution.reinit(dof_handler.locally_owned_dofs(),\\n\\u00a0                     DoFTools::extract_locally_active_dofs(dof_handler),\\n\\u00a0                     MPI_COMM_WORLD);\\n\\u00a0 \\n\\u00a0     VectorTools::interpolate(mapping,\\n\\u00a0                              dof_handler,\\n\\u00a0                              Functions::SignedDistance::Plane<dim>(\\n\\u00a0                                Point<dim>(), Point<dim>::unit_vector(0)),\\n\\u00a0                              solution);\\n\\u00a0 \\nFunctions::SignedDistance::PlaneDefinition function_signed_distance.h:105\\nWe create a list of arbitrary (evaluation) points along a horizontal line, which intersects the center of the sphere. We do this only on the root rank, since we intend to output the results to a CSV file by the root rank.\\n\\u00a0     std::vector<Point<dim>> profile;\\n\\u00a0     if (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)\\n\\u00a0       profile = create_points_along_line((dim == 1) ? Point<dim>(0.0) :\\n\\u00a0                                          (dim == 2) ? Point<dim>(0.0, 0.5) :\\n\\u00a0                                                       Point<dim>(0.0, 0.5, 0.5),\\n\\u00a0                                          (dim == 1) ? Point<dim>(1.0) :\\n\\u00a0                                          (dim == 2) ? Point<dim>(1.0, 0.5) :\\n\\u00a0                                                       Point<dim>(1.0, 0.5, 0.5),\\n\\u00a0                                          20);\\n\\u00a0 \\nNow, we can evaluate the results, e.g., for the signed distance function at all evaluation points in one go. First, we create a modifiable Utilities::MPI::RemotePointEvaluation object. We use VectorTools::point_values() by specifying the number of components of the solution vector (1 for the present example) as a template parameter. Within this function, the provided object for Utilities::MPI::RemotePointEvaluation is automatically reinitialized with the given points (profile). The ghost values of the solution vector need to be updated from the user.\\n\\u00a0     Utilities::MPI::RemotePointEvaluation<dim, dim> rpe;\\n\\u00a0 \\n\\u00a0     signed_distance.update_ghost_values();\\n\\u00a0     const std::vector<double> profile_signed_distance =\\n\\u00a0       VectorTools::point_values<1>(\\n\\u00a0         mapping, dof_handler, signed_distance, profile, rpe);\\n\\u00a0 \\nUtilities::MPI::RemotePointEvaluationDefinition mpi_remote_point_evaluation.h:56\\nIn addition to VectorTools::point_values(), function gradients can be evaluated via VectorTools::point_gradient(). However, for the computation of user-derived quantities, one might need to fall back to the direct usage of Utilities::MPI::RemotePointEvaluation::evaluate_and_process() or Utilities::MPI::RemotePointEvaluation::process_and_evaluate(). For the sake of demonstration, we use the former to evaluate the values of the solution vector at the requested points. First, we define a lambda function for the operation on the surrounding cells. Using the CellData object, we can create a FEPointEvaluation object to evaluate the solution values at the cell-specific unit coordinates of the requested points. Then, we assign the values to the result vector.\\n\\u00a0     const auto evaluate_function = [&](const ArrayView<double> &values,\\n\\u00a0                                        const auto              &cell_data) {\\n\\u00a0       FEPointEvaluation<1, dim> fe_point(mapping, fe, update_values);\\n\\u00a0 \\n\\u00a0       std::vector<double>                  local_values;\\n\\u00a0       std::vector<types::global_dof_index> local_dof_indices;\\n\\u00a0 \\n\\u00a0       for (const auto cell : cell_data.cell_indices())\\n\\u00a0         {\\n\\u00a0           const auto cell_dofs =\\n\\u00a0             cell_data.get_active_cell_iterator(cell)->as_dof_handler_iterator(\\n\\u00a0               dof_handler);\\n\\u00a0 \\n\\u00a0           const auto unit_points = cell_data.get_unit_points(cell);\\n\\u00a0           const auto local_value = cell_data.get_data_view(cell, values);\\n\\u00a0 \\n\\u00a0           local_values.resize(cell_dofs->get_fe().n_dofs_per_cell());\\n\\u00a0           cell_dofs->get_dof_values(solution,\\n\\u00a0                                     local_values.begin(),\\n\\u00a0                                     local_values.end());\\n\\u00a0 \\n\\u00a0           fe_point.reinit(cell_dofs, unit_points);\\n\\u00a0           fe_point.evaluate(local_values, EvaluationFlags::values);\\n\\u00a0 \\n\\u00a0           for (unsigned int q = 0; q < unit_points.size(); ++q)\\n\\u00a0             local_value[q] = fe_point.get_value(q);\\n\\u00a0         }\\n\\u00a0     };\\n\\u00a0 \\nThe lambda function is passed to Utilities::MPI::RemotePointEvaluation::evaluate_and_process(), where the values are processed accordingly and stored within the created output vector. Again, the ghost values of the vector to be read need to be updated by the user.\\n\\u00a0     solution.update_ghost_values();\\n\\u00a0 \\n\\u00a0     const std::vector<double> output =\\n\\u00a0       rpe.evaluate_and_process<double>(evaluate_function);\\n\\u00a0 \\nFinally, we output all results: the mesh as a VTU file and the results along the line as a CSV file. You can import the CSV file in ParaView and compare the output with the native line plot of ParaView based on the VTU file.\\n\\u00a0     DataOut<dim> data_out;\\n\\u00a0     data_out.add_data_vector(dof_handler, signed_distance, \\\"signed_distance\\\");\\n\\u00a0     data_out.build_patches(mapping);\\n\\u00a0     data_out.write_vtu_in_parallel(\\\"example_1.vtu\\\", MPI_COMM_WORLD);\\n\\u00a0 \\n\\u00a0     if (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)\\n\\u00a0       {\\n\\u00a0         std::cout << \\\" - writing csv file\\\" << std::endl;\\n\\u00a0         print_along_line(\\\"example_1_profile.csv\\\",\\n\\u00a0                          profile,\\n\\u00a0                          profile_signed_distance,\\n\\u00a0                          output);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOutDefinition data_out.h:147\\n Mini example 2: Closest-point evaluation on a distributed mesh\\nIn this mini example, we perform a closest-point projection for each support point of a mesh within a narrow band by iteratively solving for    \\n\\\\[\\n   \\\\boldsymbol{x}^{(i+1)} = \\\\boldsymbol{x}^{(i)} -\\n   \\\\boldsymbol{n}(\\\\boldsymbol{x}^{(i)})\\\\phi(\\\\boldsymbol{x}^{(i)}).\\n   \\\\]\\n\\n Once the closest point is determined, we can compute the distance and extrapolate the values from the interface. Note that the demonstrated algorithm does not guarantee that the closest points are collinear (see discussion in [67]). For the latter, one might also need to perform a tangential correction, which we omit here to keep the discussion concise.\\nWe start with creating the objects for the finite element representation of the background mesh.\\n\\u00a0   void example_2()\\n\\u00a0   {\\n\\u00a0     constexpr unsigned int dim       = 2;\\n\\u00a0     constexpr unsigned int fe_degree = 3;\\n\\u00a0 \\n\\u00a0     ConditionalOStream pcout(std::cout,\\n\\u00a0                              Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) ==\\n\\u00a0                                0);\\n\\u00a0 \\n\\u00a0     pcout << \\\"Running: example 2\\\" << std::endl;\\n\\u00a0     pcout << \\\"  - create system\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     const FE_Q<dim>               fe(fe_degree);\\n\\u00a0     MappingQ1<dim>                mapping;\\n\\u00a0     DistributedTriangulation<dim> tria(MPI_COMM_WORLD);\\n\\u00a0     GridGenerator::subdivided_hyper_cube(tria, 50);\\n\\u00a0 \\n\\u00a0     DoFHandler<dim> dof_handler(tria);\\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0 \\nWe compute finite element solution vector, based on an arbitrary function. In addition, a finite element function computed from a signed distance function represents the geometry of a sphere implicitly.\\n\\u00a0     LinearAlgebra::distributed::Vector<double> solution;\\n\\u00a0     solution.reinit(dof_handler.locally_owned_dofs(),\\n\\u00a0                     DoFTools::extract_locally_active_dofs(dof_handler),\\n\\u00a0                     MPI_COMM_WORLD);\\n\\u00a0 \\n\\u00a0     VectorTools::interpolate(mapping,\\n\\u00a0                              dof_handler,\\n\\u00a0                              Functions::SignedDistance::Plane<dim>(\\n\\u00a0                                Point<dim>(), Point<dim>::unit_vector(0)),\\n\\u00a0                              solution);\\n\\u00a0 \\n\\u00a0     LinearAlgebra::distributed::Vector<double> signed_distance;\\n\\u00a0     signed_distance.reinit(dof_handler.locally_owned_dofs(),\\n\\u00a0                            DoFTools::extract_locally_active_dofs(dof_handler),\\n\\u00a0                            MPI_COMM_WORLD);\\n\\u00a0 \\n\\u00a0     VectorTools::interpolate(mapping,\\n\\u00a0                              dof_handler,\\n\\u00a0                              Functions::SignedDistance::Sphere<dim>(\\n\\u00a0                                (dim == 1) ? Point<dim>(0.5) :\\n\\u00a0                                (dim == 2) ? Point<dim>(0.5, 0.5) :\\n\\u00a0                                             Point<dim>(0.5, 0.5, 0.5),\\n\\u00a0                                0.25),\\n\\u00a0                              signed_distance);\\n\\u00a0     signed_distance.update_ghost_values();\\n\\u00a0 \\nIn the next step, we collect the points in the narrow band around the zero-level-set isosurface for which we would like to perform a closest point projection. To this end, we loop over all support points and collect the coordinates and the DoF indices of those with a maximum distance of 0.1 from the zero-level-set isosurface.\\n\\u00a0     pcout << \\\"  - determine narrow band\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     const auto [support_points, support_points_idx] =\\n\\u00a0       collect_support_points_with_narrow_band(mapping,\\n\\u00a0                                               dof_handler,\\n\\u00a0                                               signed_distance,\\n\\u00a0                                               dof_handler,\\n\\u00a0                                               0.1 /*narrow_band_threshold*/);\\n\\u00a0 \\nFor the iterative solution procedure of the closest-point projection, the maximum number of iterations and the tolerance for the maximum absolute acceptable change in the distance in one iteration are set.\\n\\u00a0     pcout << \\\"  - determine closest point iteratively\\\" << std::endl;\\n\\u00a0     constexpr int    max_iter     = 30;\\n\\u00a0     constexpr double tol_distance = 1e-6;\\n\\u00a0 \\nNow, we are ready to perform the algorithm by setting an initial guess for the projection points simply corresponding to the collected support points. We collect the global indices of the support points and the total number of points that need to be processed and do not fulfill the required tolerance. Those will be gradually reduced upon the iterative process.\\n\\u00a0     std::vector<Point<dim>> closest_points = support_points; // initial guess\\n\\u00a0 \\n\\u00a0     std::vector<unsigned int> unmatched_points_idx(closest_points.size());\\n\\u00a0     std::iota(unmatched_points_idx.begin(), unmatched_points_idx.end(), 0);\\n\\u00a0 \\n\\u00a0     int n_unmatched_points =\\n\\u00a0       Utilities::MPI::sum(unmatched_points_idx.size(), MPI_COMM_WORLD);\\n\\u00a0 \\nUtilities::MPI::sumT sum(const T &t, const MPI_Comm mpi_communicator)\\nNow, we create a Utilities::MPI::RemotePointEvaluation cache object and start the loop for the fix-point iteration. We update the list of points that still need to be processed and subsequently pass this information to the Utilities::MPI::RemotePointEvaluation object. For the sake of illustration, we export the coordinates of the points to be updated for each iteration to a CSV file. Next, we can evaluate the signed distance function and the gradient at those points to update the current solution for the closest points. We perform the update only if the signed distance of the closest point is not already within the tolerance and register those points that still need to be processed.\\n\\u00a0     Utilities::MPI::RemotePointEvaluation<dim, dim> rpe;\\n\\u00a0 \\n\\u00a0     for (int it = 0; it < max_iter && n_unmatched_points > 0; ++it)\\n\\u00a0       {\\n\\u00a0         pcout << \\\"    - iteration \\\" << it << \\\": \\\" << n_unmatched_points;\\n\\u00a0 \\n\\u00a0         std::vector<Point<dim>> unmatched_points(unmatched_points_idx.size());\\n\\u00a0         for (unsigned int i = 0; i < unmatched_points_idx.size(); ++i)\\n\\u00a0           unmatched_points[i] = closest_points[unmatched_points_idx[i]];\\n\\u00a0 \\n\\u00a0         const auto all_unmatched_points =\\n\\u00a0           Utilities::MPI::reduce<std::vector<Point<dim>>>(\\n\\u00a0             unmatched_points, MPI_COMM_WORLD, [](const auto &a, const auto &b) {\\n\\u00a0               auto result = a;\\n\\u00a0               result.insert(result.end(), b.begin(), b.end());\\n\\u00a0               return result;\\n\\u00a0             });\\n\\u00a0 \\n\\u00a0         if (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)\\n\\u00a0           {\\n\\u00a0             std::ofstream file(\\\"example_2_\\\" + std::to_string(it) + \\\".csv\\\");\\n\\u00a0             for (const auto &p : all_unmatched_points)\\n\\u00a0               file << p << std::endl;\\n\\u00a0             file.close();\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         rpe.reinit(unmatched_points, tria, mapping);\\n\\u00a0 \\n\\u00a0         AssertThrow(rpe.all_points_found(),\\n\\u00a0                     ExcMessage(\\\"Processed point is outside domain.\\\"));\\n\\u00a0 \\n\\u00a0         const auto eval_values =\\n\\u00a0           VectorTools::point_values<1>(rpe, dof_handler, signed_distance);\\n\\u00a0 \\n\\u00a0         const auto eval_gradient =\\n\\u00a0           VectorTools::point_gradients<1>(rpe, dof_handler, signed_distance);\\n\\u00a0 \\n\\u00a0         std::vector<unsigned int> unmatched_points_idx_next;\\n\\u00a0 \\n\\u00a0         for (unsigned int i = 0; i < unmatched_points_idx.size(); ++i)\\n\\u00a0           if (std::abs(eval_values[i]) > tol_distance)\\n\\u00a0             {\\n\\u00a0               closest_points[unmatched_points_idx[i]] -=\\n\\u00a0                 eval_values[i] * eval_gradient[i];\\n\\u00a0 \\n\\u00a0               unmatched_points_idx_next.emplace_back(unmatched_points_idx[i]);\\n\\u00a0             }\\n\\u00a0 \\n\\u00a0         unmatched_points_idx.swap(unmatched_points_idx_next);\\n\\u00a0 \\n\\u00a0         n_unmatched_points =\\n\\u00a0           Utilities::MPI::sum(unmatched_points_idx.size(), MPI_COMM_WORLD);\\n\\u00a0 \\n\\u00a0         pcout << \\\" -> \\\" << n_unmatched_points << std::endl;\\n\\u00a0       }\\n\\u00a0 \\nUtilities::MPI::reduceT reduce(const T &local_value, const MPI_Comm comm, const std::function< T(const T &, const T &)> &combiner, const unsigned int root_process=0)\\nstd::abs::VectorizedArray< Number, width > abs(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6927\\nWe print a warning message if we exceed the maximum number of allowed iterations and if there are still projection points with a distance value exceeding the tolerance.\\n\\u00a0     if (n_unmatched_points > 0)\\n\\u00a0       pcout << \\\"WARNING: The tolerance of \\\" << n_unmatched_points\\n\\u00a0             << \\\" points is not yet attained.\\\" << std::endl;\\n\\u00a0 \\nAs a result, we obtain a list of support points and corresponding closest points at the zero-isosurface level set. This information can be used to update the signed distance function, i.e., the reinitialization the values of the level-set function to maintain the signed distance property [116].\\n\\u00a0     pcout << \\\"  - determine distance in narrow band\\\" << std::endl;\\n\\u00a0     LinearAlgebra::distributed::Vector<double> solution_distance;\\n\\u00a0     solution_distance.reinit(solution);\\n\\u00a0 \\n\\u00a0     for (unsigned int i = 0; i < closest_points.size(); ++i)\\n\\u00a0       solution_distance[support_points_idx[i]] =\\n\\u00a0         support_points[i].distance(closest_points[i]);\\n\\u00a0 \\nIn addition, we use the information of the closest point to extrapolate values from the interface, i.e., the zero-level set isosurface, to the support points within the narrow band. This might be helpful to improve accuracy, e.g., for diffuse interface fluxes where certain quantities are only accurately determined at the interface (e.g. curvature for surface tension [67]).\\n\\u00a0     pcout << \\\"  - perform extrapolation in narrow band\\\" << std::endl;\\n\\u00a0     rpe.reinit(closest_points, tria, mapping);\\n\\u00a0     solution.update_ghost_values();\\n\\u00a0     const auto vals = VectorTools::point_values<1>(rpe, dof_handler, solution);\\n\\u00a0 \\n\\u00a0     LinearAlgebra::distributed::Vector<double> solution_extrapolated;\\n\\u00a0     solution_extrapolated.reinit(solution);\\n\\u00a0 \\n\\u00a0     for (unsigned int i = 0; i < closest_points.size(); ++i)\\n\\u00a0       solution_extrapolated[support_points_idx[i]] = vals[i];\\n\\u00a0 \\nFinally, we output the results to a VTU file.\\n\\u00a0     pcout << \\\"  - output results\\\" << std::endl;\\n\\u00a0     DataOut<dim> data_out;\\n\\u00a0     data_out.add_data_vector(dof_handler, signed_distance, \\\"signed_distance\\\");\\n\\u00a0     data_out.add_data_vector(dof_handler, solution, \\\"solution\\\");\\n\\u00a0     data_out.add_data_vector(dof_handler,\\n\\u00a0                              solution_distance,\\n\\u00a0                              \\\"solution_distance\\\");\\n\\u00a0     data_out.add_data_vector(dof_handler,\\n\\u00a0                              solution_extrapolated,\\n\\u00a0                              \\\"solution_extrapolated\\\");\\n\\u00a0     data_out.build_patches(mapping);\\n\\u00a0     data_out.write_vtu_in_parallel(\\\"example_2.vtu\\\", MPI_COMM_WORLD);\\n\\u00a0 \\n\\u00a0     pcout << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n Mini example 3: Sharp interface method on the example of surface tension for front tracking\\nThe final mini example presents a basic implementation of front tracking [174], [204] of a surface mesh \\\\(\\\\mathbb{T}_\\\\Gamma\\\\) immersed in a Eulerian background fluid mesh \\\\(\\\\mathbb{T}_\\\\Omega\\\\).\\nWe assume that the immersed surface is transported according to a prescribed velocity field from the background mesh. Subsequently, we perform a sharp computation of the surface-tension force:            \\n\\\\[\\n   (\\\\boldsymbol v_i (\\\\boldsymbol{x}), \\\\boldsymbol F_S\\n   (\\\\boldsymbol{x}))_{\\\\Omega}\\n   =\\n   \\\\left( \\\\boldsymbol{v}_i (\\\\boldsymbol{x}), \\\\sigma (\\\\boldsymbol{x}) \\\\kappa\\n   (\\\\boldsymbol{x}) \\\\boldsymbol{n} (\\\\boldsymbol{x}) \\\\right)_\\\\Gamma \\\\approx\\n   \\\\sum_{q\\\\in\\\\mathbb{T}_\\\\Gamma} \\\\boldsymbol{v}_i^T (\\\\boldsymbol{x}_q)\\n   \\\\sigma (\\\\boldsymbol{x}_q) \\\\kappa (\\\\boldsymbol{x}_q) \\\\boldsymbol{n}\\n   (\\\\boldsymbol{x}_q) |J(\\\\boldsymbol{x}_q)| w(\\\\boldsymbol{x}_q) \\\\quad \\\\forall\\n   i\\\\in\\\\mathbb{T}_\\\\Omega\\n   .\\n   \\\\]\\n\\n We decompose this operation into two steps. In the first step, we evaluate the force contributions   \\\\(\\\\sigma (\\\\boldsymbol{x}_q) \\\\kappa\\n   (\\\\boldsymbol{x}_q) \\\\boldsymbol{n}\\n   (\\\\boldsymbol{x}_q)\\\\) at the quadrature points defined on the immersed mesh and multiply them with the mapped quadrature weight  \\\\(|J(\\\\boldsymbol{x}_q)|\\n   w_q\\\\):     \\n\\\\[\\n   \\\\boldsymbol{F}_S (\\\\boldsymbol{x}_q) \\\\gets \\\\sigma (\\\\boldsymbol{x}_q) \\\\kappa\\n   (\\\\boldsymbol{x}_q) \\\\boldsymbol{n} (\\\\boldsymbol{x}_q) |J(\\\\boldsymbol{x}_q)|\\n   w_q \\\\quad \\\\forall q\\\\in\\\\mathbb{T}_\\\\Gamma.\\n   \\\\]\\n\\n In the second step, we compute the discretized weak form by multiplying with test functions on the background mesh:        \\n\\\\[\\n   (\\\\boldsymbol v_i (\\\\boldsymbol{x}), \\\\boldsymbol F_S\\n   (\\\\boldsymbol{x}))_{\\\\Omega} \\\\gets \\\\sum_q \\\\boldsymbol{v}_i^T\\n   (\\\\boldsymbol{x}_q) \\\\boldsymbol{F}_S\\n   (\\\\boldsymbol{x}_q)\\n   \\\\quad \\\\forall i\\\\in\\\\mathbb{T}_\\\\Omega\\n   .\\n   \\\\]\\n\\n Obviously, we need to communicate between the two steps. The second step can be handled completely by Utilities::MPI::RemotePointEvaluation, which provides the function Utilities::MPI::RemotePointEvaluation::process_and_evaluate() for this purpose.\\nWe start with setting the parameters consisting of the polynomial degree of the shape functions, the dimension of the background mesh, the time-step size to be considered for transporting the surface mesh and the number of time steps.\\n\\u00a0   void example_3()\\n\\u00a0   {\\n\\u00a0     constexpr unsigned int degree       = 3;\\n\\u00a0     constexpr unsigned int dim          = 2;\\n\\u00a0     const double           dt           = 0.01;\\n\\u00a0     const unsigned int     n_time_steps = 200;\\n\\u00a0 \\nThis program is intended to be executed in 2D or 3D.\\n\\u00a0     static_assert(dim == 2 || dim == 3, \\\"Only implemented for 2D or 3D.\\\");\\n\\u00a0 \\n\\u00a0     ConditionalOStream pcout(std::cout,\\n\\u00a0                              Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) ==\\n\\u00a0                                0);\\n\\u00a0 \\n\\u00a0     pcout << \\\"Running: example 3\\\" << std::endl;\\n\\u00a0 \\nNext, we create the standard objects necessary for the finite element representation of the background mesh\\n\\u00a0     pcout << \\\"  - creating background mesh\\\" << std::endl;\\n\\u00a0     DistributedTriangulation<dim> tria_background(MPI_COMM_WORLD);\\n\\u00a0     GridGenerator::hyper_cube(tria_background);\\n\\u00a0     tria_background.refine_global(5);\\n\\u00a0 \\n\\u00a0     MappingQ1<dim>      mapping_background;\\n\\u00a0     const FESystem<dim> fe_background(FE_Q<dim>(degree), dim);\\n\\u00a0     DoFHandler<dim>     dof_handler_background(tria_background);\\n\\u00a0     dof_handler_background.distribute_dofs(fe_background);\\n\\u00a0 \\nFESystemDefinition fe_system.h:208\\nGridGenerator::hyper_cubevoid hyper_cube(Triangulation< dim, spacedim > &tria, const double left=0., const double right=1., const bool colorize=false)\\nand, similarly, for the immersed surface mesh. We use a sphere with radius \\\\(r=0.75\\\\) which is placed in the center of the top half of the cubic background domain.\\n\\u00a0     pcout << \\\"  - creating immersed mesh\\\" << std::endl;\\n\\u00a0     const Point<dim> center((dim == 2) ? Point<dim>(0.5, 0.75) :\\n\\u00a0                                          Point<dim>(0.5, 0.75, 0.5));\\n\\u00a0     const double     radius = 0.15;\\n\\u00a0 \\n\\u00a0     DistributedTriangulation<dim - 1, dim> tria_immersed(MPI_COMM_WORLD);\\n\\u00a0     GridGenerator::hyper_sphere(tria_immersed, center, radius);\\n\\u00a0     tria_immersed.refine_global(4);\\n\\u00a0 \\ncenterPoint< 3 > centerDefinition data_out_base.cc:267\\nGridGenerator::hyper_spherevoid hyper_sphere(Triangulation< spacedim - 1, spacedim > &tria, const Point< spacedim > &center=Point< spacedim >(), const double radius=1.)\\nTwo different mappings are considered for the immersed surface mesh: one valid for the initial configuration and one that is updated in every time step according to the nodal displacements. Two types of finite elements are used to represent scalar and vector-valued DoF values.\\n\\u00a0     MappingQ<dim - 1, dim>      mapping_immersed_base(3);\\n\\u00a0     MappingQCache<dim - 1, dim> mapping_immersed(3);\\n\\u00a0     mapping_immersed.initialize(mapping_immersed_base, tria_immersed);\\n\\u00a0     const QGauss<dim - 1> quadrature_immersed(degree + 1);\\n\\u00a0 \\n\\u00a0     const FE_Q<dim - 1, dim>     fe_scalar_immersed(degree);\\n\\u00a0     const FESystem<dim - 1, dim> fe_immersed(fe_scalar_immersed, dim);\\n\\u00a0     DoFHandler<dim - 1, dim>     dof_handler_immersed(tria_immersed);\\n\\u00a0     dof_handler_immersed.distribute_dofs(fe_immersed);\\n\\u00a0 \\nMappingQCacheDefinition mapping_q_cache.h:54\\nMappingQDefinition mapping_q.h:110\\nQGaussDefinition quadrature_lib.h:40\\nWe renumber the DoFs related to the vector-valued problem to simplify access to the individual components.\\n\\u00a0     DoFRenumbering::support_point_wise(dof_handler_immersed);\\n\\u00a0 \\nDoFRenumbering::support_point_wisevoid support_point_wise(DoFHandler< dim, spacedim > &dof_handler)Definition dof_renumbering.cc:2256\\nWe fill a DoF vector on the background mesh with an analytical velocity field considering the Rayleigh-Kothe vortex flow and initialize a DoF vector for the weak form of the surface-tension force.\\n\\u00a0     LinearAlgebra::distributed::Vector<double> velocity;\\n\\u00a0     velocity.reinit(dof_handler_background.locally_owned_dofs(),\\n\\u00a0                     DoFTools::extract_locally_active_dofs(\\n\\u00a0                       dof_handler_background),\\n\\u00a0                     MPI_COMM_WORLD);\\n\\u00a0     Functions::RayleighKotheVortex<dim> vortex(2);\\n\\u00a0 \\n\\u00a0     LinearAlgebra::distributed::Vector<double> force_vector(\\n\\u00a0       dof_handler_background.locally_owned_dofs(),\\n\\u00a0       DoFTools::extract_locally_active_dofs(dof_handler_background),\\n\\u00a0       MPI_COMM_WORLD);\\n\\u00a0 \\nFunctions::RayleighKotheVortexDefinition function_lib.h:1813\\nNext, we collect the real positions \\\\(\\\\boldsymbol{x}_q\\\\) of the quadrature points of the surface mesh in a vector.\\n\\u00a0     LinearAlgebra::distributed::Vector<double> immersed_support_points;\\n\\u00a0     collect_support_points(mapping_immersed,\\n\\u00a0                            dof_handler_immersed,\\n\\u00a0                            immersed_support_points);\\n\\u00a0 \\nWe initialize a Utilities::MPI::RemotePointEvaluation object and start the time loop. For any other step than the initial one, we first move the support points of the surface mesh according to the fluid velocity of the background mesh. Thereto, we first update the time of the velocity function. Then, we update the internal data structures of the Utilities::MPI::RemotePointEvaluation object with the collected support points of the immersed mesh. We throw an exception if one of the points cannot be found within the domain of the background mesh. Next, we evaluate the velocity at the surface-mesh support points and compute the resulting update of the coordinates. Finally, we update the mapping of the immersed surface mesh to the current position.\\n\\u00a0     Utilities::MPI::RemotePointEvaluation<dim> rpe;\\n\\u00a0     double                                     time = 0.0;\\n\\u00a0     for (unsigned int it = 0; it <= n_time_steps; ++it, time += dt)\\n\\u00a0       {\\n\\u00a0         pcout << \\\"time: \\\" << time << std::endl;\\n\\u00a0         if (it > 0)\\n\\u00a0           {\\n\\u00a0             pcout << \\\"  - move support points (immersed mesh)\\\" << std::endl;\\n\\u00a0             vortex.set_time(time);\\n\\u00a0             VectorTools::interpolate(mapping_background,\\n\\u00a0                                      dof_handler_background,\\n\\u00a0                                      vortex,\\n\\u00a0                                      velocity);\\n\\u00a0             rpe.reinit(convert<dim>(immersed_support_points),\\n\\u00a0                        tria_background,\\n\\u00a0                        mapping_background);\\n\\u00a0 \\n\\u00a0             AssertThrow(rpe.all_points_found(),\\n\\u00a0                         ExcMessage(\\n\\u00a0                           \\\"Immersed domain leaves background domain!\\\"));\\n\\u00a0 \\n\\u00a0             velocity.update_ghost_values();\\n\\u00a0             const auto immersed_velocity =\\n\\u00a0               VectorTools::point_values<dim>(rpe,\\n\\u00a0                                              dof_handler_background,\\n\\u00a0                                              velocity);\\n\\u00a0             velocity.zero_out_ghost_values();\\n\\u00a0 \\n\\u00a0             for (unsigned int i = 0, c = 0;\\n\\u00a0                  i < immersed_support_points.locally_owned_size() / dim;\\n\\u00a0                  ++i)\\n\\u00a0               for (unsigned int d = 0; d < dim; ++d, ++c)\\n\\u00a0                 immersed_support_points.local_element(c) +=\\n\\u00a0                   immersed_velocity[i][d] * dt;\\n\\u00a0 \\n\\u00a0             mapping_immersed.initialize(mapping_immersed_base,\\n\\u00a0                                         dof_handler_immersed,\\n\\u00a0                                         immersed_support_points,\\n\\u00a0                                         false);\\n\\u00a0           }\\n\\u00a0 \\nNext, we loop over all locally owned cells of the immersed mesh and its quadrature points to compute the value for the local surface tension force contribution \\\\(\\\\boldsymbol{F}_S(\\\\boldsymbol{x}_q)\\\\). We store the real coordinates of the quadrature points and the corresponding force contributions in two individual vectors. For computation of the latter, the normal vector \\\\(\\\\boldsymbol{n}(\\\\boldsymbol{x}_q)\\\\) can be directly extracted from the surface mesh via FEValues and, for the curvature, we use the following approximation:              \\n\\\\[\\n   \\\\kappa(\\\\boldsymbol{x}_q)\\n   =\\n   \\\\nabla \\\\cdot \\\\boldsymbol{n}(\\\\boldsymbol{x}_q)\\n   =\\n   \\\\text{tr}\\\\left({\\\\nabla \\\\boldsymbol{n}(\\\\boldsymbol{x}_q)}\\\\right)\\n   \\\\approx\\n   \\\\text{tr}\\\\left({\\\\nabla \\\\sum_i \\\\boldsymbol{N}_i (\\\\boldsymbol{x}_q)\\n   \\\\boldsymbol n_i}\\\\right)\\n   =\\n   \\\\sum_i\\\\text{tr}\\\\left({\\\\nabla \\\\boldsymbol{N}_i (\\\\boldsymbol{x}_q)\\n   \\\\boldsymbol n_i}\\\\right)\\n   \\\\;\\\\text{with}\\\\; i\\\\in[0,n_{\\\\text{dofs\\\\_per\\\\_cell}}),\\n   \\\\]\\n\\n which we can apply since the immersed mesh is consistently orientated. The surface tension coefficient is set to 1 for the sake of demonstration.\\n\\u00a0         pcout << \\\"  - compute to be tested values (immersed mesh)\\\" << std::endl;\\n\\u00a0         using value_type = Tensor<1, dim, double>;\\n\\u00a0 \\n\\u00a0         std::vector<Point<dim>> integration_points;\\n\\u00a0         std::vector<value_type> integration_values;\\n\\u00a0 \\n\\u00a0         FEValues<dim - 1, dim> fe_values(mapping_immersed,\\n\\u00a0                                          fe_immersed,\\n\\u00a0                                          quadrature_immersed,\\n\\u00a0                                          update_JxW_values | update_gradients |\\n\\u00a0                                            update_normal_vectors |\\n\\u00a0                                            update_quadrature_points);\\n\\u00a0 \\n\\u00a0         FEValues<dim - 1, dim> fe_values_co(\\n\\u00a0           mapping_immersed,\\n\\u00a0           fe_scalar_immersed,\\n\\u00a0           fe_scalar_immersed.get_unit_support_points(),\\n\\u00a0           update_JxW_values | update_normal_vectors);\\n\\u00a0 \\n\\u00a0         std::vector<unsigned int> component_to_system_index(\\n\\u00a0           fe_immersed.n_dofs_per_cell());\\n\\u00a0 \\n\\u00a0         for (unsigned int i = 0, c = 0;\\n\\u00a0              i < fe_scalar_immersed.n_dofs_per_cell();\\n\\u00a0              ++i)\\n\\u00a0           for (unsigned int d = 0; d < dim; ++d, ++c)\\n\\u00a0             component_to_system_index[c] =\\n\\u00a0               fe_immersed.component_to_system_index(d, i);\\n\\u00a0 \\n\\u00a0         for (const auto &cell : tria_immersed.active_cell_iterators() |\\n\\u00a0                                   IteratorFilters::LocallyOwnedCell())\\n\\u00a0           {\\n\\u00a0             fe_values.reinit(cell);\\n\\u00a0             fe_values_co.reinit(cell);\\n\\u00a0 \\n\\u00a0             for (const auto &q : fe_values.quadrature_point_indices())\\n\\u00a0               {\\n\\u00a0                 integration_points.emplace_back(fe_values.quadrature_point(q));\\n\\u00a0 \\n\\u00a0                 const auto sigma = 1.0; // surface tension coefficient\\n\\u00a0 \\n\\u00a0                 const auto normal    = fe_values.normal_vector(q);\\n\\u00a0                 double     curvature = 0;\\n\\u00a0                 for (unsigned int i = 0, c = 0;\\n\\u00a0                      i < fe_scalar_immersed.n_dofs_per_cell();\\n\\u00a0                      ++i)\\n\\u00a0                   for (unsigned int d = 0; d < dim; ++d, ++c)\\n\\u00a0                     curvature += fe_values.shape_grad_component(\\n\\u00a0                                    component_to_system_index[c], q, d)[d] *\\n\\u00a0                                  fe_values_co.normal_vector(i)[d];\\n\\u00a0 \\n\\u00a0                 const auto FxJxW =\\n\\u00a0                   sigma * curvature * normal * fe_values.JxW(q);\\n\\u00a0 \\n\\u00a0                 integration_values.emplace_back(FxJxW);\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0 \\nTensorDefinition tensor.h:471\\nupdate_normal_vectors@ update_normal_vectorsNormal vectors.Definition fe_update_flags.h:141\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nIteratorFiltersDefinition filtered_iterator.h:54\\nBefore we evaluate the weak form of the surface-tension force, the communication pattern of Utilities::MPI::RemotePointEvaluation is set up from the quadrature points of the immersed mesh, determining the surrounding cells on the background mesh.\\n\\u00a0         pcout << \\\"  - test values (background mesh)\\\" << std::endl;\\n\\u00a0 \\n\\u00a0         rpe.reinit(integration_points, tria_background, mapping_background);\\n\\u00a0 \\nIn preparation for utilizing Utilities::MPI::RemotePointEvaluation::process_and_evaluate that performs the multiplication with the test function, we set up a callback function that contains the operation on the intersected cells of the background mesh. Within this function, we initialize a FEPointEvaluation object that allows us to integrate values at arbitrary points within a cell. We loop over the cells that surround quadrature points of the immersed mesh \\u2013 provided by the callback function. From the provided CellData object, we retrieve the unit points, i.e., the quadrature points of the immersed mesh that lie within the current cell and a pointer to the stored values on the current cell (local surface-tension force) for convenience. We reinitialize the data structure of FEPointEvaluation on every cell according to the unit points. Next, we loop over the quadrature points attributed to the cell and submit the local surface-tension force to the FEPointEvaluation object. Via FEPointEvaluation::test_and_sum(), the submitted values are multiplied by the values of the test function and a summation over all given points is performed. Subsequently, the contributions are assembled into the global vector containing the weak form of the surface-tension force.\\n\\u00a0         const auto integration_function = [&](const auto &values,\\n\\u00a0                                               const auto &cell_data) {\\n\\u00a0           FEPointEvaluation<dim, dim> phi_force(mapping_background,\\n\\u00a0                                                 fe_background,\\n\\u00a0                                                 update_values);\\n\\u00a0 \\n\\u00a0           std::vector<double>                  local_values;\\n\\u00a0           std::vector<types::global_dof_index> local_dof_indices;\\n\\u00a0 \\n\\u00a0           for (const auto cell : cell_data.cell_indices())\\n\\u00a0             {\\n\\u00a0               const auto cell_dofs =\\n\\u00a0                 cell_data.get_active_cell_iterator(cell)\\n\\u00a0                   ->as_dof_handler_iterator(dof_handler_background);\\n\\u00a0 \\n\\u00a0               const auto unit_points = cell_data.get_unit_points(cell);\\n\\u00a0               const auto FxJxW       = cell_data.get_data_view(cell, values);\\n\\u00a0 \\n\\u00a0               phi_force.reinit(cell_dofs, unit_points);\\n\\u00a0 \\n\\u00a0               for (const auto q : phi_force.quadrature_point_indices())\\n\\u00a0                 phi_force.submit_value(FxJxW[q], q);\\n\\u00a0 \\n\\u00a0               local_values.resize(cell_dofs->get_fe().n_dofs_per_cell());\\n\\u00a0               phi_force.test_and_sum(local_values, EvaluationFlags::values);\\n\\u00a0 \\n\\u00a0               local_dof_indices.resize(cell_dofs->get_fe().n_dofs_per_cell());\\n\\u00a0               cell_dofs->get_dof_indices(local_dof_indices);\\n\\u00a0               AffineConstraints<double>().distribute_local_to_global(\\n\\u00a0                 local_values, local_dof_indices, force_vector);\\n\\u00a0             }\\n\\u00a0         };\\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nAffineConstraints::distribute_local_to_globalvoid distribute_local_to_global(const InVector &local_vector, const std::vector< size_type > &local_dof_indices, OutVector &global_vector) constDefinition affine_constraints.h:2651\\nThe callback function is passed together with the vector holding the surface-tension force contribution at each quadrature point of the immersed mesh to Utilities::MPI::RemotePointEvaluation::process_and_evaluate. The only missing step is to compress the distributed force vector.\\n\\u00a0         rpe.process_and_evaluate<value_type>(integration_values,\\n\\u00a0                                              integration_function);\\n\\u00a0         force_vector.compress(VectorOperation::add);\\n\\u00a0 \\nVectorOperation::add@ addDefinition vector_operation.h:53\\nAfter every tenth step or at the beginning/end of the time loop, we output the force vector and the velocity of the background mesh to a VTU file. In addition, we also export the geometry of the (deformed) immersed surface mesh to a separate VTU file.\\n\\u00a0         if (it % 10 == 0 || it == n_time_steps)\\n\\u00a0           {\\n\\u00a0             std::vector<\\n\\u00a0               DataComponentInterpretation::DataComponentInterpretation>\\n\\u00a0               vector_component_interpretation(\\n\\u00a0                 dim, DataComponentInterpretation::component_is_part_of_vector);\\n\\u00a0             pcout << \\\"  - write data (background mesh)\\\" << std::endl;\\n\\u00a0             DataOut<dim>          data_out_background;\\n\\u00a0             DataOutBase::VtkFlags flags_background;\\n\\u00a0             flags_background.write_higher_order_cells = true;\\n\\u00a0             data_out_background.set_flags(flags_background);\\n\\u00a0             data_out_background.add_data_vector(\\n\\u00a0               dof_handler_background,\\n\\u00a0               force_vector,\\n\\u00a0               std::vector<std::string>(dim, \\\"force\\\"),\\n\\u00a0               vector_component_interpretation);\\n\\u00a0             data_out_background.add_data_vector(\\n\\u00a0               dof_handler_background,\\n\\u00a0               velocity,\\n\\u00a0               std::vector<std::string>(dim, \\\"velocity\\\"),\\n\\u00a0               vector_component_interpretation);\\n\\u00a0             data_out_background.build_patches(mapping_background, 3);\\n\\u00a0             data_out_background.write_vtu_in_parallel(\\\"example_3_background_\\\" +\\n\\u00a0                                                         std::to_string(it) +\\n\\u00a0                                                         \\\".vtu\\\",\\n\\u00a0                                                       MPI_COMM_WORLD);\\n\\u00a0 \\n\\u00a0             pcout << \\\"  - write mesh (immersed mesh)\\\" << std::endl;\\n\\u00a0             DataOut<dim - 1, dim> data_out_immersed;\\n\\u00a0             data_out_immersed.attach_triangulation(tria_immersed);\\n\\u00a0             data_out_immersed.build_patches(mapping_immersed, 3);\\n\\u00a0             data_out_immersed.write_vtu_in_parallel(\\\"example_3_immersed_\\\" +\\n\\u00a0                                                       std::to_string(it) +\\n\\u00a0                                                       \\\".vtu\\\",\\n\\u00a0                                                     MPI_COMM_WORLD);\\n\\u00a0           }\\n\\u00a0         pcout << std::endl;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\nDataOut_DoFData::attach_triangulationvoid attach_triangulation(const Triangulation< dim, spacedim > &)\\nDataComponentInterpretation::DataComponentInterpretationDataComponentInterpretationDefinition data_component_interpretation.h:47\\nDataComponentInterpretation::component_is_part_of_vector@ component_is_part_of_vectorDefinition data_component_interpretation.h:58\\nDataOutBase::VtkFlagsDefinition data_out_base.h:1127\\nDataOutBase::VtkFlags::write_higher_order_cellsbool write_higher_order_cellsDefinition data_out_base.h:1201\\n Utility functions (definition)\\n\\u00a0   template <int spacedim>\\n\\u00a0   std::vector<Point<spacedim>>\\n\\u00a0   create_points_along_line(const Point<spacedim> &p0,\\n\\u00a0                            const Point<spacedim> &p1,\\n\\u00a0                            const unsigned int     n_subdivisions)\\n\\u00a0   {\\n\\u00a0     Assert(n_subdivisions >= 1, ExcInternalError());\\n\\u00a0 \\n\\u00a0     std::vector<Point<spacedim>> points;\\n\\u00a0     points.reserve(n_subdivisions + 1);\\n\\u00a0 \\n\\u00a0     points.emplace_back(p0);\\n\\u00a0     for (unsigned int i = 1; i < n_subdivisions; ++i)\\n\\u00a0       points.emplace_back(p0 + (p1 - p0) * static_cast<double>(i) /\\n\\u00a0                                  static_cast<double>(n_subdivisions));\\n\\u00a0     points.emplace_back(p1);\\n\\u00a0 \\n\\u00a0     return points;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <int spacedim, typename T0, typename T1>\\n\\u00a0   void print_along_line(const std::string                  &file_name,\\n\\u00a0                         const std::vector<Point<spacedim>> &points,\\n\\u00a0                         const std::vector<T0>              &values_0,\\n\\u00a0                         const std::vector<T1>              &values_1)\\n\\u00a0   {\\n\\u00a0     AssertThrow(points.size() == values_0.size() &&\\n\\u00a0                   (values_1.size() == points.size() || values_1.empty()),\\n\\u00a0                 ExcMessage(\\\"The provided vectors must have the same length.\\\"));\\n\\u00a0 \\n\\u00a0     std::ofstream file(file_name);\\n\\u00a0 \\n\\u00a0     for (unsigned int i = 0; i < points.size(); ++i)\\n\\u00a0       {\\n\\u00a0         file << std::fixed << std::right << std::setw(5) << std::setprecision(3)\\n\\u00a0              << points[0].distance(points[i]);\\n\\u00a0 \\n\\u00a0         for (unsigned int d = 0; d < spacedim; ++d)\\n\\u00a0           file << std::fixed << std::right << std::setw(10)\\n\\u00a0                << std::setprecision(3) << points[i][d];\\n\\u00a0 \\n\\u00a0         file << std::fixed << std::right << std::setw(10)\\n\\u00a0              << std::setprecision(3) << values_0[i];\\n\\u00a0 \\n\\u00a0         if (!values_1.empty())\\n\\u00a0           file << std::fixed << std::right << std::setw(10)\\n\\u00a0                << std::setprecision(3) << values_1[i];\\n\\u00a0         file << std::endl;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <int dim, int spacedim>\\n\\u00a0   void collect_support_points(\\n\\u00a0     const Mapping<dim, spacedim>               &mapping,\\n\\u00a0     const DoFHandler<dim, spacedim>            &dof_handler,\\n\\u00a0     LinearAlgebra::distributed::Vector<double> &support_points)\\n\\u00a0   {\\n\\u00a0     support_points.reinit(dof_handler.locally_owned_dofs(),\\n\\u00a0                           DoFTools::extract_locally_active_dofs(dof_handler),\\n\\u00a0                           dof_handler.get_communicator());\\n\\u00a0 \\n\\u00a0     const auto &fe = dof_handler.get_fe();\\n\\u00a0 \\n\\u00a0     FEValues<dim, spacedim> fe_values(\\n\\u00a0       mapping,\\n\\u00a0       fe,\\n\\u00a0       fe.base_element(0).get_unit_support_points(),\\n\\u00a0       update_quadrature_points);\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(\\n\\u00a0       fe.n_dofs_per_cell());\\n\\u00a0 \\n\\u00a0     std::vector<unsigned int> component_to_system_index(\\n\\u00a0       fe_values.n_quadrature_points * spacedim);\\n\\u00a0 \\n\\u00a0     for (unsigned int q = 0, c = 0; q < fe_values.n_quadrature_points; ++q)\\n\\u00a0       for (unsigned int d = 0; d < spacedim; ++d, ++c)\\n\\u00a0         component_to_system_index[c] = fe.component_to_system_index(d, q);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators() |\\n\\u00a0                               IteratorFilters::LocallyOwnedCell())\\n\\u00a0       {\\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0 \\n\\u00a0         for (unsigned int q = 0, c = 0; q < fe_values.n_quadrature_points; ++q)\\n\\u00a0           for (unsigned int d = 0; d < spacedim; ++d, ++c)\\n\\u00a0             support_points[local_dof_indices[component_to_system_index[c]]] =\\n\\u00a0               fe_values.quadrature_point(q)[d];\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <int dim, int spacedim, typename T>\\n\\u00a0   std::tuple<std::vector<Point<spacedim>>, std::vector<types::global_dof_index>>\\n\\u00a0   collect_support_points_with_narrow_band(\\n\\u00a0     const Mapping<dim, spacedim>                &mapping,\\n\\u00a0     const DoFHandler<dim, spacedim>             &dof_handler_signed_distance,\\n\\u00a0     const LinearAlgebra::distributed::Vector<T> &signed_distance,\\n\\u00a0     const DoFHandler<dim, spacedim>             &dof_handler_support_points,\\n\\u00a0     const double                                 narrow_band_threshold)\\n\\u00a0   {\\n\\u00a0     AssertThrow(narrow_band_threshold >= 0,\\n\\u00a0                 ExcMessage(\\\"The narrow band threshold\\\"\\n\\u00a0                            \\\" must be larger than or equal to 0.\\\"));\\n\\u00a0     const auto &tria = dof_handler_signed_distance.get_triangulation();\\n\\u00a0     const Quadrature<dim> quad(dof_handler_support_points.get_fe()\\n\\u00a0                                  .base_element(0)\\n\\u00a0                                  .get_unit_support_points());\\n\\u00a0 \\n\\u00a0     FEValues<dim> distance_values(mapping,\\n\\u00a0                                   dof_handler_signed_distance.get_fe(),\\n\\u00a0                                   quad,\\n\\u00a0                                   update_values);\\n\\u00a0 \\n\\u00a0     FEValues<dim> req_values(mapping,\\n\\u00a0                              dof_handler_support_points.get_fe(),\\n\\u00a0                              quad,\\n\\u00a0                              update_quadrature_points);\\n\\u00a0 \\n\\u00a0     std::vector<T>                       temp_distance(quad.size());\\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(\\n\\u00a0       dof_handler_support_points.get_fe().n_dofs_per_cell());\\n\\u00a0 \\n\\u00a0     std::vector<Point<dim>>              support_points;\\n\\u00a0     std::vector<types::global_dof_index> support_points_idx;\\n\\u00a0 \\n\\u00a0     const bool has_ghost_elements = signed_distance.has_ghost_elements();\\n\\u00a0 \\n\\u00a0     const auto &locally_owned_dofs_req =\\n\\u00a0       dof_handler_support_points.locally_owned_dofs();\\n\\u00a0     std::vector<bool> flags(locally_owned_dofs_req.n_elements(), false);\\n\\u00a0 \\n\\u00a0     if (has_ghost_elements == false)\\n\\u00a0       signed_distance.update_ghost_values();\\n\\u00a0 \\n\\u00a0     for (const auto &cell :\\n\\u00a0          tria.active_cell_iterators() | IteratorFilters::LocallyOwnedCell())\\n\\u00a0       {\\n\\u00a0         const auto cell_distance =\\n\\u00a0           cell->as_dof_handler_iterator(dof_handler_signed_distance);\\n\\u00a0         distance_values.reinit(cell_distance);\\n\\u00a0         distance_values.get_function_values(signed_distance, temp_distance);\\n\\u00a0 \\n\\u00a0         const auto cell_req =\\n\\u00a0           cell->as_dof_handler_iterator(dof_handler_support_points);\\n\\u00a0         req_values.reinit(cell_req);\\n\\u00a0         cell_req->get_dof_indices(local_dof_indices);\\n\\u00a0 \\n\\u00a0         for (const auto q : req_values.quadrature_point_indices())\\n\\u00a0           if (std::abs(temp_distance[q]) < narrow_band_threshold)\\n\\u00a0             {\\n\\u00a0               const auto idx = local_dof_indices[q];\\n\\u00a0 \\n\\u00a0               if (locally_owned_dofs_req.is_element(idx) == false ||\\n\\u00a0                   flags[locally_owned_dofs_req.index_within_set(idx)])\\n\\u00a0                 continue;\\n\\u00a0 \\n\\u00a0               flags[locally_owned_dofs_req.index_within_set(idx)] = true;\\n\\u00a0 \\n\\u00a0               support_points_idx.emplace_back(idx);\\n\\u00a0               support_points.emplace_back(req_values.quadrature_point(q));\\n\\u00a0             }\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     if (has_ghost_elements == false)\\n\\u00a0       signed_distance.zero_out_ghost_values();\\n\\u00a0 \\n\\u00a0     return {support_points, support_points_idx};\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <int spacedim>\\n\\u00a0   std::vector<Point<spacedim>> convert(\\n\\u00a0     const LinearAlgebra::distributed::Vector<double> &support_points_unrolled)\\n\\u00a0   {\\n\\u00a0     const unsigned int n_points =\\n\\u00a0       support_points_unrolled.locally_owned_size() / spacedim;\\n\\u00a0 \\n\\u00a0     std::vector<Point<spacedim>> points(n_points);\\n\\u00a0 \\n\\u00a0     for (unsigned int i = 0, c = 0; i < n_points; ++i)\\n\\u00a0       for (unsigned int d = 0; d < spacedim; ++d, ++c)\\n\\u00a0         points[i][d] = support_points_unrolled.local_element(c);\\n\\u00a0 \\n\\u00a0     return points;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 } // namespace Step87\\n\\u00a0 \\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\nLinearAlgebraDefinition template_constraints.h:615\\nPhysics::Elasticity::Kinematics::dSymmetricTensor< 2, dim, Number > d(const Tensor< 2, dim, Number > &F, const Tensor< 2, dim, Number > &dF_dt)\\n Driver\\nFinally, the driver of the program executes the four mini examples.\\n\\u00a0 int main(int argc, char **argv)\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0   Utilities::MPI::MPI_InitFinalize mpi(argc, argv, 1);\\n\\u00a0   std::cout.precision(5);\\n\\u00a0 \\n\\u00a0   if (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)\\n\\u00a0     Step87::example_0(); // only run on root process\\n\\u00a0 \\n\\u00a0   Step87::example_1();\\n\\u00a0   Step87::example_2();\\n\\u00a0   Step87::example_3();\\n\\u00a0 }\\nUtilities::MPI::MPI_InitFinalizeDefinition mpi.h:1081\\n Results\\nMini example 0\\nWe present a part of the terminal output. It shows, for each point, the determined cell and reference position. Also, one can see that the values evaluated with FEValues, FEPointEvaluation, and VectorTools::point_values() are identical, as expected.\\nRunning: example 0\\n - Found point with real coordinates: 0 0.5\\n   - in cell with vertices: (0 0.4) (0.2 0.4) (0 0.6) (0.2 0.6)\\n   - with coordinates on the unit cell: (0 0.5)\\n - Values at point:\\n  - 0.25002 (w. FEValues)\\n  - 0.25002 (w. FEPointEvaluation)\\n  - 0.25002 (w. VectorTools::point_value())\\n\\n - Found point with real coordinates: 0.05 0.5\\n   - in cell with vertices: (0 0.4) (0.2 0.4) (0 0.6) (0.2 0.6)\\n   - with coordinates on the unit cell: (0.25 0.5)\\n - Values at point:\\n  - 0.20003 (w. FEValues)\\n  - 0.20003 (w. FEPointEvaluation)\\n  - 0.20003 (w. VectorTools::point_value())\\n\\n...\\n\\n - Found point with real coordinates: 1 0.5\\n   - in cell with vertices: (0.8 0.4) (1 0.4) (0.8 0.6) (1 0.6)\\n   - with coordinates on the unit cell: (1 0.5)\\n - Values at point:\\n  - 0.25002 (w. FEValues)\\n  - 0.25002 (w. FEPointEvaluation)\\n  - 0.25002 (w. VectorTools::point_value())\\n\\n - writing csv file\\nThe CSV output is as follows and contains, in the first column, the distances with respect to the first point, the second and the third column represent the coordinates of the points and the fourth column the evaluated solution values at those points.\\n0.000     0.000     0.500     0.250\\n0.050     0.050     0.500     0.200\\n0.100     0.100     0.500     0.150\\n0.150     0.150     0.500     0.100\\n0.200     0.200     0.500     0.050\\n0.250     0.250     0.500     0.000\\n0.300     0.300     0.500    -0.050\\n0.350     0.350     0.500    -0.100\\n0.400     0.400     0.500    -0.149\\n0.450     0.450     0.500    -0.200\\n0.500     0.500     0.500    -0.222\\n0.550     0.550     0.500    -0.200\\n0.600     0.600     0.500    -0.149\\n0.650     0.650     0.500    -0.100\\n0.700     0.700     0.500    -0.050\\n0.750     0.750     0.500     0.000\\n0.800     0.800     0.500     0.050\\n0.850     0.850     0.500     0.100\\n0.900     0.900     0.500     0.150\\n0.950     0.950     0.500     0.200\\n1.000     1.000     0.500     0.250\\nMini example 1\\nWe show the terminal output.\\nRunning: example 1\\n - writing csv file\\nThe CSV output is as follows and identical to the results of the serial case presented in mini example 0. The fifth column shows the user quantity evaluated additionally in this mini example.\\n0.000     0.000     0.500     0.250     0.000\\n0.050     0.050     0.500     0.200     0.050\\n0.100     0.100     0.500     0.150     0.100\\n0.150     0.150     0.500     0.100     0.150\\n0.200     0.200     0.500     0.050     0.200\\n0.250     0.250     0.500     0.000     0.250\\n0.300     0.300     0.500    -0.050     0.300\\n0.350     0.350     0.500    -0.100     0.350\\n0.400     0.400     0.500    -0.149     0.400\\n0.450     0.450     0.500    -0.200     0.450\\n0.500     0.500     0.500    -0.222     0.500\\n0.550     0.550     0.500    -0.200     0.550\\n0.600     0.600     0.500    -0.149     0.600\\n0.650     0.650     0.500    -0.100     0.650\\n0.700     0.700     0.500    -0.050     0.700\\n0.750     0.750     0.500     0.000     0.750\\n0.800     0.800     0.500     0.050     0.800\\n0.850     0.850     0.500     0.100     0.850\\n0.900     0.900     0.500     0.150     0.900\\n0.950     0.950     0.500     0.200     0.950\\n1.000     1.000     0.500     0.250     1.000\\nMini example 2\\nWe show the terminal output. Running: example 2\\n  - create system\\n  - determine narrow band\\n  - determine closest point iteratively\\n    - iteration 0: 7076 -> 7076\\n    - iteration 1: 7076 -> 104\\n    - iteration 2: 104 -> 0\\n  - determine distance in narrow band\\n  - perform extrapolation in narrow band\\n  - output results\\nThe following three plots, representing the performed iterations of the closest-point projection, show the current position of the closest points exceeding the required tolerance of the discrete interface of the circle and still need to be corrected. It can be seen that the numbers of points to be processed decrease from iteration to iteration. \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nThe output visualized in Paraview looks like the following: On the left, the original distance function is shown as the light gray surface. In addition, the contour values refer to the distance values determined from calculation of the distance to the closest points at the interface in the narrow band. It can be seen that the two functions coincide. Similarly, on the right, the original solution and the extrapolated solution from the interface is shown.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nMini example 3\\nWe show a shortened version of the terminal output.\\nRunning: example 3\\n  - creating background mesh\\n  - creating immersed mesh\\ntime: 0\\n  - compute to be tested values (immersed mesh)\\n  - test values (background mesh)\\n  - write data (background mesh)\\n  - write mesh (immersed mesh)\\n\\ntime: 0.01\\n  - move support points (immersed mesh)\\n  - compute to be tested values (immersed mesh)\\n  - test values (background mesh)\\n\\ntime: 0.02\\n  - move support points (immersed mesh)\\n  - compute to be tested values (immersed mesh)\\n  - test values (background mesh)\\n\\n...\\n\\ntime: 2\\n  - move support points (immersed mesh)\\n  - compute to be tested values (immersed mesh)\\n  - test values (background mesh)\\n  - write data (background mesh)\\n  - write mesh (immersed mesh)\\nThe output visualized in Paraview looks like the following: The deformation of the immersed mesh by the reversible vortex flow can be seen. Due to discretization errors, the shape is not exactly circular at the end, illustrated in the right figure. The sharp nature of the surface-tension force vector, shown as vector plots, can be seen by its restriction to cells that are intersected by the immersed mesh.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nPossibilities for extension\\nThis program highlights some of the main capabilities of the distributed evaluation routines in deal.II. However, there are many related topics worth mentioning:\\nPerforming a distributed search is an expensive step. That is why we suggest to provide hints to Utilities::MPI::RemotePointEvaluation and to reuse Utilities::MPI::RemotePointEvaluation instances in the case that the communication pattern has not changed. Furthermore, there are instances where no search is needed and the points are already sorted into the right cells. This is the case if the points are generated on the cell level (see step-85; CutFEM) or the points are automatically sorted into the correct (neighboring) cell (see step-68; PIC with Particles::ParticleHandler). Having said that, the Particles::ParticleHandler::insert_global_particles() function uses the described infrastructure to perform the initial sorting of particles into cells.\\nWe concentrated on parallelization aspects in this tutorial. However, we would like to point out the need for fast evaluation on cell level. The task for this in deal.II is FEPointEvaluation. It exploits the structure of   \\n\\\\[\\n\\\\hat{u}(\\\\hat{\\\\boldsymbol{x}}) = \\\\sum_i \\\\hat{N}_i(\\\\hat{\\\\boldsymbol{x}}) \\\\hat{u}_i\\n\\\\]\\n\\n to derive fast implementations, e.g., for tensor-product elements       \\n\\\\[\\n\\\\hat{u}(\\\\hat{x}_0, \\\\hat{x}_1, \\\\hat{x}_2) =\\n\\\\sum_k \\\\hat{N}^{\\\\text{1D}}_k(\\\\hat{x}_2)\\n\\\\sum_j \\\\hat{N}^{\\\\text{1D}}_j(\\\\hat{x}_1)\\n\\\\sum_i \\\\hat{N}^{\\\\text{1D}}_i(\\\\hat{x}_0)\\n\\\\hat{u}_{ijk}.\\n\\\\]\\n\\n Since only 1D shape functions are queried and are re-used in re-occurring terms, this formulation is faster than without exploitation of the structure.\\nUtilities::MPI::RemotePointEvaluation is used in multiple places in deal.II. The class DataOutResample allows to output results on a different mesh than the computational mesh. This is useful if one wants to output the results on a coarser mesh or one does not want to output 3D results but instead 2D slices. In addition, MGTwoLevelTransferNonNested allows to prolongate solutions and restrict residuals between two independent meshes. By passing a sequence of such two-level transfer operators to MGTransferMF and, finally, to Multigrid, non-nested multigrid can be computed.\\nUtilities::MPI::RemotePointEvaluation can be used to couple non-matching grids via surfaces (example: fluid-structure interaction, independently created grids). The evaluation points can come from any side (pointwise interpolation) or are defined on intersected meshes (Nitsche-type mortaring [112]). Concerning the creation of such intersected meshes and the corresponding evaluation points, see GridTools::internal::distributed_compute_intersection_locations().\\nAlternatively to the coupling via Utilities::MPI::RemotePointEvaluation, preCICE [49] [56] can be used. The code-gallery program \\\"Laplace equation coupled to an external simulation\\nprogram\\\" shows how to use this library with deal.II.\\n\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2023 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n *\\n * Authors: Magdalena Schreter-Fleischhacker, Technical University of\\n *          Munich, 2023\\n *          Peter Munch, University of Augsburg, 2023\\n */\\n \\n#include <deal.II/base/conditional_ostream.h>\\n#include <deal.II/base/function_lib.h>\\n#include <deal.II/base/function_signed_distance.h>\\n#include <deal.II/base/mpi.h>\\n#include <deal.II/base/mpi.templates.h>\\n \\n#include <deal.II/distributed/tria.h>\\n \\n#include <deal.II/dofs/dof_renumbering.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/fe/fe_nothing.h>\\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_system.h>\\n#include <deal.II/fe/mapping_q1.h>\\n#include <deal.II/fe/mapping_q_cache.h>\\n \\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_tools.h>\\n \\n#include <deal.II/lac/generic_linear_algebra.h>\\n \\n#include <deal.II/numerics/data_out.h>\\n \\n#include <iostream>\\n#include <fstream>\\n \\n#include <deal.II/base/mpi_remote_point_evaluation.h>\\n#include <deal.II/numerics/vector_tools.h>\\n \\n#include <deal.II/matrix_free/fe_point_evaluation.h>\\n \\n \\nnamespace Step87\\n{\\n using namespace dealii;\\n \\n#ifdef DEAL_II_WITH_P4EST\\n template <int dim, int spacedim = dim>\\n using DistributedTriangulation = typename std::conditional_t<\\n    dim == 1,\\n parallel::shared::Triangulation<dim, spacedim>,\\n parallel::distributed::Triangulation<dim, spacedim>>;\\n#else\\n template <int dim, int spacedim = dim>\\n using DistributedTriangulation =\\n parallel::shared::Triangulation<dim, spacedim>;\\n#endif\\n \\n template <int spacedim>\\n  std::vector<Point<spacedim>>\\n  create_points_along_line(const Point<spacedim> &p0,\\n const Point<spacedim> &p1,\\n const unsigned int     n_subdivisions);\\n \\n template <int spacedim, typename T0, typename T1 = int>\\n void print_along_line(const std::string                  &file_name,\\n const std::vector<Point<spacedim>> &points,\\n const std::vector<T0>              &values_0,\\n const std::vector<T1>              &values_1 = {});\\n \\n template <int dim, int spacedim>\\n void collect_support_points(\\n const Mapping<dim, spacedim>               &mapping,\\n const DoFHandler<dim, spacedim>            &dof_handler,\\n LinearAlgebra::distributed::Vector<double> &support_points);\\n \\n template <int dim, int spacedim, typename T>\\n  std::tuple<std::vector<Point<spacedim>>, std::vector<types::global_dof_index>>\\n  collect_support_points_with_narrow_band(\\n const Mapping<dim, spacedim>                &mapping,\\n const DoFHandler<dim, spacedim>             &dof_handler_signed_distance,\\n const LinearAlgebra::distributed::Vector<T> &signed_distance,\\n const DoFHandler<dim, spacedim>             &dof_handler_support_points,\\n const double                                 narrow_band_threshold);\\n \\n template <int spacedim>\\n  std::vector<Point<spacedim>> convert(\\n const LinearAlgebra::distributed::Vector<double> &support_points_unrolled);\\n \\n void example_0()\\n  {\\n    std::cout << \\\"Running: example 0\\\" << std::endl;\\n \\n constexpr unsigned int dim       = 2;\\n constexpr unsigned int fe_degree = 3;\\n \\n MappingQ1<dim>     mapping;\\n Triangulation<dim> tria;\\n GridGenerator::subdivided_hyper_cube(tria, 7);\\n \\n const FE_Q<dim> fe(fe_degree);\\n DoFHandler<dim> dof_handler(tria);\\n    dof_handler.distribute_dofs(fe);\\n \\n Vector<double> vector(dof_handler.n_dofs());\\n VectorTools::interpolate(mapping,\\n                             dof_handler,\\n Functions::SignedDistance::Sphere<dim>(\\n                               (dim == 1) ? Point<dim>(0.5) :\\n                               (dim == 2) ? Point<dim>(0.5, 0.5) :\\n Point<dim>(0.5, 0.5, 0.5),\\n                               0.25),\\n                             vector);\\n \\n const auto points_line =\\n      create_points_along_line((dim == 1) ? Point<dim>(0.0) :\\n                               (dim == 2) ? Point<dim>(0.0, 0.5) :\\n Point<dim>(0.0, 0.5, 0.5),\\n                               (dim == 1) ? Point<dim>(1.0) :\\n                               (dim == 2) ? Point<dim>(1.0, 0.5) :\\n Point<dim>(1.0, 0.5, 0.5),\\n                               20);\\n \\n    std::vector<double> values_line;\\n    values_line.reserve(points_line.size());\\n \\n for (const auto &p_real : points_line)\\n      {\\n const auto [cell, p_unit] =\\n GridTools::find_active_cell_around_point(mapping,\\n                                                   dof_handler,\\n                                                   p_real);\\n \\n        {\\n AssertThrow(cell != dof_handler.end(), ExcInternalError());\\n          std::cout << \\\" - Found point with real coordinates: \\\" << p_real\\n                    << std::endl;\\n          std::cout << \\\"   - in cell with vertices:\\\";\\n for (const auto &v : cell->vertex_indices())\\n std::cout << \\\" (\\\" << cell->vertex(v) << \\\")\\\";\\n          std::cout << std::endl;\\n          std::cout << \\\"   - with coordinates on the unit cell: (\\\" << p_unit\\n                    << \\\")\\\" << std::endl;\\n        }\\n \\n        std::cout << \\\" - Values at point:\\\" << std::endl;\\n \\n        {\\n FEValues<dim> fe_values(mapping,\\n                                  fe,\\n Quadrature<dim>(p_unit),\\n update_values);\\n          fe_values.reinit(cell);\\n \\n          std::vector<double> quad_values(1);\\n          fe_values.get_function_values(vector, quad_values);\\n const double value_0 = quad_values[0];\\n          std::cout << \\\"  - \\\" << value_0 << \\\" (w. FEValues)\\\" << std::endl;\\n          values_line.push_back(value_0);\\n        }\\n \\n        {\\n          std::vector<double> cell_vector(fe.n_dofs_per_cell());\\n          cell->get_dof_values(vector, cell_vector.begin(), cell_vector.end());\\n \\n FEPointEvaluation<1, dim> fe_point(mapping, fe, update_values);\\n          fe_point.reinit(cell, ArrayView<const Point<dim>>(p_unit));\\n          fe_point.evaluate(cell_vector, EvaluationFlags::values);\\n const auto value_1 = fe_point.get_value(0);\\n          std::cout << \\\"  - \\\" << value_1 << \\\" (w. FEPointEvaluation)\\\"\\n                    << std::endl;\\n        }\\n \\n        {\\n const auto value_2 =\\n VectorTools::point_value(dof_handler, vector, p_real);\\n          std::cout << \\\"  - \\\" << value_2 << \\\" (w. VectorTools::point_value())\\\"\\n                    << std::endl;\\n          std::cout << std::endl;\\n        }\\n      }\\n \\n    std::cout << \\\" - writing csv file\\\" << std::endl;\\n    print_along_line(\\\"example_0_profile.csv\\\", points_line, values_line);\\n  }\\n \\n void example_1()\\n  {\\n constexpr unsigned int dim       = 2;\\n constexpr unsigned int fe_degree = 3;\\n \\n ConditionalOStream pcout(std::cout,\\n Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) ==\\n                               0);\\n \\n    pcout << \\\"Running: example 1\\\" << std::endl;\\n \\n MappingQ1<dim>                mapping;\\n    DistributedTriangulation<dim> tria(MPI_COMM_WORLD);\\n GridGenerator::subdivided_hyper_cube(tria, 7);\\n \\n const FE_Q<dim> fe(fe_degree);\\n DoFHandler<dim> dof_handler(tria);\\n    dof_handler.distribute_dofs(fe);\\n \\n LinearAlgebra::distributed::Vector<double> signed_distance;\\n    signed_distance.reinit(dof_handler.locally_owned_dofs(),\\n DoFTools::extract_locally_active_dofs(dof_handler),\\n                           MPI_COMM_WORLD);\\n \\n VectorTools::interpolate(mapping,\\n                             dof_handler,\\n Functions::SignedDistance::Sphere<dim>(\\n                               (dim == 1) ? Point<dim>(0.5) :\\n                               (dim == 2) ? Point<dim>(0.5, 0.5) :\\n Point<dim>(0.5, 0.5, 0.5),\\n                               0.25),\\n                             signed_distance);\\n \\n LinearAlgebra::distributed::Vector<double> solution;\\n    solution.reinit(dof_handler.locally_owned_dofs(),\\n DoFTools::extract_locally_active_dofs(dof_handler),\\n                    MPI_COMM_WORLD);\\n \\n VectorTools::interpolate(mapping,\\n                             dof_handler,\\n Functions::SignedDistance::Plane<dim>(\\n Point<dim>(), Point<dim>::unit_vector(0)),\\n                             solution);\\n \\n    std::vector<Point<dim>> profile;\\n if (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)\\n      profile = create_points_along_line((dim == 1) ? Point<dim>(0.0) :\\n                                         (dim == 2) ? Point<dim>(0.0, 0.5) :\\n Point<dim>(0.0, 0.5, 0.5),\\n                                         (dim == 1) ? Point<dim>(1.0) :\\n                                         (dim == 2) ? Point<dim>(1.0, 0.5) :\\n Point<dim>(1.0, 0.5, 0.5),\\n                                         20);\\n \\n Utilities::MPI::RemotePointEvaluation<dim, dim> rpe;\\n \\n    signed_distance.update_ghost_values();\\n const std::vector<double> profile_signed_distance =\\n VectorTools::point_values<1>(\\n        mapping, dof_handler, signed_distance, profile, rpe);\\n \\n const auto evaluate_function = [&](const ArrayView<double> &values,\\n const auto              &cell_data) {\\n FEPointEvaluation<1, dim> fe_point(mapping, fe, update_values);\\n \\n      std::vector<double>                  local_values;\\n      std::vector<types::global_dof_index> local_dof_indices;\\n \\n for (const auto cell : cell_data.cell_indices())\\n        {\\n const auto cell_dofs =\\n            cell_data.get_active_cell_iterator(cell)->as_dof_handler_iterator(\\n              dof_handler);\\n \\n const auto unit_points = cell_data.get_unit_points(cell);\\n const auto local_value = cell_data.get_data_view(cell, values);\\n \\n          local_values.resize(cell_dofs->get_fe().n_dofs_per_cell());\\n          cell_dofs->get_dof_values(solution,\\n                                    local_values.begin(),\\n                                    local_values.end());\\n \\n          fe_point.reinit(cell_dofs, unit_points);\\n          fe_point.evaluate(local_values, EvaluationFlags::values);\\n \\n for (unsigned int q = 0; q < unit_points.size(); ++q)\\n            local_value[q] = fe_point.get_value(q);\\n        }\\n    };\\n \\n    solution.update_ghost_values();\\n \\n const std::vector<double> output =\\n      rpe.evaluate_and_process<double>(evaluate_function);\\n \\n DataOut<dim> data_out;\\n    data_out.add_data_vector(dof_handler, signed_distance, \\\"signed_distance\\\");\\n    data_out.build_patches(mapping);\\n    data_out.write_vtu_in_parallel(\\\"example_1.vtu\\\", MPI_COMM_WORLD);\\n \\n if (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)\\n      {\\n        std::cout << \\\" - writing csv file\\\" << std::endl;\\n        print_along_line(\\\"example_1_profile.csv\\\",\\n                         profile,\\n                         profile_signed_distance,\\n                         output);\\n      }\\n  }\\n \\n void example_2()\\n  {\\n constexpr unsigned int dim       = 2;\\n constexpr unsigned int fe_degree = 3;\\n \\n ConditionalOStream pcout(std::cout,\\n Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) ==\\n                               0);\\n \\n    pcout << \\\"Running: example 2\\\" << std::endl;\\n    pcout << \\\"  - create system\\\" << std::endl;\\n \\n const FE_Q<dim>               fe(fe_degree);\\n MappingQ1<dim>                mapping;\\n    DistributedTriangulation<dim> tria(MPI_COMM_WORLD);\\n GridGenerator::subdivided_hyper_cube(tria, 50);\\n \\n DoFHandler<dim> dof_handler(tria);\\n    dof_handler.distribute_dofs(fe);\\n \\n LinearAlgebra::distributed::Vector<double> solution;\\n    solution.reinit(dof_handler.locally_owned_dofs(),\\n DoFTools::extract_locally_active_dofs(dof_handler),\\n                    MPI_COMM_WORLD);\\n \\n VectorTools::interpolate(mapping,\\n                             dof_handler,\\n Functions::SignedDistance::Plane<dim>(\\n Point<dim>(), Point<dim>::unit_vector(0)),\\n                             solution);\\n \\n LinearAlgebra::distributed::Vector<double> signed_distance;\\n    signed_distance.reinit(dof_handler.locally_owned_dofs(),\\n DoFTools::extract_locally_active_dofs(dof_handler),\\n                           MPI_COMM_WORLD);\\n \\n VectorTools::interpolate(mapping,\\n                             dof_handler,\\n Functions::SignedDistance::Sphere<dim>(\\n                               (dim == 1) ? Point<dim>(0.5) :\\n                               (dim == 2) ? Point<dim>(0.5, 0.5) :\\n Point<dim>(0.5, 0.5, 0.5),\\n                               0.25),\\n                             signed_distance);\\n    signed_distance.update_ghost_values();\\n \\n    pcout << \\\"  - determine narrow band\\\" << std::endl;\\n \\n const auto [support_points, support_points_idx] =\\n      collect_support_points_with_narrow_band(mapping,\\n                                              dof_handler,\\n                                              signed_distance,\\n                                              dof_handler,\\n                                              0.1 /*narrow_band_threshold*/);\\n \\n    pcout << \\\"  - determine closest point iteratively\\\" << std::endl;\\n constexpr int    max_iter     = 30;\\n constexpr double tol_distance = 1e-6;\\n \\n    std::vector<Point<dim>> closest_points = support_points; // initial guess\\n \\n    std::vector<unsigned int> unmatched_points_idx(closest_points.size());\\n    std::iota(unmatched_points_idx.begin(), unmatched_points_idx.end(), 0);\\n \\n int n_unmatched_points =\\n Utilities::MPI::sum(unmatched_points_idx.size(), MPI_COMM_WORLD);\\n \\n Utilities::MPI::RemotePointEvaluation<dim, dim> rpe;\\n \\n for (int it = 0; it < max_iter && n_unmatched_points > 0; ++it)\\n      {\\n        pcout << \\\"    - iteration \\\" << it << \\\": \\\" << n_unmatched_points;\\n \\n        std::vector<Point<dim>> unmatched_points(unmatched_points_idx.size());\\n for (unsigned int i = 0; i < unmatched_points_idx.size(); ++i)\\n          unmatched_points[i] = closest_points[unmatched_points_idx[i]];\\n \\n const auto all_unmatched_points =\\n Utilities::MPI::reduce<std::vector<Point<dim>>>(\\n            unmatched_points, MPI_COMM_WORLD, [](const auto &a, const auto &b) {\\n auto result = a;\\n              result.insert(result.end(), b.begin(), b.end());\\n return result;\\n            });\\n \\n if (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)\\n          {\\n            std::ofstream file(\\\"example_2_\\\" + std::to_string(it) + \\\".csv\\\");\\n for (const auto &p : all_unmatched_points)\\n              file << p << std::endl;\\n            file.close();\\n          }\\n \\n        rpe.reinit(unmatched_points, tria, mapping);\\n \\n AssertThrow(rpe.all_points_found(),\\n                    ExcMessage(\\\"Processed point is outside domain.\\\"));\\n \\n const auto eval_values =\\n VectorTools::point_values<1>(rpe, dof_handler, signed_distance);\\n \\n const auto eval_gradient =\\n VectorTools::point_gradients<1>(rpe, dof_handler, signed_distance);\\n \\n        std::vector<unsigned int> unmatched_points_idx_next;\\n \\n for (unsigned int i = 0; i < unmatched_points_idx.size(); ++i)\\n if (std::abs(eval_values[i]) > tol_distance)\\n            {\\n              closest_points[unmatched_points_idx[i]] -=\\n                eval_values[i] * eval_gradient[i];\\n \\n              unmatched_points_idx_next.emplace_back(unmatched_points_idx[i]);\\n            }\\n \\n        unmatched_points_idx.swap(unmatched_points_idx_next);\\n \\n        n_unmatched_points =\\n Utilities::MPI::sum(unmatched_points_idx.size(), MPI_COMM_WORLD);\\n \\n        pcout << \\\" -> \\\" << n_unmatched_points << std::endl;\\n      }\\n \\n if (n_unmatched_points > 0)\\n      pcout << \\\"WARNING: The tolerance of \\\" << n_unmatched_points\\n            << \\\" points is not yet attained.\\\" << std::endl;\\n \\n    pcout << \\\"  - determine distance in narrow band\\\" << std::endl;\\n LinearAlgebra::distributed::Vector<double> solution_distance;\\n    solution_distance.reinit(solution);\\n \\n for (unsigned int i = 0; i < closest_points.size(); ++i)\\n      solution_distance[support_points_idx[i]] =\\n        support_points[i].distance(closest_points[i]);\\n \\n    pcout << \\\"  - perform extrapolation in narrow band\\\" << std::endl;\\n    rpe.reinit(closest_points, tria, mapping);\\n    solution.update_ghost_values();\\n const auto vals = VectorTools::point_values<1>(rpe, dof_handler, solution);\\n \\n LinearAlgebra::distributed::Vector<double> solution_extrapolated;\\n    solution_extrapolated.reinit(solution);\\n \\n for (unsigned int i = 0; i < closest_points.size(); ++i)\\n      solution_extrapolated[support_points_idx[i]] = vals[i];\\n \\n    pcout << \\\"  - output results\\\" << std::endl;\\n DataOut<dim> data_out;\\n    data_out.add_data_vector(dof_handler, signed_distance, \\\"signed_distance\\\");\\n    data_out.add_data_vector(dof_handler, solution, \\\"solution\\\");\\n    data_out.add_data_vector(dof_handler,\\n                             solution_distance,\\n \\\"solution_distance\\\");\\n    data_out.add_data_vector(dof_handler,\\n                             solution_extrapolated,\\n \\\"solution_extrapolated\\\");\\n    data_out.build_patches(mapping);\\n    data_out.write_vtu_in_parallel(\\\"example_2.vtu\\\", MPI_COMM_WORLD);\\n \\n    pcout << std::endl;\\n  }\\n \\n \\n void example_3()\\n  {\\n constexpr unsigned int degree       = 3;\\n constexpr unsigned int dim          = 2;\\n const double           dt           = 0.01;\\n const unsigned int     n_time_steps = 200;\\n \\n static_assert(dim == 2 || dim == 3, \\\"Only implemented for 2D or 3D.\\\");\\n \\n ConditionalOStream pcout(std::cout,\\n Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) ==\\n                               0);\\n \\n    pcout << \\\"Running: example 3\\\" << std::endl;\\n \\n    pcout << \\\"  - creating background mesh\\\" << std::endl;\\n    DistributedTriangulation<dim> tria_background(MPI_COMM_WORLD);\\n GridGenerator::hyper_cube(tria_background);\\n    tria_background.refine_global(5);\\n \\n MappingQ1<dim>      mapping_background;\\n const FESystem<dim> fe_background(FE_Q<dim>(degree), dim);\\n DoFHandler<dim>     dof_handler_background(tria_background);\\n    dof_handler_background.distribute_dofs(fe_background);\\n \\n    pcout << \\\"  - creating immersed mesh\\\" << std::endl;\\n const Point<dim> center((dim == 2) ? Point<dim>(0.5, 0.75) :\\n Point<dim>(0.5, 0.75, 0.5));\\n const double     radius = 0.15;\\n \\n    DistributedTriangulation<dim - 1, dim> tria_immersed(MPI_COMM_WORLD);\\n GridGenerator::hyper_sphere(tria_immersed, center, radius);\\n    tria_immersed.refine_global(4);\\n \\n MappingQ<dim - 1, dim>      mapping_immersed_base(3);\\n MappingQCache<dim - 1, dim> mapping_immersed(3);\\n    mapping_immersed.initialize(mapping_immersed_base, tria_immersed);\\n const QGauss<dim - 1> quadrature_immersed(degree + 1);\\n \\n const FE_Q<dim - 1, dim>     fe_scalar_immersed(degree);\\n const FESystem<dim - 1, dim> fe_immersed(fe_scalar_immersed, dim);\\n DoFHandler<dim - 1, dim>     dof_handler_immersed(tria_immersed);\\n    dof_handler_immersed.distribute_dofs(fe_immersed);\\n \\n DoFRenumbering::support_point_wise(dof_handler_immersed);\\n \\n LinearAlgebra::distributed::Vector<double> velocity;\\n    velocity.reinit(dof_handler_background.locally_owned_dofs(),\\n DoFTools::extract_locally_active_dofs(\\n                      dof_handler_background),\\n                    MPI_COMM_WORLD);\\n Functions::RayleighKotheVortex<dim> vortex(2);\\n \\n LinearAlgebra::distributed::Vector<double> force_vector(\\n      dof_handler_background.locally_owned_dofs(),\\n DoFTools::extract_locally_active_dofs(dof_handler_background),\\n      MPI_COMM_WORLD);\\n \\n LinearAlgebra::distributed::Vector<double> immersed_support_points;\\n    collect_support_points(mapping_immersed,\\n                           dof_handler_immersed,\\n                           immersed_support_points);\\n \\n Utilities::MPI::RemotePointEvaluation<dim> rpe;\\n double                                     time = 0.0;\\n for (unsigned int it = 0; it <= n_time_steps; ++it, time += dt)\\n      {\\n        pcout << \\\"time: \\\" << time << std::endl;\\n if (it > 0)\\n          {\\n            pcout << \\\"  - move support points (immersed mesh)\\\" << std::endl;\\n            vortex.set_time(time);\\n VectorTools::interpolate(mapping_background,\\n                                     dof_handler_background,\\n                                     vortex,\\n                                     velocity);\\n            rpe.reinit(convert<dim>(immersed_support_points),\\n                       tria_background,\\n                       mapping_background);\\n \\n AssertThrow(rpe.all_points_found(),\\n                        ExcMessage(\\n \\\"Immersed domain leaves background domain!\\\"));\\n \\n            velocity.update_ghost_values();\\n const auto immersed_velocity =\\n VectorTools::point_values<dim>(rpe,\\n                                             dof_handler_background,\\n                                             velocity);\\n            velocity.zero_out_ghost_values();\\n \\n for (unsigned int i = 0, c = 0;\\n                 i < immersed_support_points.locally_owned_size() / dim;\\n                 ++i)\\n for (unsigned int d = 0; d < dim; ++d, ++c)\\n                immersed_support_points.local_element(c) +=\\n                  immersed_velocity[i][d] * dt;\\n \\n            mapping_immersed.initialize(mapping_immersed_base,\\n                                        dof_handler_immersed,\\n                                        immersed_support_points,\\n false);\\n          }\\n \\n        pcout << \\\"  - compute to be tested values (immersed mesh)\\\" << std::endl;\\n using value_type = Tensor<1, dim, double>;\\n \\n        std::vector<Point<dim>> integration_points;\\n        std::vector<value_type> integration_values;\\n \\n FEValues<dim - 1, dim> fe_values(mapping_immersed,\\n                                         fe_immersed,\\n                                         quadrature_immersed,\\n update_JxW_values | update_gradients |\\n update_normal_vectors |\\n update_quadrature_points);\\n \\n FEValues<dim - 1, dim> fe_values_co(\\n          mapping_immersed,\\n          fe_scalar_immersed,\\n          fe_scalar_immersed.get_unit_support_points(),\\n update_JxW_values | update_normal_vectors);\\n \\n        std::vector<unsigned int> component_to_system_index(\\n          fe_immersed.n_dofs_per_cell());\\n \\n for (unsigned int i = 0, c = 0;\\n             i < fe_scalar_immersed.n_dofs_per_cell();\\n             ++i)\\n for (unsigned int d = 0; d < dim; ++d, ++c)\\n            component_to_system_index[c] =\\n              fe_immersed.component_to_system_index(d, i);\\n \\n for (const auto &cell : tria_immersed.active_cell_iterators() |\\n IteratorFilters::LocallyOwnedCell())\\n          {\\n            fe_values.reinit(cell);\\n            fe_values_co.reinit(cell);\\n \\n for (const auto &q : fe_values.quadrature_point_indices())\\n              {\\n                integration_points.emplace_back(fe_values.quadrature_point(q));\\n \\n const auto sigma = 1.0; // surface tension coefficient\\n \\n const auto normal    = fe_values.normal_vector(q);\\n double     curvature = 0;\\n for (unsigned int i = 0, c = 0;\\n                     i < fe_scalar_immersed.n_dofs_per_cell();\\n                     ++i)\\n for (unsigned int d = 0; d < dim; ++d, ++c)\\n                    curvature += fe_values.shape_grad_component(\\n                                   component_to_system_index[c], q, d)[d] *\\n                                 fe_values_co.normal_vector(i)[d];\\n \\n const auto FxJxW =\\n                  sigma * curvature * normal * fe_values.JxW(q);\\n \\n                integration_values.emplace_back(FxJxW);\\n              }\\n          }\\n \\n        pcout << \\\"  - test values (background mesh)\\\" << std::endl;\\n \\n        rpe.reinit(integration_points, tria_background, mapping_background);\\n \\n const auto integration_function = [&](const auto &values,\\n const auto &cell_data) {\\n FEPointEvaluation<dim, dim> phi_force(mapping_background,\\n                                                fe_background,\\n update_values);\\n \\n          std::vector<double>                  local_values;\\n          std::vector<types::global_dof_index> local_dof_indices;\\n \\n for (const auto cell : cell_data.cell_indices())\\n            {\\n const auto cell_dofs =\\n                cell_data.get_active_cell_iterator(cell)\\n                  ->as_dof_handler_iterator(dof_handler_background);\\n \\n const auto unit_points = cell_data.get_unit_points(cell);\\n const auto FxJxW       = cell_data.get_data_view(cell, values);\\n \\n              phi_force.reinit(cell_dofs, unit_points);\\n \\n for (const auto q : phi_force.quadrature_point_indices())\\n                phi_force.submit_value(FxJxW[q], q);\\n \\n              local_values.resize(cell_dofs->get_fe().n_dofs_per_cell());\\n              phi_force.test_and_sum(local_values, EvaluationFlags::values);\\n \\n              local_dof_indices.resize(cell_dofs->get_fe().n_dofs_per_cell());\\n              cell_dofs->get_dof_indices(local_dof_indices);\\n AffineConstraints<double>().distribute_local_to_global(\\n                local_values, local_dof_indices, force_vector);\\n            }\\n        };\\n \\n        rpe.process_and_evaluate<value_type>(integration_values,\\n                                             integration_function);\\n        force_vector.compress(VectorOperation::add);\\n \\n if (it % 10 == 0 || it == n_time_steps)\\n          {\\n            std::vector<\\n DataComponentInterpretation::DataComponentInterpretation>\\n              vector_component_interpretation(\\n                dim, DataComponentInterpretation::component_is_part_of_vector);\\n            pcout << \\\"  - write data (background mesh)\\\" << std::endl;\\n DataOut<dim>          data_out_background;\\n DataOutBase::VtkFlags flags_background;\\n            flags_background.write_higher_order_cells = true;\\n            data_out_background.set_flags(flags_background);\\n            data_out_background.add_data_vector(\\n              dof_handler_background,\\n              force_vector,\\n              std::vector<std::string>(dim, \\\"force\\\"),\\n              vector_component_interpretation);\\n            data_out_background.add_data_vector(\\n              dof_handler_background,\\n              velocity,\\n              std::vector<std::string>(dim, \\\"velocity\\\"),\\n              vector_component_interpretation);\\n            data_out_background.build_patches(mapping_background, 3);\\n            data_out_background.write_vtu_in_parallel(\\\"example_3_background_\\\" +\\n                                                        std::to_string(it) +\\n \\\".vtu\\\",\\n                                                      MPI_COMM_WORLD);\\n \\n            pcout << \\\"  - write mesh (immersed mesh)\\\" << std::endl;\\n DataOut<dim - 1, dim> data_out_immersed;\\n            data_out_immersed.attach_triangulation(tria_immersed);\\n            data_out_immersed.build_patches(mapping_immersed, 3);\\n            data_out_immersed.write_vtu_in_parallel(\\\"example_3_immersed_\\\" +\\n                                                      std::to_string(it) +\\n \\\".vtu\\\",\\n                                                    MPI_COMM_WORLD);\\n          }\\n        pcout << std::endl;\\n      }\\n  }\\n \\n template <int spacedim>\\n  std::vector<Point<spacedim>>\\n  create_points_along_line(const Point<spacedim> &p0,\\n const Point<spacedim> &p1,\\n const unsigned int     n_subdivisions)\\n  {\\n Assert(n_subdivisions >= 1, ExcInternalError());\\n \\n    std::vector<Point<spacedim>> points;\\n    points.reserve(n_subdivisions + 1);\\n \\n    points.emplace_back(p0);\\n for (unsigned int i = 1; i < n_subdivisions; ++i)\\n      points.emplace_back(p0 + (p1 - p0) * static_cast<double>(i) /\\n static_cast<double>(n_subdivisions));\\n    points.emplace_back(p1);\\n \\n return points;\\n  }\\n \\n template <int spacedim, typename T0, typename T1>\\n void print_along_line(const std::string                  &file_name,\\n const std::vector<Point<spacedim>> &points,\\n const std::vector<T0>              &values_0,\\n const std::vector<T1>              &values_1)\\n  {\\n AssertThrow(points.size() == values_0.size() &&\\n                  (values_1.size() == points.size() || values_1.empty()),\\n                ExcMessage(\\\"The provided vectors must have the same length.\\\"));\\n \\n    std::ofstream file(file_name);\\n \\n for (unsigned int i = 0; i < points.size(); ++i)\\n      {\\n        file << std::fixed << std::right << std::setw(5) << std::setprecision(3)\\n             << points[0].distance(points[i]);\\n \\n for (unsigned int d = 0; d < spacedim; ++d)\\n          file << std::fixed << std::right << std::setw(10)\\n               << std::setprecision(3) << points[i][d];\\n \\n        file << std::fixed << std::right << std::setw(10)\\n             << std::setprecision(3) << values_0[i];\\n \\n if (!values_1.empty())\\n          file << std::fixed << std::right << std::setw(10)\\n               << std::setprecision(3) << values_1[i];\\n        file << std::endl;\\n      }\\n  }\\n \\n template <int dim, int spacedim>\\n void collect_support_points(\\n const Mapping<dim, spacedim>               &mapping,\\n const DoFHandler<dim, spacedim>            &dof_handler,\\n LinearAlgebra::distributed::Vector<double> &support_points)\\n  {\\n    support_points.reinit(dof_handler.locally_owned_dofs(),\\n DoFTools::extract_locally_active_dofs(dof_handler),\\n                          dof_handler.get_communicator());\\n \\n const auto &fe = dof_handler.get_fe();\\n \\n FEValues<dim, spacedim> fe_values(\\n      mapping,\\n      fe,\\n      fe.base_element(0).get_unit_support_points(),\\n update_quadrature_points);\\n \\n    std::vector<types::global_dof_index> local_dof_indices(\\n      fe.n_dofs_per_cell());\\n \\n    std::vector<unsigned int> component_to_system_index(\\n      fe_values.n_quadrature_points * spacedim);\\n \\n for (unsigned int q = 0, c = 0; q < fe_values.n_quadrature_points; ++q)\\n for (unsigned int d = 0; d < spacedim; ++d, ++c)\\n        component_to_system_index[c] = fe.component_to_system_index(d, q);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators() |\\n IteratorFilters::LocallyOwnedCell())\\n      {\\n        fe_values.reinit(cell);\\n        cell->get_dof_indices(local_dof_indices);\\n \\n for (unsigned int q = 0, c = 0; q < fe_values.n_quadrature_points; ++q)\\n for (unsigned int d = 0; d < spacedim; ++d, ++c)\\n            support_points[local_dof_indices[component_to_system_index[c]]] =\\n              fe_values.quadrature_point(q)[d];\\n      }\\n  }\\n \\n template <int dim, int spacedim, typename T>\\n  std::tuple<std::vector<Point<spacedim>>, std::vector<types::global_dof_index>>\\n  collect_support_points_with_narrow_band(\\n const Mapping<dim, spacedim>                &mapping,\\n const DoFHandler<dim, spacedim>             &dof_handler_signed_distance,\\n const LinearAlgebra::distributed::Vector<T> &signed_distance,\\n const DoFHandler<dim, spacedim>             &dof_handler_support_points,\\n const double                                 narrow_band_threshold)\\n  {\\n AssertThrow(narrow_band_threshold >= 0,\\n                ExcMessage(\\\"The narrow band threshold\\\"\\n \\\" must be larger than or equal to 0.\\\"));\\n const auto &tria = dof_handler_signed_distance.get_triangulation();\\n const Quadrature<dim> quad(dof_handler_support_points.get_fe()\\n                                 .base_element(0)\\n                                 .get_unit_support_points());\\n \\n FEValues<dim> distance_values(mapping,\\n                                  dof_handler_signed_distance.get_fe(),\\n                                  quad,\\n update_values);\\n \\n FEValues<dim> req_values(mapping,\\n                             dof_handler_support_points.get_fe(),\\n                             quad,\\n update_quadrature_points);\\n \\n    std::vector<T>                       temp_distance(quad.size());\\n    std::vector<types::global_dof_index> local_dof_indices(\\n      dof_handler_support_points.get_fe().n_dofs_per_cell());\\n \\n    std::vector<Point<dim>>              support_points;\\n    std::vector<types::global_dof_index> support_points_idx;\\n \\n const bool has_ghost_elements = signed_distance.has_ghost_elements();\\n \\n const auto &locally_owned_dofs_req =\\n      dof_handler_support_points.locally_owned_dofs();\\n    std::vector<bool> flags(locally_owned_dofs_req.n_elements(), false);\\n \\n if (has_ghost_elements == false)\\n      signed_distance.update_ghost_values();\\n \\n for (const auto &cell :\\n         tria.active_cell_iterators() | IteratorFilters::LocallyOwnedCell())\\n      {\\n const auto cell_distance =\\n          cell->as_dof_handler_iterator(dof_handler_signed_distance);\\n        distance_values.reinit(cell_distance);\\n        distance_values.get_function_values(signed_distance, temp_distance);\\n \\n const auto cell_req =\\n          cell->as_dof_handler_iterator(dof_handler_support_points);\\n        req_values.reinit(cell_req);\\n        cell_req->get_dof_indices(local_dof_indices);\\n \\n for (const auto q : req_values.quadrature_point_indices())\\n          if (std::abs(temp_distance[q]) < narrow_band_threshold)\\n            {\\n const auto idx = local_dof_indices[q];\\n \\n if (locally_owned_dofs_req.is_element(idx) == false ||\\n                  flags[locally_owned_dofs_req.index_within_set(idx)])\\n continue;\\n \\n              flags[locally_owned_dofs_req.index_within_set(idx)] = true;\\n \\n              support_points_idx.emplace_back(idx);\\n              support_points.emplace_back(req_values.quadrature_point(q));\\n            }\\n      }\\n \\n if (has_ghost_elements == false)\\n      signed_distance.zero_out_ghost_values();\\n \\n return {support_points, support_points_idx};\\n  }\\n \\n template <int spacedim>\\n  std::vector<Point<spacedim>> convert(\\n const LinearAlgebra::distributed::Vector<double> &support_points_unrolled)\\n  {\\n const unsigned int n_points =\\n      support_points_unrolled.locally_owned_size() / spacedim;\\n \\n    std::vector<Point<spacedim>> points(n_points);\\n \\n for (unsigned int i = 0, c = 0; i < n_points; ++i)\\n for (unsigned int d = 0; d < spacedim; ++d, ++c)\\n        points[i][d] = support_points_unrolled.local_element(c);\\n \\n return points;\\n  }\\n \\n} // namespace Step87\\n \\nint main(int argc, char **argv)\\n{\\n using namespace dealii;\\n Utilities::MPI::MPI_InitFinalize mpi(argc, argv, 1);\\n  std::cout.precision(5);\\n \\n if (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)\\n    Step87::example_0(); // only run on root process\\n \\n  Step87::example_1();\\n  Step87::example_2();\\n  Step87::example_3();\\n}\\nDataOutInterface::write_vtu_in_parallelvoid write_vtu_in_parallel(const std::string &filename, const MPI_Comm comm) constDefinition data_out_base.cc:7715\\nDataOutInterface::set_flagsvoid set_flags(const FlagType &flags)Definition data_out_base.cc:8863\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nDoFHandler::get_feconst FiniteElement< dim, spacedim > & get_fe(const types::fe_index index=0) const\\nDoFHandler::get_triangulationconst Triangulation< dim, spacedim > & get_triangulation() const\\nDoFHandler::locally_owned_dofsconst IndexSet & locally_owned_dofs() const\\nDoFHandler::get_communicatorMPI_Comm get_communicator() const\\nFiniteElementData::n_dofs_per_cellunsigned int n_dofs_per_cell() const\\nFiniteElement::base_elementvirtual const FiniteElement< dim, spacedim > & base_element(const unsigned int index) const\\nFiniteElement::get_unit_support_pointsconst std::vector< Point< dim > > & get_unit_support_points() const\\nLinearAlgebra::distributed::Vector::zero_out_ghost_valuesvoid zero_out_ghost_values() const\\nLinearAlgebra::distributed::Vector::has_ghost_elementsbool has_ghost_elements() const\\nLinearAlgebra::distributed::Vector::local_elementNumber local_element(const size_type local_index) const\\nLinearAlgebra::distributed::Vector::update_ghost_valuesvoid update_ghost_values() const\\nLinearAlgebra::distributed::Vector::locally_owned_sizesize_type locally_owned_size() const\\nUtilities::MPI::RemotePointEvaluation::all_points_foundbool all_points_found() constDefinition mpi_remote_point_evaluation.cc:338\\nUtilities::MPI::RemotePointEvaluation::process_and_evaluatevoid process_and_evaluate(const std::vector< T > &input, std::vector< T > &buffer, const std::function< void(const ArrayView< const T > &, const CellData &)> &evaluation_function, const bool sort_data=true) constDefinition mpi_remote_point_evaluation.h:921\\nUtilities::MPI::RemotePointEvaluation::evaluate_and_processvoid evaluate_and_process(std::vector< T > &output, std::vector< T > &buffer, const std::function< void(const ArrayView< T > &, const CellData &)> &evaluation_function, const bool sort_data=true) constDefinition mpi_remote_point_evaluation.h:709\\nUtilities::MPI::RemotePointEvaluation::reinitvoid reinit(const std::vector< Point< spacedim > > &points, const Triangulation< dim, spacedim > &tria, const Mapping< dim, spacedim > &mapping)Definition mpi_remote_point_evaluation.cc:86\\nconditional_ostream.h\\ntria.h\\ndof_renumbering.h\\ndof_tools.h\\nfe_nothing.h\\nfe_point_evaluation.h\\nfe_q.h\\nfe_system.h\\nfunction_lib.h\\nfunction_signed_distance.h\\ngeneric_linear_algebra.h\\ngrid_generator.h\\ngrid_tools.h\\nmapping_q1.h\\nmapping_q_cache.h\\nmpi.h\\nmpi_remote_point_evaluation.h\\nGridTools::find_active_cell_around_pointstd::pair< typename MeshType< dim, spacedim >::active_cell_iterator, Point< dim > > find_active_cell_around_point(const Mapping< dim, spacedim > &mapping, const MeshType< dim, spacedim > &mesh, const Point< spacedim > &p, const std::vector< bool > &marked_vertices={}, const double tolerance=1.e-10)Definition grid_tools_dof_handlers.cc:442\\nPhysics::Elasticity::Kinematics::eSymmetricTensor< 2, dim, Number > e(const Tensor< 2, dim, Number > &F)\\nPhysics::Elasticity::Kinematics::bSymmetricTensor< 2, dim, Number > b(const Tensor< 2, dim, Number > &F)\\ndata_out.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"