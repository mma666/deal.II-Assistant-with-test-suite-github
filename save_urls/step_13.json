"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_13.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-13 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-13 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-13 tutorial program\\n\\n\\nThis tutorial depends on step-6.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nBackground and purpose\\nWhat the program does\\n\\n The commented program\\n\\nEvaluation of the solution\\n\\n%Point evaluation\\nGenerating output\\nOther evaluations\\n\\nThe Laplace solver classes\\n\\nAn abstract base class\\nA general solver class\\nA primal solver\\nGlobal refinement\\nLocal refinement by the Kelly error indicator\\n\\nEquation data\\nThe driver routines\\n\\n\\n Results\\n\\n\\n The plain program\\n   \\n Introduction\\nBackground and purpose\\nIn this example program, we will not so much be concerned with describing new ways how to use deal.II and its facilities, but rather with presenting methods of writing modular and extensible finite element programs. The main reason for this is the size and complexity of modern research software: applications implementing modern error estimation concepts and adaptive solution methods tend to become rather large. For example, when this program was written in 2002, the three largest applications by the main authors of deal.II, are at the time of writing of this example program: \\n\\na program for solving conservation hyperbolic equations by the Discontinuous Galerkin Finite Element method: 33,775 lines of code; \\n\\na parameter estimation program: 28,980 lines of code; \\n\\na wave equation solver: 21,020 lines of code. \\n\\n(The library proper - without example programs and test suite - has slightly more than 150,000 lines of code as of spring 2002. It is of course several times larger now.) The sizes of these applications are at the edge of what one person, even an experienced programmer, can manage.\\nThe numbers above make one thing rather clear: monolithic programs that are not broken up into smaller, mostly independent pieces have no way of surviving, since even the author will quickly lose the overview of the various dependencies between different parts of a program. Only data encapsulation, for example using object oriented programming methods, and modularization by defining small but fixed interfaces can help structure data flow and mutual interdependencies. It is also an absolute prerequisite if more than one person is developing a program, since otherwise confusion will quickly prevail as one developer would need to know if another changed something about the internals of a different module if they were not cleanly separated.\\nIn previous examples, you have seen how the library itself is broken up into several complexes each building atop the underlying ones, but relatively independent of the other ones: \\n\\nthe triangulation class complex, with associated iterator classes; \\n\\nthe finite element classes; \\n\\nthe DoFHandler class complex, with associated iterators, built on the triangulation and finite element classes; \\n\\nthe classes implementing mappings between unit and real cells; \\n\\nthe FEValues class complex, built atop the finite elements and mappings. \\n\\nBesides these, and a large number of smaller classes, there are of course the following \\\"tool\\\" modules: \\n\\noutput in various graphical formats; \\n\\nlinear algebra classes. \\n\\nThese complexes can also be found as a flow chart on the front page of the deal.II manual website.\\nThe goal of this program is now to give an example of how a relatively simple finite element program could be structured such that we end up with a set of modules that are as independent of each other as possible. This allows to change the program at one end, without having to worry that it might break at the other, as long as we do not touch the interface through which the two ends communicate. The interface in C++, of course, is the declaration of abstract base classes.\\nHere, we will implement (again) a Laplace solver, although with a number of differences compared to previous example programs: \\n\\nThe classes that implement the process of numerically solving the equation are no more responsible for driving the process of \\\"solving-estimating error-refining-solving again\\\", but we delegate this to external functions. This allows first to use it as a building block in a larger context, where the solution of a Laplace equation might only be one part (for example, in a nonlinear problem, where Laplace equations might have to be solved in each nonlinear step). It would also allow to build a framework around this class that would allow using solvers for other equations (but with the same external interface) instead, in case some techniques shall be evaluated for different types of partial differential equations. \\n\\nIt splits the process of evaluating the computed solution to a separate set of classes. The reason is that one is usually not interested in the solution of a PDE per se, but rather in certain aspects of it. For example, one might wish to compute the traction at a certain boundary in elastic computations, or in the signal of a seismic wave at a receiver position at a given location. Sometimes, one might have an interest in several of these aspects. Since the evaluation of a solution is something that does not usually affect the process of solution, we split it off into a separate module, to allow for the development of such evaluation filters independently of the development of the solver classes. \\n\\nSeparate the classes that implement mesh refinement from the classes that compute the solution. \\n\\nSeparate the description of the test case with which we will present the program, from the rest of the program. \\n\\nParallelize the assembly of linear systems using the WorkStream facilities. This follows the extensive description that can be found in the Parallel computing with multiple processors accessing shared memory documentation topic. The implementation essentially follows what has already been described in step-9. \\n\\nThe things the program does are not new. In fact, this is more like a melange of previous programs, cannibalizing various parts and functions from earlier examples. It is the way they are arranged in this program that should be the focus of the reader, i.e. the software design techniques used in the program to achieve the goal of implementing the desired mathematical method. However, we must stress that software design is in part also a subjective matter: different persons have different programming backgrounds and have different opinions about the \\\"right\\\" style of programming; this program therefore expresses only what the author considers useful practice, and is not necessarily a style that you have to adopt in order to write successful numerical software if you feel uncomfortable with the chosen ways. It should serve as a case study, however, inspiring the reader with ideas to the desired end.\\nOnce you have worked through the program, you will remark that it is already somewhat complex in its structure. Nevertheless, it only has about 850 lines of code, without comments. In real applications, there would of course be comments and class documentation, which would bring that to maybe 1200 lines. Yet, compared to the applications listed above, this is still small, as they are 20 to 25 times as large. For programs as large, a proper design right from the start is thus indispensable. Otherwise, it will have to be redesigned at one point in its life, once it becomes too large to be manageable.\\nDespite of this, all three programs listed above have undergone major revisions, or even rewrites. The wave program, for example, was once entirely teared to parts when it was still significantly smaller, just to assemble it again in a more modular form. By that time, it had become impossible to add functionality without affecting older parts of the code (the main problem with the code was the data flow: in time dependent application, the major concern is when to store data to disk and when to reload it again; if this is not done in an organized fashion, then you end up with data released too early, loaded too late, or not released at all). Although the present example program thus draws from several years of experience, it is certainly not without flaws in its design, and in particular might not be suited for an application where the objective is different. It should serve as an inspiration for writing your own application in a modular way, to avoid the pitfalls of too closely coupled codes.\\nWhat the program does\\nWhat the program actually does is not even the main point of this program, the structure of the program is more important. However, in a few words, a description would be: solve the Laplace equation for a given right hand side such that the solution is the function \\\\(u(x,t)=\\\\exp(x+\\\\sin(10y+5x^2))\\\\). The goal of the computation is to get the value of the solution at the point \\\\(x_0=(0.5,0.5)\\\\), and to compare the accuracy with which we resolve this value for two refinement criteria, namely global refinement and refinement by the error indicator by Kelly et al. which we have already used in previous examples.\\nThe results will, as usual, be discussed in the respective section of this document. In doing so, we will find a slightly irritating observation about the relative performance of the two refinement criteria. In a later example program, building atop this one, we will devise a different method that should hopefully perform better than the techniques discussed here.\\nSo much now for all the theoretical and anecdotal background. The best way of learning about a program is to look at it, so here it is:\\n The commented program\\nAs in all programs, we start with a list of include files from the library, and as usual they are in the standard order which is base \\u2013 lac \\u2013 grid \\u2013 dofs \\u2013 fe \\u2013 numerics (as each of these categories roughly builds upon previous ones), then C++ standard headers:\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/base/table_handler.h>\\n\\u00a0 #include <deal.II/base/thread_management.h>\\n\\u00a0 #include <deal.II/base/work_stream.h>\\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/solver_cg.h>\\n\\u00a0 #include <deal.II/lac/precondition.h>\\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_refinement.h>\\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 #include <deal.II/numerics/matrix_tools.h>\\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/error_estimator.h>\\n\\u00a0 \\nNow for the C++ standard headers:\\n\\u00a0 #include <iostream>\\n\\u00a0 #include <fstream>\\n\\u00a0 #include <list>\\n\\u00a0 \\nThe last step is as in all previous programs:\\n\\u00a0 namespace Step13\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n Evaluation of the solution\\nAs for the program itself, we first define classes that evaluate the solutions of a Laplace equation. In fact, they can evaluate every kind of solution, as long as it is described by a DoFHandler object, and a solution vector. We define them here first, even before the classes that actually generate the solution to be evaluated, since we need to declare an abstract base class that the solver classes can refer to.\\nFrom an abstract point of view, we declare a pure base class that provides an evaluation operator() which will do the evaluation of the solution (whatever derived classes might consider an evaluation). Since this is the only real function of this base class (except for some bookkeeping machinery), one usually terms such a class that only has an operator() a functor in C++ terminology, since it is used just like a function object.\\nObjects of this functor type will then later be passed to the solver object, which applies it to the solution just computed. The evaluation objects may then extract any quantity they like from the solution. The advantage of putting these evaluation functions into a separate hierarchy of classes is that by design they cannot use the internals of the solver object and are therefore independent of changes to the way the solver works. Furthermore, it is trivial to write another evaluation class without modifying the solver class, which speeds up programming (not being able to use internals of another class also means that you do not have to worry about them \\u2013 programming evaluators is usually a rather quickly done task), as well as compilation (if solver and evaluation classes are put into different files: the solver only needs to see the declaration of the abstract base class, and therefore does not need to be recompiled upon addition of a new evaluation class, or modification of an old one). On a related note, you can reuse the evaluation classes for other projects, solving different equations.\\nIn order to improve separation of code into different groups, we put the evaluation classes into a namespace of their own. This makes it easier to actually solve different equations in the same program, by assembling it from existing building blocks. The reason for this is that classes for similar purposes tend to have the same name, although they were developed in different contexts. In order to be able to use them together in one program, it is necessary that they are placed in different namespaces. This we do here:\\n\\u00a0   namespace Evaluation\\n\\u00a0   {\\nNow for the abstract base class of evaluation classes: its main purpose is to declare a pure virtual function operator() taking a DoFHandler object, and the solution vector. In order to be able to use pointers to this base class only, it also has to declare a virtual destructor, which however does nothing. Besides this, it only provides for a little bit of bookkeeping: since we usually want to evaluate solutions on subsequent refinement levels, we store the number of the present refinement cycle, and provide a function to change this number.\\n\\u00a0     template <int dim>\\n\\u00a0     class EvaluationBase\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       virtual ~EvaluationBase() = default;\\n\\u00a0 \\n\\u00a0       void set_refinement_cycle(const unsigned int refinement_cycle);\\n\\u00a0 \\n\\u00a0       virtual void operator()(const DoFHandler<dim> &dof_handler,\\n\\u00a0                               const Vector<double>  &solution) const = 0;\\n\\u00a0 \\n\\u00a0     protected:\\n\\u00a0       unsigned int refinement_cycle;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void EvaluationBase<dim>::set_refinement_cycle(const unsigned int step)\\n\\u00a0     {\\n\\u00a0       refinement_cycle = step;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\nDoFHandlerDefinition dof_handler.h:317\\nVectorDefinition vector.h:120\\n Point evaluation\\nThe next thing is to implement actual evaluation classes. As noted in the introduction, we'd like to extract a point value from the solution, so the first class does this in its operator(). The actual point is given to this class through the constructor, as well as a table object into which it will put its findings.\\nFinding out the value of a finite element field at an arbitrary point is rather difficult, if we cannot rely on knowing the actual finite element used, since then we cannot, for example, interpolate between nodes. For simplicity, we therefore assume here that the point at which we want to evaluate the field is actually a node. If, in the process of evaluating the solution, we find that we did not encounter this point upon looping over all vertices, we then have to throw an exception in order to signal to the calling functions that something has gone wrong, rather than silently ignore this error.\\nIn the step-9 example program, we have already seen how such an exception class can be declared, using the DeclExceptionN macros. We use this mechanism here again.\\nFrom this, the actual declaration of this class should be evident. Note that of course even if we do not list a destructor explicitly, an implicit destructor is generated from the compiler, and it is virtual just as the one of the base class.\\n\\u00a0     template <int dim>\\n\\u00a0     class PointValueEvaluation : public EvaluationBase<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       PointValueEvaluation(const Point<dim> &evaluation_point,\\n\\u00a0                            TableHandler     &results_table);\\n\\u00a0 \\n\\u00a0       virtual void operator()(const DoFHandler<dim> &dof_handler,\\n\\u00a0                               const Vector<double>  &solution) const override;\\n\\u00a0 \\n\\u00a0       DeclException1(\\n\\u00a0         ExcEvaluationPointNotFound,\\n\\u00a0         Point<dim>,\\n\\u00a0         << \\\"The evaluation point \\\" << arg1\\n\\u00a0         << \\\" was not found among the vertices of the present grid.\\\");\\n\\u00a0 \\n\\u00a0     private:\\n\\u00a0       const Point<dim> evaluation_point;\\n\\u00a0       TableHandler    &results_table;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\nPointDefinition point.h:111\\nTableHandlerDefinition table_handler.h:293\\nDeclException1#define DeclException1(Exception1, type1, outsequence)Definition exceptions.h:516\\nAs for the definition, the constructor is trivial, just taking data and storing it in object-local ones:\\n\\u00a0     template <int dim>\\n\\u00a0     PointValueEvaluation<dim>::PointValueEvaluation(\\n\\u00a0       const Point<dim> &evaluation_point,\\n\\u00a0       TableHandler     &results_table)\\n\\u00a0       : evaluation_point(evaluation_point)\\n\\u00a0       , results_table(results_table)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nNow for the function that is mainly of interest in this class, the computation of the point value:\\n\\u00a0     template <int dim>\\n\\u00a0     void\\n\\u00a0     PointValueEvaluation<dim>::operator()(const DoFHandler<dim> &dof_handler,\\n\\u00a0                                           const Vector<double>  &solution) const\\n\\u00a0     {\\nFirst allocate a variable that will hold the point value. Initialize it with a value that is clearly bogus, so that if we fail to set it to a reasonable value, we will note at once. This may not be necessary in a function as small as this one, since we can easily see all possible paths of execution here, but it proved to be helpful for more complex cases, and so we employ this strategy here as well.\\n\\u00a0       double point_value = 1e20;\\n\\u00a0 \\nThen loop over all cells and all their vertices, and check whether a vertex matches the evaluation point. If this is the case, then extract the point value, set a flag that we have found the point of interest, and exit the loop.\\n\\u00a0       bool evaluation_point_found = false;\\n\\u00a0       for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0         if (!evaluation_point_found)\\n\\u00a0           for (const auto vertex : cell->vertex_indices())\\n\\u00a0             if (cell->vertex(vertex) == evaluation_point)\\n\\u00a0               {\\nvertex_indicesunsigned int vertex_indices[2]Definition grid_tools_topology.cc:947\\nIn order to extract the point value from the global solution vector, pick that component that belongs to the vertex of interest, and, in case the solution is vector-valued, take the first component of it:\\n\\u00a0                 point_value = solution(cell->vertex_dof_index(vertex, 0));\\nNote that by this we have made an assumption that is not valid always and should be documented in the class declaration if this were code for a real application rather than a tutorial program: we assume that the finite element used for the solution we try to evaluate actually has degrees of freedom associated with vertices. This, for example, does not hold for discontinuous elements, were the support points for the shape functions happen to be located at the vertices, but are not associated with the vertices but rather with the cell interior, since association with vertices would imply continuity there. It would also not hold for edge oriented elements, and the like.\\nIdeally, we would check this at the beginning of the function, for example by a statement like Assert (dof_handler.get_fe().dofs_per_vertex > 0, ExcNotImplemented()), which should make it quite clear what is going wrong when the exception is triggered. In this case, we omit it (which is indeed bad style), but knowing that that does not hurt here, since the statement cell->vertex_dof_index(vertex,0) would fail if we asked it to give us the DoF index of a vertex if there were none.\\nWe stress again that this restriction on the allowed finite elements should be stated in the class documentation.\\nSince we found the right point, we now set the respective flag and exit the innermost loop. The outer loop will also be terminated due to the set flag.\\n\\u00a0                 evaluation_point_found = true;\\n\\u00a0                 break;\\n\\u00a0               };\\n\\u00a0 \\nFinally, we'd like to make sure that we have indeed found the evaluation point, since if that were not so we could not give a reasonable value of the solution there and the rest of the computations were useless anyway. So make sure through the AssertThrow macro already used in the step-9 program that we have indeed found this point. If this is not so, the macro throws an exception of the type that is given to it as second argument, but compared to a straightforward throw statement, it fills the exception object with a set of additional information, for example the source file and line number where the exception was generated, and the condition that failed. If you have a catch clause in your main function (as this program has), you will catch all exceptions that are not caught somewhere in between and thus already handled, and this additional information will help you find out what happened and where it went wrong.\\n\\u00a0       AssertThrow(evaluation_point_found,\\n\\u00a0                   ExcEvaluationPointNotFound(evaluation_point));\\nAssertThrow#define AssertThrow(cond, exc)Definition exceptions.h:1739\\nNote that we have used the Assert macro in other example programs as well. It differed from the AssertThrow macro used here in that it simply aborts the program, rather than throwing an exception, and that it did so only in debug mode. It was the right macro to use to check about the size of vectors passed as arguments to functions, and the like.\\nHowever, here the situation is different: whether we find the evaluation point or not may change from refinement to refinement (for example, if the four cells around point are coarsened away, then the point may vanish after refinement and coarsening). This is something that cannot be predicted from a few number of runs of the program in debug mode, but should be checked always, also in production runs. Thus the use of the AssertThrow macro here.\\nNow, if we are sure that we have found the evaluation point, we can add the results into the table of results:\\n\\u00a0       results_table.add_value(\\\"DoFs\\\", dof_handler.n_dofs());\\n\\u00a0       results_table.add_value(\\\"u(x_0)\\\", point_value);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n Generating output\\nA different, maybe slightly odd kind of evaluation of a solution is to output it to a file in a graphical format. Since in the evaluation functions we are given a DoFHandler object and the solution vector, we have all we need to do this, so we can do it in an evaluation class. The reason for actually doing so instead of putting it into the class that computed the solution is that this way we have more flexibility: if we choose to only output certain aspects of it, or not output it at all. In any case, we do not need to modify the solver class, we just have to modify one of the modules out of which we build this program. This form of encapsulation, as above, helps us to keep each part of the program rather simple as the interfaces are kept simple, and no access to hidden data is possible.\\nSince this class which generates the output is derived from the common EvaluationBase base class, its main interface is the operator() function. Furthermore, it has a constructor taking a string that will be used as the base part of the file name to which output will be sent (we will augment it by a number indicating the number of the refinement cycle \\u2013 the base class has this information at hand \\u2013, and a suffix), and the constructor also takes a value that indicates which format is requested, i.e. for which graphics program we shall generate output (from this we will then also generate the suffix of the filename to which we write).\\nRegarding the output format, the DataOutBase namespace provides an enumeration field DataOutBase::OutputFormat which lists names for all supported output formats. At the time of writing of this program, the supported graphics formats are represented by the enum values ucd, gnuplot, povray, eps, gmv, tecplot, dx, vtk, etc, but this list will certainly grow over time. Now, within various functions of that base class, you can use values of this type to get information about these graphics formats (for example the default suffix used for files of each format), and you can call a generic write function, which then branches to the write_gnuplot, write_ucd, etc functions which we have used in previous examples already, based on the value of a second argument given to it denoting the required output format. This mechanism makes it simple to write an extensible program that can decide which output format to use at runtime, and it also makes it rather simple to write the program in a way such that it takes advantage of newly implemented output formats, without the need to change the application program.\\nOf these two fields, the base name and the output format descriptor, the constructor takes values and stores them for later use by the actual evaluation function.\\n\\u00a0     template <int dim>\\n\\u00a0     class SolutionOutput : public EvaluationBase<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       SolutionOutput(const std::string              &output_name_base,\\n\\u00a0                      const DataOutBase::OutputFormat output_format);\\n\\u00a0 \\n\\u00a0       virtual void operator()(const DoFHandler<dim> &dof_handler,\\n\\u00a0                               const Vector<double>  &solution) const override;\\n\\u00a0 \\n\\u00a0     private:\\n\\u00a0       const std::string               output_name_base;\\n\\u00a0       const DataOutBase::OutputFormat output_format;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     SolutionOutput<dim>::SolutionOutput(\\n\\u00a0       const std::string              &output_name_base,\\n\\u00a0       const DataOutBase::OutputFormat output_format)\\n\\u00a0       : output_name_base(output_name_base)\\n\\u00a0       , output_format(output_format)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\nDataOutBase::OutputFormatOutputFormatDefinition data_out_base.h:1613\\nFollowing the description above, the function generating the actual output is now relatively straightforward. The only particularly interesting feature over previous example programs is the use of the DataOutBase::default_suffix function, returning the usual suffix for files of a given format (e.g. \\\".eps\\\" for encapsulated postscript files, \\\".gnuplot\\\" for Gnuplot files), and of the generic DataOut::write() function with a second argument, which internally branches to the actual output functions for the different graphics formats, based on the value of the format descriptor passed as second argument.\\nAlso note that we have to prefix this-> to access a member variable of the template dependent base class. The reason here, and further down in the program is the same as the one described in the step-7 example program (look for two-stage name lookup there).\\n\\u00a0     template <int dim>\\n\\u00a0     void SolutionOutput<dim>::operator()(const DoFHandler<dim> &dof_handler,\\n\\u00a0                                          const Vector<double>  &solution) const\\n\\u00a0     {\\n\\u00a0       DataOut<dim> data_out;\\n\\u00a0       data_out.attach_dof_handler(dof_handler);\\n\\u00a0       data_out.add_data_vector(solution, \\\"solution\\\");\\n\\u00a0       data_out.build_patches();\\n\\u00a0 \\n\\u00a0       std::ofstream out(output_name_base + \\\"-\\\" +\\n\\u00a0                         std::to_string(this->refinement_cycle) +\\n\\u00a0                         data_out.default_suffix(output_format));\\n\\u00a0 \\n\\u00a0       data_out.write(out, output_format);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\n Other evaluations\\nIn practical applications, one would add here a list of other possible evaluation classes, representing quantities that one may be interested in. For this example, that much shall be sufficient, so we close the namespace.\\n\\u00a0   } // namespace Evaluation\\n\\u00a0 \\n\\u00a0 \\n The Laplace solver classes\\nAfter defining what we want to know of the solution, we should now care how to get at it. We will pack everything we need into a namespace of its own, for much the same reasons as for the evaluations above.\\nSince we have discussed Laplace solvers already in considerable detail in previous examples, there is not much new stuff following. Rather, we have to a great extent cannibalized previous examples and put them, in slightly different form, into this example program. We will therefore mostly be concerned with discussing the differences to previous examples.\\nBasically, as already said in the introduction, the lack of new stuff in this example is deliberate, as it is more to demonstrate software design practices, rather than mathematics. The emphasis in explanations below will therefore be more on the actual implementation.\\n\\u00a0   namespace LaplaceSolver\\n\\u00a0   {\\n An abstract base class\\nIn defining a Laplace solver, we start out by declaring an abstract base class, that has no functionality itself except for taking and storing a pointer to the triangulation to be used later.\\nThis base class is very general, and could as well be used for any other stationary problem. It provides declarations of functions that shall, in derived classes, solve a problem, postprocess the solution with a list of evaluation objects, and refine the grid, respectively. None of these functions actually does something itself in the base class.\\nDue to the lack of actual functionality, the programming style of declaring very abstract base classes is similar to the style used in Smalltalk or Java programs, where all classes are derived from entirely abstract classes Object, even number representations. The author admits that he does not particularly like the use of such a style in C++, as it puts style over reason. Furthermore, it promotes the use of virtual functions for everything (for example, in Java, all functions are virtual per se), which, however, has proven to be rather inefficient in many applications where functions are often only accessing data, not doing computations, and therefore quickly return; the overhead of virtual functions can then be significant. The opinion of the author is to have abstract base classes wherever at least some part of the code of actual implementations can be shared and thus separated into the base class.\\nBesides all these theoretical questions, we here have a good reason, which will become clearer to the reader below. Basically, we want to be able to have a family of different Laplace solvers that differ so much that no larger common subset of functionality could be found. We therefore just declare such an abstract base class, taking a pointer to a triangulation in the constructor and storing it henceforth. Since this triangulation will be used throughout all computations, we have to make sure that the triangulation is valid until it is last used. We do this by keeping a SmartPointer to this triangulation, as explained in step-7.\\nNote that while the pointer itself is declared constant (i.e. throughout the lifetime of this object, the pointer points to the same object), it is not declared as a pointer to a constant triangulation. In fact, by this we allow that derived classes refine or coarsen the triangulation within the refine_grid function.\\nFinally, we have a function n_dofs is only a tool for the driver functions to decide whether we want to go on with mesh refinement or not. It returns the number of degrees of freedom the present simulation has.\\n\\u00a0     template <int dim>\\n\\u00a0     class Base\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       Base(Triangulation<dim> &coarse_grid);\\n\\u00a0       virtual ~Base() = default;\\n\\u00a0 \\n\\u00a0       virtual void solve_problem() = 0;\\n\\u00a0       virtual void postprocess(\\n\\u00a0         const Evaluation::EvaluationBase<dim> &postprocessor) const = 0;\\n\\u00a0       virtual void         refine_grid()                            = 0;\\n\\u00a0       virtual unsigned int n_dofs() const                           = 0;\\n\\u00a0 \\n\\u00a0     protected:\\n\\u00a0       const SmartPointer<Triangulation<dim>> triangulation;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\nSmartPointerDefinition smartpointer.h:93\\nTriangulationDefinition tria.h:1323\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\nThe implementation of the only two non-abstract functions is then rather boring:\\n\\u00a0     template <int dim>\\n\\u00a0     Base<dim>::Base(Triangulation<dim> &coarse_grid)\\n\\u00a0       : triangulation(&coarse_grid)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n A general solver class\\nFollowing now the main class that implements assembling the matrix of the linear system, solving it, and calling the postprocessor objects on the solution. It implements the solve_problem and postprocess functions declared in the base class. It does not, however, implement the refine_grid method, as mesh refinement will be implemented in a number of derived classes.\\nIt also declares a new abstract virtual function, assemble_rhs, that needs to be overloaded in subclasses. The reason is that we will implement two different classes that will implement different methods to assemble the right hand side vector. This function might also be interesting in cases where the right hand side depends not simply on a continuous function, but on something else as well, for example the solution of another discretized problem, etc. The latter happens frequently in non-linear problems.\\nAs we mentioned previously, the actual content of this class is not new, but a mixture of various techniques already used in previous examples. We will therefore not discuss them in detail, but refer the reader to these programs.\\nBasically, in a few words, the constructor of this class takes pointers to a triangulation, a finite element, and a function object representing the boundary values. These are either passed down to the base class's constructor, or are stored and used to generate a DoFHandler object later. Since finite elements and quadrature formula should match, it is also passed a quadrature object.\\nThe solve_problem sets up the data structures for the actual solution, calls the functions to assemble the linear system, and solves it.\\nThe postprocess function finally takes an evaluation object and applies it to the computed solution.\\nThe n_dofs function finally implements the pure virtual function of the base class.\\n\\u00a0     template <int dim>\\n\\u00a0     class Solver : public virtual Base<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       Solver(Triangulation<dim>       &triangulation,\\n\\u00a0              const FiniteElement<dim> &fe,\\n\\u00a0              const Quadrature<dim>    &quadrature,\\n\\u00a0              const Function<dim>      &boundary_values);\\n\\u00a0       virtual ~Solver() override;\\n\\u00a0 \\n\\u00a0       virtual void solve_problem() override;\\n\\u00a0 \\n\\u00a0       virtual void postprocess(\\n\\u00a0         const Evaluation::EvaluationBase<dim> &postprocessor) const override;\\n\\u00a0 \\n\\u00a0       virtual unsigned int n_dofs() const override;\\n\\u00a0 \\nFiniteElementDefinition fe.h:655\\nFunctionDefinition function.h:152\\nQuadratureDefinition quadrature.h:123\\nIn the protected section of this class, we first have a number of member variables, of which the use should be clear from the previous examples:\\n\\u00a0     protected:\\n\\u00a0       const SmartPointer<const FiniteElement<dim>> fe;\\n\\u00a0       const SmartPointer<const Quadrature<dim>>    quadrature;\\n\\u00a0       DoFHandler<dim>                              dof_handler;\\n\\u00a0       Vector<double>                               solution;\\n\\u00a0       const SmartPointer<const Function<dim>>      boundary_values;\\n\\u00a0 \\nThen we declare an abstract function that will be used to assemble the right hand side. As explained above, there are various cases for which this action differs strongly in what is necessary, so we defer this to derived classes:\\n\\u00a0       virtual void assemble_rhs(Vector<double> &rhs) const = 0;\\n\\u00a0 \\nNext, in the private section, we have a small class which represents an entire linear system, i.e. a matrix, a right hand side, and a solution vector, as well as the constraints that are applied to it, such as those due to hanging nodes. Its constructor initializes the various subobjects, and there is a function that implements a conjugate gradient method as solver.\\n\\u00a0     private:\\n\\u00a0       struct LinearSystem\\n\\u00a0       {\\n\\u00a0         LinearSystem(const DoFHandler<dim> &dof_handler);\\n\\u00a0 \\n\\u00a0         void solve(Vector<double> &solution) const;\\n\\u00a0 \\n\\u00a0         AffineConstraints<double> hanging_node_constraints;\\n\\u00a0         SparsityPattern           sparsity_pattern;\\n\\u00a0         SparseMatrix<double>      matrix;\\n\\u00a0         Vector<double>            rhs;\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nSparseMatrixDefinition sparse_matrix.h:520\\nSparsityPatternDefinition sparsity_pattern.h:343\\nFinally, there is a set of functions which will be used to assemble the actual system matrix. The main function of this group, assemble_linear_system() computes the matrix in parallel on multicore systems, using the following two helper functions. The mechanism for doing so is the same as in the step-9 example program and follows the WorkStream concept outlined in Parallel computing with multiple processors accessing shared memory . The main function also calls the virtual function assembling the right hand side.\\n\\u00a0       struct AssemblyScratchData\\n\\u00a0       {\\n\\u00a0         AssemblyScratchData(const FiniteElement<dim> &fe,\\n\\u00a0                             const Quadrature<dim>    &quadrature);\\n\\u00a0         AssemblyScratchData(const AssemblyScratchData &scratch_data);\\n\\u00a0 \\n\\u00a0         FEValues<dim> fe_values;\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0       struct AssemblyCopyData\\n\\u00a0       {\\n\\u00a0         FullMatrix<double>                   cell_matrix;\\n\\u00a0         std::vector<types::global_dof_index> local_dof_indices;\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0       void assemble_linear_system(LinearSystem &linear_system);\\n\\u00a0 \\n\\u00a0       void local_assemble_matrix(\\n\\u00a0         const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0         AssemblyScratchData                                  &scratch_data,\\n\\u00a0         AssemblyCopyData                                     &copy_data) const;\\n\\u00a0 \\n\\u00a0       void copy_local_to_global(const AssemblyCopyData &copy_data,\\n\\u00a0                                 LinearSystem           &linear_system) const;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFEValuesDefinition fe_values.h:63\\nFullMatrixDefinition full_matrix.h:79\\nDoFHandler::active_cell_iteratortypename ActiveSelector::active_cell_iterator active_cell_iteratorDefinition dof_handler.h:440\\nNow here comes the constructor of the class. It does not do much except store pointers to the objects given, and generate DoFHandler object initialized with the given pointer to a triangulation. This causes the DoF handler to store that pointer, but does not already generate a finite element numbering (we only ask for that in the solve_problem function).\\n\\u00a0     template <int dim>\\n\\u00a0     Solver<dim>::Solver(Triangulation<dim>       &triangulation,\\n\\u00a0                         const FiniteElement<dim> &fe,\\n\\u00a0                         const Quadrature<dim>    &quadrature,\\n\\u00a0                         const Function<dim>      &boundary_values)\\n\\u00a0       : Base<dim>(triangulation)\\n\\u00a0       , fe(&fe)\\n\\u00a0       , quadrature(&quadrature)\\n\\u00a0       , dof_handler(triangulation)\\n\\u00a0       , boundary_values(&boundary_values)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\nThe destructor is simple, it only clears the information stored in the DoF handler object to release the memory.\\n\\u00a0     template <int dim>\\n\\u00a0     Solver<dim>::~Solver()\\n\\u00a0     {\\n\\u00a0       dof_handler.clear();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\nThe next function is the one which delegates the main work in solving the problem: it sets up the DoF handler object with the finite element given to the constructor of this object, the creates an object that denotes the linear system (i.e. the matrix, the right hand side vector, and the solution vector), calls the function to assemble it, and finally solves it:\\n\\u00a0     template <int dim>\\n\\u00a0     void Solver<dim>::solve_problem()\\n\\u00a0     {\\n\\u00a0       dof_handler.distribute_dofs(*fe);\\n\\u00a0       solution.reinit(dof_handler.n_dofs());\\n\\u00a0 \\n\\u00a0       LinearSystem linear_system(dof_handler);\\n\\u00a0       assemble_linear_system(linear_system);\\n\\u00a0       linear_system.solve(solution);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\nAs stated above, the postprocess function takes an evaluation object, and applies it to the computed solution. This function may be called multiply, once for each evaluation of the solution which the user required.\\n\\u00a0     template <int dim>\\n\\u00a0     void Solver<dim>::postprocess(\\n\\u00a0       const Evaluation::EvaluationBase<dim> &postprocessor) const\\n\\u00a0     {\\n\\u00a0       postprocessor(dof_handler, solution);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\nThe n_dofs function should be self-explanatory:\\n\\u00a0     template <int dim>\\n\\u00a0     unsigned int Solver<dim>::n_dofs() const\\n\\u00a0     {\\n\\u00a0       return dof_handler.n_dofs();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\nThe following function assembles matrix and right hand side of the linear system to be solved in each step. We will do things in parallel at a couple of levels. First, note that we need to assemble both the matrix and the right hand side. These are independent operations, and we should do this in parallel. To this end, we use the concept of \\\"tasks\\\" that is discussed in the Parallel computing with multiple processors accessing shared memory documentation topic. In essence, what we want to say \\\"here is something that needs to be worked on, go do it\\n   whenever a CPU core is available\\\", then do something else, and when we need the result of the first operation wait for its completion. At the second level, we want to assemble the matrix using the exact same strategy we have already used in step-9, namely the WorkStream concept.\\nWhile we could consider either assembling the right hand side or assembling the matrix as the thing to do in the background while doing the other, we will opt for the former approach simply because the call to Solver::assemble_rhs is so much simpler to write than the call to WorkStream::run with its many arguments. In any case, the code then looks like this to assemble the entire linear system:\\n\\u00a0     template <int dim>\\n\\u00a0     void Solver<dim>::assemble_linear_system(LinearSystem &linear_system)\\n\\u00a0     {\\n\\u00a0       Threads::Task<void> rhs_task =\\n\\u00a0         Threads::new_task(&Solver<dim>::assemble_rhs, *this, linear_system.rhs);\\n\\u00a0 \\n\\u00a0       auto worker =\\n\\u00a0         [this](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0                AssemblyScratchData &scratch_data,\\n\\u00a0                AssemblyCopyData    &copy_data) {\\n\\u00a0           this->local_assemble_matrix(cell, scratch_data, copy_data);\\n\\u00a0         };\\n\\u00a0 \\n\\u00a0       auto copier = [this, &linear_system](const AssemblyCopyData &copy_data) {\\n\\u00a0         this->copy_local_to_global(copy_data, linear_system);\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0       WorkStream::run(dof_handler.begin_active(),\\n\\u00a0                       dof_handler.end(),\\n\\u00a0                       worker,\\n\\u00a0                       copier,\\n\\u00a0                       AssemblyScratchData(*fe, *quadrature),\\n\\u00a0                       AssemblyCopyData());\\n\\u00a0       linear_system.hanging_node_constraints.condense(linear_system.matrix);\\n\\u00a0 \\nThreads::TaskDefinition thread_management.h:489\\nThreads::new_taskTask< RT > new_task(const std::function< RT()> &function)Definition thread_management.h:1153\\nWorkStream::runvoid run(const std::vector< std::vector< Iterator > > &colored_iterators, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length=2 *MultithreadInfo::n_threads(), const unsigned int chunk_size=8)Definition work_stream.h:1272\\nThe syntax above requires some explanation. There are multiple version of WorkStream::run that expect different arguments. In step-9, we used one version that took a pair of iterators, a pair of pointers to member functions with very specific argument lists, a pointer or reference to the object on which these member functions have to work, and a scratch and copy data object. This is a bit restrictive since the member functions called this way have to have an argument list that exactly matches what WorkStream::run expects: the local assembly function needs to take an iterator, a scratch object and a copy object; and the copy-local-to-global function needs to take exactly a copy object. But, what if we want something that's slightly more general? For example, in the current program, the copy-local-to-global function needs to know which linear system object to write the local contributions into, i.e., it also has to take a LinearSystem argument. That won't work with the approach using member function pointers.\\nFortunately, C++ offers a way out. These are called function objects. In essence, what WorkStream::run wants to do is not call a member function. It wants to call some function that takes an iterator, a scratch object and a copy object in the first case, and a copy object in the second case. Whether these are member functions, global functions, or something else, is really not of much concern to WorkStream. Consequently, there is a second version of the function that just takes function objects \\u2013 objects that have an operator() and that consequently can be called like functions, whatever they really represent. The typical way to generate such function objects is using a lambda function that wraps the function call including the individual arguments with fixed values. All the arguments that are part of the outer function signature are specified as regular function arguments in the lambda function. The fixed values are passed into the lambda function using the capture list ([...]). It is possible to use a capture default or to list all the variables that are to be bound to the lambda explicitly. For the sake of clarity we decided to omit the capture default here, but that capture list could equally well be [&], meaning that all used variables are copied into the lambda by reference.\\nAt this point, we have assembled the matrix and condensed it. The right hand side may or may not have been completely assembled, but we would like to condense the right hand side vector next. We can only do this if the assembly of this vector has finished, so we have to wait for the task to finish; in computer science, waiting for a task is typically called \\\"joining\\\" the task, explaining the name of the function we call below.\\nSince that task may or may not have finished, and since we may have to wait for it to finish, we may as well try to pack other things that need to be done anyway into this gap. Consequently, we first interpolate boundary values before we wait for the right hand side. Of course, another possibility would have been to also interpolate the boundary values on a separate task since doing so is independent of the other things we have done in this function so far. Feel free to find the correct syntax to also create a task for this interpolation and start it at the top of this function, along with the assembly of the right hand side. (You will find that this is slightly more complicated since there are multiple versions of VectorTools::interpolate_boundary_values(), and so simply taking the address &VectorTools::interpolate_boundary_values produces a set of overloaded functions that can't be passed to Threads::new_task() right away \\u2013 you have to select which element of this overload set you want by casting the address expression to a function pointer type that is specific to the version of the function that you want to call on the task.)\\n\\u00a0       std::map<types::global_dof_index, double> boundary_value_map;\\n\\u00a0       VectorTools::interpolate_boundary_values(dof_handler,\\n\\u00a0                                                0,\\n\\u00a0                                                *boundary_values,\\n\\u00a0                                                boundary_value_map);\\n\\u00a0 \\n\\u00a0       rhs_task.join();\\n\\u00a0       linear_system.hanging_node_constraints.condense(linear_system.rhs);\\n\\u00a0 \\nVectorTools::interpolate_boundary_valuesvoid interpolate_boundary_values(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const std::map< types::boundary_id, const Function< spacedim, number > * > &function_map, std::map< types::global_dof_index, number > &boundary_values, const ComponentMask &component_mask={})\\nNow that we have the complete linear system, we can also treat boundary values, which need to be eliminated from both the matrix and the right hand side:\\n\\u00a0       MatrixTools::apply_boundary_values(boundary_value_map,\\n\\u00a0                                          linear_system.matrix,\\n\\u00a0                                          solution,\\n\\u00a0                                          linear_system.rhs);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\nMatrixTools::apply_boundary_valuesvoid apply_boundary_values(const std::map< types::global_dof_index, number > &boundary_values, SparseMatrix< number > &matrix, Vector< number > &solution, Vector< number > &right_hand_side, const bool eliminate_columns=true)Definition matrix_tools.cc:75\\nThe second half of this set of functions deals with the local assembly on each cell and copying local contributions into the global matrix object. This works in exactly the same way as described in step-9:\\n\\u00a0     template <int dim>\\n\\u00a0     Solver<dim>::AssemblyScratchData::AssemblyScratchData(\\n\\u00a0       const FiniteElement<dim> &fe,\\n\\u00a0       const Quadrature<dim>    &quadrature)\\n\\u00a0       : fe_values(fe, quadrature, update_gradients | update_JxW_values)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     Solver<dim>::AssemblyScratchData::AssemblyScratchData(\\n\\u00a0       const AssemblyScratchData &scratch_data)\\n\\u00a0       : fe_values(scratch_data.fe_values.get_fe(),\\n\\u00a0                   scratch_data.fe_values.get_quadrature(),\\n\\u00a0                   update_gradients | update_JxW_values)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void Solver<dim>::local_assemble_matrix(\\n\\u00a0       const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0       AssemblyScratchData                                  &scratch_data,\\n\\u00a0       AssemblyCopyData                                     &copy_data) const\\n\\u00a0     {\\n\\u00a0       const unsigned int dofs_per_cell = fe->n_dofs_per_cell();\\n\\u00a0       const unsigned int n_q_points    = quadrature->size();\\n\\u00a0 \\n\\u00a0       copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);\\n\\u00a0 \\n\\u00a0       copy_data.local_dof_indices.resize(dofs_per_cell);\\n\\u00a0 \\n\\u00a0       scratch_data.fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0       for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n\\u00a0         for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0           for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0             copy_data.cell_matrix(i, j) +=\\n\\u00a0               (scratch_data.fe_values.shape_grad(i, q_point) *\\n\\u00a0                scratch_data.fe_values.shape_grad(j, q_point) *\\n\\u00a0                scratch_data.fe_values.JxW(q_point));\\n\\u00a0 \\n\\u00a0       cell->get_dof_indices(copy_data.local_dof_indices);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void Solver<dim>::copy_local_to_global(const AssemblyCopyData &copy_data,\\n\\u00a0                                            LinearSystem &linear_system) const\\n\\u00a0     {\\n\\u00a0       for (unsigned int i = 0; i < copy_data.local_dof_indices.size(); ++i)\\n\\u00a0         for (unsigned int j = 0; j < copy_data.local_dof_indices.size(); ++j)\\n\\u00a0           linear_system.matrix.add(copy_data.local_dof_indices[i],\\n\\u00a0                                    copy_data.local_dof_indices[j],\\n\\u00a0                                    copy_data.cell_matrix(i, j));\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\nint\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nNow for the functions that implement actions in the linear system class. First, the constructor initializes all data elements to their correct sizes, and sets up a number of additional data structures, such as constraints due to hanging nodes. Since setting up the hanging nodes and finding out about the nonzero elements of the matrix is independent, we do that in parallel (if the library was configured to use concurrency, at least; otherwise, the actions are performed sequentially). Note that we start only one thread, and do the second action in the main thread. Since only one task is generated, we don't use the Threads::TaskGroup class here, but rather use the one created task object directly to wait for this particular task's exit.\\nNote that taking up the address of the DoFTools::make_hanging_node_constraints function is a little tricky, since there are actually three of them, one for each supported space dimension. Taking addresses of overloaded functions is somewhat complicated in C++, since the address-of operator & in that case returns more like a set of values (the addresses of all functions with that name), and selecting the right one is then the next step. If the context dictates which one to take (for example by assigning to a function pointer of known type), then the compiler can do that by itself, but if this set of pointers shall be given as the argument to a function that takes a template, the compiler could choose all without having a preference for one. We therefore have to make it clear to the compiler which one we would like to have; for this, we could use a cast, but for more clarity, we assign it to a temporary mhnc_p (short for pointer to make_hanging_node_constraints) with the right type, and using this pointer instead.\\n\\u00a0     template <int dim>\\n\\u00a0     Solver<dim>::LinearSystem::LinearSystem(const DoFHandler<dim> &dof_handler)\\n\\u00a0     {\\n\\u00a0       hanging_node_constraints.clear();\\n\\u00a0 \\n\\u00a0       void (*mhnc_p)(const DoFHandler<dim> &, AffineConstraints<double> &) =\\n\\u00a0         &DoFTools::make_hanging_node_constraints;\\n\\u00a0 \\nDoFTools::make_hanging_node_constraintsvoid make_hanging_node_constraints(const DoFHandler< dim, spacedim > &dof_handler, AffineConstraints< number > &constraints)Definition dof_tools_constraints.cc:3073\\nStart a side task then continue on the main thread\\n\\u00a0       Threads::Task<void> side_task =\\n\\u00a0         Threads::new_task(mhnc_p, dof_handler, hanging_node_constraints);\\n\\u00a0 \\n\\u00a0       DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());\\n\\u00a0       DoFTools::make_sparsity_pattern(dof_handler, dsp);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nDoFHandler::n_dofstypes::global_dof_index n_dofs() const\\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nWait for the side task to be done before going further\\n\\u00a0       side_task.join();\\n\\u00a0 \\n\\u00a0       hanging_node_constraints.close();\\n\\u00a0       hanging_node_constraints.condense(dsp);\\n\\u00a0       sparsity_pattern.copy_from(dsp);\\n\\u00a0 \\n\\u00a0 \\nFinally initialize the matrix and right hand side vector\\n\\u00a0       matrix.reinit(sparsity_pattern);\\n\\u00a0       rhs.reinit(dof_handler.n_dofs());\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nThe second function of this class simply solves the linear system by a preconditioned conjugate gradient method. This has been extensively discussed before, so we don't dwell into it any more.\\n\\u00a0     template <int dim>\\n\\u00a0     void Solver<dim>::LinearSystem::solve(Vector<double> &solution) const\\n\\u00a0     {\\n\\u00a0       SolverControl            solver_control(1000, 1e-12);\\n\\u00a0       SolverCG<Vector<double>> cg(solver_control);\\n\\u00a0 \\n\\u00a0       PreconditionSSOR<SparseMatrix<double>> preconditioner;\\n\\u00a0       preconditioner.initialize(matrix, 1.2);\\n\\u00a0 \\n\\u00a0       cg.solve(matrix, solution, rhs, preconditioner);\\n\\u00a0 \\n\\u00a0       hanging_node_constraints.distribute(solution);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nPreconditionSSORDefinition precondition.h:1778\\nPreconditionSSOR::initializevoid initialize(const MatrixType &A, const AdditionalData &parameters=AdditionalData())\\nSolverCGDefinition solver_cg.h:179\\nSolverControlDefinition solver_control.h:67\\n A primal solver\\nIn the previous section, a base class for Laplace solvers was implemented, that lacked the functionality to assemble the right hand side vector, however, for reasons that were explained there. Now we implement a corresponding class that can do this for the case that the right hand side of a problem is given as a function object.\\nThe actions of the class are rather what you have seen already in previous examples already, so a brief explanation should suffice: the constructor takes the same data as does that of the underlying class (to which it passes all information) except for one function object that denotes the right hand side of the problem. A pointer to this object is stored (again as a SmartPointer, in order to make sure that the function object is not deleted as long as it is still used by this class).\\nThe only functional part of this class is the assemble_rhs method that does what its name suggests.\\n\\u00a0     template <int dim>\\n\\u00a0     class PrimalSolver : public Solver<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       PrimalSolver(Triangulation<dim>       &triangulation,\\n\\u00a0                    const FiniteElement<dim> &fe,\\n\\u00a0                    const Quadrature<dim>    &quadrature,\\n\\u00a0                    const Function<dim>      &rhs_function,\\n\\u00a0                    const Function<dim>      &boundary_values);\\n\\u00a0 \\n\\u00a0     protected:\\n\\u00a0       const SmartPointer<const Function<dim>> rhs_function;\\n\\u00a0       virtual void assemble_rhs(Vector<double> &rhs) const override;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\nThe constructor of this class basically does what it is announced to do above...\\n\\u00a0     template <int dim>\\n\\u00a0     PrimalSolver<dim>::PrimalSolver(Triangulation<dim>       &triangulation,\\n\\u00a0                                     const FiniteElement<dim> &fe,\\n\\u00a0                                     const Quadrature<dim>    &quadrature,\\n\\u00a0                                     const Function<dim>      &rhs_function,\\n\\u00a0                                     const Function<dim>      &boundary_values)\\n\\u00a0       : Base<dim>(triangulation)\\n\\u00a0       , Solver<dim>(triangulation, fe, quadrature, boundary_values)\\n\\u00a0       , rhs_function(&rhs_function)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n... as does the assemble_rhs function. Since this is explained in several of the previous example programs, we leave it at that.\\n\\u00a0     template <int dim>\\n\\u00a0     void PrimalSolver<dim>::assemble_rhs(Vector<double> &rhs) const\\n\\u00a0     {\\n\\u00a0       FEValues<dim> fe_values(*this->fe,\\n\\u00a0                               *this->quadrature,\\n\\u00a0                               update_values | update_quadrature_points |\\n\\u00a0                                 update_JxW_values);\\n\\u00a0 \\n\\u00a0       const unsigned int dofs_per_cell = this->fe->n_dofs_per_cell();\\n\\u00a0       const unsigned int n_q_points    = this->quadrature->size();\\n\\u00a0 \\n\\u00a0       Vector<double>                       cell_rhs(dofs_per_cell);\\n\\u00a0       std::vector<double>                  rhs_values(n_q_points);\\n\\u00a0       std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0       for (const auto &cell : this->dof_handler.active_cell_iterators())\\n\\u00a0         {\\n\\u00a0           cell_rhs = 0;\\n\\u00a0           fe_values.reinit(cell);\\n\\u00a0           rhs_function->value_list(fe_values.get_quadrature_points(),\\n\\u00a0                                    rhs_values);\\n\\u00a0 \\n\\u00a0           for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n\\u00a0             for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0               cell_rhs(i) += fe_values.shape_value(i, q_point) * \\n\\u00a0                              rhs_values[q_point] *               \\n\\u00a0                              fe_values.JxW(q_point);\\n\\u00a0 \\n\\u00a0           cell->get_dof_indices(local_dof_indices);\\n\\u00a0           for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0             rhs(local_dof_indices[i]) += cell_rhs(i);\\n\\u00a0         };\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\n Global refinement\\nBy now, all functions of the abstract base class except for the refine_grid function have been implemented. We will now have two classes that implement this function for the PrimalSolver class, one doing global refinement, one a form of local refinement.\\nThe first, doing global refinement, is rather simple: its main function just calls triangulation->refine_global (1);, which does all the work.\\nNote that since the Base base class of the Solver class is virtual, we have to declare a constructor that initializes the immediate base class as well as the abstract virtual one.\\nApart from this technical complication, the class is probably simple enough to be left without further comments.\\n\\u00a0     template <int dim>\\n\\u00a0     class RefinementGlobal : public PrimalSolver<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       RefinementGlobal(Triangulation<dim>       &coarse_grid,\\n\\u00a0                        const FiniteElement<dim> &fe,\\n\\u00a0                        const Quadrature<dim>    &quadrature,\\n\\u00a0                        const Function<dim>      &rhs_function,\\n\\u00a0                        const Function<dim>      &boundary_values);\\n\\u00a0 \\n\\u00a0       virtual void refine_grid() override;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     RefinementGlobal<dim>::RefinementGlobal(\\n\\u00a0       Triangulation<dim>       &coarse_grid,\\n\\u00a0       const FiniteElement<dim> &fe,\\n\\u00a0       const Quadrature<dim>    &quadrature,\\n\\u00a0       const Function<dim>      &rhs_function,\\n\\u00a0       const Function<dim>      &boundary_values)\\n\\u00a0       : Base<dim>(coarse_grid)\\n\\u00a0       , PrimalSolver<dim>(coarse_grid,\\n\\u00a0                           fe,\\n\\u00a0                           quadrature,\\n\\u00a0                           rhs_function,\\n\\u00a0                           boundary_values)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void RefinementGlobal<dim>::refine_grid()\\n\\u00a0     {\\n\\u00a0       this->triangulation->refine_global(1);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n Local refinement by the Kelly error indicator\\nThe second class implementing refinement strategies uses the Kelly refinement indicator used in various example programs before. Since this indicator is already implemented in a class of its own inside the deal.II library, there is not much t do here except cal the function computing the indicator, then using it to select a number of cells for refinement and coarsening, and refinement the mesh accordingly.\\nAgain, this should now be sufficiently standard to allow the omission of further comments.\\n\\u00a0     template <int dim>\\n\\u00a0     class RefinementKelly : public PrimalSolver<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       RefinementKelly(Triangulation<dim>       &coarse_grid,\\n\\u00a0                       const FiniteElement<dim> &fe,\\n\\u00a0                       const Quadrature<dim>    &quadrature,\\n\\u00a0                       const Function<dim>      &rhs_function,\\n\\u00a0                       const Function<dim>      &boundary_values);\\n\\u00a0 \\n\\u00a0       virtual void refine_grid() override;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     RefinementKelly<dim>::RefinementKelly(Triangulation<dim>       &coarse_grid,\\n\\u00a0                                           const FiniteElement<dim> &fe,\\n\\u00a0                                           const Quadrature<dim>    &quadrature,\\n\\u00a0                                           const Function<dim> &rhs_function,\\n\\u00a0                                           const Function<dim> &boundary_values)\\n\\u00a0       : Base<dim>(coarse_grid)\\n\\u00a0       , PrimalSolver<dim>(coarse_grid,\\n\\u00a0                           fe,\\n\\u00a0                           quadrature,\\n\\u00a0                           rhs_function,\\n\\u00a0                           boundary_values)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void RefinementKelly<dim>::refine_grid()\\n\\u00a0     {\\n\\u00a0       Vector<float> estimated_error_per_cell(\\n\\u00a0         this->triangulation->n_active_cells());\\n\\u00a0       KellyErrorEstimator<dim>::estimate(\\n\\u00a0         this->dof_handler,\\n\\u00a0         QGauss<dim - 1>(this->fe->degree + 1),\\n\\u00a0         std::map<types::boundary_id, const Function<dim> *>(),\\n\\u00a0         this->solution,\\n\\u00a0         estimated_error_per_cell);\\n\\u00a0       GridRefinement::refine_and_coarsen_fixed_number(*this->triangulation,\\n\\u00a0                                                       estimated_error_per_cell,\\n\\u00a0                                                       0.3,\\n\\u00a0                                                       0.03);\\n\\u00a0       this->triangulation->execute_coarsening_and_refinement();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   } // namespace LaplaceSolver\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nKellyErrorEstimator::estimatestatic void estimate(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const Quadrature< dim - 1 > &quadrature, const std::map< types::boundary_id, const Function< spacedim, Number > * > &neumann_bc, const ReadVector< Number > &solution, Vector< float > &error, const ComponentMask &component_mask={}, const Function< spacedim > *coefficients=nullptr, const unsigned int n_threads=numbers::invalid_unsigned_int, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id, const types::material_id material_id=numbers::invalid_material_id, const Strategy strategy=cell_diameter_over_24)\\nQGaussDefinition quadrature_lib.h:40\\nTriangulation::execute_coarsening_and_refinementvirtual void execute_coarsening_and_refinement()\\nunsigned int\\nGridRefinement::refine_and_coarsen_fixed_numbervoid refine_and_coarsen_fixed_number(Triangulation< dim, spacedim > &triangulation, const Vector< Number > &criteria, const double top_fraction_of_cells, const double bottom_fraction_of_cells, const unsigned int max_n_cells=std::numeric_limits< unsigned int >::max())Definition grid_refinement.cc:318\\n Equation data\\nAs this is one more academic example, we'd like to compare exact and computed solution against each other. For this, we need to declare function classes representing the exact solution (for comparison and for the Dirichlet boundary values), as well as a class that denotes the right hand side of the equation (this is simply the Laplace operator applied to the exact solution we'd like to recover).\\nFor this example, let us choose as exact solution the function \\\\(u(x,y)=exp(x+sin(10y+5x^2))\\\\). In more than two dimensions, simply repeat the sine-factor with y replaced by z and so on. Given this, the following two classes are probably straightforward from the previous examples.\\n\\u00a0   template <int dim>\\n\\u00a0   class Solution : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component) const override;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double Solution<dim>::value(const Point<dim>  &p,\\n\\u00a0                               const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     (void)component;\\n\\u00a0     AssertIndexRange(component, 1);\\n\\u00a0     double q = p[0];\\n\\u00a0     for (unsigned int i = 1; i < dim; ++i)\\n\\u00a0       q += std::sin(10 * p[i] + 5 * p[0] * p[0]);\\n\\u00a0     const double exponential = std::exp(q);\\n\\u00a0     return exponential;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   class RightHandSide : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component) const override;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double RightHandSide<dim>::value(const Point<dim>  &p,\\n\\u00a0                                    const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     (void)component;\\n\\u00a0     AssertIndexRange(component, 1);\\n\\u00a0     double q = p[0];\\n\\u00a0     for (unsigned int i = 1; i < dim; ++i)\\n\\u00a0       q += std::sin(10 * p[i] + 5 * p[0] * p[0]);\\n\\u00a0     const double u  = std::exp(q);\\n\\u00a0     double       t1 = 1, t2 = 0, t3 = 0;\\n\\u00a0     for (unsigned int i = 1; i < dim; ++i)\\n\\u00a0       {\\n\\u00a0         t1 += std::cos(10 * p[i] + 5 * p[0] * p[0]) * 10 * p[0];\\n\\u00a0         t2 += 10 * std::cos(10 * p[i] + 5 * p[0] * p[0]) -\\n\\u00a0               100 * std::sin(10 * p[i] + 5 * p[0] * p[0]) * p[0] * p[0];\\n\\u00a0         t3 += 100 * std::cos(10 * p[i] + 5 * p[0] * p[0]) *\\n\\u00a0                 std::cos(10 * p[i] + 5 * p[0] * p[0]) -\\n\\u00a0               100 * std::sin(10 * p[i] + 5 * p[0] * p[0]);\\n\\u00a0       };\\n\\u00a0     t1 = t1 * t1;\\n\\u00a0 \\n\\u00a0     return -u * (t1 + t2 + t3);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFunction::valuevirtual RangeNumberType value(const Point< dim > &p, const unsigned int component=0) const\\nAssertIndexRange#define AssertIndexRange(index, range)Definition exceptions.h:2053\\nstd::exp::VectorizedArray< Number, width > exp(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6829\\nstd::cos::VectorizedArray< Number, width > cos(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6609\\nstd::sin::VectorizedArray< Number, width > sin(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6589\\n The driver routines\\nWhat is now missing are only the functions that actually select the various options, and run the simulation on successively finer grids to monitor the progress as the mesh is refined.\\nThis we do in the following function: it takes a solver object, and a list of postprocessing (evaluation) objects, and runs them with intermittent mesh refinement:\\n\\u00a0   template <int dim>\\n\\u00a0   void run_simulation(\\n\\u00a0     LaplaceSolver::Base<dim>                           &solver,\\n\\u00a0     const std::list<Evaluation::EvaluationBase<dim> *> &postprocessor_list)\\n\\u00a0   {\\nWe will give an indicator of the step we are presently computing, in order to keep the user informed that something is still happening, and that the program is not in an endless loop. This is the head of this status line:\\n\\u00a0     std::cout << \\\"Refinement cycle: \\\";\\n\\u00a0 \\nThen start a loop which only terminates once the number of degrees of freedom is larger than 20,000 (you may of course change this limit, if you need more \\u2013 or less \\u2013 accuracy from your program).\\n\\u00a0     for (unsigned int step = 0; true; ++step)\\n\\u00a0       {\\nThen give the alive indication for this iteration. Note that the std::flush is needed to have the text actually appear on the screen, rather than only in some buffer that is only flushed the next time we issue an end-line.\\n\\u00a0         std::cout << step << ' ' << std::flush;\\n\\u00a0 \\nNow solve the problem on the present grid, and run the evaluators on it. The long type name of iterators into the list is a little annoying, but could be shortened by an alias, if so desired.\\n\\u00a0         solver.solve_problem();\\n\\u00a0 \\n\\u00a0         for (const auto &postprocessor : postprocessor_list)\\n\\u00a0           {\\n\\u00a0             postprocessor->set_refinement_cycle(step);\\n\\u00a0             solver.postprocess(*postprocessor);\\n\\u00a0           };\\n\\u00a0 \\n\\u00a0 \\nNow check whether more iterations are required, or whether the loop shall be ended:\\n\\u00a0         if (solver.n_dofs() < 20000)\\n\\u00a0           solver.refine_grid();\\n\\u00a0         else\\n\\u00a0           break;\\n\\u00a0       };\\n\\u00a0 \\nFinally end the line in which we displayed status reports:\\n\\u00a0     std::cout << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nThe final function is one which takes the name of a solver (presently \\\"kelly\\\" and \\\"global\\\" are allowed), creates a solver object out of it using a coarse grid (in this case the ubiquitous unit square) and a finite element object (here the likewise ubiquitous bilinear one), and uses that solver to ask for the solution of the problem on a sequence of successively refined grids.\\nThe function also sets up two of evaluation functions, one evaluating the solution at the point (0.5,0.5), the other writing out the solution to a file.\\n\\u00a0   template <int dim>\\n\\u00a0   void solve_problem(const std::string &solver_name)\\n\\u00a0   {\\nFirst minor task: tell the user what is going to happen. Thus write a header line, and a line with all '-' characters of the same length as the first one right below.\\n\\u00a0     const std::string header =\\n\\u00a0       \\\"Running tests with \\\\\\\"\\\" + solver_name + \\\"\\\\\\\" refinement criterion:\\\";\\n\\u00a0     std::cout << header << std::endl\\n\\u00a0               << std::string(header.size(), '-') << std::endl;\\n\\u00a0 \\nThen set up triangulation, finite element, etc.\\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0     GridGenerator::hyper_cube(triangulation, -1, 1);\\n\\u00a0     triangulation.refine_global(2);\\n\\u00a0     const FE_Q<dim>    fe(1);\\n\\u00a0     const QGauss<dim>  quadrature(4);\\n\\u00a0     RightHandSide<dim> rhs_function;\\n\\u00a0     Solution<dim>      boundary_values;\\n\\u00a0 \\nFE_QDefinition fe_q.h:554\\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nGridGenerator::hyper_cubevoid hyper_cube(Triangulation< dim, spacedim > &tria, const double left=0., const double right=1., const bool colorize=false)\\nCreate a solver object of the kind indicated by the argument to this function. If the name is not recognized, throw an exception! The respective solver object is stored in a std::unique_ptr to avoid having to delete the pointer after use.\\n\\u00a0     std::unique_ptr<LaplaceSolver::Base<dim>> solver;\\n\\u00a0     if (solver_name == \\\"global\\\")\\n\\u00a0       solver = std::make_unique<LaplaceSolver::RefinementGlobal<dim>>(\\n\\u00a0         triangulation, fe, quadrature, rhs_function, boundary_values);\\n\\u00a0     else if (solver_name == \\\"kelly\\\")\\n\\u00a0       solver = std::make_unique<LaplaceSolver::RefinementKelly<dim>>(\\n\\u00a0         triangulation, fe, quadrature, rhs_function, boundary_values);\\n\\u00a0     else\\n\\u00a0       AssertThrow(false, ExcNotImplemented());\\n\\u00a0 \\nNext create a table object in which the values of the numerical solution at the point (0.5,0.5) will be stored, and create a respective evaluation object:\\n\\u00a0     TableHandler                          results_table;\\n\\u00a0     Evaluation::PointValueEvaluation<dim> postprocessor1(Point<dim>(0.5, 0.5),\\n\\u00a0                                                          results_table);\\n\\u00a0 \\nAlso generate an evaluator which writes out the solution:\\n\\u00a0     Evaluation::SolutionOutput<dim> postprocessor2(std::string(\\\"solution-\\\") +\\n\\u00a0                                                      solver_name,\\n\\u00a0                                                    DataOutBase::gnuplot);\\n\\u00a0 \\nDataOutBase::gnuplot@ gnuplotDefinition data_out_base.h:1637\\nTake these two evaluation objects and put them in a list...\\n\\u00a0     std::list<Evaluation::EvaluationBase<dim> *> postprocessor_list;\\n\\u00a0     postprocessor_list.push_back(&postprocessor1);\\n\\u00a0     postprocessor_list.push_back(&postprocessor2);\\n\\u00a0 \\n... which we can then pass on to the function that actually runs the simulation on successively refined grids:\\n\\u00a0     run_simulation(*solver, postprocessor_list);\\n\\u00a0 \\nWhen this all is done, write out the results of the point evaluations:\\n\\u00a0     results_table.write_text(std::cout);\\n\\u00a0 \\nAnd one blank line after all results:\\n\\u00a0     std::cout << std::endl;\\n\\u00a0   }\\n\\u00a0 } // namespace Step13\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nThere is not much to say about the main function. It follows the same pattern as in all previous examples, with attempts to catch thrown exceptions, and displaying as much information as possible if we should get some. The rest is self-explanatory.\\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       Step13::solve_problem<2>(\\\"global\\\");\\n\\u00a0       Step13::solve_problem<2>(\\\"kelly\\\");\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nThe results of this program are not that interesting - after all its purpose was not to demonstrate some new mathematical idea, and also not how to program with deal.II, but rather to use the material which we have developed in the previous examples to form something which demonstrates a way to build modern finite element software in a modular and extensible way.\\nNevertheless, we of course show the results of the program. Of foremost interest is the point value computation, for which we had implemented the corresponding evaluation class. The results (i.e. the output) of the program looks as follows: Running tests with \\\"global\\\" refinement criterion:\\n-------------------------------------------------\\nRefinement cycle: 0 1 2 3 4 5 6\\nDoFs  u(x_0)\\n   25 1.2868\\n   81 1.6945\\n  289 1.4658\\n 1089 1.5679\\n 4225 1.5882\\n16641 1.5932\\n66049 1.5945\\n \\nRunning tests with \\\"kelly\\\" refinement criterion:\\n------------------------------------------------\\nRefinement cycle: 0 1 2 3 4 5 6 7 8 9 10 11\\nDoFs  u(x_0)\\n   25 1.2868\\n   47 0.8775\\n   89 1.5365\\n  165 1.2974\\n  316 1.6442\\n  589 1.5221\\n 1093 1.5724\\n 2042 1.5627\\n 3766 1.5916\\n 7124 1.5876\\n13111 1.5942\\n24838 1.5932\\nWhat surprises here is that the exact value is 1.59491554..., and that it is apparently surprisingly complicated to compute the solution even to only one per cent accuracy, although the solution is smooth (in fact infinitely often differentiable). This smoothness is shown in the graphical output generated by the program, here coarse grid and the first 9 refinement steps of the Kelly refinement indicator:\\n\\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\nWhile we're already at watching pictures, this is the eighth grid, as viewed from top:\\n\\nHowever, we are not yet finished with evaluation the point value computation. In fact, plotting the error \\\\(e=|u(x_0)-u_h(x_0)|\\\\) for the two refinement criteria yields the following picture:\\n\\nWhat is disturbing about this picture is that not only is the adaptive mesh refinement not better than global refinement as one would usually expect, it is even significantly worse since its convergence is irregular, preventing all extrapolation techniques when using the values of subsequent meshes! On the other hand, global refinement provides a perfect \\\\(1/N\\\\) or \\\\(h^{-2}\\\\) convergence history and provides every opportunity to even improve on the point values by extrapolation. Global mesh refinement must therefore be considered superior in this example! This is even more surprising as the evaluation point is not somewhere in the left part where the mesh is coarse, but rather to the right and the adaptive refinement should refine the mesh around the evaluation point as well.\\nWe thus close the discussion of this example program with a question:\\n\\nWhat is wrong with adaptivity if it is not better than global refinement?\\nExercise at the end of this example: There is a simple reason for the bad and irregular behavior of the adapted mesh solutions. It is simple to find out by looking at the mesh around the evaluation point in each of the steps - the data for this is in the output files of the program. An exercise would therefore be to modify the mesh refinement routine such that the problem (once you remark it) is avoided. The second exercise is to check whether the results are then better than global refinement, and if so if even a better order of convergence (in terms of the number of degrees of freedom) is achieved, or only by a better constant.\\n(Very brief answers for the impatient: at steps with larger errors, the mesh is not regular at the point of evaluation, i.e. some of the adjacent cells have hanging nodes; this destroys some superapproximation effects of which the globally refined mesh can profit. Answer 2: this quick hack bool refinement_indicated = false;\\nfor (const auto &cell : triangulation.active_cell_iterators())\\n  for (const auto v : cell->vertex_indices())\\n        if (cell->vertex(v) == Point<dim>(.5,.5))\\n          {\\n            cell->clear_coarsen_flag();\\n            refinement_indicated |= cell->refine_flag_set();\\n          }\\nif (refinement_indicated)\\n for (const auto &cell : triangulation.active_cell_iterators())\\n    for (const auto v : cell->vertex_indices())\\n          if (cell->vertex(v) == Point<dim>(.5,.5))\\n            cell->set_refine_flag ();\\n in the refinement function of the Kelly refinement class right before executing refinement would improve the results (exercise: what does the code do?), making them consistently better than global refinement. Behavior is still irregular, though, so no results about an order of convergence are possible.)\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2002 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Author: Wolfgang Bangerth, University of Heidelberg, 2001, 2002\\n */\\n \\n \\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/function.h>\\n#include <deal.II/base/table_handler.h>\\n#include <deal.II/base/thread_management.h>\\n#include <deal.II/base/work_stream.h>\\n#include <deal.II/lac/vector.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/precondition.h>\\n#include <deal.II/lac/affine_constraints.h>\\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_refinement.h>\\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_tools.h>\\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_values.h>\\n#include <deal.II/numerics/vector_tools.h>\\n#include <deal.II/numerics/matrix_tools.h>\\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/error_estimator.h>\\n \\n#include <iostream>\\n#include <fstream>\\n#include <list>\\n \\nnamespace Step13\\n{\\n using namespace dealii;\\n \\n \\n namespace Evaluation\\n  {\\n template <int dim>\\n class EvaluationBase\\n    {\\n public:\\n virtual ~EvaluationBase() = default;\\n \\n void set_refinement_cycle(const unsigned int refinement_cycle);\\n \\n virtual void operator()(const DoFHandler<dim> &dof_handler,\\n const Vector<double>  &solution) const = 0;\\n \\n protected:\\n unsigned int refinement_cycle;\\n    };\\n \\n \\n \\n template <int dim>\\n void EvaluationBase<dim>::set_refinement_cycle(const unsigned int step)\\n    {\\n      refinement_cycle = step;\\n    }\\n \\n \\n \\n template <int dim>\\n class PointValueEvaluation : public EvaluationBase<dim>\\n    {\\n public:\\n      PointValueEvaluation(const Point<dim> &evaluation_point,\\n TableHandler     &results_table);\\n \\n virtual void operator()(const DoFHandler<dim> &dof_handler,\\n const Vector<double>  &solution) const override;\\n \\n DeclException1(\\n        ExcEvaluationPointNotFound,\\n Point<dim>,\\n        << \\\"The evaluation point \\\" << arg1\\n        << \\\" was not found among the vertices of the present grid.\\\");\\n \\n private:\\n const Point<dim> evaluation_point;\\n TableHandler    &results_table;\\n    };\\n \\n \\n template <int dim>\\n    PointValueEvaluation<dim>::PointValueEvaluation(\\n const Point<dim> &evaluation_point,\\n TableHandler     &results_table)\\n      : evaluation_point(evaluation_point)\\n      , results_table(results_table)\\n    {}\\n \\n \\n \\n template <int dim>\\n void\\n    PointValueEvaluation<dim>::operator()(const DoFHandler<dim> &dof_handler,\\n const Vector<double>  &solution) const\\n {\\n double point_value = 1e20;\\n \\n bool evaluation_point_found = false;\\n for (const auto &cell : dof_handler.active_cell_iterators())\\n        if (!evaluation_point_found)\\n          for (const auto vertex : cell->vertex_indices())\\n            if (cell->vertex(vertex) == evaluation_point)\\n              {\\n point_value = solution(cell->vertex_dof_index(vertex, 0));\\n \\n                evaluation_point_found = true;\\n break;\\n              };\\n \\n AssertThrow(evaluation_point_found,\\n                  ExcEvaluationPointNotFound(evaluation_point));\\n \\n      results_table.add_value(\\\"DoFs\\\", dof_handler.n_dofs());\\n      results_table.add_value(\\\"u(x_0)\\\", point_value);\\n    }\\n \\n \\n \\n \\n template <int dim>\\n class SolutionOutput : public EvaluationBase<dim>\\n    {\\n public:\\n      SolutionOutput(const std::string              &output_name_base,\\n const DataOutBase::OutputFormat output_format);\\n \\n virtual void operator()(const DoFHandler<dim> &dof_handler,\\n const Vector<double>  &solution) const override;\\n \\n private:\\n const std::string               output_name_base;\\n const DataOutBase::OutputFormat output_format;\\n    };\\n \\n \\n template <int dim>\\n    SolutionOutput<dim>::SolutionOutput(\\n const std::string              &output_name_base,\\n const DataOutBase::OutputFormat output_format)\\n      : output_name_base(output_name_base)\\n      , output_format(output_format)\\n    {}\\n \\n \\n template <int dim>\\n void SolutionOutput<dim>::operator()(const DoFHandler<dim> &dof_handler,\\n const Vector<double>  &solution) const\\n {\\n DataOut<dim> data_out;\\n      data_out.attach_dof_handler(dof_handler);\\n      data_out.add_data_vector(solution, \\\"solution\\\");\\n      data_out.build_patches();\\n \\n      std::ofstream out(output_name_base + \\\"-\\\" +\\n                        std::to_string(this->refinement_cycle) +\\n                        data_out.default_suffix(output_format));\\n \\n      data_out.write(out, output_format);\\n    }\\n \\n \\n \\n \\n  } // namespace Evaluation\\n \\n \\n \\n namespace LaplaceSolver\\n  {\\n \\n template <int dim>\\n class Base\\n    {\\n public:\\n      Base(Triangulation<dim> &coarse_grid);\\n virtual ~Base() = default;\\n \\n virtual void solve_problem() = 0;\\n virtual void postprocess(\\n const Evaluation::EvaluationBase<dim> &postprocessor) const = 0;\\n virtual void         refine_grid()                            = 0;\\n virtual unsigned int n_dofs() const                           = 0;\\n \\n protected:\\n const SmartPointer<Triangulation<dim>> triangulation;\\n    };\\n \\n \\n template <int dim>\\n    Base<dim>::Base(Triangulation<dim> &coarse_grid)\\n      : triangulation(&coarse_grid)\\n    {}\\n \\n \\n \\n template <int dim>\\n class Solver : public virtual Base<dim>\\n    {\\n public:\\n      Solver(Triangulation<dim>       &triangulation,\\n const FiniteElement<dim> &fe,\\n const Quadrature<dim>    &quadrature,\\n const Function<dim>      &boundary_values);\\n virtual ~Solver() override;\\n \\n virtual void solve_problem() override;\\n \\n virtual void postprocess(\\n const Evaluation::EvaluationBase<dim> &postprocessor) const override;\\n \\n virtual unsigned int n_dofs() const override;\\n \\n protected:\\n const SmartPointer<const FiniteElement<dim>> fe;\\n const SmartPointer<const Quadrature<dim>>    quadrature;\\n DoFHandler<dim>                              dof_handler;\\n Vector<double>                               solution;\\n const SmartPointer<const Function<dim>>      boundary_values;\\n \\n virtual void assemble_rhs(Vector<double> &rhs) const = 0;\\n \\n private:\\n struct LinearSystem\\n      {\\n        LinearSystem(const DoFHandler<dim> &dof_handler);\\n \\n void solve(Vector<double> &solution) const;\\n \\n AffineConstraints<double> hanging_node_constraints;\\n SparsityPattern           sparsity_pattern;\\n SparseMatrix<double> matrix;\\n Vector<double>            rhs;\\n      };\\n \\n \\n struct AssemblyScratchData\\n      {\\n        AssemblyScratchData(const FiniteElement<dim> &fe,\\n const Quadrature<dim>    &quadrature);\\n        AssemblyScratchData(const AssemblyScratchData &scratch_data);\\n \\n FEValues<dim> fe_values;\\n      };\\n \\n struct AssemblyCopyData\\n      {\\n FullMatrix<double> cell_matrix;\\n        std::vector<types::global_dof_index> local_dof_indices;\\n      };\\n \\n void assemble_linear_system(LinearSystem &linear_system);\\n \\n void local_assemble_matrix(\\n const typename DoFHandler<dim>::active_cell_iterator &cell,\\n        AssemblyScratchData                                  &scratch_data,\\n        AssemblyCopyData                                     &copy_data) const;\\n \\n void copy_local_to_global(const AssemblyCopyData &copy_data,\\n                                LinearSystem           &linear_system) const;\\n    };\\n \\n \\n \\n template <int dim>\\n    Solver<dim>::Solver(Triangulation<dim>       &triangulation,\\n const FiniteElement<dim> &fe,\\n const Quadrature<dim>    &quadrature,\\n const Function<dim>      &boundary_values)\\n      : Base<dim>(triangulation)\\n      , fe(&fe)\\n      , quadrature(&quadrature)\\n      , dof_handler(triangulation)\\n      , boundary_values(&boundary_values)\\n    {}\\n \\n \\n template <int dim>\\n    Solver<dim>::~Solver()\\n    {\\n      dof_handler.clear();\\n    }\\n \\n \\n template <int dim>\\n void Solver<dim>::solve_problem()\\n    {\\n      dof_handler.distribute_dofs(*fe);\\n      solution.reinit(dof_handler.n_dofs());\\n \\n      LinearSystem linear_system(dof_handler);\\n      assemble_linear_system(linear_system);\\n      linear_system.solve(solution);\\n    }\\n \\n \\n template <int dim>\\n void Solver<dim>::postprocess(\\n const Evaluation::EvaluationBase<dim> &postprocessor) const\\n {\\n      postprocessor(dof_handler, solution);\\n    }\\n \\n \\n template <int dim>\\n unsigned int Solver<dim>::n_dofs() const\\n {\\n return dof_handler.n_dofs();\\n    }\\n \\n \\n template <int dim>\\n void Solver<dim>::assemble_linear_system(LinearSystem &linear_system)\\n    {\\n Threads::Task<void> rhs_task =\\n Threads::new_task(&Solver<dim>::assemble_rhs, *this, linear_system.rhs);\\n \\n auto worker =\\n        [this](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n               AssemblyScratchData &scratch_data,\\n               AssemblyCopyData    &copy_data) {\\n          this->local_assemble_matrix(cell, scratch_data, copy_data);\\n        };\\n \\n auto copier = [this, &linear_system](const AssemblyCopyData &copy_data) {\\n        this->copy_local_to_global(copy_data, linear_system);\\n      };\\n \\n WorkStream::run(dof_handler.begin_active(),\\n                      dof_handler.end(),\\n                      worker,\\n                      copier,\\n                      AssemblyScratchData(*fe, *quadrature),\\n                      AssemblyCopyData());\\n      linear_system.hanging_node_constraints.condense(linear_system.matrix);\\n \\n      std::map<types::global_dof_index, double> boundary_value_map;\\n VectorTools::interpolate_boundary_values(dof_handler,\\n                                               0,\\n                                               *boundary_values,\\n                                               boundary_value_map);\\n \\n      rhs_task.join();\\n      linear_system.hanging_node_constraints.condense(linear_system.rhs);\\n \\n MatrixTools::apply_boundary_values(boundary_value_map,\\n                                         linear_system.matrix,\\n                                         solution,\\n                                         linear_system.rhs);\\n    }\\n \\n \\n template <int dim>\\n    Solver<dim>::AssemblyScratchData::AssemblyScratchData(\\n const FiniteElement<dim> &fe,\\n const Quadrature<dim>    &quadrature)\\n      : fe_values(fe, quadrature, update_gradients | update_JxW_values)\\n    {}\\n \\n \\n template <int dim>\\n    Solver<dim>::AssemblyScratchData::AssemblyScratchData(\\n const AssemblyScratchData &scratch_data)\\n      : fe_values(scratch_data.fe_values.get_fe(),\\n                  scratch_data.fe_values.get_quadrature(),\\n update_gradients | update_JxW_values)\\n    {}\\n \\n \\n template <int dim>\\n void Solver<dim>::local_assemble_matrix(\\n const typename DoFHandler<dim>::active_cell_iterator &cell,\\n      AssemblyScratchData                                  &scratch_data,\\n      AssemblyCopyData                                     &copy_data) const\\n {\\n const unsigned int dofs_per_cell = fe->n_dofs_per_cell();\\n const unsigned int n_q_points    = quadrature->size();\\n \\n      copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);\\n \\n      copy_data.local_dof_indices.resize(dofs_per_cell);\\n \\n      scratch_data.fe_values.reinit(cell);\\n \\n for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n            copy_data.cell_matrix(i, j) +=\\n              (scratch_data.fe_values.shape_grad(i, q_point) *\\n               scratch_data.fe_values.shape_grad(j, q_point) *\\n               scratch_data.fe_values.JxW(q_point));\\n \\n      cell->get_dof_indices(copy_data.local_dof_indices);\\n    }\\n \\n \\n \\n template <int dim>\\n void Solver<dim>::copy_local_to_global(const AssemblyCopyData &copy_data,\\n                                           LinearSystem &linear_system) const\\n {\\n for (unsigned int i = 0; i < copy_data.local_dof_indices.size(); ++i)\\n for (unsigned int j = 0; j < copy_data.local_dof_indices.size(); ++j)\\n          linear_system.matrix.add(copy_data.local_dof_indices[i],\\n                                   copy_data.local_dof_indices[j],\\n                                   copy_data.cell_matrix(i, j));\\n    }\\n \\n \\n template <int dim>\\n    Solver<dim>::LinearSystem::LinearSystem(const DoFHandler<dim> &dof_handler)\\n    {\\n      hanging_node_constraints.clear();\\n \\n      void (*mhnc_p)(const DoFHandler<dim> &, AffineConstraints<double> &) =\\n        &DoFTools::make_hanging_node_constraints;\\n \\n Threads::Task<void> side_task =\\n Threads::new_task(mhnc_p, dof_handler, hanging_node_constraints);\\n \\n DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());\\n DoFTools::make_sparsity_pattern(dof_handler, dsp);\\n \\n \\n \\n      side_task.join();\\n \\n      hanging_node_constraints.close();\\n      hanging_node_constraints.condense(dsp);\\n      sparsity_pattern.copy_from(dsp);\\n \\n \\n matrix.reinit(sparsity_pattern);\\n      rhs.reinit(dof_handler.n_dofs());\\n    }\\n \\n \\n \\n template <int dim>\\n void Solver<dim>::LinearSystem::solve(Vector<double> &solution) const\\n {\\n SolverControl            solver_control(1000, 1e-12);\\n SolverCG<Vector<double>> cg(solver_control);\\n \\n PreconditionSSOR<SparseMatrix<double>> preconditioner;\\n      preconditioner.initialize(matrix, 1.2);\\n \\n      cg.solve(matrix, solution, rhs, preconditioner);\\n \\n      hanging_node_constraints.distribute(solution);\\n    }\\n \\n \\n \\n \\n template <int dim>\\n class PrimalSolver : public Solver<dim>\\n    {\\n public:\\n      PrimalSolver(Triangulation<dim>       &triangulation,\\n const FiniteElement<dim> &fe,\\n const Quadrature<dim>    &quadrature,\\n const Function<dim>      &rhs_function,\\n const Function<dim>      &boundary_values);\\n \\n protected:\\n const SmartPointer<const Function<dim>> rhs_function;\\n virtual void assemble_rhs(Vector<double> &rhs) const override;\\n    };\\n \\n \\n template <int dim>\\n    PrimalSolver<dim>::PrimalSolver(Triangulation<dim>       &triangulation,\\n const FiniteElement<dim> &fe,\\n const Quadrature<dim>    &quadrature,\\n const Function<dim>      &rhs_function,\\n const Function<dim>      &boundary_values)\\n      : Base<dim>(triangulation)\\n      , Solver<dim>(triangulation, fe, quadrature, boundary_values)\\n      , rhs_function(&rhs_function)\\n    {}\\n \\n \\n \\n template <int dim>\\n void PrimalSolver<dim>::assemble_rhs(Vector<double> &rhs) const\\n {\\n FEValues<dim> fe_values(*this->fe,\\n                              *this->quadrature,\\n update_values | update_quadrature_points |\\n update_JxW_values);\\n \\n const unsigned int dofs_per_cell = this->fe->n_dofs_per_cell();\\n const unsigned int n_q_points    = this->quadrature->size();\\n \\n Vector<double>                       cell_rhs(dofs_per_cell);\\n      std::vector<double>                  rhs_values(n_q_points);\\n      std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n for (const auto &cell : this->dof_handler.active_cell_iterators())\\n        {\\n          cell_rhs = 0;\\n          fe_values.reinit(cell);\\n          rhs_function->value_list(fe_values.get_quadrature_points(),\\n                                   rhs_values);\\n \\n for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n              cell_rhs(i) += fe_values.shape_value(i, q_point) * \\n                             rhs_values[q_point] *               \\n                             fe_values.JxW(q_point);\\n \\n          cell->get_dof_indices(local_dof_indices);\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n            rhs(local_dof_indices[i]) += cell_rhs(i);\\n        };\\n    }\\n \\n \\n \\n template <int dim>\\n class RefinementGlobal : public PrimalSolver<dim>\\n    {\\n public:\\n      RefinementGlobal(Triangulation<dim>       &coarse_grid,\\n const FiniteElement<dim> &fe,\\n const Quadrature<dim>    &quadrature,\\n const Function<dim>      &rhs_function,\\n const Function<dim>      &boundary_values);\\n \\n virtual void refine_grid() override;\\n    };\\n \\n \\n \\n template <int dim>\\n    RefinementGlobal<dim>::RefinementGlobal(\\n Triangulation<dim>       &coarse_grid,\\n const FiniteElement<dim> &fe,\\n const Quadrature<dim>    &quadrature,\\n const Function<dim>      &rhs_function,\\n const Function<dim>      &boundary_values)\\n      : Base<dim>(coarse_grid)\\n      , PrimalSolver<dim>(coarse_grid,\\n                          fe,\\n                          quadrature,\\n                          rhs_function,\\n                          boundary_values)\\n    {}\\n \\n \\n \\n template <int dim>\\n void RefinementGlobal<dim>::refine_grid()\\n    {\\n      this->triangulation->refine_global(1);\\n    }\\n \\n \\n \\n template <int dim>\\n class RefinementKelly : public PrimalSolver<dim>\\n    {\\n public:\\n      RefinementKelly(Triangulation<dim>       &coarse_grid,\\n const FiniteElement<dim> &fe,\\n const Quadrature<dim>    &quadrature,\\n const Function<dim>      &rhs_function,\\n const Function<dim>      &boundary_values);\\n \\n virtual void refine_grid() override;\\n    };\\n \\n \\n \\n template <int dim>\\n    RefinementKelly<dim>::RefinementKelly(Triangulation<dim>       &coarse_grid,\\n const FiniteElement<dim> &fe,\\n const Quadrature<dim>    &quadrature,\\n const Function<dim> &rhs_function,\\n const Function<dim> &boundary_values)\\n      : Base<dim>(coarse_grid)\\n      , PrimalSolver<dim>(coarse_grid,\\n                          fe,\\n                          quadrature,\\n                          rhs_function,\\n                          boundary_values)\\n    {}\\n \\n \\n \\n template <int dim>\\n void RefinementKelly<dim>::refine_grid()\\n    {\\n Vector<float> estimated_error_per_cell(\\n        this->triangulation->n_active_cells());\\n KellyErrorEstimator<dim>::estimate(\\n        this->dof_handler,\\n QGauss<dim - 1>(this->fe->degree + 1),\\n        std::map<types::boundary_id, const Function<dim> *>(),\\n        this->solution,\\n        estimated_error_per_cell);\\n GridRefinement::refine_and_coarsen_fixed_number(*this->triangulation,\\n                                                      estimated_error_per_cell,\\n                                                      0.3,\\n                                                      0.03);\\n      this->triangulation->execute_coarsening_and_refinement();\\n    }\\n \\n  } // namespace LaplaceSolver\\n \\n \\n \\n \\n template <int dim>\\n class Solution : public Function<dim>\\n  {\\n public:\\n virtual double value(const Point<dim>  &p,\\n const unsigned int component) const override;\\n  };\\n \\n \\n template <int dim>\\n double Solution<dim>::value(const Point<dim>  &p,\\n const unsigned int component) const\\n {\\n    (void)component;\\n AssertIndexRange(component, 1);\\n double q = p[0];\\n for (unsigned int i = 1; i < dim; ++i)\\n      q += std::sin(10 * p[i] + 5 * p[0] * p[0]);\\n const double exponential = std::exp(q);\\n return exponential;\\n  }\\n \\n \\n \\n template <int dim>\\n class RightHandSide : public Function<dim>\\n  {\\n public:\\n virtual double value(const Point<dim>  &p,\\n const unsigned int component) const override;\\n  };\\n \\n \\n template <int dim>\\n double RightHandSide<dim>::value(const Point<dim>  &p,\\n const unsigned int component) const\\n {\\n    (void)component;\\n AssertIndexRange(component, 1);\\n double q = p[0];\\n for (unsigned int i = 1; i < dim; ++i)\\n      q += std::sin(10 * p[i] + 5 * p[0] * p[0]);\\n const double u  = std::exp(q);\\n double       t1 = 1, t2 = 0, t3 = 0;\\n for (unsigned int i = 1; i < dim; ++i)\\n      {\\n        t1 += std::cos(10 * p[i] + 5 * p[0] * p[0]) * 10 * p[0];\\n        t2 += 10 * std::cos(10 * p[i] + 5 * p[0] * p[0]) -\\n              100 * std::sin(10 * p[i] + 5 * p[0] * p[0]) * p[0] * p[0];\\n        t3 += 100 * std::cos(10 * p[i] + 5 * p[0] * p[0]) *\\n std::cos(10 * p[i] + 5 * p[0] * p[0]) -\\n              100 * std::sin(10 * p[i] + 5 * p[0] * p[0]);\\n      };\\n    t1 = t1 * t1;\\n \\n return -u * (t1 + t2 + t3);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void run_simulation(\\n    LaplaceSolver::Base<dim>                           &solver,\\n const std::list<Evaluation::EvaluationBase<dim> *> &postprocessor_list)\\n  {\\n    std::cout << \\\"Refinement cycle: \\\";\\n \\n for (unsigned int step = 0; true; ++step)\\n      {\\n        std::cout << step << ' ' << std::flush;\\n \\n        solver.solve_problem();\\n \\n for (const auto &postprocessor : postprocessor_list)\\n          {\\n            postprocessor->set_refinement_cycle(step);\\n            solver.postprocess(*postprocessor);\\n          };\\n \\n \\n if (solver.n_dofs() < 20000)\\n          solver.refine_grid();\\n else\\n break;\\n      };\\n \\n    std::cout << std::endl;\\n  }\\n \\n \\n \\n template <int dim>\\n void solve_problem(const std::string &solver_name)\\n  {\\n const std::string header =\\n \\\"Running tests with \\\\\\\"\\\" + solver_name + \\\"\\\\\\\" refinement criterion:\\\";\\n    std::cout << header << std::endl\\n              << std::string(header.size(), '-') << std::endl;\\n \\n Triangulation<dim> triangulation;\\n GridGenerator::hyper_cube(triangulation, -1, 1);\\n triangulation.refine_global(2);\\n const FE_Q<dim>    fe(1);\\n const QGauss<dim>  quadrature(4);\\n    RightHandSide<dim> rhs_function;\\n    Solution<dim>      boundary_values;\\n \\n    std::unique_ptr<LaplaceSolver::Base<dim>> solver;\\n if (solver_name == \\\"global\\\")\\n      solver = std::make_unique<LaplaceSolver::RefinementGlobal<dim>>(\\n triangulation, fe, quadrature, rhs_function, boundary_values);\\n else if (solver_name == \\\"kelly\\\")\\n      solver = std::make_unique<LaplaceSolver::RefinementKelly<dim>>(\\n triangulation, fe, quadrature, rhs_function, boundary_values);\\n else\\n AssertThrow(false, ExcNotImplemented());\\n \\n TableHandler                          results_table;\\n    Evaluation::PointValueEvaluation<dim> postprocessor1(Point<dim>(0.5, 0.5),\\n                                                         results_table);\\n \\n    Evaluation::SolutionOutput<dim> postprocessor2(std::string(\\\"solution-\\\") +\\n                                                     solver_name,\\n DataOutBase::gnuplot);\\n \\n    std::list<Evaluation::EvaluationBase<dim> *> postprocessor_list;\\n    postprocessor_list.push_back(&postprocessor1);\\n    postprocessor_list.push_back(&postprocessor2);\\n \\n    run_simulation(*solver, postprocessor_list);\\n \\n    results_table.write_text(std::cout);\\n \\n    std::cout << std::endl;\\n  }\\n} // namespace Step13\\n \\n \\n \\nint main()\\n{\\n try\\n    {\\n      Step13::solve_problem<2>(\\\"global\\\");\\n      Step13::solve_problem<2>(\\\"kelly\\\");\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    };\\n \\n return 0;\\n}\\naffine_constraints.h\\nDataOutInterface::default_suffixstd::string default_suffix(const DataOutBase::OutputFormat output_format=DataOutBase::default_format) constDefinition data_out_base.cc:8900\\nDataOutInterface::writevoid write(std::ostream &out, const DataOutBase::OutputFormat output_format=DataOutBase::default_format) constDefinition data_out_base.cc:8787\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nDoFHandler::endcell_iterator end() const\\nDoFHandler::distribute_dofsvoid distribute_dofs(const FiniteElement< dim, spacedim > &fe)\\nDoFHandler::begin_activeactive_cell_iterator begin_active(const unsigned int level=0) const\\nDoFHandler::clearvoid clear()\\nTableHandler::write_textvoid write_text(std::ostream &out, const TextOutputFormat format=table_with_headers) constDefinition table_handler.cc:371\\nThreads::Task::joinvoid join() constDefinition thread_management.h:738\\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nVector::reinitvirtual void reinit(const size_type N, const bool omit_zeroing_entries=false)\\nparallel::distributed::Triangulation::execute_coarsening_and_refinementvirtual void execute_coarsening_and_refinement() overrideDefinition tria.cc:3320\\ndof_handler.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nerror_estimator.h\\nfe_values.h\\nfe_q.h\\nfull_matrix.h\\nfunction.h\\ngrid_refinement.h\\ntria.h\\ngrid_generator.h\\nmatrix_tools.h\\nLAPACKSupport::matrix@ matrixContents is actually a matrix.Definition lapack_support.h:57\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\nVectorTools::point_valuevoid point_value(const DoFHandler< dim, spacedim > &dof, const VectorType &fe_function, const Point< spacedim, double > &point, Vector< typename VectorType::value_type > &value)\\ndata_out.h\\nprecondition.h\\nquadrature_lib.h\\nsolver_cg.h\\nsparse_matrix.h\\ntable_handler.h\\nthread_management.h\\nvector.h\\nvector_tools.h\\nwork_stream.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"