"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_83.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-83 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-83 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-83 tutorial program\\n\\n\\nThis tutorial depends on step-19.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nCheckpoint/restart\\nSerialization/deserialization\\n\\n Serialization of parallel programs \\n\\nCheckpointing strategies\\n\\nWhat to save/restore\\nHow precisely should we save the data of a checkpoint\\nHow often to save/restore\\n\\n\\n The commented program\\n\\nInclude files\\nGlobal definitions\\nThe main class\\nThe CathodeRaySimulator class implementation\\n\\nThe unchanged parts of the class\\nCathodeRaySimulator::serialize()\\nCathodeRaySimulator::checkpoint()\\nCathodeRaySimulator::restart()\\nCathodeRaySimulator::run()\\n\\nThe main function\\n\\n\\n Results\\n\\nPossibilities for extensions\\n\\n Making efficiency a priority \\n\\n\\n The plain program\\n   \\n\\n\\n This program was contributed by Pasquale Africa (SISSA), Wolfgang Bangerth (Colorado State University), and Bruno Blais (Polytechnique Montreal).\\nThis material is based upon work partially supported by National Science Foundation grants OAC-1835673, DMS-1821210, and EAR-1925595; and by the Computational Infrastructure in Geodynamics initiative (CIG), through the National Science Foundation under Award No. EAR-1550901 and The University of California-Davis.  \\n\\n Introduction\\nCheckpoint/restart\\nA common problem in scientific computing is that a program runs such a long time that one would like to be able to periodically save the state of the program, and then have the possibility to restart at the same point where the program was when the state was saved. There are a number of reasons why one would want to do that:\\n\\nOn machines that are shared with many other users, say on supercomputers, it is common to use queues that have a time limit on how long programs can run. For example, one can only run programs that run at most 48 hours. But what if a simulation hasn't done the requisite number of time steps when those 48 hours are up, or for some other reason isn't finished yet? If we could save the state of the program every hour, that wouldn't matter so much: If the queuing system terminates the program after 48 hours, we could simply let the program run again and pick up where the last state was saved somewhere between hour 47 and 48 \\u2013 at most an hour of run time would have been lost.\\nFor some of the very largest computations one can do today, with tens or hundreds of thousands of processors (this being written in 2023), it is not entirely uncommon that one has to expect that a node in a supercomputer dies over the course of long run. This could be because of hardware failures, system software failures, power failures, or any other reason that might affect the stability of the system. It is not entirely unreasonable that one would have to expect that: A computation with, say, 100,000 cores on machines with 32 cores each uses 3,000 nodes; a computation that takes 24 hours on such a machine uses nearly 10 years of machine time, a time frame within which we would certainly expect that a typical machine might die. In such cases, losing a simulation bears a very substsntial cost, given how expensive it is to get 100,000 cores for a whole day, and being able to periodically save the state will guard against the loss of this investment.\\nThere are sometimes cases where one would like to compute an expensive step once and then do many inexpensive computations on top of it. For example, one might be interested in an expensive simulation of the weather pattern today, and then consider where rain falls by looking at many stochastic perturbations. In such a case, one would save the state at the end of the expensive computation, and re-start from it many times over with different perturbations.\\n\\nThe ability to save the state of a program and restart from it is often called checkpoint/restart. \\\"Checkpointing\\\" refers to the step of writing the current state of the program into one or several files on disk (or, in more general schemes, into some kind of temporary storage: disk files may be one option, but it could also be non-volatile memory on other nodes of a parallel machine). \\\"Restarting\\\" means starting a program not from scratch, but from a previously stored \\\"checkpoint\\\". This tutorial discusses both how one should conceptually think about checkpoint/restart, as well as how this is typically implemented.\\nThe program is informed by how this has been implemented in the ASPECT code, in which we have used this strategy for many years successfully. Many of the ideas that can be found in ASPECT are based on approaches that other codes have used long before that.\\nSerialization/deserialization\\nThe second term that we should introduce is \\\"serialization\\\" and \\\"deserialization\\\". A key piece of checkpoint/restart is that we need to \\\"dump\\\" the state of the program (i.e., the data structures currently stored in memory, and where the program currently is in the sequence of what operations it is doing one after the other) into a file or some other temporary storage.\\nThe thing, however, is that we are often using very complicated data structures. Think, for example, of a std::map<unsigned int,std::string> object: This isn't just an array of double numbers, but is in general stored as a tree data structure where every node will have to consist of the key (an integer) and the value (a string, which is itself a non-trivial object). How would one store this on disk?\\nThe solution is that one has to convert every piece of data that corresponds to a linear array of bytes that can then be saved in a file \\u2013 because what files store are ultimately just a sequence of bytes. This process is called \\\"serialization\\\": It converts the data that represents the program into a series of bytes. The way this conceptually works is that one has to define bottom-up serialization functions: If we have a function that converts an unsigned int into a series of bytes (for example by just storing the four bytes that represent an integer on most current architectures) and a function that converts a std::string into a series of bytes (for example, by storing first the length of the string as an unsigned int in the way described before, and then the individual characters that make up that string), then we can define a function that stores a std::map: For example, we could first store the number of entries in the map, and then for each key/value pair, we first serialize the key and then the value. We can do this for the larger-and-large classes and eventually the whole program: We convert each member variable in turn into a sequence of bytes if we have already defined how each of the member variables individually would do that.\\nFrom this kind of information, we can then also re-load the state of the program: Starting with the top-level object of our program, we read each member variable in turn from the file, where each member variable may again be a class of its own that read its member variables, etc. This process is then called \\\"deserialization\\\": Building data structures from a serial representation.\\nIt seems like a monumental task to write functions that serialize and again deserialize all possible data structures. One would have to do this for built-in types like double, int, etc., but then also for all of the C++ containers such as std::vector, std::list, std::map along with C-style arrays. From there, one might work one's way up to classes such as Tensor, Point, and eventually Triangulation, Vector, or ParticleHandler. This would be a lot of work.\\nFortunately, help exists: There are a number of external libraries that make this task relatively straightforward. The one that deal.II uses for serialization and deserialization is the BOOST serialization library that has everything related to (de)serialization of built-in and std:: data types already available. One then only has to write functions for each class that needs to be (de)serialized, but this is also made relatively simple by BOOST serialization: One only has to add a single function in which one can use operator overloading. For example, here is a very short excerpt of how the Tensor class might do this: template <int rank, int dim, typename Number>\\nclass Tensor\\n{\\npublic:\\n //\\n // Read or write the data of this object to or from a stream for the purpose\\n // of serialization using the BOOST serialization\\n // library.\\n //\\n template <class Archive>\\n void\\n serialize(Archive &ar, const unsigned int version);\\n \\nprivate:\\n //\\n // Array of tensors holding the subelements.\\n //\\n Tensor<rank-1, dim, Number> values[dim];\\n};\\n \\n \\ntemplate <int rank, int dim, typename Number>\\ntemplate <class Archive>\\ninline void\\nTensor<rank, dim, Number>::serialize(Archive &ar, const unsigned int /*version*/)\\n{\\n  ar & values;\\n}\\nTensorDefinition tensor.h:471\\nTensor::rankstatic constexpr unsigned int rankDefinition tensor.h:490\\nTensor::serializevoid serialize(Archive &ar, const unsigned int version)\\nIn other words, the Tensor class stores an array of dim objects of a tensor of one rank lower, and in order to serialize this array, the function simply uses the overloaded operator& which recognizes that values is a C-style array of fixed length, and what the data type of the elements of this array are. It will then in turn call the serialize() member function of Tensor<rank-1,dim>. (The recursion has a stopping point which is not of importance for this discussion. The actual implementation of class Tensor looks different, but you get the general idea here.)\\nDepending on whether the Archive type used for the first argument of this function is an input or output archive, operator& reads from or writes into the values member variable. If the class had more member variables, one would list them one after the other. The same is true if a class has base classes. For example, here is the corresponding function for the Quadrature class that stores quadrature points and weights, and is derived from the Subscriptor base class: template <int dim>\\ntemplate <class Archive>\\ninline void\\nQuadrature<dim>::serialize(Archive &ar, const unsigned int)\\n{\\n // Forward to the (de)serialization function in the base class:\\n  ar & static_cast<Subscriptor &>(*this);\\n \\n // Then (de)serialize the member variables:\\n  ar & quadrature_points & weights;\\n}\\nQuadrature::serializevoid serialize(Archive &ar, const unsigned int version)\\nSubscriptorDefinition subscriptor.h:60\\n The beauty of having to write only one function for both serialization and deserialization is that obviously one has to read data from the archive in the same order as one writes into it, and that is easy to get wrong if one had to write two separate functions \\u2013 but that is automatically correct if one has the same function for both purposes!\\nThe BOOST serialization library also has mechanisms if one wants to write separate save and load functions. This is useful if a class stores a lot of data in one array and then has a cache of commonly accessed data on the side for fast access; one would then only store and load the large array, and in the load function re-build the cache from the large array. (See also the discussion below on what one actually wants to save.)\\nBased on these principles, let us consider how one would (de)serialize a program such as step-19. Recall that its principal class looked essentially as follows: template <int dim>\\nclass CathodeRaySimulator\\n{\\npublic:\\n  CathodeRaySimulator();\\n \\n void run();\\n \\nprivate:\\n void make_grid();\\n void setup_system();\\n void assemble_system();\\n void solve_field();\\n void refine_grid();\\n \\n void create_particles();\\n void move_particles();\\n void track_lost_particle(const typename Particles::ParticleIterator<dim> &        particle,\\n const typename Triangulation<dim>::active_cell_iterator &cell);\\n \\n \\n void update_timestep_size();\\n void output_results() const;\\n \\n Triangulation<dim> triangulation;\\n MappingQGeneric<dim>      mapping;\\n FE_Q<dim>                 fe;\\n DoFHandler<dim>           dof_handler;\\n AffineConstraints<double> constraints;\\n \\n SparseMatrix<double>      system_matrix;\\n SparsityPattern           sparsity_pattern;\\n \\n Vector<double>            solution;\\n Vector<double>            system_rhs;\\n \\n Particles::ParticleHandler<dim> particle_handler;\\n types::particle_index           next_unused_particle_id;\\n types::particle_index           n_recently_lost_particles;\\n types::particle_index           n_total_lost_particles;\\n types::particle_index           n_particles_lost_through_anode;\\n \\n DiscreteTime time;\\n};\\nAffineConstraintsDefinition affine_constraints.h:507\\nDiscreteTimeDefinition discrete_time.h:233\\nDoFHandlerDefinition dof_handler.h:317\\nFE_QDefinition fe_q.h:554\\nMappingQDefinition mapping_q.h:110\\nParticles::ParticleHandlerDefinition particle_handler.h:63\\nParticles::ParticleIteratorDefinition particle_iterator.h:39\\nSparseMatrixDefinition sparse_matrix.h:520\\nSparsityPatternDefinition sparsity_pattern.h:343\\nTriaActiveIteratorDefinition tria_iterator.h:755\\nTriangulationDefinition tria.h:1323\\nVectorDefinition vector.h:120\\nunsigned int\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\n One would then first write a function that allows (de)serialization of the data of this class as follows: template <int dim>\\ntemplate <class Archive>\\nvoid CathodeRaySimulator<dim>::serialize(Archive &ar,\\n const unsigned int /* version */)\\n{\\n  ar & triangulation;\\n  ar & solution;\\n  ar & particle_handler;\\n  ar & next_unused_particle_id;\\n  ar & n_recently_lost_particles;\\n  ar & n_total_lost_particles;\\n  ar & n_particles_lost_through_anode;\\n  ar & time;\\n}\\n As discussed below, this is not the entire list of member variables: We only want to serialize those that we cannot otherwise re-generate.\\nNext, we need a function that writes a checkpoint by creating an \\\"output\\narchive\\\" and using the usual operator<< to put an object into this archive. In the code of this program, this will then look as follows (with some minor modifications we will discuss later): template <int dim>\\nvoid CathodeRaySimulator<dim>::checkpoint()\\n{\\n  std::ofstream                 checkpoint_file(\\\"checkpoint\\\");\\n  boost::archive::text_oarchive archive(checkpoint_file,\\n                                        boost::archive::no_header);\\n \\n  archive << *this;\\n}\\nWhat operator<< does here is to call the serialization functions of the right hand operand (here, the serialize() function described above, with an output archive as template argument), and create a serialized representation of the data. In the end, serialization has put everything into the \\\"archive\\\" from which one can extract a (sometimes very long) string that one can save in bulk into a file, and that is exactly what happens when the destructor of the archive variable is called.\\nBOOST serialization offers different archives, including ones that store the data in text format (as we do above), in binary format, or already compressed with something like gzip to minimize the amount of space necessary. The specific type of archive to be used is selected by the type of the archive variable above (and the corresponding variable in the restart() function of course). This program uses a text archive so that you can look at how a serialized representation would actually look at, though a \\\"real\\\" program would of course try to be more space efficient by using binary (and possibly compressed) representations of the data.\\nIn any case, the data we have thus created is read in very similarly in the following function (again with some minor modifications): template <int dim>\\nvoid CathodeRaySimulator<dim>::restart()\\n{\\n  std::ifstream checkpoint_file(\\\"checkpoint\\\");\\n \\n  boost::archive::text_iarchive archive(checkpoint_file,\\n                                        boost::archive::no_header);\\n \\n  archive >> *this;\\n}\\nThe magic of this approach is that one doesn't actually have to write very much code to checkpoint or restart programs: It is all hidden in the serialization functions of classes such as Triangulation, Particles::ParticleHandler, etc., which the deal.II library provides for you.\\nSerialization of parallel programs \\nThe program as provided here is sequential, i.e., it runs on a single processor just like the original step-19 did. But what if you had a parallel program \\u2013 say, something like step-40 \\u2013 that runs in parallel with MPI? In that case, serialization and checkpoint/restart becomes more complicated. While parallel execution is not something that is of concern to us in this program, it is an issue that has influenced the design of how deal.II does serialization; as a consequence, we need to talk through what makes serialization of parallel programs more difficult in order to understand why this program does things the way it does.\\nIntuitively, one might simply want to use the same idea as we used here except that we let every MPI process serialize its own data, and read its own data. This works, but there are some drawbacks:\\nThere is a certain subset of data that is replicated across all MPI processes and that would be then written by all processes. An example is the time data structure that stores the current time, time step size, and other information, and that better be the same on all processes. Typically, the replicated data isn't a large fraction of a program's overall memory usage, and perhaps writing it more than once isn't going to be too much of a problem, but it is unsatisfactory anyway to have this kind of data on disk more than once.\\nOne would have to think in detail how exactly one wants to represent the data on disk. One possibility would be for every MPI process to write its own file. On the other hand, checkpointing is most useful for large programs, using large numbers of processes \\u2013 it is not uncommon to use checkpointing on programs that run on 10,000 or more processors in parallel. This would then lead to 10,000 or more files on disk. That's unpleasant, and probably inefficient as well. We could address this by first letting all the processes serialize into a string in memory (using std::ostringstream) and then collating all of these strings into one file. The MPI I/O sub-system has facilities to make that happen, for example, but it will require a bit of thought not the least because the serialized data from each process will likely result in strings of different sizes.\\nPerhaps the most important reason to rethink how one does things in parallel is because, with a little bit of thought, it is possible to checkpoint a program running with \\\\(N\\\\) MPI processes and restart it with \\\\(M\\\\neq N\\\\) processes. This may, at first, seem like a pointless exercise, but it is useful if one had, for example, a program that repeatedly refines the mesh and where it is inefficient to run the early refinement steps with a coarse mesh on too many processes, whereas it is too slow to run the later refinement steps with a fine mesh on too few processes.\\n\\nIn order to address these issues, in particular the last one, the right approach is to deviate a bit from the simple scheme of having a serialize() function that simply serializes/deserializes everything into an archive, and then have two functions checkpoint() and restart() that for all practical purposes defer all the work to the serialize() function. Instead, one splits all data into two categories:\\nData that is tied to the cells of a triangulation. This includes the mesh itself, but also the particles in the Particles::ParticleHandler class, and most importantly the solution vector(s). The way to serialize such data is to attach the data to cells and then let the Triangulation class serialize the attached data along with its own data. If this is done in a way so that we can re-load a triangulation on a different number of processes than the data was written, then this automatically also ensures that we can restore solution vectors and Particles::ParticleHandler objects (and everything else we can attach to the cells of a triangulation) on a different number of processes.\\nOther data. In finite element programs, this data is almost always replicated across processes, and so it is enough if the \\\"root\\\" process (typically the process with MPI rank zero) writes it to disk. Upon restart, the root process reads the data from disk, sends it to all other processes (however many of them there may be), and these then initialize their own copies of the replicated data structures.\\n\\nThese sorts of considerations have influenced the design of the Triangulation and Particles::ParticleHandler classes. In particular, Particles::ParticleHandler's serialize() function only serializes the \\\"other data\\\" category, but not the actual particles; these can instead be attached to the triangulation by calling Particles::ParticleHandler::prepare_for_serialization(), and then one can call Triangulation::save() to actually write this information into a set of files that become part of the checkpoint. Upon restart, we then first call Triangulation::load(), followed by Particles::ParticleHandler::deserialize() to retrieve the particles from the cells they are attached to.\\n(We could, with relatively minimal effort, use the same scheme for the solution vector: The SolutionTransfer class can be used to attach the values of degrees of freedom to cells, and then Triangulation::save() also writes these into checkpoint files. SolutionTransfer would then be able to re-create the solution vector upon restart in a similar way. However, in contrast to Particles::ParticleHandler, the Vector class we use for the solution vector can actually serialize itself completely, and so we will go with this approach and save ourselves the dozen or so additional lines of code.)\\nFinally, even though we wrote the serialize() function above in such a way that it also serializes the triangulation member variable, in practice the call to Triangulation::save() we needed to deal with the particles also saves the same kind of information, and Triangulation::load() reads it. In other words, we are saving redundant information; in the actual implementation of the program, we therefore skip the call to ar & triangulation;\\n We do still need to say ar & particle_handler;\\n because the information attached to the cells of the triangulation only contains information about the particles themselves, whereas the previous line is necessary to store information such as how many particles there are, what the next unused particle index is, and other internal information about the class.\\nCheckpointing strategies\\nHaving discussed the general idea of checkpoint/restart, let us turn to some more specific questions one has to answer: (i) What do we actually want to save/restore? (ii) How often do we want to write checkpoints?\\nWhat to save/restore\\nWe will base this tutorial on step-19, and so let us use it as an example in this section. Recall that that program simulates an electric field in which particles move from the electrode on one side to the other side of the domain, i.e., we have both field-based and particle-based information to store.\\nRecall the main class of step-19, which had quite a lot of member variables one might want to (de)serialize: template <int dim>\\nclass CathodeRaySimulator\\n{\\npublic:\\n  CathodeRaySimulator();\\n \\n void run();\\n \\nprivate:\\n  [... member functions ...]\\n \\n Triangulation<dim> triangulation;\\n MappingQGeneric<dim>      mapping;\\n FE_Q<dim>                 fe;\\n DoFHandler<dim>           dof_handler;\\n AffineConstraints<double> constraints;\\n \\n SparseMatrix<double>      system_matrix;\\n SparsityPattern           sparsity_pattern;\\n \\n Vector<double>            solution;\\n Vector<double>            system_rhs;\\n \\n Particles::ParticleHandler<dim> particle_handler;\\n types::particle_index           next_unused_particle_id;\\n types::particle_index           n_recently_lost_particles;\\n types::particle_index           n_total_lost_particles;\\n types::particle_index           n_particles_lost_through_anode;\\n \\n DiscreteTime time;\\n};\\n Do we really need to save all of these to disk? That would presumably lead to quite a lot of data that needs to be stored and, if necessary, re-loaded.\\nIn practice, one does not save all of this information, but only what cannot be reasonably re-computed in different ways. What is saved should also depend on also where in the program's algorithm one currently is, and one generally finds a convenient point at which not so much data needs to be stored. For the current example of step-19, a time dependent problem, one could apply the following considerations:\\n\\nThe program runs with the same finite element every time, so there is no need to actually save the element: We know what polynomial degree we want, and can just re-generate the element upon restart. If the polynomial degree was a run-time parameter, then maybe we should serialize the polynomial degree rather than all of the myriad data structures that characterize a FE_Q object, given that we can always re-generate the object by just knowing its polynomial degree. This is the classical trade-off of space vs time: We can achieve the same outcome by saving far less data if we are willing to offer a bit of CPU time to regenerate all of the internal data structures of the FE_Q given the polynomial degree.\\nWe rebuild the matrix and sparsity pattern in each time step from the DoFHandler and the finite element. These are quite large data structures, but they are conceptually easy to re-create again as necessary. So they do not need to be saved to disk, and this is going to save quite a lot of space. Furthermore, we really only need the matrix for the linear solve; once we are done with the linear solve in the solve_field() function, the contents of the matrix are no longer used and are, indeed, overwritten in the next time step. As a consequence, there would really only be a point in saving the matrix if we did the checkpointing between the assembly and the linear solve \\u2013 but maybe that is just not a convenient point for this operation, and we should pick a better location. In practice, one generally puts the checkpointing at either the very end or the very beginning of the time stepping loop, given that this is the point where the number of variables whose values are currently active is minimal.\\nWe also do not need to save the DoFHandler object: If we know the triangulation, we can always just create a DoFHandler object during restart to enumerate degrees of freedom in the same way as we did the last time before a previous program run was checkpointed. In fact, the example implementation of the checkpoint() function shown above did not serialize the DoFHandler object for this very reason. On the other hand, we probably do want to save the Triangulation here given that the triangulation is not statically generated once at the beginning of the program and then never changed, but is dynamically adapted every few time steps. In order to re-generate the triangulation, we would therefore have to save which cells were refined/coarsened and when (i.e., the history of the triangulation), and this would likely cost substantially more disk space for long-running computations than just saving the triangulation itself.\\n\\nSimilar considerations can be applied to all member variables: Can we re-generate their values with relatively little effort (in which case they do not have to be saved) or is their state difficult or impossible to re-generate if it is not saved to disk (in which case the variable needs to be serialized)?\\nNoteIf you have carefully read step-19, you might now realize that strictly speaking, we do not need to checkpoint to solution vector. This is because the solution vector represents the electric field, which the program solves for at the beginning of each timestep and that this solve does not make reference to the electric field at previous time steps \\u2013 in other words, the electric field is not a \\\"history variable\\\": If we know the domain, the mesh, the finite element, and the positions of the particles, we can recompute the solution vector, and consequently we would not have to save it into the checkpoint file. However, this is perhaps more work than we want to do for checkpointing (which you will see is otherwise rather little code) and so, for pedagological purposes, we simply save the solution vector along with the other variables that actually do represent the history of the program.\\nHow precisely should we save the data of a checkpoint\\nRecall that the goal of checkpointing is to end up with a safe copy of where the program currently is in its computations. As a consequence, we need to make sure that we do not end up in a situation where, for example, we start overwriting the previous checkpoint file and somewhere halfway through the serialization process, the machine crashes and we end up with an aborted program and no functional checkpoint file.\\nInstead, the procedure one generally follows to guard against this kind of scenario is that checkpoints are written into a file that is separate* from the previous checkpoint file; only once we are past the writing process and the file is safely on disk can we replace the previous checkpoint file by the one just written \\u2013 that is, we move the new file into place of the old one. You will see in the code how this two-step process is implemented in practice.\\nThe situation is made slightly more complicated by the fact that in the program below, a \\\"checkpoint\\\" actually consists of a number of files \\u2013 one file into which we write the program's member variables, and several into which the triangulation puts its information. We then would have to rename several files, preferrably as a single, \\\"atomic\\\" operation that cannot be interrupted. Implementing this is tricky and non-trivial (though possible), and so we will not show this part and instead just assume that nothing will happen between renaming the first and the last of the files \\u2013 maybe not a great strategy in general, but good enough for this tutorial program.\\nHow often to save/restore\\nNow that we know what we want to save and how we want to restore it, we need to answer the question how often we want to checkpoint the program. At least theoretically, this question has been answered many decades ago already, see [211] and [68]. In practice (as actually also in these theoretical derivations), it comes down to (i) how long it takes to checkpoint data, and (ii) how frequently we expect that the stored data will have to be used, i.e., how often the system crashes.\\nFor example, if it takes five minutes to save the state of the program, then we probably do not want to write a checkpoint every ten minutes. On the other hand, if it only takes five seconds, then maybe ten minutes is a reasonable frequency if we run on a modest 100 cores and the machine does not crash very often, given that in that case the overhead is only approximately 1%. Finally, if it takes five seconds to save the state, but we are running on 100,000 processes (i.e., a very expensive simulation) and the machine frequently crashes, then maybe we are willing to offer a 5% penalty in the overall run time and write a checkpoint every minute and a half given that we lose far less work this way on average if the machine crashes at an unpredictable moment in our computations. The papers cited above essentially just formalize this sort of consideration.\\nIn the program, we will not dwell on this and simply choose an ad-hoc value of saving the state every ten time steps: That's too often in practice, but is useful for experiencing how this works in practice without having to run the program too long.\\n The commented program\\n Include files\\nThis program, with the exception of the checkpointing component is identical to step-19, and so the following include files are all the same:\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/discrete_time.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/precondition.h>\\n\\u00a0 #include <deal.II/lac/solver_cg.h>\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_refinement.h>\\n\\u00a0 #include <deal.II/grid/grid_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/mapping_q.h>\\n\\u00a0 #include <deal.II/matrix_free/fe_point_evaluation.h>\\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 #include <deal.II/numerics/error_estimator.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/particles/particle_handler.h>\\n\\u00a0 #include <deal.II/particles/data_out.h>\\n\\u00a0 \\nThe only thing new are the following two include files. They are the ones that declare the classes we use as archives for reading (iarchive = input archive) and writing (oarchive = output archive) serialized data:\\n\\u00a0 #include <boost/archive/text_iarchive.hpp>\\n\\u00a0 #include <boost/archive/text_oarchive.hpp>\\n\\u00a0 \\n\\u00a0 #include <filesystem>\\n\\u00a0 #include <fstream>\\n\\u00a0 #include <string>\\n\\u00a0 \\nboostDefinition bounding_box.h:26\\n Global definitions\\nAs is customary, we put everything that corresponds to the details of the program into a namespace of its own.\\n\\u00a0 namespace Step83\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\n\\u00a0   namespace BoundaryIds\\n\\u00a0   {\\n\\u00a0     constexpr types::boundary_id open          = 101;\\n\\u00a0     constexpr types::boundary_id cathode       = 102;\\n\\u00a0     constexpr types::boundary_id focus_element = 103;\\n\\u00a0     constexpr types::boundary_id anode         = 104;\\n\\u00a0   } // namespace BoundaryIds\\n\\u00a0 \\n\\u00a0   namespace Constants\\n\\u00a0   {\\n\\u00a0     constexpr double electron_mass   = 9.1093837015e-31;\\n\\u00a0     constexpr double electron_charge = 1.602176634e-19;\\n\\u00a0 \\n\\u00a0     constexpr double V0 = 1;\\n\\u00a0 \\n\\u00a0     constexpr double E_threshold = 0.05;\\n\\u00a0 \\n\\u00a0     constexpr double electrons_per_particle = 3e15;\\n\\u00a0   } // namespace Constants\\n\\u00a0 \\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n The main class\\nThe following is then the main class of this program. It is, fundamentally, identical to step-19 with the exception of the checkpoint() and restart() functions, along with the serialize() function we use to serialize and deserialize the data this class stores. The serialize() function is called by the BOOST serialization framework, and consequently has to have exactly the set of arguments used here. Furthermore, because it is called by BOOST functions, it has to be public; the other two new functions are as always made private.\\nThe run() function has also been modified to enable simulation restart via its new argument do_restart that indicates whether or not to start the simulation from a checkpoint.\\n\\u00a0   template <int dim>\\n\\u00a0   class CathodeRaySimulator\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     CathodeRaySimulator();\\n\\u00a0 \\n\\u00a0     void run(const bool do_restart);\\n\\u00a0 \\n\\u00a0     template <class Archive>\\n\\u00a0     void serialize(Archive &ar, const unsigned int version);\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void make_grid();\\n\\u00a0     void setup_system();\\n\\u00a0     void assemble_system();\\n\\u00a0     void solve_field();\\n\\u00a0     void refine_grid();\\n\\u00a0 \\n\\u00a0     void create_particles();\\n\\u00a0     void move_particles();\\n\\u00a0     void track_lost_particle(\\n\\u00a0       const Particles::ParticleIterator<dim>                  &particle,\\n\\u00a0       const typename Triangulation<dim>::active_cell_iterator &cell);\\n\\u00a0 \\n\\u00a0     void update_timestep_size();\\n\\u00a0     void output_results() const;\\n\\u00a0 \\n\\u00a0     void checkpoint();\\n\\u00a0     void restart();\\n\\u00a0 \\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0     const MappingQ<dim>       mapping;\\n\\u00a0     const FE_Q<dim>           fe;\\n\\u00a0     DoFHandler<dim>           dof_handler;\\n\\u00a0     AffineConstraints<double> constraints;\\n\\u00a0 \\n\\u00a0     SparseMatrix<double> system_matrix;\\n\\u00a0     SparsityPattern      sparsity_pattern;\\n\\u00a0 \\n\\u00a0     Vector<double> solution;\\n\\u00a0     Vector<double> system_rhs;\\n\\u00a0 \\n\\u00a0     Particles::ParticleHandler<dim> particle_handler;\\n\\u00a0     types::particle_index           next_unused_particle_id;\\n\\u00a0     types::particle_index           n_recently_lost_particles;\\n\\u00a0     types::particle_index           n_total_lost_particles;\\n\\u00a0     types::particle_index           n_particles_lost_through_anode;\\n\\u00a0 \\n\\u00a0     DiscreteTime time;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n The CathodeRaySimulator class implementation\\n The unchanged parts of the class\\nLet us start with those parts of the class that are all unchanged from step-19 and about which you can learn there. We will then pick up with commentary again when we get to the two new functions, checkpoint() and restart(), along with how the run() function needs to be modified:\\n\\u00a0   template <int dim>\\n\\u00a0   CathodeRaySimulator<dim>::CathodeRaySimulator()\\n\\u00a0     : mapping(1)\\n\\u00a0     , fe(2)\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0     , particle_handler(triangulation, mapping, /*n_properties=*/dim)\\n\\u00a0     , next_unused_particle_id(0)\\n\\u00a0     , n_recently_lost_particles(0)\\n\\u00a0     , n_total_lost_particles(0)\\n\\u00a0     , n_particles_lost_through_anode(0)\\n\\u00a0     , time(0, 1e-4)\\n\\u00a0   {\\n\\u00a0     particle_handler.signals.particle_lost.connect(\\n\\u00a0       [this](const typename Particles::ParticleIterator<dim>         &particle,\\n\\u00a0              const typename Triangulation<dim>::active_cell_iterator &cell) {\\n\\u00a0         this->track_lost_particle(particle, cell);\\n\\u00a0       });\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::make_grid()\\n\\u00a0   {\\n\\u00a0     static_assert(dim == 2,\\n\\u00a0                   \\\"This function is currently only implemented for 2d.\\\");\\n\\u00a0 \\n\\u00a0     const double       delta = 0.5;\\n\\u00a0     const unsigned int nx    = 5;\\n\\u00a0     const unsigned int ny    = 3;\\n\\u00a0 \\n\\u00a0     const std::vector<Point<dim>> vertices \\n\\u00a0       = {{0, 0},\\n\\u00a0          {1, 0},\\n\\u00a0          {2, 0},\\n\\u00a0          {3, 0},\\n\\u00a0          {4, 0},\\n\\u00a0          {delta, 1},\\n\\u00a0          {1, 1},\\n\\u00a0          {2, 1},\\n\\u00a0          {3, 1},\\n\\u00a0          {4, 1},\\n\\u00a0          {0, 2},\\n\\u00a0          {1, 2},\\n\\u00a0          {2, 2},\\n\\u00a0          {3, 2},\\n\\u00a0          {4, 2}};\\n\\u00a0     AssertDimension(vertices.size(), nx * ny);\\n\\u00a0 \\n\\u00a0     const std::vector<unsigned int> cell_vertices[(nx - 1) * (ny - 1)] = {\\n\\u00a0       {0, 1, nx + 0, nx + 1},\\n\\u00a0       {1, 2, nx + 1, nx + 2},\\n\\u00a0       {2, 3, nx + 2, nx + 3},\\n\\u00a0       {3, 4, nx + 3, nx + 4},\\n\\u00a0 \\n\\u00a0       {5, nx + 1, 2 * nx + 0, 2 * nx + 1},\\n\\u00a0       {nx + 1, nx + 2, 2 * nx + 1, 2 * nx + 2},\\n\\u00a0       {nx + 2, nx + 3, 2 * nx + 2, 2 * nx + 3},\\n\\u00a0       {nx + 3, nx + 4, 2 * nx + 3, 2 * nx + 4}};\\n\\u00a0 \\n\\u00a0     std::vector<CellData<dim>> cells((nx - 1) * (ny - 1), CellData<dim>());\\n\\u00a0     for (unsigned int i = 0; i < cells.size(); ++i)\\n\\u00a0       {\\n\\u00a0         cells[i].vertices    = cell_vertices[i];\\n\\u00a0         cells[i].material_id = 0;\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     GridTools::consistently_order_cells(cells);\\n\\u00a0     triangulation.create_triangulation(\\n\\u00a0       vertices,\\n\\u00a0       cells,\\n\\u00a0       SubCellData()); // No boundary information\\n\\u00a0 \\n\\u00a0     triangulation.refine_global(2);\\n\\u00a0 \\n\\u00a0     for (auto &cell : triangulation.active_cell_iterators())\\n\\u00a0       for (auto &face : cell->face_iterators())\\n\\u00a0         if (face->at_boundary())\\n\\u00a0           {\\n\\u00a0             if ((face->center()[0] > 0) && (face->center()[0] < 0.5) &&\\n\\u00a0                 (face->center()[1] > 0) && (face->center()[1] < 2))\\n\\u00a0               face->set_boundary_id(BoundaryIds::cathode);\\n\\u00a0             else if ((face->center()[0] > 0) && (face->center()[0] < 2))\\n\\u00a0               face->set_boundary_id(BoundaryIds::focus_element);\\n\\u00a0             else if ((face->center()[0] > 4 - 1e-12) &&\\n\\u00a0                      ((face->center()[1] > 1.5) || (face->center()[1] < 0.5)))\\n\\u00a0               face->set_boundary_id(BoundaryIds::anode);\\n\\u00a0             else\\n\\u00a0               face->set_boundary_id(BoundaryIds::open);\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0     triangulation.refine_global(1);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::setup_system()\\n\\u00a0   {\\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0 \\n\\u00a0     solution.reinit(dof_handler.n_dofs());\\n\\u00a0     system_rhs.reinit(dof_handler.n_dofs());\\n\\u00a0 \\n\\u00a0     constraints.clear();\\n\\u00a0     DoFTools::make_hanging_node_constraints(dof_handler, constraints);\\n\\u00a0 \\n\\u00a0     VectorTools::interpolate_boundary_values(dof_handler,\\n\\u00a0                                              BoundaryIds::cathode,\\n\\u00a0                                              Functions::ConstantFunction<dim>(\\n\\u00a0                                                -Constants::V0),\\n\\u00a0                                              constraints);\\n\\u00a0     VectorTools::interpolate_boundary_values(dof_handler,\\n\\u00a0                                              BoundaryIds::focus_element,\\n\\u00a0                                              Functions::ConstantFunction<dim>(\\n\\u00a0                                                -Constants::V0),\\n\\u00a0                                              constraints);\\n\\u00a0     VectorTools::interpolate_boundary_values(dof_handler,\\n\\u00a0                                              BoundaryIds::anode,\\n\\u00a0                                              Functions::ConstantFunction<dim>(\\n\\u00a0                                                +Constants::V0),\\n\\u00a0                                              constraints);\\n\\u00a0     constraints.close();\\n\\u00a0 \\n\\u00a0     DynamicSparsityPattern dsp(dof_handler.n_dofs());\\n\\u00a0     DoFTools::make_sparsity_pattern(dof_handler,\\n\\u00a0                                     dsp,\\n\\u00a0                                     constraints,\\n\\u00a0                                     /* keep_constrained_dofs = */ false);\\n\\u00a0     sparsity_pattern.copy_from(dsp);\\n\\u00a0 \\n\\u00a0     system_matrix.reinit(sparsity_pattern);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::assemble_system()\\n\\u00a0   {\\n\\u00a0     system_matrix = 0;\\n\\u00a0     system_rhs    = 0;\\n\\u00a0 \\n\\u00a0     const QGauss<dim> quadrature_formula(fe.degree + 1);\\n\\u00a0 \\n\\u00a0     FEValues<dim> fe_values(fe,\\n\\u00a0                             quadrature_formula,\\n\\u00a0                             update_values | update_gradients |\\n\\u00a0                               update_quadrature_points | update_JxW_values);\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell = fe.dofs_per_cell;\\n\\u00a0 \\n\\u00a0     FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0     Vector<double>     cell_rhs(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         cell_matrix = 0;\\n\\u00a0         cell_rhs    = 0;\\n\\u00a0 \\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0         for (const unsigned int q_index : fe_values.quadrature_point_indices())\\n\\u00a0           for (const unsigned int i : fe_values.dof_indices())\\n\\u00a0             {\\n\\u00a0               for (const unsigned int j : fe_values.dof_indices())\\n\\u00a0                 cell_matrix(i, j) +=\\n\\u00a0                   (fe_values.shape_grad(i, q_index) * // grad phi_i(x_q)\\n\\u00a0                    fe_values.shape_grad(j, q_index) * // grad phi_j(x_q)\\n\\u00a0                    fe_values.JxW(q_index));           // dx\\n\\u00a0             }\\n\\u00a0 \\n\\u00a0         if (particle_handler.n_particles_in_cell(cell) > 0)\\n\\u00a0           for (const auto &particle : particle_handler.particles_in_cell(cell))\\n\\u00a0             {\\n\\u00a0               const Point<dim> &reference_location =\\n\\u00a0                 particle.get_reference_location();\\n\\u00a0               for (const unsigned int i : fe_values.dof_indices())\\n\\u00a0                 cell_rhs(i) +=\\n\\u00a0                   (fe.shape_value(i, reference_location) * // phi_i(x_p)\\n\\u00a0                    (-Constants::electrons_per_particle *   // N\\n\\u00a0                     Constants::electron_charge));          // e\\n\\u00a0             }\\n\\u00a0 \\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0         constraints.distribute_local_to_global(\\n\\u00a0           cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::solve_field()\\n\\u00a0   {\\n\\u00a0     SolverControl            solver_control(1000, 1e-12);\\n\\u00a0     SolverCG<Vector<double>> solver(solver_control);\\n\\u00a0 \\n\\u00a0     PreconditionSSOR<SparseMatrix<double>> preconditioner;\\n\\u00a0     preconditioner.initialize(system_matrix, 1.2);\\n\\u00a0 \\n\\u00a0     solver.solve(system_matrix, solution, system_rhs, preconditioner);\\n\\u00a0 \\n\\u00a0     constraints.distribute(solution);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::refine_grid()\\n\\u00a0   {\\n\\u00a0     Vector<float> estimated_error_per_cell(triangulation.n_active_cells());\\n\\u00a0 \\n\\u00a0     KellyErrorEstimator<dim>::estimate(dof_handler,\\n\\u00a0                                        QGauss<dim - 1>(fe.degree + 1),\\n\\u00a0                                        {},\\n\\u00a0                                        solution,\\n\\u00a0                                        estimated_error_per_cell);\\n\\u00a0 \\n\\u00a0     GridRefinement::refine_and_coarsen_fixed_number(triangulation,\\n\\u00a0                                                     estimated_error_per_cell,\\n\\u00a0                                                     0.1,\\n\\u00a0                                                     0.03);\\n\\u00a0 \\n\\u00a0     triangulation.execute_coarsening_and_refinement();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::create_particles()\\n\\u00a0   {\\n\\u00a0     FEFaceValues<dim> fe_face_values(fe,\\n\\u00a0                                      QMidpoint<dim - 1>(),\\n\\u00a0                                      update_quadrature_points |\\n\\u00a0                                        update_gradients |\\n\\u00a0                                        update_normal_vectors);\\n\\u00a0 \\n\\u00a0     std::vector<Tensor<1, dim>> solution_gradients(\\n\\u00a0       fe_face_values.n_quadrature_points);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       for (const auto &face : cell->face_iterators())\\n\\u00a0         if (face->at_boundary() &&\\n\\u00a0             (face->boundary_id() == BoundaryIds::cathode))\\n\\u00a0           {\\n\\u00a0             fe_face_values.reinit(cell, face);\\n\\u00a0 \\n\\u00a0             const FEValuesExtractors::Scalar electric_potential(0);\\n\\u00a0             fe_face_values[electric_potential].get_function_gradients(\\n\\u00a0               solution, solution_gradients);\\n\\u00a0             for (const unsigned int q_point :\\n\\u00a0                  fe_face_values.quadrature_point_indices())\\n\\u00a0               {\\n\\u00a0                 const Tensor<1, dim> E = solution_gradients[q_point];\\n\\u00a0 \\n\\u00a0                 if ((E * fe_face_values.normal_vector(q_point) < 0) &&\\n\\u00a0                     (E.norm() > Constants::E_threshold))\\n\\u00a0                   {\\n\\u00a0                     const Point<dim> &location =\\n\\u00a0                       fe_face_values.quadrature_point(q_point);\\n\\u00a0 \\n\\u00a0                     Particles::Particle<dim> new_particle;\\n\\u00a0                     new_particle.set_location(location);\\n\\u00a0                     new_particle.set_reference_location(\\n\\u00a0                       mapping.transform_real_to_unit_cell(cell, location));\\n\\u00a0                     new_particle.set_id(next_unused_particle_id);\\n\\u00a0                     particle_handler.insert_particle(new_particle, cell);\\n\\u00a0 \\n\\u00a0                     ++next_unused_particle_id;\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0     particle_handler.update_cached_numbers();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::move_particles()\\n\\u00a0   {\\n\\u00a0     const double dt = time.get_next_step_size();\\n\\u00a0 \\n\\u00a0     Vector<double>            solution_values(fe.n_dofs_per_cell());\\n\\u00a0     FEPointEvaluation<1, dim> evaluator(mapping, fe, update_gradients);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       if (particle_handler.n_particles_in_cell(cell) > 0)\\n\\u00a0         {\\n\\u00a0           const typename Particles::ParticleHandler<\\n\\u00a0             dim>::particle_iterator_range particles_in_cell =\\n\\u00a0             particle_handler.particles_in_cell(cell);\\n\\u00a0 \\n\\u00a0           std::vector<Point<dim>> particle_positions;\\n\\u00a0           for (const auto &particle : particles_in_cell)\\n\\u00a0             particle_positions.push_back(particle.get_reference_location());\\n\\u00a0 \\n\\u00a0           cell->get_dof_values(solution, solution_values);\\n\\u00a0 \\n\\u00a0           evaluator.reinit(cell, particle_positions);\\n\\u00a0           evaluator.evaluate(make_array_view(solution_values),\\n\\u00a0                              EvaluationFlags::gradients);\\n\\u00a0 \\n\\u00a0           {\\n\\u00a0             typename Particles::ParticleHandler<dim>::particle_iterator\\n\\u00a0               particle = particles_in_cell.begin();\\n\\u00a0             for (unsigned int particle_index = 0;\\n\\u00a0                  particle != particles_in_cell.end();\\n\\u00a0                  ++particle, ++particle_index)\\n\\u00a0               {\\n\\u00a0                 const Tensor<1, dim> &E =\\n\\u00a0                   evaluator.get_gradient(particle_index);\\n\\u00a0 \\n\\u00a0                 const Tensor<1, dim> old_velocity(particle->get_properties());\\n\\u00a0 \\n\\u00a0                 const Tensor<1, dim> acceleration =\\n\\u00a0                   Constants::electron_charge / Constants::electron_mass * E;\\n\\u00a0 \\n\\u00a0                 const Tensor<1, dim> new_velocity =\\n\\u00a0                   old_velocity + acceleration * dt;\\n\\u00a0 \\n\\u00a0                 particle->set_properties(new_velocity);\\n\\u00a0 \\n\\u00a0                 const Point<dim> new_location =\\n\\u00a0                   particle->get_location() + dt * new_velocity;\\n\\u00a0                 particle->set_location(new_location);\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0     particle_handler.sort_particles_into_subdomains_and_cells();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::track_lost_particle(\\n\\u00a0     const typename Particles::ParticleIterator<dim>         &particle,\\n\\u00a0     const typename Triangulation<dim>::active_cell_iterator &cell)\\n\\u00a0   {\\n\\u00a0     ++n_recently_lost_particles;\\n\\u00a0     ++n_total_lost_particles;\\n\\u00a0 \\n\\u00a0     const Point<dim> current_location              = particle->get_location();\\n\\u00a0     const Point<dim> approximate_previous_location = cell->center();\\n\\u00a0 \\n\\u00a0     if ((approximate_previous_location[0] < 4) && (current_location[0] > 4))\\n\\u00a0       {\\n\\u00a0         const Tensor<1, dim> direction =\\n\\u00a0           (current_location - approximate_previous_location) /\\n\\u00a0           (current_location[0] - approximate_previous_location[0]);\\n\\u00a0 \\n\\u00a0         const double right_boundary_intercept =\\n\\u00a0           approximate_previous_location[1] +\\n\\u00a0           (4 - approximate_previous_location[0]) * direction[1];\\n\\u00a0         if ((right_boundary_intercept > 0.5) &&\\n\\u00a0             (right_boundary_intercept < 1.5))\\n\\u00a0           ++n_particles_lost_through_anode;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::update_timestep_size()\\n\\u00a0   {\\n\\u00a0     if (time.get_step_number() > 0)\\n\\u00a0       {\\n\\u00a0         double min_cell_size_over_velocity = std::numeric_limits<double>::max();\\n\\u00a0 \\n\\u00a0         for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0           if (particle_handler.n_particles_in_cell(cell) > 0)\\n\\u00a0             {\\n\\u00a0               const double cell_size = cell->minimum_vertex_distance();\\n\\u00a0 \\n\\u00a0               double max_particle_velocity(0.0);\\n\\u00a0 \\n\\u00a0               for (const auto &particle :\\n\\u00a0                    particle_handler.particles_in_cell(cell))\\n\\u00a0                 {\\n\\u00a0                   const Tensor<1, dim> velocity(particle.get_properties());\\n\\u00a0                   max_particle_velocity =\\n\\u00a0                     std::max(max_particle_velocity, velocity.norm());\\n\\u00a0                 }\\n\\u00a0 \\n\\u00a0               if (max_particle_velocity > 0)\\n\\u00a0                 min_cell_size_over_velocity =\\n\\u00a0                   std::min(min_cell_size_over_velocity,\\n\\u00a0                            cell_size / max_particle_velocity);\\n\\u00a0             }\\n\\u00a0 \\n\\u00a0         constexpr double c_safety = 0.5;\\n\\u00a0         time.set_desired_next_step_size(c_safety * 0.5 *\\n\\u00a0                                         min_cell_size_over_velocity);\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       {\\n\\u00a0         const QTrapezoid<dim> vertex_quadrature;\\n\\u00a0         FEValues<dim> fe_values(fe, vertex_quadrature, update_gradients);\\n\\u00a0 \\n\\u00a0         std::vector<Tensor<1, dim>> field_gradients(vertex_quadrature.size());\\n\\u00a0 \\n\\u00a0         double min_timestep = std::numeric_limits<double>::max();\\n\\u00a0 \\n\\u00a0         for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0           if (particle_handler.n_particles_in_cell(cell) > 0)\\n\\u00a0             {\\n\\u00a0               const double cell_size = cell->minimum_vertex_distance();\\n\\u00a0 \\n\\u00a0               fe_values.reinit(cell);\\n\\u00a0               fe_values.get_function_gradients(solution, field_gradients);\\n\\u00a0 \\n\\u00a0               double max_E = 0;\\n\\u00a0               for (const auto q_point : fe_values.quadrature_point_indices())\\n\\u00a0                 max_E = std::max(max_E, field_gradients[q_point].norm());\\n\\u00a0 \\n\\u00a0               if (max_E > 0)\\n\\u00a0                 min_timestep =\\n\\u00a0                   std::min(min_timestep,\\n\\u00a0                            std::sqrt(0.5 * cell_size *\\n\\u00a0                                      Constants::electron_mass /\\n\\u00a0                                      Constants::electron_charge / max_E));\\n\\u00a0             }\\n\\u00a0 \\n\\u00a0         time.set_desired_next_step_size(min_timestep);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   class ElectricFieldPostprocessor : public DataPostprocessorVector<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     ElectricFieldPostprocessor()\\n\\u00a0       : DataPostprocessorVector<dim>(\\\"electric_field\\\", update_gradients)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     virtual void evaluate_scalar_field(\\n\\u00a0       const DataPostprocessorInputs::Scalar<dim> &input_data,\\n\\u00a0       std::vector<Vector<double>> &computed_quantities) const override\\n\\u00a0     {\\n\\u00a0       AssertDimension(input_data.solution_gradients.size(),\\n\\u00a0                       computed_quantities.size());\\n\\u00a0 \\n\\u00a0       for (unsigned int p = 0; p < input_data.solution_gradients.size(); ++p)\\n\\u00a0         {\\n\\u00a0           AssertDimension(computed_quantities[p].size(), dim);\\n\\u00a0           for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0             computed_quantities[p][d] = input_data.solution_gradients[p][d];\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::output_results() const\\n\\u00a0   {\\n\\u00a0     {\\n\\u00a0       ElectricFieldPostprocessor<dim> electric_field;\\n\\u00a0       DataOut<dim>                    data_out;\\n\\u00a0       data_out.attach_dof_handler(dof_handler);\\n\\u00a0       data_out.add_data_vector(solution, \\\"electric_potential\\\");\\n\\u00a0       data_out.add_data_vector(solution, electric_field);\\n\\u00a0       data_out.build_patches();\\n\\u00a0 \\n\\u00a0       DataOutBase::VtkFlags output_flags;\\n\\u00a0       output_flags.time  = time.get_current_time();\\n\\u00a0       output_flags.cycle = time.get_step_number();\\n\\u00a0       output_flags.physical_units[\\\"electric_potential\\\"] = \\\"V\\\";\\n\\u00a0       output_flags.physical_units[\\\"electric_field\\\"]     = \\\"V/m\\\";\\n\\u00a0 \\n\\u00a0       data_out.set_flags(output_flags);\\n\\u00a0 \\n\\u00a0       std::ofstream output(\\\"solution-\\\" +\\n\\u00a0                            Utilities::int_to_string(time.get_step_number(), 4) +\\n\\u00a0                            \\\".vtu\\\");\\n\\u00a0       data_out.write_vtu(output);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       Particles::DataOut<dim> particle_out;\\n\\u00a0       particle_out.build_patches(\\n\\u00a0         particle_handler,\\n\\u00a0         std::vector<std::string>(dim, \\\"velocity\\\"),\\n\\u00a0         std::vector<DataComponentInterpretation::DataComponentInterpretation>(\\n\\u00a0           dim, DataComponentInterpretation::component_is_part_of_vector));\\n\\u00a0 \\n\\u00a0       DataOutBase::VtkFlags output_flags;\\n\\u00a0       output_flags.time                       = time.get_current_time();\\n\\u00a0       output_flags.cycle                      = time.get_step_number();\\n\\u00a0       output_flags.physical_units[\\\"velocity\\\"] = \\\"m/s\\\";\\n\\u00a0 \\n\\u00a0       particle_out.set_flags(output_flags);\\n\\u00a0 \\n\\u00a0       std::ofstream output(\\\"particles-\\\" +\\n\\u00a0                            Utilities::int_to_string(time.get_step_number(), 4) +\\n\\u00a0                            \\\".vtu\\\");\\n\\u00a0       particle_out.write_vtu(output);\\n\\u00a0     }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nmake_array_viewArrayView< std::remove_reference_t< typename std::iterator_traits< Iterator >::reference >, MemorySpaceType > make_array_view(const Iterator begin, const Iterator end)Definition array_view.h:949\\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nDataPostprocessorVectorDefinition data_postprocessor.h:978\\nDataPostprocessor::evaluate_scalar_fieldvirtual void evaluate_scalar_field(const DataPostprocessorInputs::Scalar< dim > &input_data, std::vector< Vector< double > > &computed_quantities) constDefinition data_postprocessor.cc:48\\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nFEFaceValuesDefinition fe_values.h:322\\nFEPointEvaluationDefinition fe_point_evaluation.h:1126\\nFEValuesDefinition fe_values.h:63\\nFullMatrixDefinition full_matrix.h:79\\nFunctions::ConstantFunctionDefinition function.h:410\\nKellyErrorEstimator::estimatestatic void estimate(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const Quadrature< dim - 1 > &quadrature, const std::map< types::boundary_id, const Function< spacedim, Number > * > &neumann_bc, const ReadVector< Number > &solution, Vector< float > &error, const ComponentMask &component_mask={}, const Function< spacedim > *coefficients=nullptr, const unsigned int n_threads=numbers::invalid_unsigned_int, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id, const types::material_id material_id=numbers::invalid_material_id, const Strategy strategy=cell_diameter_over_24)\\nParticles::DataOutDefinition data_out.h:44\\nParticles::DataOut::build_patchesvoid build_patches(const Particles::ParticleHandler< dim, spacedim > &particles, const std::vector< std::string > &data_component_names={}, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretations={})Definition data_out.cc:27\\nParticles::ParticleDefinition particle.h:94\\nParticles::Particle::set_locationvoid set_location(const Point< spacedim > &new_location)Definition particle.h:545\\nPointDefinition point.h:111\\nPreconditionSSORDefinition precondition.h:1778\\nPreconditionSSOR::initializevoid initialize(const MatrixType &A, const AdditionalData &parameters=AdditionalData())\\nQGaussDefinition quadrature_lib.h:40\\nQMidpointDefinition quadrature_lib.h:162\\nQTrapezoidDefinition quadrature_lib.h:191\\nSolverCGDefinition solver_cg.h:179\\nSolverControlDefinition solver_control.h:67\\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nint\\nparallel::distributed::Triangulation::execute_coarsening_and_refinementvirtual void execute_coarsening_and_refinement() overrideDefinition tria.cc:3320\\nparallel::distributed::Triangulation::create_triangulationvirtual void create_triangulation(const std::vector< Point< spacedim > > &vertices, const std::vector< CellData< dim > > &cells, const SubCellData &subcelldata) overrideDefinition tria.cc:1798\\ncenterPoint< 3 > centerDefinition data_out_base.cc:267\\nverticesPoint< 3 > vertices[4]Definition data_out_base.cc:272\\nAssertDimension#define AssertDimension(dim1, dim2)Definition exceptions.h:1985\\nDoFTools::make_hanging_node_constraintsvoid make_hanging_node_constraints(const DoFHandler< dim, spacedim > &dof_handler, AffineConstraints< number > &constraints)Definition dof_tools_constraints.cc:3073\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_normal_vectors@ update_normal_vectorsNormal vectors.Definition fe_update_flags.h:141\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nGridTools::consistently_order_cellsvoid consistently_order_cells(std::vector< CellData< dim > > &cells)Definition grid_tools_topology.cc:1615\\nDataComponentInterpretation::component_is_part_of_vector@ component_is_part_of_vectorDefinition data_component_interpretation.h:58\\nEvaluationFlags::gradients@ gradientsDefinition evaluation_flags.h:54\\nGridRefinement::refine_and_coarsen_fixed_numbervoid refine_and_coarsen_fixed_number(Triangulation< dim, spacedim > &triangulation, const Vector< Number > &criteria, const double top_fraction_of_cells, const double bottom_fraction_of_cells, const unsigned int max_n_cells=std::numeric_limits< unsigned int >::max())Definition grid_refinement.cc:318\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\nLocalIntegrators::Divergence::normdouble norm(const FEValuesBase< dim > &fe, const ArrayView< const std::vector< Tensor< 1, dim > > > &Du)Definition divergence.h:471\\nParticlesDefinition data_out.h:29\\nPhysics::Elasticity::Kinematics::ESymmetricTensor< 2, dim, Number > E(const Tensor< 2, dim, Number > &F)\\nPhysics::Elasticity::Kinematics::dSymmetricTensor< 2, dim, Number > d(const Tensor< 2, dim, Number > &F, const Tensor< 2, dim, Number > &dF_dt)\\nUtilities::int_to_stringstd::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)Definition utilities.cc:470\\nVectorTools::EvaluationFlags::max@ maxDefinition vector_tools_evaluate.h:55\\nVectorTools::interpolate_boundary_valuesvoid interpolate_boundary_values(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const std::map< types::boundary_id, const Function< spacedim, number > * > &function_map, std::map< types::global_dof_index, number > &boundary_values, const ComponentMask &component_mask={})\\ninternal::reinitvoid reinit(MatrixBlock< MatrixType > &v, const BlockSparsityPattern &p)Definition matrix_block.h:617\\nstdSTL namespace.\\nstd::min::VectorizedArray< Number, width > min(const ::VectorizedArray< Number, width > &, const ::VectorizedArray< Number, width > &)Definition vectorization.h:6960\\nstd::max::VectorizedArray< Number, width > max(const ::VectorizedArray< Number, width > &, const ::VectorizedArray< Number, width > &)Definition vectorization.h:6943\\nstd::sqrt::VectorizedArray< Number, width > sqrt(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6869\\ntypes::boundary_idunsigned int boundary_idDefinition types.h:144\\ntypes::particle_indexunsigned int particle_indexDefinition property_pool.h:64\\nCellDataDefinition tria_description.h:79\\nDataOutBase::VtkFlagsDefinition data_out_base.h:1127\\nDataOutBase::VtkFlags::timedouble timeDefinition data_out_base.h:1138\\nDataPostprocessorInputs::ScalarDefinition data_postprocessor.h:322\\nFEValuesExtractors::ScalarDefinition fe_values_extractors.h:95\\nSubCellDataDefinition tria_description.h:238\\n CathodeRaySimulator::serialize()\\nThe first of the new function is the one that is called by the BOOST Serialization framework to serialize and deserialize the data of this class. It has already been discussed in the introduction to this program and so does not provide any surprises. All it does is write those member variables of the current class that cannot be re-created easily into an archive, or read these members from it. (Whether operator & facilitates a write or read operation depends on whether the Archive type is an output or input archive.)\\nThe function takes a second argument, version, that can be used to create checkpoints that have version numbers. This is useful if one evolves programs by adding more member variables, but still wants to retain the ability to read checkpoint files created with earlier versions of the program. The version variable would, in that case, be used to represent which version of the program wrote the file, and if necessary to read only those variables that were written with that past version, finding a different way to initialize the new member variables that have been added since then. We will not make use of this ability here.\\nFinally, while the program that indents all deal.II source files format the following code as  ar &solution;\\n  as if we are taking the address of the triangulation variable, the way you should read the code is as  ar & solution;\\n  where operator & is a binary operator that could either be interpreted as operator << for output or operator >> for input.\\nAs discussed in the introduction, we do not serialize the triangulation member variable, instead leaving that to separate calls in the checkpoint() and restart() functions below.\\n\\u00a0   template <int dim>\\n\\u00a0   template <class Archive>\\n\\u00a0   void CathodeRaySimulator<dim>::serialize(Archive &ar,\\n\\u00a0                                            const unsigned int /* version */)\\n\\u00a0   {\\n\\u00a0     ar &solution;\\n\\u00a0     ar &particle_handler;\\n\\u00a0     ar &next_unused_particle_id;\\n\\u00a0     ar &n_recently_lost_particles;\\n\\u00a0     ar &n_total_lost_particles;\\n\\u00a0     ar &n_particles_lost_through_anode;\\n\\u00a0     ar &time;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n CathodeRaySimulator::checkpoint()\\nThe checkpoint function of the principal class of this program is then quite straightforward: We create an output file (and check that it is writable), create an output archive, and then move the serialized contents of the current object (i.e., the *this object) into the archive. The use of operator<< here calls the serialize() function above with an output archive as argument. When the destructor of the archive variable is called at the end of the code block within which it lives, the entire archive is written into the output file stream it is associated with.\\nAs mentioned in the introduction, \\\"real\\\" applications would not use text-based archives as provided by the boost::archive::text_oarchive class, but use binary and potentially compressed versions. This can easily be achieved by using differently named classes, and the BOOST documentation explains how to do that.\\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::checkpoint()\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"--- Writing checkpoint... ---\\\" << std::endl << std::endl;\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       std::ofstream checkpoint_file(\\\"tmp.checkpoint_step_83\\\");\\n\\u00a0       AssertThrow(checkpoint_file,\\n\\u00a0                   ExcMessage(\\n\\u00a0                     \\\"Could not write to the <tmp.checkpoint_step_83> file.\\\"));\\n\\u00a0 \\n\\u00a0       boost::archive::text_oarchive archive(checkpoint_file);\\n\\u00a0 \\n\\u00a0       archive << *this;\\n\\u00a0     }\\n\\u00a0 \\nAssertThrow#define AssertThrow(cond, exc)Definition exceptions.h:1739\\nThe second part of the serialization is all of the data that we can attach to cells \\u2013 see the discussion about this in the introduction. Here, the only data we attach to cells are the particles. We then let the triangulation save these into a set of files that all start with the same prefix as we chose above, namely \\\"tmp.checkpoint\\\":\\n\\u00a0     particle_handler.prepare_for_serialization();\\n\\u00a0     triangulation.save(\\\"tmp.checkpoint\\\");\\n\\u00a0 \\n\\u00a0 \\nparallel::distributed::Triangulation::savevirtual void save(const std::string &file_basename) const overrideDefinition tria.cc:2054\\nAt this point, the serialized data of this file has ended up in a number of files that all start with tmp.checkpoint file. As mentioned in the introduction, we do not want to directly overwrite the checkpointing files from the previous checkpoint operation, for fear that the program may be interrupted while writing the checkpoint files. This would result in corrupted files, and defeat the whole purpose of checkpointing because one cannot restart from such a file. On the other hand, if we got here, we know that the \\\"tmp.checkpoint*\\\" files were successfully written, and we can rename it to \\\"checkpoint*\\\", in the process replacing the old file.\\nWe do this move operation by calling the C++ function that does the renaming of files. Note that it is documented as being for all practical purposes \\\"atomic\\\", i.e., we do not need to worry that the program may be interrupted somewhere within the renaming operation itself. Of course, it is possible that we get interrupted somewhere between renaming one file and the next, and that presents problems in itself \\u2013 in essence, we want the entire renaming operation of all of these files to be atomic. With a couple dozen lines of extra code, one could address this issue (using strategies that databases use frequently: if one operation fails, we need to rollback the entire transaction). For the purposes of this program, this is perhaps too much, and we will simply hope that that doesn't happen, perhaps based on the belief that renaming files is much faster than writing them, and that unlike writing checkpoint files, renaming does not require much memory or disk space and so does not risk running out of either.\\nAs a consequence, the following code first loops over all files in the current directory, picks out those that start with the string \\\"tmp.checkpoint\\\", and puts them into a list. In a second step, we loop over the list and rename each of these files to one whose name consists of the \\\"tmp.checkpoint*\\\" file but stripped off its first four characters (i.e., only the \\\"checkpoint*\\\" part). We use this approach, rather than listing the files we want to rename, because we do not actually know the names of the files written by the Triangulation::save() function, though we know how each of these file names starts.\\n\\u00a0     std::list<std::string> tmp_checkpoint_files;\\n\\u00a0     for (const auto &dir_entry : std::filesystem::directory_iterator(\\\".\\\"))\\n\\u00a0       if (dir_entry.is_regular_file() &&\\n\\u00a0           (dir_entry.path().filename().string().find(\\\"tmp.checkpoint\\\") == 0))\\n\\u00a0         tmp_checkpoint_files.push_back(dir_entry.path().filename().string());\\n\\u00a0 \\n\\u00a0     for (const std::string &filename : tmp_checkpoint_files)\\n\\u00a0       std::filesystem::rename(filename, filename.substr(4, std::string::npos));\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n CathodeRaySimulator::restart()\\nThe restart function of this class then simply does the opposite: It opens an input file (and triggers an error if that file cannot be opened), associates an input archive with it, and then reads the contents of the current object from it, again using the serialize() function from above. Clearly, since we have written data into a text-based archive above, we need to use the corresponding boost::archive::text_iarchive class for reading.\\nIn a second step, we ask the triangulation to read in cell-attached data, and then tell the Particles::ParticleHandler object to re-create its information about all of the particles from the data just read.\\nThe function ends by printing a status message about having restarted:\\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::restart()\\n\\u00a0   {\\n\\u00a0     {\\n\\u00a0       std::ifstream checkpoint_file(\\\"checkpoint_step_83\\\");\\n\\u00a0       AssertThrow(checkpoint_file,\\n\\u00a0                   ExcMessage(\\n\\u00a0                     \\\"Could not read from the <checkpoint_step_83> file.\\\"));\\n\\u00a0 \\n\\u00a0       boost::archive::text_iarchive archive(checkpoint_file);\\n\\u00a0       archive >> *this;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     triangulation.load(\\\"checkpoint\\\");\\n\\u00a0     particle_handler.deserialize();\\n\\u00a0 \\n\\u00a0     std::cout << \\\"--- Restarting at t=\\\" << time.get_current_time()\\n\\u00a0               << \\\", dt=\\\" << time.get_next_step_size() << std::endl\\n\\u00a0               << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nparallel::distributed::Triangulation::loadvirtual void load(const std::string &file_basename) overrideDefinition tria.cc:2109\\n CathodeRaySimulator::run()\\nThe last member function of the principal class of this program is then the driver. The driver takes a single argument to indicate if the simulation is a restart. If it is not a restart, the mesh is set up and the problem is solved like in step-19. If it is a restart, then we read in everything that is a history variable from the checkpoint file via the restart() function. Recall that everything that is inside the if block at the top of the function is exactly like in step-19, as is almost everything that follows:\\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::run(const bool do_restart)\\n\\u00a0   {\\n\\u00a0     if (do_restart == false)\\n\\u00a0       {\\n\\u00a0         make_grid();\\n\\u00a0 \\n\\u00a0         const unsigned int n_pre_refinement_cycles = 3;\\n\\u00a0         for (unsigned int refinement_cycle = 0;\\n\\u00a0              refinement_cycle < n_pre_refinement_cycles;\\n\\u00a0              ++refinement_cycle)\\n\\u00a0           {\\n\\u00a0             setup_system();\\n\\u00a0             assemble_system();\\n\\u00a0             solve_field();\\n\\u00a0             refine_grid();\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       {\\n\\u00a0         restart();\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     setup_system();\\n\\u00a0     do\\n\\u00a0       {\\n\\u00a0         std::cout << \\\"Timestep \\\" << time.get_step_number() + 1 << std::endl;\\n\\u00a0         std::cout << \\\"  Field degrees of freedom:                 \\\"\\n\\u00a0                   << dof_handler.n_dofs() << std::endl;\\n\\u00a0 \\n\\u00a0         assemble_system();\\n\\u00a0         solve_field();\\n\\u00a0 \\n\\u00a0         create_particles();\\n\\u00a0         std::cout << \\\"  Total number of particles in simulation:  \\\"\\n\\u00a0                   << particle_handler.n_global_particles() << std::endl;\\n\\u00a0 \\n\\u00a0         n_recently_lost_particles = 0;\\n\\u00a0         update_timestep_size();\\n\\u00a0         move_particles();\\n\\u00a0 \\n\\u00a0         time.advance_time();\\n\\u00a0 \\n\\u00a0         output_results();\\n\\u00a0 \\n\\u00a0         std::cout << \\\"  Number of particles lost this time step:  \\\"\\n\\u00a0                   << n_recently_lost_particles << std::endl;\\n\\u00a0         if (n_total_lost_particles > 0)\\n\\u00a0           std::cout << \\\"  Fraction of particles lost through anode: \\\"\\n\\u00a0                     << 1. * n_particles_lost_through_anode /\\n\\u00a0                          n_total_lost_particles\\n\\u00a0                     << std::endl;\\n\\u00a0 \\n\\u00a0         std::cout << std::endl\\n\\u00a0                   << \\\"  Now at t=\\\" << time.get_current_time()\\n\\u00a0                   << \\\", dt=\\\" << time.get_previous_step_size() << '.'\\n\\u00a0                   << std::endl\\n\\u00a0                   << std::endl;\\n\\u00a0 \\nThe only other difference between this program and step-19 is that we checkpoint the simulation every ten time steps:\\n\\u00a0         if (time.get_step_number() % 10 == 0)\\n\\u00a0           checkpoint();\\n\\u00a0       }\\n\\u00a0     while (time.is_at_end() == false);\\n\\u00a0   }\\n\\u00a0 } // namespace Step83\\n\\u00a0 \\n\\u00a0 \\n The main function\\nThe final function of the program is then again the main() function. Its overall structure is unchanged in all tutorial programs since step-6 and so there is nothing new to discuss about this aspect.\\nThe only difference is that we need to figure out whether a restart was requested, or whether the program should simply start from scratch when called. We do this using a command line argument: The argc argument to main() indicates how many command line arguments were provided when the program was called (counting the name of the program as the zeroth argument), and argv is an array of strings with as many elements as argc that contains these command line arguments. So if you call the program as  ./step-83\\n  then argc will be 1, and argv will be the array with one element and content [ \\\"./step-83\\\" ]. On the other hand, if you call the program as  ./step-83 restart\\n  then argc will be 2, and argv will be the array with two elements and content [ \\\"./step-83\\\", \\\"restart\\\" ]. Every other choice should be flagged as an error. The following try block then does exactly this:\\n\\u00a0 int main(int argc, char *argv[])\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       Step83::CathodeRaySimulator<2> cathode_ray_simulator;\\n\\u00a0 \\n\\u00a0       if (argc == 1)\\n\\u00a0         cathode_ray_simulator.run(false); // no restart\\n\\u00a0       else if ((argc == 2) && (std::string(argv[1]) == \\\"restart\\\"))\\n\\u00a0         cathode_ray_simulator.run(true); // yes restart\\n\\u00a0       else\\n\\u00a0         {\\n\\u00a0           std::cerr << \\\"Error: The only allowed command line argument to this\\\\n\\\"\\n\\u00a0                        \\\"       program is 'restart'.\\\"\\n\\u00a0                     << std::endl;\\n\\u00a0           return 1;\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0 \\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nWhen you run this program, it produces the following output that is almost exactly identical to what you get from step-19: Timestep 1\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  20\\n  Number of particles lost this time step:  0\\n \\n  Now at t=2.12647e-07, dt=2.12647e-07.\\n \\nTimestep 2\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  40\\n  Number of particles lost this time step:  0\\n \\n  Now at t=4.14362e-07, dt=2.01715e-07.\\n \\nTimestep 3\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  60\\n  Number of particles lost this time step:  0\\n \\n  Now at t=5.23066e-07, dt=1.08704e-07.\\n \\nTimestep 4\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  80\\n  Number of particles lost this time step:  0\\n \\n  Now at t=6.08431e-07, dt=8.53649e-08.\\n \\nTimestep 5\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  100\\n  Number of particles lost this time step:  0\\n \\n  Now at t=6.81935e-07, dt=7.35039e-08.\\n \\nTimestep 6\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  120\\n  Number of particles lost this time step:  0\\n \\n  Now at t=7.47864e-07, dt=6.59294e-08.\\n \\nTimestep 7\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  140\\n  Number of particles lost this time step:  0\\n \\n  Now at t=8.2516e-07, dt=7.72957e-08.\\n \\nTimestep 8\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  158\\n  Number of particles lost this time step:  0\\n \\n  Now at t=8.95325e-07, dt=7.01652e-08.\\n \\nTimestep 9\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  172\\n  Number of particles lost this time step:  0\\n \\n  Now at t=9.67852e-07, dt=7.25269e-08.\\n \\nTimestep 10\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  186\\n  Number of particles lost this time step:  0\\n \\n  Now at t=1.03349e-06, dt=6.56398e-08.\\n \\n--- Writing checkpoint... ---\\n \\nTimestep 11\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  198\\n  Number of particles lost this time step:  0\\n \\n  Now at t=1.11482e-06, dt=8.13268e-08.\\n \\nTimestep 12\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  206\\n  Number of particles lost this time step:  0\\n \\n  Now at t=1.18882e-06, dt=7.39967e-08.\\n \\nTimestep 13\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  212\\n  Number of particles lost this time step:  0\\n \\n  Now at t=1.26049e-06, dt=7.16705e-08.\\n \\n[...]\\n The only thing that is different is the additional line after the tenth output (which also appears after the 20th, 30th, etc., time step) indicating that a checkpoint file has been written.\\nBecause we chose to use a text-based format for the checkpoint file (which you should not do in production codes because it uses quite a lot of disk space), we can actually inspect this file. It will look like this, with many many more lines: 22 serialization::archive 18 0 0 0 0 0 7 0 0 3 1 0\\n4989 -1.00000000000000000e+00 -1.00000000000000000e+00 -1.00000000000000000e+00 -9.96108134982226390e-01 -1.00000000000000000e+00 -9.98361082867431748e-01\\n[...]\\n What each of these numbers represents is hard to tell in practice, and also entirely unimporant for our current purposes \\u2013 it's a representation of the many objects that make up this program's state, and from which one can restore its state. The point simply being that this is what serialization produces: A long list (a sequence) of bits that we can put into a file, and that we can later read again to recreate the state of the program.\\nNow here's the fun part. Let's say you hit Control-C on the command line at the point above (say, during time step 13 or 14). There's a set of checkpoint files on disk that saved the state after ten time steps. Based on the logic in main(), we should be able to restart from this point if we run the program with ./step-83 restart\\n Indeed, this is what then happens: --- Restarting at t=1.03349e-06, dt=6.56398e-08\\n \\nTimestep 11\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  198\\n  Number of particles lost this time step:  0\\n \\n  Now at t=1.11482e-06, dt=8.13268e-08.\\n \\nTimestep 12\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  206\\n  Number of particles lost this time step:  0\\n \\n  Now at t=1.18882e-06, dt=7.39967e-08.\\n \\n[...]\\n After the status message that shows that we are restarting, this is indeed the exact same output for the following time steps we had gotten previously \\u2013 in other words, saving the complete state seems to have worked, and the program has continued as if it had never been interrupted!\\n Possibilities for extensions\\nMaking efficiency a priority \\nWhile the techniques we have shown here are fully sufficient for what we want to do, namely checkpoint and restart computations, and are in fact also fully sufficient for much larger code bases such as ASPECT, one could go beyond what is still a relatively simple scheme.\\nSpecifically, among the things we need to recognize is that writing large amounts of data to disk is expensive and can take a good long time to finish \\u2013 for example, for large parallel computations with, say, a billion unknowns, checkpoints can run into the hundred gigabyte range or beyond. One may ask whether that could be avoided, or at least whether we can mitigate the cost.\\nOne way to do that is to first serialize the state of the program into a buffer in memory (like the Archive objects the serialize() functions write to and read from), and once that is done, start a separate thread do the writing while the rest of the program continues with computations. This is useful because writing the data to disk often takes a long time but not a lot of CPU power: It just takes time to move the data through the network to the file server, and from there onto the actual disks. This is something that might as well happen while we are doing something useful again (namely, solving more time steps). Should the machine crash during this phase, nothing is lost: As discussed in the introduction, we are writing the checkpoint into a temporary file (which will be lost in the case of a machine failure), but we have kept the previous checkpoint around until we know that the temporary file is complete and can be moved over the old one.\\nThe only thing we have to pay attention in this background-writing scheme is that we cannot start with creating a new checkpoint while the previous one is still being written in the background.\\nDoing this all is not technically very difficult; the code just requires more explanation than lines of code, and so we omit doing this in the program here. But you can take a look at the MainLoop::output() function of step-69 to see how such a code looks like.\\nA variation of this general approach is that each process writes its data immediately, but into files that are held on fast file systems \\u2013 say, a node-local SSD rather than a file server shared by the entire cluster. One would then just tell the operating system to move this file to the centeral file server in a second step, and this step can happen in the background at whatever speed the operating system can provide. Or perhaps one leaves most of these files on the fast local file system in hopes that the restart happens before these files are purged (say, by a script that runs nightly) and only moves these files to the permanent file system every tenth time we create a checkpoint.\\nIn all of these cases, the logic quickly becomes quite complicated. As usual, the solution is not to re-invent the wheel: Libraries such as VeloC, developed by the Exascale Computing Project (ECP) already do all of this and more, for codes that are orders of magnitude more complex than the little example here.\\nSeparately, one might want to try to reduce the amount of time it takes to serialize objects into a buffer in memory. As mentioned above, we use the BOOST serialization library for this task, but it is not the only player in town. One could, for example, use the bitsery, cereal, or zpp projects instead, which can be substantially faster than BOOST.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2023 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Author: Pasquale Africa, SISSA, 2024,\\n *         Wolfgang Bangerth, Colorado State University, 2024,\\n *         Bruno Blais, Polytechnique Montreal, 2024.\\n */\\n \\n \\n \\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/discrete_time.h>\\n \\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/precondition.h>\\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/lac/vector.h>\\n#include <deal.II/lac/affine_constraints.h>\\n \\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_refinement.h>\\n#include <deal.II/grid/grid_tools.h>\\n \\n#include <deal.II/fe/mapping_q.h>\\n#include <deal.II/matrix_free/fe_point_evaluation.h>\\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_values.h>\\n \\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/vector_tools.h>\\n#include <deal.II/numerics/error_estimator.h>\\n \\n#include <deal.II/particles/particle_handler.h>\\n#include <deal.II/particles/data_out.h>\\n \\n#include <boost/archive/text_iarchive.hpp>\\n#include <boost/archive/text_oarchive.hpp>\\n \\n#include <filesystem>\\n#include <fstream>\\n#include <string>\\n \\n \\nnamespace Step83\\n{\\n using namespace dealii;\\n \\n namespace BoundaryIds\\n  {\\n constexpr types::boundary_id open          = 101;\\n constexpr types::boundary_id cathode       = 102;\\n constexpr types::boundary_id focus_element = 103;\\n constexpr types::boundary_id anode         = 104;\\n  } // namespace BoundaryIds\\n \\n namespace Constants\\n  {\\n constexpr double electron_mass   = 9.1093837015e-31;\\n constexpr double electron_charge = 1.602176634e-19;\\n \\n constexpr double V0 = 1;\\n \\n constexpr double E_threshold = 0.05;\\n \\n constexpr double electrons_per_particle = 3e15;\\n  } // namespace Constants\\n \\n \\n \\n template <int dim>\\n class CathodeRaySimulator\\n  {\\n public:\\n    CathodeRaySimulator();\\n \\n void run(const bool do_restart);\\n \\n template <class Archive>\\n void serialize(Archive &ar, const unsigned int version);\\n \\n private:\\n void make_grid();\\n void setup_system();\\n void assemble_system();\\n void solve_field();\\n void refine_grid();\\n \\n void create_particles();\\n void move_particles();\\n void track_lost_particle(\\n const Particles::ParticleIterator<dim>                  &particle,\\n const typename Triangulation<dim>::active_cell_iterator &cell);\\n \\n void update_timestep_size();\\n void output_results() const;\\n \\n void checkpoint();\\n void restart();\\n \\n Triangulation<dim> triangulation;\\n const MappingQ<dim>       mapping;\\n const FE_Q<dim>           fe;\\n DoFHandler<dim>           dof_handler;\\n AffineConstraints<double> constraints;\\n \\n SparseMatrix<double> system_matrix;\\n SparsityPattern      sparsity_pattern;\\n \\n Vector<double> solution;\\n Vector<double> system_rhs;\\n \\n Particles::ParticleHandler<dim> particle_handler;\\n types::particle_index           next_unused_particle_id;\\n types::particle_index           n_recently_lost_particles;\\n types::particle_index           n_total_lost_particles;\\n types::particle_index           n_particles_lost_through_anode;\\n \\n DiscreteTime time;\\n  };\\n \\n \\n \\n \\n \\n template <int dim>\\n  CathodeRaySimulator<dim>::CathodeRaySimulator()\\n    : mapping(1)\\n    , fe(2)\\n    , dof_handler(triangulation)\\n    , particle_handler(triangulation, mapping, /*n_properties=*/dim)\\n    , next_unused_particle_id(0)\\n    , n_recently_lost_particles(0)\\n    , n_total_lost_particles(0)\\n    , n_particles_lost_through_anode(0)\\n    , time(0, 1e-4)\\n  {\\n    particle_handler.signals.particle_lost.connect(\\n      [this](const typename Particles::ParticleIterator<dim>         &particle,\\n const typename Triangulation<dim>::active_cell_iterator &cell) {\\n        this->track_lost_particle(particle, cell);\\n      });\\n  }\\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::make_grid()\\n  {\\n static_assert(dim == 2,\\n \\\"This function is currently only implemented for 2d.\\\");\\n \\n const double       delta = 0.5;\\n const unsigned int nx    = 5;\\n const unsigned int ny    = 3;\\n \\n const std::vector<Point<dim>> vertices \\n      = {{0, 0},\\n         {1, 0},\\n         {2, 0},\\n         {3, 0},\\n         {4, 0},\\n         {delta, 1},\\n         {1, 1},\\n         {2, 1},\\n         {3, 1},\\n         {4, 1},\\n         {0, 2},\\n         {1, 2},\\n         {2, 2},\\n         {3, 2},\\n         {4, 2}};\\n AssertDimension(vertices.size(), nx * ny);\\n \\n const std::vector<unsigned int> cell_vertices[(nx - 1) * (ny - 1)] = {\\n      {0, 1, nx + 0, nx + 1},\\n      {1, 2, nx + 1, nx + 2},\\n      {2, 3, nx + 2, nx + 3},\\n      {3, 4, nx + 3, nx + 4},\\n \\n      {5, nx + 1, 2 * nx + 0, 2 * nx + 1},\\n      {nx + 1, nx + 2, 2 * nx + 1, 2 * nx + 2},\\n      {nx + 2, nx + 3, 2 * nx + 2, 2 * nx + 3},\\n      {nx + 3, nx + 4, 2 * nx + 3, 2 * nx + 4}};\\n \\n    std::vector<CellData<dim>> cells((nx - 1) * (ny - 1), CellData<dim>());\\n for (unsigned int i = 0; i < cells.size(); ++i)\\n      {\\n        cells[i].vertices    = cell_vertices[i];\\n        cells[i].material_id = 0;\\n      }\\n \\n GridTools::consistently_order_cells(cells);\\n triangulation.create_triangulation(\\n vertices,\\n      cells,\\n SubCellData()); // No boundary information\\n \\n triangulation.refine_global(2);\\n \\n for (auto &cell : triangulation.active_cell_iterators())\\n      for (auto &face : cell->face_iterators())\\n        if (face->at_boundary())\\n          {\\n if ((face->center()[0] > 0) && (face->center()[0] < 0.5) &&\\n                (face->center()[1] > 0) && (face->center()[1] < 2))\\n              face->set_boundary_id(BoundaryIds::cathode);\\n else if ((face->center()[0] > 0) && (face->center()[0] < 2))\\n              face->set_boundary_id(BoundaryIds::focus_element);\\n else if ((face->center()[0] > 4 - 1e-12) &&\\n                     ((face->center()[1] > 1.5) || (face->center()[1] < 0.5)))\\n              face->set_boundary_id(BoundaryIds::anode);\\n else\\n              face->set_boundary_id(BoundaryIds::open);\\n          }\\n \\n triangulation.refine_global(1);\\n  }\\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::setup_system()\\n  {\\n    dof_handler.distribute_dofs(fe);\\n \\n    solution.reinit(dof_handler.n_dofs());\\n    system_rhs.reinit(dof_handler.n_dofs());\\n \\n    constraints.clear();\\n DoFTools::make_hanging_node_constraints(dof_handler, constraints);\\n \\n VectorTools::interpolate_boundary_values(dof_handler,\\n                                             BoundaryIds::cathode,\\n Functions::ConstantFunction<dim>(\\n                                               -Constants::V0),\\n                                             constraints);\\n VectorTools::interpolate_boundary_values(dof_handler,\\n                                             BoundaryIds::focus_element,\\n Functions::ConstantFunction<dim>(\\n                                               -Constants::V0),\\n                                             constraints);\\n VectorTools::interpolate_boundary_values(dof_handler,\\n                                             BoundaryIds::anode,\\n Functions::ConstantFunction<dim>(\\n                                               +Constants::V0),\\n                                             constraints);\\n    constraints.close();\\n \\n DynamicSparsityPattern dsp(dof_handler.n_dofs());\\n DoFTools::make_sparsity_pattern(dof_handler,\\n                                    dsp,\\n                                    constraints,\\n /* keep_constrained_dofs = */ false);\\n    sparsity_pattern.copy_from(dsp);\\n \\n    system_matrix.reinit(sparsity_pattern);\\n  }\\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::assemble_system()\\n  {\\n    system_matrix = 0;\\n    system_rhs    = 0;\\n \\n const QGauss<dim> quadrature_formula(fe.degree + 1);\\n \\n FEValues<dim> fe_values(fe,\\n                            quadrature_formula,\\n update_values | update_gradients |\\n update_quadrature_points | update_JxW_values);\\n \\n const unsigned int dofs_per_cell = fe.dofs_per_cell;\\n \\n FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n Vector<double>     cell_rhs(dofs_per_cell);\\n \\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n cell_matrix = 0;\\n        cell_rhs    = 0;\\n \\n        fe_values.reinit(cell);\\n \\n for (const unsigned int q_index : fe_values.quadrature_point_indices())\\n          for (const unsigned int i : fe_values.dof_indices())\\n            {\\n for (const unsigned int j : fe_values.dof_indices())\\n cell_matrix(i, j) +=\\n                  (fe_values.shape_grad(i, q_index) * // grad phi_i(x_q)\\n                   fe_values.shape_grad(j, q_index) * // grad phi_j(x_q)\\n                   fe_values.JxW(q_index));           // dx\\n            }\\n \\n if (particle_handler.n_particles_in_cell(cell) > 0)\\n for (const auto &particle : particle_handler.particles_in_cell(cell))\\n            {\\n const Point<dim> &reference_location =\\n                particle.get_reference_location();\\n for (const unsigned int i : fe_values.dof_indices())\\n                cell_rhs(i) +=\\n                  (fe.shape_value(i, reference_location) * // phi_i(x_p)\\n                   (-Constants::electrons_per_particle *   // N\\n                    Constants::electron_charge));          // e\\n            }\\n \\n        cell->get_dof_indices(local_dof_indices);\\n        constraints.distribute_local_to_global(\\n          cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);\\n      }\\n  }\\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::solve_field()\\n  {\\n SolverControl            solver_control(1000, 1e-12);\\n SolverCG<Vector<double>> solver(solver_control);\\n \\n PreconditionSSOR<SparseMatrix<double>> preconditioner;\\n    preconditioner.initialize(system_matrix, 1.2);\\n \\n    solver.solve(system_matrix, solution, system_rhs, preconditioner);\\n \\n    constraints.distribute(solution);\\n  }\\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::refine_grid()\\n  {\\n Vector<float> estimated_error_per_cell(triangulation.n_active_cells());\\n \\n KellyErrorEstimator<dim>::estimate(dof_handler,\\n QGauss<dim - 1>(fe.degree + 1),\\n                                       {},\\n                                       solution,\\n                                       estimated_error_per_cell);\\n \\n GridRefinement::refine_and_coarsen_fixed_number(triangulation,\\n                                                    estimated_error_per_cell,\\n                                                    0.1,\\n                                                    0.03);\\n \\n triangulation.execute_coarsening_and_refinement();\\n  }\\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::create_particles()\\n  {\\n FEFaceValues<dim> fe_face_values(fe,\\n QMidpoint<dim - 1>(),\\n update_quadrature_points |\\n update_gradients |\\n update_normal_vectors);\\n \\n    std::vector<Tensor<1, dim>> solution_gradients(\\n      fe_face_values.n_quadrature_points);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      for (const auto &face : cell->face_iterators())\\n        if (face->at_boundary() &&\\n            (face->boundary_id() == BoundaryIds::cathode))\\n          {\\n            fe_face_values.reinit(cell, face);\\n \\n const FEValuesExtractors::Scalar electric_potential(0);\\n            fe_face_values[electric_potential].get_function_gradients(\\n              solution, solution_gradients);\\n for (const unsigned int q_point :\\n                 fe_face_values.quadrature_point_indices())\\n              {\\n const Tensor<1, dim> E = solution_gradients[q_point];\\n \\n if ((E * fe_face_values.normal_vector(q_point) < 0) &&\\n                    (E.norm() > Constants::E_threshold))\\n                  {\\n const Point<dim> &location =\\n                      fe_face_values.quadrature_point(q_point);\\n \\n Particles::Particle<dim> new_particle;\\n                    new_particle.set_location(location);\\n                    new_particle.set_reference_location(\\n                      mapping.transform_real_to_unit_cell(cell, location));\\n                    new_particle.set_id(next_unused_particle_id);\\n                    particle_handler.insert_particle(new_particle, cell);\\n \\n                    ++next_unused_particle_id;\\n                  }\\n              }\\n          }\\n \\n    particle_handler.update_cached_numbers();\\n  }\\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::move_particles()\\n  {\\n const double dt = time.get_next_step_size();\\n \\n Vector<double>            solution_values(fe.n_dofs_per_cell());\\n FEPointEvaluation<1, dim> evaluator(mapping, fe, update_gradients);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      if (particle_handler.n_particles_in_cell(cell) > 0)\\n        {\\n const typename Particles::ParticleHandler<\\n            dim>::particle_iterator_range particles_in_cell =\\n            particle_handler.particles_in_cell(cell);\\n \\n          std::vector<Point<dim>> particle_positions;\\n for (const auto &particle : particles_in_cell)\\n            particle_positions.push_back(particle.get_reference_location());\\n \\n          cell->get_dof_values(solution, solution_values);\\n \\n          evaluator.reinit(cell, particle_positions);\\n          evaluator.evaluate(make_array_view(solution_values),\\n EvaluationFlags::gradients);\\n \\n          {\\n typename Particles::ParticleHandler<dim>::particle_iterator\\n              particle = particles_in_cell.begin();\\n for (unsigned int particle_index = 0;\\n                 particle != particles_in_cell.end();\\n                 ++particle, ++particle_index)\\n              {\\n const Tensor<1, dim> &E =\\n                  evaluator.get_gradient(particle_index);\\n \\n const Tensor<1, dim> old_velocity(particle->get_properties());\\n \\n const Tensor<1, dim> acceleration =\\n                  Constants::electron_charge / Constants::electron_mass * E;\\n \\n const Tensor<1, dim> new_velocity =\\n                  old_velocity + acceleration * dt;\\n \\n                particle->set_properties(new_velocity);\\n \\n const Point<dim> new_location =\\n                  particle->get_location() + dt * new_velocity;\\n                particle->set_location(new_location);\\n              }\\n          }\\n        }\\n \\n    particle_handler.sort_particles_into_subdomains_and_cells();\\n  }\\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::track_lost_particle(\\n const typename Particles::ParticleIterator<dim>         &particle,\\n const typename Triangulation<dim>::active_cell_iterator &cell)\\n  {\\n    ++n_recently_lost_particles;\\n    ++n_total_lost_particles;\\n \\n const Point<dim> current_location              = particle->get_location();\\n const Point<dim> approximate_previous_location = cell->center();\\n \\n if ((approximate_previous_location[0] < 4) && (current_location[0] > 4))\\n      {\\n const Tensor<1, dim> direction =\\n          (current_location - approximate_previous_location) /\\n          (current_location[0] - approximate_previous_location[0]);\\n \\n const double right_boundary_intercept =\\n          approximate_previous_location[1] +\\n          (4 - approximate_previous_location[0]) * direction[1];\\n if ((right_boundary_intercept > 0.5) &&\\n            (right_boundary_intercept < 1.5))\\n          ++n_particles_lost_through_anode;\\n      }\\n  }\\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::update_timestep_size()\\n  {\\n if (time.get_step_number() > 0)\\n      {\\n double min_cell_size_over_velocity = std::numeric_limits<double>::max();\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n          if (particle_handler.n_particles_in_cell(cell) > 0)\\n            {\\n const double cell_size = cell->minimum_vertex_distance();\\n \\n double max_particle_velocity(0.0);\\n \\n for (const auto &particle :\\n                   particle_handler.particles_in_cell(cell))\\n                {\\n const Tensor<1, dim> velocity(particle.get_properties());\\n                  max_particle_velocity =\\n std::max(max_particle_velocity, velocity.norm());\\n                }\\n \\n if (max_particle_velocity > 0)\\n                min_cell_size_over_velocity =\\n std::min(min_cell_size_over_velocity,\\n                           cell_size / max_particle_velocity);\\n            }\\n \\n constexpr double c_safety = 0.5;\\n        time.set_desired_next_step_size(c_safety * 0.5 *\\n                                        min_cell_size_over_velocity);\\n      }\\n else\\n      {\\n const QTrapezoid<dim> vertex_quadrature;\\n FEValues<dim> fe_values(fe, vertex_quadrature, update_gradients);\\n \\n        std::vector<Tensor<1, dim>> field_gradients(vertex_quadrature.size());\\n \\n double min_timestep = std::numeric_limits<double>::max();\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n          if (particle_handler.n_particles_in_cell(cell) > 0)\\n            {\\n const double cell_size = cell->minimum_vertex_distance();\\n \\n              fe_values.reinit(cell);\\n              fe_values.get_function_gradients(solution, field_gradients);\\n \\n double max_E = 0;\\n for (const auto q_point : fe_values.quadrature_point_indices())\\n                max_E = std::max(max_E, field_gradients[q_point].norm());\\n \\n if (max_E > 0)\\n                min_timestep =\\n std::min(min_timestep,\\n std::sqrt(0.5 * cell_size *\\n                                     Constants::electron_mass /\\n                                     Constants::electron_charge / max_E));\\n            }\\n \\n        time.set_desired_next_step_size(min_timestep);\\n      }\\n  }\\n \\n \\n \\n template <int dim>\\n class ElectricFieldPostprocessor : public DataPostprocessorVector<dim>\\n  {\\n public:\\n    ElectricFieldPostprocessor()\\n      : DataPostprocessorVector<dim>(\\\"electric_field\\\", update_gradients)\\n    {}\\n \\n virtual void evaluate_scalar_field(\\n const DataPostprocessorInputs::Scalar<dim> &input_data,\\n      std::vector<Vector<double>> &computed_quantities) const override\\n {\\n AssertDimension(input_data.solution_gradients.size(),\\n                      computed_quantities.size());\\n \\n for (unsigned int p = 0; p < input_data.solution_gradients.size(); ++p)\\n        {\\n AssertDimension(computed_quantities[p].size(), dim);\\n for (unsigned int d = 0; d < dim; ++d)\\n            computed_quantities[p][d] = input_data.solution_gradients[p][d];\\n        }\\n    }\\n  };\\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::output_results() const\\n {\\n    {\\n      ElectricFieldPostprocessor<dim> electric_field;\\n DataOut<dim>                    data_out;\\n      data_out.attach_dof_handler(dof_handler);\\n      data_out.add_data_vector(solution, \\\"electric_potential\\\");\\n      data_out.add_data_vector(solution, electric_field);\\n      data_out.build_patches();\\n \\n DataOutBase::VtkFlags output_flags;\\n      output_flags.time  = time.get_current_time();\\n      output_flags.cycle = time.get_step_number();\\n      output_flags.physical_units[\\\"electric_potential\\\"] = \\\"V\\\";\\n      output_flags.physical_units[\\\"electric_field\\\"]     = \\\"V/m\\\";\\n \\n      data_out.set_flags(output_flags);\\n \\n      std::ofstream output(\\\"solution-\\\" +\\n Utilities::int_to_string(time.get_step_number(), 4) +\\n \\\".vtu\\\");\\n      data_out.write_vtu(output);\\n    }\\n \\n    {\\n Particles::DataOut<dim> particle_out;\\n      particle_out.build_patches(\\n        particle_handler,\\n        std::vector<std::string>(dim, \\\"velocity\\\"),\\n        std::vector<DataComponentInterpretation::DataComponentInterpretation>(\\n          dim, DataComponentInterpretation::component_is_part_of_vector));\\n \\n DataOutBase::VtkFlags output_flags;\\n      output_flags.time                       = time.get_current_time();\\n      output_flags.cycle                      = time.get_step_number();\\n      output_flags.physical_units[\\\"velocity\\\"] = \\\"m/s\\\";\\n \\n      particle_out.set_flags(output_flags);\\n \\n      std::ofstream output(\\\"particles-\\\" +\\n Utilities::int_to_string(time.get_step_number(), 4) +\\n \\\".vtu\\\");\\n      particle_out.write_vtu(output);\\n    }\\n  }\\n \\n \\n \\n \\n template <int dim>\\n template <class Archive>\\n void CathodeRaySimulator<dim>::serialize(Archive &ar,\\n const unsigned int /* version */)\\n  {\\n    ar &solution;\\n    ar &particle_handler;\\n    ar &next_unused_particle_id;\\n    ar &n_recently_lost_particles;\\n    ar &n_total_lost_particles;\\n    ar &n_particles_lost_through_anode;\\n    ar &time;\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::checkpoint()\\n  {\\n    std::cout << \\\"--- Writing checkpoint... ---\\\" << std::endl << std::endl;\\n \\n    {\\n      std::ofstream checkpoint_file(\\\"tmp.checkpoint_step_83\\\");\\n AssertThrow(checkpoint_file,\\n                  ExcMessage(\\n \\\"Could not write to the <tmp.checkpoint_step_83> file.\\\"));\\n \\n      boost::archive::text_oarchive archive(checkpoint_file);\\n \\n      archive << *this;\\n    }\\n \\n    particle_handler.prepare_for_serialization();\\n triangulation.save(\\\"tmp.checkpoint\\\");\\n \\n \\n    std::list<std::string> tmp_checkpoint_files;\\n for (const auto &dir_entry : std::filesystem::directory_iterator(\\\".\\\"))\\n      if (dir_entry.is_regular_file() &&\\n          (dir_entry.path().filename().string().find(\\\"tmp.checkpoint\\\") == 0))\\n        tmp_checkpoint_files.push_back(dir_entry.path().filename().string());\\n \\n for (const std::string &filename : tmp_checkpoint_files)\\n std::filesystem::rename(filename, filename.substr(4, std::string::npos));\\n  }\\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::restart()\\n  {\\n    {\\n      std::ifstream checkpoint_file(\\\"checkpoint_step_83\\\");\\n AssertThrow(checkpoint_file,\\n                  ExcMessage(\\n \\\"Could not read from the <checkpoint_step_83> file.\\\"));\\n \\n      boost::archive::text_iarchive archive(checkpoint_file);\\n      archive >> *this;\\n    }\\n \\n triangulation.load(\\\"checkpoint\\\");\\n    particle_handler.deserialize();\\n \\n    std::cout << \\\"--- Restarting at t=\\\" << time.get_current_time()\\n              << \\\", dt=\\\" << time.get_next_step_size() << std::endl\\n              << std::endl;\\n  }\\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::run(const bool do_restart)\\n  {\\n if (do_restart == false)\\n      {\\n        make_grid();\\n \\n const unsigned int n_pre_refinement_cycles = 3;\\n for (unsigned int refinement_cycle = 0;\\n             refinement_cycle < n_pre_refinement_cycles;\\n             ++refinement_cycle)\\n          {\\n            setup_system();\\n            assemble_system();\\n            solve_field();\\n            refine_grid();\\n          }\\n      }\\n else\\n      {\\n        restart();\\n      }\\n \\n    setup_system();\\n do\\n      {\\n        std::cout << \\\"Timestep \\\" << time.get_step_number() + 1 << std::endl;\\n        std::cout << \\\"  Field degrees of freedom:                 \\\"\\n                  << dof_handler.n_dofs() << std::endl;\\n \\n        assemble_system();\\n        solve_field();\\n \\n        create_particles();\\n        std::cout << \\\"  Total number of particles in simulation:  \\\"\\n                  << particle_handler.n_global_particles() << std::endl;\\n \\n        n_recently_lost_particles = 0;\\n        update_timestep_size();\\n        move_particles();\\n \\n        time.advance_time();\\n \\n        output_results();\\n \\n        std::cout << \\\"  Number of particles lost this time step:  \\\"\\n                  << n_recently_lost_particles << std::endl;\\n if (n_total_lost_particles > 0)\\n          std::cout << \\\"  Fraction of particles lost through anode: \\\"\\n                    << 1. * n_particles_lost_through_anode /\\n                         n_total_lost_particles\\n                    << std::endl;\\n \\n        std::cout << std::endl\\n                  << \\\"  Now at t=\\\" << time.get_current_time()\\n                  << \\\", dt=\\\" << time.get_previous_step_size() << '.'\\n                  << std::endl\\n                  << std::endl;\\n \\n if (time.get_step_number() % 10 == 0)\\n          checkpoint();\\n      }\\n while (time.is_at_end() == false);\\n  }\\n} // namespace Step83\\n \\n \\n \\nint main(int argc, char *argv[])\\n{\\n try\\n    {\\n      Step83::CathodeRaySimulator<2> cathode_ray_simulator;\\n \\n if (argc == 1)\\n        cathode_ray_simulator.run(false); // no restart\\n else if ((argc == 2) && (std::string(argv[1]) == \\\"restart\\\"))\\n        cathode_ray_simulator.run(true); // yes restart\\n else\\n        {\\n          std::cerr << \\\"Error: The only allowed command line argument to this\\\\n\\\"\\n \\\"       program is 'restart'.\\\"\\n                    << std::endl;\\n return 1;\\n        }\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n \\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n return 0;\\n}\\naffine_constraints.h\\nDataOutInterface::write_vtuvoid write_vtu(std::ostream &out) constDefinition data_out_base.cc:7692\\nDataOutInterface::set_flagsvoid set_flags(const FlagType &flags)Definition data_out_base.cc:8863\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nParticles::ParticleHandler::particles_in_cellparticle_iterator_range particles_in_cell(const typename Triangulation< dim, spacedim >::active_cell_iterator &cell)Definition particle_handler.cc:449\\nParticles::Particle::set_reference_locationvoid set_reference_location(const Point< dim > &new_reference_location)Definition particle.h:572\\nParticles::Particle::set_idvoid set_id(const types::particle_index &new_id)Definition particle.h:599\\ndiscrete_time.h\\ndof_handler.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nerror_estimator.h\\nfe_values.h\\nfe_point_evaluation.h\\nfe_q.h\\nfull_matrix.h\\ngrid_refinement.h\\ntria.h\\ngrid_tools.h\\nmapping_q.h\\nPhysics::Elasticity::Kinematics::eSymmetricTensor< 2, dim, Number > e(const Tensor< 2, dim, Number > &F)\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\ndata_out.h\\nparticle_handler.h\\ndata_out.h\\nprecondition.h\\nquadrature_lib.h\\nsolver_cg.h\\nsparse_matrix.h\\nDataOutBase::VtkFlags::cycleunsigned int cycleDefinition data_out_base.h:1150\\nDataOutBase::VtkFlags::physical_unitsstd::map< std::string, std::string > physical_unitsDefinition data_out_base.h:1224\\nDataPostprocessorInputs::Scalar::solution_gradientsstd::vector< Tensor< 1, spacedim > > solution_gradientsDefinition data_postprocessor.h:343\\nvector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"