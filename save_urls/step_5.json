"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_5.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-5 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-5 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-5 tutorial program\\n\\n\\nThis tutorial depends on step-4.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\n Successively refined grids \\n Reading in an externally generated mesh \\n Solving a generalized Laplace (Poisson) equation \\n Support for debugging: Assertions \\n\\n The commented program\\n\\nInclude files\\nThe Step5 class template\\nWorking with nonconstant coefficients\\nThe Step5 class implementation\\n\\nStep5::Step5\\nStep5::setup_system\\nStep5::assemble_system\\nStep5::solve\\nStep5::output_results and setting output flags\\nStep5::run\\n\\nThe main function\\n\\n\\n Results\\n\\n\\n The plain program\\n   \\n Introduction\\nNoteThe material presented here is also discussed in video lecture 14. (All video lectures are also available here.)\\nThis example shows a number of improvements over the previous examples, along with some of the things that can usually be found in finite element programs. Let us outline these in the following.\\nSuccessively refined grids \\nYou know from theory that the solution of a partial differential equation computed by the finite element method is an approximation of the exact solution, and that the approximation converges to the exact solution. But if you only compute on a single mesh (as we have done in step-3 and step-4), how do you know that the approximation is good enough (however you want to define that)? In practice, there are two ways you can assess this: First, you can compute the solution on a whole sequence of meshes and observe how the solution changes (or doesn't) from one mesh to another. Second, you can just compare the solution on one mesh against the solution computed on a once-refined meshes. Both step-3 and step-4 discuss these sorts of things in their respective \\\"Results\\\" sections, doing the mesh refinement mostly by hand: You had to make a change in the program, re-compile everything, and then run the program again.\\nThis program automates this process via a loop over a sequence of more-and-more refined meshes, doing the mesh refinement as part of the loop. In this program, the mesh is refined by simply replacing every (quadrilateral) cell of the mesh by its four children. In reality, this is often not necessary, because the solution is already sufficiently good in some parts of the domain whereas the mesh is still too coarse in other parts, and in those cases one can get away with refining only some of the cells \\u2013 but this is the topic of step-6, and we leave it for there.\\nReading in an externally generated mesh \\nIn practical applications, the domain on which you want to solve a partial differential equation is often subdivided into a triangulations by automatic mesh generators, i.e., specialized tools external to deal.II. (deal.II can generate some simple meshes using the functions in namespace GridGenerator, and it also has interfaces to the Gmsh mesh generator in namespace Gmsh, but for most complex geometries, you will want to use an external mesh generator.) These mesh generators will typically write the mesh they create into a file. In order to use such meshes, it is important to read these files into the coarse grid triangulation from which we can then continue by refining the mesh appropriately. For reading meshes, we will use the GridIn class that can read meshes in a substantial number of formats produced by most of the widely used mesh generators. In this tutorial, we will read a coarse grid in UCD (short for \\\"unstructured\\ncell data\\\") format: When this program was first written around 2000, the UCD format was what the AVS Explorer used \\u2013 a program reasonably widely used at the time though today no longer of importance. The file format itself has survived and is still widely understood, but because GridIn reads so many different formats, the specific choice used in this tutorial program is perhaps not all that important.\\nSolving a generalized Laplace (Poisson) equation \\nThe equation to solve here is as follows:     \\n\\\\begin{align*}\\n  -\\\\nabla \\\\cdot a(\\\\mathbf x) \\\\nabla u(\\\\mathbf x) &= 1 \\\\qquad\\\\qquad & \\\\text{in}\\\\ \\\\Omega,\\n  \\\\\\\\\\n  u &= 0 \\\\qquad\\\\qquad & \\\\text{on}\\\\ \\\\partial\\\\Omega.\\n\\\\end{align*}\\n\\n If \\\\(a(\\\\mathbf x)\\\\) was a constant coefficient, this would simply be the Poisson equation that we have already solved in step-3 and step-4. However, if it is indeed spatially variable, it is a more complex equation (sometimes referred to as the \\\"Poisson equation with a coefficient\\\"). Specifically, we will here choose it as follows:       \\n\\\\begin{align*}\\n  a(\\\\mathbf x) =\\n  \\\\begin{cases}\\n    20 & \\\\text{if}\\\\ |\\\\mathbf x|<0.5, \\\\\\\\\\n    1  & \\\\text{otherwise.}\\n  \\\\end{cases}\\n\\\\end{align*}\\n\\n Depending on what the variable \\\\(u\\\\) refers to, it models a variety of situations with wide applicability:\\n\\nIf \\\\(u\\\\) is the electric potential, then \\\\(-a\\\\nabla u\\\\) is the electric current in a medium and the coefficient \\\\(a\\\\) is the conductivity of the medium at any given point. (In this situation, the right hand side of the equation would be the electric source density and would usually be zero or consist of localized, Delta-like, functions if specific points of the domain are connected to current sources that send electrons into or out of the domain.) In many media, \\\\(a=a(\\\\mathbf x)\\\\) is indeed spatially variable because the medium is not homogeneous. For example, in electrical impedance tomography, a biomedical imaging technique, one wants to image the body's interior by sending electric currents through the body between electrodes attached to the skin; in this case, \\\\(a(\\\\mathbf x)\\\\) describes the electrical conductivity of the different parts of the human body \\u2013 so \\\\(a(\\\\mathbf x)\\\\) would be large for points \\\\(\\\\mathbf x\\\\) that lie in organs well supplied by blood (such as the heart), whereas it would be small for organs such as the lung that do not conduct electricity well (because air is a poor conductor). Similarly, if you are simulating an electronic device, \\\\(a(\\\\mathbf x)\\\\) would be large in parts of the volume occupied by conductors such as copper, gold, or aluminum; it would have intermediate values for parts of the volume occupied by semiconductors such as silicon; and it would be small in non-conducting and insulating parts of the volume (e.g., those occupied by air, or the circuit board on which the electronics are mounted).\\nIf we are describing the vertical deflection \\\\(u\\\\) of a thin membrane under a vertical force \\\\(f\\\\), then \\\\(a\\\\) would be a measure of the local stiffness of the membrane, which can be spatially variable if the membrane is made from different materials, or if the thickness of the membrane varies spatially. This is the interpretation of the equation that will allow us to interpret the images shown in the results section below.\\n\\nSince the Laplace/Poisson equation appears in so many contexts, there are of course many more uses than just the two listed above, each providing a different interpretation what a spatially variable coefficient would mean in that context.\\nWhat you should have taken away from this is that equations with spatially variable coefficients in the differential operator are quite common, and indeed quite useful in describing the world around us. As a consequence, we should be able to reflect such cases in the numerical methods we use. It turns out that it is not entirely obvious how to deal with such spatially variable coefficients in finite difference methods (though it is also not too complicated to come with ways to do that systematically). But we are using finite element methods, and for these it is entirely trivial to incorporate such coefficients: You just do what you always do, namely multiply by a test function, then integrate by parts. This yields the weak form, which here reads as follows:      \\n\\\\begin{align*}\\n  \\\\int_\\\\Omega a(\\\\mathbf x) \\\\nabla \\\\varphi(\\\\mathbf x) \\\\cdot\\n            \\\\nabla u(\\\\mathbf x) \\\\; dx\\n  &=\\n  \\\\int_\\\\Omega \\\\varphi(\\\\mathbf x) f(\\\\mathbf x) \\\\; dx \\\\qquad \\\\qquad \\\\forall \\\\varphi.\\n\\\\end{align*}\\n\\n For this program here, we will specifically use \\\\(f(\\\\mathbf x)=1\\\\). In our usual short-hand notation, the equation's weak form can then be written as   \\n\\\\begin{align*}\\n  (a \\\\nabla \\\\varphi, \\\\nabla u) &= (\\\\varphi, 1) \\\\qquad \\\\qquad \\\\forall \\\\varphi.\\n\\\\end{align*}\\n\\nAs you will recall from step-3 and step-4, the weak formulation is implemented in the assemble_system function, substituting integrals by quadrature. Indeed, what you will find in this program is that as before, the implementation follows immediately from the statement of the weak form above.\\nSupport for debugging: Assertions \\nFinite element programs tend to be complex pieces of software, so debugging is an important aspect of developing finite element codes. deal.II supports safe programming by using assertions that check the validity of parameters and internal states in a \\\"debug\\\" mode, but are removed in \\\"optimized\\\" (or \\\"release\\\") mode. (See also video lecture 18.) This program will show you how to write such assertions.\\nThe usefulness of assertions is that they allow you to put whatever you think must be true into actual code, and let the computer check that you are right. To give an example, here is the function that adds one vector to another: template <typename Number>\\nVector<Number> &\\nVector<Number>::operator+=(const Vector<Number> &v)\\n{\\n Assert(size() != 0, ExcEmptyObject());\\n Assert(size() == v.size(), ExcDimensionMismatch(size(), v.size()));\\n \\n  ... do the actual addition of elements ...\\n \\n return *this;\\n}\\nVectorDefinition vector.h:120\\nVector::sizevirtual size_type size() const override\\nVector::operator+=Vector< Number > & operator+=(const Vector< Number > &V)\\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\n The point here is that it only makes sense to add two vectors together if (i) the vectors have nonzero size, and (ii) have the same size. It does not make sense to add a vector of size 10 to a vector of size 20. That is an obvious statement, and one could argue that if anyone tried to do so anyway, they get what they deserve \\u2013 most often this may be wrong results, overwritten memory, or other terrible things that are difficult to debug. It is much better to check such conditions \\u2013 i.e., to check the assumptions a function such as the one above makes on function arguments or the internal state of the program it is working on \\u2013 because if you check, you can do two things: (i) If an assumption is violated, you can abort the program at the first moment where you know that something is going wrong, rather than letting the program later spend quality hours with a debugger trying to figure out why the program is producing wrong results; (ii) if an assumption is violated, you can print information that explicitly shows what the violated assumption is, where in the program this happened, and how you got to this place (i.e., it can show you the stack trace).\\nThe two Assert statements above do exactly this: The first argument to Assert is the condition whose truth we want to ensure. The second argument is an object that contains information (and can print this information) used if the condition is not true. The program will show a real-world case where assertions are useful in user code.\\n The commented program\\n Include files\\nAgain, the first few include files are already known, so we won't comment on them:\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/solver_cg.h>\\n\\u00a0 #include <deal.II/lac/precondition.h>\\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 #include <deal.II/numerics/matrix_tools.h>\\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 \\nThis one is new. We want to read a triangulation from disk, and the class which does this is declared in the following file :\\n\\u00a0 #include <deal.II/grid/grid_in.h>\\n\\u00a0 \\nWe will use a circular domain, and the object describing the boundary of it comes from this file :\\n\\u00a0 #include <deal.II/grid/manifold_lib.h>\\n\\u00a0 \\nThis is C++ ...\\n\\u00a0 #include <fstream>\\n\\u00a0 #include <iostream>\\n\\u00a0 \\n\\u00a0 \\nFinally, this has been discussed in previous tutorial programs before:\\n\\u00a0 using namespace dealii;\\n\\u00a0 \\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n The Step5 class template\\nThe main class is mostly as in the previous example. The most visible change is that the function make_grid has been removed, since creating the grid is now done in the run function and the rest of its functionality is now in setup_system. Apart from this, everything is as before.\\n\\u00a0 template <int dim>\\n\\u00a0 class Step5\\n\\u00a0 {\\n\\u00a0 public:\\n\\u00a0   Step5();\\n\\u00a0   void run();\\n\\u00a0 \\n\\u00a0 private:\\n\\u00a0   void setup_system();\\n\\u00a0   void assemble_system();\\n\\u00a0   void solve();\\n\\u00a0   void output_results(const unsigned int cycle) const;\\n\\u00a0 \\n\\u00a0   Triangulation<dim> triangulation;\\n\\u00a0   const FE_Q<dim>    fe;\\n\\u00a0   DoFHandler<dim>    dof_handler;\\n\\u00a0 \\n\\u00a0   SparsityPattern      sparsity_pattern;\\n\\u00a0   SparseMatrix<double> system_matrix;\\n\\u00a0 \\n\\u00a0   Vector<double> solution;\\n\\u00a0   Vector<double> system_rhs;\\n\\u00a0 };\\n\\u00a0 \\n\\u00a0 \\nDoFHandlerDefinition dof_handler.h:317\\nFE_QDefinition fe_q.h:554\\nSparseMatrixDefinition sparse_matrix.h:520\\nSparsityPatternDefinition sparsity_pattern.h:343\\nTriangulationDefinition tria.h:1323\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\n Working with nonconstant coefficients\\nIn step-4, we showed how to use non-constant boundary values and right hand side. In this example, we want to use a variable coefficient in the elliptic operator instead. Since we have a function which just depends on the point in space we can do things a bit more simply and use a plain function instead of inheriting from Function.\\nThis is the implementation of the coefficient function for a single point. We let it return 20 if the distance to the origin is less than 0.5, and 1 otherwise.\\n\\u00a0 template <int dim>\\n\\u00a0 double coefficient(const Point<dim> &p)\\n\\u00a0 {\\n\\u00a0   if (p.square() < 0.5 * 0.5)\\n\\u00a0     return 20;\\n\\u00a0   else\\n\\u00a0     return 1;\\n\\u00a0 }\\n\\u00a0 \\nPointDefinition point.h:111\\nPoint::squareconstexpr numbers::NumberTraits< Number >::real_type square() const\\n The Step5 class implementation\\n Step5::Step5\\nThis function is as before.\\n\\u00a0 template <int dim>\\n\\u00a0 Step5<dim>::Step5()\\n\\u00a0   : fe(/* polynomial degree = */ 1)\\n\\u00a0   , dof_handler(triangulation)\\n\\u00a0 {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n Step5::setup_system\\nThis is the function make_grid from the previous example, minus the generation of the grid. Everything else is unchanged:\\n\\u00a0 template <int dim>\\n\\u00a0 void Step5<dim>::setup_system()\\n\\u00a0 {\\n\\u00a0   dof_handler.distribute_dofs(fe);\\n\\u00a0 \\n\\u00a0   std::cout << \\\"   Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n\\u00a0             << std::endl;\\n\\u00a0 \\n\\u00a0   DynamicSparsityPattern dsp(dof_handler.n_dofs());\\n\\u00a0   DoFTools::make_sparsity_pattern(dof_handler, dsp);\\n\\u00a0   sparsity_pattern.copy_from(dsp);\\n\\u00a0 \\n\\u00a0   system_matrix.reinit(sparsity_pattern);\\n\\u00a0 \\n\\u00a0   solution.reinit(dof_handler.n_dofs());\\n\\u00a0   system_rhs.reinit(dof_handler.n_dofs());\\n\\u00a0 }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\n Step5::assemble_system\\nAs in the previous examples, this function is not changed much with regard to its functionality, but there are still some optimizations which we will show. For this, it is important to note that if efficient solvers are used (such as the preconditioned CG method), assembling the matrix and right hand side can take a comparable time, and you should think about using one or two optimizations at some places.\\nThe first parts of the function are completely unchanged from before:\\n\\u00a0 template <int dim>\\n\\u00a0 void Step5<dim>::assemble_system()\\n\\u00a0 {\\n\\u00a0   const QGauss<dim> quadrature_formula(fe.degree + 1);\\n\\u00a0 \\n\\u00a0   FEValues<dim> fe_values(fe,\\n\\u00a0                           quadrature_formula,\\n\\u00a0                           update_values | update_gradients |\\n\\u00a0                             update_quadrature_points | update_JxW_values);\\n\\u00a0 \\n\\u00a0   const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n\\u00a0 \\n\\u00a0   FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0   Vector<double>     cell_rhs(dofs_per_cell);\\n\\u00a0 \\n\\u00a0   std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\nFEValuesDefinition fe_values.h:63\\nFullMatrixDefinition full_matrix.h:79\\nQGaussDefinition quadrature_lib.h:40\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nNext is the typical loop over all cells to compute local contributions and then to transfer them into the global matrix and vector. The only change in this part, compared to step-4, is that we will use the coefficient() function defined above to compute the coefficient value at each quadrature point.\\n\\u00a0   for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0     {\\n\\u00a0       fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0       cell_matrix = 0.;\\n\\u00a0       cell_rhs    = 0.;\\n\\u00a0 \\n\\u00a0       for (const unsigned int q_index : fe_values.quadrature_point_indices())\\n\\u00a0         {\\n\\u00a0           const double current_coefficient =\\n\\u00a0             coefficient(fe_values.quadrature_point(q_index));\\n\\u00a0           for (const unsigned int i : fe_values.dof_indices())\\n\\u00a0             {\\n\\u00a0               for (const unsigned int j : fe_values.dof_indices())\\n\\u00a0                 cell_matrix(i, j) +=\\n\\u00a0                   (current_coefficient *              // a(x_q)\\n\\u00a0                    fe_values.shape_grad(i, q_index) * // grad phi_i(x_q)\\n\\u00a0                    fe_values.shape_grad(j, q_index) * // grad phi_j(x_q)\\n\\u00a0                    fe_values.JxW(q_index));           // dx\\n\\u00a0 \\n\\u00a0               cell_rhs(i) += (fe_values.shape_value(i, q_index) * // phi_i(x_q)\\n\\u00a0                               1.0 *                               // f(x_q)\\n\\u00a0                               fe_values.JxW(q_index));            // dx\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0       cell->get_dof_indices(local_dof_indices);\\n\\u00a0       for (const unsigned int i : fe_values.dof_indices())\\n\\u00a0         {\\n\\u00a0           for (const unsigned int j : fe_values.dof_indices())\\n\\u00a0             system_matrix.add(local_dof_indices[i],\\n\\u00a0                               local_dof_indices[j],\\n\\u00a0                               cell_matrix(i, j));\\n\\u00a0 \\n\\u00a0           system_rhs(local_dof_indices[i]) += cell_rhs(i);\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\nint\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\nWith the matrix so built, we use zero boundary values again:\\n\\u00a0   std::map<types::global_dof_index, double> boundary_values;\\n\\u00a0   VectorTools::interpolate_boundary_values(dof_handler,\\n\\u00a0                                            types::boundary_id(0),\\n\\u00a0                                            Functions::ZeroFunction<dim>(),\\n\\u00a0                                            boundary_values);\\n\\u00a0   MatrixTools::apply_boundary_values(boundary_values,\\n\\u00a0                                      system_matrix,\\n\\u00a0                                      solution,\\n\\u00a0                                      system_rhs);\\n\\u00a0 }\\n\\u00a0 \\n\\u00a0 \\nFunctions::ZeroFunctionDefinition function.h:510\\nunsigned int\\nMatrixTools::apply_boundary_valuesvoid apply_boundary_values(const std::map< types::global_dof_index, number > &boundary_values, SparseMatrix< number > &matrix, Vector< number > &solution, Vector< number > &right_hand_side, const bool eliminate_columns=true)Definition matrix_tools.cc:75\\nVectorTools::interpolate_boundary_valuesvoid interpolate_boundary_values(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const std::map< types::boundary_id, const Function< spacedim, number > * > &function_map, std::map< types::global_dof_index, number > &boundary_values, const ComponentMask &component_mask={})\\n Step5::solve\\nThe solution process again looks mostly like in the previous examples. However, we will now use a preconditioned conjugate gradient algorithm. It is not very difficult to make this change. In fact, the only thing we have to alter is that we need an object which will act as a preconditioner. We will use SSOR (symmetric successive overrelaxation), with a relaxation factor of 1.2. For this purpose, the SparseMatrix class has a function which does one SSOR step, and we need to package the address of this function together with the matrix on which it should act (which is the matrix to be inverted) and the relaxation factor into one object. The PreconditionSSOR class does this for us. (PreconditionSSOR class takes a template argument denoting the matrix type it is supposed to work on. The default value is SparseMatrix<double>, which is exactly what we need here, so we simply stick with the default and do not specify anything in the angle brackets.)\\nNote that for the present case, SSOR doesn't really perform much better than most other preconditioners (though better than no preconditioning at all). A brief comparison of different preconditioners is presented in the Results section of the next tutorial program, step-6.\\nWith this, the rest of the function is trivial: instead of the PreconditionIdentity object we have created before, we now use the preconditioner we have declared, and the CG solver will do the rest for us:\\n\\u00a0 template <int dim>\\n\\u00a0 void Step5<dim>::solve()\\n\\u00a0 {\\n\\u00a0   SolverControl            solver_control(1000, 1e-6 * system_rhs.l2_norm());\\n\\u00a0   SolverCG<Vector<double>> solver(solver_control);\\n\\u00a0 \\n\\u00a0   PreconditionSSOR<SparseMatrix<double>> preconditioner;\\n\\u00a0   preconditioner.initialize(system_matrix, 1.2);\\n\\u00a0 \\n\\u00a0   solver.solve(system_matrix, solution, system_rhs, preconditioner);\\n\\u00a0 \\n\\u00a0   std::cout << \\\"   \\\" << solver_control.last_step()\\n\\u00a0             << \\\" CG iterations needed to obtain convergence.\\\" << std::endl;\\n\\u00a0 }\\n\\u00a0 \\n\\u00a0 \\nPreconditionSSORDefinition precondition.h:1778\\nPreconditionSSOR::initializevoid initialize(const MatrixType &A, const AdditionalData &parameters=AdditionalData())\\nSolverCGDefinition solver_cg.h:179\\nSolverControlDefinition solver_control.h:67\\n Step5::output_results and setting output flags\\nWriting output to a file is mostly the same as for the previous tutorial. The only difference is that we now need to construct a different filename for each refinement cycle.\\nThe function writes the output in VTU format, a variation of the VTK format that requires less disk space because it compresses the data. Of course, there are many other formats supported by the DataOut class if you desire to use a program for visualization that doesn't understand VTK or VTU.\\n\\u00a0 template <int dim>\\n\\u00a0 void Step5<dim>::output_results(const unsigned int cycle) const\\n\\u00a0 {\\n\\u00a0   DataOut<dim> data_out;\\n\\u00a0 \\n\\u00a0   data_out.attach_dof_handler(dof_handler);\\n\\u00a0   data_out.add_data_vector(solution, \\\"solution\\\");\\n\\u00a0 \\n\\u00a0   data_out.build_patches();\\n\\u00a0 \\n\\u00a0   std::ofstream output(\\\"solution-\\\" + std::to_string(cycle) + \\\".vtu\\\");\\n\\u00a0   data_out.write_vtu(output);\\n\\u00a0 }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\n Step5::run\\nThe second to last thing in this program is the definition of the run() function. In contrast to the previous programs, we will compute on a sequence of meshes that after each iteration is globally refined. The function therefore consists of a loop over 6 cycles. In each cycle, we first print the cycle number, and then have to decide what to do with the mesh. If this is not the first cycle, we simply refine the existing mesh once globally. Before running through these cycles, however, we have to generate a mesh:\\nIn previous examples, we have already used some of the functions from the GridGenerator class. Here we would like to read a grid from a file where the cells are stored and which may originate from someone else, or may be the product of a mesh generator tool.\\nIn order to read a grid from a file, we generate an object of data type GridIn and associate the triangulation to it (i.e. we tell it to fill our triangulation object when we ask it to read the file). Then we open the respective file and initialize the triangulation with the data in the file :\\n\\u00a0 template <int dim>\\n\\u00a0 void Step5<dim>::run()\\n\\u00a0 {\\n\\u00a0   GridIn<dim> grid_in;\\n\\u00a0   grid_in.attach_triangulation(triangulation);\\n\\u00a0   std::ifstream input_file(\\\"circle-grid.inp\\\");\\nGridInDefinition grid_in.h:311\\nGridIn::attach_triangulationvoid attach_triangulation(Triangulation< dim, spacedim > &tria)Definition grid_in.cc:153\\nWe would now like to read the file. However, the input file is only for a two-dimensional triangulation, while this function is a template for arbitrary dimension. Since this is only a demonstration program, we will not use different input files for the different dimensions, but rather quickly kill the whole program if we are not in 2d. Of course, since the main function below assumes that we are working in two dimensions we could skip this check, in this version of the program, without any ill effects.\\nIt turns out that perhaps 90 per cent of programming errors are invalid function parameters such as invalid array sizes, etc., so we use assertions heavily throughout deal.II to catch such mistakes. For this, the Assert macro is a good choice, since it makes sure that the condition which is given as first argument is valid, and if not throws an exception (its second argument) which will usually terminate the program giving information where the error occurred and what the reason was. (A longer discussion of what exactly the Assert macro does can be found in the exception documentation topic.) This generally reduces the time to find programming errors dramatically and we have found assertions an invaluable means to program fast.\\nOn the other hand, all these checks (there are over 10,000 of them in the library at present) should not slow down the program too much if you want to do large computations. To this end, the Assert macro is only used in debug mode and expands to nothing if in optimized mode. Therefore, while you test your program on small problems and debug it, the assertions will tell you where the problems are. Once your program is stable, you can switch off debugging and the program will run your real computations without the assertions and at maximum speed. More precisely: turning off all the checks in the library (which prevent you from calling functions with wrong arguments, walking off of arrays, etc.) by compiling your program in optimized mode usually makes things run about four times faster. Even though optimized programs are more performant, you should always develop in debug mode since it allows the library to find lots of common programming errors automatically. For those who want to try: The way to switch from debug mode to optimized mode is to recompile your program with the command make release. The output of the make program should now indicate to you that the program is now compiled in optimized mode, and it will later also be linked to libraries that have been compiled for optimized mode. In order to switch back to debug mode, simply recompile with the command make debug.\\n\\u00a0   Assert(dim == 2, ExcNotImplemented());\\nExcNotImplemented is a globally defined exception, which may be thrown whenever a piece of code has simply not been implemented for a case other than the condition checked in the assertion. Here, it would not be difficult to simply implement reading a different mesh file that contains a description of a 1d or 3d geometry, but this has not (yet) been implemented and so the exception is appropriate.\\nUsually, one would like to use more specific exception classes, and particular in this case one would of course try to do something else if dim is not equal to two, e.g. create a grid using library functions. Aborting a program is usually not a good idea and assertions should really only be used for exceptional cases which should not occur, but might due to stupidity of the programmer, user, or someone else.\\nSo if we got past the assertion, we know that dim==2, and we can now actually read the grid. It is in UCD (unstructured cell data) format (though the convention is to use the suffix inp for UCD files):\\n\\u00a0   grid_in.read_ucd(input_file);\\nIf you like to use another input format, you have to use one of the other grid_in.read_xxx function. (See the documentation of the GridIn class to find out what input formats are presently supported.)\\nThe grid in the file describes a circle. Therefore we have to use a manifold object which tells the triangulation where to put new points on the boundary when the grid is refined. Unlike step-1, since GridIn does not know that the domain has a circular boundary (unlike GridGenerator::hyper_shell) we have to explicitly attach a manifold to the boundary after creating the triangulation to get the correct result when we refine the mesh.\\n\\u00a0   const SphericalManifold<dim> boundary;\\n\\u00a0   triangulation.set_all_manifold_ids_on_boundary(0);\\n\\u00a0   triangulation.set_manifold(0, boundary);\\n\\u00a0 \\n\\u00a0   for (unsigned int cycle = 0; cycle < 6; ++cycle)\\n\\u00a0     {\\n\\u00a0       std::cout << \\\"Cycle \\\" << cycle << ':' << std::endl;\\n\\u00a0 \\n\\u00a0       if (cycle != 0)\\n\\u00a0         triangulation.refine_global(1);\\n\\u00a0 \\nSphericalManifoldDefinition manifold_lib.h:263\\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nTriangulation::set_all_manifold_ids_on_boundaryvoid set_all_manifold_ids_on_boundary(const types::manifold_id number)\\nTriangulation::set_manifoldvoid set_manifold(const types::manifold_id number, const Manifold< dim, spacedim > &manifold_object)\\nNow that we have a mesh for sure, we write some output and do all the things that we have already seen in the previous examples.\\n\\u00a0       std::cout << \\\"   Number of active cells: \\\" \\n\\u00a0                 << triangulation.n_active_cells() \\n\\u00a0                 << std::endl                      \\n\\u00a0                 << \\\"   Total number of cells: \\\" \\n\\u00a0                 << triangulation.n_cells()        \\n\\u00a0                 << std::endl;\\n\\u00a0 \\n\\u00a0       setup_system();\\n\\u00a0       assemble_system();\\n\\u00a0       solve();\\n\\u00a0       output_results(cycle);\\n\\u00a0     }\\n\\u00a0 }\\n\\u00a0 \\n\\u00a0 \\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nTriangulation::n_cellsunsigned int n_cells() const\\n The main function\\nThe main function looks mostly like the one in the previous example, so we won't comment on it further:\\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   Step5<2> laplace_problem_2d;\\n\\u00a0   laplace_problem_2d.run();\\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nHere is the console output: Cycle 0:\\n   Number of active cells: 20\\n   Total number of cells: 20\\n   Number of degrees of freedom: 25\\n   8 CG iterations needed to obtain convergence.\\nCycle 1:\\n   Number of active cells: 80\\n   Total number of cells: 100\\n   Number of degrees of freedom: 89\\n   12 CG iterations needed to obtain convergence.\\nCycle 2:\\n   Number of active cells: 320\\n   Total number of cells: 420\\n   Number of degrees of freedom: 337\\n   21 CG iterations needed to obtain convergence.\\nCycle 3:\\n   Number of active cells: 1280\\n   Total number of cells: 1700\\n   Number of degrees of freedom: 1313\\n   38 CG iterations needed to obtain convergence.\\nCycle 4:\\n   Number of active cells: 5120\\n   Total number of cells: 6820\\n   Number of degrees of freedom: 5185\\n   70 CG iterations needed to obtain convergence.\\nCycle 5:\\n   Number of active cells: 20480\\n   Total number of cells: 27300\\n   Number of degrees of freedom: 20609\\n   136 CG iterations needed to obtain convergence.\\nIn each cycle, the number of cells quadruples and the number of CG iterations roughly doubles. Also, in each cycle, the program writes one output graphic file in VTU format. They are depicted in the following:\\n\\n\\n  \\n\\n  \\n\\n  \\n\\nDue to the variable coefficient (the curvature there is reduced by the same factor by which the coefficient is increased), the top region of the solution is flattened. The gradient of the solution is discontinuous along the interface, although this is not very clearly visible in the pictures above. We will look at this in more detail in the next example.\\nThe pictures also show that the solution computed by this program is actually pretty wrong on a very coarse mesh (its magnitude is wrong). That's because no numerical method guarantees that the solution on a coarse mesh is particularly accurate \\u2013 but we know that the solution converges to the exact solution, and indeed you can see how the solutions from one mesh to the next seem to not change very much any more at the end.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 1999 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n */\\n \\n \\n \\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/function.h>\\n#include <deal.II/lac/vector.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/precondition.h>\\n#include <deal.II/grid/tria.h>\\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_tools.h>\\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_values.h>\\n#include <deal.II/numerics/vector_tools.h>\\n#include <deal.II/numerics/matrix_tools.h>\\n#include <deal.II/numerics/data_out.h>\\n \\n#include <deal.II/grid/grid_in.h>\\n \\n#include <deal.II/grid/manifold_lib.h>\\n \\n#include <fstream>\\n#include <iostream>\\n \\n \\nusing namespace dealii;\\n \\n \\n \\ntemplate <int dim>\\nclass Step5\\n{\\npublic:\\n  Step5();\\n void run();\\n \\nprivate:\\n void setup_system();\\n void assemble_system();\\n void solve();\\n void output_results(const unsigned int cycle) const;\\n \\n Triangulation<dim> triangulation;\\n const FE_Q<dim>    fe;\\n DoFHandler<dim>    dof_handler;\\n \\n SparsityPattern      sparsity_pattern;\\n SparseMatrix<double> system_matrix;\\n \\n Vector<double> solution;\\n Vector<double> system_rhs;\\n};\\n \\n \\n \\n \\ntemplate <int dim>\\ndouble coefficient(const Point<dim> &p)\\n{\\n if (p.square() < 0.5 * 0.5)\\n return 20;\\n else\\n return 1;\\n}\\n \\n \\n \\ntemplate <int dim>\\nStep5<dim>::Step5()\\n  : fe(/* polynomial degree = */ 1)\\n  , dof_handler(triangulation)\\n{}\\n \\n \\n \\n \\ntemplate <int dim>\\nvoid Step5<dim>::setup_system()\\n{\\n  dof_handler.distribute_dofs(fe);\\n \\n  std::cout << \\\"   Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n            << std::endl;\\n \\n DynamicSparsityPattern dsp(dof_handler.n_dofs());\\n DoFTools::make_sparsity_pattern(dof_handler, dsp);\\n  sparsity_pattern.copy_from(dsp);\\n \\n  system_matrix.reinit(sparsity_pattern);\\n \\n  solution.reinit(dof_handler.n_dofs());\\n  system_rhs.reinit(dof_handler.n_dofs());\\n}\\n \\n \\n \\n \\ntemplate <int dim>\\nvoid Step5<dim>::assemble_system()\\n{\\n const QGauss<dim> quadrature_formula(fe.degree + 1);\\n \\n FEValues<dim> fe_values(fe,\\n                          quadrature_formula,\\n update_values | update_gradients |\\n update_quadrature_points | update_JxW_values);\\n \\n const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n \\n FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n Vector<double>     cell_rhs(dofs_per_cell);\\n \\n  std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n    {\\n      fe_values.reinit(cell);\\n \\n cell_matrix = 0.;\\n      cell_rhs    = 0.;\\n \\n for (const unsigned int q_index : fe_values.quadrature_point_indices())\\n        {\\n const double current_coefficient =\\n            coefficient(fe_values.quadrature_point(q_index));\\n for (const unsigned int i : fe_values.dof_indices())\\n            {\\n for (const unsigned int j : fe_values.dof_indices())\\n cell_matrix(i, j) +=\\n                  (current_coefficient *              // a(x_q)\\n                   fe_values.shape_grad(i, q_index) * // grad phi_i(x_q)\\n                   fe_values.shape_grad(j, q_index) * // grad phi_j(x_q)\\n                   fe_values.JxW(q_index));           // dx\\n \\n              cell_rhs(i) += (fe_values.shape_value(i, q_index) * // phi_i(x_q)\\n                              1.0 *                               // f(x_q)\\n                              fe_values.JxW(q_index));            // dx\\n            }\\n        }\\n \\n \\n      cell->get_dof_indices(local_dof_indices);\\n for (const unsigned int i : fe_values.dof_indices())\\n        {\\n for (const unsigned int j : fe_values.dof_indices())\\n            system_matrix.add(local_dof_indices[i],\\n                              local_dof_indices[j],\\n cell_matrix(i, j));\\n \\n          system_rhs(local_dof_indices[i]) += cell_rhs(i);\\n        }\\n    }\\n \\n  std::map<types::global_dof_index, double> boundary_values;\\n VectorTools::interpolate_boundary_values(dof_handler,\\n types::boundary_id(0),\\n Functions::ZeroFunction<dim>(),\\n                                           boundary_values);\\n MatrixTools::apply_boundary_values(boundary_values,\\n                                     system_matrix,\\n                                     solution,\\n                                     system_rhs);\\n}\\n \\n \\n \\ntemplate <int dim>\\nvoid Step5<dim>::solve()\\n{\\n SolverControl            solver_control(1000, 1e-6 * system_rhs.l2_norm());\\n SolverCG<Vector<double>> solver(solver_control);\\n \\n PreconditionSSOR<SparseMatrix<double>> preconditioner;\\n  preconditioner.initialize(system_matrix, 1.2);\\n \\n  solver.solve(system_matrix, solution, system_rhs, preconditioner);\\n \\n  std::cout << \\\"   \\\" << solver_control.last_step()\\n            << \\\" CG iterations needed to obtain convergence.\\\" << std::endl;\\n}\\n \\n \\n \\ntemplate <int dim>\\nvoid Step5<dim>::output_results(const unsigned int cycle) const\\n{\\n DataOut<dim> data_out;\\n \\n  data_out.attach_dof_handler(dof_handler);\\n  data_out.add_data_vector(solution, \\\"solution\\\");\\n \\n  data_out.build_patches();\\n \\n  std::ofstream output(\\\"solution-\\\" + std::to_string(cycle) + \\\".vtu\\\");\\n  data_out.write_vtu(output);\\n}\\n \\n \\n \\n \\n \\ntemplate <int dim>\\nvoid Step5<dim>::run()\\n{\\n GridIn<dim> grid_in;\\n  grid_in.attach_triangulation(triangulation);\\n  std::ifstream input_file(\\\"circle-grid.inp\\\");\\n Assert(dim == 2, ExcNotImplemented());\\n \\n  grid_in.read_ucd(input_file);\\n \\n const SphericalManifold<dim> boundary;\\n triangulation.set_all_manifold_ids_on_boundary(0);\\n triangulation.set_manifold(0, boundary);\\n \\n for (unsigned int cycle = 0; cycle < 6; ++cycle)\\n    {\\n      std::cout << \\\"Cycle \\\" << cycle << ':' << std::endl;\\n \\n if (cycle != 0)\\n triangulation.refine_global(1);\\n \\n      std::cout << \\\"   Number of active cells: \\\" \\n                << triangulation.n_active_cells() \\n                << std::endl                      \\n                << \\\"   Total number of cells: \\\" \\n                << triangulation.n_cells()        \\n                << std::endl;\\n \\n      setup_system();\\n      assemble_system();\\n      solve();\\n      output_results(cycle);\\n    }\\n}\\n \\n \\n \\nint main()\\n{\\n  Step5<2> laplace_problem_2d;\\n  laplace_problem_2d.run();\\n return 0;\\n}\\nDataOutInterface::write_vtuvoid write_vtu(std::ostream &out) constDefinition data_out_base.cc:7692\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nGridIn::read_ucdvoid read_ucd(std::istream &in, const bool apply_all_indicators_to_manifolds=false)Definition grid_in.cc:914\\ndof_handler.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nfe_values.h\\nfe_q.h\\nfull_matrix.h\\nfunction.h\\nmanifold_lib.h\\ntria.h\\ngrid_in.h\\nmatrix_tools.h\\ndata_out.h\\nprecondition.h\\nquadrature_lib.h\\nsolver_cg.h\\nsparse_matrix.h\\nvector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"