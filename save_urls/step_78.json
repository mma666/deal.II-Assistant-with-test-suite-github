"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_78.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-78 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-78 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-78 tutorial program\\n\\n\\nThis tutorial depends on step-26.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nParticularities of the equation system\\nScheme for the numerical solution\\nTest Case\\n\\n The commented program\\n\\nInclude files\\nSolution Class\\nEquation Data\\nThe BlackScholes Class\\nThe BlackScholes Implementation\\n\\nBlackScholes::setup_system\\nBlackScholes::solve_time_step\\nBlackScholes::add_results_for_output\\nBlackScholes::refine_grid\\nBlackScholes::process_solution\\nBlackScholes::write_convergence_table \\nBlackScholes::run\\n\\nThe main Function\\n\\n\\n Results\\n\\n\\n The plain program\\n   \\n Introduction\\nThe Black-Scholes equation is a partial differential equation that falls a bit out of the ordinary scheme. It describes what the fair price of a \\\"European\\ncall\\\" stock option is. Without going into too much detail, a stock \\\"option\\\" is a contract one can buy from a bank that allows me, but not requires me, to buy a specific stock at a fixed price \\\\(K\\\\) at a fixed future time \\\\(T\\\\) in the future. The question one would then want to answer as a buyer of such an option is \\\"How much do I think such a contract is worth?\\\", or as the seller \\\"How much do I need to charge for this contract?\\\", both as a function of the time \\\\(t<T\\\\) before the contract is up at time \\\\(T\\\\) and as a function of the stock price \\\\(S\\\\). Fischer Black and Myron Scholes derived a partial differential equation for the fair price \\\\(V(S,t)\\\\) for such options under the assumption that stock prices exhibit random price fluctuations with a given level of \\\"volatility\\\" plus a background exponential price increase (which one can think of as the inflation rate that simply devalues all money over time). For their work, Black and Scholes received the Nobel Prize in Economic Sciences in 1997, making this the first tutorial program dealing with a problem for which someone has gotten a Nobel Prize [31].\\nThe equation reads as follows:               \\n\\\\begin{align*}\\n    &\\\\frac{\\\\partial V}{\\\\partial t} + \\\\frac{\\\\sigma^2S^2}{2} \\\\\\n    \\\\frac{\\\\partial^2 V}{\\\\partial S^2} + \\\\\\n    rS\\\\frac{\\\\partial V}{\\\\partial S} - rV = 0, \\\\\\n    \\\\quad\\\\quad &&\\\\forall S\\\\in \\\\Omega, t \\\\in (0,T)\\n    \\\\\\\\\\n    &V(0,t) = 0, \\\\\\n    &&\\\\forall t \\\\in (0,T)\\n    \\\\\\\\\\n    &V(S,t) \\\\rightarrow S, \\\\\\n    && \\\\text{as } S \\\\rightarrow \\\\infty, \\\\forall t \\\\in (0,T)\\n    \\\\\\\\\\n    &V(S,T) = \\\\max(S-K,0) \\\\\\n    &&\\\\forall S \\\\in \\\\Omega\\n\\\\end{align*}\\n\\n where      \\n\\\\begin{align*}\\n    V(S,t): && \\\\text{Value of call option at time t and asset price S} \\\\\\\\\\n    \\\\sigma: && \\\\text{Volatility of the underlying asset} \\\\\\\\\\n    r: && \\\\text{Risk free interest rate} \\\\\\\\\\n    K : && \\\\text{Strike price for purchasing asset}\\n\\\\end{align*}\\n\\nThe way we should interpret this equation is that it is a time-dependent partial differential equation of one \\\"space\\\" variable \\\\(S\\\\) as the price of the stock, and \\\\(V(S,t)\\\\) is the price of the option at time \\\\(t\\\\) if the stock price at that time were \\\\(S\\\\).\\nParticularities of the equation system\\nThere are a number of oddities in this equation that are worth discussing before moving on to its numerical solution. First, the \\\"spatial\\\" domain \\\\(\\\\Omega\\\\subset\\\\mathbb{R}\\\\) is unbounded, and thus \\\\(S\\\\) can be unbounded in value. This is because there may be a practical upper bound for stock prices, but not a conceptual one. The boundary conditions \\\\(V(S,t)\\\\rightarrow S\\\\) as \\\\(S\\\\rightarrow \\\\infty\\\\) can then be interpreted as follows: What is the value of an option that allows me to buy a stock at price \\\\(K\\\\) if the stock price (today or at time \\\\(t=T\\\\)) is \\\\(S\\\\gg K\\\\)? One would expect that it is \\\\(V\\\\approx S-K\\\\) plus some adjustment for inflation, or, if we really truly consider huge values of \\\\(S\\\\), we can neglect \\\\(K\\\\) and arrive at the statement that the boundary values at the infinite boundary should be of the form \\\\(V\\\\rightarrow S\\\\) as stated above.\\nIn practice, for us to use a finite element method to solve this, we are going to need to bound \\\\(\\\\Omega\\\\). Since this equation describes prices, and it doesn't make sense to talk about prices being negative, we will set the lower bound of \\\\(\\\\Omega\\\\) to be 0. Then, for an upper bound, we will choose a very large number, one that \\\\(S\\\\) is not very likely to ever get to. We will call this \\\\(S_\\\\text{max}\\\\). So, \\\\(\\\\Omega=[0,S_\\\\text{max}]\\\\).\\nSecond, after truncating the domain, we need to ask what boundary values we should pose at this now finite boundary. To take care of this, we use \\\"put-call\\\" parity [197]. A \\\"pull option\\\" is one in which we are allowed, but not required, to sell a stock at price \\\\(K\\\\) to someone at a future time \\\\(T\\\\). This says   \\n\\\\begin{align*}\\n    V(S,t)+Ke^{-r(T-t)}=P(S,t)+S\\n\\\\end{align*}\\n\\n where \\\\(V(S,t)\\\\) is the value of the call option, and \\\\(P(S,t)\\\\) is the value of the put option. Since we expect \\\\(P(S,t) \\\\rightarrow 0\\\\) as \\\\(S \\\\rightarrow \\\\infty\\\\), this says   \\n\\\\begin{align*}\\n    V(S,t) \\\\rightarrow S-Ke^{-r(T-t)},\\n\\\\end{align*}\\n\\n and we can use this as a reasonable boundary condition at our finite point \\\\(S_\\\\text{max}\\\\).\\nThe second complication of the Block-Scholes equation is that we are given a final condition, and not an initial condition. This is because we know what the option is worth at time \\\\(t=T\\\\): If the stock price at \\\\(T\\\\) is \\\\(S<K\\\\), then we have no incentive to use our option of buying a price \\\\(K\\\\) because we can buy that stock for cheaper on the open market. So \\\\(V(S,T)=0\\\\) for \\\\(S<K\\\\). On the other hand, if at time \\\\(T\\\\) we have \\\\(S>K\\\\), then we can buy the stock at price \\\\(K\\\\) via the option and immediately sell it again on the market for price \\\\(S\\\\), giving me a profit of \\\\(S-K\\\\). In other words, \\\\(V(S,T)=S-K\\\\) for \\\\(S>K\\\\). So, we only know values for \\\\(V\\\\) at the end time but not the initial time \\u2013 in fact, finding out what a fair price at the current time (conventionally taken to be \\\\(t=0\\\\)) is what solving these equations is all about.\\nThis means that this is not an equation that is posed going forward in time, but in fact going backward in time. Thus it makes sense to solve this problem in reverse by making the change of variables \\\\(\\\\tau=T-t\\\\) where now \\\\(\\\\tau\\\\) denotes the time before the strike time \\\\(T\\\\).\\nWith all of this, we finally end up with the following problem:              \\n\\\\begin{align*}\\n    &-\\\\frac{\\\\partial V}{\\\\partial \\\\tau} + \\\\frac{\\\\sigma^2S^2}{2} \\\\\\n    \\\\frac{\\\\partial^2 V}{\\\\partial S^2} + rS\\\\frac{\\\\partial V}{\\\\partial S} - rV=0\\\\\\n    , \\\\quad\\\\quad &&\\\\forall S\\\\in [0,S_\\\\text{max}], \\\\tau \\\\in [0,T]\\n    \\\\\\\\\\n    &V(0,\\\\tau) = 0, \\\\\\n    &&\\\\forall \\\\tau \\\\in [0,T]\\n    \\\\\\\\\\n    &V(S_\\\\text{max},\\\\tau)=S_\\\\text{max}-Ke^{-r\\\\tau}, \\\\\\n    &&\\\\forall \\\\tau \\\\in [0,T]\\n    \\\\\\\\\\n    &V(S,0) = \\\\max(S-K,0) \\\\\\n    &&\\\\forall S \\\\in [0,S_\\\\text{max}]\\n\\\\end{align*}\\n\\nConceptually, this is an advection-diffusion-reaction problem for the variable \\\\(V\\\\): There is both a second-order derivative diffusion term, a first-order derivative advection term, and a zeroth-order reaction term. We can expect this problem to be a little bit forgiving in practice because for realistic values of the coefficients, it is diffusive dominated. But, because of the advective terms in the problem, we will have to be careful with mesh refinement and time step choice. There is also the issue that the diffusion term is written in a non-conservative form and so integration by parts is not immediately obvious. This will be discussed in the next section.\\nScheme for the numerical solution\\nWe will solve this problem using an IMEX method. In particular, we first discretize in time with the theta method and will later pick different values of theta for the advective and diffusive terms. Let \\\\(V^n(S)\\\\) approximate \\\\(V(S,\\\\tau_n)\\\\):        \\n\\\\begin{align*}\\n    0=&-\\\\frac{V^n(S)-V^{n-1}(S)}{k_n} \\\\\\\\\\n    &+\\\\frac{\\\\sigma^2S^2}{2}\\\\left[(1-\\\\theta)\\\\frac{d^2V^{n-1}(S)}{dS^2} + \\\\\\n    \\\\theta \\\\frac{d^2V^{n}(S)}{dS^2}\\\\right] \\\\\\\\\\n    &+rS\\\\left[(1-\\\\theta)\\\\frac{dV^{n-1}(S)}{dS} + \\\\\\n    \\\\theta\\\\frac{dV^{n}(S)}{dS}\\\\right]  \\\\\\\\\\n    &-r\\\\left[(1-\\\\theta)V^{n-1}(S) + \\\\theta V^n(S)\\\\right]\\n\\\\end{align*}\\n\\n Here, \\\\(k_n=\\\\tau_n-\\\\tau_{n-1}\\\\) is the time step size. Given this time discretization, we can proceed to discretize space by multiplying with test functions and then integrating by parts. Because there are some interesting details in this due to the advective and non-advective terms in this equation, this process will be explained in detail.\\nSo, we begin by multiplying by test functions, \\\\(\\\\{\\\\phi_i(S)\\\\}_{i\\\\in\\\\mathbb{N}}\\\\):           \\n\\\\begin{align*}\\n    0=&-\\\\int_0^{S_\\\\text{max}}\\\\phi_i(S)\\\\left[V^n(S)-V^{n-1}(S)\\\\right]dS \\\\\\\\\\n    &+k_n\\\\int_0^{S_\\\\text{max}}\\\\phi_i(S)\\\\left[\\\\frac{\\\\sigma^2S^2}{2} \\\\\\n    \\\\left[(1-\\\\theta)\\\\frac{d^2V^{n-1}(S)}{dS^2} + \\\\\\n     \\\\theta \\\\frac{d^2V^{n}(S)}{dS^2}\\\\right]\\\\right]dS \\\\\\\\\\n    &+k_n\\\\int_0^{S_\\\\text{max}}\\\\phi_i(S)\\\\left[rS\\\\left[(1-\\\\theta)\\n     \\\\frac{dV^{n-1}(S)}{dS}\\\\\\n     + \\\\theta\\\\frac{dV^{n}(S)}{dS}\\\\right]\\\\right]dS  \\\\\\\\\\n    &-k_n\\\\int_0^{S_\\\\text{max}}\\\\phi_i(S)\\\\left[r\\\\left[(1-\\\\theta)V^{n-1}(S)\\\\\\n     + \\\\theta V^n(S)\\\\right]\\\\right]dS\\n\\\\end{align*}\\n\\nAs usual, (1) becomes \\\\(-\\\\textbf{M}V^n+\\\\textbf{M}V^{n-1}\\\\) and (4) becomes \\\\(k_n\\\\left[-r(1-\\\\theta)\\\\textbf{M}V^{n-1} - \\\\theta r\\\\textbf{M}V^n\\\\right]\\\\), where \\\\(\\\\textbf{M}_{i,j}=\\\\left(\\\\phi_i(S),\\\\phi_j(S)\\\\right)\\\\), and where we have taken the liberty of denoting by \\\\(V\\\\) not only the function \\\\(V(S)\\\\) but also the vector of nodal values after discretization.\\nThe interesting parts come from (2) and (3).\\nFor (2), we have:         \\n\\\\begin{align*}\\n    &k_n\\\\int_0^{S_\\\\text{max}}\\\\phi_i(S)\\\\left[\\\\frac{\\\\sigma^2S^2}{2} \\\\\\n     \\\\left[(1-\\\\theta)\\\\frac{d^2V^{n-1}(S)}{dS^2} + \\\\\\n     \\\\theta \\\\frac{d^2V^{n}(S)}{dS^2}\\\\right]\\\\right]dS \\\\\\\\\\n    &=k_n(1-\\\\theta)\\\\int_0^{S_\\\\text{max}}\\\\phi_i(S)\\\\frac{\\\\sigma^2S^2}{2} \\\\\\n     \\\\frac{d^2V^{n-1}(S)}{dS^2} \\\\\\n    +k_n\\\\theta\\\\int_0^{S_\\\\text{max}}\\\\phi_i(S)\\\\frac{\\\\sigma^2S^2}{2} \\\\\\n     \\\\frac{d^2V^{n}(S)}{dS^2}\\n\\\\end{align*}\\n\\nThere are two integrals here, that are more or less the same, with the differences being a slightly different coefficient in front of the integral, and a different time step for V. Therefore, we will outline this integral in the general case, and account for the differences at the end. So, consider the general integral, which we will solve using integration by parts:                         \\n\\\\begin{align*}\\n    &\\\\int_{0}^{S_\\\\text{max}} \\\\phi_i(S)\\\\frac{\\\\sigma^2S^2}{2}\\n        \\\\frac{d^2V^n(S)}{dS^2}dS \\\\\\\\\\n    &= \\\\phi_i(S)\\\\frac{1}{2}\\\\sigma^2S^2\\\\frac{dV^n(S)}{dS}\\\\Bigg|_0^{S_{max}} - \\\\\\n    \\\\int_0^{S_\\\\text{max}} \\\\phi_i(S)\\\\sigma^2S\\\\frac{dV^n(S)}{dS}dS - \\\\\\n    \\\\int_0^{S_\\\\text{max}} \\\\frac{d\\\\phi_i(S)}{dS}\\\\frac{1}{2}\\\\sigma^2S^2 \\\\\\n    \\\\frac{dV^n(S)}{dS}dS \\\\\\\\\\n    &= -\\\\int_0^{S_\\\\text{max}} \\\\phi_i(S)\\\\sigma^2S\\\\frac{dV^n(S)}{dS}dS - \\\\\\n    \\\\int_0^{S_\\\\text{max}} \\\\frac{d\\\\phi_i(S)}{dS}\\\\frac{1}{2}\\\\sigma^2S^2 \\\\\\n    \\\\frac{dV^n(S)}{dS}dS \\\\\\\\\\n    &= -\\\\int_0^{S_\\\\text{max}} \\\\phi_i(S)\\\\sigma^2S \\\\sum_j V_j^n\\n        \\\\frac{d\\\\phi_j(S)}{dS}dS \\\\\\n    -\\\\int_0^{S_\\\\text{max}} \\\\frac{d\\\\phi_i(S)}{dS}\\\\frac{1}{2} \\\\\\n    \\\\sigma^2S^2  \\\\sum_k V_k^n \\\\frac{d\\\\phi_k(S)}{dS}dS \\\\\\\\\\n    &= -\\\\sum_j \\\\sigma^2 \\\\int_0^{S_\\\\text{max}} \\\\phi_i(S)S\\n        \\\\frac{d\\\\phi_j(S)}{dS}dS V_j^n\\\\\\n    - \\\\sum_k \\\\frac{1}{2}\\\\sigma^2 \\\\int_0^{S_\\\\text{max}} \\\\frac{d\\\\phi_i(S)}{dS}S^2\\\\\\n    \\\\frac{d\\\\phi_k}{dS}dS V_k^n \\\\\\\\\\n    &= -\\\\sum_j \\\\sigma^2 \\\\left(\\\\phi_i(S)S, \\\\frac{d\\\\phi_j(S)}{dS}\\\\right) V_j^n \\\\\\n    - \\\\sum_k \\\\frac{1}{2}\\\\sigma^2 \\\\left(\\\\frac{d\\\\phi_i(S)}{dS}S^2,\\\\\\n    \\\\frac{d\\\\phi_k(S)}{dS}\\\\right) V_k^n \\\\\\\\\\n    &= -\\\\sigma^2\\\\textbf{B}V^n - \\\\frac{1}{2}\\\\sigma^2\\\\textbf{D}V^n, \\\\quad\\\\quad \\\\\\n    \\\\textbf{B}_{i,j} = \\\\left(\\\\phi_i(S)S, \\\\frac{d\\\\phi_j(S)}{dS}\\\\right),\\\\\\n    \\\\textbf{D}_{i,j} = \\\\left(\\\\frac{d\\\\phi_i(S)}{dS}S^2,\\\\frac{d\\\\phi_j(S)}{dS}\\\\right)\\n\\\\end{align*}\\n\\nSo, after adding in the constants and exchanging \\\\(V^n\\\\) for \\\\(V^{n-1}\\\\) where applicable, we arrive at the following for (2):          \\n\\\\begin{align*}\\n    &k_n\\\\int_0^{S_\\\\text{max}}\\\\phi_i(S)\\\\left[\\\\frac{\\\\sigma^2S^2}{2}\\n        \\\\left[(1-\\\\theta)\\\\\\n    \\\\frac{d^2V^{n-1}(S)}{dS^2} + \\\\\\n    \\\\theta \\\\frac{d^2V^{n}(S)}{dS^2}\\\\right]\\\\right]dS \\\\\\\\\\n    &= k_n\\\\left[-(1-\\\\theta)\\\\sigma^2\\\\textbf{B}V^{n-1}\\\\\\n     -(1-\\\\theta)\\\\frac{1}{2}\\\\sigma^2\\\\textbf{D}V^{n-1} \\\\\\n    -\\\\theta\\\\sigma^2\\\\textbf{B}V^{n}\\n     -\\\\theta\\\\frac{1}{2}\\\\sigma^2\\\\textbf{D}V^{n}\\\\right]\\n\\\\end{align*}\\n\\n But, because the matrix \\\\(\\\\textbf{B}\\\\) involves an advective term, we will choose \\\\(\\\\theta=0\\\\) there \\u2013 in other words, we use an explicit Euler method to treat advection. Conversely, since the matrix \\\\(\\\\textbf{D}\\\\) involves the diffusive term, we will choose \\\\(\\\\theta=1/2\\\\) there \\u2013 i.e., we treat diffusion using the second order Crank-Nicolson method.\\nSo, we arrive at the following:     \\n\\\\begin{align*}\\n    k_n\\\\left[-\\\\frac{1}{4}\\\\sigma^2\\\\textbf{D}V^{n-1} \\\\\\n    -\\\\frac{1}{4}\\\\sigma^2\\\\textbf{D}V^n \\\\\\n    - \\\\sigma^2\\\\textbf{B}V^{n-1}\\\\right]\\n\\\\end{align*}\\n\\nNow, to handle (3). For this, we will again proceed by considering the general case like above.\\n\\n\\\\begin{align*}\\n    &\\\\int_{0}^{S_\\\\text{max}} \\\\phi_i(S)rS\\\\frac{dV^n}{dS}dS \\\\\\\\\\n    &= \\\\phi_i(S)rSV^n\\\\Bigg|_0^{S_\\\\text{max}} - \\\\int_0^{S_\\\\text{max}}\\n        \\\\left[r\\\\phi_i(S) \\\\\\n    + r\\\\frac{d\\\\phi_i(S)}{dS}S \\\\right]V^ndS \\\\\\\\\\n    &= -\\\\int_0^{S_\\\\text{max}} r\\\\phi_i(S)V^ndS - \\\\\\n    \\\\int_0^{S_\\\\text{max}} r\\\\frac{d\\\\phi_i(S)}{dS}SV^ndS \\\\\\\\\\n    &= -\\\\int_0^{S_\\\\text{max}} r\\\\phi_i(S) \\\\sum_j V_j^n\\\\phi_j(S)dS \\\\\\n    -\\\\int_0^{S_\\\\text{max}} rS\\\\frac{d\\\\phi_i(S)}{dS} \\\\sum_k V_k\\\\phi_k(S)dS \\\\\\\\\\n    &= -\\\\sum_j r\\\\left(\\\\phi_i(S), \\\\phi_j(S)\\\\right) V_j^n -\\\\\\n     \\\\sum_k r\\\\left(S\\\\frac{d\\\\phi_i(S)}{dS}, \\\\phi_k(S)\\\\right)V_k^n \\\\\\\\\\n    &= -r\\\\textbf{M}V^n -r\\\\textbf{A}V^n, \\\\quad\\\\quad\\\\\\n    \\\\textbf{M}_{i,j} = \\\\left(\\\\phi_i(S), \\\\phi_j(S)\\\\right),\\\\\\n    \\\\textbf{A}_{i,j} = \\\\left(S\\\\frac{d\\\\phi_i(S)}{dS}, \\\\phi_j(S)\\\\right)\\n\\\\end{align*}\\n\\nSo, again after adding in the constants and exchanging \\\\(V^n\\\\) for \\\\(V^{n-1}\\\\) where applicable, we arrive at the following for (3):       \\n\\\\begin{align*}\\n    &k_n\\\\int_0^{S_\\\\text{max}}\\\\phi_i(S)\\\\left[rS\\\\left[(1-\\\\theta)\\n        \\\\frac{dV^{n-1}(S)}{dS} +\\\\\\n     \\\\theta\\\\frac{dV^{n}(S)}{dS}\\\\right]\\\\right]dS \\\\\\\\\\n    &= k_n\\\\left[-(1-\\\\theta)r\\\\textbf{M}V^{n-1} -(1-\\\\theta)r\\\\textbf{A}V^{n-1}\\\\\\n    -\\\\theta r\\\\textbf{M}V^n -\\\\theta r\\\\textbf{A}V^n\\\\right]\\n\\\\end{align*}\\n\\n Just as before, we will use \\\\(\\\\theta=0\\\\) for the matrix \\\\(\\\\textbf{A}\\\\) and \\\\(\\\\theta=\\\\frac{1}{2}\\\\) for the matrix \\\\(\\\\textbf{M}\\\\). So, we arrive at the following for (3):    \\n\\\\begin{align*}\\n    k_n\\\\left[-\\\\frac{1}{2}r\\\\textbf{M}V^{n-1} - \\\\frac{1}{2}r\\\\textbf{M}V^n \\\\\\n    -r\\\\textbf{A}V^{n-1}\\\\right]\\n\\\\end{align*}\\n\\nNow, putting everything together, we obtain the following discrete form for the Black-Scholes Equation:              \\n\\\\begin{align*}\\n    0&= \\\\\\\\\\n    &-\\\\textbf{M}V^n+\\\\textbf{M}V^{n-1} \\\\\\\\\\n    & +k_n\\\\left[-\\\\frac{1}{4}\\\\sigma^2\\\\textbf{D}V^{n-1} \\\\\\n    -\\\\frac{1}{4}\\\\sigma^2\\\\textbf{D}V^n \\\\\\n    - \\\\sigma^2\\\\textbf{B}V^n \\\\\\n     -\\\\frac{1}{2}r\\\\textbf{M}V^{n-1} - \\\\frac{1}{2}r\\\\textbf{M}V^n \\\\\\n    -r\\\\textbf{A}V^n \\\\\\n     -r\\\\frac{1}{2}\\\\textbf{M}V^{n-1} - \\\\frac{1}{2} r\\\\textbf{M}V^n\\\\right] \\\\\\\\\\n    &= -\\\\textbf{M}V^n + \\\\textbf{M}V^{n-1} +\\\\\\n    k_n\\\\left[- \\\\frac{1}{4}\\\\sigma^2\\\\textbf{D}V^{n-1} -\\\\\\n    \\\\frac{1}{4}\\\\sigma^2\\\\textbf{D}V^n - r\\\\textbf{M}V^{n-1} -\\\\\\n    r\\\\textbf{M}V^n  - \\\\sigma^2\\\\textbf{B}V^{n-1} - r\\\\textbf{A}V^{n-1}\\\\right]\\n\\\\end{align*}\\n\\n So, altogether we have:\\n\\n\\\\begin{equation}\\n    0 = \\\\textbf{M}V^n - \\\\textbf{M}V^{n-1} +\\\\\\n    k_n\\\\left[ \\\\frac{1}{4}\\\\sigma^2\\\\textbf{D}V^{n-1} +\\\\\\n    \\\\frac{1}{4}\\\\sigma^2\\\\textbf{D}V^n + r\\\\textbf{M}V^{n-1} + r\\\\textbf{M}V^n  +\\\\\\n    \\\\sigma^2\\\\textbf{B}V^{n-1} + r\\\\textbf{A}V^{n-1}\\\\right]\\\\tag{*}\\n\\\\end{equation}\\n\\nAs usual, we can write this with the unknown quantities on the left and the known ones on the right. This leads to the following linear system that would have to be solved in each time step:\\n\\n\\\\begin{align*}\\n    \\\\left[\\\\textbf{M}+\\\\frac{1}{4}k_n\\\\sigma^2\\\\textbf{D}+k_nr\\\\textbf{M}\\\\right]V^n\\\\\\n     =\\\\\\n    \\\\left[-\\\\frac{1}{4}k_n\\\\sigma^2\\\\textbf{D}-\\\\\\n    k_nr\\\\textbf{M}+k_n\\\\sigma^2\\\\textbf{B}-\\\\\\n    k_nr\\\\textbf{A}+\\\\textbf{M}\\\\right]V^{n-1}\\n\\\\end{align*}\\n\\nTest Case\\nFor this program, we will use the Method of Manufactured Solutions (MMS) to test that it is working correctly. This means that we will choose our solution to be a certain function similar to step-7. For our case, we will use:   \\n\\\\begin{align*}\\n    V(S,\\\\tau) = -\\\\tau^2 - S^2 + 6\\\\tag{**}\\n\\\\end{align*}\\n\\n This means that, using our PDE, we arrive at the following problem:        \\n\\\\begin{align*}\\n    &-\\\\frac{\\\\partial V}{\\\\partial \\\\tau} +\\\\\\n    \\\\frac{\\\\sigma^2S^2}{2}\\\\frac{\\\\partial^2 V}{\\\\partial S^2} +\\\\\\n    rS\\\\frac{\\\\partial V}{\\\\partial S} - rV = f(S,\\\\tau) \\\\\\\\\\n    &V(0,\\\\tau) = -\\\\tau^2 + 6 \\\\\\\\\\n    &V(S_\\\\text{max}, \\\\tau) = -S_\\\\text{max}^2 - \\\\tau^2 + 6 \\\\\\\\\\n    &V(S, 0) = -S^2 + 6\\n\\\\end{align*}\\n\\n Where, \\\\(f(S,\\\\tau) = 2\\\\tau - \\\\sigma^2S^2 - 2rS^2 - r(-\\\\tau^2 - S^2 + 6)\\\\). This set-up now has right hand sides for the equation itself and for the boundary conditions at \\\\(S=0\\\\) that we did not have before, along with \\\"final\\\" conditions (or, with \\\\(\\\\tau\\\\)-time \\\"initial conditions\\\") that do not match the real situation. We will implement this in such a way in the code that it is easy to exchange \\u2013 the introduction of the changes above is just meant to enable the use of a manufactured solution.\\nIf the program is working correctly, then it should produce (**) as the solution. This does mean that we need to modify our variational form somewhat to account for the non-zero right hand side.\\nFirst, we define the following:    \\n\\\\begin{align*}\\n    F^n_i = \\\\left(\\\\phi_i(S), f^n(S)\\\\right), && \\\\text{where } f^n(S) =\\\\\\n     f(S,\\\\tau_n)\\n\\\\end{align*}\\n\\n So, we arrive at the new equation:\\n\\n\\\\begin{align*}\\n    \\\\left[\\\\textbf{M}+\\\\frac{1}{4}k_n\\\\sigma^2\\\\textbf{D}+k_nr\\\\textbf{M}\\\\right]V^n\\\\\\n     =\\\\\\n     \\\\left[-\\\\frac{1}{4}k_n\\\\sigma^2\\\\textbf{D}-\\\\\\n     k_nr\\\\textbf{M}+k_n\\\\sigma^2\\\\textbf{B}-\\\\\\n     k_nr\\\\textbf{A}+\\\\textbf{M}\\\\right]V^{n-1} -\\\\\\n      k_n\\\\left[\\\\frac{1}{2}F^{n-1}+\\\\frac{1}{2}F^n\\\\right]\\n\\\\end{align*}\\n\\nWe then solve this equation as outlined above.\\n The commented program\\n Include files\\nThe program starts with the usual include files, all of which you should have seen before by now:\\n\\u00a0 #include <deal.II/base/convergence_table.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/utilities.h>\\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_accessor.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_refinement.h>\\n\\u00a0 #include <deal.II/grid/grid_out.h>\\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/tria_accessor.h>\\n\\u00a0 #include <deal.II/grid/tria_iterator.h>\\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/precondition.h>\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/solver_cg.h>\\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/data_out_stack.h>\\n\\u00a0 #include <deal.II/numerics/error_estimator.h>\\n\\u00a0 #include <deal.II/numerics/matrix_creator.h>\\n\\u00a0 #include <deal.II/numerics/matrix_tools.h>\\n\\u00a0 #include <deal.II/numerics/solution_transfer.h>\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 \\n\\u00a0 #include <fstream>\\n\\u00a0 #include <iostream>\\n\\u00a0 \\nThen the usual placing of all content of this program into a namespace and the importation of the deal.II namespace into the one we will work in. We also define an identifier to allow for the MMS code to be run when MMS is defined. Otherwise, the program solves the original problem:\\n\\u00a0 namespace BlackScholesSolver\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\n\\u00a0 #define MMS\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n Solution Class\\nThis section creates a class for the known solution when testing using the MMS. Here we are using \\\\(v(\\\\tau,S) = -\\\\tau^2 -S^2 + 6\\\\) for the solution. We need to include the solution equation and the gradient for the H1 seminorm calculation.\\n\\u00a0   template <int dim>\\n\\u00a0   class Solution : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     Solution(const double maturity_time);\\n\\u00a0 \\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component = 0) const override;\\n\\u00a0 \\n\\u00a0     virtual Tensor<1, dim>\\n\\u00a0     gradient(const Point<dim>  &p,\\n\\u00a0              const unsigned int component = 0) const override;\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     const double maturity_time;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   Solution<dim>::Solution(const double maturity_time)\\n\\u00a0     : maturity_time(maturity_time)\\n\\u00a0   {\\n\\u00a0     Assert(dim == 1, ExcNotImplemented());\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double Solution<dim>::value(const Point<dim>  &p,\\n\\u00a0                               const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     return -Utilities::fixed_power<2, double>(p[component]) -\\n\\u00a0            Utilities::fixed_power<2, double>(this->get_time()) + 6;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   Tensor<1, dim> Solution<dim>::gradient(const Point<dim>  &p,\\n\\u00a0                                          const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     return Point<dim>(-2 * p[component]);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFunctionDefinition function.h:152\\nFunction::gradientvirtual Tensor< 1, dim, RangeNumberType > gradient(const Point< dim > &p, const unsigned int component=0) const\\nFunction::valuevirtual RangeNumberType value(const Point< dim > &p, const unsigned int component=0) const\\nPointDefinition point.h:111\\nTensorDefinition tensor.h:471\\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\nUtilities::System::get_timestd::string get_time()Definition utilities.cc:1013\\nUtilities::fixed_powerconstexpr T fixed_power(const T t)Definition utilities.h:942\\n Equation Data\\nIn the following classes and functions, we implement the right hand side and boundary values that define this problem and for which we need function objects. The right hand side is chosen as discussed at the end of the introduction.\\nFirst, we handle the initial condition.\\n\\u00a0   template <int dim>\\n\\u00a0   class InitialConditions : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     InitialConditions(const double strike_price);\\n\\u00a0 \\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component = 0) const override;\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     const double strike_price;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   InitialConditions<dim>::InitialConditions(const double strike_price)\\n\\u00a0     : strike_price(strike_price)\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double InitialConditions<dim>::value(const Point<dim>  &p,\\n\\u00a0                                        const unsigned int component) const\\n\\u00a0   {\\n\\u00a0 #ifdef MMS\\n\\u00a0     return -Utilities::fixed_power<2, double>(p[component]) + 6;\\n\\u00a0 #else\\n\\u00a0     return std::max(p[component] - strike_price, 0.);\\n\\u00a0 #endif\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nint\\nUtilitiesDefinition communication_pattern_base.h:30\\nstd::max::VectorizedArray< Number, width > max(const ::VectorizedArray< Number, width > &, const ::VectorizedArray< Number, width > &)Definition vectorization.h:6943\\nNext, we handle the left boundary condition.\\n\\u00a0   template <int dim>\\n\\u00a0   class LeftBoundaryValues : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component = 0) const override;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double LeftBoundaryValues<dim>::value(const Point<dim> &,\\n\\u00a0                                         const unsigned int /*component*/) const\\n\\u00a0   {\\n\\u00a0 #ifdef MMS\\n\\u00a0     return -Utilities::fixed_power<2, double>(this->get_time()) + 6;\\n\\u00a0 #else\\n\\u00a0     return 0.;\\n\\u00a0 #endif\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nThen, we handle the right boundary condition.\\n\\u00a0   template <int dim>\\n\\u00a0   class RightBoundaryValues : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     RightBoundaryValues(const double strike_price, const double interest_rate);\\n\\u00a0 \\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component = 0) const override;\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     const double strike_price;\\n\\u00a0     const double interest_rate;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   RightBoundaryValues<dim>::RightBoundaryValues(const double strike_price,\\n\\u00a0                                                 const double interest_rate)\\n\\u00a0     : strike_price(strike_price)\\n\\u00a0     , interest_rate(interest_rate)\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double RightBoundaryValues<dim>::value(const Point<dim>  &p,\\n\\u00a0                                          const unsigned int component) const\\n\\u00a0   {\\n\\u00a0 #ifdef MMS\\n\\u00a0     return -Utilities::fixed_power<2, double>(p[component]) -\\n\\u00a0            Utilities::fixed_power<2, double>(this->get_time()) + 6;\\n\\u00a0 #else\\n\\u00a0     return (p[component] - strike_price) *\\n\\u00a0            exp((-interest_rate) * (this->get_time()));\\n\\u00a0 #endif\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFinally, we handle the right hand side.\\n\\u00a0   template <int dim>\\n\\u00a0   class RightHandSide : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     RightHandSide(const double asset_volatility, const double interest_rate);\\n\\u00a0 \\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component = 0) const override;\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     const double asset_volatility;\\n\\u00a0     const double interest_rate;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   RightHandSide<dim>::RightHandSide(const double asset_volatility,\\n\\u00a0                                     const double interest_rate)\\n\\u00a0     : asset_volatility(asset_volatility)\\n\\u00a0     , interest_rate(interest_rate)\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double RightHandSide<dim>::value(const Point<dim>  &p,\\n\\u00a0                                    const unsigned int component) const\\n\\u00a0   {\\n\\u00a0 #ifdef MMS\\n\\u00a0     return 2 * (this->get_time()) -\\n\\u00a0            Utilities::fixed_power<2, double>(asset_volatility * p[component]) -\\n\\u00a0            2 * interest_rate * Utilities::fixed_power<2, double>(p[component]) -\\n\\u00a0            interest_rate *\\n\\u00a0              (-Utilities::fixed_power<2, double>(p[component]) -\\n\\u00a0               Utilities::fixed_power<2, double>(this->get_time()) + 6);\\n\\u00a0 #else\\n\\u00a0     (void)p;\\n\\u00a0     (void)component;\\n\\u00a0     return 0.0;\\n\\u00a0 #endif\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n The BlackScholes Class\\nThe next piece is the declaration of the main class of this program. This is very similar to the step-26 tutorial, with some modifications. New matrices had to be added to calculate the A and B matrices, as well as the \\\\(V_{diff}\\\\) vector mentioned in the introduction. We also define the parameters used in the problem.\\n\\nmaximum_stock_price: The imposed upper bound on the spatial domain. This is the maximum allowed stock price.\\nmaturity_time: The upper bound on the time domain. This is when the option expires.\\n\\nasset_volatility: The volatility of the stock price.\\n\\ninterest_rate: The risk free interest rate.\\n\\nstrike_price: The agreed upon price that the buyer will have the option of purchasing the stocks at the expiration time.\\n\\nSome slight differences between this program and step-26 are the creation of the a_matrix and the b_matrix, which is described in the introduction. We then also need to store the current time, the size of the time step, and the number of the current time step. Next, we will store the output into a DataOutStack variable because we will be layering the solution at each time on top of one another to create the solution manifold. Then, we have a variable that stores the current cycle and number of cycles that we will run when calculating the solution. The cycle is one full solution calculation given a mesh. We refine the mesh once in between each cycle to exhibit the convergence properties of our program. Finally, we store the convergence data into a convergence table.\\nAs far as member functions are concerned, we have a function that calculates the convergence information for each cycle, called process_solution. This is just like what is done in step-7.\\n\\u00a0   template <int dim>\\n\\u00a0   class BlackScholes\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     BlackScholes();\\n\\u00a0 \\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void setup_system();\\n\\u00a0     void solve_time_step();\\n\\u00a0     void refine_grid();\\n\\u00a0     void process_solution();\\n\\u00a0     void add_results_for_output();\\n\\u00a0     void write_convergence_table();\\n\\u00a0 \\n\\u00a0     const double maximum_stock_price;\\n\\u00a0     const double maturity_time;\\n\\u00a0     const double asset_volatility;\\n\\u00a0     const double interest_rate;\\n\\u00a0     const double strike_price;\\n\\u00a0 \\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0     const FE_Q<dim>    fe;\\n\\u00a0     DoFHandler<dim>    dof_handler;\\n\\u00a0 \\n\\u00a0     AffineConstraints<double> constraints;\\n\\u00a0 \\n\\u00a0     SparsityPattern      sparsity_pattern;\\n\\u00a0     SparseMatrix<double> mass_matrix;\\n\\u00a0     SparseMatrix<double> laplace_matrix;\\n\\u00a0     SparseMatrix<double> a_matrix;\\n\\u00a0     SparseMatrix<double> b_matrix;\\n\\u00a0     SparseMatrix<double> system_matrix;\\n\\u00a0 \\n\\u00a0     Vector<double> solution;\\n\\u00a0     Vector<double> system_rhs;\\n\\u00a0 \\n\\u00a0     double time;\\n\\u00a0     double time_step;\\n\\u00a0 \\n\\u00a0     const double       theta;\\n\\u00a0     const unsigned int n_cycles;\\n\\u00a0     const unsigned int n_time_steps;\\n\\u00a0 \\n\\u00a0     DataOutStack<dim>        data_out_stack;\\n\\u00a0     std::vector<std::string> solution_names;\\n\\u00a0 \\n\\u00a0     ConvergenceTable convergence_table;\\n\\u00a0   };\\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nConvergenceTableDefinition convergence_table.h:64\\nDataOutStackDefinition data_out_stack.h:116\\nDoFHandlerDefinition dof_handler.h:317\\nFE_QDefinition fe_q.h:554\\nSparseMatrixDefinition sparse_matrix.h:520\\nSparsityPatternDefinition sparsity_pattern.h:343\\nTriangulationDefinition tria.h:1323\\nVectorDefinition vector.h:120\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\n The BlackScholes Implementation\\nNow, we get to the implementation of the main class. We will set the values for the various parameters used in the problem. These were chosen because they are fairly normal values for these parameters. Although the stock price has no upper bound in reality (it is in fact infinite), we impose an upper bound that is twice the strike price. This is a somewhat arbitrary choice to be twice the strike price, but it is large enough to see the interesting parts of the solution.\\n\\u00a0   template <int dim>\\n\\u00a0   BlackScholes<dim>::BlackScholes()\\n\\u00a0     : maximum_stock_price(1.)\\n\\u00a0     , maturity_time(1.)\\n\\u00a0     , asset_volatility(.2)\\n\\u00a0     , interest_rate(0.05)\\n\\u00a0     , strike_price(0.5)\\n\\u00a0     , fe(1)\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0     , time(0.0)\\n\\u00a0     , theta(0.5)\\n\\u00a0     , n_cycles(4)\\n\\u00a0     , n_time_steps(5000)\\n\\u00a0   {\\n\\u00a0     Assert(dim == 1, ExcNotImplemented());\\n\\u00a0   }\\n\\u00a0 \\n BlackScholes::setup_system\\nThe next function sets up the DoFHandler object, computes the constraints, and sets the linear algebra objects to their correct sizes. We also compute the mass matrix here by calling a function from the library. We will compute the other 3 matrices next, because these need to be computed 'by hand'.\\nNote, that the time step is initialized here because the maturity time was needed to compute the time step.\\n\\u00a0   template <int dim>\\n\\u00a0   void BlackScholes<dim>::setup_system()\\n\\u00a0   {\\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0 \\n\\u00a0     time_step = maturity_time / n_time_steps;\\n\\u00a0 \\n\\u00a0     constraints.clear();\\n\\u00a0     DoFTools::make_hanging_node_constraints(dof_handler, constraints);\\n\\u00a0     constraints.close();\\n\\u00a0     DynamicSparsityPattern dsp(dof_handler.n_dofs());\\n\\u00a0     DoFTools::make_sparsity_pattern(dof_handler,\\n\\u00a0                                     dsp,\\n\\u00a0                                     constraints,\\n\\u00a0                                     /*keep_constrained_dofs = */ true);\\n\\u00a0     sparsity_pattern.copy_from(dsp);\\n\\u00a0 \\n\\u00a0     mass_matrix.reinit(sparsity_pattern);\\n\\u00a0     laplace_matrix.reinit(sparsity_pattern);\\n\\u00a0     a_matrix.reinit(sparsity_pattern);\\n\\u00a0     b_matrix.reinit(sparsity_pattern);\\n\\u00a0     system_matrix.reinit(sparsity_pattern);\\n\\u00a0 \\n\\u00a0     MatrixCreator::create_mass_matrix(dof_handler,\\n\\u00a0                                       QGauss<dim>(fe.degree + 1),\\n\\u00a0                                       mass_matrix);\\n\\u00a0 \\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nQGaussDefinition quadrature_lib.h:40\\nDoFTools::make_hanging_node_constraintsvoid make_hanging_node_constraints(const DoFHandler< dim, spacedim > &dof_handler, AffineConstraints< number > &constraints)Definition dof_tools_constraints.cc:3073\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nMatrixCreator::create_mass_matrixvoid create_mass_matrix(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const Quadrature< dim > &q, MatrixType &matrix, const Function< spacedim, typename MatrixType::value_type > *const a=nullptr, const AffineConstraints< typename MatrixType::value_type > &constraints=AffineConstraints< typename MatrixType::value_type >())\\nBelow is the code to create the Laplace matrix with non-constant coefficients. This corresponds to the matrix D in the introduction. This non-constant coefficient is represented in the current_coefficient variable.\\n\\u00a0     const unsigned int dofs_per_cell = fe.dofs_per_cell;\\n\\u00a0     FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0     const QGauss<dim>  quadrature_formula(fe.degree + 1);\\n\\u00a0     FEValues<dim>      fe_values(fe,\\n\\u00a0                             quadrature_formula,\\n\\u00a0                             update_values | update_gradients |\\n\\u00a0                               update_quadrature_points | update_JxW_values);\\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         cell_matrix = 0.;\\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0         for (const unsigned int q_index : fe_values.quadrature_point_indices())\\n\\u00a0           {\\n\\u00a0             const double current_coefficient =\\n\\u00a0               fe_values.quadrature_point(q_index).square();\\n\\u00a0             for (const unsigned int i : fe_values.dof_indices())\\n\\u00a0               {\\n\\u00a0                 for (const unsigned int j : fe_values.dof_indices())\\n\\u00a0                   cell_matrix(i, j) +=\\n\\u00a0                     (current_coefficient *              // (x_q)^2\\n\\u00a0                      fe_values.shape_grad(i, q_index) * // grad phi_i(x_q)\\n\\u00a0                      fe_values.shape_grad(j, q_index) * // grad phi_j(x_q)\\n\\u00a0                      fe_values.JxW(q_index));           // dx\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0         for (const unsigned int i : fe_values.dof_indices())\\n\\u00a0           {\\n\\u00a0             for (const unsigned int j : fe_values.dof_indices())\\n\\u00a0               laplace_matrix.add(local_dof_indices[i],\\n\\u00a0                                  local_dof_indices[j],\\n\\u00a0                                  cell_matrix(i, j));\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\nFEValuesDefinition fe_values.h:63\\nFullMatrixDefinition full_matrix.h:79\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\nNow we will create the A matrix. Below is the code to create the matrix A as discussed in the introduction. The non constant coefficient is again represented in the current_coefficient variable.\\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         cell_matrix = 0.;\\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0         for (const unsigned int q_index : fe_values.quadrature_point_indices())\\n\\u00a0           {\\n\\u00a0             const Tensor<1, dim> current_coefficient =\\n\\u00a0               fe_values.quadrature_point(q_index);\\n\\u00a0             for (const unsigned int i : fe_values.dof_indices())\\n\\u00a0               {\\n\\u00a0                 for (const unsigned int j : fe_values.dof_indices())\\n\\u00a0                   {\\n\\u00a0                     cell_matrix(i, j) +=\\n\\u00a0                       (current_coefficient *               // x_q\\n\\u00a0                        fe_values.shape_grad(i, q_index) *  // grad phi_i(x_q)\\n\\u00a0                        fe_values.shape_value(j, q_index) * // phi_j(x_q)\\n\\u00a0                        fe_values.JxW(q_index));            // dx\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0         for (const unsigned int i : fe_values.dof_indices())\\n\\u00a0           {\\n\\u00a0             for (const unsigned int j : fe_values.dof_indices())\\n\\u00a0               a_matrix.add(local_dof_indices[i],\\n\\u00a0                            local_dof_indices[j],\\n\\u00a0                            cell_matrix(i, j));\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\nFinally we will create the matrix B. Below is the code to create the matrix B as discussed in the introduction. The non constant coefficient is again represented in the current_coefficient variable.\\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         cell_matrix = 0.;\\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0         for (const unsigned int q_index : fe_values.quadrature_point_indices())\\n\\u00a0           {\\n\\u00a0             const Tensor<1, dim> current_coefficient =\\n\\u00a0               fe_values.quadrature_point(q_index);\\n\\u00a0             for (const unsigned int i : fe_values.dof_indices())\\n\\u00a0               {\\n\\u00a0                 for (const unsigned int j : fe_values.dof_indices())\\n\\u00a0                   cell_matrix(i, j) +=\\n\\u00a0                     (current_coefficient *               // x_q\\n\\u00a0                      fe_values.shape_value(i, q_index) * // phi_i(x_q)\\n\\u00a0                      fe_values.shape_grad(j, q_index) *  // grad phi_j(x_q)\\n\\u00a0                      fe_values.JxW(q_index));            // dx\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0         for (const unsigned int i : fe_values.dof_indices())\\n\\u00a0           {\\n\\u00a0             for (const unsigned int j : fe_values.dof_indices())\\n\\u00a0               b_matrix.add(local_dof_indices[i],\\n\\u00a0                            local_dof_indices[j],\\n\\u00a0                            cell_matrix(i, j));\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     solution.reinit(dof_handler.n_dofs());\\n\\u00a0     system_rhs.reinit(dof_handler.n_dofs());\\n\\u00a0   }\\n\\u00a0 \\n BlackScholes::solve_time_step\\nThe next function is the one that solves the actual linear system for a single time step. The only interesting thing here is that the matrices we have built are symmetric positive definite, so we can use the conjugate gradient method.\\n\\u00a0   template <int dim>\\n\\u00a0   void BlackScholes<dim>::solve_time_step()\\n\\u00a0   {\\n\\u00a0     SolverControl                          solver_control(1000, 1e-12);\\n\\u00a0     SolverCG<Vector<double>>               cg(solver_control);\\n\\u00a0     PreconditionSSOR<SparseMatrix<double>> preconditioner;\\n\\u00a0     preconditioner.initialize(system_matrix, 1.0);\\n\\u00a0     cg.solve(system_matrix, solution, system_rhs, preconditioner);\\n\\u00a0     constraints.distribute(solution);\\n\\u00a0   }\\n\\u00a0 \\nPreconditionSSORDefinition precondition.h:1778\\nPreconditionSSOR::initializevoid initialize(const MatrixType &A, const AdditionalData &parameters=AdditionalData())\\nSolverCGDefinition solver_cg.h:179\\nSolverControlDefinition solver_control.h:67\\n BlackScholes::add_results_for_output\\nThis is simply the function to stitch the solution pieces together. For this, we create a new layer at each time, and then add the solution vector for that timestep. The function then stitches this together with the old solutions using 'build_patches'.\\n\\u00a0   template <int dim>\\n\\u00a0   void BlackScholes<dim>::add_results_for_output()\\n\\u00a0   {\\n\\u00a0     data_out_stack.new_parameter_value(time, time_step);\\n\\u00a0     data_out_stack.attach_dof_handler(dof_handler);\\n\\u00a0     data_out_stack.add_data_vector(solution, solution_names);\\n\\u00a0     data_out_stack.build_patches(2);\\n\\u00a0     data_out_stack.finish_parameter_value();\\n\\u00a0   }\\n\\u00a0 \\n BlackScholes::refine_grid\\nIt is somewhat unnecessary to have a function for the global refinement that we do. The reason for the function is to allow for the possibility of an adaptive refinement later.\\n\\u00a0   template <int dim>\\n\\u00a0   void BlackScholes<dim>::refine_grid()\\n\\u00a0   {\\n\\u00a0     triangulation.refine_global(1);\\n\\u00a0   }\\n\\u00a0 \\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\n BlackScholes::process_solution\\nThis is where we calculate the convergence and error data to evaluate the effectiveness of the program. Here, we calculate the \\\\(L^2\\\\), \\\\(H^1\\\\) and \\\\(L^{\\\\infty}\\\\) norms.\\n\\u00a0   template <int dim>\\n\\u00a0   void BlackScholes<dim>::process_solution()\\n\\u00a0   {\\n\\u00a0     Solution<dim> sol(maturity_time);\\n\\u00a0     sol.set_time(time);\\n\\u00a0     Vector<float> difference_per_cell(triangulation.n_active_cells());\\n\\u00a0     VectorTools::integrate_difference(dof_handler,\\n\\u00a0                                       solution,\\n\\u00a0                                       sol,\\n\\u00a0                                       difference_per_cell,\\n\\u00a0                                       QGauss<dim>(fe.degree + 1),\\n\\u00a0                                       VectorTools::L2_norm);\\n\\u00a0     const double L2_error =\\n\\u00a0       VectorTools::compute_global_error(triangulation,\\n\\u00a0                                         difference_per_cell,\\n\\u00a0                                         VectorTools::L2_norm);\\n\\u00a0     VectorTools::integrate_difference(dof_handler,\\n\\u00a0                                       solution,\\n\\u00a0                                       sol,\\n\\u00a0                                       difference_per_cell,\\n\\u00a0                                       QGauss<dim>(fe.degree + 1),\\n\\u00a0                                       VectorTools::H1_seminorm);\\n\\u00a0     const double H1_error =\\n\\u00a0       VectorTools::compute_global_error(triangulation,\\n\\u00a0                                         difference_per_cell,\\n\\u00a0                                         VectorTools::H1_seminorm);\\n\\u00a0     const QTrapezoid<1>  q_trapezoid;\\n\\u00a0     const QIterated<dim> q_iterated(q_trapezoid, fe.degree * 2 + 1);\\n\\u00a0     VectorTools::integrate_difference(dof_handler,\\n\\u00a0                                       solution,\\n\\u00a0                                       sol,\\n\\u00a0                                       difference_per_cell,\\n\\u00a0                                       q_iterated,\\n\\u00a0                                       VectorTools::Linfty_norm);\\n\\u00a0     const double Linfty_error =\\n\\u00a0       VectorTools::compute_global_error(triangulation,\\n\\u00a0                                         difference_per_cell,\\n\\u00a0                                         VectorTools::Linfty_norm);\\n\\u00a0     const unsigned int n_active_cells = triangulation.n_active_cells();\\n\\u00a0     const unsigned int n_dofs         = dof_handler.n_dofs();\\n\\u00a0     convergence_table.add_value(\\\"cells\\\", n_active_cells);\\n\\u00a0     convergence_table.add_value(\\\"dofs\\\", n_dofs);\\n\\u00a0     convergence_table.add_value(\\\"L2\\\", L2_error);\\n\\u00a0     convergence_table.add_value(\\\"H1\\\", H1_error);\\n\\u00a0     convergence_table.add_value(\\\"Linfty\\\", Linfty_error);\\n\\u00a0   }\\n\\u00a0 \\nQIteratedDefinition quadrature.h:435\\nQTrapezoidDefinition quadrature_lib.h:191\\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nVectorTools::compute_global_errordouble compute_global_error(const Triangulation< dim, spacedim > &tria, const InVector &cellwise_error, const NormType &norm, const double exponent=2.)\\nVectorTools::Linfty_norm@ Linfty_normDefinition vector_tools_common.h:147\\nVectorTools::H1_seminorm@ H1_seminormDefinition vector_tools_common.h:164\\nVectorTools::L2_norm@ L2_normDefinition vector_tools_common.h:112\\nVectorTools::integrate_differencevoid integrate_difference(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const ReadVector< Number > &fe_function, const Function< spacedim, Number > &exact_solution, OutVector &difference, const Quadrature< dim > &q, const NormType &norm, const Function< spacedim, double > *weight=nullptr, const double exponent=2.)\\n BlackScholes::write_convergence_table \\nThis next part is building the convergence and error tables. By this, we need to set the settings for how to output the data that was calculated during BlackScholes::process_solution. First, we will create the headings and set up the cells properly. During this, we will also prescribe the precision of our results. Then we will write the calculated errors based on the \\\\(L^2\\\\), \\\\(H^1\\\\), and \\\\(L^{\\\\infty}\\\\) norms to the console and to the error LaTeX file.\\n\\u00a0   template <int dim>\\n\\u00a0   void BlackScholes<dim>::write_convergence_table()\\n\\u00a0   {\\n\\u00a0     convergence_table.set_precision(\\\"L2\\\", 3);\\n\\u00a0     convergence_table.set_precision(\\\"H1\\\", 3);\\n\\u00a0     convergence_table.set_precision(\\\"Linfty\\\", 3);\\n\\u00a0     convergence_table.set_scientific(\\\"L2\\\", true);\\n\\u00a0     convergence_table.set_scientific(\\\"H1\\\", true);\\n\\u00a0     convergence_table.set_scientific(\\\"Linfty\\\", true);\\n\\u00a0     convergence_table.set_tex_caption(\\\"cells\\\", \\\"\\\\\\\\# cells\\\");\\n\\u00a0     convergence_table.set_tex_caption(\\\"dofs\\\", \\\"\\\\\\\\# dofs\\\");\\n\\u00a0     convergence_table.set_tex_caption(\\\"L2\\\", \\\"@fL^2@f-error\\\");\\n\\u00a0     convergence_table.set_tex_caption(\\\"H1\\\", \\\"@fH^1@f-error\\\");\\n\\u00a0     convergence_table.set_tex_caption(\\\"Linfty\\\", \\\"@fL^\\\\\\\\infty@f-error\\\");\\n\\u00a0     convergence_table.set_tex_format(\\\"cells\\\", \\\"r\\\");\\n\\u00a0     convergence_table.set_tex_format(\\\"dofs\\\", \\\"r\\\");\\n\\u00a0     std::cout << std::endl;\\n\\u00a0     convergence_table.write_text(std::cout);\\n\\u00a0     std::string error_filename = \\\"error\\\";\\n\\u00a0     error_filename += \\\"-global\\\";\\n\\u00a0     error_filename += \\\".tex\\\";\\n\\u00a0     std::ofstream error_table_file(error_filename);\\n\\u00a0     convergence_table.write_tex(error_table_file);\\n\\u00a0 \\nNext, we will make the convergence table. We will again write this to the console and to the convergence LaTeX file.\\n\\u00a0     convergence_table.add_column_to_supercolumn(\\\"cells\\\", \\\"n cells\\\");\\n\\u00a0     std::vector<std::string> new_order;\\n\\u00a0     new_order.emplace_back(\\\"n cells\\\");\\n\\u00a0     new_order.emplace_back(\\\"H1\\\");\\n\\u00a0     new_order.emplace_back(\\\"L2\\\");\\n\\u00a0     convergence_table.set_column_order(new_order);\\n\\u00a0     convergence_table.evaluate_convergence_rates(\\n\\u00a0       \\\"L2\\\", ConvergenceTable::reduction_rate);\\n\\u00a0     convergence_table.evaluate_convergence_rates(\\n\\u00a0       \\\"L2\\\", ConvergenceTable::reduction_rate_log2);\\n\\u00a0     convergence_table.evaluate_convergence_rates(\\n\\u00a0       \\\"H1\\\", ConvergenceTable::reduction_rate);\\n\\u00a0     convergence_table.evaluate_convergence_rates(\\n\\u00a0       \\\"H1\\\", ConvergenceTable::reduction_rate_log2);\\n\\u00a0     std::cout << std::endl;\\n\\u00a0     convergence_table.write_text(std::cout);\\n\\u00a0     std::string conv_filename = \\\"convergence\\\";\\n\\u00a0     conv_filename += \\\"-global\\\";\\n\\u00a0     switch (fe.degree)\\n\\u00a0       {\\n\\u00a0         case 1:\\n\\u00a0           conv_filename += \\\"-q1\\\";\\n\\u00a0           break;\\n\\u00a0         case 2:\\n\\u00a0           conv_filename += \\\"-q2\\\";\\n\\u00a0           break;\\n\\u00a0         default:\\n\\u00a0           DEAL_II_NOT_IMPLEMENTED();\\n\\u00a0       }\\n\\u00a0     conv_filename += \\\".tex\\\";\\n\\u00a0     std::ofstream table_file(conv_filename);\\n\\u00a0     convergence_table.write_tex(table_file);\\n\\u00a0   }\\n\\u00a0 \\nConvergenceTable::reduction_rate_log2@ reduction_rate_log2Definition convergence_table.h:88\\nConvergenceTable::reduction_rate@ reduction_rateDefinition convergence_table.h:83\\nDEAL_II_NOT_IMPLEMENTED#define DEAL_II_NOT_IMPLEMENTED()Definition exceptions.h:1814\\n BlackScholes::run\\nNow we get to the main driver of the program. This is where we do all the work of looping through the time steps and calculating the solution vector each time. Here at the top, we set the initial refinement value and then create a mesh. Then we refine this mesh once. Next, we set up the data_out_stack object to store our solution. Finally, we start a for loop to loop through the cycles. This lets us recalculate a solution for each successive mesh refinement. At the beginning of each iteration, we need to reset the time and time step number. We introduce an if statement to accomplish this because we don't want to do this on the first iteration.\\n\\u00a0   template <int dim>\\n\\u00a0   void BlackScholes<dim>::run()\\n\\u00a0   {\\n\\u00a0     GridGenerator::hyper_cube(triangulation, 0.0, maximum_stock_price, true);\\n\\u00a0     triangulation.refine_global(0);\\n\\u00a0 \\n\\u00a0     solution_names.emplace_back(\\\"u\\\");\\n\\u00a0     data_out_stack.declare_data_vector(solution_names,\\n\\u00a0                                        DataOutStack<dim>::dof_vector);\\n\\u00a0 \\n\\u00a0     Vector<double> vmult_result;\\n\\u00a0     Vector<double> forcing_terms;\\n\\u00a0 \\n\\u00a0     for (unsigned int cycle = 0; cycle < n_cycles; ++cycle)\\n\\u00a0       {\\n\\u00a0         if (cycle != 0)\\n\\u00a0           {\\n\\u00a0             refine_grid();\\n\\u00a0             time = 0.0;\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         setup_system();\\n\\u00a0 \\n\\u00a0         std::cout << std::endl\\n\\u00a0                   << \\\"===========================================\\\" << std::endl\\n\\u00a0                   << \\\"Cycle \\\" << cycle << ':' << std::endl\\n\\u00a0                   << \\\"Number of active cells: \\\"\\n\\u00a0                   << triangulation.n_active_cells() << std::endl\\n\\u00a0                   << \\\"Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n\\u00a0                   << std::endl\\n\\u00a0                   << std::endl;\\n\\u00a0 \\n\\u00a0         VectorTools::interpolate(dof_handler,\\n\\u00a0                                  InitialConditions<dim>(strike_price),\\n\\u00a0                                  solution);\\n\\u00a0 \\n\\u00a0         if (cycle == (n_cycles - 1))\\n\\u00a0           {\\n\\u00a0             add_results_for_output();\\n\\u00a0           }\\n\\u00a0 \\nGridGenerator::hyper_cubevoid hyper_cube(Triangulation< dim, spacedim > &tria, const double left=0., const double right=1., const bool colorize=false)\\nVectorTools::interpolatevoid interpolate(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const Function< spacedim, typename VectorType::value_type > &function, VectorType &vec, const ComponentMask &component_mask={})\\nNext, we run the main loop which runs until we exceed the maturity time. We first compute the right hand side of the equation, which is described in the introduction. Recall that it contains the term  \\\\(\\\\left[-\\\\frac{1}{4}k_n\\\\sigma^2\\\\mathbf{D}-k_nr\\\\mathbf{M}+k_n\\\\sigma^2\\n   \\\\mathbf{B}-k_nr\\\\mathbf{A}+\\\\mathbf{M}\\\\right]V^{n-1}\\\\). We put these terms into the variable system_rhs, with the help of a temporary vector:\\n\\u00a0         vmult_result.reinit(dof_handler.n_dofs());\\n\\u00a0         forcing_terms.reinit(dof_handler.n_dofs());\\n\\u00a0         for (unsigned int timestep_number = 0; timestep_number < n_time_steps;\\n\\u00a0              ++timestep_number)\\n\\u00a0           {\\n\\u00a0             time += time_step;\\n\\u00a0 \\n\\u00a0             if (timestep_number % 1000 == 0)\\n\\u00a0               std::cout << \\\"Time step \\\" << timestep_number << \\\" at t=\\\" << time\\n\\u00a0                         << std::endl;\\n\\u00a0 \\n\\u00a0             mass_matrix.vmult(system_rhs, solution);\\n\\u00a0 \\n\\u00a0             laplace_matrix.vmult(vmult_result, solution);\\n\\u00a0             system_rhs.add(\\n\\u00a0               (-1) * (1 - theta) * time_step *\\n\\u00a0                 Utilities::fixed_power<2, double>(asset_volatility) * 0.5,\\n\\u00a0               vmult_result);\\n\\u00a0             mass_matrix.vmult(vmult_result, solution);\\n\\u00a0 \\n\\u00a0             system_rhs.add((-1) * (1 - theta) * time_step * interest_rate * 2,\\n\\u00a0                            vmult_result);\\n\\u00a0 \\n\\u00a0             a_matrix.vmult(vmult_result, solution);\\n\\u00a0             system_rhs.add((-1) * time_step * interest_rate, vmult_result);\\n\\u00a0 \\n\\u00a0             b_matrix.vmult(vmult_result, solution);\\n\\u00a0             system_rhs.add(\\n\\u00a0               (-1) * Utilities::fixed_power<2, double>(asset_volatility) *\\n\\u00a0                 time_step * 1,\\n\\u00a0               vmult_result);\\n\\u00a0 \\nThe second piece is to compute the contributions of the source terms. This corresponds to the term  \\\\(-k_n\\\\left[\\\\frac{1}{2}F^{n-1}\\n   +\\\\frac{1}{2}F^n\\\\right]\\\\). The following code calls VectorTools::create_right_hand_side to compute the vectors \\\\(F\\\\), where we set the time of the right hand side (source) function before we evaluate it. The result of this all ends up in the forcing_terms variable:\\n\\u00a0             RightHandSide<dim> rhs_function(asset_volatility, interest_rate);\\n\\u00a0             rhs_function.set_time(time);\\n\\u00a0             VectorTools::create_right_hand_side(dof_handler,\\n\\u00a0                                                 QGauss<dim>(fe.degree + 1),\\n\\u00a0                                                 rhs_function,\\n\\u00a0                                                 forcing_terms);\\n\\u00a0             forcing_terms *= time_step * theta;\\n\\u00a0             system_rhs -= forcing_terms;\\n\\u00a0 \\n\\u00a0             rhs_function.set_time(time - time_step);\\n\\u00a0             VectorTools::create_right_hand_side(dof_handler,\\n\\u00a0                                                 QGauss<dim>(fe.degree + 1),\\n\\u00a0                                                 rhs_function,\\n\\u00a0                                                 forcing_terms);\\n\\u00a0             forcing_terms *= time_step * (1 - theta);\\n\\u00a0             system_rhs -= forcing_terms;\\n\\u00a0 \\nVectorTools::create_right_hand_sidevoid create_right_hand_side(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const Quadrature< dim > &q, const Function< spacedim, typename VectorType::value_type > &rhs, VectorType &rhs_vector, const AffineConstraints< typename VectorType::value_type > &constraints=AffineConstraints< typename VectorType::value_type >())\\nNext, we add the forcing terms to the ones that come from the time stepping, and also build the matrix  \\\\(\\\\left[\\\\mathbf{M}+\\n   \\\\frac{1}{4}k_n\\\\sigma^2\\\\mathbf{D}+k_nr\\\\mathbf{M}\\\\right]\\\\) that we have to invert in each time step. The final piece of these operations is to eliminate hanging node constrained degrees of freedom from the linear system:\\n\\u00a0             system_matrix.copy_from(mass_matrix);\\n\\u00a0             system_matrix.add(\\n\\u00a0               (theta)*time_step *\\n\\u00a0                 Utilities::fixed_power<2, double>(asset_volatility) * 0.5,\\n\\u00a0               laplace_matrix);\\n\\u00a0             system_matrix.add((time_step)*interest_rate * theta * (1 + 1),\\n\\u00a0                               mass_matrix);\\n\\u00a0 \\n\\u00a0             constraints.condense(system_matrix, system_rhs);\\n\\u00a0 \\nThere is one more operation we need to do before we can solve it: boundary values. To this end, we create a boundary value object, set the proper time to the one of the current time step, and evaluate it as we have done many times before. The result is used to also set the correct boundary values in the linear system:\\n\\u00a0             {\\n\\u00a0               RightBoundaryValues<dim> right_boundary_function(strike_price,\\n\\u00a0                                                                interest_rate);\\n\\u00a0               LeftBoundaryValues<dim>  left_boundary_function;\\n\\u00a0               right_boundary_function.set_time(time);\\n\\u00a0               left_boundary_function.set_time(time);\\n\\u00a0               std::map<types::global_dof_index, double> boundary_values;\\n\\u00a0               VectorTools::interpolate_boundary_values(dof_handler,\\n\\u00a0                                                        0,\\n\\u00a0                                                        left_boundary_function,\\n\\u00a0                                                        boundary_values);\\n\\u00a0               VectorTools::interpolate_boundary_values(dof_handler,\\n\\u00a0                                                        1,\\n\\u00a0                                                        right_boundary_function,\\n\\u00a0                                                        boundary_values);\\n\\u00a0               MatrixTools::apply_boundary_values(boundary_values,\\n\\u00a0                                                  system_matrix,\\n\\u00a0                                                  solution,\\n\\u00a0                                                  system_rhs);\\n\\u00a0             }\\n\\u00a0 \\nMatrixTools::apply_boundary_valuesvoid apply_boundary_values(const std::map< types::global_dof_index, number > &boundary_values, SparseMatrix< number > &matrix, Vector< number > &solution, Vector< number > &right_hand_side, const bool eliminate_columns=true)Definition matrix_tools.cc:75\\nVectorTools::interpolate_boundary_valuesvoid interpolate_boundary_values(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const std::map< types::boundary_id, const Function< spacedim, number > * > &function_map, std::map< types::global_dof_index, number > &boundary_values, const ComponentMask &component_mask={})\\nWith this out of the way, all we have to do is solve the system, generate graphical data on the last cycle, and create the convergence table data.\\n\\u00a0             solve_time_step();\\n\\u00a0 \\n\\u00a0             if (cycle == (n_cycles - 1))\\n\\u00a0               {\\n\\u00a0                 add_results_for_output();\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0 #ifdef MMS\\n\\u00a0         process_solution();\\n\\u00a0 #endif\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     const std::string filename = \\\"solution.vtk\\\";\\n\\u00a0     std::ofstream     output(filename);\\n\\u00a0     data_out_stack.write_vtk(output);\\n\\u00a0 \\n\\u00a0 #ifdef MMS\\n\\u00a0     write_convergence_table();\\n\\u00a0 #endif\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 } // namespace BlackScholesSolver\\n\\u00a0 \\n The main Function\\nHaving made it this far, there is, again, nothing much to discuss for the main function of this program: it looks like all such functions since step-6.\\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       using namespace BlackScholesSolver;\\n\\u00a0 \\n\\u00a0       BlackScholes<1> black_scholes_solver;\\n\\u00a0       black_scholes_solver.run();\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nBelow is the output of the program: ===========================================\\nNumber of active cells: 1\\nNumber of degrees of freedom: 2\\n \\nTime step 0 at t=0.0002\\n[...]\\n \\nCycle 7:\\nNumber of active cells: 128\\nNumber of degrees of freedom: 129\\n \\nTime step 0 at t=0.0002\\nTime step 1000 at t=0.2002\\nTime step 2000 at t=0.4002\\nTime step 3000 at t=0.6002\\nTime step 4000 at t=0.8002\\n \\ncells dofs    L2        H1      Linfty\\n    1    2 1.667e-01 5.774e-01 2.222e-01\\n    2    3 3.906e-02 2.889e-01 5.380e-02\\n    4    5 9.679e-03 1.444e-01 1.357e-02\\n    8    9 2.405e-03 7.218e-02 3.419e-03\\n   16   17 5.967e-04 3.609e-02 8.597e-04\\n   32   33 1.457e-04 1.804e-02 2.155e-04\\n   64   65 3.307e-05 9.022e-03 5.388e-05\\n  128  129 5.016e-06 4.511e-03 1.342e-05\\n \\nn cells         H1                  L2\\n      1 5.774e-01    -    - 1.667e-01    -    -\\n      2 2.889e-01 2.00 1.00 3.906e-02 4.27 2.09\\n      4 1.444e-01 2.00 1.00 9.679e-03 4.04 2.01\\n      8 7.218e-02 2.00 1.00 2.405e-03 4.02 2.01\\n     16 3.609e-02 2.00 1.00 5.967e-04 4.03 2.01\\n     32 1.804e-02 2.00 1.00 1.457e-04 4.10 2.03\\n     64 9.022e-03 2.00 1.00 3.307e-05 4.41 2.14\\n    128 4.511e-03 2.00 1.00 5.016e-06 6.59 2.72\\nWhat is more interesting is the output of the convergence tables. They are outputted into the console, as well into a LaTeX file. The convergence tables are shown above. Here, you can see that the solution has a convergence rate of \\\\(\\\\mathcal{O}(h)\\\\) with respect to the \\\\(H^1\\\\)-norm, and the solution has a convergence rate of \\\\(\\\\mathcal{O}(h^2)\\\\) with respect to the \\\\(L^2\\\\)-norm.\\nBelow is the visualization of the solution.\\n   The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2021 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Author: Tyler Anderson, Colorado State University, 2021\\n */\\n \\n \\n \\n#include <deal.II/base/convergence_table.h>\\n#include <deal.II/base/function.h>\\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/utilities.h>\\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_accessor.h>\\n#include <deal.II/dofs/dof_tools.h>\\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_values.h>\\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_refinement.h>\\n#include <deal.II/grid/grid_out.h>\\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/tria_accessor.h>\\n#include <deal.II/grid/tria_iterator.h>\\n#include <deal.II/lac/affine_constraints.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/precondition.h>\\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/vector.h>\\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/data_out_stack.h>\\n#include <deal.II/numerics/error_estimator.h>\\n#include <deal.II/numerics/matrix_creator.h>\\n#include <deal.II/numerics/matrix_tools.h>\\n#include <deal.II/numerics/solution_transfer.h>\\n#include <deal.II/numerics/vector_tools.h>\\n \\n#include <fstream>\\n#include <iostream>\\n \\nnamespace BlackScholesSolver\\n{\\n using namespace dealii;\\n \\n#define MMS\\n \\n \\n template <int dim>\\n class Solution : public Function<dim>\\n  {\\n public:\\n    Solution(const double maturity_time);\\n \\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n \\n virtual Tensor<1, dim>\\n    gradient(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n \\n private:\\n const double maturity_time;\\n  };\\n \\n \\n template <int dim>\\n  Solution<dim>::Solution(const double maturity_time)\\n    : maturity_time(maturity_time)\\n  {\\n Assert(dim == 1, ExcNotImplemented());\\n  }\\n \\n \\n template <int dim>\\n double Solution<dim>::value(const Point<dim>  &p,\\n const unsigned int component) const\\n {\\n return -Utilities::fixed_power<2, double>(p[component]) -\\n Utilities::fixed_power<2, double>(this->get_time()) + 6;\\n  }\\n \\n \\n template <int dim>\\n Tensor<1, dim> Solution<dim>::gradient(const Point<dim>  &p,\\n const unsigned int component) const\\n {\\n return Point<dim>(-2 * p[component]);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n class InitialConditions : public Function<dim>\\n  {\\n public:\\n    InitialConditions(const double strike_price);\\n \\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n \\n private:\\n const double strike_price;\\n  };\\n \\n \\n template <int dim>\\n  InitialConditions<dim>::InitialConditions(const double strike_price)\\n    : strike_price(strike_price)\\n  {}\\n \\n \\n template <int dim>\\n double InitialConditions<dim>::value(const Point<dim>  &p,\\n const unsigned int component) const\\n {\\n#ifdef MMS\\n return -Utilities::fixed_power<2, double>(p[component]) + 6;\\n#else\\n return std::max(p[component] - strike_price, 0.);\\n#endif\\n  }\\n \\n \\n \\n template <int dim>\\n class LeftBoundaryValues : public Function<dim>\\n  {\\n public:\\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n  };\\n \\n \\n template <int dim>\\n double LeftBoundaryValues<dim>::value(const Point<dim> &,\\n const unsigned int /*component*/) const\\n {\\n#ifdef MMS\\n return -Utilities::fixed_power<2, double>(this->get_time()) + 6;\\n#else\\n return 0.;\\n#endif\\n  }\\n \\n \\n \\n template <int dim>\\n class RightBoundaryValues : public Function<dim>\\n  {\\n public:\\n    RightBoundaryValues(const double strike_price, const double interest_rate);\\n \\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n \\n private:\\n const double strike_price;\\n const double interest_rate;\\n  };\\n \\n \\n template <int dim>\\n  RightBoundaryValues<dim>::RightBoundaryValues(const double strike_price,\\n const double interest_rate)\\n    : strike_price(strike_price)\\n    , interest_rate(interest_rate)\\n  {}\\n \\n \\n template <int dim>\\n double RightBoundaryValues<dim>::value(const Point<dim>  &p,\\n const unsigned int component) const\\n {\\n#ifdef MMS\\n return -Utilities::fixed_power<2, double>(p[component]) -\\n Utilities::fixed_power<2, double>(this->get_time()) + 6;\\n#else\\n return (p[component] - strike_price) *\\n exp((-interest_rate) * (this->get_time()));\\n#endif\\n  }\\n \\n \\n \\n template <int dim>\\n class RightHandSide : public Function<dim>\\n  {\\n public:\\n    RightHandSide(const double asset_volatility, const double interest_rate);\\n \\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n \\n private:\\n const double asset_volatility;\\n const double interest_rate;\\n  };\\n \\n \\n template <int dim>\\n  RightHandSide<dim>::RightHandSide(const double asset_volatility,\\n const double interest_rate)\\n    : asset_volatility(asset_volatility)\\n    , interest_rate(interest_rate)\\n  {}\\n \\n \\n template <int dim>\\n double RightHandSide<dim>::value(const Point<dim>  &p,\\n const unsigned int component) const\\n {\\n#ifdef MMS\\n return 2 * (this->get_time()) -\\n Utilities::fixed_power<2, double>(asset_volatility * p[component]) -\\n           2 * interest_rate * Utilities::fixed_power<2, double>(p[component]) -\\n           interest_rate *\\n             (-Utilities::fixed_power<2, double>(p[component]) -\\n Utilities::fixed_power<2, double>(this->get_time()) + 6);\\n#else\\n    (void)p;\\n    (void)component;\\n return 0.0;\\n#endif\\n  }\\n \\n \\n \\n \\n template <int dim>\\n class BlackScholes\\n  {\\n public:\\n    BlackScholes();\\n \\n void run();\\n \\n private:\\n void setup_system();\\n void solve_time_step();\\n void refine_grid();\\n void process_solution();\\n void add_results_for_output();\\n void write_convergence_table();\\n \\n const double maximum_stock_price;\\n const double maturity_time;\\n const double asset_volatility;\\n const double interest_rate;\\n const double strike_price;\\n \\n Triangulation<dim> triangulation;\\n const FE_Q<dim>    fe;\\n DoFHandler<dim>    dof_handler;\\n \\n AffineConstraints<double> constraints;\\n \\n SparsityPattern      sparsity_pattern;\\n SparseMatrix<double> mass_matrix;\\n SparseMatrix<double> laplace_matrix;\\n SparseMatrix<double> a_matrix;\\n SparseMatrix<double> b_matrix;\\n SparseMatrix<double> system_matrix;\\n \\n Vector<double> solution;\\n Vector<double> system_rhs;\\n \\n double time;\\n double time_step;\\n \\n const double       theta;\\n const unsigned int n_cycles;\\n const unsigned int n_time_steps;\\n \\n DataOutStack<dim>        data_out_stack;\\n    std::vector<std::string> solution_names;\\n \\n ConvergenceTable convergence_table;\\n  };\\n \\n \\n template <int dim>\\n  BlackScholes<dim>::BlackScholes()\\n    : maximum_stock_price(1.)\\n    , maturity_time(1.)\\n    , asset_volatility(.2)\\n    , interest_rate(0.05)\\n    , strike_price(0.5)\\n    , fe(1)\\n    , dof_handler(triangulation)\\n    , time(0.0)\\n    , theta(0.5)\\n    , n_cycles(4)\\n    , n_time_steps(5000)\\n  {\\n Assert(dim == 1, ExcNotImplemented());\\n  }\\n \\n \\n template <int dim>\\n void BlackScholes<dim>::setup_system()\\n  {\\n    dof_handler.distribute_dofs(fe);\\n \\n    time_step = maturity_time / n_time_steps;\\n \\n    constraints.clear();\\n DoFTools::make_hanging_node_constraints(dof_handler, constraints);\\n    constraints.close();\\n DynamicSparsityPattern dsp(dof_handler.n_dofs());\\n DoFTools::make_sparsity_pattern(dof_handler,\\n                                    dsp,\\n                                    constraints,\\n /*keep_constrained_dofs = */ true);\\n    sparsity_pattern.copy_from(dsp);\\n \\n mass_matrix.reinit(sparsity_pattern);\\n    laplace_matrix.reinit(sparsity_pattern);\\n    a_matrix.reinit(sparsity_pattern);\\n    b_matrix.reinit(sparsity_pattern);\\n    system_matrix.reinit(sparsity_pattern);\\n \\n MatrixCreator::create_mass_matrix(dof_handler,\\n QGauss<dim>(fe.degree + 1),\\n                                      mass_matrix);\\n \\n const unsigned int dofs_per_cell = fe.dofs_per_cell;\\n FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n const QGauss<dim>  quadrature_formula(fe.degree + 1);\\n FEValues<dim>      fe_values(fe,\\n                            quadrature_formula,\\n update_values | update_gradients |\\n update_quadrature_points | update_JxW_values);\\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n cell_matrix = 0.;\\n        fe_values.reinit(cell);\\n for (const unsigned int q_index : fe_values.quadrature_point_indices())\\n          {\\n const double current_coefficient =\\n              fe_values.quadrature_point(q_index).square();\\n for (const unsigned int i : fe_values.dof_indices())\\n              {\\n for (const unsigned int j : fe_values.dof_indices())\\n cell_matrix(i, j) +=\\n                    (current_coefficient *              // (x_q)^2\\n                     fe_values.shape_grad(i, q_index) * // grad phi_i(x_q)\\n                     fe_values.shape_grad(j, q_index) * // grad phi_j(x_q)\\n                     fe_values.JxW(q_index));           // dx\\n              }\\n          }\\n        cell->get_dof_indices(local_dof_indices);\\n for (const unsigned int i : fe_values.dof_indices())\\n          {\\n for (const unsigned int j : fe_values.dof_indices())\\n              laplace_matrix.add(local_dof_indices[i],\\n                                 local_dof_indices[j],\\n cell_matrix(i, j));\\n          }\\n      }\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n cell_matrix = 0.;\\n        fe_values.reinit(cell);\\n for (const unsigned int q_index : fe_values.quadrature_point_indices())\\n          {\\n const Tensor<1, dim> current_coefficient =\\n              fe_values.quadrature_point(q_index);\\n for (const unsigned int i : fe_values.dof_indices())\\n              {\\n for (const unsigned int j : fe_values.dof_indices())\\n                  {\\n cell_matrix(i, j) +=\\n                      (current_coefficient *               // x_q\\n                       fe_values.shape_grad(i, q_index) *  // grad phi_i(x_q)\\n                       fe_values.shape_value(j, q_index) * // phi_j(x_q)\\n                       fe_values.JxW(q_index));            // dx\\n                  }\\n              }\\n          }\\n        cell->get_dof_indices(local_dof_indices);\\n for (const unsigned int i : fe_values.dof_indices())\\n          {\\n for (const unsigned int j : fe_values.dof_indices())\\n              a_matrix.add(local_dof_indices[i],\\n                           local_dof_indices[j],\\n cell_matrix(i, j));\\n          }\\n      }\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n cell_matrix = 0.;\\n        fe_values.reinit(cell);\\n for (const unsigned int q_index : fe_values.quadrature_point_indices())\\n          {\\n const Tensor<1, dim> current_coefficient =\\n              fe_values.quadrature_point(q_index);\\n for (const unsigned int i : fe_values.dof_indices())\\n              {\\n for (const unsigned int j : fe_values.dof_indices())\\n cell_matrix(i, j) +=\\n                    (current_coefficient *               // x_q\\n                     fe_values.shape_value(i, q_index) * // phi_i(x_q)\\n                     fe_values.shape_grad(j, q_index) *  // grad phi_j(x_q)\\n                     fe_values.JxW(q_index));            // dx\\n              }\\n          }\\n        cell->get_dof_indices(local_dof_indices);\\n for (const unsigned int i : fe_values.dof_indices())\\n          {\\n for (const unsigned int j : fe_values.dof_indices())\\n              b_matrix.add(local_dof_indices[i],\\n                           local_dof_indices[j],\\n cell_matrix(i, j));\\n          }\\n      }\\n \\n    solution.reinit(dof_handler.n_dofs());\\n    system_rhs.reinit(dof_handler.n_dofs());\\n  }\\n \\n \\n template <int dim>\\n void BlackScholes<dim>::solve_time_step()\\n  {\\n SolverControl                          solver_control(1000, 1e-12);\\n SolverCG<Vector<double>>               cg(solver_control);\\n PreconditionSSOR<SparseMatrix<double>> preconditioner;\\n    preconditioner.initialize(system_matrix, 1.0);\\n    cg.solve(system_matrix, solution, system_rhs, preconditioner);\\n    constraints.distribute(solution);\\n  }\\n \\n \\n template <int dim>\\n void BlackScholes<dim>::add_results_for_output()\\n  {\\n    data_out_stack.new_parameter_value(time, time_step);\\n    data_out_stack.attach_dof_handler(dof_handler);\\n    data_out_stack.add_data_vector(solution, solution_names);\\n    data_out_stack.build_patches(2);\\n    data_out_stack.finish_parameter_value();\\n  }\\n \\n \\n template <int dim>\\n void BlackScholes<dim>::refine_grid()\\n  {\\n triangulation.refine_global(1);\\n  }\\n \\n \\n template <int dim>\\n void BlackScholes<dim>::process_solution()\\n  {\\n    Solution<dim> sol(maturity_time);\\n    sol.set_time(time);\\n Vector<float> difference_per_cell(triangulation.n_active_cells());\\n VectorTools::integrate_difference(dof_handler,\\n                                      solution,\\n                                      sol,\\n                                      difference_per_cell,\\n QGauss<dim>(fe.degree + 1),\\n VectorTools::L2_norm);\\n const double L2_error =\\n VectorTools::compute_global_error(triangulation,\\n                                        difference_per_cell,\\n VectorTools::L2_norm);\\n VectorTools::integrate_difference(dof_handler,\\n                                      solution,\\n                                      sol,\\n                                      difference_per_cell,\\n QGauss<dim>(fe.degree + 1),\\n VectorTools::H1_seminorm);\\n const double H1_error =\\n VectorTools::compute_global_error(triangulation,\\n                                        difference_per_cell,\\n VectorTools::H1_seminorm);\\n const QTrapezoid<1>  q_trapezoid;\\n const QIterated<dim> q_iterated(q_trapezoid, fe.degree * 2 + 1);\\n VectorTools::integrate_difference(dof_handler,\\n                                      solution,\\n                                      sol,\\n                                      difference_per_cell,\\n                                      q_iterated,\\n VectorTools::Linfty_norm);\\n const double Linfty_error =\\n VectorTools::compute_global_error(triangulation,\\n                                        difference_per_cell,\\n VectorTools::Linfty_norm);\\n const unsigned int n_active_cells = triangulation.n_active_cells();\\n const unsigned int n_dofs         = dof_handler.n_dofs();\\n    convergence_table.add_value(\\\"cells\\\", n_active_cells);\\n    convergence_table.add_value(\\\"dofs\\\", n_dofs);\\n    convergence_table.add_value(\\\"L2\\\", L2_error);\\n    convergence_table.add_value(\\\"H1\\\", H1_error);\\n    convergence_table.add_value(\\\"Linfty\\\", Linfty_error);\\n  }\\n \\n \\n template <int dim>\\n void BlackScholes<dim>::write_convergence_table()\\n  {\\n    convergence_table.set_precision(\\\"L2\\\", 3);\\n    convergence_table.set_precision(\\\"H1\\\", 3);\\n    convergence_table.set_precision(\\\"Linfty\\\", 3);\\n    convergence_table.set_scientific(\\\"L2\\\", true);\\n    convergence_table.set_scientific(\\\"H1\\\", true);\\n    convergence_table.set_scientific(\\\"Linfty\\\", true);\\n    convergence_table.set_tex_caption(\\\"cells\\\", \\\"\\\\\\\\# cells\\\");\\n    convergence_table.set_tex_caption(\\\"dofs\\\", \\\"\\\\\\\\# dofs\\\");\\n    convergence_table.set_tex_caption(\\\"L2\\\", \\\"@f@f$L^2@f@f$-error\\\");\\n    convergence_table.set_tex_caption(\\\"H1\\\", \\\"@f@f$H^1@f@f$-error\\\");\\n    convergence_table.set_tex_caption(\\\"Linfty\\\", \\\"@f@f$L^\\\\\\\\infty@f@f$-error\\\");\\n    convergence_table.set_tex_format(\\\"cells\\\", \\\"r\\\");\\n    convergence_table.set_tex_format(\\\"dofs\\\", \\\"r\\\");\\n    std::cout << std::endl;\\n    convergence_table.write_text(std::cout);\\n    std::string error_filename = \\\"error\\\";\\n    error_filename += \\\"-global\\\";\\n    error_filename += \\\".tex\\\";\\n    std::ofstream error_table_file(error_filename);\\n    convergence_table.write_tex(error_table_file);\\n \\n    convergence_table.add_column_to_supercolumn(\\\"cells\\\", \\\"n cells\\\");\\n    std::vector<std::string> new_order;\\n    new_order.emplace_back(\\\"n cells\\\");\\n    new_order.emplace_back(\\\"H1\\\");\\n    new_order.emplace_back(\\\"L2\\\");\\n    convergence_table.set_column_order(new_order);\\n    convergence_table.evaluate_convergence_rates(\\n \\\"L2\\\", ConvergenceTable::reduction_rate);\\n    convergence_table.evaluate_convergence_rates(\\n \\\"L2\\\", ConvergenceTable::reduction_rate_log2);\\n    convergence_table.evaluate_convergence_rates(\\n \\\"H1\\\", ConvergenceTable::reduction_rate);\\n    convergence_table.evaluate_convergence_rates(\\n \\\"H1\\\", ConvergenceTable::reduction_rate_log2);\\n    std::cout << std::endl;\\n    convergence_table.write_text(std::cout);\\n    std::string conv_filename = \\\"convergence\\\";\\n    conv_filename += \\\"-global\\\";\\n switch (fe.degree)\\n      {\\n case 1:\\n          conv_filename += \\\"-q1\\\";\\n break;\\n case 2:\\n          conv_filename += \\\"-q2\\\";\\n break;\\n default:\\n DEAL_II_NOT_IMPLEMENTED();\\n      }\\n    conv_filename += \\\".tex\\\";\\n    std::ofstream table_file(conv_filename);\\n    convergence_table.write_tex(table_file);\\n  }\\n \\n \\n template <int dim>\\n void BlackScholes<dim>::run()\\n  {\\n GridGenerator::hyper_cube(triangulation, 0.0, maximum_stock_price, true);\\n triangulation.refine_global(0);\\n \\n    solution_names.emplace_back(\\\"u\\\");\\n    data_out_stack.declare_data_vector(solution_names,\\n DataOutStack<dim>::dof_vector);\\n \\n Vector<double> vmult_result;\\n Vector<double> forcing_terms;\\n \\n for (unsigned int cycle = 0; cycle < n_cycles; ++cycle)\\n      {\\n if (cycle != 0)\\n          {\\n            refine_grid();\\n            time = 0.0;\\n          }\\n \\n        setup_system();\\n \\n        std::cout << std::endl\\n                  << \\\"===========================================\\\" << std::endl\\n                  << \\\"Cycle \\\" << cycle << ':' << std::endl\\n                  << \\\"Number of active cells: \\\"\\n                  << triangulation.n_active_cells() << std::endl\\n                  << \\\"Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n                  << std::endl\\n                  << std::endl;\\n \\n VectorTools::interpolate(dof_handler,\\n                                 InitialConditions<dim>(strike_price),\\n                                 solution);\\n \\n if (cycle == (n_cycles - 1))\\n          {\\n            add_results_for_output();\\n          }\\n \\n        vmult_result.reinit(dof_handler.n_dofs());\\n        forcing_terms.reinit(dof_handler.n_dofs());\\n for (unsigned int timestep_number = 0; timestep_number < n_time_steps;\\n             ++timestep_number)\\n          {\\n            time += time_step;\\n \\n if (timestep_number % 1000 == 0)\\n              std::cout << \\\"Time step \\\" << timestep_number << \\\" at t=\\\" << time\\n                        << std::endl;\\n \\n mass_matrix.vmult(system_rhs, solution);\\n \\n            laplace_matrix.vmult(vmult_result, solution);\\n            system_rhs.add(\\n              (-1) * (1 - theta) * time_step *\\n Utilities::fixed_power<2, double>(asset_volatility) * 0.5,\\n              vmult_result);\\n mass_matrix.vmult(vmult_result, solution);\\n \\n            system_rhs.add((-1) * (1 - theta) * time_step * interest_rate * 2,\\n                           vmult_result);\\n \\n            a_matrix.vmult(vmult_result, solution);\\n            system_rhs.add((-1) * time_step * interest_rate, vmult_result);\\n \\n            b_matrix.vmult(vmult_result, solution);\\n            system_rhs.add(\\n              (-1) * Utilities::fixed_power<2, double>(asset_volatility) *\\n                time_step * 1,\\n              vmult_result);\\n \\n            RightHandSide<dim> rhs_function(asset_volatility, interest_rate);\\n            rhs_function.set_time(time);\\n VectorTools::create_right_hand_side(dof_handler,\\n QGauss<dim>(fe.degree + 1),\\n                                                rhs_function,\\n                                                forcing_terms);\\n            forcing_terms *= time_step * theta;\\n            system_rhs -= forcing_terms;\\n \\n            rhs_function.set_time(time - time_step);\\n VectorTools::create_right_hand_side(dof_handler,\\n QGauss<dim>(fe.degree + 1),\\n                                                rhs_function,\\n                                                forcing_terms);\\n            forcing_terms *= time_step * (1 - theta);\\n            system_rhs -= forcing_terms;\\n \\n            system_matrix.copy_from(mass_matrix);\\n            system_matrix.add(\\n              (theta)*time_step *\\n Utilities::fixed_power<2, double>(asset_volatility) * 0.5,\\n              laplace_matrix);\\n            system_matrix.add((time_step)*interest_rate * theta * (1 + 1),\\n                              mass_matrix);\\n \\n            constraints.condense(system_matrix, system_rhs);\\n \\n            {\\n              RightBoundaryValues<dim> right_boundary_function(strike_price,\\n                                                               interest_rate);\\n              LeftBoundaryValues<dim>  left_boundary_function;\\n              right_boundary_function.set_time(time);\\n              left_boundary_function.set_time(time);\\n              std::map<types::global_dof_index, double> boundary_values;\\n VectorTools::interpolate_boundary_values(dof_handler,\\n                                                       0,\\n                                                       left_boundary_function,\\n                                                       boundary_values);\\n VectorTools::interpolate_boundary_values(dof_handler,\\n                                                       1,\\n                                                       right_boundary_function,\\n                                                       boundary_values);\\n MatrixTools::apply_boundary_values(boundary_values,\\n                                                 system_matrix,\\n                                                 solution,\\n                                                 system_rhs);\\n            }\\n \\n            solve_time_step();\\n \\n if (cycle == (n_cycles - 1))\\n              {\\n                add_results_for_output();\\n              }\\n          }\\n#ifdef MMS\\n        process_solution();\\n#endif\\n      }\\n \\n const std::string filename = \\\"solution.vtk\\\";\\n    std::ofstream     output(filename);\\n    data_out_stack.write_vtk(output);\\n \\n#ifdef MMS\\n    write_convergence_table();\\n#endif\\n  }\\n \\n} // namespace BlackScholesSolver\\n \\n \\nint main()\\n{\\n try\\n    {\\n using namespace BlackScholesSolver;\\n \\n      BlackScholes<1> black_scholes_solver;\\n      black_scholes_solver.run();\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n return 0;\\n}\\naffine_constraints.h\\nVector::addvoid add(const std::vector< size_type > &indices, const std::vector< OtherNumber > &values)\\nVector::reinitvirtual void reinit(const size_type N, const bool omit_zeroing_entries=false)\\nconvergence_table.h\\ndata_out_stack.h\\ndof_accessor.h\\ndof_handler.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nerror_estimator.h\\nfe_values.h\\nfe_q.h\\nfull_matrix.h\\nfunction.h\\ngrid_refinement.h\\ntria.h\\ngrid_generator.h\\ngrid_out.h\\nutilities.h\\nmatrix_creator.h\\nmatrix_tools.h\\nLocalIntegrators::L2::mass_matrixvoid mass_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const double factor=1.)Definition l2.h:57\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\ninternal::TriangulationImplementation::n_active_cellsunsigned int n_active_cells(const internal::TriangulationImplementation::NumberCache< 1 > &c)Definition tria.cc:14890\\nstd::exp::VectorizedArray< Number, width > exp(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6829\\ndata_out.h\\nsolution_transfer.h\\nprecondition.h\\nquadrature_lib.h\\nsolver_cg.h\\nsparse_matrix.h\\ntria_accessor.h\\ntria_iterator.h\\nvector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"