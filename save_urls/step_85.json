"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_85.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-85 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-85 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-85 tutorial program\\n\\n\\nThis tutorial depends on step-12.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nThe Cut Finite Element Method\\nDiscrete Level Set Function\\nThe MeshClassifier Class\\n\\n The commented program\\n\\nInclude files\\nThe LaplaceSolver class Template\\nSetting up the Background Mesh\\nSetting up the Discrete Level Set Function\\nSetting up the Finite Element Space\\nSparsity Pattern\\nAssembling the System\\nSolving the System\\nData Output\\nL2-Error\\nA Convergence Study\\nThe main() function\\n\\n\\n Results\\n\\n\\n The plain program\\n   \\n This program was contributed by Simon Sticko.\\nThe material is based upon work partially supported by eSSENCE of e-Science and the Swedish Research Council under grants 2014-6088 (Kreiss) and 2017-05038 (Massing). \\n Introduction\\nThe Cut Finite Element Method\\nIn this example, we show how to use the cut finite element method (CutFEM) in deal.II. For illustration, we want to solve the simplest possible problem, so we again consider Poisson's equation:     \\n\\\\begin{align*}\\n  -\\\\Delta u &= f \\\\qquad && \\\\text{in }\\\\, \\\\Omega,\\n  \\\\\\\\\\n  u &= u_D       \\\\qquad && \\\\text{on }\\\\, \\\\Gamma = \\\\partial \\\\Omega,\\n\\\\end{align*}\\n\\n where we choose \\\\(f(x) = 4\\\\) and \\\\(u_D(x) = 1\\\\). CutFEM is an immersed method. In this context, \\\"immersed\\\" means that the mesh is unfitted to the geometry of the domain, \\\\(\\\\Omega\\\\). Instead, \\\\(\\\\Omega\\\\) floats freely on top of a uniform background mesh, \\\\(\\\\mathcal{T}^h\\\\). \\n\\n\\n Since we no longer use the mesh to describe the geometry of the domain, we need some other way to represent it. This can be done in several ways but here we assume that \\\\(\\\\Omega\\\\) is described by a level set function, \\\\(\\\\psi : \\\\mathbb{R}^{\\\\text{dim}} \\\\to \\\\mathbb{R}\\\\) such that    \\n\\\\begin{align*}\\n  \\\\Omega &= \\\\{x \\\\in \\\\mathbb{R}^{\\\\text{dim}} : \\\\psi(x) < 0 \\\\}, \\\\\\\\\\n  \\\\Gamma &= \\\\{x \\\\in \\\\mathbb{R}^{\\\\text{dim}} : \\\\psi(x) = 0 \\\\}.\\n\\\\end{align*}\\n\\n For simplicity, we choose \\\\(\\\\Omega\\\\) to be a unit disk, so that   \\n\\\\begin{equation*}\\n  \\\\psi(x) = \\\\| x \\\\| - 1.\\n\\\\end{equation*}\\n\\n As can be seen from the figure below, the level set function is negative for points in \\\\(\\\\Omega\\\\), zero on the boundary, and positive everywhere else. \\n\\n\\n To solve this problem, we want to distribute degrees of freedom over the smallest submesh, \\\\(\\\\mathcal{T}_\\\\Omega^h\\\\), that completely covers the domain:   \\n\\\\begin{equation*}\\n  \\\\mathcal{T}_\\\\Omega^h = \\\\{ T \\\\in \\\\mathcal{T}^{h} : T \\\\cap \\\\Omega \\\\neq \\\\emptyset \\\\}.\\n\\\\end{equation*}\\n\\n This is usually referred to as the \\\"active mesh\\\". \\n\\n\\n The finite element space where we want to find our numerical solution, \\\\(u_h\\\\), is now   \\n\\\\begin{equation*}\\n  V_\\\\Omega^h = \\\\{ v \\\\in C(\\\\mathcal{N}_\\\\Omega^h) : v \\\\in Q_p(T), \\\\, T \\\\in \\\\mathcal{T}_\\\\Omega^h \\\\},\\n\\\\end{equation*}\\n\\n where   \\n\\\\begin{equation*}\\n  \\\\mathcal{N}_\\\\Omega^h = \\\\bigcup_{T \\\\in \\\\mathcal{T}_\\\\Omega^h} \\\\overline{T},\\n\\\\end{equation*}\\n\\n and \\\\(\\\\overline{T}\\\\) denotes the closure of \\\\(T\\\\). The set \\\\(\\\\mathcal{N}_\\\\Omega^h\\\\) is sometimes referred to as the \\\"fictitious domain\\\". Since \\\\(\\\\Omega \\\\subset \\\\mathcal{N}_\\\\Omega^h\\\\), we see that the numerical solution is defined over a slightly larger region than the analytical solution.\\nIn this type of immersed finite element method, the standard way to apply boundary conditions is using Nitsche's method. Multiplying the PDE with a test function, \\\\(v_h \\\\in V_\\\\Omega^h\\\\), and integrating by parts over \\\\(\\\\Omega\\\\), as usual, gives us   \\n\\\\begin{equation*}\\n  (\\\\nabla u_h, \\\\nabla v_h)_\\\\Omega - (\\\\partial_n u_h, v_h)_\\\\Gamma = (f,v)_\\\\Omega.\\n\\\\end{equation*}\\n\\n Let \\\\(\\\\gamma_D > 0\\\\) be a scalar penalty parameter and let \\\\(h\\\\) be some measure of the local cell size. We now note that the following terms are consistent with the Dirichlet boundary condition:    \\n\\\\begin{align*}\\n  -(u_h, \\\\partial_n v_h)_\\\\Gamma &= -(u_D, \\\\partial_n v_h)_\\\\Gamma, \\\\\\\\\\n  \\\\left (\\\\frac{\\\\gamma_D}{h} u_h, v_h \\\\right )_\\\\Gamma &= \\\\left (\\\\frac{\\\\gamma_D}{h}u_D, v_h \\\\right )_\\\\Gamma.\\n\\\\end{align*}\\n\\n Thus, we can add these to the weak formulation to enforce the boundary condition. This leads to the following weak formulation: Find \\\\(u_h \\\\in V_\\\\Omega^h\\\\) such that   \\n\\\\begin{equation*}\\n  a_h(u_h, v_h) = L_h(v_h), \\\\quad \\\\forall v_h \\\\in V_\\\\Omega^h,\\n\\\\end{equation*}\\n\\n where         \\n\\\\begin{align*}\\n  a_h(u_h, v_h) &=  (\\\\nabla u_h, \\\\nabla v_h)_\\\\Omega\\n                  - (\\\\partial_n u_h, v_h)_\\\\Gamma\\n                  - (u_h, \\\\partial_n v_h)_\\\\Gamma\\n                  + \\\\left (\\\\frac{\\\\gamma_D}{h} u_h, v_h \\\\right )_\\\\Gamma,\\n  \\\\\\\\\\n  L_h(v_h)      &=  (f,v)_\\\\Omega\\n                  + \\\\left (u_D, \\\\frac{\\\\gamma_D}{h} v_h -\\\\partial_n v_h \\\\right )_\\\\Gamma.\\n\\\\end{align*}\\n\\n In this formulation, there is one big difference, compared to a standard boundary-fitted finite element method. On each cell, we need to integrate over the part of the domain and the part of the boundary that falls within the cell. Thus, on each cell intersected by \\\\(\\\\Gamma\\\\), we need special quadrature rules that only integrate over these parts of the cell, that is, over \\\\(T \\\\cap \\\\Omega\\\\) and \\\\(T \\\\cap \\\\Gamma\\\\). \\n\\n\\n Since \\\\(\\\\Omega \\\\cap T\\\\) is the part of the cell that lies inside the domain, we shall refer to the following regions     \\n\\\\begin{align*}\\n  \\\\{x \\\\in T : \\\\psi(x) < 0 \\\\}, \\\\\\\\\\n  \\\\{x \\\\in T : \\\\psi(x) > 0 \\\\}, \\\\\\\\\\n  \\\\{x \\\\in T : \\\\psi(x) = 0 \\\\},\\n\\\\end{align*}\\n\\n as the \\\"inside\\\", \\\"outside\\\" and the \\\"surface region\\\" of the cell \\\\(T\\\\).\\nThe above finite element method that uses the bilinear form \\\\(a_h(\\\\cdot, \\\\cdot)\\\\) is sometimes referred to as the \\\"naive weak formulation\\\" because it suffers from the so-called \\\"small cut problem\\\". Depending on how \\\\(\\\\Omega\\\\) is located relative to \\\\(\\\\mathcal{T}_h\\\\), a cut between a cell, \\\\(T \\\\in \\\\mathcal{T}_h\\\\), and \\\\(\\\\Omega\\\\) can become arbitrarily small: \\\\(|\\\\Omega \\\\cap T | \\\\rightarrow 0\\\\). For Neumann boundary conditions, the consequence is that the stiffness matrix can become arbitrarily ill-conditioned as the cut-size approaches zero. For a Dirichlet condition, the situation is even worse. For any finite choice of Nitsche constant, \\\\(\\\\gamma_D\\\\), the bilinear form \\\\(a_h(\\\\cdot,\\\\cdot)\\\\) loses coercivity as the size of a cell cut approaches zero. This makes the above weak formulation essentially useless because as we refine we typically can not control how the cells intersect \\\\(\\\\Gamma\\\\). One way to avoid this problem is to add a so-called ghost penalty term, \\\\(g_h\\\\), to the weak formulation (see e.g. [50] and [51]). This leads to the stabilized cut finite element method, which reads: Find \\\\(u_h \\\\in V_\\\\Omega^h\\\\) such that   \\n\\\\begin{equation*}\\n  A_h(u_h, v_h) = L_h(v_h), \\\\quad \\\\forall v_h \\\\in V_\\\\Omega^h,\\n\\\\end{equation*}\\n\\n where   \\n\\\\begin{equation*}\\n  A_h(u_h,v_h) = a_h(u_h,v_h) + g_h(u_h, v_h).\\n\\\\end{equation*}\\n\\n The point of this ghost penalty is that it makes the numerical method essentially independent of how \\\\(\\\\Omega\\\\) relates to the background mesh. In particular, \\\\(A_h\\\\) can be shown to be continuous and coercive, with constants that do not depend on how \\\\(\\\\Omega\\\\) intersects \\\\(\\\\mathcal{T}^h\\\\). To define the ghost penalty, let \\\\(\\\\mathcal{T}_\\\\Gamma^h\\\\) be the set of intersected cells:   \\n\\\\begin{equation*}\\n  \\\\mathcal{T}_{\\\\Gamma}^h = \\\\{ T \\\\in \\\\mathcal{T}_{\\\\Omega}^{h} : T \\\\cap \\\\Gamma \\\\neq \\\\emptyset \\\\},\\n\\\\end{equation*}\\n\\n and let \\\\(\\\\mathcal{F}_h\\\\) denote the interior faces of the intersected cells in the active mesh:      \\n\\\\begin{equation*}\\n  \\\\mathcal{F}_h = \\\\{ F = \\\\overline{T}_+ \\\\cap \\\\overline{T}_- : \\\\,\\n                     T_+ \\\\in \\\\mathcal{T}_{\\\\Gamma}^h, \\\\,\\n                     T_- \\\\in \\\\mathcal{T}_{\\\\Omega}^h\\n                  \\\\}.\\n\\\\end{equation*}\\n\\n\\n\\n\\n The ghost penalty acts on these faces and reads   \\n\\\\begin{equation*}\\n  g_h(u_h,v_h) = \\\\gamma_A \\\\sum_{F \\\\in \\\\mathcal{F}_h} g_F(u_h, v_h),\\n\\\\end{equation*}\\n\\n where \\\\(g_F\\\\) is the face-wise ghost penalty:   \\n\\\\begin{equation*}\\n  g_F(u_h, v_h) = \\\\gamma_A \\\\sum_{k=0}^p \\\\left(\\\\frac{h_F^{2k-1}}{k!^2}[\\\\partial_n^k u_h], [\\\\partial_n^k v_h] \\\\right)_F.\\n\\\\end{equation*}\\n\\n Here, \\\\(\\\\gamma_A\\\\) is a penalty parameter and \\\\(h_F\\\\) is some measure of the face size. We see that \\\\(g_F\\\\) penalizes the jumps in the face-normal derivatives, \\\\(\\\\partial_n^k\\\\), over \\\\(F = \\\\overline{T}_+ \\\\cap \\\\overline{T}_-\\\\). Since we include all normal derivatives up to the polynomial degree, we weakly force the piecewise polynomial to behave as a single polynomial over \\\\(\\\\overline{T}_+ \\\\cup \\\\overline{T}_-\\\\). Hand-wavingly speaking, this is the reason why we obtain a cut-independent method when we enforce \\\\(g_F(u_h, v_h) = 0\\\\) over the faces in \\\\(\\\\mathcal{F}_h\\\\). Here, we shall use a continuous space of \\\\(Q_1\\\\)-elements, so the ghost penalty is reduced to   \\n\\\\begin{equation*}\\n  g_h(u_h,v_h) = \\\\gamma_A \\\\sum_{F \\\\in \\\\mathcal{F}_h} (h_F [\\\\partial_n u_h], [\\\\partial_n v_h])_F.\\n\\\\end{equation*}\\n\\nDiscrete Level Set Function\\nA typical use case of a level set method is a problem where the domain is advected in a velocity field, such that the domain deforms with time. For such a problem, one would typically solve for an approximation of the level set function, \\\\(\\\\psi_h \\\\in V^h\\\\), in a separate finite element space over the whole background mesh:   \\n\\\\begin{equation*}\\n  V^h = \\\\{ v \\\\in C(\\\\mathcal{N}^h) : v \\\\in Q_p(T), \\\\, T \\\\in \\\\mathcal{T}^h \\\\},\\n\\\\end{equation*}\\n\\n where \\\\(\\\\mathcal{N}^h = \\\\bigcup_{T \\\\in \\\\mathcal{T}^h} \\\\overline{T}\\\\). Even if we solve a much simpler problem with a stationary domain in this tutorial, we shall, just to illustrate, still use a discrete level set function for the Poisson problem. Technically, this is a so-called \\\"variational crime\\\" because we are actually not using the bilinear form \\\\(a_h\\\\) but instead    \\n\\\\begin{equation*}\\n  a_h^\\\\star(u_h, v_h) = (\\\\nabla u_h, \\\\nabla v_h)_{\\\\Omega_h}\\n                      - (\\\\partial_n u_h, v_h)_{\\\\Gamma_h} + \\\\ldots\\n\\\\end{equation*}\\n\\n This is an approximation of \\\\(a_h\\\\) since we integrate over the approximations of the geometry that we get via the discrete level set function:    \\n\\\\begin{align*}\\n  \\\\Omega_h &= \\\\{x \\\\in \\\\mathbb{R}^{\\\\text{dim}} : \\\\psi_h(x) < 0 \\\\}, \\\\\\\\\\n  \\\\Gamma_h &= \\\\{x \\\\in \\\\mathbb{R}^{\\\\text{dim}} : \\\\psi_h(x) = 0 \\\\}.\\n\\\\end{align*}\\n\\n Using \\\\(\\\\Omega_h\\\\) instead of \\\\(\\\\Omega\\\\) in the method will give rise to a larger error in the numerical solution. This is often referred to as the \\\"geometrical error\\\". However, when the same element order, \\\\(p\\\\), is used in \\\\(V^h\\\\) and \\\\(V_\\\\Omega^h\\\\), one can often show that the method gives the same order of convergence as if the exact domain would have been used. Furthermore, deal.II allows us to independently choose a more accurate geometry representation with a higher-order level set function, compared to the function space for solving the Poisson equation.\\nThe MeshClassifier Class\\nEven if we have used \\\\(\\\\mathcal{T}_\\\\Omega^h\\\\) to define the finite element space, we will not create this submesh in practice. As in step-46, we shall instead use the hp-framework. To create \\\\(V_\\\\Omega^h\\\\), we first add an FE_Q and an FE_Nothing element to an hp::FECollection. We then iterate over each cell, \\\\(T\\\\), and depending on whether \\\\(T\\\\) belongs to \\\\(\\\\mathcal{T}_\\\\Omega^h\\\\) or not, we set the active_fe_index to either 0 or 1. To do so, we need to determine if a given cell is in \\\\(\\\\mathcal{T}_\\\\Omega^h\\\\) or not. For this purpose, we will use the class NonMatching::MeshClassifier. The NonMatching::MeshClassifier takes the discrete level set function, described as a (DoFHandler, Vector)-pair, as arguments to its constructor: MeshClassifier(const DoFHandler<dim> &level_set_dof_handler,\\n const VectorType &     level_set);\\nDoFHandlerDefinition dof_handler.h:317\\n When we call the reclassify() function on an object of this class, each active cell and face is associated with one of the values {inside, outside, intersected} of the enum NonMatching::LocationToLevelSet. Here, \\\"inside\\\" means that the level set function is negative over the whole cell so that it lies completely inside the domain. Analogously, \\\"outside\\\" means that \\\\(\\\\psi\\\\) is positive over the whole cell, and \\\"intersected\\\" means that \\\\(\\\\psi\\\\) varies in sign over \\\\(T\\\\) so that the zero-contour of \\\\(\\\\psi\\\\) goes through \\\\(T\\\\).\\n\\n\\nLocationToLevelSet   \\\\(\\\\psi(x)\\\\) for \\\\(x \\\\in T\\\\)   Relation to \\\\(\\\\Omega\\\\)    \\n\\ninside   \\\\(\\\\psi(x) < 0\\\\)   \\\\(T \\\\cap \\\\Omega = T\\\\)    \\n\\noutside   \\\\(0 < \\\\psi(x)\\\\)   \\\\(T \\\\cap \\\\Omega = \\\\emptyset\\\\)    \\n\\nintersected   \\\\(\\\\psi(x)\\\\) varies in sign   \\\\(T \\\\cap \\\\Gamma \\\\neq \\\\emptyset\\\\)   \\n\\nEach active face is classified in the same way, according to how the sign of \\\\(\\\\psi\\\\) varies over the face. NonMatching::MeshClassifier lets you query this information for a given cell/face via its NonMatching::MeshClassifier::location_to_level_set() methods: NonMatching::MeshClassifier<dim> mesh_classifier(dof_handler, level_set);\\nmesh_classifier.reclassify();\\n \\nfor (const auto &cell : triangulation.active_cell_iterators())\\n  {\\n NonMatching::LocationToLevelSet cell_location =\\n      mesh_classifier.location_to_level_set(cell);\\n \\n for (const unsigned int f : cell->face_indices())\\n      {\\n NonMatching::LocationToLevelSet face_location =\\n          mesh_classifier.location_to_level_set(cell, f);\\n      }\\n  }\\nNonMatching::MeshClassifierDefinition mesh_classifier.h:109\\nNonMatching::LocationToLevelSetLocationToLevelSetDefinition mesh_classifier.h:55\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\n The commented program\\n Include files\\nThe first include files have all been treated in previous examples.\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/base/convergence_table.h>\\n\\u00a0 #include <deal.II/base/point.h>\\n\\u00a0 #include <deal.II/base/quadrature.h>\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/tensor.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_interface_values.h>\\n\\u00a0 #include <deal.II/fe/fe_nothing.h>\\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_update_flags.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/filtered_iterator.h>\\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/hp/fe_collection.h>\\n\\u00a0 #include <deal.II/hp/q_collection.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/precondition.h>\\n\\u00a0 #include <deal.II/lac/solver_cg.h>\\n\\u00a0 #include <deal.II/lac/solver_control.h>\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 \\n\\u00a0 #include <fstream>\\n\\u00a0 #include <vector>\\n\\u00a0 \\nhpDefinition hp.h:117\\nThe first new header contains some common level set functions. For example, the spherical geometry that we use here.\\n\\u00a0 #include <deal.II/base/function_signed_distance.h>\\n\\u00a0 \\nWe also need 3 new headers from the NonMatching namespace.\\n\\u00a0 #include <deal.II/non_matching/fe_immersed_values.h>\\n\\u00a0 #include <deal.II/non_matching/fe_values.h>\\n\\u00a0 #include <deal.II/non_matching/mesh_classifier.h>\\n\\u00a0 \\n The LaplaceSolver class Template\\nWe then define the main class that solves the Laplace problem.\\n\\u00a0 namespace Step85\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   class LaplaceSolver\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     LaplaceSolver();\\n\\u00a0 \\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void make_grid();\\n\\u00a0 \\n\\u00a0     void setup_discrete_level_set();\\n\\u00a0 \\n\\u00a0     void distribute_dofs();\\n\\u00a0 \\n\\u00a0     void initialize_matrices();\\n\\u00a0 \\n\\u00a0     void assemble_system();\\n\\u00a0 \\n\\u00a0     void solve();\\n\\u00a0 \\n\\u00a0     void output_results() const;\\n\\u00a0 \\n\\u00a0     double compute_L2_error() const;\\n\\u00a0 \\n\\u00a0     bool face_has_ghost_penalty(\\n\\u00a0       const typename Triangulation<dim>::active_cell_iterator &cell,\\n\\u00a0       const unsigned int face_index) const;\\n\\u00a0 \\n\\u00a0     const unsigned int fe_degree;\\n\\u00a0 \\n\\u00a0     const Functions::ConstantFunction<dim> rhs_function;\\n\\u00a0     const Functions::ConstantFunction<dim> boundary_condition;\\n\\u00a0 \\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0 \\nFunctions::ConstantFunctionDefinition function.h:410\\nTriaActiveIteratorDefinition tria_iterator.h:755\\nTriangulationDefinition tria.h:1323\\ndealiiDefinition namespace_dealii.h:25\\nWe need two separate DoFHandlers. The first manages the DoFs for the discrete level set function that describes the geometry of the domain.\\n\\u00a0     const FE_Q<dim> fe_level_set;\\n\\u00a0     DoFHandler<dim> level_set_dof_handler;\\n\\u00a0     Vector<double>  level_set;\\n\\u00a0 \\nFE_QDefinition fe_q.h:554\\nVectorDefinition vector.h:120\\nThe second DoFHandler manages the DoFs for the solution of the Poisson equation.\\n\\u00a0     hp::FECollection<dim> fe_collection;\\n\\u00a0     DoFHandler<dim>       dof_handler;\\n\\u00a0     Vector<double>        solution;\\n\\u00a0 \\n\\u00a0     NonMatching::MeshClassifier<dim> mesh_classifier;\\n\\u00a0 \\n\\u00a0     SparsityPattern      sparsity_pattern;\\n\\u00a0     SparseMatrix<double> stiffness_matrix;\\n\\u00a0     Vector<double>       rhs;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   LaplaceSolver<dim>::LaplaceSolver()\\n\\u00a0     : fe_degree(1)\\n\\u00a0     , rhs_function(4.0)\\n\\u00a0     , boundary_condition(1.0)\\n\\u00a0     , fe_level_set(fe_degree)\\n\\u00a0     , level_set_dof_handler(triangulation)\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0     , mesh_classifier(level_set_dof_handler, level_set)\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nSparseMatrixDefinition sparse_matrix.h:520\\nSparsityPatternDefinition sparsity_pattern.h:343\\nhp::FECollectionDefinition fe_collection.h:61\\n Setting up the Background Mesh\\nWe generate a background mesh with perfectly Cartesian cells. Our domain is a unit disc centered at the origin, so we need to make the background mesh a bit larger than \\\\([-1, 1]^{\\\\text{dim}}\\\\) to completely cover \\\\(\\\\Omega\\\\).\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceSolver<dim>::make_grid()\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"Creating background mesh\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     GridGenerator::hyper_cube(triangulation, -1.21, 1.21);\\n\\u00a0     triangulation.refine_global(2);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nGridGenerator::hyper_cubevoid hyper_cube(Triangulation< dim, spacedim > &tria, const double left=0., const double right=1., const bool colorize=false)\\n Setting up the Discrete Level Set Function\\nThe discrete level set function is defined on the whole background mesh. Thus, to set up the DoFHandler for the level set function, we distribute DoFs over all elements in \\\\(\\\\mathcal{T}_h\\\\). We then set up the discrete level set function by interpolating onto this finite element space.\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceSolver<dim>::setup_discrete_level_set()\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"Setting up discrete level set function\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     level_set_dof_handler.distribute_dofs(fe_level_set);\\n\\u00a0     level_set.reinit(level_set_dof_handler.n_dofs());\\n\\u00a0 \\n\\u00a0     const Functions::SignedDistance::Sphere<dim> signed_distance_sphere;\\n\\u00a0     VectorTools::interpolate(level_set_dof_handler,\\n\\u00a0                              signed_distance_sphere,\\n\\u00a0                              level_set);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFunctions::SignedDistance::SphereDefinition function_signed_distance.h:49\\nVectorTools::interpolatevoid interpolate(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const Function< spacedim, typename VectorType::value_type > &function, VectorType &vec, const ComponentMask &component_mask={})\\n Setting up the Finite Element Space\\nTo set up the finite element space \\\\(V_\\\\Omega^h\\\\), we will use 2 different elements: FE_Q and FE_Nothing. For better readability we define an enum for the indices in the order we store them in the hp::FECollection.\\n\\u00a0   enum ActiveFEIndex\\n\\u00a0   {\\n\\u00a0     lagrange = 0,\\n\\u00a0     nothing  = 1\\n\\u00a0   };\\n\\u00a0 \\nWe then use the MeshClassifier to check LocationToLevelSet for each cell in the mesh and tell the DoFHandler to use FE_Q on elements that are inside or intersected, and FE_Nothing on the elements that are outside.\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceSolver<dim>::distribute_dofs()\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"Distributing degrees of freedom\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     fe_collection.push_back(FE_Q<dim>(fe_degree));\\n\\u00a0     fe_collection.push_back(FE_Nothing<dim>());\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         const NonMatching::LocationToLevelSet cell_location =\\n\\u00a0           mesh_classifier.location_to_level_set(cell);\\n\\u00a0 \\n\\u00a0         if (cell_location == NonMatching::LocationToLevelSet::outside)\\n\\u00a0           cell->set_active_fe_index(ActiveFEIndex::nothing);\\n\\u00a0         else\\n\\u00a0           cell->set_active_fe_index(ActiveFEIndex::lagrange);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     dof_handler.distribute_dofs(fe_collection);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFE_NothingDefinition fe_nothing.h:131\\nNonMatchingDefinition mapping.h:54\\nNonMatching::LocationToLevelSet::outside@ outside\\n Sparsity Pattern\\nThe added ghost penalty results in a sparsity pattern similar to a DG method with a symmetric-interior-penalty term. Thus, we can use the make_flux_sparsity_pattern() function to create it. However, since the ghost-penalty terms only act on the faces in \\\\(\\\\mathcal{F}_h\\\\), we can pass in a lambda function that tells make_flux_sparsity_pattern() over which faces the flux-terms appear. This gives us a sparsity pattern with minimal number of entries. When passing a lambda function, make_flux_sparsity_pattern requires us to also pass cell and face coupling tables to it. If the problem was vector-valued, these tables would allow us to couple only some of the vector components. This is discussed in step-46.\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceSolver<dim>::initialize_matrices()\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"Initializing matrices\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     const auto face_has_flux_coupling = [&](const auto        &cell,\\n\\u00a0                                             const unsigned int face_index) {\\n\\u00a0       return this->face_has_ghost_penalty(cell, face_index);\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());\\n\\u00a0 \\n\\u00a0     const unsigned int           n_components = fe_collection.n_components();\\n\\u00a0     Table<2, DoFTools::Coupling> cell_coupling(n_components, n_components);\\n\\u00a0     Table<2, DoFTools::Coupling> face_coupling(n_components, n_components);\\n\\u00a0     cell_coupling[0][0] = DoFTools::always;\\n\\u00a0     face_coupling[0][0] = DoFTools::always;\\n\\u00a0 \\n\\u00a0     const AffineConstraints<double> constraints;\\n\\u00a0     const bool                      keep_constrained_dofs = true;\\n\\u00a0 \\n\\u00a0     DoFTools::make_flux_sparsity_pattern(dof_handler,\\n\\u00a0                                          dsp,\\n\\u00a0                                          constraints,\\n\\u00a0                                          keep_constrained_dofs,\\n\\u00a0                                          cell_coupling,\\n\\u00a0                                          face_coupling,\\n\\u00a0                                          numbers::invalid_subdomain_id,\\n\\u00a0                                          face_has_flux_coupling);\\n\\u00a0     sparsity_pattern.copy_from(dsp);\\n\\u00a0 \\n\\u00a0     stiffness_matrix.reinit(sparsity_pattern);\\n\\u00a0     solution.reinit(dof_handler.n_dofs());\\n\\u00a0     rhs.reinit(dof_handler.n_dofs());\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nTableDefinition array_view.h:39\\nDoFTools::make_flux_sparsity_patternvoid make_flux_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern)Definition dof_tools_sparsity.cc:697\\nDoFTools::always@ alwaysDefinition dof_tools.h:247\\nnumbers::invalid_subdomain_idconst types::subdomain_id invalid_subdomain_idDefinition types.h:341\\nThe following function describes which faces are part of the set \\\\(\\\\mathcal{F}_h\\\\). That is, it returns true if the face of the incoming cell belongs to the set \\\\(\\\\mathcal{F}_h\\\\).\\n\\u00a0   template <int dim>\\n\\u00a0   bool LaplaceSolver<dim>::face_has_ghost_penalty(\\n\\u00a0     const typename Triangulation<dim>::active_cell_iterator &cell,\\n\\u00a0     const unsigned int                                       face_index) const\\n\\u00a0   {\\n\\u00a0     if (cell->at_boundary(face_index))\\n\\u00a0       return false;\\n\\u00a0 \\n\\u00a0     const NonMatching::LocationToLevelSet cell_location =\\n\\u00a0       mesh_classifier.location_to_level_set(cell);\\n\\u00a0 \\n\\u00a0     const NonMatching::LocationToLevelSet neighbor_location =\\n\\u00a0       mesh_classifier.location_to_level_set(cell->neighbor(face_index));\\n\\u00a0 \\n\\u00a0     if (cell_location == NonMatching::LocationToLevelSet::intersected &&\\n\\u00a0         neighbor_location != NonMatching::LocationToLevelSet::outside)\\n\\u00a0       return true;\\n\\u00a0 \\n\\u00a0     if (neighbor_location == NonMatching::LocationToLevelSet::intersected &&\\n\\u00a0         cell_location != NonMatching::LocationToLevelSet::outside)\\n\\u00a0       return true;\\n\\u00a0 \\n\\u00a0     return false;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nNonMatching::LocationToLevelSet::intersected@ intersected\\n Assembling the System\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceSolver<dim>::assemble_system()\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"Assembling\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     const unsigned int n_dofs_per_cell = fe_collection[0].dofs_per_cell;\\n\\u00a0     FullMatrix<double> local_stiffness(n_dofs_per_cell, n_dofs_per_cell);\\n\\u00a0     Vector<double>     local_rhs(n_dofs_per_cell);\\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(n_dofs_per_cell);\\n\\u00a0 \\n\\u00a0     const double ghost_parameter   = 0.5;\\n\\u00a0     const double nitsche_parameter = 5 * (fe_degree + 1) * fe_degree;\\n\\u00a0 \\nFullMatrixDefinition full_matrix.h:79\\nSince the ghost penalty is similar to a DG flux term, the simplest way to assemble it is to use an FEInterfaceValues object.\\n\\u00a0     const QGauss<dim - 1>  face_quadrature(fe_degree + 1);\\n\\u00a0     FEInterfaceValues<dim> fe_interface_values(fe_collection[0],\\n\\u00a0                                                face_quadrature,\\n\\u00a0                                                update_gradients |\\n\\u00a0                                                  update_JxW_values |\\n\\u00a0                                                  update_normal_vectors);\\n\\u00a0 \\n\\u00a0 \\nFEInterfaceValuesDefinition fe_interface_values.h:1277\\nQGaussDefinition quadrature_lib.h:40\\nupdate_normal_vectors@ update_normal_vectorsNormal vectors.Definition fe_update_flags.h:141\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nAs we iterate over the cells in the mesh, we would in principle have to do the following on each cell, \\\\(T\\\\),\\n\\nConstruct one quadrature rule to integrate over the intersection with the domain, \\\\(T \\\\cap \\\\Omega\\\\), and one quadrature rule to integrate over the intersection with the boundary, \\\\(T \\\\cap \\\\Gamma\\\\).\\nCreate FEValues-like objects with the new quadratures.\\nAssemble the local matrix using the created FEValues-objects.\\n\\nTo make the assembly easier, we use the class NonMatching::FEValues, which does the above steps 1 and 2 for us. The algorithm [189] that is used to generate the quadrature rules on the intersected cells uses a 1-dimensional quadrature rule as base. Thus, we pass a 1d Gauss\\u2013Legendre quadrature to the constructor of NonMatching::FEValues. On the non-intersected cells, a tensor product of this 1d-quadrature will be used.\\nAs stated in the introduction, each cell has 3 different regions: inside, surface, and outside, where the level set function in each region is negative, zero, and positive. We need an UpdateFlags variable for each such region. These are stored on an object of type NonMatching::RegionUpdateFlags, which we pass to NonMatching::FEValues.\\n\\u00a0     const QGauss<1> quadrature_1D(fe_degree + 1);\\n\\u00a0 \\n\\u00a0     NonMatching::RegionUpdateFlags region_update_flags;\\n\\u00a0     region_update_flags.inside = update_values | update_gradients |\\n\\u00a0                                  update_JxW_values | update_quadrature_points;\\n\\u00a0     region_update_flags.surface = update_values | update_gradients |\\n\\u00a0                                   update_JxW_values | update_quadrature_points |\\n\\u00a0                                   update_normal_vectors;\\n\\u00a0 \\n\\u00a0     NonMatching::FEValues<dim> non_matching_fe_values(fe_collection,\\n\\u00a0                                                       quadrature_1D,\\n\\u00a0                                                       region_update_flags,\\n\\u00a0                                                       mesh_classifier,\\n\\u00a0                                                       level_set_dof_handler,\\n\\u00a0                                                       level_set);\\n\\u00a0 \\nNonMatching::FEValuesDefinition fe_values.h:144\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nNonMatching::RegionUpdateFlagsDefinition fe_values.h:58\\nNonMatching::RegionUpdateFlags::insideUpdateFlags insideDefinition fe_values.h:67\\nAs we iterate over the cells, we don't need to do anything on the cells that have FE_Nothing elements. To disregard them we use an iterator filter.\\n\\u00a0     for (const auto &cell :\\n\\u00a0          dof_handler.active_cell_iterators() |\\n\\u00a0            IteratorFilters::ActiveFEIndexEqualTo(ActiveFEIndex::lagrange))\\n\\u00a0       {\\n\\u00a0         local_stiffness = 0;\\n\\u00a0         local_rhs       = 0;\\n\\u00a0 \\n\\u00a0         const double cell_side_length = cell->minimum_vertex_distance();\\n\\u00a0 \\nIteratorFiltersDefinition filtered_iterator.h:54\\nFirst, we call the reinit function of our NonMatching::FEValues object. In the background, NonMatching::FEValues uses the MeshClassifier passed to its constructor to check if the incoming cell is intersected. If that is the case, NonMatching::FEValues calls the NonMatching::QuadratureGenerator in the background to create the immersed quadrature rules.\\n\\u00a0         non_matching_fe_values.reinit(cell);\\n\\u00a0 \\nAfter calling reinit, we can retrieve a FEValues object with quadrature points that corresponds to integrating over the inside region of the cell. This is the object we use to do the local assembly. This is similar to how hp::FEValues builds FEValues objects. However, one difference here is that the FEValues object is returned as an optional. This is a type that wraps an object that may or may not be present. This requires us to add an if-statement to check if the returned optional contains a value, before we use it. This might seem odd at first. Why does the function not just return a reference to a const FEValues<dim>? The reason is that in an immersed method, we have essentially no control of how the cuts occur. Even if the cell is formally intersected:  \\\\(T \\\\cap \\\\Omega\\n   \\\\neq \\\\emptyset\\\\), it might be that the cut is only of floating point size \\\\(|T \\\\cap \\\\Omega| \\\\sim \\\\epsilon\\\\). When this is the case, we can not expect that the algorithm that generates the quadrature rule produces anything useful. It can happen that the algorithm produces 0 quadrature points. When this happens, the returned optional will not contain a value, even if the cell is formally intersected.\\n\\u00a0         const std::optional<FEValues<dim>> &inside_fe_values =\\n\\u00a0           non_matching_fe_values.get_inside_fe_values();\\n\\u00a0 \\n\\u00a0         if (inside_fe_values)\\n\\u00a0           for (const unsigned int q :\\n\\u00a0                inside_fe_values->quadrature_point_indices())\\n\\u00a0             {\\n\\u00a0               const Point<dim> &point = inside_fe_values->quadrature_point(q);\\n\\u00a0               for (const unsigned int i : inside_fe_values->dof_indices())\\n\\u00a0                 {\\n\\u00a0                   for (const unsigned int j : inside_fe_values->dof_indices())\\n\\u00a0                     {\\n\\u00a0                       local_stiffness(i, j) +=\\n\\u00a0                         inside_fe_values->shape_grad(i, q) *\\n\\u00a0                         inside_fe_values->shape_grad(j, q) *\\n\\u00a0                         inside_fe_values->JxW(q);\\n\\u00a0                     }\\n\\u00a0                   local_rhs(i) += rhs_function.value(point) *\\n\\u00a0                                   inside_fe_values->shape_value(i, q) *\\n\\u00a0                                   inside_fe_values->JxW(q);\\n\\u00a0                 }\\n\\u00a0             }\\n\\u00a0 \\nPointDefinition point.h:111\\nint\\nIn the same way, we can use NonMatching::FEValues to retrieve an FEFaceValues-like object to integrate over \\\\(T \\\\cap \\\\Gamma\\\\). The only thing that is new here is the type of the object. The transformation from quadrature weights to JxW-values is different for surfaces, so we need a new class: NonMatching::FEImmersedSurfaceValues. In addition to the ordinary functions shape_value(..), shape_grad(..), etc., one can use its normal_vector(..)-function to get an outward normal to the immersed surface, \\\\(\\\\Gamma\\\\). In terms of the level set function, this normal reads   \\n\\\\begin{equation*}\\n   n = \\\\frac{\\\\nabla \\\\psi}{\\\\| \\\\nabla \\\\psi \\\\|}.\\n   \\\\end{equation*}\\n\\n An additional benefit of std::optional is that we do not need any other check for whether we are on intersected cells: In case we are on an inside cell, we get an empty object here.\\n\\u00a0         const std::optional<NonMatching::FEImmersedSurfaceValues<dim>>\\n\\u00a0           &surface_fe_values = non_matching_fe_values.get_surface_fe_values();\\n\\u00a0 \\n\\u00a0         if (surface_fe_values)\\n\\u00a0           {\\n\\u00a0             for (const unsigned int q :\\n\\u00a0                  surface_fe_values->quadrature_point_indices())\\n\\u00a0               {\\n\\u00a0                 const Point<dim> &point =\\n\\u00a0                   surface_fe_values->quadrature_point(q);\\n\\u00a0                 const Tensor<1, dim> &normal =\\n\\u00a0                   surface_fe_values->normal_vector(q);\\n\\u00a0                 for (const unsigned int i : surface_fe_values->dof_indices())\\n\\u00a0                   {\\n\\u00a0                     for (const unsigned int j :\\n\\u00a0                          surface_fe_values->dof_indices())\\n\\u00a0                       {\\n\\u00a0                         local_stiffness(i, j) +=\\n\\u00a0                           (-normal * surface_fe_values->shape_grad(i, q) *\\n\\u00a0                              surface_fe_values->shape_value(j, q) +\\n\\u00a0                            -normal * surface_fe_values->shape_grad(j, q) *\\n\\u00a0                              surface_fe_values->shape_value(i, q) +\\n\\u00a0                            nitsche_parameter / cell_side_length *\\n\\u00a0                              surface_fe_values->shape_value(i, q) *\\n\\u00a0                              surface_fe_values->shape_value(j, q)) *\\n\\u00a0                           surface_fe_values->JxW(q);\\n\\u00a0                       }\\n\\u00a0                     local_rhs(i) +=\\n\\u00a0                       boundary_condition.value(point) *\\n\\u00a0                       (nitsche_parameter / cell_side_length *\\n\\u00a0                          surface_fe_values->shape_value(i, q) -\\n\\u00a0                        normal * surface_fe_values->shape_grad(i, q)) *\\n\\u00a0                       surface_fe_values->JxW(q);\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0 \\n\\u00a0         stiffness_matrix.add(local_dof_indices, local_stiffness);\\n\\u00a0         rhs.add(local_dof_indices, local_rhs);\\n\\u00a0 \\nTensorDefinition tensor.h:471\\nThe assembly of the ghost penalty term is straight forward. As we iterate over the local faces, we first check if the current face belongs to the set \\\\(\\\\mathcal{F}_h\\\\). The actual assembly is simple using FEInterfaceValues. Assembling in this we will traverse each internal face in the mesh twice, so in order to get the penalty constant we expect, we multiply the penalty term with a factor 1/2.\\n\\u00a0         for (const unsigned int f : cell->face_indices())\\n\\u00a0           if (face_has_ghost_penalty(cell, f))\\n\\u00a0             {\\n\\u00a0               const unsigned int invalid_subface =\\n\\u00a0                 numbers::invalid_unsigned_int;\\n\\u00a0 \\n\\u00a0               fe_interface_values.reinit(cell,\\n\\u00a0                                          f,\\n\\u00a0                                          invalid_subface,\\n\\u00a0                                          cell->neighbor(f),\\n\\u00a0                                          cell->neighbor_of_neighbor(f),\\n\\u00a0                                          invalid_subface);\\n\\u00a0 \\n\\u00a0               const unsigned int n_interface_dofs =\\n\\u00a0                 fe_interface_values.n_current_interface_dofs();\\n\\u00a0               FullMatrix<double> local_stabilization(n_interface_dofs,\\n\\u00a0                                                      n_interface_dofs);\\n\\u00a0               for (unsigned int q = 0;\\n\\u00a0                    q < fe_interface_values.n_quadrature_points;\\n\\u00a0                    ++q)\\n\\u00a0                 {\\n\\u00a0                   const Tensor<1, dim> normal = fe_interface_values.normal(q);\\n\\u00a0                   for (unsigned int i = 0; i < n_interface_dofs; ++i)\\n\\u00a0                     for (unsigned int j = 0; j < n_interface_dofs; ++j)\\n\\u00a0                       {\\n\\u00a0                         local_stabilization(i, j) +=\\n\\u00a0                           .5 * ghost_parameter * cell_side_length * normal *\\n\\u00a0                           fe_interface_values.jump_in_shape_gradients(i, q) *\\n\\u00a0                           normal *\\n\\u00a0                           fe_interface_values.jump_in_shape_gradients(j, q) *\\n\\u00a0                           fe_interface_values.JxW(q);\\n\\u00a0                       }\\n\\u00a0                 }\\n\\u00a0 \\n\\u00a0               const std::vector<types::global_dof_index>\\n\\u00a0                 local_interface_dof_indices =\\n\\u00a0                   fe_interface_values.get_interface_dof_indices();\\n\\u00a0 \\n\\u00a0               stiffness_matrix.add(local_interface_dof_indices,\\n\\u00a0                                    local_stabilization);\\n\\u00a0             }\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nnumbersDefinition numbers.h:230\\n Solving the System\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceSolver<dim>::solve()\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"Solving system\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     const unsigned int max_iterations = solution.size();\\n\\u00a0     SolverControl      solver_control(max_iterations);\\n\\u00a0     SolverCG<>         solver(solver_control);\\n\\u00a0     solver.solve(stiffness_matrix, solution, rhs, PreconditionIdentity());\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nPreconditionIdentityDefinition precondition.h:220\\nSolverCGDefinition solver_cg.h:179\\nSolverControlDefinition solver_control.h:67\\n Data Output\\nSince both DoFHandler instances use the same triangulation, we can add both the level set function and the solution to the same vtu-file. Further, we do not want to output the cells that have LocationToLevelSet value outside. To disregard them, we write a small lambda function and use the set_cell_selection function of the DataOut class.\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceSolver<dim>::output_results() const\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"Writing vtu file\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     DataOut<dim> data_out;\\n\\u00a0     data_out.add_data_vector(dof_handler, solution, \\\"solution\\\");\\n\\u00a0     data_out.add_data_vector(level_set_dof_handler, level_set, \\\"level_set\\\");\\n\\u00a0 \\n\\u00a0     data_out.set_cell_selection(\\n\\u00a0       [this](const typename Triangulation<dim>::cell_iterator &cell) {\\n\\u00a0         return cell->is_active() &&\\n\\u00a0                mesh_classifier.location_to_level_set(cell) !=\\n\\u00a0                  NonMatching::LocationToLevelSet::outside;\\n\\u00a0       });\\n\\u00a0 \\n\\u00a0     data_out.build_patches();\\n\\u00a0     std::ofstream output(\\\"step-85.vtu\\\");\\n\\u00a0     data_out.write_vtu(output);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOutDefinition data_out.h:147\\nTriaIteratorDefinition tria_iterator.h:574\\n L2-Error\\nTo test that the implementation works as expected, we want to compute the error in the solution in the \\\\(L^2\\\\)-norm. The analytical solution to the Poisson problem stated in the introduction reads    \\n\\\\begin{align*}\\n   u(x) = 1 - \\\\frac{2}{\\\\text{dim}}(\\\\| x \\\\|^2 - 1) , \\\\qquad x \\\\in\\n   \\\\overline{\\\\Omega}.\\n   \\\\end{align*}\\n\\n We first create a function corresponding to the analytical solution:\\n\\u00a0   template <int dim>\\n\\u00a0   class AnalyticalSolution : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     double value(const Point<dim>  &point,\\n\\u00a0                  const unsigned int component = 0) const override;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double AnalyticalSolution<dim>::value(const Point<dim>  &point,\\n\\u00a0                                         const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     AssertIndexRange(component, this->n_components);\\n\\u00a0     (void)component;\\n\\u00a0 \\n\\u00a0     return 1. - 2. / dim * (point.norm_square() - 1.);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFunctionDefinition function.h:152\\nFunction::valuevirtual RangeNumberType value(const Point< dim > &p, const unsigned int component=0) const\\nTensor::norm_squareconstexpr numbers::NumberTraits< Number >::real_type norm_square() const\\nAssertIndexRange#define AssertIndexRange(index, range)Definition exceptions.h:2053\\nOf course, the analytical solution, and thus also the error, is only defined in \\\\(\\\\overline{\\\\Omega}\\\\). Thus, to compute the \\\\(L^2\\\\)-error we must proceed in the same way as when we assembled the linear system. We first create an NonMatching::FEValues object.\\n\\u00a0   template <int dim>\\n\\u00a0   double LaplaceSolver<dim>::compute_L2_error() const\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"Computing L2 error\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     const QGauss<1> quadrature_1D(fe_degree + 1);\\n\\u00a0 \\n\\u00a0     NonMatching::RegionUpdateFlags region_update_flags;\\n\\u00a0     region_update_flags.inside =\\n\\u00a0       update_values | update_JxW_values | update_quadrature_points;\\n\\u00a0 \\n\\u00a0     NonMatching::FEValues<dim> non_matching_fe_values(fe_collection,\\n\\u00a0                                                       quadrature_1D,\\n\\u00a0                                                       region_update_flags,\\n\\u00a0                                                       mesh_classifier,\\n\\u00a0                                                       level_set_dof_handler,\\n\\u00a0                                                       level_set);\\n\\u00a0 \\nWe then iterate iterate over the cells that have LocationToLevelSetValue value inside or intersected again. For each quadrature point, we compute the pointwise error and use this to compute the integral.\\n\\u00a0     AnalyticalSolution<dim> analytical_solution;\\n\\u00a0     double                  error_L2_squared = 0;\\n\\u00a0 \\n\\u00a0     for (const auto &cell :\\n\\u00a0          dof_handler.active_cell_iterators() |\\n\\u00a0            IteratorFilters::ActiveFEIndexEqualTo(ActiveFEIndex::lagrange))\\n\\u00a0       {\\n\\u00a0         non_matching_fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0         const std::optional<FEValues<dim>> &fe_values =\\n\\u00a0           non_matching_fe_values.get_inside_fe_values();\\n\\u00a0 \\n\\u00a0         if (fe_values)\\n\\u00a0           {\\n\\u00a0             std::vector<double> solution_values(fe_values->n_quadrature_points);\\n\\u00a0             fe_values->get_function_values(solution, solution_values);\\n\\u00a0 \\n\\u00a0             for (const unsigned int q : fe_values->quadrature_point_indices())\\n\\u00a0               {\\n\\u00a0                 const Point<dim> &point = fe_values->quadrature_point(q);\\n\\u00a0                 const double      error_at_point =\\n\\u00a0                   solution_values.at(q) - analytical_solution.value(point);\\n\\u00a0                 error_L2_squared +=\\n\\u00a0                   Utilities::fixed_power<2>(error_at_point) * fe_values->JxW(q);\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     return std::sqrt(error_L2_squared);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nUtilities::fixed_powerconstexpr T fixed_power(const T t)Definition utilities.h:942\\nstd::sqrt::VectorizedArray< Number, width > sqrt(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6869\\n A Convergence Study\\nFinally, we do a convergence study to check that the \\\\(L^2\\\\)-error decreases with the expected rate. We refine the background mesh a few times. In each refinement cycle, we solve the problem, compute the error, and add the \\\\(L^2\\\\)-error and the mesh size to a ConvergenceTable.\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceSolver<dim>::run()\\n\\u00a0   {\\n\\u00a0     ConvergenceTable   convergence_table;\\n\\u00a0     const unsigned int n_refinements = 3;\\n\\u00a0 \\n\\u00a0     make_grid();\\n\\u00a0     for (unsigned int cycle = 0; cycle <= n_refinements; cycle++)\\n\\u00a0       {\\n\\u00a0         std::cout << \\\"Refinement cycle \\\" << cycle << std::endl;\\n\\u00a0         triangulation.refine_global(1);\\n\\u00a0         setup_discrete_level_set();\\n\\u00a0         std::cout << \\\"Classifying cells\\\" << std::endl;\\n\\u00a0         mesh_classifier.reclassify();\\n\\u00a0         distribute_dofs();\\n\\u00a0         initialize_matrices();\\n\\u00a0         assemble_system();\\n\\u00a0         solve();\\n\\u00a0         if (cycle == 1)\\n\\u00a0           output_results();\\n\\u00a0         const double error_L2 = compute_L2_error();\\n\\u00a0         const double cell_side_length =\\n\\u00a0           triangulation.begin_active()->minimum_vertex_distance();\\n\\u00a0 \\n\\u00a0         convergence_table.add_value(\\\"Cycle\\\", cycle);\\n\\u00a0         convergence_table.add_value(\\\"Mesh size\\\", cell_side_length);\\n\\u00a0         convergence_table.add_value(\\\"L2-Error\\\", error_L2);\\n\\u00a0 \\n\\u00a0         convergence_table.evaluate_convergence_rates(\\n\\u00a0           \\\"L2-Error\\\", ConvergenceTable::reduction_rate_log2);\\n\\u00a0         convergence_table.set_scientific(\\\"L2-Error\\\", true);\\n\\u00a0 \\n\\u00a0         std::cout << std::endl;\\n\\u00a0         convergence_table.write_text(std::cout);\\n\\u00a0         std::cout << std::endl;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 } // namespace Step85\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nConvergenceTableDefinition convergence_table.h:64\\nConvergenceTable::reduction_rate_log2@ reduction_rate_log2Definition convergence_table.h:88\\nTriangulation::begin_activeactive_cell_iterator begin_active(const unsigned int level=0) const\\n The main() function\\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   const int dim = 2;\\n\\u00a0 \\n\\u00a0   Step85::LaplaceSolver<dim> laplace_solver;\\n\\u00a0   laplace_solver.run();\\n\\u00a0 }\\n Results\\nThe numerical solution for one of the refinements is shown in the below figure. The zero-contour of the level set function is shown as a white line. On the intersected cells, we see that the numerical solution has a value also outside \\\\(\\\\overline{\\\\Omega}\\\\). As mentioned earlier, this extension of the solution is artificial.\\nThe results of the convergence study is shown in the table below. We see that the \\\\(L^2\\\\) error decreases as we refine and that the estimated order of convergence, EOC, is close to 2.\\n\\n\\n\\n\\n\\nCycle   Mesh size   \\\\(L^2\\\\)-Error   EOC    \\n\\n0   0.3025   8.0657e-02   -    \\n\\n1   0.1513   1.8711e-02   2.11    \\n\\n2   0.0756   4.1624e-03   2.17    \\n\\n3   0.0378   9.3979e-04   2.15   \\n\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2022 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Author: Simon Sticko, Uppsala University, 2021\\n */\\n \\n \\n \\n#include <deal.II/base/function.h>\\n \\n#include <deal.II/base/convergence_table.h>\\n#include <deal.II/base/point.h>\\n#include <deal.II/base/quadrature.h>\\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/tensor.h>\\n \\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/fe/fe_interface_values.h>\\n#include <deal.II/fe/fe_nothing.h>\\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_update_flags.h>\\n#include <deal.II/fe/fe_values.h>\\n \\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/filtered_iterator.h>\\n#include <deal.II/grid/tria.h>\\n \\n#include <deal.II/hp/fe_collection.h>\\n#include <deal.II/hp/q_collection.h>\\n \\n#include <deal.II/lac/affine_constraints.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/precondition.h>\\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/solver_control.h>\\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/lac/sparsity_pattern.h>\\n#include <deal.II/lac/vector.h>\\n \\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/vector_tools.h>\\n \\n#include <fstream>\\n#include <vector>\\n \\n#include <deal.II/base/function_signed_distance.h>\\n \\n#include <deal.II/non_matching/fe_immersed_values.h>\\n#include <deal.II/non_matching/fe_values.h>\\n#include <deal.II/non_matching/mesh_classifier.h>\\n \\n \\nnamespace Step85\\n{\\n using namespace dealii;\\n \\n template <int dim>\\n class LaplaceSolver\\n  {\\n public:\\n    LaplaceSolver();\\n \\n void run();\\n \\n private:\\n void make_grid();\\n \\n void setup_discrete_level_set();\\n \\n void distribute_dofs();\\n \\n void initialize_matrices();\\n \\n void assemble_system();\\n \\n void solve();\\n \\n void output_results() const;\\n \\n double compute_L2_error() const;\\n \\n bool face_has_ghost_penalty(\\n const typename Triangulation<dim>::active_cell_iterator &cell,\\n const unsigned int face_index) const;\\n \\n const unsigned int fe_degree;\\n \\n const Functions::ConstantFunction<dim> rhs_function;\\n const Functions::ConstantFunction<dim> boundary_condition;\\n \\n Triangulation<dim> triangulation;\\n \\n const FE_Q<dim> fe_level_set;\\n DoFHandler<dim> level_set_dof_handler;\\n Vector<double>  level_set;\\n \\n hp::FECollection<dim> fe_collection;\\n DoFHandler<dim>       dof_handler;\\n Vector<double>        solution;\\n \\n NonMatching::MeshClassifier<dim> mesh_classifier;\\n \\n SparsityPattern      sparsity_pattern;\\n SparseMatrix<double> stiffness_matrix;\\n Vector<double>       rhs;\\n  };\\n \\n \\n \\n template <int dim>\\n  LaplaceSolver<dim>::LaplaceSolver()\\n    : fe_degree(1)\\n    , rhs_function(4.0)\\n    , boundary_condition(1.0)\\n    , fe_level_set(fe_degree)\\n    , level_set_dof_handler(triangulation)\\n    , dof_handler(triangulation)\\n    , mesh_classifier(level_set_dof_handler, level_set)\\n  {}\\n \\n \\n \\n template <int dim>\\n void LaplaceSolver<dim>::make_grid()\\n  {\\n    std::cout << \\\"Creating background mesh\\\" << std::endl;\\n \\n GridGenerator::hyper_cube(triangulation, -1.21, 1.21);\\n triangulation.refine_global(2);\\n  }\\n \\n \\n \\n template <int dim>\\n void LaplaceSolver<dim>::setup_discrete_level_set()\\n  {\\n    std::cout << \\\"Setting up discrete level set function\\\" << std::endl;\\n \\n    level_set_dof_handler.distribute_dofs(fe_level_set);\\n    level_set.reinit(level_set_dof_handler.n_dofs());\\n \\n const Functions::SignedDistance::Sphere<dim> signed_distance_sphere;\\n VectorTools::interpolate(level_set_dof_handler,\\n                             signed_distance_sphere,\\n                             level_set);\\n  }\\n \\n \\n \\n enum ActiveFEIndex\\n  {\\n    lagrange = 0,\\n nothing  = 1\\n  };\\n \\n template <int dim>\\n void LaplaceSolver<dim>::distribute_dofs()\\n  {\\n    std::cout << \\\"Distributing degrees of freedom\\\" << std::endl;\\n \\n    fe_collection.push_back(FE_Q<dim>(fe_degree));\\n    fe_collection.push_back(FE_Nothing<dim>());\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n const NonMatching::LocationToLevelSet cell_location =\\n          mesh_classifier.location_to_level_set(cell);\\n \\n if (cell_location == NonMatching::LocationToLevelSet::outside)\\n          cell->set_active_fe_index(ActiveFEIndex::nothing);\\n else\\n          cell->set_active_fe_index(ActiveFEIndex::lagrange);\\n      }\\n \\n    dof_handler.distribute_dofs(fe_collection);\\n  }\\n \\n \\n \\n template <int dim>\\n void LaplaceSolver<dim>::initialize_matrices()\\n  {\\n    std::cout << \\\"Initializing matrices\\\" << std::endl;\\n \\n const auto face_has_flux_coupling = [&](const auto        &cell,\\n const unsigned int face_index) {\\n return this->face_has_ghost_penalty(cell, face_index);\\n    };\\n \\n DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());\\n \\n const unsigned int           n_components = fe_collection.n_components();\\n Table<2, DoFTools::Coupling> cell_coupling(n_components, n_components);\\n Table<2, DoFTools::Coupling> face_coupling(n_components, n_components);\\n    cell_coupling[0][0] = DoFTools::always;\\n    face_coupling[0][0] = DoFTools::always;\\n \\n const AffineConstraints<double> constraints;\\n const bool                      keep_constrained_dofs = true;\\n \\n DoFTools::make_flux_sparsity_pattern(dof_handler,\\n                                         dsp,\\n                                         constraints,\\n                                         keep_constrained_dofs,\\n                                         cell_coupling,\\n                                         face_coupling,\\n numbers::invalid_subdomain_id,\\n                                         face_has_flux_coupling);\\n    sparsity_pattern.copy_from(dsp);\\n \\n    stiffness_matrix.reinit(sparsity_pattern);\\n    solution.reinit(dof_handler.n_dofs());\\n    rhs.reinit(dof_handler.n_dofs());\\n  }\\n \\n \\n \\n template <int dim>\\n bool LaplaceSolver<dim>::face_has_ghost_penalty(\\n const typename Triangulation<dim>::active_cell_iterator &cell,\\n const unsigned int                                       face_index) const\\n {\\n if (cell->at_boundary(face_index))\\n return false;\\n \\n const NonMatching::LocationToLevelSet cell_location =\\n      mesh_classifier.location_to_level_set(cell);\\n \\n const NonMatching::LocationToLevelSet neighbor_location =\\n      mesh_classifier.location_to_level_set(cell->neighbor(face_index));\\n \\n if (cell_location == NonMatching::LocationToLevelSet::intersected &&\\n        neighbor_location != NonMatching::LocationToLevelSet::outside)\\n return true;\\n \\n if (neighbor_location == NonMatching::LocationToLevelSet::intersected &&\\n        cell_location != NonMatching::LocationToLevelSet::outside)\\n return true;\\n \\n return false;\\n  }\\n \\n \\n \\n template <int dim>\\n void LaplaceSolver<dim>::assemble_system()\\n  {\\n    std::cout << \\\"Assembling\\\" << std::endl;\\n \\n const unsigned int n_dofs_per_cell = fe_collection[0].dofs_per_cell;\\n FullMatrix<double> local_stiffness(n_dofs_per_cell, n_dofs_per_cell);\\n Vector<double>     local_rhs(n_dofs_per_cell);\\n    std::vector<types::global_dof_index> local_dof_indices(n_dofs_per_cell);\\n \\n const double ghost_parameter   = 0.5;\\n const double nitsche_parameter = 5 * (fe_degree + 1) * fe_degree;\\n \\n const QGauss<dim - 1>  face_quadrature(fe_degree + 1);\\n FEInterfaceValues<dim> fe_interface_values(fe_collection[0],\\n                                               face_quadrature,\\n update_gradients |\\n update_JxW_values |\\n update_normal_vectors);\\n \\n \\n const QGauss<1> quadrature_1D(fe_degree + 1);\\n \\n NonMatching::RegionUpdateFlags region_update_flags;\\n    region_update_flags.inside = update_values | update_gradients |\\n update_JxW_values | update_quadrature_points;\\n    region_update_flags.surface = update_values | update_gradients |\\n update_JxW_values | update_quadrature_points |\\n update_normal_vectors;\\n \\n NonMatching::FEValues<dim> non_matching_fe_values(fe_collection,\\n                                                      quadrature_1D,\\n                                                      region_update_flags,\\n                                                      mesh_classifier,\\n                                                      level_set_dof_handler,\\n                                                      level_set);\\n \\n for (const auto &cell :\\n         dof_handler.active_cell_iterators() |\\n IteratorFilters::ActiveFEIndexEqualTo(ActiveFEIndex::lagrange))\\n      {\\n        local_stiffness = 0;\\n        local_rhs       = 0;\\n \\n const double cell_side_length = cell->minimum_vertex_distance();\\n \\n        non_matching_fe_values.reinit(cell);\\n \\n const std::optional<FEValues<dim>> &inside_fe_values =\\n          non_matching_fe_values.get_inside_fe_values();\\n \\n if (inside_fe_values)\\n for (const unsigned int q :\\n               inside_fe_values->quadrature_point_indices())\\n            {\\n const Point<dim> &point = inside_fe_values->quadrature_point(q);\\n for (const unsigned int i : inside_fe_values->dof_indices())\\n                {\\n for (const unsigned int j : inside_fe_values->dof_indices())\\n                    {\\n                      local_stiffness(i, j) +=\\n                        inside_fe_values->shape_grad(i, q) *\\n                        inside_fe_values->shape_grad(j, q) *\\n                        inside_fe_values->JxW(q);\\n                    }\\n                  local_rhs(i) += rhs_function.value(point) *\\n                                  inside_fe_values->shape_value(i, q) *\\n                                  inside_fe_values->JxW(q);\\n                }\\n            }\\n \\n const std::optional<NonMatching::FEImmersedSurfaceValues<dim>>\\n          &surface_fe_values = non_matching_fe_values.get_surface_fe_values();\\n \\n if (surface_fe_values)\\n          {\\n for (const unsigned int q :\\n                 surface_fe_values->quadrature_point_indices())\\n              {\\n const Point<dim> &point =\\n                  surface_fe_values->quadrature_point(q);\\n const Tensor<1, dim> &normal =\\n                  surface_fe_values->normal_vector(q);\\n for (const unsigned int i : surface_fe_values->dof_indices())\\n                  {\\n for (const unsigned int j :\\n                         surface_fe_values->dof_indices())\\n                      {\\n                        local_stiffness(i, j) +=\\n                          (-normal * surface_fe_values->shape_grad(i, q) *\\n                             surface_fe_values->shape_value(j, q) +\\n                           -normal * surface_fe_values->shape_grad(j, q) *\\n                             surface_fe_values->shape_value(i, q) +\\n                           nitsche_parameter / cell_side_length *\\n                             surface_fe_values->shape_value(i, q) *\\n                             surface_fe_values->shape_value(j, q)) *\\n                          surface_fe_values->JxW(q);\\n                      }\\n                    local_rhs(i) +=\\n                      boundary_condition.value(point) *\\n                      (nitsche_parameter / cell_side_length *\\n                         surface_fe_values->shape_value(i, q) -\\n                       normal * surface_fe_values->shape_grad(i, q)) *\\n                      surface_fe_values->JxW(q);\\n                  }\\n              }\\n          }\\n \\n        cell->get_dof_indices(local_dof_indices);\\n \\n        stiffness_matrix.add(local_dof_indices, local_stiffness);\\n        rhs.add(local_dof_indices, local_rhs);\\n \\n for (const unsigned int f : cell->face_indices())\\n          if (face_has_ghost_penalty(cell, f))\\n            {\\n const unsigned int invalid_subface =\\n numbers::invalid_unsigned_int;\\n \\n              fe_interface_values.reinit(cell,\\n                                         f,\\n                                         invalid_subface,\\n                                         cell->neighbor(f),\\n                                         cell->neighbor_of_neighbor(f),\\n                                         invalid_subface);\\n \\n const unsigned int n_interface_dofs =\\n                fe_interface_values.n_current_interface_dofs();\\n FullMatrix<double> local_stabilization(n_interface_dofs,\\n                                                     n_interface_dofs);\\n for (unsigned int q = 0;\\n                   q < fe_interface_values.n_quadrature_points;\\n                   ++q)\\n                {\\n const Tensor<1, dim> normal = fe_interface_values.normal(q);\\n for (unsigned int i = 0; i < n_interface_dofs; ++i)\\n for (unsigned int j = 0; j < n_interface_dofs; ++j)\\n                      {\\n                        local_stabilization(i, j) +=\\n                          .5 * ghost_parameter * cell_side_length * normal *\\n                          fe_interface_values.jump_in_shape_gradients(i, q) *\\n                          normal *\\n                          fe_interface_values.jump_in_shape_gradients(j, q) *\\n                          fe_interface_values.JxW(q);\\n                      }\\n                }\\n \\n const std::vector<types::global_dof_index>\\n                local_interface_dof_indices =\\n                  fe_interface_values.get_interface_dof_indices();\\n \\n              stiffness_matrix.add(local_interface_dof_indices,\\n                                   local_stabilization);\\n            }\\n      }\\n  }\\n \\n \\n template <int dim>\\n void LaplaceSolver<dim>::solve()\\n  {\\n    std::cout << \\\"Solving system\\\" << std::endl;\\n \\n const unsigned int max_iterations = solution.size();\\n SolverControl      solver_control(max_iterations);\\n SolverCG<>         solver(solver_control);\\n    solver.solve(stiffness_matrix, solution, rhs, PreconditionIdentity());\\n  }\\n \\n \\n \\n template <int dim>\\n void LaplaceSolver<dim>::output_results() const\\n {\\n    std::cout << \\\"Writing vtu file\\\" << std::endl;\\n \\n DataOut<dim> data_out;\\n    data_out.add_data_vector(dof_handler, solution, \\\"solution\\\");\\n    data_out.add_data_vector(level_set_dof_handler, level_set, \\\"level_set\\\");\\n \\n    data_out.set_cell_selection(\\n      [this](const typename Triangulation<dim>::cell_iterator &cell) {\\n return cell->is_active() &&\\n               mesh_classifier.location_to_level_set(cell) !=\\n NonMatching::LocationToLevelSet::outside;\\n      });\\n \\n    data_out.build_patches();\\n    std::ofstream output(\\\"step-85.vtu\\\");\\n    data_out.write_vtu(output);\\n  }\\n \\n \\n \\n template <int dim>\\n class AnalyticalSolution : public Function<dim>\\n  {\\n public:\\n double value(const Point<dim>  &point,\\n const unsigned int component = 0) const override;\\n  };\\n \\n \\n \\n template <int dim>\\n double AnalyticalSolution<dim>::value(const Point<dim>  &point,\\n const unsigned int component) const\\n {\\n AssertIndexRange(component, this->n_components);\\n    (void)component;\\n \\n return 1. - 2. / dim * (point.norm_square() - 1.);\\n  }\\n \\n \\n \\n template <int dim>\\n double LaplaceSolver<dim>::compute_L2_error() const\\n {\\n    std::cout << \\\"Computing L2 error\\\" << std::endl;\\n \\n const QGauss<1> quadrature_1D(fe_degree + 1);\\n \\n NonMatching::RegionUpdateFlags region_update_flags;\\n    region_update_flags.inside =\\n update_values | update_JxW_values | update_quadrature_points;\\n \\n NonMatching::FEValues<dim> non_matching_fe_values(fe_collection,\\n                                                      quadrature_1D,\\n                                                      region_update_flags,\\n                                                      mesh_classifier,\\n                                                      level_set_dof_handler,\\n                                                      level_set);\\n \\n    AnalyticalSolution<dim> analytical_solution;\\n double                  error_L2_squared = 0;\\n \\n for (const auto &cell :\\n         dof_handler.active_cell_iterators() |\\n IteratorFilters::ActiveFEIndexEqualTo(ActiveFEIndex::lagrange))\\n      {\\n        non_matching_fe_values.reinit(cell);\\n \\n const std::optional<FEValues<dim>> &fe_values =\\n          non_matching_fe_values.get_inside_fe_values();\\n \\n if (fe_values)\\n          {\\n            std::vector<double> solution_values(fe_values->n_quadrature_points);\\n            fe_values->get_function_values(solution, solution_values);\\n \\n for (const unsigned int q : fe_values->quadrature_point_indices())\\n              {\\n const Point<dim> &point = fe_values->quadrature_point(q);\\n const double      error_at_point =\\n                  solution_values.at(q) - analytical_solution.value(point);\\n                error_L2_squared +=\\n Utilities::fixed_power<2>(error_at_point) * fe_values->JxW(q);\\n              }\\n          }\\n      }\\n \\n return std::sqrt(error_L2_squared);\\n  }\\n \\n \\n \\n template <int dim>\\n void LaplaceSolver<dim>::run()\\n  {\\n ConvergenceTable   convergence_table;\\n const unsigned int n_refinements = 3;\\n \\n    make_grid();\\n for (unsigned int cycle = 0; cycle <= n_refinements; cycle++)\\n      {\\n        std::cout << \\\"Refinement cycle \\\" << cycle << std::endl;\\n triangulation.refine_global(1);\\n        setup_discrete_level_set();\\n        std::cout << \\\"Classifying cells\\\" << std::endl;\\n        mesh_classifier.reclassify();\\n        distribute_dofs();\\n        initialize_matrices();\\n        assemble_system();\\n        solve();\\n if (cycle == 1)\\n          output_results();\\n const double error_L2 = compute_L2_error();\\n const double cell_side_length =\\n triangulation.begin_active()->minimum_vertex_distance();\\n \\n        convergence_table.add_value(\\\"Cycle\\\", cycle);\\n        convergence_table.add_value(\\\"Mesh size\\\", cell_side_length);\\n        convergence_table.add_value(\\\"L2-Error\\\", error_L2);\\n \\n        convergence_table.evaluate_convergence_rates(\\n \\\"L2-Error\\\", ConvergenceTable::reduction_rate_log2);\\n        convergence_table.set_scientific(\\\"L2-Error\\\", true);\\n \\n        std::cout << std::endl;\\n        convergence_table.write_text(std::cout);\\n        std::cout << std::endl;\\n      }\\n  }\\n \\n} // namespace Step85\\n \\n \\n \\nint main()\\n{\\n const int dim = 2;\\n \\n  Step85::LaplaceSolver<dim> laplace_solver;\\n  laplace_solver.run();\\n}\\naffine_constraints.h\\npoint.h\\nConvergenceTable::evaluate_convergence_ratesvoid evaluate_convergence_rates(const std::string &data_column_key, const std::string &reference_column_key, const RateMode rate_mode, const unsigned int dim=2)Definition convergence_table.cc:22\\nDataOutInterface::write_vtuvoid write_vtu(std::ostream &out) constDefinition data_out_base.cc:7692\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nDataOut::set_cell_selectionvoid set_cell_selection(const std::function< cell_iterator(const Triangulation< dim, spacedim > &)> &first_cell, const std::function< cell_iterator(const Triangulation< dim, spacedim > &, const cell_iterator &)> &next_cell)Definition data_out.cc:1273\\nTableHandler::write_textvoid write_text(std::ostream &out, const TextOutputFormat format=table_with_headers) constDefinition table_handler.cc:371\\nTableHandler::add_valuevoid add_value(const std::string &key, const T value)Definition table_handler.h:945\\nTableHandler::set_scientificvoid set_scientific(const std::string &key, const bool scientific)Definition table_handler.cc:359\\nconvergence_table.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nfe_values.h\\nfe_collection.h\\nfe_immersed_values.h\\nfe_interface_values.h\\nfe_nothing.h\\nfe_q.h\\nfe_update_flags.h\\nfiltered_iterator.h\\nfull_matrix.h\\nfunction.h\\nfunction_signed_distance.h\\ntria.h\\ngrid_generator.h\\nquadrature.h\\nmesh_classifier.h\\nEvaluationFlags::nothing@ nothingDefinition evaluation_flags.h:46\\nOpenCASCADE::pointPoint< spacedim > point(const gp_Pnt &p, const double tolerance=1e-10)Definition utilities.cc:191\\nnumbers::invalid_unsigned_intstatic const unsigned int invalid_unsigned_intDefinition types.h:220\\nfe_values.h\\ndata_out.h\\nprecondition.h\\nq_collection.h\\nquadrature_lib.h\\nsolver_cg.h\\nsolver_control.h\\nsparse_matrix.h\\nsparsity_pattern.h\\nNonMatching::RegionUpdateFlags::surfaceUpdateFlags surfaceDefinition fe_values.h:77\\ntensor.h\\nvector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"