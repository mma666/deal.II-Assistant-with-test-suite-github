"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_79.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-79 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-79 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-79 tutorial program\\n\\n\\nThis tutorial depends on step-8, step-15.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nSolid Isotropic Material with Penalization\\nElasticity Equation\\nMaking the solution mesh-independent\\nComplete Problem Formulation\\nSolution procedure\\nDiscretization\\nNonlinear Algorithm\\nMerit Function\\n\\n The commented program\\n\\nPreliminaries\\nThe SANDTopOpt main class\\nConstructor and set-up functions\\nSetting up block matrices and vectors\\nCreating the filter matrix\\nAssembling the Newton matrix\\nSolving the Newton linear system\\nDetails of the optimization algorithm\\n\\nComputing step lengths\\nComputing residuals\\nComputing the merit function\\nFinding a search direction\\nComputing a scaled step\\nChecking for convergence\\n\\nPostprocessing the solution\\nThe run() function driving the overall algorithm\\nThe main function\\n\\n\\n Results\\n\\nTest Problem\\n\\nPossibilities for extensions\\n\\n\\n The plain program\\n   \\n Introduction\\nTopology Optimization of Elastic Media is a technique used to optimize a structure that is bearing some load. Ideally, we would like to minimize the maximum stress placed on a structure by selecting a region \\\\(E\\\\) where material is placed. In other words,   \\n\\\\[\\n  \\\\text{minimize}\\\\| \\\\boldsymbol{\\\\sigma} (\\\\mathbf{u}) \\\\|_\\\\infty\\n\\\\]\\n\\n\\n\\\\[\\n  \\\\text{subject to } |E|\\\\leq V_{\\\\max},\\n\\\\]\\n\\n\\n\\\\[\\n  \\\\text{and } \\\\nabla \\\\cdot \\\\boldsymbol{\\\\sigma} + \\\\mathbf{F} = \\\\mathbf{0}.\\n\\\\]\\n\\nHere, \\\\(\\\\boldsymbol{\\\\sigma} = \\\\mathbf{C} : \\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{u})\\\\) is the stress within the body that is caused by the external forces \\\\(\\\\mathbf F\\\\), where we have for simplicity assumed that the material is linear-elastic and so \\\\(\\\\mathbf{C}\\\\) is the stress-strain tensor and \\\\(\\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{u})=\\\\frac{1}{2} (\\\\nabla \\\\mathbf{u} + (\\\\nabla\\\\mathbf{u})^T)\\\\) is the small-deformation strain as a function of the displacement \\\\(\\\\mathbf{u}\\\\) \\u2013 see step-8 and step-17 for more on linear elasticity. In the formulation above, \\\\(V_\\\\text{max}\\\\) is the maximal amount of material we are willing to provide to build the object. The last of the constraints is the partial differential equation that relates stress \\\\(\\\\boldsymbol{\\\\sigma}\\\\) and forces \\\\(\\\\mathbf F\\\\) and is simply the steady-state force balance.\\nThat said, the infinity norm above creates a problem: As a function of location of material, this objective function is necessarily not differentiable, making prospects of optimization rather bleak. So instead, a common approach in topology optimization is to find an approximate solution by optimizing a related problem: We would like to minimize the strain energy. This is a measure of the potential energy stored in an object due to its deformation, but also works as a measure of total deformation over the structure.\\n\\n\\\\[\\n  \\\\text{minimize  } \\\\int_E \\\\frac{1}{2}\\\\boldsymbol{\\\\sigma} : \\\\boldsymbol{\\\\varepsilon} dV\\n\\\\]\\n\\n\\n\\\\[\\n  \\\\text{subject to } \\\\|E\\\\| \\\\leq V_{\\\\max}\\n\\\\]\\n\\n\\n\\\\[\\n  \\\\text{and } \\\\nabla \\\\cdot \\\\boldsymbol{\\\\sigma} + \\\\mathbf{F} = \\\\mathbf{0}\\n\\\\]\\n\\nThe value of the objective function is calculated using a finite element method, where the solution is the displacements. This is placed inside of a nonlinear solver loop that solves for a vector denoting placement of material.\\nSolid Isotropic Material with Penalization\\nIn actual practice, we can only build objects in which the material is either present, or not present, at any given point \\u2013 i.e., we would have an indicator function \\\\(\\\\rho_E(\\\\mathbf{x})\\\\in \\\\{0,1\\\\}\\\\) that describes the material-filled region and that we want to find through the optimization problem. In this case, the optimization problem becomes combinatorial, and very expensive to solve. Instead, we use an approach called Solid Isotropic Material with Penalization, or SIMP. [24]\\nThe SIMP method is based on an idea of allowing the material to exist in a location with a density \\\\(\\\\rho\\\\) between 0 and 1. A density of 0 suggests the material is not there, and it is not a part of the structure, while a density of 1 suggests the material is present. Values between 0 and 1 do not reflect a design we can create in the real-world, but allow us to turn the combinatorial problem into a continuous one. One then looks at density values \\\\(\\\\rho\\\\), with the constraint that \\\\(0 < \\\\rho_{\\\\min} \\\\leq \\\\rho \\\\leq 1\\\\). The minimum value \\\\(\\\\rho_{\\\\min}\\\\), typically chosen to be around \\\\(10^{-3}\\\\), avoids the possibility of having an infinite strain energy, but is small enough to provide accurate results.\\nThe straightforward application of the effect of this \\\"density\\\" on the elasticity of the media would be to simply multiply the stiffness tensor \\\\(\\\\mathbf{C}_0\\\\) of the medium by the given density, that is, \\\\(\\\\mathbf{C} = \\\\rho \\\\mathbf{C}_0\\\\). However, this approach often gives optimal solutions where density values are far from both 0 and 1. As one wants to find a real-world solution, meaning the material either is present or it is not, a penalty is applied to these in-between values. A simple and effective way to do this is to multiply the stiffness tensor by the density raised to some integer power penalty parameter \\\\(p\\\\), so that \\\\(\\\\mathbf{C} = \\\\rho^p \\\\mathbf{C}_0\\\\). This makes density values farther away from 0 or 1 less effective. It has been shown that using \\\\(p=3\\\\) is sufficiently high to create 'black-and-white' solutions: that is, one gets optimal solutions in which material is either present or not present at all points.\\nMore material should always provide a structure with a lower strain energy, and so the inequality constraint can be viewed as an equality where the total volume used is the maximum volume.\\nUsing this density idea also allows us to reframe the volume constraint on the optimization problem. Use of SIMP then turns the optimization problem into the following:\\n\\n\\\\[\\n  \\\\text{minimize  } \\\\int_\\\\Omega \\\\frac{1}{2}\\\\boldsymbol{\\\\sigma}(\\\\rho) : \\\\boldsymbol{\\\\varepsilon}(\\\\rho) d\\\\Omega\\n\\\\]\\n\\n\\n\\\\[\\n  \\\\text{subject to } \\\\int_\\\\Omega \\\\rho(x) d\\\\Omega= V_{\\\\max},\\n\\\\]\\n\\n\\n\\\\[\\n  0<\\\\rho_{\\\\min}\\\\leq \\\\rho(x) \\\\leq 1,\\n\\\\]\\n\\n\\n\\\\[\\n  \\\\nabla \\\\cdot \\\\boldsymbol{\\\\sigma}(\\\\rho) + \\\\mathbf{F} = 0 \\\\quad \\\\text{on } \\\\Omega\\n\\\\]\\n\\n The final constraint, the balance of linear momentum (which we will refer to as the elasticity equation), gives a method for finding \\\\(\\\\boldsymbol{\\\\sigma}\\\\) and \\\\(\\\\boldsymbol{\\\\varepsilon}\\\\) given the density \\\\(\\\\rho\\\\).\\nElasticity Equation\\nThe elasticity equation in the time independent limit reads   \\n\\\\[\\n  \\\\nabla \\\\cdot \\\\boldsymbol{\\\\sigma} + \\\\mathbf{F} = \\\\mathbf{0} .\\n\\\\]\\n\\n In the situations we will care about, we will assume that the medium has a linear material response and in that case, we have that    \\n\\\\[\\n  \\\\boldsymbol{\\\\sigma} = \\\\mathbf{C} : \\\\boldsymbol{\\\\varepsilon} = \\\\rho^p \\\\mathbf{C}_0 : \\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{u})\\n   = \\\\rho^p \\\\mathbf{C}_0 : \\\\left[\\\\frac{1}{2} (\\\\nabla \\\\mathbf{u} + (\\\\nabla \\\\mathbf{u})^T) \\\\right] .\\n\\\\]\\n\\n In everything we will do below, we will always consider the displacement field \\\\(\\\\mathbf{u}\\\\) as the only solution variable, rather than considering \\\\(\\\\mathbf{u}\\\\) and \\\\(\\\\boldsymbol{\\\\sigma}\\\\) as solution variables (as is done in mixed formulations).\\nFurthermore, we will make the assumption that the material is linear isotropic, in which case the stress-strain tensor can be expressed in terms of the Lam\\u00e9 parameters \\\\(\\\\lambda,\\\\mu\\\\) such that    \\n\\\\begin{align}\\n  \\\\boldsymbol{\\\\sigma} &= \\\\rho^p (\\\\lambda \\\\text{tr}(\\\\boldsymbol{\\\\varepsilon}) \\\\mathbf{I} + 2 \\\\mu \\\\boldsymbol{\\\\varepsilon}) , \\\\\\\\\\n  \\\\sigma_{i,j} &= \\\\rho^p (\\\\lambda \\\\varepsilon_{k,k} \\\\delta_{i,j} + 2 \\\\mu \\\\varepsilon_{i,j}) .\\n\\\\end{align}\\n\\n See step-8 for how this transformation works.\\nIntegrating the objective function by parts gives     \\n\\\\[\\n  \\\\int_\\\\Omega \\\\boldsymbol{\\\\sigma}(\\\\rho) : (\\\\nabla \\\\mathbf{u} + (\\\\nabla \\\\mathbf{u}))^T  d\\\\Omega+\\n  \\\\int_\\\\Omega (\\\\nabla \\\\cdot \\\\boldsymbol{\\\\sigma}(\\\\rho)) \\\\cdot \\\\mathbf{u}  d\\\\Omega=\\n  \\\\int_{\\\\partial \\\\Omega} \\\\mathbf{t} \\\\cdot \\\\mathbf{u} d\\\\partial\\\\Omega ,\\n\\\\]\\n\\n into which the linear elasticity equation can then be substituted, giving     \\n\\\\[\\n  \\\\int_\\\\Omega \\\\boldsymbol{\\\\sigma}(\\\\rho) : (\\\\nabla \\\\mathbf{u} + (\\\\nabla \\\\mathbf{u})^T) d\\\\Omega =\\n  \\\\int_\\\\Omega \\\\mathbf{F}\\\\cdot \\\\mathbf{u} d\\\\Omega+\\n  \\\\int_{\\\\partial \\\\Omega} \\\\mathbf{t} \\\\cdot \\\\mathbf{u} d\\\\partial\\\\Omega .\\n\\\\]\\n\\n Because we are assuming no body forces, this simplifies further to    \\n\\\\[\\n  \\\\int_\\\\Omega \\\\boldsymbol{\\\\sigma}(\\\\rho) : (\\\\nabla \\\\mathbf{u} + (\\\\nabla \\\\mathbf{u})^T) d\\\\Omega\\n  = \\\\int_{\\\\partial \\\\Omega} \\\\mathbf{t} \\\\cdot \\\\mathbf{u} d\\\\partial\\\\Omega,\\n\\\\]\\n\\n which is the final form of the governing equation that we'll be considering from this point forward.\\nMaking the solution mesh-independent\\nTypically, the solutions to topology optimization problems are mesh-dependent, and as such the problem is ill-posed. This is because fractal structures are often formed as the mesh is refined further. As the mesh gains resolution, the optimal solution typically gains smaller and smaller structures. There are a few competing workarounds to this issue, but the most popular for first order optimization is the sensitivity filter, while second order optimization methods tend to prefer use of a density filter.\\nAs the filters affect the gradient and Hessian of the strain energy (i.e., the objective function), the choice of filter has an effect on the solution of the problem. The density filter as part of a second order method works by introducing an unfiltered density, which we refer to as \\\\(\\\\varrho\\\\), and then requiring that the density be a convolution of the unfiltered density:   \\n\\\\[\\n  \\\\rho = H(\\\\varrho).\\n\\\\]\\n\\n Here, \\\\(H\\\\) is an operator so that \\\\(\\\\rho(\\\\mathbf{x})\\\\) is some kind of average of the values of \\\\(\\\\varrho\\\\) in the area around \\\\(\\\\mathbf{x}\\\\) \\u2013 i.e., it is a smoothed version of \\\\(\\\\varrho\\\\).\\nThis prevents checkerboarding; the radius of the filter allows the user to define an effective minimal beam width for the optimal structures we seek to find.\\n  Complete Problem Formulation\\nThe minimization problem is now   \\n\\\\[\\n  \\\\min_{\\\\rho,\\\\varrho,\\\\mathbf{u}} \\\\int_{\\\\partial\\\\Omega} \\\\mathbf{u} \\\\cdot \\\\mathbf{t} d\\\\partial\\\\Omega\\n\\\\]\\n\\n\\n\\\\[\\n  \\\\text{subject to   } \\\\rho = H(\\\\varrho)\\n\\\\]\\n\\n\\n\\\\[\\n  \\\\int_\\\\Omega \\\\rho^p \\\\left(\\\\frac{\\\\mu}{2}\\\\left(\\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{v}):\\n  \\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{u})) \\\\right) + \\\\lambda \\\\left( \\\\nabla \\\\cdot \\\\mathbf{u} \\\\nabla\\n  \\\\cdot \\\\mathbf{v} \\\\right)  \\\\right) d\\\\Omega = \\\\int_{\\\\partial \\\\Omega} \\\\mathbf{v} \\\\cdot\\n  \\\\mathbf{t} d\\\\partial\\\\Omega\\n\\\\]\\n\\n\\n\\\\[\\n  \\\\int_\\\\Omega \\\\rho d\\\\Omega= V\\n\\\\]\\n\\n\\n\\\\[\\n  0\\\\leq \\\\varrho \\\\leq 1\\n\\\\]\\n\\nThe inequality constraints are dealt with by first introducing slack variables, and second using log barriers to ensure that we obtain an interior-point method. The penalty parameter is going to be \\\\(\\\\alpha\\\\), and the following slack variables are \\n\\n\\\\(s_1\\\\) - a slack variable corresponding to the lower bound \\n\\n\\\\(s_2\\\\) - a slack variable corresponding to the upper bound. \\n\\nThis now gives the following problem:    \\n\\\\[\\n  \\\\min_{\\\\rho,\\\\varrho,\\\\mathbf{u}, s_1, s_2} \\\\int_{\\\\partial\\\\Omega} \\\\mathbf{u} \\\\cdot\\n  \\\\mathbf{t} d\\\\partial\\\\Omega- \\\\alpha \\\\int_\\\\Omega \\\\left(\\\\log(s_1) + \\\\log(s_2)\\\\right) d\\\\Omega\\n\\\\]\\n\\n\\n\\\\[\\n  \\\\text{subject to   } \\\\rho = H(\\\\varrho)\\n\\\\]\\n\\n\\n\\\\[\\n  \\\\int_\\\\Omega \\\\rho^p \\\\left(\\\\frac{\\\\mu}{2}\\\\left(\\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{v}):\\n  \\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{u})) \\\\right) + \\\\lambda \\\\left( \\\\nabla \\\\cdot \\\\mathbf{u} \\\\nabla\\n  \\\\cdot \\\\mathbf{v} \\\\right)  \\\\right) d\\\\Omega = \\\\int_{\\\\partial \\\\Omega} \\\\mathbf{v} \\\\cdot\\n  \\\\mathbf{t} d\\\\partial\\\\Omega\\n\\\\]\\n\\n\\n\\\\[\\n  \\\\int_\\\\Omega \\\\rho d\\\\Omega = V\\n\\\\]\\n\\n\\n\\\\[\\n  \\\\varrho = s_1\\n\\\\]\\n\\n\\n\\\\[\\n  1-\\\\varrho = s_2\\n\\\\]\\n\\nWith these variables in place, we can then follow the usual approach to solving constrained optimization problems: We introduce a Lagrangian in which we combine the objective function and the constraints by multiplying the constraints by Lagrange multipliers. Specifically, we will use the following symbols for the Lagrange multipliers for the various constraints: \\n\\n\\\\(\\\\mathbf{y}_1 \\\\): a Lagrange multiplier corresponding to the elasticity constraint,  \\n\\n\\\\(y_2\\\\): a Lagrange multiplier corresponding to the convolution filter constraint,  \\n\\n\\\\(z_1\\\\): a Lagrange multiplier corresponding to the lower slack variable, and  \\n\\n\\\\(z_2\\\\): a Lagrange multiplier corresponding to the upper slack variable.  \\n\\nWith these variables, the Lagrangian function reads as follows:\\n\\n\\\\begin{align}\\n  \\\\mathcal{L} =& \\\\int_{\\\\partial\\\\Omega} \\\\mathbf{u} \\\\cdot \\\\mathbf{t} d\\\\partial\\\\Omega\\n   - \\\\alpha \\\\int_\\\\Omega \\\\left(\\\\log(s_1) + \\\\log(s_2)\\\\right) d\\\\Omega-  \\\\int_\\\\Omega\\n   \\\\rho^p \\\\left(\\\\frac{\\\\mu}{2}\\\\left(\\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{y}_1):\\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{u}))\\n   \\\\right) + \\\\lambda \\\\left( \\\\nabla \\\\cdot \\\\mathbf{u} \\\\nabla \\\\cdot \\\\mathbf{y}_1\\n   \\\\right)\\\\right) d\\\\Omega - \\\\int_{\\\\partial \\\\Omega} \\\\mathbf{y}_1 \\\\cdot \\\\mathbf{t} d\\\\partial\\\\Omega  \\\\\\\\\\n   & -\\\\int_\\\\Omega y_2 (\\\\rho - H(\\\\varrho)) d\\\\Omega - \\\\int_\\\\Omega z_1 (\\\\varrho-s_1) d\\\\Omega\\n   - \\\\int_\\\\Omega z_2 (1 - s_2 -\\\\varrho) d\\\\Omega\\n\\\\end{align}\\n\\nThe solution of the optimization problem then needs to satisfy what are known as the Karush-Kuhn-Tucker (KKT) conditions: The derivatives of the Lagrangian with respect to all of its arguments need to be equal to zero, and because we have inequality constraints, we also have \\\"complementarity\\\" conditions. Since we here have an infinite-dimensional problem, these conditions all involve directional derivatives of the Lagrangian with regard to certain test functions \\u2013 in other words, all of these conditions have to be stated in weak form as is typically the basis for finite element methods anyway.\\nThe barrier method allows us to initially weaken the \\\"complementary slackness\\\" as required by the typical KKT conditions. Typically, we would require that \\\\(s_i z_i = 0\\\\), but the barrier formulations give KKT conditions where \\\\(s_i z_i = \\\\alpha\\\\), where \\\\(\\\\alpha\\\\) is our barrier parameter. As part of the barrier method, this parameter must be driven close to 0 to give a good approximation of the original problem.\\nIn the following, let us state all of these conditions where \\\\(d_{\\\\{\\\\bullet\\\\}}\\\\) is a test function that is naturally paired with variational derivatives of the Lagrangian with respect to the \\\\(\\\\{\\\\bullet\\\\}\\\\) function. For simplicity, we introduce \\\\(\\\\Gamma\\\\) to indicate the portion of the boundary where forces are applied, and Neumann boundary conditions are used.\\n\\n\\nStationarity:      \\n\\\\[\\n  \\\\int_\\\\Omega  - d_\\\\rho y_2 + p\\\\rho^{p-1}d_\\\\rho \\\\left[\\\\lambda\\n  (\\\\nabla \\\\cdot \\\\mathbf{y}_1) (\\\\nabla \\\\cdot \\\\mathbf{u}) +\\n  \\\\mu \\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{u}):\\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{y}_1)\\\\right] d\\\\Omega=0\\\\;\\\\;\\n  \\\\forall d_\\\\rho\\n\\\\]\\n\\n\\n\\\\[\\n  \\\\int_\\\\Gamma \\\\mathbf d_\\\\mathbf{u} \\\\cdot \\\\mathbf{t} d\\\\partial\\\\Omega+ \\\\int_\\\\Omega p\\\\rho^{p}\\n  \\\\left[\\\\lambda (\\\\nabla \\\\cdot \\\\mathbf d_\\\\mathbf{u})( \\\\nabla \\\\cdot \\\\mathbf{y}_1)\\n  + \\\\mu \\\\boldsymbol{\\\\varepsilon}(\\\\mathbf d_\\\\mathbf{u}):\\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{y}_1)\\\\right] d\\\\Omega=0\\\\;\\\\;\\n  \\\\forall \\\\mathbf{d}_\\\\mathbf{u}\\n\\\\]\\n\\n\\n\\\\[\\n  \\\\int_\\\\Omega -d_\\\\varrho z_1 + d_\\\\varrho z_2 + H(d_\\\\varrho)y_2 d\\\\Omega= 0\\\\;\\\\;\\\\forall\\n  d_\\\\varrho\\n\\\\]\\n\\n\\n\\nPrimal Feasibility:      \\n\\\\[\\n  \\\\int_\\\\Omega \\\\rho^{p}\\\\lambda (\\\\nabla \\\\cdot \\\\mathbf d_{\\\\mathbf{y}_1})\\n  (\\\\nabla \\\\cdot \\\\mathbf{u}) +  \\\\rho^{p}\\\\mu  \\\\boldsymbol{\\\\varepsilon}(\\\\mathbf\\n  d_{\\\\mathbf{y}_1}) : \\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{u}) d\\\\Omega - \\\\int_\\\\Gamma \\\\mathbf\\n  d_{\\\\mathbf{y}_1} \\\\cdot \\\\mathbf{t} d\\\\partial\\\\Omega =0 \\\\;\\\\;\\\\forall \\\\mathbf{d}_{\\\\mathbf{y}_1}\\n\\\\]\\n\\n\\n\\\\[\\n  \\\\int_\\\\Omega d_{z_1}(\\\\varrho - s_1) d\\\\Omega = 0\\\\;\\\\;\\\\forall d_{z_1}\\n\\\\]\\n\\n\\n\\\\[\\n  \\\\int_\\\\Omega d_{z_z}(1-\\\\varrho-s_2) d\\\\Omega = 0\\\\;\\\\;\\\\forall d_{z_2}\\n\\\\]\\n\\n\\n\\\\[\\n  \\\\int_\\\\Omega d_{y_2}(\\\\rho - H(\\\\varrho)) d\\\\Omega = 0\\\\;\\\\;\\\\forall d_{y_2}\\n\\\\]\\n\\n\\n\\nComplementary Slackness:    \\n\\\\[\\n  \\\\int_\\\\Omega d_{s_1}(s_1z_1 - \\\\alpha) d\\\\Omega = 0 \\\\;\\\\;\\\\forall d_{s_1} ,\\\\;\\\\;\\\\;\\n  \\\\alpha \\\\to 0\\n\\\\]\\n\\n\\n\\\\[\\n  \\\\int_\\\\Omega d_{s_2}(s_2z_2 - \\\\alpha) d\\\\Omega = 0  \\\\;\\\\;\\\\forall d_{s_2} ,\\\\;\\\\;\\\\;\\n  \\\\alpha \\\\to 0\\n\\\\]\\n\\n\\n\\nDual Feasibility:   \\n\\\\[\\n  s_{1,i},s_{2,i},z_{1,i},z_{2,i} \\\\geq 0 \\\\;\\\\;\\\\;\\\\; \\\\forall i\\n\\\\]\\n\\n\\n\\nSolution procedure\\nThe optimality conditions above are, in addition to being convoluted, of a kind that is not easy to solve: They are generally nonlinear, and some of the relationships are also inequalities. We will address the nonlinearity using a Newton method to compute search directions, and come back to how to deal with the inequalities below when talking about step length procedures.\\nNewton's method applied to the equations above results in the system of equations listed below. Therein, variational derivatives with respect to the \\\\(\\\\{\\\\bullet\\\\}\\\\) variable are taken in the \\\\(c_{\\\\{\\\\bullet\\\\}}\\\\) direction.\\n\\n\\nStationarity: These equations ensure we are at a critical point of the objective function when constrained.\\nEquation 1             \\n\\\\begin{align}\\n  &\\\\int_\\\\Omega-d_\\\\rho c_{y_2} + p(p-1) \\\\rho^{p-2} d_\\\\rho c_\\\\rho [\\\\lambda \\\\nabla\\n  \\\\cdot \\\\mathbf{y}_1 \\\\nabla \\\\cdot \\\\mathbf{u} +  \\\\mu  \\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{u})\\n  \\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{y}_1)]\\n  + p \\\\rho^{p-1} d_\\\\rho[\\\\lambda \\\\nabla \\\\cdot\\n  \\\\mathbf{c}_{\\\\mathbf{y}_1} \\\\nabla \\\\cdot \\\\mathbf{u} +   \\\\mu  \\\\boldsymbol{\\\\varepsilon}\\n  (\\\\mathbf{u}) \\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{c}_{\\\\mathbf{y}_1})]  +  p \\\\rho^{p-1} d_\\\\rho\\n  [\\\\lambda \\\\nabla \\\\cdot {\\\\mathbf{y}_1} \\\\nabla \\\\cdot \\\\mathbf{c}_\\\\mathbf{u} +\\n  \\\\mu  \\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{c}_\\\\mathbf{u}) \\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{y}_1)] d\\\\Omega \\\\\\\\\\n  &= -\\\\int_\\\\Omega -d_\\\\rho z_1 + d_\\\\rho z_2 - d_\\\\rho y_2 + p\\\\rho^{p-1}d_\\\\rho\\n[\\\\lambda \\\\nabla \\\\cdot \\\\mathbf{y}_1 \\\\nabla \\\\cdot \\\\mathbf{u} + \\\\mu \\\\boldsymbol{\\\\varepsilon}\\n(\\\\mathbf{u})\\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{y}_1)] d\\\\Omega\\n\\\\end{align}\\n\\nEquation 2          \\n\\\\begin{align}\\n  &\\\\int_\\\\Omega p \\\\rho^{p-1} c_\\\\rho [\\\\lambda \\\\nabla \\\\cdot {\\\\mathbf{y}_1} \\\\nabla\\n  \\\\cdot \\\\mathbf{d}_\\\\mathbf{u} +  \\\\mu  \\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{d}_\\\\mathbf{u})\\n  \\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{y})] + \\\\rho^{p} [\\\\lambda \\\\nabla \\\\cdot\\n  \\\\mathbf{c}_{\\\\mathbf{y}_1} \\\\nabla \\\\cdot \\\\mathbf{d}_\\\\mathbf{u} +  \\\\mu\\n  \\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{d}_\\\\mathbf{u})\\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{c}_{\\\\mathbf{y}_1})] d\\\\Omega \\\\\\\\\\n  &= -\\\\int_\\\\Gamma \\\\mathbf{d}_\\\\mathbf{u} \\\\cdot \\\\mathbf{t} -\\\\int_\\\\Omega \\\\rho^{p}\\n  [\\\\lambda \\\\nabla \\\\cdot \\\\mathbf{y} \\\\nabla \\\\cdot \\\\mathbf{d}_\\\\mathbf{u} + \\\\mu\\n  \\\\boldsymbol{\\\\varepsilon}(d_\\\\mathbf{u})\\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{y}_1)] d\\\\Omega\\n\\\\end{align}\\n\\nEquation 3    \\n\\\\[\\n  \\\\int_\\\\Omega  - d_\\\\varrho c_{z_1} +d_\\\\varrho c_{z_2}  + H(d_\\\\varrho)c_{y_2}  d\\\\Omega =\\n  -\\\\int_\\\\Omega -d_\\\\varrho z_1 + d_\\\\varrho z_2 + H(d_\\\\varrho)y_2 d\\\\Omega\\n\\\\]\\n\\n\\n\\n\\nPrimal Feasibility: These equations ensure the equality constraints are met.\\nEquation 4            \\n\\\\begin{align}\\n  &\\\\int_\\\\Omega p \\\\rho^{p-1} c_p[\\\\lambda \\\\nabla \\\\cdot\\n  \\\\mathbf{d}_{\\\\mathbf{y}_1} \\\\nabla \\\\cdot \\\\mathbf{u} +  \\\\mu\\n  \\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{u}) \\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{d}_{\\\\mathbf{y}_1})] +\\n  \\\\rho^{p}[\\\\lambda \\\\nabla \\\\cdot \\\\mathbf{d}_{\\\\mathbf{y}_1} \\\\nabla \\\\cdot\\n  \\\\mathbf{c}_\\\\mathbf{u} +  \\\\mu  \\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{c}_\\\\mathbf{u})\\n  \\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{d}_{\\\\mathbf{y}_1})] d\\\\Omega \\\\\\\\\\n  &= -\\\\int_\\\\Omega \\\\rho^{p}[\\\\lambda \\\\nabla \\\\cdot \\\\mathbf{d}_{\\\\mathbf{y}_1} \\\\nabla\\n  \\\\cdot \\\\mathbf{u} + \\\\mu  \\\\boldsymbol{\\\\varepsilon}(\\\\mathbf{u}) \\\\boldsymbol{\\\\varepsilon}\\n  (\\\\mathbf{d}_{\\\\mathbf{y}_1})]  + \\\\int_\\\\Gamma  \\\\mathbf{d}_{\\\\mathbf{y}_1}\\n  \\\\cdot \\\\mathbf{t} d\\\\partial\\\\Omega\\n\\\\end{align}\\n\\nEquation 5   \\n\\\\[\\n  -\\\\int_\\\\Omega d_{z_1}(c_\\\\varrho - c_{s_1}) d\\\\Omega=\\\\int_\\\\Omega d_{z_1} (\\\\varrho - s_1) d\\\\Omega\\n\\\\]\\n\\nEquation 6   \\n\\\\[\\n  -\\\\int_\\\\Omega d_{z_2}(-c_\\\\varrho-c_{s_2}) d\\\\Omega= \\\\int_\\\\Omega d_{z_2} (1-\\\\varrho-s_2) d\\\\Omega\\n\\\\]\\n\\nEquation 7    \\n\\\\[\\n  -\\\\int_\\\\Omega   d_{y_2}(c_\\\\rho - H(c_\\\\varrho)) d\\\\Omega=\\\\int_\\\\Omega d_{y_2}\\n  (\\\\rho - H(\\\\varrho)) d\\\\Omega\\n\\\\]\\n\\n\\n\\n\\nComplementary Slackness: These equations essentially ensure the barrier is met - in the final solution, we need \\\\(s^T z = 0\\\\).\\nEquation 8    \\n\\\\[\\n  \\\\int_\\\\Omega d_{s_1}(c_{s_1}z_1/s_1 +  c_{z_1} ) d\\\\Omega=-\\\\int_\\\\Omega d_{s_1}\\n  (z_1 - \\\\alpha/s_1) d\\\\Omega ,\\\\;\\\\;\\\\; \\\\alpha \\\\to 0\\n\\\\]\\n\\nEquation 9    \\n\\\\[\\n  \\\\int_\\\\Omega d_{s_2} (c_{s_2}z_2/s_2 + c_{z_2} ) d\\\\Omega=-\\\\int_\\\\Omega d_{s_2}\\n  (z_2 - \\\\alpha/s_2)  d\\\\Omega,\\\\;\\\\;\\\\; \\\\alpha \\\\to 0\\n\\\\]\\n\\n\\n\\n\\nDual Feasibility: The Lagrange multiplier on slacks and slack variables must be kept greater than 0. (This is the only part not implemented in the SANDTopOpt::assemble_system() function.)   \\n\\\\[\\n  s,z \\\\geq 0\\n\\\\]\\n\\n\\n\\nDiscretization\\nWe use a quadrilateral mesh with \\\\(Q_1\\\\) elements to discretize the displacement and displacement Lagrange multiplier. Piecewise constant \\\\(DGQ_0\\\\) elements are used to discretize the density, unfiltered density, density slack variables, and multipliers for the slack variables and filter constraint.\\nNonlinear Algorithm\\nWhile most of the discussion above follows traditional and well-known approaches to solving nonlinear optimization problems, it turns out that the problem is actually quite difficult to solve in practice. In particular, it is quite nonlinear and an important question is not just to find search directions \\\\(c_{\\\\{\\\\bullet\\\\}}\\\\) as discussed above based on a Newton method, but that one needs to spend quite a lot of attention to how far one wants to go in this direction. This is often called \\\"line search\\\" and comes down to the question of how to choose the step length \\\\(\\\\alpha_k \\\\in (0,1]\\\\) so that we move from the current iterate \\\\(\\\\mathbf{x}_k\\\\) to the next iterate \\\\(\\\\mathbf{x}_{k+1}=\\\\mathbf{x}_k+\\\\alpha_k \\\\mathbf{x}_k\\\\) in as efficient a way as possible. It is well understood that we need to eventually choose \\\\(\\\\alpha_k=1\\\\) to realize the Newton's method's quadratic convergence; however, in the early iterations, taking such a long step might actually make things worse, either by leading to a point that has a worse objective function or at which the constraints are satisfied less well than they are at \\\\(\\\\mathbf{x}_k\\\\).\\nVery complex algorithms have been proposed to deal with this issue [166] [206]. Here, we implement a watchdog-search algorithm [165]. When discussing this algorithm, we will use the vector \\\\(\\\\mathbf{x}\\\\) to represent all primal variables - the filtered and unfiltered densities, slack variables and displacement - and use the vector \\\\(\\\\mathbf{y}\\\\) to represent all of the dual vectors. The (incremental) solution to the nonlinear system of equations stated above will now be referred to as \\\\(\\\\Delta \\\\mathbf{x}\\\\) and  \\\\(\\\\Delta\\n\\\\mathbf{y}\\\\) instead of \\\\(c_{\\\\{\\\\bullet\\\\}}\\\\). A merit function (explained in more detail later) is referred to here as \\\\(\\\\phi(\\\\mathbf{x,\\\\mathbf{y}})\\\\).\\nThe watchdog algorithm applied to a subproblem with a given barrier parameter works in the following way: First, the current iteration is saved as a \\\"watchdog\\\" state, and the merit of the watchdog state is recorded. A maximal feasible Newton step is then taken. If the merit sufficiently decreased from the first step, this new step is accepted. If not, another maximal feasible Newton step is taken, and the merit is again compared to the watchdog merit. If after some number (typically between 5 and 8) of Newton steps, the merit did not adequately decrease, the algorithm takes a scaled Newton step from either the watchdog state or the last iteration that guarantees a sufficient decrease of the merit, and that step is accepted. Once a step is accepted, the norm of the KKT error is measured, and if it is sufficiently small, the barrier value is decreased. If it is not sufficiently small, the last accepted step is taken to be the new watchdog step, and the process is repeated.\\nAbove, the \\\"maximal feasible step\\\" is a scaling of the Newton step in both the primal and dual variables given by\\n\\n\\\\[\\n  \\\\beta^\\\\mathbf{y} = \\\\min\\\\{1,\\\\max \\\\beta \\\\text{ such that }\\\\left(\\\\mathbf{z}_{k+i}\\n   + \\\\beta^\\\\mathbf{z}_{k+i} \\\\Delta \\\\mathbf{z}_{k+i}\\\\right)_j \\\\geq \\\\zeta\\n   \\\\mathbf{z}_{k+i,j} \\\\forall j\\\\}\\n\\\\]\\n\\n\\n\\\\[\\n  \\\\beta^\\\\mathbf{x} = \\\\min\\\\{1,\\\\max \\\\beta \\\\text{ such that }\\\\left(\\\\mathbf{s}_{k+i}\\n   + \\\\beta^\\\\mathbf{s}_{k+i} \\\\Delta \\\\mathbf{s}_{k+i}\\\\right)_j \\\\geq \\\\zeta\\n   \\\\mathbf{s}_{k+i,j} \\\\forall j\\\\}\\n\\\\]\\n\\nAbove, \\\\(\\\\zeta\\\\) is the \\\"fraction to boundary\\\" that is allowed on any step. Because the derivatives become ill-conditioned near the boundary, this technique stands in for a trust region and is necessary to ensure good approximations in the future. \\\\(\\\\zeta\\\\) is taken to be \\\\(\\\\max\\\\{0.8, 1-\\\\alpha\\\\}\\\\), which allows movement closer to the boundary as the barrier becomes smaller. In the future, when implementing the LOQO algorithm for barrier reduction, this must be kept to 0.8 as the barrier parameter can vary wildly.\\nSeparately, we need to deal with the log-barrier that we have used to enforce the positivity constraint on the slack variables \\\\(s_1,s_2\\\\): In the statement of the final optimization problem we solve, we have added the term   \\n\\\\[\\n  -\\\\alpha \\\\int_\\\\Omega (\\\\log(s_1) + \\\\log(s_2)) d\\\\Omega.\\n\\\\]\\n\\n The question is how we should choose the penalty factor \\\\(\\\\alpha\\\\). As with all penalty methods, we are in reality only interested in the limit as \\\\(\\\\alpha\\\\to 0\\\\), since this is then the problem we really wanted to solve, subject to the positivity constraints on the slack variables. On the other hand, we need to choose \\\\(\\\\alpha\\\\) large enough to make the problem solvable in practice. Actual implementations therefore start with a larger value of \\\\(\\\\alpha\\\\) and gradually decrease it as the outer iterations proceed.\\nIn the monotone method implemented here, the barrier parameter is updated whenever some level of convergence is achieved at the current barrier parameter. We use the \\\\(l_\\\\infty\\\\) norm of the KKT conditions to check for convergence at each barrier size. The requirement is that \\\\(\\\\|KKT\\\\|_{l_\\\\infty} < c \\\\cdot \\\\alpha\\\\) where \\\\(c\\\\) is a constant over any barrier size and \\\\(\\\\alpha\\\\) is the barrier parameter. This forces better convergence in later iterations, and is the same requirement as is used in IPOPT (an open source software package for large-scale nonlinear optimization).\\nHere, the barrier is reduced linearly at larger values, and superlinearly at smaller values. At larger values, it is multiplied by a constant (around 0.6), and at lower values the barrier value is replaced by the barrier value raised to some exponent (around 1.2). This method has proven to be effective at keeping the subproblem solvable at large barrier values, while still allowing superlinear convergence at smaller barrier values. In practice, this looks like the following:   \\n\\\\[\\n  \\\\alpha_{k+1} = \\\\min\\\\{\\\\alpha_k^{1.2},0.6\\\\alpha_k\\\\}\\n\\\\]\\n\\nWhile taking large steps at reducing the barrier size when convergence is reached is widely used, more recent research has shown that it is typically faster to use algorithms that adaptively update barrier each iteration, i.e., methods in which we use concrete criteria at the end of each iteration to determine what the penalty parameter should be in the next iteration, rather than using reduction factors that are independent of the current solution. That said, such methods are also more complicated and we will not do this here.\\nMerit Function\\nThe algorithm outlined above makes use of a \\\"merit function\\\". Merit functions are used to determine whether a step from \\\\(x_k\\\\) to a proposed point \\\\(x_{k+1}\\\\) is beneficial. In unconstrained optimization problems, one can simply check this with the objective function we try to minimize, and typically uses conditions such as the Wolfe and Goldstein conditions.\\nIn constrained optimization problems, the question is how to balance reduction in the objective function against a possible increase in the violation of constraints: A proposed step might make the objective function smaller but be further away from the set of points that satisfy the constraints \\u2013 or the other way around. This trade-off is typically resolved by using a merit function that combines the two criteria.\\nHere, we use an exact \\\\(l_1\\\\) merit function to test the steps:          \\n\\\\begin{align}\\n  \\\\phi(\\\\mathbf{x},\\\\mathbf{y}) =& \\\\int_{\\\\partial \\\\Omega} \\\\mathbf{u}\\\\cdot\\n  \\\\mathbf{t} d\\\\partial\\\\Omega- \\\\alpha \\\\int_\\\\Omega (\\\\log(s_1) + \\\\log(s_2)) + p \\\\sum_i\\\\left|\\n  \\\\int_\\\\Omega y_{2,i}(H(\\\\varrho) - \\\\rho) d\\\\Omega \\\\right| \\\\\\\\\\n  & + p \\\\sum_i\\\\left| \\\\int_{\\\\partial \\\\Omega} \\\\mathbf{y}_{1,i}\\\\cdot \\\\mathbf{t}  d\\\\partial\\\\Omega\\n  - \\\\int_\\\\Omega \\\\rho^p[\\\\lambda \\\\nabla \\\\cdot \\\\mathbf{u} \\\\nabla \\\\cdot \\\\mathbf{y}_{1,i}\\n  + \\\\mu \\\\boldsymbol{\\\\varepsilon}{\\\\mathbf{u}}\\\\boldsymbol{\\\\varepsilon}{\\\\mathbf{y}_{1,i}}] d\\\\Omega \\\\right|\\n  + p \\\\sum_i\\\\left| \\\\int_\\\\Omega z_{1,i}(s_1 - \\\\varrho) d\\\\Omega\\\\right|\\n  + p \\\\sum_i\\\\left| \\\\int_\\\\Omega z_{2,i}(1-\\\\varrho - s_2) d\\\\Omega\\\\right|\\n\\\\end{align}\\n\\nHere, \\\\(p\\\\) is a penalty parameter. This merit function being exact means that there exists some \\\\(p_0\\\\) so that for any \\\\(p > p_0\\\\), the merit function has its minima at the same location as the original problem. This penalty parameter is updated (by recommendation of Nocedal and Wright [25]) as follows:    \\n\\\\[\\n  p > \\\\frac{\\\\frac{1}{2} \\\\mathbf{x}^T \\\\cdot \\\\mathbf{H} \\\\cdot \\\\mathbf{x} - \\\\mathbf{x}^T \\\\cdot \\\\nabla f}{\\\\|c_i\\\\|_{l_\\\\infty}}\\n  \\\\quad , i \\\\in \\\\mathcal{E},\\n\\\\]\\n\\n where \\\\(\\\\mathbf{H}\\\\) is the Hessian of the objective function, \\\\(\\\\mathbf{x}\\\\) is a vector of our decision (primal) variables, \\\\(f\\\\) is the objective function, and \\\\(c_i\\\\) is the error on a current equality constraint.\\nOur use of this method is partially due to already having most of the necessary parts calculated in finding the right hand side, but also the use of an exact merit function ensures that it is minimized in the same location as the overall problem. Recent research has shown that one can replace merit functions by what are called \\\"filter methods\\\", and one should consider using these instead as they prove to be more efficient.\\n The commented program\\n Preliminaries\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/base/tensor.h>\\n\\u00a0 #include <deal.II/base/timer.h>\\n\\u00a0 #include <deal.II/base/signaling_nan.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/block_vector.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/block_sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/linear_operator.h>\\n\\u00a0 #include <deal.II/lac/packaged_operation.h>\\n\\u00a0 #include <deal.II/lac/sparse_direct.h>\\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_refinement.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_renumbering.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 #include <deal.II/fe/fe_dgq.h>\\n\\u00a0 #include <deal.II/fe/fe_system.h>\\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/matrix_tools.h>\\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0 #include <iostream>\\n\\u00a0 #include <fstream>\\n\\u00a0 #include <algorithm>\\n\\u00a0 \\nlinear_operatorLinearOperator< Range, Domain, Payload > linear_operator(const OperatorExemplar &, const Matrix &)Definition linear_operator.h:1427\\nAbove are fairly common files to include. These also include the one for the sparse direct class SparseDirectUMFPACK. This is not the most efficient way to solve large linear problems, but it will do for now.\\nAs usual, we put everything into a common namespace. We then start by declaring a number of symbolic names for constants that will be used throughout this tutorial. Specifically, we have a lot of variables in this program (of course the density and the displacement, but also the unfiltered density and quite a number of Lagrange multipliers). It is easy to forget which of these variables is at which position in the solution vector, and trying to use numbers for these vector components is a prescription for bugs. Rather, we define static variables that can be used in all of these places and that have to be initialized only once. In practice, this will lead to some lengthy expressions, but they are more readable and less likely to be wrong.\\nA similar issue arises with the ordering of blocks in the system matrix and in vectors. The matrices have \\\\(9\\\\times 9\\\\) blocks, and it's difficult to remember which is which. It is far easier to just use symbolic names for those as well.\\nFinally, while we're at it, we introduce symbolic names also for the boundary indicators we will use, in the same spirit as was done in step-19.\\nIn all of these cases, we declare these variables as members in a namespace. In the case of the solution components, the concrete values of these variables depend on the space dimension, so we use template variables to make the value of the variable depend on a template argument in the same way as we often use template functions.\\n\\u00a0 namespace SAND\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\nThis namespace keeps track of the first component in our finite element system that corresponds to each variable.\\n\\u00a0   namespace SolutionComponents\\n\\u00a0   {\\n\\u00a0     template <int dim>\\n\\u00a0     constexpr unsigned int density = 0;\\n\\u00a0     template <int dim>\\n\\u00a0     constexpr unsigned int displacement = 1;\\n\\u00a0     template <int dim>\\n\\u00a0     constexpr unsigned int unfiltered_density = 1 + dim;\\n\\u00a0     template <int dim>\\n\\u00a0     constexpr unsigned int displacement_multiplier = 2 + dim;\\n\\u00a0     template <int dim>\\n\\u00a0     constexpr unsigned int unfiltered_density_multiplier = 2 + 2 * dim;\\n\\u00a0     template <int dim>\\n\\u00a0     constexpr unsigned int density_lower_slack = 3 + 2 * dim;\\n\\u00a0     template <int dim>\\n\\u00a0     constexpr unsigned int density_lower_slack_multiplier = 4 + 2 * dim;\\n\\u00a0     template <int dim>\\n\\u00a0     constexpr unsigned int density_upper_slack = 5 + 2 * dim;\\n\\u00a0     template <int dim>\\n\\u00a0     constexpr unsigned int density_upper_slack_multiplier = 6 + 2 * dim;\\n\\u00a0   } // namespace SolutionComponents\\n\\u00a0 \\nThis is the namespace which keeps track of which block corresponds to which variable.\\n\\u00a0   namespace SolutionBlocks\\n\\u00a0   {\\n\\u00a0     constexpr unsigned int density                        = 0;\\n\\u00a0     constexpr unsigned int displacement                   = 1;\\n\\u00a0     constexpr unsigned int unfiltered_density             = 2;\\n\\u00a0     constexpr unsigned int displacement_multiplier        = 3;\\n\\u00a0     constexpr unsigned int unfiltered_density_multiplier  = 4;\\n\\u00a0     constexpr unsigned int density_lower_slack            = 5;\\n\\u00a0     constexpr unsigned int density_lower_slack_multiplier = 6;\\n\\u00a0     constexpr unsigned int density_upper_slack            = 7;\\n\\u00a0     constexpr unsigned int density_upper_slack_multiplier = 8;\\n\\u00a0   } // namespace SolutionBlocks\\n\\u00a0 \\n\\u00a0   namespace BoundaryIds\\n\\u00a0   {\\n\\u00a0     constexpr types::boundary_id down_force = 101;\\n\\u00a0     constexpr types::boundary_id no_force   = 102;\\n\\u00a0   } // namespace BoundaryIds\\n\\u00a0 \\n\\u00a0   namespace ValueExtractors\\n\\u00a0   {\\n\\u00a0     template <int dim>\\n\\u00a0     const FEValuesExtractors::Scalar\\n\\u00a0       densities(SolutionComponents::density<dim>);\\n\\u00a0     template <int dim>\\n\\u00a0     const FEValuesExtractors::Vector\\n\\u00a0       displacements(SolutionComponents::displacement<dim>);\\n\\u00a0     template <int dim>\\n\\u00a0     const FEValuesExtractors::Scalar\\n\\u00a0       unfiltered_densities(SolutionComponents::unfiltered_density<dim>);\\n\\u00a0     template <int dim>\\n\\u00a0     const FEValuesExtractors::Vector displacement_multipliers(\\n\\u00a0       SolutionComponents::displacement_multiplier<dim>);\\n\\u00a0     template <int dim>\\n\\u00a0     const FEValuesExtractors::Scalar unfiltered_density_multipliers(\\n\\u00a0       SolutionComponents::unfiltered_density_multiplier<dim>);\\n\\u00a0     template <int dim>\\n\\u00a0     const FEValuesExtractors::Scalar\\n\\u00a0       density_lower_slacks(SolutionComponents::density_lower_slack<dim>);\\n\\u00a0     template <int dim>\\n\\u00a0     const FEValuesExtractors::Scalar density_lower_slack_multipliers(\\n\\u00a0       SolutionComponents::density_lower_slack_multiplier<dim>);\\n\\u00a0     template <int dim>\\n\\u00a0     const FEValuesExtractors::Scalar\\n\\u00a0       density_upper_slacks(SolutionComponents::density_upper_slack<dim>);\\n\\u00a0     template <int dim>\\n\\u00a0     const FEValuesExtractors::Scalar density_upper_slack_multipliers(\\n\\u00a0       SolutionComponents::density_upper_slack_multiplier<dim>);\\n\\u00a0   } // namespace ValueExtractors\\n\\u00a0 \\n\\u00a0 \\nunsigned int\\nFEValuesExtractors::ScalarDefinition fe_values_extractors.h:95\\nFEValuesExtractors::VectorDefinition fe_values_extractors.h:150\\n The SANDTopOpt main class\\nNext up is the main class for this problem. The majority of functions follow the usual naming schemes of tutorial programs, though there are a couple that have been broken out of what is usually called the setup_system() function because of their length, and there are also a number that deal with various aspects of the optimization algorithm.\\nAs an added bonus, the program writes the computed design as an STL file that one can, for example, send to a 3d printer.\\n\\u00a0   template <int dim>\\n\\u00a0   class SANDTopOpt\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     SANDTopOpt();\\n\\u00a0 \\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void create_triangulation();\\n\\u00a0 \\n\\u00a0     void setup_boundary_values();\\n\\u00a0 \\n\\u00a0     void setup_block_system();\\n\\u00a0 \\n\\u00a0     void setup_filter_matrix();\\n\\u00a0 \\n\\u00a0     void assemble_system();\\n\\u00a0 \\n\\u00a0     BlockVector<double> solve();\\n\\u00a0 \\n\\u00a0     std::pair<double, double>\\n\\u00a0     calculate_max_step_size(const BlockVector<double> &state,\\n\\u00a0                             const BlockVector<double> &step) const;\\n\\u00a0 \\n\\u00a0     BlockVector<double>\\n\\u00a0     calculate_test_rhs(const BlockVector<double> &test_solution) const;\\n\\u00a0 \\n\\u00a0     double calculate_exact_merit(const BlockVector<double> &test_solution);\\n\\u00a0 \\n\\u00a0     BlockVector<double> find_max_step();\\n\\u00a0 \\n\\u00a0     BlockVector<double> compute_scaled_step(const BlockVector<double> &state,\\n\\u00a0                                             const BlockVector<double> &step,\\n\\u00a0                                             const double descent_requirement);\\n\\u00a0 \\n\\u00a0     bool check_convergence(const BlockVector<double> &state);\\n\\u00a0 \\n\\u00a0     void output_results(const unsigned int j) const;\\n\\u00a0 \\n\\u00a0     void write_as_stl();\\n\\u00a0 \\n\\u00a0     std::set<typename Triangulation<dim>::cell_iterator>\\n\\u00a0     find_relevant_neighbors(\\n\\u00a0       typename Triangulation<dim>::cell_iterator cell) const;\\n\\u00a0 \\n\\u00a0 \\nBlockVectorDefinition block_vector.h:71\\nTriaIteratorDefinition tria_iterator.h:574\\nMost of the member variables are also standard. There are, however, a number of variables that are specifically related to the optimization algorithm (such the various scalar factors below) as well as the filter matrix to ensure that the design remains smooth.\\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0     const FESystem<dim>       fe;\\n\\u00a0     DoFHandler<dim>           dof_handler;\\n\\u00a0     AffineConstraints<double> constraints;\\n\\u00a0 \\n\\u00a0     std::map<types::global_dof_index, double> boundary_values;\\n\\u00a0 \\n\\u00a0     BlockSparsityPattern      sparsity_pattern;\\n\\u00a0     BlockSparseMatrix<double> system_matrix;\\n\\u00a0 \\n\\u00a0     SparsityPattern      filter_sparsity_pattern;\\n\\u00a0     SparseMatrix<double> filter_matrix;\\n\\u00a0 \\n\\u00a0     BlockVector<double> system_rhs;\\n\\u00a0     BlockVector<double> nonlinear_solution;\\n\\u00a0 \\n\\u00a0     const double density_ratio;\\n\\u00a0     const double density_penalty_exponent;\\n\\u00a0     const double filter_r;\\n\\u00a0     double       penalty_multiplier;\\n\\u00a0     double       barrier_size;\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     TimerOutput timer;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nBlockSparseMatrixDefinition block_sparse_matrix.h:50\\nBlockSparsityPatternDefinition block_sparsity_pattern.h:437\\nDoFHandlerDefinition dof_handler.h:317\\nFESystemDefinition fe_system.h:208\\nSparseMatrixDefinition sparse_matrix.h:520\\nSparsityPatternDefinition sparsity_pattern.h:343\\nTimerOutputDefinition timer.h:549\\nTriangulationDefinition tria.h:1323\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\n Constructor and set-up functions\\nWe initialize a FESystem composed of 2 \\\\(\\\\times\\\\)dim FE_Q(1) elements for the displacement variable and its Lagrange multiplier, and 7 FE_DGQ(0) elements. These piecewise constant functions are for density-related variables: the density itself, the unfiltered density, the slack variables for the lower and upper bounds on the unfiltered density, and then Lagrange multipliers for the connection between filtered and unfiltered densities as well as for the inequality constraints.\\nThe order in which these elements appear is documented above.\\n\\u00a0   template <int dim>\\n\\u00a0   SANDTopOpt<dim>::SANDTopOpt()\\n\\u00a0     : fe(FE_DGQ<dim>(0),\\n\\u00a0          1,\\n\\u00a0          FESystem<dim>(FE_Q<dim>(1), dim),\\n\\u00a0          1,\\n\\u00a0          FE_DGQ<dim>(0),\\n\\u00a0          1,\\n\\u00a0          FESystem<dim>(FE_Q<dim>(1), dim),\\n\\u00a0          1,\\n\\u00a0          FE_DGQ<dim>(0),\\n\\u00a0          5)\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0     , density_ratio(.5)\\n\\u00a0     , density_penalty_exponent(3)\\n\\u00a0     , filter_r(.251)\\n\\u00a0     , penalty_multiplier(1)\\n\\u00a0     , timer(std::cout, TimerOutput::summary, TimerOutput::wall_times)\\n\\u00a0   {\\n\\u00a0     Assert(dim > 1, ExcNotImplemented());\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nFE_DGQDefinition fe_dgq.h:112\\nFE_QDefinition fe_q.h:554\\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\nstdSTL namespace.\\nThe first step then is to create the triangulation that matches the problem description in the introduction \\u2013 a 6-by-1 rectangle (or a 6-by-1-by-1 box in 3d) where a force will be applied in the top center. This triangulation is then uniformly refined a number of times.\\nIn contrast to nearly the entire rest of this program, this function specifically assumes that we are in 2d and will require changes if we wanted to move to 3d simulations. We ensure that nobody tries to accidentally run in 3d without such modifications through an assertion at the top of the function.\\n\\u00a0   template <int dim>\\n\\u00a0   void SANDTopOpt<dim>::create_triangulation()\\n\\u00a0   {\\n\\u00a0     Assert(dim == 2, ExcNotImplemented());\\n\\u00a0     GridGenerator::subdivided_hyper_rectangle(triangulation,\\n\\u00a0                                               {6, 1},\\n\\u00a0                                               Point<dim>(0, 0),\\n\\u00a0                                               Point<dim>(6, 1));\\n\\u00a0 \\n\\u00a0     triangulation.refine_global(3);\\n\\u00a0 \\nPointDefinition point.h:111\\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nGridGenerator::subdivided_hyper_rectanglevoid subdivided_hyper_rectangle(Triangulation< dim, spacedim > &tria, const std::vector< unsigned int > &repetitions, const Point< dim > &p1, const Point< dim > &p2, const bool colorize=false)\\nThe second step is to apply boundary indicators to parts of the boundary. The following code assigns boundary indicators to the bottom, top, left, and right boundaries of the box, respectively. The center region of the top boundary is given a separate boundary indicator: This is where we will apply the down force.\\n\\u00a0     for (const auto &cell : triangulation.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         for (const auto &face : cell->face_iterators())\\n\\u00a0           {\\n\\u00a0             if (face->at_boundary())\\n\\u00a0               {\\n\\u00a0                 const auto center = face->center();\\n\\u00a0                 if (std::fabs(center[1] - 1) < 1e-12)\\n\\u00a0                   {\\n\\u00a0                     if ((std::fabs(center[0] - 3) < .3))\\n\\u00a0                       face->set_boundary_id(BoundaryIds::down_force);\\n\\u00a0                     else\\n\\u00a0                       face->set_boundary_id(BoundaryIds::no_force);\\n\\u00a0                   }\\n\\u00a0                 else\\n\\u00a0                   face->set_boundary_id(BoundaryIds::no_force);\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\ncenterPoint< 3 > centerDefinition data_out_base.cc:267\\nNext, determine the constraints due to boundary values. The bottom corners of the domain are kept in place in the \\\\(y\\\\) direction \\u2013 the bottom left also in the \\\\(x\\\\) direction. deal.II generally thinks of boundary values as attached to pieces of the boundary, i.e., faces, rather than individual vertices. Indeed, mathematically speaking, one can not assign boundary values to individual points for the infinite-dimensional partial differential equation. But, since we are trying to reproduce a widely used benchmark, we will do so anyway and keep in mind that we have a finite-dimensional problem for which imposing boundary conditions at a single node is valid.\\n\\u00a0   template <int dim>\\n\\u00a0   void SANDTopOpt<dim>::setup_boundary_values()\\n\\u00a0   {\\n\\u00a0     boundary_values.clear();\\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         for (const auto &face : cell->face_iterators())\\n\\u00a0           {\\n\\u00a0             if (face->at_boundary())\\n\\u00a0               {\\n\\u00a0                 const auto center = face->center();\\n\\u00a0 \\nCheck whether the current face is on the bottom boundary, and if it is whether one of its vertices might be the bottom left or bottom right vertex:\\n\\u00a0                 if (std::fabs(center[1] - 0) < 1e-12)\\n\\u00a0                   {\\n\\u00a0                     for (const auto vertex_number : cell->vertex_indices())\\n\\u00a0                       {\\n\\u00a0                         const auto vert = cell->vertex(vertex_number);\\n\\u00a0 \\n\\u00a0                         if (std::fabs(vert[0] - 0) < 1e-12 &&\\n\\u00a0                             std::fabs(vert[1] - 0) < 1e-12)\\n\\u00a0                           {\\n\\u00a0                             types::global_dof_index x_displacement =\\n\\u00a0                               cell->vertex_dof_index(vertex_number, 0);\\n\\u00a0                             types::global_dof_index y_displacement =\\n\\u00a0                               cell->vertex_dof_index(vertex_number, 1);\\n\\u00a0                             types::global_dof_index x_displacement_multiplier =\\n\\u00a0                               cell->vertex_dof_index(vertex_number, 2);\\n\\u00a0                             types::global_dof_index y_displacement_multiplier =\\n\\u00a0                               cell->vertex_dof_index(vertex_number, 3);\\n\\u00a0 \\n\\u00a0                             boundary_values[x_displacement]            = 0;\\n\\u00a0                             boundary_values[y_displacement]            = 0;\\n\\u00a0                             boundary_values[x_displacement_multiplier] = 0;\\n\\u00a0                             boundary_values[y_displacement_multiplier] = 0;\\n\\u00a0                           }\\n\\u00a0 \\n\\u00a0                         else if (std::fabs(vert[0] - 6) < 1e-12 &&\\n\\u00a0                                  std::fabs(vert[1] - 0) < 1e-12)\\n\\u00a0                           {\\n\\u00a0                             types::global_dof_index y_displacement =\\n\\u00a0                               cell->vertex_dof_index(vertex_number, 1);\\n\\u00a0                             types::global_dof_index y_displacement_multiplier =\\n\\u00a0                               cell->vertex_dof_index(vertex_number, 3);\\n\\u00a0 \\n\\u00a0                             boundary_values[y_displacement]            = 0;\\n\\u00a0                             boundary_values[y_displacement_multiplier] = 0;\\n\\u00a0                           }\\n\\u00a0                       }\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\nvertex_indicesunsigned int vertex_indices[2]Definition grid_tools_topology.cc:947\\n Setting up block matrices and vectors\\nThe next function makes a giant 9-by-9 block matrix, and also sets up the necessary block vectors. The sparsity pattern for this matrix includes the sparsity pattern for the filter matrix. It also initializes any block vectors we will use.\\nSetting up the blocks by themselves is not overly complicated and follows what is already done in programs such as step-22, for example.\\n\\u00a0   template <int dim>\\n\\u00a0   void SANDTopOpt<dim>::setup_block_system()\\n\\u00a0   {\\n\\u00a0     std::vector<unsigned int> block_component(9, 2);\\n\\u00a0     block_component[0] = 0;\\n\\u00a0     block_component[1] = 1;\\n\\u00a0     const std::vector<types::global_dof_index> dofs_per_block =\\n\\u00a0       DoFTools::count_dofs_per_fe_block(dof_handler, block_component);\\n\\u00a0 \\n\\u00a0     const types::global_dof_index                     n_p = dofs_per_block[0];\\n\\u00a0     const types::global_dof_index                     n_u = dofs_per_block[1];\\n\\u00a0     const std::vector<BlockVector<double>::size_type> block_sizes = {\\n\\u00a0       n_p, n_u, n_p, n_u, n_p, n_p, n_p, n_p, n_p};\\n\\u00a0 \\n\\u00a0     BlockDynamicSparsityPattern dsp(block_sizes, block_sizes);\\n\\u00a0 \\n\\u00a0 \\nBlockDynamicSparsityPatternDefinition block_sparsity_pattern.h:549\\nDoFTools::count_dofs_per_fe_blockstd::vector< types::global_dof_index > count_dofs_per_fe_block(const DoFHandler< dim, spacedim > &dof, const std::vector< unsigned int > &target_block=std::vector< unsigned int >())Definition dof_tools.cc:2104\\nThe bulk of the function is in setting up which of these blocks will actually contain anything, i.e., which variables couple with which other variables. This is cumbersome but necessary to ensure that we don't just allocate a very large number of entries for our matrix that will then end up being zero.\\nThe concrete pattern you see below is something one probably has to draw once on a piece of paper, but follows in an otherwise relatively straightforward way from looking through the many terms of the bilinear form we will have to assemble in each nonlinear iteration.\\nThe use of the symbolic names defined in namespace SolutionComponents helps understand what each of the following terms corresponds to, but it also makes the expressions lengthy and unwieldy: A term such as coupling[SolutionComponents::density_upper_slack_multiplier<dim>][SolutionComponents::density<dim>] just doesn't read very well, and would either have to be split over several lines or run off the right edge of nearly every screen. As a consequence, we open a curly-brace enclosed code block in which we temporarily make the names in namespace SolutionComponents available without the namespace qualifier, by saying using namespace SolutionComponents.\\n\\u00a0     Table<2, DoFTools::Coupling> coupling(2 * dim + 7, 2 * dim + 7);\\n\\u00a0     {\\n\\u00a0       using namespace SolutionComponents;\\n\\u00a0 \\n\\u00a0       coupling[density<dim>][density<dim>] = DoFTools::always;\\n\\u00a0 \\n\\u00a0       for (unsigned int i = 0; i < dim; ++i)\\n\\u00a0         {\\n\\u00a0           coupling[density<dim>][displacement<dim> + i] = DoFTools::always;\\n\\u00a0           coupling[displacement<dim> + i][density<dim>] = DoFTools::always;\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0       for (unsigned int i = 0; i < dim; ++i)\\n\\u00a0         {\\n\\u00a0           coupling[density<dim>][displacement_multiplier<dim> + i] =\\n\\u00a0             DoFTools::always;\\n\\u00a0           coupling[displacement_multiplier<dim> + i][density<dim>] =\\n\\u00a0             DoFTools::always;\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0       coupling[density<dim>][unfiltered_density_multiplier<dim>] =\\n\\u00a0         DoFTools::always;\\n\\u00a0       coupling[unfiltered_density_multiplier<dim>][density<dim>] =\\n\\u00a0         DoFTools::always;\\n\\u00a0 \\n\\u00a0       /* Coupling for displacement */\\n\\u00a0 \\n\\u00a0       for (unsigned int i = 0; i < dim; ++i)\\n\\u00a0         {\\n\\u00a0           for (unsigned int k = 0; k < dim; ++k)\\n\\u00a0             {\\n\\u00a0               coupling[displacement<dim> + i]\\n\\u00a0                       [displacement_multiplier<dim> + k] = DoFTools::always;\\n\\u00a0               coupling[displacement_multiplier<dim> + k]\\n\\u00a0                       [displacement<dim> + i] = DoFTools::always;\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0       /* Coupling for slack variables */\\n\\u00a0       coupling[density_lower_slack<dim>][density_lower_slack<dim>] =\\n\\u00a0         DoFTools::always;\\n\\u00a0       coupling[density_lower_slack<dim>][density_upper_slack<dim>] =\\n\\u00a0         DoFTools::always;\\n\\u00a0       coupling[density_upper_slack<dim>][density_lower_slack<dim>] =\\n\\u00a0         DoFTools::always;\\n\\u00a0 \\n\\u00a0       coupling[density_lower_slack_multiplier<dim>]\\n\\u00a0               [density_lower_slack_multiplier<dim>] = DoFTools::always;\\n\\u00a0       coupling[density_lower_slack_multiplier<dim>]\\n\\u00a0               [density_upper_slack_multiplier<dim>] = DoFTools::always;\\n\\u00a0       coupling[density_upper_slack_multiplier<dim>]\\n\\u00a0               [density_lower_slack_multiplier<dim>] = DoFTools::always;\\n\\u00a0     }\\n\\u00a0 \\nTableDefinition array_view.h:39\\nDoFTools::always@ alwaysDefinition dof_tools.h:247\\nBefore we can create the sparsity pattern, we also have to set up constraints. Since this program does not adaptively refine the mesh, the only constraint we have is one that couples all density variables to enforce the volume constraint. This will ultimately lead to a dense sub-block of the matrix, but there is little we can do about that.\\n\\u00a0     const ComponentMask density_mask =\\n\\u00a0       fe.component_mask(ValueExtractors::densities<dim>);\\n\\u00a0     const IndexSet density_dofs =\\n\\u00a0       DoFTools::extract_dofs(dof_handler, density_mask);\\n\\u00a0 \\n\\u00a0     types::global_dof_index last_density_dof =\\n\\u00a0       density_dofs.nth_index_in_set(density_dofs.n_elements() - 1);\\n\\u00a0     constraints.clear();\\n\\u00a0     {\\n\\u00a0       std::vector<std::pair<types::global_dof_index, double>>\\n\\u00a0         constraint_entries;\\n\\u00a0       constraint_entries.reserve(density_dofs.n_elements() - 1);\\n\\u00a0       for (const types::global_dof_index dof_index : density_dofs)\\n\\u00a0         if (dof_index != last_density_dof)\\n\\u00a0           constraint_entries.emplace_back(dof_index, -1.);\\n\\u00a0 \\n\\u00a0       constraints.add_constraint(last_density_dof, constraint_entries, 0.);\\n\\u00a0     }\\n\\u00a0     constraints.close();\\n\\u00a0 \\nComponentMaskDefinition component_mask.h:81\\nComponentMask::component_maskstd::vector< bool > component_maskDefinition component_mask.h:244\\nIndexSetDefinition index_set.h:70\\nDoFTools::extract_dofsIndexSet extract_dofs(const DoFHandler< dim, spacedim > &dof_handler, const ComponentMask &component_mask)Definition dof_tools.cc:414\\nWe can now finally create the sparsity pattern for the matrix, taking into account which variables couple with which other variables, and the constraints we have on the density.\\n\\u00a0     DoFTools::make_sparsity_pattern(dof_handler, coupling, dsp, constraints);\\n\\u00a0 \\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nThe only part of the matrix we have not dealt with is the filter matrix and its transpose. These are non-local (integral) operators for which deal.II does not currently have functions. What we will ultimately need to do is go over all cells and couple the unfiltered density on this cell to all filtered densities of neighboring cells that are less than a threshold distance away, and the other way around; for the moment, we are only concerned with building the sparsity pattern that would correspond to this kind of matrix, so we perform the equivalent loop and where later on we would write into an entry of the matrix, we now simply add an entry to the sparsity matrix:\\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         const unsigned int i = cell->active_cell_index();\\n\\u00a0         for (const auto &check_cell : find_relevant_neighbors(cell))\\n\\u00a0           {\\n\\u00a0             const double distance =\\n\\u00a0               cell->center().distance(check_cell->center());\\n\\u00a0             if (distance < filter_r)\\n\\u00a0               {\\n\\u00a0                 dsp\\n\\u00a0                   .block(SolutionBlocks::unfiltered_density,\\n\\u00a0                          SolutionBlocks::unfiltered_density_multiplier)\\n\\u00a0                   .add(i, check_cell->active_cell_index());\\n\\u00a0                 dsp\\n\\u00a0                   .block(SolutionBlocks::unfiltered_density_multiplier,\\n\\u00a0                          SolutionBlocks::unfiltered_density)\\n\\u00a0                   .add(i, check_cell->active_cell_index());\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\nint\\nHaving so generated the \\\"dynamic\\\" sparsity pattern, we can finally copy it to the structure that is used to associate matrices with a sparsity pattern. Because the sparsity pattern is large and complex, we also output it into a file of its own for visualization purposes \\u2013 in other words, for \\\"visual debugging\\\".\\n\\u00a0     sparsity_pattern.copy_from(dsp);\\n\\u00a0 \\n\\u00a0     std::ofstream out(\\\"sparsity.plt\\\");\\n\\u00a0     sparsity_pattern.print_gnuplot(out);\\n\\u00a0 \\n\\u00a0     system_matrix.reinit(sparsity_pattern);\\n\\u00a0 \\n\\u00a0 \\nWhat is left is to correctly size the various vectors and their blocks, as well as setting initial guesses for some of the components of the (nonlinear) solution vector. We here use the symbolic component names for individual blocks of the solution vector and, for brevity, use the same trick with using namespace as above:\\n\\u00a0     nonlinear_solution.reinit(block_sizes);\\n\\u00a0     system_rhs.reinit(block_sizes);\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       using namespace SolutionBlocks;\\n\\u00a0       nonlinear_solution.block(density).add(density_ratio);\\n\\u00a0       nonlinear_solution.block(unfiltered_density).add(density_ratio);\\n\\u00a0       nonlinear_solution.block(unfiltered_density_multiplier)\\n\\u00a0         .add(density_ratio);\\n\\u00a0       nonlinear_solution.block(density_lower_slack).add(density_ratio);\\n\\u00a0       nonlinear_solution.block(density_lower_slack_multiplier).add(50);\\n\\u00a0       nonlinear_solution.block(density_upper_slack).add(1 - density_ratio);\\n\\u00a0       nonlinear_solution.block(density_upper_slack_multiplier).add(50);\\n\\u00a0     }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n Creating the filter matrix\\nNext up, a function that is used once at the beginning of the program: It creates a matrix \\\\(H\\\\) so that the filtered density vector equals \\\\(H\\\\) times the unfiltered density. The creation of this matrix is non-trivial, and it is used in every iteration, and so rather than reforming it as we do with the Newton matrix, it is made only once and stored separately.\\nThe way this matrix is computed follows the outline used above already to form its sparsity pattern. We repeat this process here for the sparsity pattern of this separately formed matrix, and then actually build the matrix itself. You may want to check the definition of this matrix in the introduction to this program.\\n\\u00a0   template <int dim>\\n\\u00a0   void SANDTopOpt<dim>::setup_filter_matrix()\\n\\u00a0   {\\nThe sparsity pattern of the filter has already been determined and implemented in the setup_system() function. We copy the structure from the appropriate block and use it again here.\\n\\u00a0     filter_sparsity_pattern.copy_from(\\n\\u00a0       sparsity_pattern.block(SolutionBlocks::unfiltered_density,\\n\\u00a0                              SolutionBlocks::unfiltered_density_multiplier));\\n\\u00a0     filter_matrix.reinit(filter_sparsity_pattern);\\n\\u00a0 \\nHaving so built the sparsity pattern, now we re-do all of these loops to actually compute the necessary values of the matrix entries:\\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         const unsigned int i = cell->active_cell_index();\\n\\u00a0         for (const auto &check_cell : find_relevant_neighbors(cell))\\n\\u00a0           {\\n\\u00a0             const double distance =\\n\\u00a0               cell->center().distance(check_cell->center());\\n\\u00a0             if (distance < filter_r)\\n\\u00a0               {\\n\\u00a0                 filter_matrix.add(i,\\n\\u00a0                                   check_cell->active_cell_index(),\\n\\u00a0                                   filter_r - distance);\\n\\u00a0                 \\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\nThe final step is to normalize the matrix so that for each row, the sum of entries equals one.\\n\\u00a0     for (unsigned int i = 0; i < filter_matrix.m(); ++i)\\n\\u00a0       {\\n\\u00a0         double denominator = 0;\\n\\u00a0         for (SparseMatrix<double>::iterator iter = filter_matrix.begin(i);\\n\\u00a0              iter != filter_matrix.end(i);\\n\\u00a0              iter++)\\n\\u00a0           denominator = denominator + iter->value();\\n\\u00a0         for (SparseMatrix<double>::iterator iter = filter_matrix.begin(i);\\n\\u00a0              iter != filter_matrix.end(i);\\n\\u00a0              iter++)\\n\\u00a0           iter->value() = iter->value() / denominator;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\nSparseMatrixIterators::IteratorDefinition sparse_matrix.h:347\\nThis function is used for building the filter matrix. We create a set of all the cell iterators within a certain radius of the cell that is input. These are the neighboring cells that will be relevant for the filter.\\n\\u00a0   template <int dim>\\n\\u00a0   std::set<typename Triangulation<dim>::cell_iterator>\\n\\u00a0   SANDTopOpt<dim>::find_relevant_neighbors(\\n\\u00a0     typename Triangulation<dim>::cell_iterator cell) const\\n\\u00a0   {\\n\\u00a0     std::set<unsigned int>                               neighbor_ids;\\n\\u00a0     std::set<typename Triangulation<dim>::cell_iterator> cells_to_check;\\n\\u00a0 \\n\\u00a0     neighbor_ids.insert(cell->active_cell_index());\\n\\u00a0     cells_to_check.insert(cell);\\n\\u00a0 \\n\\u00a0     bool new_neighbors_found;\\n\\u00a0     do\\n\\u00a0       {\\n\\u00a0         new_neighbors_found = false;\\n\\u00a0         for (const auto &check_cell :\\n\\u00a0              std::vector<typename Triangulation<dim>::cell_iterator>(\\n\\u00a0                cells_to_check.begin(), cells_to_check.end()))\\n\\u00a0           {\\n\\u00a0             for (const auto n : check_cell->face_indices())\\n\\u00a0               {\\n\\u00a0                 if (!(check_cell->face(n)->at_boundary()))\\n\\u00a0                   {\\n\\u00a0                     const auto  &neighbor = check_cell->neighbor(n);\\n\\u00a0                     const double distance =\\n\\u00a0                       cell->center().distance(neighbor->center());\\n\\u00a0                     if ((distance < filter_r) &&\\n\\u00a0                         !(neighbor_ids.count(neighbor->active_cell_index())))\\n\\u00a0                       {\\n\\u00a0                         cells_to_check.insert(neighbor);\\n\\u00a0                         neighbor_ids.insert(neighbor->active_cell_index());\\n\\u00a0                         new_neighbors_found = true;\\n\\u00a0                       }\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0     while (new_neighbors_found);\\n\\u00a0     return cells_to_check;\\n\\u00a0   }\\n\\u00a0 \\n Assembling the Newton matrix\\nWhereas the setup_filter_matrix function built a matrix that is the same as long as the mesh does not change (which we don't do anyway in this program), the next function builds the matrix to be solved in each iteration. This is where the magic happens. The components of the system of linear equations describing Newton's method for finding the solution of the KKT conditions are implemented here.\\nThe top of the function is as in most of these functions and just sets up all sorts of variables necessary for the actual assembly, including a whole bunch of extractors. The entire set up should look familiar, though somewhat lengthier, if you've previously looked at step-22.\\n\\u00a0   template <int dim>\\n\\u00a0   void SANDTopOpt<dim>::assemble_system()\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope t(timer, \\\"assembly\\\");\\n\\u00a0 \\n\\u00a0     system_matrix = 0;\\n\\u00a0     system_rhs    = 0;\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     MappingQ<dim>         mapping(1);\\n\\u00a0     const QGauss<dim>     quadrature_formula(fe.degree + 1);\\n\\u00a0     const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);\\n\\u00a0     FEValues<dim>         fe_values(mapping,\\n\\u00a0                             fe,\\n\\u00a0                             quadrature_formula,\\n\\u00a0                             update_values | update_gradients |\\n\\u00a0                               update_quadrature_points | update_JxW_values);\\n\\u00a0     FEFaceValues<dim>     fe_face_values(mapping,\\n\\u00a0                                      fe,\\n\\u00a0                                      face_quadrature_formula,\\n\\u00a0                                      update_values | update_quadrature_points |\\n\\u00a0                                        update_normal_vectors |\\n\\u00a0                                        update_JxW_values);\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell = fe.dofs_per_cell;\\n\\u00a0     const unsigned int n_q_points    = quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0     Vector<double>     dummy_cell_rhs(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     std::vector<double>                    lambda_values(n_q_points);\\n\\u00a0     std::vector<double>                    mu_values(n_q_points);\\n\\u00a0     const Functions::ConstantFunction<dim> lambda(1.);\\n\\u00a0     const Functions::ConstantFunction<dim> mu(1.);\\n\\u00a0     std::vector<Tensor<1, dim>>            rhs_values(n_q_points);\\n\\u00a0 \\nFEFaceValuesDefinition fe_values.h:322\\nFEValuesDefinition fe_values.h:63\\nFullMatrixDefinition full_matrix.h:79\\nFunctions::ConstantFunctionDefinition function.h:410\\nMappingQDefinition mapping_q.h:110\\nQGaussDefinition quadrature_lib.h:40\\nTimerOutput::ScopeDefinition timer.h:557\\nVectorDefinition vector.h:120\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_normal_vectors@ update_normal_vectorsNormal vectors.Definition fe_update_flags.h:141\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nAt this point, we apply the filter to the unfiltered density, and apply the adjoint (transpose) operation to the unfiltered density multiplier, both to the current best guess for the nonlinear solution. We use this later to tell us how far off our filtered density is from the filter applied to the unfiltered density. That is because while at the solution of the nonlinear problem, we have \\\\(\\\\rho=H\\\\varrho\\\\), but at intermediate iterations, we in general have \\\\(\\\\rho^k\\\\neq H\\\\varrho^k\\\\) and the \\\"residual\\\" \\\\(\\\\rho^k-H\\\\varrho^k\\\\) will then appear as the right hand side of one of the Newton update equations that we compute below.\\n\\u00a0     BlockVector<double> filtered_unfiltered_density_solution =\\n\\u00a0       nonlinear_solution;\\n\\u00a0     BlockVector<double> filter_adjoint_unfiltered_density_multiplier_solution =\\n\\u00a0       nonlinear_solution;\\n\\u00a0 \\n\\u00a0     filter_matrix.vmult(filtered_unfiltered_density_solution.block(\\n\\u00a0                           SolutionBlocks::unfiltered_density),\\n\\u00a0                         nonlinear_solution.block(\\n\\u00a0                           SolutionBlocks::unfiltered_density));\\n\\u00a0     filter_matrix.Tvmult(\\n\\u00a0       filter_adjoint_unfiltered_density_multiplier_solution.block(\\n\\u00a0         SolutionBlocks::unfiltered_density_multiplier),\\n\\u00a0       nonlinear_solution.block(SolutionBlocks::unfiltered_density_multiplier));\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     std::vector<double>                  old_density_values(n_q_points);\\n\\u00a0     std::vector<Tensor<1, dim>>          old_displacement_values(n_q_points);\\n\\u00a0     std::vector<double>                  old_displacement_divs(n_q_points);\\n\\u00a0     std::vector<SymmetricTensor<2, dim>> old_displacement_symmgrads(n_q_points);\\n\\u00a0     std::vector<Tensor<1, dim>> old_displacement_multiplier_values(n_q_points);\\n\\u00a0     std::vector<double>         old_displacement_multiplier_divs(n_q_points);\\n\\u00a0     std::vector<SymmetricTensor<2, dim>> old_displacement_multiplier_symmgrads(\\n\\u00a0       n_q_points);\\n\\u00a0     std::vector<double> old_lower_slack_multiplier_values(n_q_points);\\n\\u00a0     std::vector<double> old_upper_slack_multiplier_values(n_q_points);\\n\\u00a0     std::vector<double> old_lower_slack_values(n_q_points);\\n\\u00a0     std::vector<double> old_upper_slack_values(n_q_points);\\n\\u00a0     std::vector<double> old_unfiltered_density_values(n_q_points);\\n\\u00a0     std::vector<double> old_unfiltered_density_multiplier_values(n_q_points);\\n\\u00a0     std::vector<double> filtered_unfiltered_density_values(n_q_points);\\n\\u00a0     std::vector<double> filter_adjoint_unfiltered_density_multiplier_values(\\n\\u00a0       n_q_points);\\n\\u00a0 \\n\\u00a0     using namespace ValueExtractors;\\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         cell_matrix = 0;\\n\\u00a0 \\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0 \\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0         lambda.value_list(fe_values.get_quadrature_points(), lambda_values);\\n\\u00a0         mu.value_list(fe_values.get_quadrature_points(), mu_values);\\n\\u00a0 \\nAs part of the construction of our system matrix, we need to retrieve values from our current guess at the solution. The following lines of code retrieve the needed values.\\n\\u00a0         fe_values[densities<dim>].get_function_values(nonlinear_solution,\\n\\u00a0                                                       old_density_values);\\n\\u00a0         fe_values[displacements<dim>].get_function_values(\\n\\u00a0           nonlinear_solution, old_displacement_values);\\n\\u00a0         fe_values[displacements<dim>].get_function_divergences(\\n\\u00a0           nonlinear_solution, old_displacement_divs);\\n\\u00a0         fe_values[displacements<dim>].get_function_symmetric_gradients(\\n\\u00a0           nonlinear_solution, old_displacement_symmgrads);\\n\\u00a0         fe_values[displacement_multipliers<dim>].get_function_values(\\n\\u00a0           nonlinear_solution, old_displacement_multiplier_values);\\n\\u00a0         fe_values[displacement_multipliers<dim>].get_function_divergences(\\n\\u00a0           nonlinear_solution, old_displacement_multiplier_divs);\\n\\u00a0         fe_values[displacement_multipliers<dim>]\\n\\u00a0           .get_function_symmetric_gradients(\\n\\u00a0             nonlinear_solution, old_displacement_multiplier_symmgrads);\\n\\u00a0         fe_values[density_lower_slacks<dim>].get_function_values(\\n\\u00a0           nonlinear_solution, old_lower_slack_values);\\n\\u00a0         fe_values[density_lower_slack_multipliers<dim>].get_function_values(\\n\\u00a0           nonlinear_solution, old_lower_slack_multiplier_values);\\n\\u00a0         fe_values[density_upper_slacks<dim>].get_function_values(\\n\\u00a0           nonlinear_solution, old_upper_slack_values);\\n\\u00a0         fe_values[density_upper_slack_multipliers<dim>].get_function_values(\\n\\u00a0           nonlinear_solution, old_upper_slack_multiplier_values);\\n\\u00a0         fe_values[unfiltered_densities<dim>].get_function_values(\\n\\u00a0           nonlinear_solution, old_unfiltered_density_values);\\n\\u00a0         fe_values[unfiltered_density_multipliers<dim>].get_function_values(\\n\\u00a0           nonlinear_solution, old_unfiltered_density_multiplier_values);\\n\\u00a0         fe_values[unfiltered_densities<dim>].get_function_values(\\n\\u00a0           filtered_unfiltered_density_solution,\\n\\u00a0           filtered_unfiltered_density_values);\\n\\u00a0         fe_values[unfiltered_density_multipliers<dim>].get_function_values(\\n\\u00a0           filter_adjoint_unfiltered_density_multiplier_solution,\\n\\u00a0           filter_adjoint_unfiltered_density_multiplier_values);\\n\\u00a0 \\n\\u00a0         for (const auto q_point : fe_values.quadrature_point_indices())\\n\\u00a0           {\\nWe need several more values corresponding to the test functions coming from the first derivatives taken from the Lagrangian, that is the \\\\(d_{\\\\bullet}\\\\) functions. These are calculated here:\\n\\u00a0             for (const auto i : fe_values.dof_indices())\\n\\u00a0               {\\n\\u00a0                 const SymmetricTensor<2, dim> displacement_phi_i_symmgrad =\\n\\u00a0                   fe_values[displacements<dim>].symmetric_gradient(i, q_point);\\n\\u00a0                 const double displacement_phi_i_div =\\n\\u00a0                   fe_values[displacements<dim>].divergence(i, q_point);\\n\\u00a0 \\n\\u00a0                 const SymmetricTensor<2, dim>\\n\\u00a0                   displacement_multiplier_phi_i_symmgrad =\\n\\u00a0                     fe_values[displacement_multipliers<dim>].symmetric_gradient(\\n\\u00a0                       i, q_point);\\n\\u00a0                 const double displacement_multiplier_phi_i_div =\\n\\u00a0                   fe_values[displacement_multipliers<dim>].divergence(i,\\n\\u00a0                                                                       q_point);\\n\\u00a0 \\n\\u00a0                 const double density_phi_i =\\n\\u00a0                   fe_values[densities<dim>].value(i, q_point);\\n\\u00a0                 const double unfiltered_density_phi_i =\\n\\u00a0                   fe_values[unfiltered_densities<dim>].value(i, q_point);\\n\\u00a0                 const double unfiltered_density_multiplier_phi_i =\\n\\u00a0                   fe_values[unfiltered_density_multipliers<dim>].value(i,\\n\\u00a0                                                                        q_point);\\n\\u00a0 \\n\\u00a0                 const double lower_slack_multiplier_phi_i =\\n\\u00a0                   fe_values[density_lower_slack_multipliers<dim>].value(\\n\\u00a0                     i, q_point);\\n\\u00a0 \\n\\u00a0                 const double lower_slack_phi_i =\\n\\u00a0                   fe_values[density_lower_slacks<dim>].value(i, q_point);\\n\\u00a0 \\n\\u00a0                 const double upper_slack_phi_i =\\n\\u00a0                   fe_values[density_upper_slacks<dim>].value(i, q_point);\\n\\u00a0 \\n\\u00a0                 const double upper_slack_multiplier_phi_i =\\n\\u00a0                   fe_values[density_upper_slack_multipliers<dim>].value(\\n\\u00a0                     i, q_point);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0                 for (const auto j : fe_values.dof_indices())\\n\\u00a0                   {\\nSymmetricTensorDefinition symmetric_tensor.h:719\\nFinally, we need values that come from the second round of derivatives taken from the Lagrangian, the \\\\(c_{\\\\bullet}\\\\) functions. These are calculated here:\\n\\u00a0                     const SymmetricTensor<2, dim> displacement_phi_j_symmgrad =\\n\\u00a0                       fe_values[displacements<dim>].symmetric_gradient(j,\\n\\u00a0                                                                        q_point);\\n\\u00a0                     const double displacement_phi_j_div =\\n\\u00a0                       fe_values[displacements<dim>].divergence(j, q_point);\\n\\u00a0 \\n\\u00a0                     const SymmetricTensor<2, dim>\\n\\u00a0                       displacement_multiplier_phi_j_symmgrad =\\n\\u00a0                         fe_values[displacement_multipliers<dim>]\\n\\u00a0                           .symmetric_gradient(j, q_point);\\n\\u00a0                     const double displacement_multiplier_phi_j_div =\\n\\u00a0                       fe_values[displacement_multipliers<dim>].divergence(\\n\\u00a0                         j, q_point);\\n\\u00a0 \\n\\u00a0                     const double density_phi_j =\\n\\u00a0                       fe_values[densities<dim>].value(j, q_point);\\n\\u00a0 \\n\\u00a0                     const double unfiltered_density_phi_j =\\n\\u00a0                       fe_values[unfiltered_densities<dim>].value(j, q_point);\\n\\u00a0                     const double unfiltered_density_multiplier_phi_j =\\n\\u00a0                       fe_values[unfiltered_density_multipliers<dim>].value(\\n\\u00a0                         j, q_point);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0                     const double lower_slack_phi_j =\\n\\u00a0                       fe_values[density_lower_slacks<dim>].value(j, q_point);\\n\\u00a0 \\n\\u00a0                     const double upper_slack_phi_j =\\n\\u00a0                       fe_values[density_upper_slacks<dim>].value(j, q_point);\\n\\u00a0 \\n\\u00a0                     const double lower_slack_multiplier_phi_j =\\n\\u00a0                       fe_values[density_lower_slack_multipliers<dim>].value(\\n\\u00a0                         j, q_point);\\n\\u00a0 \\n\\u00a0                     const double upper_slack_multiplier_phi_j =\\n\\u00a0                       fe_values[density_upper_slack_multipliers<dim>].value(\\n\\u00a0                         j, q_point);\\n\\u00a0 \\nThis is where the actual work starts. In the following, we will build all of the terms of the matrix \\u2013 they are numerous and not entirely self-explanatory, also depending on the previous solutions and its derivatives (which we have already evaluated above and put into the variables called old_*). To understand what each of these terms corresponds to, you will want to look at the explicit form of these terms in the introduction above.\\nThe right hand sides of the equations being driven to 0 give all the KKT conditions for finding a local minimum \\u2013 the descriptions of what each individual equation are given with the computations of the right hand side.\\n  \\u00a0                     /* Equation 1 */\\n  \\u00a0                     cell_matrix(i, j) +=\\n  \\u00a0                       fe_values.JxW(q_point) *\\n  \\u00a0                       (\\n  \\u00a0 \\n  \\u00a0                         -density_phi_i * unfiltered_density_multiplier_phi_j\\n  \\u00a0 \\n  \\u00a0                         + density_penalty_exponent *\\n  \\u00a0                             (density_penalty_exponent - 1) *\\n  \\u00a0                             std::pow(old_density_values[q_point],\\n  \\u00a0                                      density_penalty_exponent - 2) *\\n  \\u00a0                             density_phi_i * density_phi_j *\\n  \\u00a0                             (old_displacement_multiplier_divs[q_point] *\\n  \\u00a0                                old_displacement_divs[q_point] *\\n  \\u00a0                                lambda_values[q_point] +\\n  \\u00a0                              2 * mu_values[q_point] *\\n  \\u00a0                                (old_displacement_symmgrads[q_point] *\\n  \\u00a0                                 old_displacement_multiplier_symmgrads[q_point]))\\n  \\u00a0 \\n  \\u00a0                         + density_penalty_exponent *\\n  \\u00a0                             std::pow(old_density_values[q_point],\\n  \\u00a0                                      density_penalty_exponent - 1) *\\n  \\u00a0                             density_phi_i *\\n  \\u00a0                             (displacement_multiplier_phi_j_div *\\n  \\u00a0                                old_displacement_divs[q_point] *\\n  \\u00a0                                lambda_values[q_point] +\\n  \\u00a0                              2 * mu_values[q_point] *\\n  \\u00a0                                (old_displacement_symmgrads[q_point] *\\n  \\u00a0                                 displacement_multiplier_phi_j_symmgrad))\\n  \\u00a0 \\n  \\u00a0                         + density_penalty_exponent *\\n  \\u00a0                             std::pow(old_density_values[q_point],\\n  \\u00a0                                      density_penalty_exponent - 1) *\\n  \\u00a0                             density_phi_i *\\n  \\u00a0                             (displacement_phi_j_div *\\n  \\u00a0                                old_displacement_multiplier_divs[q_point] *\\n  \\u00a0                                lambda_values[q_point] +\\n  \\u00a0                              2 * mu_values[q_point] *\\n  \\u00a0                                (old_displacement_multiplier_symmgrads[q_point] *\\n  \\u00a0                                 displacement_phi_j_symmgrad)));\\n  \\u00a0 \\n  \\u00a0                     /* Equation 2 */\\n  \\u00a0                     cell_matrix(i, j) +=\\n  \\u00a0                       fe_values.JxW(q_point) *\\n  \\u00a0                       (density_penalty_exponent *\\n  \\u00a0                          std::pow(old_density_values[q_point],\\n  \\u00a0                                   density_penalty_exponent - 1) *\\n  \\u00a0                          density_phi_j *\\n  \\u00a0                          (old_displacement_multiplier_divs[q_point] *\\n  \\u00a0                             displacement_phi_i_div * lambda_values[q_point] +\\n  \\u00a0                           2 * mu_values[q_point] *\\n  \\u00a0                             (old_displacement_multiplier_symmgrads[q_point] *\\n  \\u00a0                              displacement_phi_i_symmgrad))\\n  \\u00a0 \\n  \\u00a0                        + std::pow(old_density_values[q_point],\\n  \\u00a0                                   density_penalty_exponent) *\\n  \\u00a0                            (displacement_multiplier_phi_j_div *\\n  \\u00a0                               displacement_phi_i_div * lambda_values[q_point] +\\n  \\u00a0                             2 * mu_values[q_point] *\\n  \\u00a0                               (displacement_multiplier_phi_j_symmgrad *\\n  \\u00a0                                displacement_phi_i_symmgrad))\\n  \\u00a0 \\n  \\u00a0                       );\\n  \\u00a0 \\n  \\u00a0                     /* Equation 3, which has to do with the filter and which is\\n* \\u00a0                      * calculated elsewhere. */\\n  \\u00a0                     cell_matrix(i, j) +=\\n  \\u00a0                       fe_values.JxW(q_point) *\\n  \\u00a0                       (-1 * unfiltered_density_phi_i *\\n  \\u00a0                          lower_slack_multiplier_phi_j +\\n  \\u00a0                        unfiltered_density_phi_i * upper_slack_multiplier_phi_j);\\n  \\u00a0 \\n  \\u00a0 \\n  \\u00a0                     /* Equation 4: Primal feasibility */\\n  \\u00a0                     cell_matrix(i, j) +=\\n  \\u00a0                       fe_values.JxW(q_point) *\\n  \\u00a0                       (\\n  \\u00a0 \\n  \\u00a0                         density_penalty_exponent *\\n  \\u00a0                           std::pow(old_density_values[q_point],\\n  \\u00a0                                    density_penalty_exponent - 1) *\\n  \\u00a0                           density_phi_j *\\n  \\u00a0                           (old_displacement_divs[q_point] *\\n  \\u00a0                              displacement_multiplier_phi_i_div *\\n  \\u00a0                              lambda_values[q_point] +\\n  \\u00a0                            2 * mu_values[q_point] *\\n  \\u00a0                              (old_displacement_symmgrads[q_point] *\\n  \\u00a0                               displacement_multiplier_phi_i_symmgrad))\\n  \\u00a0 \\n  \\u00a0                         + std::pow(old_density_values[q_point],\\n  \\u00a0                                    density_penalty_exponent) *\\n  \\u00a0                             (displacement_phi_j_div *\\n  \\u00a0                                displacement_multiplier_phi_i_div *\\n  \\u00a0                                lambda_values[q_point] +\\n  \\u00a0                              2 * mu_values[q_point] *\\n  \\u00a0                                (displacement_phi_j_symmgrad *\\n  \\u00a0                                 displacement_multiplier_phi_i_symmgrad)));\\n  \\u00a0 \\n  \\u00a0                     /* Equation 5: Primal feasibility */\\n  \\u00a0                     cell_matrix(i, j) +=\\n  \\u00a0                       -1 * fe_values.JxW(q_point) *\\n  \\u00a0                       lower_slack_multiplier_phi_i *\\n  \\u00a0                       (unfiltered_density_phi_j - lower_slack_phi_j);\\n  \\u00a0 \\n  \\u00a0                     /* Equation 6: Primal feasibility */\\n  \\u00a0                     cell_matrix(i, j) +=\\n  \\u00a0                       -1 * fe_values.JxW(q_point) *\\n  \\u00a0                       upper_slack_multiplier_phi_i *\\n  \\u00a0                       (-1 * unfiltered_density_phi_j - upper_slack_phi_j);\\n  \\u00a0 \\n  \\u00a0                     /* Equation 7: Primal feasibility - the part with the filter\\n* \\u00a0                      * is added later */\\n  \\u00a0                     cell_matrix(i, j) += -1 * fe_values.JxW(q_point) *\\n  \\u00a0                                          unfiltered_density_multiplier_phi_i *\\n  \\u00a0                                          (density_phi_j);\\n  \\u00a0 \\n  \\u00a0                     /* Equation 8: Complementary slackness */\\n  \\u00a0                     cell_matrix(i, j) +=\\n  \\u00a0                       fe_values.JxW(q_point) *\\n  \\u00a0                       (lower_slack_phi_i * lower_slack_multiplier_phi_j\\n  \\u00a0 \\n  \\u00a0                        + lower_slack_phi_i * lower_slack_phi_j *\\n  \\u00a0                            old_lower_slack_multiplier_values[q_point] /\\n  \\u00a0                            old_lower_slack_values[q_point]);\\n  \\u00a0 \\n  \\u00a0                     /* Equation 9: Complementary slackness */\\n  \\u00a0                     cell_matrix(i, j) +=\\n  \\u00a0                       fe_values.JxW(q_point) *\\n  \\u00a0                       (upper_slack_phi_i * upper_slack_multiplier_phi_j\\n  \\u00a0 \\n  \\u00a0 \\n  \\u00a0                        + upper_slack_phi_i * upper_slack_phi_j *\\n  \\u00a0                            old_upper_slack_multiplier_values[q_point] /\\n  \\u00a0                            old_upper_slack_values[q_point]);\\n  \\u00a0                   }\\n  \\u00a0               }\\n  \\u00a0           }\\n  \\u00a0 \\nstd::pow::VectorizedArray< Number, width > pow(const ::VectorizedArray< Number, width > &, const Number p)Definition vectorization.h:6885\\nNow that we have everything assembled, all we have to do is deal with the effect of (Dirichlet) boundary conditions and other constraints. We incorporate the former locally with just the contributions from the current cell, and then let the AffineConstraint class deal with the latter while copying contributions from the current cell into the global linear system:\\n\\u00a0         MatrixTools::local_apply_boundary_values(boundary_values,\\n\\u00a0                                                  local_dof_indices,\\n\\u00a0                                                  cell_matrix,\\n\\u00a0                                                  dummy_cell_rhs,\\n\\u00a0                                                  true);\\n\\u00a0 \\n\\u00a0         constraints.distribute_local_to_global(cell_matrix,\\n\\u00a0                                                local_dof_indices,\\n\\u00a0                                                system_matrix);\\n\\u00a0       }\\n\\u00a0 \\nMatrixTools::local_apply_boundary_valuesvoid local_apply_boundary_values(const std::map< types::global_dof_index, number > &boundary_values, const std::vector< types::global_dof_index > &local_dof_indices, FullMatrix< number > &local_matrix, Vector< number > &local_rhs, const bool eliminate_columns)Definition matrix_tools.cc:499\\nHaving accumulated all of the terms that belong into the Newton matrix, we now also have to compute the terms for the right hand side (i.e., the negative residual). We already do this in another function, and so we call that here:\\n\\u00a0     system_rhs = calculate_test_rhs(nonlinear_solution);\\n\\u00a0 \\nHere we use the filter matrix we have already constructed. We only need to integrate this filter applied to test functions, which are piecewise constant, and so the integration becomes a simple multiplication by the measure of the cell. Iterating over the pre-made filter matrix allows us to use the information about which cells are in or out of the filter without repeatedly checking neighbor cells again.\\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         const unsigned int i = cell->active_cell_index();\\n\\u00a0         for (typename SparseMatrix<double>::iterator iter =\\n\\u00a0                filter_matrix.begin(i);\\n\\u00a0              iter != filter_matrix.end(i);\\n\\u00a0              ++iter)\\n\\u00a0           {\\n\\u00a0             const unsigned int j     = iter->column();\\n\\u00a0             const double       value = iter->value() * cell->measure();\\n\\u00a0 \\n\\u00a0             system_matrix\\n\\u00a0               .block(SolutionBlocks::unfiltered_density_multiplier,\\n\\u00a0                      SolutionBlocks::unfiltered_density)\\n\\u00a0               .add(i, j, value);\\n\\u00a0             system_matrix\\n\\u00a0               .block(SolutionBlocks::unfiltered_density,\\n\\u00a0                      SolutionBlocks::unfiltered_density_multiplier)\\n\\u00a0               .add(j, i, value);\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n Solving the Newton linear system\\nWe will need to solve a linear system in each iteration. We use a direct solver, for now \\u2013 this is clearly not an efficient choice for a matrix that has so many non-zeroes, and it will not scale to anything interesting. For \\\"real\\\" applications, we will need an iterative solver but the complexity of the system means that an iterative solver algorithm will take a good deal of work. Because this is not the focus of the current program, we simply stick with the direct solver we have here \\u2013 the function follows the same structure as used in step-29.\\n\\u00a0   template <int dim>\\n\\u00a0   BlockVector<double> SANDTopOpt<dim>::solve()\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope t(timer, \\\"solver\\\");\\n\\u00a0 \\n\\u00a0     BlockVector<double> linear_solution;\\n\\u00a0     linear_solution.reinit(nonlinear_solution);\\n\\u00a0 \\n\\u00a0     SparseDirectUMFPACK A_direct;\\n\\u00a0     A_direct.initialize(system_matrix);\\n\\u00a0     A_direct.vmult(linear_solution, system_rhs);\\n\\u00a0 \\n\\u00a0     constraints.distribute(linear_solution);\\n\\u00a0 \\n\\u00a0     return linear_solution;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nBlockVector::reinitvoid reinit(const unsigned int n_blocks, const size_type block_size=0, const bool omit_zeroing_entries=false)\\nSparseDirectUMFPACKDefinition sparse_direct.h:92\\nSparseDirectUMFPACK::initializevoid initialize(const SparsityPattern &sparsity_pattern)Definition sparse_direct.cc:67\\n Details of the optimization algorithm\\nThe next several functions deal with specific parts of the optimization algorithm, most notably with deciding whether the direction computed by solving the linearized (Newton) system is viable and, if so, how far we want to go in this direction.\\n Computing step lengths\\nWe start with a function that does a binary search to figure out the maximum step that meets the dual feasibility \\u2013 that is, how far can we go so that \\\\(s>0\\\\) and \\\\(z>0\\\\). The function returns a pair of values, one each for the \\\\(s\\\\) and \\\\(z\\\\) slack variables.\\n\\u00a0   template <int dim>\\n\\u00a0   std::pair<double, double> SANDTopOpt<dim>::calculate_max_step_size(\\n\\u00a0     const BlockVector<double> &state,\\n\\u00a0     const BlockVector<double> &step) const\\n\\u00a0   {\\n\\u00a0     double       fraction_to_boundary;\\n\\u00a0     const double min_fraction_to_boundary = .8;\\n\\u00a0     const double max_fraction_to_boundary = 1. - 1e-5;\\n\\u00a0 \\n\\u00a0     if (min_fraction_to_boundary < 1 - barrier_size)\\n\\u00a0       {\\n\\u00a0         if (1 - barrier_size < max_fraction_to_boundary)\\n\\u00a0           fraction_to_boundary = 1 - barrier_size;\\n\\u00a0         else\\n\\u00a0           fraction_to_boundary = max_fraction_to_boundary;\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       fraction_to_boundary = min_fraction_to_boundary;\\n\\u00a0 \\n\\u00a0     double step_size_s_low  = 0;\\n\\u00a0     double step_size_z_low  = 0;\\n\\u00a0     double step_size_s_high = 1;\\n\\u00a0     double step_size_z_high = 1;\\n\\u00a0     double step_size_s, step_size_z;\\n\\u00a0 \\n\\u00a0     const int max_bisection_method_steps = 50;\\n\\u00a0     for (unsigned int k = 0; k < max_bisection_method_steps; ++k)\\n\\u00a0       {\\n\\u00a0         step_size_s = (step_size_s_low + step_size_s_high) / 2;\\n\\u00a0         step_size_z = (step_size_z_low + step_size_z_high) / 2;\\n\\u00a0 \\n\\u00a0         const BlockVector<double> state_test_s =\\n\\u00a0           (fraction_to_boundary * state) + (step_size_s * step);\\n\\u00a0 \\n\\u00a0         const BlockVector<double> state_test_z =\\n\\u00a0           (fraction_to_boundary * state) + (step_size_z * step);\\n\\u00a0 \\n\\u00a0         const bool accept_s =\\n\\u00a0           (state_test_s.block(SolutionBlocks::density_lower_slack)\\n\\u00a0              .is_non_negative()) &&\\n\\u00a0           (state_test_s.block(SolutionBlocks::density_upper_slack)\\n\\u00a0              .is_non_negative());\\n\\u00a0         const bool accept_z =\\n\\u00a0           (state_test_z.block(SolutionBlocks::density_lower_slack_multiplier)\\n\\u00a0              .is_non_negative()) &&\\n\\u00a0           (state_test_z.block(SolutionBlocks::density_upper_slack_multiplier)\\n\\u00a0              .is_non_negative());\\n\\u00a0 \\n\\u00a0         if (accept_s)\\n\\u00a0           step_size_s_low = step_size_s;\\n\\u00a0         else\\n\\u00a0           step_size_s_high = step_size_s;\\n\\u00a0 \\n\\u00a0         if (accept_z)\\n\\u00a0           step_size_z_low = step_size_z;\\n\\u00a0         else\\n\\u00a0           step_size_z_high = step_size_z;\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     return {step_size_s_low, step_size_z_low};\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n Computing residuals\\nThe next function computes a right hand side vector linearized around a \\\"test solution vector\\\" that we can use to look at the magnitude of the KKT conditions. This is then used for testing the convergence before shrinking the barrier size, as well as in the calculation of the \\\\(l_1\\\\) merit.\\nThe function is lengthy and complicated, but it is really just a copy of the right hand side part of what the assemble_system() function above did.\\n\\u00a0   template <int dim>\\n\\u00a0   BlockVector<double> SANDTopOpt<dim>::calculate_test_rhs(\\n\\u00a0     const BlockVector<double> &test_solution) const\\n\\u00a0   {\\nWe first create a zero vector with size and blocking of system_rhs\\n  \\u00a0     BlockVector<double> test_rhs;\\n  \\u00a0     test_rhs.reinit(system_rhs);\\n  \\u00a0 \\n  \\u00a0     MappingQ<dim>         mapping(1);\\n  \\u00a0     const QGauss<dim>     quadrature_formula(fe.degree + 1);\\n  \\u00a0     const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);\\n  \\u00a0     FEValues<dim>         fe_values(mapping,\\n  \\u00a0                             fe,\\n  \\u00a0                             quadrature_formula,\\n  \\u00a0                             update_values | update_gradients |\\n  \\u00a0                               update_quadrature_points | update_JxW_values);\\n  \\u00a0     FEFaceValues<dim>     fe_face_values(mapping,\\n  \\u00a0                                      fe,\\n  \\u00a0                                      face_quadrature_formula,\\n  \\u00a0                                      update_values | update_quadrature_points |\\n  \\u00a0                                        update_normal_vectors |\\n  \\u00a0                                        update_JxW_values);\\n  \\u00a0 \\n  \\u00a0     const unsigned int dofs_per_cell = fe.dofs_per_cell;\\n  \\u00a0     const unsigned int n_q_points    = quadrature_formula.size();\\n  \\u00a0 \\n  \\u00a0     Vector<double>     cell_rhs(dofs_per_cell);\\n  \\u00a0     FullMatrix<double> dummy_cell_matrix(dofs_per_cell, dofs_per_cell);\\n  \\u00a0 \\n  \\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n  \\u00a0 \\n  \\u00a0     std::vector<double> lambda_values(n_q_points);\\n  \\u00a0     std::vector<double> mu_values(n_q_points);\\n  \\u00a0 \\n  \\u00a0     const Functions::ConstantFunction<dim> lambda(1.), mu(1.);\\n  \\u00a0     std::vector<Tensor<1, dim>>            rhs_values(n_q_points);\\n  \\u00a0 \\n  \\u00a0 \\n  \\u00a0     BlockVector<double> filtered_unfiltered_density_solution = test_solution;\\n  \\u00a0     BlockVector<double> filter_adjoint_unfiltered_density_multiplier_solution =\\n  \\u00a0       test_solution;\\n  \\u00a0     filtered_unfiltered_density_solution.block(\\n  \\u00a0       SolutionBlocks::unfiltered_density) = 0;\\n  \\u00a0     filter_adjoint_unfiltered_density_multiplier_solution.block(\\n  \\u00a0       SolutionBlocks::unfiltered_density_multiplier) = 0;\\n  \\u00a0 \\n  \\u00a0     filter_matrix.vmult(filtered_unfiltered_density_solution.block(\\n  \\u00a0                           SolutionBlocks::unfiltered_density),\\n  \\u00a0                         test_solution.block(\\n  \\u00a0                           SolutionBlocks::unfiltered_density));\\n  \\u00a0     filter_matrix.Tvmult(\\n  \\u00a0       filter_adjoint_unfiltered_density_multiplier_solution.block(\\n  \\u00a0         SolutionBlocks::unfiltered_density_multiplier),\\n  \\u00a0       test_solution.block(SolutionBlocks::unfiltered_density_multiplier));\\n  \\u00a0 \\n  \\u00a0 \\n  \\u00a0     std::vector<double>                  old_density_values(n_q_points);\\n  \\u00a0     std::vector<Tensor<1, dim>>          old_displacement_values(n_q_points);\\n  \\u00a0     std::vector<double>                  old_displacement_divs(n_q_points);\\n  \\u00a0     std::vector<SymmetricTensor<2, dim>> old_displacement_symmgrads(n_q_points);\\n  \\u00a0     std::vector<Tensor<1, dim>> old_displacement_multiplier_values(n_q_points);\\n  \\u00a0     std::vector<double>         old_displacement_multiplier_divs(n_q_points);\\n  \\u00a0     std::vector<SymmetricTensor<2, dim>> old_displacement_multiplier_symmgrads(\\n  \\u00a0       n_q_points);\\n  \\u00a0     std::vector<double> old_lower_slack_multiplier_values(n_q_points);\\n  \\u00a0     std::vector<double> old_upper_slack_multiplier_values(n_q_points);\\n  \\u00a0     std::vector<double> old_lower_slack_values(n_q_points);\\n  \\u00a0     std::vector<double> old_upper_slack_values(n_q_points);\\n  \\u00a0     std::vector<double> old_unfiltered_density_values(n_q_points);\\n  \\u00a0     std::vector<double> old_unfiltered_density_multiplier_values(n_q_points);\\n  \\u00a0     std::vector<double> filtered_unfiltered_density_values(n_q_points);\\n  \\u00a0     std::vector<double> filter_adjoint_unfiltered_density_multiplier_values(\\n  \\u00a0       n_q_points);\\n  \\u00a0 \\n  \\u00a0     using namespace ValueExtractors;\\n  \\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n  \\u00a0       {\\n  \\u00a0         cell_rhs = 0;\\n  \\u00a0 \\n  \\u00a0         cell->get_dof_indices(local_dof_indices);\\n  \\u00a0 \\n  \\u00a0         fe_values.reinit(cell);\\n  \\u00a0 \\n  \\u00a0         lambda.value_list(fe_values.get_quadrature_points(), lambda_values);\\n  \\u00a0         mu.value_list(fe_values.get_quadrature_points(), mu_values);\\n  \\u00a0 \\n  \\u00a0         fe_values[densities<dim>].get_function_values(test_solution,\\n  \\u00a0                                                       old_density_values);\\n  \\u00a0         fe_values[displacements<dim>].get_function_values(\\n  \\u00a0           test_solution, old_displacement_values);\\n  \\u00a0         fe_values[displacements<dim>].get_function_divergences(\\n  \\u00a0           test_solution, old_displacement_divs);\\n  \\u00a0         fe_values[displacements<dim>].get_function_symmetric_gradients(\\n  \\u00a0           test_solution, old_displacement_symmgrads);\\n  \\u00a0         fe_values[displacement_multipliers<dim>].get_function_values(\\n  \\u00a0           test_solution, old_displacement_multiplier_values);\\n  \\u00a0         fe_values[displacement_multipliers<dim>].get_function_divergences(\\n  \\u00a0           test_solution, old_displacement_multiplier_divs);\\n  \\u00a0         fe_values[displacement_multipliers<dim>]\\n  \\u00a0           .get_function_symmetric_gradients(\\n  \\u00a0             test_solution, old_displacement_multiplier_symmgrads);\\n  \\u00a0         fe_values[density_lower_slacks<dim>].get_function_values(\\n  \\u00a0           test_solution, old_lower_slack_values);\\n  \\u00a0         fe_values[density_lower_slack_multipliers<dim>].get_function_values(\\n  \\u00a0           test_solution, old_lower_slack_multiplier_values);\\n  \\u00a0         fe_values[density_upper_slacks<dim>].get_function_values(\\n  \\u00a0           test_solution, old_upper_slack_values);\\n  \\u00a0         fe_values[density_upper_slack_multipliers<dim>].get_function_values(\\n  \\u00a0           test_solution, old_upper_slack_multiplier_values);\\n  \\u00a0         fe_values[unfiltered_densities<dim>].get_function_values(\\n  \\u00a0           test_solution, old_unfiltered_density_values);\\n  \\u00a0         fe_values[unfiltered_density_multipliers<dim>].get_function_values(\\n  \\u00a0           test_solution, old_unfiltered_density_multiplier_values);\\n  \\u00a0         fe_values[unfiltered_densities<dim>].get_function_values(\\n  \\u00a0           filtered_unfiltered_density_solution,\\n  \\u00a0           filtered_unfiltered_density_values);\\n  \\u00a0         fe_values[unfiltered_density_multipliers<dim>].get_function_values(\\n  \\u00a0           filter_adjoint_unfiltered_density_multiplier_solution,\\n  \\u00a0           filter_adjoint_unfiltered_density_multiplier_values);\\n  \\u00a0 \\n  \\u00a0         for (const auto q_point : fe_values.quadrature_point_indices())\\n  \\u00a0           {\\n  \\u00a0             for (const auto i : fe_values.dof_indices())\\n  \\u00a0               {\\n  \\u00a0                 const SymmetricTensor<2, dim> displacement_phi_i_symmgrad =\\n  \\u00a0                   fe_values[displacements<dim>].symmetric_gradient(i, q_point);\\n  \\u00a0                 const double displacement_phi_i_div =\\n  \\u00a0                   fe_values[displacements<dim>].divergence(i, q_point);\\n  \\u00a0 \\n  \\u00a0                 const SymmetricTensor<2, dim>\\n  \\u00a0                   displacement_multiplier_phi_i_symmgrad =\\n  \\u00a0                     fe_values[displacement_multipliers<dim>].symmetric_gradient(\\n  \\u00a0                       i, q_point);\\n  \\u00a0                 const double displacement_multiplier_phi_i_div =\\n  \\u00a0                   fe_values[displacement_multipliers<dim>].divergence(i,\\n  \\u00a0                                                                       q_point);\\n  \\u00a0 \\n  \\u00a0 \\n  \\u00a0                 const double density_phi_i =\\n  \\u00a0                   fe_values[densities<dim>].value(i, q_point);\\n  \\u00a0                 const double unfiltered_density_phi_i =\\n  \\u00a0                   fe_values[unfiltered_densities<dim>].value(i, q_point);\\n  \\u00a0                 const double unfiltered_density_multiplier_phi_i =\\n  \\u00a0                   fe_values[unfiltered_density_multipliers<dim>].value(i,\\n  \\u00a0                                                                        q_point);\\n  \\u00a0 \\n  \\u00a0                 const double lower_slack_multiplier_phi_i =\\n  \\u00a0                   fe_values[density_lower_slack_multipliers<dim>].value(\\n  \\u00a0                     i, q_point);\\n  \\u00a0 \\n  \\u00a0                 const double lower_slack_phi_i =\\n  \\u00a0                   fe_values[density_lower_slacks<dim>].value(i, q_point);\\n  \\u00a0 \\n  \\u00a0                 const double upper_slack_phi_i =\\n  \\u00a0                   fe_values[density_upper_slacks<dim>].value(i, q_point);\\n  \\u00a0 \\n  \\u00a0                 const double upper_slack_multiplier_phi_i =\\n  \\u00a0                   fe_values[density_upper_slack_multipliers<dim>].value(\\n  \\u00a0                     i, q_point);\\n  \\u00a0 \\n  \\u00a0                 /* Equation 1: This equation, along with equations\\n* \\u00a0                  * 2 and 3, are the variational derivatives of the\\n* \\u00a0                  * Lagrangian with respect to the decision\\n* \\u00a0                  * variables - the density, displacement, and\\n* \\u00a0                  * unfiltered density. */\\n  \\u00a0                 cell_rhs(i) +=\\n  \\u00a0                   -1 * fe_values.JxW(q_point) *\\n  \\u00a0                   (density_penalty_exponent *\\n  \\u00a0                      std::pow(old_density_values[q_point],\\n  \\u00a0                               density_penalty_exponent - 1) *\\n  \\u00a0                      density_phi_i *\\n  \\u00a0                      (old_displacement_multiplier_divs[q_point] *\\n  \\u00a0                         old_displacement_divs[q_point] *\\n  \\u00a0                         lambda_values[q_point] +\\n  \\u00a0                       2 * mu_values[q_point] *\\n  \\u00a0                         (old_displacement_symmgrads[q_point] *\\n  \\u00a0                          old_displacement_multiplier_symmgrads[q_point])) -\\n  \\u00a0                    density_phi_i *\\n  \\u00a0                      old_unfiltered_density_multiplier_values[q_point]);\\n  \\u00a0 \\n  \\u00a0                 /* Equation 2; the boundary terms will be added further down\\n* \\u00a0                  * below. */\\n  \\u00a0                 cell_rhs(i) +=\\n  \\u00a0                   -1 * fe_values.JxW(q_point) *\\n  \\u00a0                   (std::pow(old_density_values[q_point],\\n  \\u00a0                             density_penalty_exponent) *\\n  \\u00a0                    (old_displacement_multiplier_divs[q_point] *\\n  \\u00a0                       displacement_phi_i_div * lambda_values[q_point] +\\n  \\u00a0                     2 * mu_values[q_point] *\\n  \\u00a0                       (old_displacement_multiplier_symmgrads[q_point] *\\n  \\u00a0                        displacement_phi_i_symmgrad)));\\n  \\u00a0 \\n  \\u00a0                 /* Equation 3 */\\n  \\u00a0                 cell_rhs(i) +=\\n  \\u00a0                   -1 * fe_values.JxW(q_point) *\\n  \\u00a0                   (unfiltered_density_phi_i *\\n  \\u00a0                      filter_adjoint_unfiltered_density_multiplier_values\\n  \\u00a0                        [q_point] +\\n  \\u00a0                    unfiltered_density_phi_i *\\n  \\u00a0                      old_upper_slack_multiplier_values[q_point] +\\n  \\u00a0                    -1 * unfiltered_density_phi_i *\\n  \\u00a0                      old_lower_slack_multiplier_values[q_point]);\\n  \\u00a0 \\n  \\u00a0 \\n  \\u00a0 \\n  \\u00a0                 /* Equation 4; boundary term will again be dealt\\n* \\u00a0                  * with below. This equation being driven to 0\\n* \\u00a0                  * ensures that the elasticity equation is met as\\n* \\u00a0                  * a constraint. */\\n  \\u00a0                 cell_rhs(i) += -1 * fe_values.JxW(q_point) *\\n  \\u00a0                                (std::pow(old_density_values[q_point],\\n  \\u00a0                                          density_penalty_exponent) *\\n  \\u00a0                                 (old_displacement_divs[q_point] *\\n  \\u00a0                                    displacement_multiplier_phi_i_div *\\n  \\u00a0                                    lambda_values[q_point] +\\n  \\u00a0                                  2 * mu_values[q_point] *\\n  \\u00a0                                    (displacement_multiplier_phi_i_symmgrad *\\n  \\u00a0                                     old_displacement_symmgrads[q_point])));\\n  \\u00a0 \\n  \\u00a0                 /* Equation 5: This equation sets the lower slack\\n* \\u00a0                  * variable equal to the unfiltered density,\\n* \\u00a0                  * giving a minimum density of 0. */\\n  \\u00a0                 cell_rhs(i) += fe_values.JxW(q_point) *\\n  \\u00a0                                (lower_slack_multiplier_phi_i *\\n  \\u00a0                                 (old_unfiltered_density_values[q_point] -\\n  \\u00a0                                  old_lower_slack_values[q_point]));\\n  \\u00a0 \\n  \\u00a0                 /* Equation 6: This equation sets the upper slack\\n* \\u00a0                  * variable equal to one minus the unfiltered\\n* \\u00a0                  * density. */\\n  \\u00a0                 cell_rhs(i) += fe_values.JxW(q_point) *\\n  \\u00a0                                (upper_slack_multiplier_phi_i *\\n  \\u00a0                                 (1 - old_unfiltered_density_values[q_point] -\\n  \\u00a0                                  old_upper_slack_values[q_point]));\\n  \\u00a0 \\n  \\u00a0                 /* Equation 7: This is the difference between the\\n* \\u00a0                  * density and the filter applied to the\\n* \\u00a0                  * unfiltered density. This being driven to 0 by\\n* \\u00a0                  * the Newton steps ensures that the filter is\\n* \\u00a0                  * applied correctly. */\\n  \\u00a0                 cell_rhs(i) += fe_values.JxW(q_point) *\\n  \\u00a0                                (unfiltered_density_multiplier_phi_i *\\n  \\u00a0                                 (old_density_values[q_point] -\\n  \\u00a0                                  filtered_unfiltered_density_values[q_point]));\\n  \\u00a0 \\n  \\u00a0                 /* Equation 8: This along with equation 9 give the\\n* \\u00a0                  * requirement that s*z = \\\\alpha for the barrier\\n* \\u00a0                  * size alpha, and gives complementary slackness\\n* \\u00a0                  * from KKT conditions when \\\\alpha goes to 0. */\\n  \\u00a0                 cell_rhs(i) +=\\n  \\u00a0                   -1 * fe_values.JxW(q_point) *\\n  \\u00a0                   (lower_slack_phi_i *\\n  \\u00a0                    (old_lower_slack_multiplier_values[q_point] -\\n  \\u00a0                     barrier_size / old_lower_slack_values[q_point]));\\n  \\u00a0 \\n  \\u00a0                 /* Equation 9 */\\n  \\u00a0                 cell_rhs(i) +=\\n  \\u00a0                   -1 * fe_values.JxW(q_point) *\\n  \\u00a0                   (upper_slack_phi_i *\\n  \\u00a0                    (old_upper_slack_multiplier_values[q_point] -\\n  \\u00a0                     barrier_size / old_upper_slack_values[q_point]));\\n  \\u00a0               }\\n  \\u00a0           }\\n  \\u00a0 \\n  \\u00a0         for (const auto &face : cell->face_iterators())\\n  \\u00a0           {\\n  \\u00a0             if (face->at_boundary() &&\\n  \\u00a0                 face->boundary_id() == BoundaryIds::down_force)\\n  \\u00a0               {\\n  \\u00a0                 fe_face_values.reinit(cell, face);\\n  \\u00a0 \\n  \\u00a0                 for (const auto face_q_point :\\n  \\u00a0                      fe_face_values.quadrature_point_indices())\\n  \\u00a0                   {\\n  \\u00a0                     for (const auto i : fe_face_values.dof_indices())\\n  \\u00a0                       {\\n  \\u00a0                         Tensor<1, dim> traction;\\n  \\u00a0                         traction[1] = -1.;\\n  \\u00a0 \\n  \\u00a0                         cell_rhs(i) +=\\n  \\u00a0                           -1 *\\n  \\u00a0                           (traction * fe_face_values[displacements<dim>].value(\\n  \\u00a0                                         i, face_q_point)) *\\n  \\u00a0                           fe_face_values.JxW(face_q_point);\\n  \\u00a0 \\n  \\u00a0                         cell_rhs(i) +=\\n  \\u00a0                           (traction *\\n  \\u00a0                            fe_face_values[displacement_multipliers<dim>].value(\\n  \\u00a0                              i, face_q_point)) *\\n  \\u00a0                           fe_face_values.JxW(face_q_point);\\n  \\u00a0                       }\\n  \\u00a0                   }\\n  \\u00a0               }\\n  \\u00a0           }\\n  \\u00a0 \\n  \\u00a0         MatrixTools::local_apply_boundary_values(boundary_values,\\n  \\u00a0                                                  local_dof_indices,\\n  \\u00a0                                                  dummy_cell_matrix,\\n  \\u00a0                                                  cell_rhs,\\n  \\u00a0                                                  true);\\n  \\u00a0 \\n  \\u00a0         constraints.distribute_local_to_global(cell_rhs,\\n  \\u00a0                                                local_dof_indices,\\n  \\u00a0                                                test_rhs);\\n  \\u00a0       }\\n  \\u00a0 \\n  \\u00a0     return test_rhs;\\n  \\u00a0   }\\n  \\u00a0 \\n  \\u00a0 \\nBlockVectorBase::blockBlockType & block(const unsigned int i)\\nTensorDefinition tensor.h:471\\ninternal::reinitvoid reinit(MatrixBlock< MatrixType > &v, const BlockSparsityPattern &p)Definition matrix_block.h:617\\ninternal::EvaluatorQuantity::value@ value\\ntypes::boundary_idunsigned int boundary_idDefinition types.h:144\\n Computing the merit function\\nThe algorithm we use herein uses a \\\"watchdog\\\" strategy to determine where and how far to go from the current iterate. We base the watchdog strategy on an exact \\\\(l_1\\\\) merit function. This function calculates the exact \\\\(l_1\\\\) merit of a given, putative, next iterate.\\nThe merit function consists of the sum of the objective function (which is simply an integral of external forces (on the boundary of the domain) times the displacement values of a test solution (typically, the current solution plus some multiple of the Newton update), and the \\\\(l_1\\\\) norms of the Lagrange multiplier components of residual vectors. The following code computes these parts in turn:\\n\\u00a0   template <int dim>\\n\\u00a0   double SANDTopOpt<dim>::calculate_exact_merit(\\n\\u00a0     const BlockVector<double> &test_solution)\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope t(timer, \\\"merit function\\\");\\n\\u00a0 \\nStart with computing the objective function:\\n\\u00a0     double objective_function_merit = 0;\\n\\u00a0     {\\n\\u00a0       MappingQ<dim>         mapping(1);\\n\\u00a0       const QGauss<dim>     quadrature_formula(fe.degree + 1);\\n\\u00a0       const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);\\n\\u00a0       FEValues<dim>         fe_values(mapping,\\n\\u00a0                               fe,\\n\\u00a0                               quadrature_formula,\\n\\u00a0                               update_values | update_gradients |\\n\\u00a0                                 update_quadrature_points | update_JxW_values);\\n\\u00a0       FEFaceValues<dim>     fe_face_values(mapping,\\n\\u00a0                                        fe,\\n\\u00a0                                        face_quadrature_formula,\\n\\u00a0                                        update_values |\\n\\u00a0                                          update_quadrature_points |\\n\\u00a0                                          update_normal_vectors |\\n\\u00a0                                          update_JxW_values);\\n\\u00a0 \\n\\u00a0       const unsigned int n_face_q_points = face_quadrature_formula.size();\\n\\u00a0 \\n\\u00a0       std::vector<Tensor<1, dim>> displacement_face_values(n_face_q_points);\\n\\u00a0 \\n\\u00a0       for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0         {\\n\\u00a0           for (const auto &face : cell->face_iterators())\\n\\u00a0             {\\n\\u00a0               if (face->at_boundary() &&\\n\\u00a0                   face->boundary_id() == BoundaryIds::down_force)\\n\\u00a0                 {\\n\\u00a0                   fe_face_values.reinit(cell, face);\\n\\u00a0                   fe_face_values[ValueExtractors::displacements<dim>]\\n\\u00a0                     .get_function_values(test_solution,\\n\\u00a0                                          displacement_face_values);\\n\\u00a0                   for (unsigned int face_q_point = 0;\\n\\u00a0                        face_q_point < n_face_q_points;\\n\\u00a0                        ++face_q_point)\\n\\u00a0                     {\\n\\u00a0                       Tensor<1, dim> traction;\\n\\u00a0                       traction[1] = -1.;\\n\\u00a0 \\n\\u00a0                       objective_function_merit +=\\n\\u00a0                         (traction * displacement_face_values[face_q_point]) *\\n\\u00a0                         fe_face_values.JxW(face_q_point);\\n\\u00a0                     }\\n\\u00a0                 }\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     for (const auto &cell : triangulation.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         objective_function_merit =\\n\\u00a0           objective_function_merit -\\n\\u00a0           barrier_size * cell->measure() *\\n\\u00a0             std::log(test_solution.block(\\n\\u00a0               SolutionBlocks::density_lower_slack)[cell->active_cell_index()]);\\n\\u00a0         objective_function_merit =\\n\\u00a0           objective_function_merit -\\n\\u00a0           barrier_size * cell->measure() *\\n\\u00a0             std::log(test_solution.block(\\n\\u00a0               SolutionBlocks::density_upper_slack)[cell->active_cell_index()]);\\n\\u00a0       }\\n\\u00a0 \\nstd::log::VectorizedArray< Number, width > log(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6849\\nThen compute the residual and take the \\\\(l_1\\\\) norms of the components that correspond to Lagrange multipliers. We add those to the objective function computed above, and return the sum at the bottom:\\n\\u00a0     const BlockVector<double> test_rhs = calculate_test_rhs(test_solution);\\n\\u00a0 \\n\\u00a0     const double elasticity_constraint_merit =\\n\\u00a0       penalty_multiplier *\\n\\u00a0       test_rhs.block(SolutionBlocks::displacement_multiplier).l1_norm();\\n\\u00a0     const double filter_constraint_merit =\\n\\u00a0       penalty_multiplier *\\n\\u00a0       test_rhs.block(SolutionBlocks::unfiltered_density_multiplier).l1_norm();\\n\\u00a0     const double lower_slack_merit =\\n\\u00a0       penalty_multiplier *\\n\\u00a0       test_rhs.block(SolutionBlocks::density_lower_slack_multiplier).l1_norm();\\n\\u00a0     const double upper_slack_merit =\\n\\u00a0       penalty_multiplier *\\n\\u00a0       test_rhs.block(SolutionBlocks::density_upper_slack_multiplier).l1_norm();\\n\\u00a0 \\n\\u00a0     const double total_merit =\\n\\u00a0       objective_function_merit + elasticity_constraint_merit +\\n\\u00a0       filter_constraint_merit + lower_slack_merit + upper_slack_merit;\\n\\u00a0     return total_merit;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n Finding a search direction\\nNext up is the function that actually computes a search direction starting at the current state (passed as the first argument) and returns the resulting vector. To this end, the function first calls the functions that assemble the linear system that corresponds to the Newton system, and that solve it.\\nThis function also updates the penalty multiplier in the merit function, and then returns the largest scaled feasible step. It uses the calculate_max_step_sizes() function to find the largest feasible step that satisfies \\\\(s>0\\\\) and \\\\(z>0\\\\).\\n\\u00a0   template <int dim>\\n\\u00a0   BlockVector<double> SANDTopOpt<dim>::find_max_step()\\n\\u00a0   {\\n\\u00a0     assemble_system();\\n\\u00a0     BlockVector<double> step = solve();\\n\\u00a0 \\nNext we are going to update penalty_multiplier. In essence, a larger penalty multiplier makes us consider the constraints more. Looking at the Hessian and gradient with respect to the step we want to take with our decision variables, and comparing that to the norm of our constraint error gives us a way to ensure that our merit function is \\\"exact\\\" - that is, it has a minimum in the same location that the objective function does. As our merit function is exact for any penalty multiplier over some minimum value, we only keep the computed value if it increases the penalty multiplier.\\n\\u00a0     const std::vector<unsigned int> decision_variables = {\\n\\u00a0       SolutionBlocks::density,\\n\\u00a0       SolutionBlocks::displacement,\\n\\u00a0       SolutionBlocks::unfiltered_density,\\n\\u00a0       SolutionBlocks::density_upper_slack,\\n\\u00a0       SolutionBlocks::density_lower_slack};\\n\\u00a0     double hess_part = 0;\\n\\u00a0     double grad_part = 0;\\n\\u00a0     for (const unsigned int decision_variable_i : decision_variables)\\n\\u00a0       {\\n\\u00a0         for (const unsigned int decision_variable_j : decision_variables)\\n\\u00a0           {\\n\\u00a0             Vector<double> temp_vector(step.block(decision_variable_i).size());\\n\\u00a0             system_matrix.block(decision_variable_i, decision_variable_j)\\n\\u00a0               .vmult(temp_vector, step.block(decision_variable_j));\\n\\u00a0             hess_part += step.block(decision_variable_i) * temp_vector;\\n\\u00a0           }\\n\\u00a0         grad_part -= system_rhs.block(decision_variable_i) *\\n\\u00a0                      step.block(decision_variable_i);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     const std::vector<unsigned int> equality_constraint_multipliers = {\\n\\u00a0       SolutionBlocks::displacement_multiplier,\\n\\u00a0       SolutionBlocks::unfiltered_density_multiplier,\\n\\u00a0       SolutionBlocks::density_lower_slack_multiplier,\\n\\u00a0       SolutionBlocks::density_upper_slack_multiplier};\\n\\u00a0     double constraint_norm = 0;\\n\\u00a0     for (const unsigned int multiplier_i : equality_constraint_multipliers)\\n\\u00a0       constraint_norm += system_rhs.block(multiplier_i).linfty_norm();\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     double test_penalty_multiplier;\\n\\u00a0     if (hess_part > 0)\\n\\u00a0       test_penalty_multiplier =\\n\\u00a0         (grad_part + .5 * hess_part) / (.05 * constraint_norm);\\n\\u00a0     else\\n\\u00a0       test_penalty_multiplier = (grad_part) / (.05 * constraint_norm);\\n\\u00a0 \\n\\u00a0     penalty_multiplier = std::max(penalty_multiplier, test_penalty_multiplier);\\n\\u00a0 \\nstd::max::VectorizedArray< Number, width > max(const ::VectorizedArray< Number, width > &, const ::VectorizedArray< Number, width > &)Definition vectorization.h:6943\\nlinfty_normNumber linfty_norm(const Tensor< 2, dim, Number > &t)Definition tensor.h:3065\\nBased on all of this, we can now compute step sizes for the primal and dual (Lagrange multiplier) variables. Once we have these, we scale the components of the solution vector, and that is what this function returns.\\n\\u00a0     const std::pair<double, double> max_step_sizes =\\n\\u00a0       calculate_max_step_size(nonlinear_solution, step);\\n\\u00a0     const double step_size_s = max_step_sizes.first;\\n\\u00a0     const double step_size_z = max_step_sizes.second;\\n\\u00a0 \\n\\u00a0     step.block(SolutionBlocks::density) *= step_size_s;\\n\\u00a0     step.block(SolutionBlocks::displacement) *= step_size_s;\\n\\u00a0     step.block(SolutionBlocks::unfiltered_density) *= step_size_s;\\n\\u00a0     step.block(SolutionBlocks::displacement_multiplier) *= step_size_z;\\n\\u00a0     step.block(SolutionBlocks::unfiltered_density_multiplier) *= step_size_z;\\n\\u00a0     step.block(SolutionBlocks::density_lower_slack) *= step_size_s;\\n\\u00a0     step.block(SolutionBlocks::density_lower_slack_multiplier) *= step_size_z;\\n\\u00a0     step.block(SolutionBlocks::density_upper_slack) *= step_size_s;\\n\\u00a0     step.block(SolutionBlocks::density_upper_slack_multiplier) *= step_size_z;\\n\\u00a0 \\n\\u00a0     return step;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n Computing a scaled step\\nThe next function then implements a back-tracking algorithm for a line search. It keeps shrinking step size until it finds a step where the merit is decreased, and then returns the new location based on the current state vector, and the direction to go into, times the step length.\\n\\u00a0   template <int dim>\\n\\u00a0   BlockVector<double>\\n\\u00a0   SANDTopOpt<dim>::compute_scaled_step(const BlockVector<double> &state,\\n\\u00a0                                        const BlockVector<double> &max_step,\\n\\u00a0                                        const double descent_requirement)\\n\\u00a0   {\\n\\u00a0     const double merit_derivative =\\n\\u00a0       (calculate_exact_merit(state + 1e-4 * max_step) -\\n\\u00a0        calculate_exact_merit(state)) /\\n\\u00a0       1e-4;\\n\\u00a0     double       step_size                 = 1;\\n\\u00a0     unsigned int max_linesearch_iterations = 10;\\n\\u00a0     for (unsigned int k = 0; k < max_linesearch_iterations; ++k)\\n\\u00a0       {\\n\\u00a0         if (calculate_exact_merit(state + step_size * max_step) <\\n\\u00a0             calculate_exact_merit(state) +\\n\\u00a0               step_size * descent_requirement * merit_derivative)\\n\\u00a0           break;\\n\\u00a0         else\\n\\u00a0           step_size = step_size / 2;\\n\\u00a0       }\\n\\u00a0     return state + (step_size * max_step);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n Checking for convergence\\nThe final auxiliary function in this block is the one that checks to see if the KKT conditions are sufficiently met so that the overall algorithm can lower the barrier size. It does so by computing the \\\\(l_1\\\\) norm of the residual, which is what calculate_test_rhs() computes.\\n\\u00a0   template <int dim>\\n\\u00a0   bool SANDTopOpt<dim>::check_convergence(const BlockVector<double> &state)\\n\\u00a0   {\\n\\u00a0     const BlockVector<double> test_rhs      = calculate_test_rhs(state);\\n\\u00a0     const double              test_rhs_norm = test_rhs.l1_norm();\\n\\u00a0 \\n\\u00a0     const double convergence_condition = 1e-2;\\n\\u00a0     const double target_norm           = convergence_condition * barrier_size;\\n\\u00a0 \\n\\u00a0     std::cout << \\\"    Checking convergence. Current rhs norm is \\\"\\n\\u00a0               << test_rhs_norm << \\\", target is \\\" << target_norm << std::endl;\\n\\u00a0 \\n\\u00a0     return (test_rhs_norm < target_norm);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n Postprocessing the solution\\nThe first of the postprocessing functions outputs information in a VTU file for visualization. It looks long, but it's really just the same as what was done in step-22, for example, just with (a lot) more solution variables:\\n\\u00a0   template <int dim>\\n\\u00a0   void SANDTopOpt<dim>::output_results(const unsigned int iteration) const\\n\\u00a0   {\\n\\u00a0     std::vector<std::string> solution_names(1, \\\"density\\\");\\n\\u00a0     std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n\\u00a0       data_component_interpretation(\\n\\u00a0         1, DataComponentInterpretation::component_is_scalar);\\n\\u00a0     for (unsigned int i = 0; i < dim; ++i)\\n\\u00a0       {\\n\\u00a0         solution_names.emplace_back(\\\"displacement\\\");\\n\\u00a0         data_component_interpretation.push_back(\\n\\u00a0           DataComponentInterpretation::component_is_part_of_vector);\\n\\u00a0       }\\n\\u00a0     solution_names.emplace_back(\\\"unfiltered_density\\\");\\n\\u00a0     data_component_interpretation.push_back(\\n\\u00a0       DataComponentInterpretation::component_is_scalar);\\n\\u00a0     for (unsigned int i = 0; i < dim; ++i)\\n\\u00a0       {\\n\\u00a0         solution_names.emplace_back(\\\"displacement_multiplier\\\");\\n\\u00a0         data_component_interpretation.push_back(\\n\\u00a0           DataComponentInterpretation::component_is_part_of_vector);\\n\\u00a0       }\\n\\u00a0     solution_names.emplace_back(\\\"unfiltered_density_multiplier\\\");\\n\\u00a0     data_component_interpretation.push_back(\\n\\u00a0       DataComponentInterpretation::component_is_scalar);\\n\\u00a0     solution_names.emplace_back(\\\"low_slack\\\");\\n\\u00a0     data_component_interpretation.push_back(\\n\\u00a0       DataComponentInterpretation::component_is_scalar);\\n\\u00a0     solution_names.emplace_back(\\\"low_slack_multiplier\\\");\\n\\u00a0     data_component_interpretation.push_back(\\n\\u00a0       DataComponentInterpretation::component_is_scalar);\\n\\u00a0     solution_names.emplace_back(\\\"high_slack\\\");\\n\\u00a0     data_component_interpretation.push_back(\\n\\u00a0       DataComponentInterpretation::component_is_scalar);\\n\\u00a0     solution_names.emplace_back(\\\"high_slack_multiplier\\\");\\n\\u00a0     data_component_interpretation.push_back(\\n\\u00a0       DataComponentInterpretation::component_is_scalar);\\n\\u00a0 \\n\\u00a0     DataOut<dim> data_out;\\n\\u00a0     data_out.attach_dof_handler(dof_handler);\\n\\u00a0     data_out.add_data_vector(nonlinear_solution,\\n\\u00a0                              solution_names,\\n\\u00a0                              DataOut<dim>::type_dof_data,\\n\\u00a0                              data_component_interpretation);\\n\\u00a0     data_out.build_patches();\\n\\u00a0 \\n\\u00a0     std::ofstream output(\\\"solution\\\" + std::to_string(iteration) + \\\".vtu\\\");\\n\\u00a0     data_out.write_vtu(output);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nDataComponentInterpretation::component_is_scalar@ component_is_scalarDefinition data_component_interpretation.h:52\\nDataComponentInterpretation::component_is_part_of_vector@ component_is_part_of_vectorDefinition data_component_interpretation.h:58\\nThe second of these functions outputs the solution as an .stl file for 3d printing. STL files are made up of triangles and normal vectors, and we will use it to show all of those cells with a density value larger than zero by first extruding the mesh from a \\\\(z\\\\) value of zero to \\\\(z=0.25\\\\), and then generating two triangles for each face of the cells with a sufficiently large density value. The triangle nodes must go counter-clockwise when looking from the outside, and the normal vectors must be unit vectors pointing outwards, which requires a few checks.\\n\\u00a0   template <int dim>\\n\\u00a0   void SANDTopOpt<dim>::write_as_stl()\\n\\u00a0   {\\n\\u00a0     static_assert(dim == 2,\\n\\u00a0                   \\\"This function is not implemented for anything \\\"\\n\\u00a0                   \\\"other than the 2d case.\\\");\\n\\u00a0 \\n\\u00a0     std::ofstream stlfile;\\n\\u00a0     stlfile.open(\\\"bridge.stl\\\");\\n\\u00a0 \\n\\u00a0     stlfile << \\\"solid bridge\\\\n\\\" << std::scientific;\\n\\u00a0     double height = .25;\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         if (nonlinear_solution.block(\\n\\u00a0               SolutionBlocks::density)[cell->active_cell_index()] > 0.5)\\n\\u00a0           {\\nWe have now found a cell with a density value larger than zero. Let us start by writing out the bottom and top faces. Owing to the ordering issue mentioned above, we have to make sure that we understand whether a cell has a right- or left-handed coordinate system. We do this by interrogating the directions of the two edges starting at vertex 0 and whether they form a right-handed coordinate system.\\n\\u00a0             const Tensor<1, dim> edge_directions[2] = {cell->vertex(1) -\\n\\u00a0                                                          cell->vertex(0),\\n\\u00a0                                                        cell->vertex(2) -\\n\\u00a0                                                          cell->vertex(0)};\\n\\u00a0             const Tensor<2, dim> edge_tensor(\\n\\u00a0               {{edge_directions[0][0], edge_directions[0][1]},\\n\\u00a0                {edge_directions[1][0], edge_directions[1][1]}});\\n\\u00a0             const bool is_right_handed_cell = (determinant(edge_tensor) > 0);\\n\\u00a0 \\n\\u00a0             if (is_right_handed_cell)\\n\\u00a0               {\\n\\u00a0                 /* Write one side at z = 0. */\\n\\u00a0                 stlfile << \\\"   facet normal \\\" << 0.000000e+00 << ' '\\n\\u00a0                         << 0.000000e+00 << ' ' << -1.000000e+00 << '\\\\n';\\n\\u00a0                 stlfile << \\\"      outer loop\\\\n\\\";\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(0)[0] << ' '\\n\\u00a0                         << cell->vertex(0)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(2)[0] << ' '\\n\\u00a0                         << cell->vertex(2)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(1)[0] << ' '\\n\\u00a0                         << cell->vertex(1)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n\\u00a0                 stlfile << \\\"      endloop\\\\n\\\";\\n\\u00a0                 stlfile << \\\"   endfacet\\\\n\\\";\\n\\u00a0                 stlfile << \\\"   facet normal \\\" << 0.000000e+00 << ' '\\n\\u00a0                         << 0.000000e+00 << ' ' << -1.000000e+00 << '\\\\n';\\n\\u00a0                 stlfile << \\\"      outer loop\\\\n\\\";\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(1)[0] << ' '\\n\\u00a0                         << cell->vertex(1)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(2)[0] << ' '\\n\\u00a0                         << cell->vertex(2)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(3)[0] << ' '\\n\\u00a0                         << cell->vertex(3)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n\\u00a0                 stlfile << \\\"      endloop\\\\n\\\";\\n\\u00a0                 stlfile << \\\"   endfacet\\\\n\\\";\\n\\u00a0 \\n\\u00a0                 /* Write one side at z = height. */\\n\\u00a0                 stlfile << \\\"   facet normal \\\" << 0.000000e+00 << ' '\\n\\u00a0                         << 0.000000e+00 << ' ' << 1.000000e+00 << '\\\\n';\\n\\u00a0                 stlfile << \\\"      outer loop\\\\n\\\";\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(0)[0] << ' '\\n\\u00a0                         << cell->vertex(0)[1] << ' ' << height << '\\\\n';\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(1)[0] << ' '\\n\\u00a0                         << cell->vertex(1)[1] << ' ' << height << '\\\\n';\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(2)[0] << ' '\\n\\u00a0                         << cell->vertex(2)[1] << ' ' << height << '\\\\n';\\n\\u00a0                 stlfile << \\\"      endloop\\\\n\\\";\\n\\u00a0                 stlfile << \\\"   endfacet\\\\n\\\";\\n\\u00a0                 stlfile << \\\"   facet normal \\\" << 0.000000e+00 << ' '\\n\\u00a0                         << 0.000000e+00 << ' ' << 1.000000e+00 << '\\\\n';\\n\\u00a0                 stlfile << \\\"      outer loop\\\\n\\\";\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(1)[0] << ' '\\n\\u00a0                         << cell->vertex(1)[1] << ' ' << height << '\\\\n';\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(3)[0] << ' '\\n\\u00a0                         << cell->vertex(3)[1] << ' ' << height << '\\\\n';\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(2)[0] << ' '\\n\\u00a0                         << cell->vertex(2)[1] << ' ' << height << '\\\\n';\\n\\u00a0                 stlfile << \\\"      endloop\\\\n\\\";\\n\\u00a0                 stlfile << \\\"   endfacet\\\\n\\\";\\n\\u00a0               }\\n\\u00a0             else /* The cell has a left-handed set up */\\n\\u00a0               {\\n\\u00a0                 /* Write one side at z = 0. */\\n\\u00a0                 stlfile << \\\"   facet normal \\\" << 0.000000e+00 << ' '\\n\\u00a0                         << 0.000000e+00 << ' ' << -1.000000e+00 << '\\\\n';\\n\\u00a0                 stlfile << \\\"      outer loop\\\\n\\\";\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(0)[0] << ' '\\n\\u00a0                         << cell->vertex(0)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(1)[0] << ' '\\n\\u00a0                         << cell->vertex(1)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(2)[0] << ' '\\n\\u00a0                         << cell->vertex(2)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n\\u00a0                 stlfile << \\\"      endloop\\\\n\\\";\\n\\u00a0                 stlfile << \\\"   endfacet\\\\n\\\";\\n\\u00a0                 stlfile << \\\"   facet normal \\\" << 0.000000e+00 << ' '\\n\\u00a0                         << 0.000000e+00 << ' ' << -1.000000e+00 << '\\\\n';\\n\\u00a0                 stlfile << \\\"      outer loop\\\\n\\\";\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(1)[0] << ' '\\n\\u00a0                         << cell->vertex(1)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(3)[0] << ' '\\n\\u00a0                         << cell->vertex(3)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(2)[0] << ' '\\n\\u00a0                         << cell->vertex(2)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n\\u00a0                 stlfile << \\\"      endloop\\\\n\\\";\\n\\u00a0                 stlfile << \\\"   endfacet\\\\n\\\";\\n\\u00a0 \\n\\u00a0                 /* Write one side at z = height. */\\n\\u00a0                 stlfile << \\\"   facet normal \\\" << 0.000000e+00 << ' '\\n\\u00a0                         << 0.000000e+00 << ' ' << 1.000000e+00 << '\\\\n';\\n\\u00a0                 stlfile << \\\"      outer loop\\\\n\\\";\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(0)[0] << ' '\\n\\u00a0                         << cell->vertex(0)[1] << ' ' << height << '\\\\n';\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(2)[0] << ' '\\n\\u00a0                         << cell->vertex(2)[1] << ' ' << height << '\\\\n';\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(1)[0] << ' '\\n\\u00a0                         << cell->vertex(1)[1] << ' ' << height << '\\\\n';\\n\\u00a0                 stlfile << \\\"      endloop\\\\n\\\";\\n\\u00a0                 stlfile << \\\"   endfacet\\\\n\\\";\\n\\u00a0                 stlfile << \\\"   facet normal \\\" << 0.000000e+00 << ' '\\n\\u00a0                         << 0.000000e+00 << ' ' << 1.000000e+00 << '\\\\n';\\n\\u00a0                 stlfile << \\\"      outer loop\\\\n\\\";\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(1)[0] << ' '\\n\\u00a0                         << cell->vertex(1)[1] << ' ' << height << '\\\\n';\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(2)[0] << ' '\\n\\u00a0                         << cell->vertex(2)[1] << ' ' << height << '\\\\n';\\n\\u00a0                 stlfile << \\\"         vertex \\\" << cell->vertex(3)[0] << ' '\\n\\u00a0                         << cell->vertex(3)[1] << ' ' << height << '\\\\n';\\n\\u00a0                 stlfile << \\\"      endloop\\\\n\\\";\\n\\u00a0                 stlfile << \\\"   endfacet\\\\n\\\";\\n\\u00a0               }\\n\\u00a0 \\ndeterminantDEAL_II_HOST constexpr Number determinant(const SymmetricTensor< 2, dim, Number > &)Definition symmetric_tensor.h:2724\\nNext we need to deal with the four faces of the cell, extended into the \\\\(z\\\\) direction. However, we only need to write these faces if either the face is on the domain boundary, or if it is the interface between a cell with density greater than 0.5, and a cell with a density less than 0.5.\\n\\u00a0             for (unsigned int face_number = 0;\\n\\u00a0                  face_number < GeometryInfo<dim>::faces_per_cell;\\n\\u00a0                  ++face_number)\\n\\u00a0               {\\n\\u00a0                 const typename DoFHandler<dim>::face_iterator face =\\n\\u00a0                   cell->face(face_number);\\n\\u00a0 \\n\\u00a0                 if ((face->at_boundary()) ||\\n\\u00a0                     (!face->at_boundary() &&\\n\\u00a0                      (nonlinear_solution.block(\\n\\u00a0                         0)[cell->neighbor(face_number)->active_cell_index()] <\\n\\u00a0                       0.5)))\\n\\u00a0                   {\\n\\u00a0                     const Tensor<1, dim> normal_vector =\\n\\u00a0                       (face->center() - cell->center());\\n\\u00a0                     const double normal_norm = normal_vector.norm();\\n\\u00a0                     if ((face->vertex(0)[0] - face->vertex(0)[0]) *\\n\\u00a0                             (face->vertex(1)[1] - face->vertex(0)[1]) *\\n\\u00a0                             0.000000e+00 +\\n\\u00a0                           (face->vertex(0)[1] - face->vertex(0)[1]) * (0 - 0) *\\n\\u00a0                             normal_vector[0] +\\n\\u00a0                           (height - 0) *\\n\\u00a0                             (face->vertex(1)[0] - face->vertex(0)[0]) *\\n\\u00a0                             normal_vector[1] -\\n\\u00a0                           (face->vertex(0)[0] - face->vertex(0)[0]) * (0 - 0) *\\n\\u00a0                             normal_vector[1] -\\n\\u00a0                           (face->vertex(0)[1] - face->vertex(0)[1]) *\\n\\u00a0                             (face->vertex(1)[0] - face->vertex(0)[0]) *\\n\\u00a0                             normal_vector[0] -\\n\\u00a0                           (height - 0) *\\n\\u00a0                             (face->vertex(1)[1] - face->vertex(0)[1]) * 0 >\\n\\u00a0                         0)\\n\\u00a0                       {\\n\\u00a0                         stlfile << \\\"   facet normal \\\"\\n\\u00a0                                 << normal_vector[0] / normal_norm << ' '\\n\\u00a0                                 << normal_vector[1] / normal_norm << ' '\\n\\u00a0                                 << 0.000000e+00 << '\\\\n';\\n\\u00a0                         stlfile << \\\"      outer loop\\\\n\\\";\\n\\u00a0                         stlfile << \\\"         vertex \\\" << face->vertex(0)[0]\\n\\u00a0                                 << ' ' << face->vertex(0)[1] << ' '\\n\\u00a0                                 << 0.000000e+00 << '\\\\n';\\n\\u00a0                         stlfile << \\\"         vertex \\\" << face->vertex(0)[0]\\n\\u00a0                                 << ' ' << face->vertex(0)[1] << ' ' << height\\n\\u00a0                                 << '\\\\n';\\n\\u00a0                         stlfile << \\\"         vertex \\\" << face->vertex(1)[0]\\n\\u00a0                                 << ' ' << face->vertex(1)[1] << ' '\\n\\u00a0                                 << 0.000000e+00 << '\\\\n';\\n\\u00a0                         stlfile << \\\"      endloop\\\\n\\\";\\n\\u00a0                         stlfile << \\\"   endfacet\\\\n\\\";\\n\\u00a0                         stlfile << \\\"   facet normal \\\"\\n\\u00a0                                 << normal_vector[0] / normal_norm << ' '\\n\\u00a0                                 << normal_vector[1] / normal_norm << ' '\\n\\u00a0                                 << 0.000000e+00 << '\\\\n';\\n\\u00a0                         stlfile << \\\"      outer loop\\\\n\\\";\\n\\u00a0                         stlfile << \\\"         vertex \\\" << face->vertex(0)[0]\\n\\u00a0                                 << ' ' << face->vertex(0)[1] << ' ' << height\\n\\u00a0                                 << '\\\\n';\\n\\u00a0                         stlfile << \\\"         vertex \\\" << face->vertex(1)[0]\\n\\u00a0                                 << ' ' << face->vertex(1)[1] << ' ' << height\\n\\u00a0                                 << '\\\\n';\\n\\u00a0                         stlfile << \\\"         vertex \\\" << face->vertex(1)[0]\\n\\u00a0                                 << ' ' << face->vertex(1)[1] << ' '\\n\\u00a0                                 << 0.000000e+00 << '\\\\n';\\n\\u00a0                         stlfile << \\\"      endloop\\\\n\\\";\\n\\u00a0                         stlfile << \\\"   endfacet\\\\n\\\";\\n\\u00a0                       }\\n\\u00a0                     else\\n\\u00a0                       {\\n\\u00a0                         stlfile << \\\"   facet normal \\\"\\n\\u00a0                                 << normal_vector[0] / normal_norm << ' '\\n\\u00a0                                 << normal_vector[1] / normal_norm << ' '\\n\\u00a0                                 << 0.000000e+00 << '\\\\n';\\n\\u00a0                         stlfile << \\\"      outer loop\\\\n\\\";\\n\\u00a0                         stlfile << \\\"         vertex \\\" << face->vertex(0)[0]\\n\\u00a0                                 << ' ' << face->vertex(0)[1] << ' '\\n\\u00a0                                 << 0.000000e+00 << '\\\\n';\\n\\u00a0                         stlfile << \\\"         vertex \\\" << face->vertex(1)[0]\\n\\u00a0                                 << ' ' << face->vertex(1)[1] << ' '\\n\\u00a0                                 << 0.000000e+00 << '\\\\n';\\n\\u00a0                         stlfile << \\\"         vertex \\\" << face->vertex(0)[0]\\n\\u00a0                                 << ' ' << face->vertex(0)[1] << ' ' << height\\n\\u00a0                                 << '\\\\n';\\n\\u00a0                         stlfile << \\\"      endloop\\\\n\\\";\\n\\u00a0                         stlfile << \\\"   endfacet\\\\n\\\";\\n\\u00a0                         stlfile << \\\"   facet normal \\\"\\n\\u00a0                                 << normal_vector[0] / normal_norm << ' '\\n\\u00a0                                 << normal_vector[1] / normal_norm << ' '\\n\\u00a0                                 << 0.000000e+00 << '\\\\n';\\n\\u00a0                         stlfile << \\\"      outer loop\\\\n\\\";\\n\\u00a0                         stlfile << \\\"         vertex \\\" << face->vertex(0)[0]\\n\\u00a0                                 << ' ' << face->vertex(0)[1] << ' ' << height\\n\\u00a0                                 << '\\\\n';\\n\\u00a0                         stlfile << \\\"         vertex \\\" << face->vertex(1)[0]\\n\\u00a0                                 << ' ' << face->vertex(1)[1] << ' '\\n\\u00a0                                 << 0.000000e+00 << '\\\\n';\\n\\u00a0                         stlfile << \\\"         vertex \\\" << face->vertex(1)[0]\\n\\u00a0                                 << ' ' << face->vertex(1)[1] << ' ' << height\\n\\u00a0                                 << '\\\\n';\\n\\u00a0                         stlfile << \\\"      endloop\\\\n\\\";\\n\\u00a0                         stlfile << \\\"   endfacet\\\\n\\\";\\n\\u00a0                       }\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0     stlfile << \\\"endsolid bridge\\\";\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nDoFHandler::face_iteratortypename ActiveSelector::face_iterator face_iteratorDefinition dof_handler.h:486\\n The run() function driving the overall algorithm\\nThis function finally provides the overall driver logic. It is, in the grand scheme of things, a rather complicated function primarily because the optimization algorithm is difficult: It isn't just about finding a Newton direction like in step-15 and then going a fixed distance in this direction any more, but instead about (i) determining what the optimal log-barrier penalty parameter should be in the current step, (ii) a complicated algorithm to determine how far we want to go, and other ingredients. Let us see how we can break this down into smaller chunks in the following documentation.\\nThe function starts out simple enough with first setting up the mesh, the DoFHandler, and then the various linear algebra objects necessary for the following:\\n\\u00a0   template <int dim>\\n\\u00a0   void SANDTopOpt<dim>::run()\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"filter r is: \\\" << filter_r << std::endl;\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       TimerOutput::Scope t(timer, \\\"setup\\\");\\n\\u00a0 \\n\\u00a0       create_triangulation();\\n\\u00a0 \\n\\u00a0       dof_handler.distribute_dofs(fe);\\n\\u00a0       DoFRenumbering::component_wise(dof_handler);\\n\\u00a0 \\n\\u00a0       setup_boundary_values();\\n\\u00a0       setup_block_system();\\n\\u00a0       setup_filter_matrix();\\n\\u00a0     }\\n\\u00a0 \\nDoFRenumbering::component_wisevoid component_wise(DoFHandler< dim, spacedim > &dof_handler, const std::vector< unsigned int > &target_component=std::vector< unsigned int >())Definition dof_renumbering.cc:666\\nWe then set a number of parameters that affect the log-barrier and line search components of the optimization algorithm:\\n\\u00a0     barrier_size                  = 25;\\n\\u00a0     const double min_barrier_size = .0005;\\n\\u00a0 \\n\\u00a0     const unsigned int max_uphill_steps    = 8;\\n\\u00a0     const double       descent_requirement = .0001;\\n\\u00a0 \\n\\u00a0 \\nNow start the principal iteration. The overall algorithm works by using an outer loop in which we loop until either (i) the log-barrier parameter has become small enough, or (ii) we have reached convergence. In any case, we terminate if end up with too large a number of iterations. This overall structure is encoded as a do { ... } while (...) loop where the convergence condition is at the bottom.\\n\\u00a0     unsigned int       iteration_number = 0;\\n\\u00a0     const unsigned int max_iterations   = 10000;\\n\\u00a0 \\n\\u00a0     do\\n\\u00a0       {\\n\\u00a0         std::cout << \\\"Starting outer step in iteration \\\" << iteration_number\\n\\u00a0                   << \\\" with barrier parameter \\\" << barrier_size << std::endl;\\n\\u00a0 \\nWithin this outer loop, we have an inner loop in which we try to find an update direction using the watchdog algorithm described in the introduction.\\nThe general idea of the watchdog algorithm itself is this: For a maximum of max_uphill_steps (i.e., a loop within the \\\"inner loop\\\" mentioned above) attempts, we use find_max_step() to compute a Newton update step, and add these up in the nonlinear_solution vector. In each of these attempts (starting from the place reached at the end of the previous attempt), we check whether we have reached a target value of the merit function described above. The target value is computed based on where this algorithm starts (the nonlinear_solution at the beginning of the watchdog loop, saves as watchdog_state) and the first proposed direction provided by find_max_step() in the first go-around of this loop (the k==0 case).\\n\\u00a0         do\\n\\u00a0           {\\n\\u00a0             std::cout << \\\"  Starting inner step in iteration \\\"\\n\\u00a0                       << iteration_number\\n\\u00a0                       << \\\" with merit function penalty multiplier \\\"\\n\\u00a0                       << penalty_multiplier << std::endl;\\n\\u00a0 \\n\\u00a0             bool watchdog_step_found = false;\\n\\u00a0 \\n\\u00a0             const BlockVector<double> watchdog_state = nonlinear_solution;\\n\\u00a0             BlockVector<double>       first_step;\\n\\u00a0             double target_merit     = numbers::signaling_nan<double>();\\n\\u00a0             double merit_derivative = numbers::signaling_nan<double>();\\n\\u00a0 \\n\\u00a0             for (unsigned int k = 0; k < max_uphill_steps; ++k)\\n\\u00a0               {\\n\\u00a0                 ++iteration_number;\\n\\u00a0                 const BlockVector<double> update_step = find_max_step();\\n\\u00a0 \\n\\u00a0                 if (k == 0)\\n\\u00a0                   {\\n\\u00a0                     first_step = update_step;\\n\\u00a0                     merit_derivative =\\n\\u00a0                       ((calculate_exact_merit(watchdog_state +\\n\\u00a0                                               .0001 * first_step) -\\n\\u00a0                         calculate_exact_merit(watchdog_state)) /\\n\\u00a0                        .0001);\\n\\u00a0                     target_merit = calculate_exact_merit(watchdog_state) +\\n\\u00a0                                    descent_requirement * merit_derivative;\\n\\u00a0                   }\\n\\u00a0 \\n\\u00a0                 nonlinear_solution += update_step;\\n\\u00a0                 const double current_merit =\\n\\u00a0                   calculate_exact_merit(nonlinear_solution);\\n\\u00a0 \\n\\u00a0                 std::cout << \\\"    current watchdog state merit is: \\\"\\n\\u00a0                           << current_merit << \\\"; target merit is \\\"\\n\\u00a0                           << target_merit << std::endl;\\n\\u00a0 \\n\\u00a0                 if (current_merit < target_merit)\\n\\u00a0                   {\\n\\u00a0                     watchdog_step_found = true;\\n\\u00a0                     std::cout << \\\"    found workable step after \\\" << k + 1\\n\\u00a0                               << \\\" iterations\\\" << std::endl;\\n\\u00a0                     break;\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0 \\nnumbers::signaling_nanT signaling_nan()Definition signaling_nan.h:270\\nThe next part of the algorithm then depends on whether the watchdog loop above succeeded. If it did, then we are satisfied and no further action is necessary: We just stay where we are. If, however, we took the maximal number of unsuccessful steps in the loop above, then we need to do something else, and this is what the following code block does.\\nSpecifically, from the final (unsuccessful) state of the loop above, we seek one more update direction and take what is called a \\\"stretch\\n   step\\\". If that stretch state satisfies a condition involving the merit function, then we go there. On the other hand, if the stretch state is also unacceptable (as all of the watchdog steps above were), then we discard all of the watchdog steps taken above and start over again where we had started the watchdog iterations \\u2013 that place was stored in the watchdog_state variable above. More specifically, the conditions below first test whether we take a step from watchdog_state in direction first_step, or whether we can do one more update from the stretch state to find a new place. It is possible that neither of these is actually better than the state we started from at the beginning of the watchdog algorithm, but even if that is so, that place clearly was a difficult place to be in, and getting away to start the next iteration from another place might be a useful strategy to eventually converge.\\nWe keep repeating the watchdog steps above along with the logic below until this inner iteration is finally converged (or if we run up against the maximal number of iterations \\u2013 where we count the number of linear solves as iterations and increment the counter every time we call find_max_step() since that is where the linear solve actually happens). In any case, at the end of each of these inner iterations we also output the solution in a form suitable for visualization.\\n\\u00a0             if (watchdog_step_found == false)\\n\\u00a0               {\\n\\u00a0                 ++iteration_number;\\n\\u00a0                 const BlockVector<double> update_step = find_max_step();\\n\\u00a0                 const BlockVector<double> stretch_state =\\n\\u00a0                   compute_scaled_step(nonlinear_solution,\\n\\u00a0                                       update_step,\\n\\u00a0                                       descent_requirement);\\n\\u00a0 \\nIf we did not get a successful watchdog step, we now need to decide between going back to where we started, or using the final state. We compare the merits of both of these locations, and then take a scaled step from whichever location is better. As the scaled step is guaranteed to lower the merit, we will end up keeping one of the two.\\n\\u00a0                 if ((calculate_exact_merit(nonlinear_solution) <\\n\\u00a0                      calculate_exact_merit(watchdog_state)) ||\\n\\u00a0                     (calculate_exact_merit(stretch_state) < target_merit))\\n\\u00a0                   {\\n\\u00a0                     std::cout << \\\"    Taking scaled step from end of watchdog\\\"\\n\\u00a0                               << std::endl;\\n\\u00a0                     nonlinear_solution = stretch_state;\\n\\u00a0                   }\\n\\u00a0                 else\\n\\u00a0                   {\\n\\u00a0                     std::cout\\n\\u00a0                       << \\\"    Taking scaled step from beginning of watchdog\\\"\\n\\u00a0                       << std::endl;\\n\\u00a0                     if (calculate_exact_merit(stretch_state) >\\n\\u00a0                         calculate_exact_merit(watchdog_state))\\n\\u00a0                       {\\n\\u00a0                         nonlinear_solution =\\n\\u00a0                           compute_scaled_step(watchdog_state,\\n\\u00a0                                               first_step,\\n\\u00a0                                               descent_requirement);\\n\\u00a0                       }\\n\\u00a0                     else\\n\\u00a0                       {\\n\\u00a0                         ++iteration_number;\\n\\u00a0                         nonlinear_solution = stretch_state;\\n\\u00a0                         const BlockVector<double> stretch_step =\\n\\u00a0                           find_max_step();\\n\\u00a0                         nonlinear_solution =\\n\\u00a0                           compute_scaled_step(nonlinear_solution,\\n\\u00a0                                               stretch_step,\\n\\u00a0                                               descent_requirement);\\n\\u00a0                       }\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0             output_results(iteration_number);\\n\\u00a0           }\\n\\u00a0         while ((iteration_number < max_iterations) &&\\n\\u00a0                (check_convergence(nonlinear_solution) == false));\\n\\u00a0 \\n\\u00a0 \\nAt the end of the outer loop, we have to update the barrier parameter, for which we use the following formula. The rest of the function is then simply about checking the outer loop convergence condition, and if we decide to terminate computations, about writing the final \\\"design\\\" as an STL file for use in 3d printing, and to output some timing information.\\n\\u00a0         const double barrier_size_multiplier = .8;\\n\\u00a0         const double barrier_size_exponent   = 1.2;\\n\\u00a0 \\n\\u00a0         barrier_size =\\n\\u00a0           std::max(std::min(barrier_size * barrier_size_multiplier,\\n\\u00a0                             std::pow(barrier_size, barrier_size_exponent)),\\n\\u00a0                    min_barrier_size);\\n\\u00a0 \\n\\u00a0         std::cout << std::endl;\\n\\u00a0       }\\n\\u00a0     while (((barrier_size > min_barrier_size) ||\\n\\u00a0             (check_convergence(nonlinear_solution) == false)) &&\\n\\u00a0            (iteration_number < max_iterations));\\n\\u00a0 \\n\\u00a0     write_as_stl();\\n\\u00a0   }\\n\\u00a0 } // namespace SAND\\n\\u00a0 \\nstd::min::VectorizedArray< Number, width > min(const ::VectorizedArray< Number, width > &, const ::VectorizedArray< Number, width > &)Definition vectorization.h:6960\\n The main function\\nThe remainder of the code, the main() function, is as usual:\\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       SAND::SANDTopOpt<2> elastic_problem_2d;\\n\\u00a0       elastic_problem_2d.run();\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0 \\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nTest Problem\\nThe algorithms used above are tested against a traditional topology optimization problem called the Messerschmitt-Bolkow-Blohm Beam (MBB Beam).\\nThis problem considers the optimal 2-d structure that can be built on a rectangle 6 units wide, and 1 unit tall. The bottom corners are fixed in place in the \\\\(y\\\\) direction using a zero Dirichlet boundary condition, and a downward force is applied in the center of the top of the beam by enforcing a Neumann boundary condition. The rest of the boundary is allowed to move, and has no external force applied, which takes the form of a zero Neumann boundary condition. In essence, we are asking the following question: How should we design a bridge in a way so that if the bottom left and bottom right point of the bridge are on rollers that allow these points to move horizontally but not vertically, and so that the displacement in response to the vertical force in the center is minimal.\\nWhile the total volume of the domain is 6 units, 3 units of material are allowed for the structure. Because of the symmetry of the problem, it could be posed on a rectangle of width 3 and height 1 by cutting the original domain in half, and using zero Dirichlet boundary conditions in the \\\\(x\\\\) direction along the cut edge. That said, symmetry of the solution is a good indicator that the program is working as expected, so we solved the problem on the whole domain, as shown below. [24]\\n  Using the program discussed above, we find the minimum volume of the MBB Beam and the individual components of the solution look as follows:\\n       These pictures show that what we find here is in accordance with what one typically sees in other publications on the topic [24]. Maybe more interestingly, the result looks like a truss bridge (except that we apply the load at the top of the trusses, rather than the bottom as in real truss bridges, akin to a \\\"deck\\ntruss\\\" bridge), suggesting that the designs that have been used in bridge-building for centuries are indeed based on ideas we can now show to be optimal in some sense. Possibilities for extensions\\nThe results shown above took around 75 iterations to find, which is quite concerning given the expense in solving the large linear systems in each iteration. Looking at the evolution, it does look as though the convergence has moments of happening quickly and moments of happening slowly. We believe this to be due to both a lack of precision on when and how to decrease the boundary values, as well as our choice of merit function being sub-optimal. In the future, a LOQO barrier update replacing the monotone reduction, as well as a Markov Filter in place of a merit function will decrease the number of necessary iterations significantly.\\nThe barrier decrease is most sensitive in the middle of the convergence, which is problematic, as it seems like we need it to decrease quickly, then slowly, then quickly again.\\nSecondly, the linear solver used here is just the sparse direct solver based on the SparseDirectUMFPACK class. This works reasonably well on small problems, but the formulation of the optimization problem detailed above has quite a large number of variables and so the linear problem is not only large but also has a lot of nonzero entries in many rows, even on meshes that overall are still relatively coarse. As a consequence, the solver time dominates the computations, and more sophisticated approaches at solving the linear system are necessary.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2021 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Author: Justin O'Connor, Colorado State University, 2021.\\n */\\n \\n \\n \\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/function.h>\\n#include <deal.II/base/tensor.h>\\n#include <deal.II/base/timer.h>\\n#include <deal.II/base/signaling_nan.h>\\n \\n#include <deal.II/lac/block_vector.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/block_sparse_matrix.h>\\n#include <deal.II/lac/linear_operator.h>\\n#include <deal.II/lac/packaged_operation.h>\\n#include <deal.II/lac/sparse_direct.h>\\n#include <deal.II/lac/affine_constraints.h>\\n \\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_refinement.h>\\n \\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_renumbering.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/fe/fe_values.h>\\n#include <deal.II/fe/fe_dgq.h>\\n#include <deal.II/fe/fe_system.h>\\n#include <deal.II/fe/fe_q.h>\\n \\n#include <deal.II/numerics/matrix_tools.h>\\n#include <deal.II/numerics/data_out.h>\\n \\n \\n \\n#include <iostream>\\n#include <fstream>\\n#include <algorithm>\\n \\nnamespace SAND\\n{\\n using namespace dealii;\\n \\n namespace SolutionComponents\\n  {\\n template <int dim>\\n constexpr unsigned int density = 0;\\n template <int dim>\\n constexpr unsigned int displacement = 1;\\n template <int dim>\\n constexpr unsigned int unfiltered_density = 1 + dim;\\n template <int dim>\\n constexpr unsigned int displacement_multiplier = 2 + dim;\\n template <int dim>\\n constexpr unsigned int unfiltered_density_multiplier = 2 + 2 * dim;\\n template <int dim>\\n constexpr unsigned int density_lower_slack = 3 + 2 * dim;\\n template <int dim>\\n constexpr unsigned int density_lower_slack_multiplier = 4 + 2 * dim;\\n template <int dim>\\n constexpr unsigned int density_upper_slack = 5 + 2 * dim;\\n template <int dim>\\n constexpr unsigned int density_upper_slack_multiplier = 6 + 2 * dim;\\n  } // namespace SolutionComponents\\n \\n namespace SolutionBlocks\\n  {\\n constexpr unsigned int density                        = 0;\\n constexpr unsigned int displacement                   = 1;\\n constexpr unsigned int unfiltered_density             = 2;\\n constexpr unsigned int displacement_multiplier        = 3;\\n constexpr unsigned int unfiltered_density_multiplier  = 4;\\n constexpr unsigned int density_lower_slack            = 5;\\n constexpr unsigned int density_lower_slack_multiplier = 6;\\n constexpr unsigned int density_upper_slack            = 7;\\n constexpr unsigned int density_upper_slack_multiplier = 8;\\n  } // namespace SolutionBlocks\\n \\n namespace BoundaryIds\\n  {\\n constexpr types::boundary_id down_force = 101;\\n constexpr types::boundary_id no_force   = 102;\\n  } // namespace BoundaryIds\\n \\n namespace ValueExtractors\\n  {\\n template <int dim>\\n const FEValuesExtractors::Scalar\\n      densities(SolutionComponents::density<dim>);\\n template <int dim>\\n const FEValuesExtractors::Vector\\n      displacements(SolutionComponents::displacement<dim>);\\n template <int dim>\\n const FEValuesExtractors::Scalar\\n      unfiltered_densities(SolutionComponents::unfiltered_density<dim>);\\n template <int dim>\\n const FEValuesExtractors::Vector displacement_multipliers(\\n      SolutionComponents::displacement_multiplier<dim>);\\n template <int dim>\\n const FEValuesExtractors::Scalar unfiltered_density_multipliers(\\n      SolutionComponents::unfiltered_density_multiplier<dim>);\\n template <int dim>\\n const FEValuesExtractors::Scalar\\n      density_lower_slacks(SolutionComponents::density_lower_slack<dim>);\\n template <int dim>\\n const FEValuesExtractors::Scalar density_lower_slack_multipliers(\\n      SolutionComponents::density_lower_slack_multiplier<dim>);\\n template <int dim>\\n const FEValuesExtractors::Scalar\\n      density_upper_slacks(SolutionComponents::density_upper_slack<dim>);\\n template <int dim>\\n const FEValuesExtractors::Scalar density_upper_slack_multipliers(\\n      SolutionComponents::density_upper_slack_multiplier<dim>);\\n  } // namespace ValueExtractors\\n \\n \\n \\n template <int dim>\\n class SANDTopOpt\\n  {\\n public:\\n    SANDTopOpt();\\n \\n void run();\\n \\n private:\\n void create_triangulation();\\n \\n void setup_boundary_values();\\n \\n void setup_block_system();\\n \\n void setup_filter_matrix();\\n \\n void assemble_system();\\n \\n BlockVector<double> solve();\\n \\n    std::pair<double, double>\\n    calculate_max_step_size(const BlockVector<double> &state,\\n const BlockVector<double> &step) const;\\n \\n BlockVector<double>\\n    calculate_test_rhs(const BlockVector<double> &test_solution) const;\\n \\n double calculate_exact_merit(const BlockVector<double> &test_solution);\\n \\n BlockVector<double> find_max_step();\\n \\n BlockVector<double> compute_scaled_step(const BlockVector<double> &state,\\n const BlockVector<double> &step,\\n const double descent_requirement);\\n \\n bool check_convergence(const BlockVector<double> &state);\\n \\n void output_results(const unsigned int j) const;\\n \\n void write_as_stl();\\n \\n    std::set<typename Triangulation<dim>::cell_iterator>\\n    find_relevant_neighbors(\\n typename Triangulation<dim>::cell_iterator cell) const;\\n \\n \\n Triangulation<dim> triangulation;\\n const FESystem<dim>       fe;\\n DoFHandler<dim>           dof_handler;\\n AffineConstraints<double> constraints;\\n \\n    std::map<types::global_dof_index, double> boundary_values;\\n \\n BlockSparsityPattern      sparsity_pattern;\\n BlockSparseMatrix<double> system_matrix;\\n \\n SparsityPattern      filter_sparsity_pattern;\\n SparseMatrix<double> filter_matrix;\\n \\n BlockVector<double> system_rhs;\\n BlockVector<double> nonlinear_solution;\\n \\n const double density_ratio;\\n const double density_penalty_exponent;\\n const double filter_r;\\n double       penalty_multiplier;\\n double       barrier_size;\\n \\n \\n TimerOutput timer;\\n  };\\n \\n \\n \\n \\n template <int dim>\\n  SANDTopOpt<dim>::SANDTopOpt()\\n    : fe(FE_DGQ<dim>(0),\\n         1,\\n FESystem<dim>(FE_Q<dim>(1), dim),\\n         1,\\n FE_DGQ<dim>(0),\\n         1,\\n FESystem<dim>(FE_Q<dim>(1), dim),\\n         1,\\n FE_DGQ<dim>(0),\\n         5)\\n    , dof_handler(triangulation)\\n    , density_ratio(.5)\\n    , density_penalty_exponent(3)\\n    , filter_r(.251)\\n    , penalty_multiplier(1)\\n    , timer(std::cout, TimerOutput::summary, TimerOutput::wall_times)\\n  {\\n Assert(dim > 1, ExcNotImplemented());\\n  }\\n \\n \\n template <int dim>\\n void SANDTopOpt<dim>::create_triangulation()\\n  {\\n Assert(dim == 2, ExcNotImplemented());\\n GridGenerator::subdivided_hyper_rectangle(triangulation,\\n                                              {6, 1},\\n Point<dim>(0, 0),\\n Point<dim>(6, 1));\\n \\n triangulation.refine_global(3);\\n \\n for (const auto &cell : triangulation.active_cell_iterators())\\n      {\\n for (const auto &face : cell->face_iterators())\\n          {\\n if (face->at_boundary())\\n              {\\n const auto center = face->center();\\n if (std::fabs(center[1] - 1) < 1e-12)\\n                  {\\n if ((std::fabs(center[0] - 3) < .3))\\n                      face->set_boundary_id(BoundaryIds::down_force);\\n else\\n                      face->set_boundary_id(BoundaryIds::no_force);\\n                  }\\n else\\n                  face->set_boundary_id(BoundaryIds::no_force);\\n              }\\n          }\\n      }\\n  }\\n \\n \\n template <int dim>\\n void SANDTopOpt<dim>::setup_boundary_values()\\n  {\\n    boundary_values.clear();\\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n for (const auto &face : cell->face_iterators())\\n          {\\n if (face->at_boundary())\\n              {\\n const auto center = face->center();\\n \\n if (std::fabs(center[1] - 0) < 1e-12)\\n                  {\\n for (const auto vertex_number : cell->vertex_indices())\\n                      {\\n const auto vert = cell->vertex(vertex_number);\\n \\n if (std::fabs(vert[0] - 0) < 1e-12 &&\\n                            std::fabs(vert[1] - 0) < 1e-12)\\n                          {\\n types::global_dof_index x_displacement =\\n                              cell->vertex_dof_index(vertex_number, 0);\\n types::global_dof_index y_displacement =\\n                              cell->vertex_dof_index(vertex_number, 1);\\n types::global_dof_index x_displacement_multiplier =\\n                              cell->vertex_dof_index(vertex_number, 2);\\n types::global_dof_index y_displacement_multiplier =\\n                              cell->vertex_dof_index(vertex_number, 3);\\n \\n                            boundary_values[x_displacement]            = 0;\\n                            boundary_values[y_displacement]            = 0;\\n                            boundary_values[x_displacement_multiplier] = 0;\\n                            boundary_values[y_displacement_multiplier] = 0;\\n                          }\\n \\n else if (std::fabs(vert[0] - 6) < 1e-12 &&\\n                                 std::fabs(vert[1] - 0) < 1e-12)\\n                          {\\n types::global_dof_index y_displacement =\\n                              cell->vertex_dof_index(vertex_number, 1);\\n types::global_dof_index y_displacement_multiplier =\\n                              cell->vertex_dof_index(vertex_number, 3);\\n \\n                            boundary_values[y_displacement]            = 0;\\n                            boundary_values[y_displacement_multiplier] = 0;\\n                          }\\n                      }\\n                  }\\n              }\\n          }\\n      }\\n  }\\n \\n \\n template <int dim>\\n void SANDTopOpt<dim>::setup_block_system()\\n  {\\n    std::vector<unsigned int> block_component(9, 2);\\n    block_component[0] = 0;\\n    block_component[1] = 1;\\n const std::vector<types::global_dof_index> dofs_per_block =\\n DoFTools::count_dofs_per_fe_block(dof_handler, block_component);\\n \\n const types::global_dof_index                     n_p = dofs_per_block[0];\\n const types::global_dof_index                     n_u = dofs_per_block[1];\\n const std::vector<BlockVector<double>::size_type> block_sizes = {\\n      n_p, n_u, n_p, n_u, n_p, n_p, n_p, n_p, n_p};\\n \\n BlockDynamicSparsityPattern dsp(block_sizes, block_sizes);\\n \\n \\n Table<2, DoFTools::Coupling> coupling(2 * dim + 7, 2 * dim + 7);\\n    {\\n using namespace SolutionComponents;\\n \\n      coupling[density<dim>][density<dim>] = DoFTools::always;\\n \\n for (unsigned int i = 0; i < dim; ++i)\\n        {\\n          coupling[density<dim>][displacement<dim> + i] = DoFTools::always;\\n          coupling[displacement<dim> + i][density<dim>] = DoFTools::always;\\n        }\\n \\n for (unsigned int i = 0; i < dim; ++i)\\n        {\\n          coupling[density<dim>][displacement_multiplier<dim> + i] =\\n DoFTools::always;\\n          coupling[displacement_multiplier<dim> + i][density<dim>] =\\n DoFTools::always;\\n        }\\n \\n      coupling[density<dim>][unfiltered_density_multiplier<dim>] =\\n DoFTools::always;\\n      coupling[unfiltered_density_multiplier<dim>][density<dim>] =\\n DoFTools::always;\\n \\n /* Coupling for displacement */\\n \\n for (unsigned int i = 0; i < dim; ++i)\\n        {\\n for (unsigned int k = 0; k < dim; ++k)\\n            {\\n              coupling[displacement<dim> + i]\\n                      [displacement_multiplier<dim> + k] = DoFTools::always;\\n              coupling[displacement_multiplier<dim> + k]\\n                      [displacement<dim> + i] = DoFTools::always;\\n            }\\n        }\\n \\n /* Coupling for slack variables */\\n      coupling[density_lower_slack<dim>][density_lower_slack<dim>] =\\n DoFTools::always;\\n      coupling[density_lower_slack<dim>][density_upper_slack<dim>] =\\n DoFTools::always;\\n      coupling[density_upper_slack<dim>][density_lower_slack<dim>] =\\n DoFTools::always;\\n \\n      coupling[density_lower_slack_multiplier<dim>]\\n              [density_lower_slack_multiplier<dim>] = DoFTools::always;\\n      coupling[density_lower_slack_multiplier<dim>]\\n              [density_upper_slack_multiplier<dim>] = DoFTools::always;\\n      coupling[density_upper_slack_multiplier<dim>]\\n              [density_lower_slack_multiplier<dim>] = DoFTools::always;\\n    }\\n \\n const ComponentMask density_mask =\\n      fe.component_mask(ValueExtractors::densities<dim>);\\n const IndexSet density_dofs =\\n DoFTools::extract_dofs(dof_handler, density_mask);\\n \\n types::global_dof_index last_density_dof =\\n      density_dofs.nth_index_in_set(density_dofs.n_elements() - 1);\\n    constraints.clear();\\n    {\\n      std::vector<std::pair<types::global_dof_index, double>>\\n        constraint_entries;\\n      constraint_entries.reserve(density_dofs.n_elements() - 1);\\n for (const types::global_dof_index dof_index : density_dofs)\\n        if (dof_index != last_density_dof)\\n          constraint_entries.emplace_back(dof_index, -1.);\\n \\n      constraints.add_constraint(last_density_dof, constraint_entries, 0.);\\n    }\\n    constraints.close();\\n \\n DoFTools::make_sparsity_pattern(dof_handler, coupling, dsp, constraints);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n const unsigned int i = cell->active_cell_index();\\n for (const auto &check_cell : find_relevant_neighbors(cell))\\n          {\\n const double distance =\\n              cell->center().distance(check_cell->center());\\n if (distance < filter_r)\\n              {\\n                dsp\\n                  .block(SolutionBlocks::unfiltered_density,\\n                         SolutionBlocks::unfiltered_density_multiplier)\\n                  .add(i, check_cell->active_cell_index());\\n                dsp\\n                  .block(SolutionBlocks::unfiltered_density_multiplier,\\n                         SolutionBlocks::unfiltered_density)\\n                  .add(i, check_cell->active_cell_index());\\n              }\\n          }\\n      }\\n \\n    sparsity_pattern.copy_from(dsp);\\n \\n    std::ofstream out(\\\"sparsity.plt\\\");\\n    sparsity_pattern.print_gnuplot(out);\\n \\n    system_matrix.reinit(sparsity_pattern);\\n \\n \\n    nonlinear_solution.reinit(block_sizes);\\n    system_rhs.reinit(block_sizes);\\n \\n    {\\n using namespace SolutionBlocks;\\n      nonlinear_solution.block(density).add(density_ratio);\\n      nonlinear_solution.block(unfiltered_density).add(density_ratio);\\n      nonlinear_solution.block(unfiltered_density_multiplier)\\n        .add(density_ratio);\\n      nonlinear_solution.block(density_lower_slack).add(density_ratio);\\n      nonlinear_solution.block(density_lower_slack_multiplier).add(50);\\n      nonlinear_solution.block(density_upper_slack).add(1 - density_ratio);\\n      nonlinear_solution.block(density_upper_slack_multiplier).add(50);\\n    }\\n  }\\n \\n \\n \\n template <int dim>\\n void SANDTopOpt<dim>::setup_filter_matrix()\\n  {\\n \\n    filter_sparsity_pattern.copy_from(\\n      sparsity_pattern.block(SolutionBlocks::unfiltered_density,\\n                             SolutionBlocks::unfiltered_density_multiplier));\\n    filter_matrix.reinit(filter_sparsity_pattern);\\n \\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n const unsigned int i = cell->active_cell_index();\\n for (const auto &check_cell : find_relevant_neighbors(cell))\\n          {\\n const double distance =\\n              cell->center().distance(check_cell->center());\\n if (distance < filter_r)\\n              {\\n                filter_matrix.add(i,\\n                                  check_cell->active_cell_index(),\\n                                  filter_r - distance);\\n              }\\n          }\\n      }\\n \\n for (unsigned int i = 0; i < filter_matrix.m(); ++i)\\n      {\\n double denominator = 0;\\n for (SparseMatrix<double>::iterator iter = filter_matrix.begin(i);\\n             iter != filter_matrix.end(i);\\n             iter++)\\n          denominator = denominator + iter->value();\\n for (SparseMatrix<double>::iterator iter = filter_matrix.begin(i);\\n             iter != filter_matrix.end(i);\\n             iter++)\\n          iter->value() = iter->value() / denominator;\\n      }\\n  }\\n \\n template <int dim>\\n  std::set<typename Triangulation<dim>::cell_iterator>\\n  SANDTopOpt<dim>::find_relevant_neighbors(\\n typename Triangulation<dim>::cell_iterator cell) const\\n {\\n    std::set<unsigned int>                               neighbor_ids;\\n    std::set<typename Triangulation<dim>::cell_iterator> cells_to_check;\\n \\n    neighbor_ids.insert(cell->active_cell_index());\\n    cells_to_check.insert(cell);\\n \\n bool new_neighbors_found;\\n do\\n      {\\n        new_neighbors_found = false;\\n for (const auto &check_cell :\\n std::vector<typename Triangulation<dim>::cell_iterator>(\\n               cells_to_check.begin(), cells_to_check.end()))\\n          {\\n for (const auto n : check_cell->face_indices())\\n              {\\n if (!(check_cell->face(n)->at_boundary()))\\n                  {\\n const auto  &neighbor = check_cell->neighbor(n);\\n const double distance =\\n                      cell->center().distance(neighbor->center());\\n if ((distance < filter_r) &&\\n                        !(neighbor_ids.count(neighbor->active_cell_index())))\\n                      {\\n                        cells_to_check.insert(neighbor);\\n                        neighbor_ids.insert(neighbor->active_cell_index());\\n                        new_neighbors_found = true;\\n                      }\\n                  }\\n              }\\n          }\\n      }\\n while (new_neighbors_found);\\n return cells_to_check;\\n  }\\n \\n \\n template <int dim>\\n void SANDTopOpt<dim>::assemble_system()\\n  {\\n TimerOutput::Scope t(timer, \\\"assembly\\\");\\n \\n    system_matrix = 0;\\n    system_rhs    = 0;\\n \\n \\n MappingQ<dim>         mapping(1);\\n const QGauss<dim>     quadrature_formula(fe.degree + 1);\\n const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);\\n FEValues<dim>         fe_values(mapping,\\n                            fe,\\n                            quadrature_formula,\\n update_values | update_gradients |\\n update_quadrature_points | update_JxW_values);\\n FEFaceValues<dim>     fe_face_values(mapping,\\n                                     fe,\\n                                     face_quadrature_formula,\\n update_values | update_quadrature_points |\\n update_normal_vectors |\\n update_JxW_values);\\n \\n const unsigned int dofs_per_cell = fe.dofs_per_cell;\\n const unsigned int n_q_points    = quadrature_formula.size();\\n \\n FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n Vector<double>     dummy_cell_rhs(dofs_per_cell);\\n \\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n    std::vector<double>                    lambda_values(n_q_points);\\n    std::vector<double>                    mu_values(n_q_points);\\n const Functions::ConstantFunction<dim> lambda(1.);\\n const Functions::ConstantFunction<dim> mu(1.);\\n    std::vector<Tensor<1, dim>>            rhs_values(n_q_points);\\n \\n BlockVector<double> filtered_unfiltered_density_solution =\\n      nonlinear_solution;\\n BlockVector<double> filter_adjoint_unfiltered_density_multiplier_solution =\\n      nonlinear_solution;\\n \\n    filter_matrix.vmult(filtered_unfiltered_density_solution.block(\\n                          SolutionBlocks::unfiltered_density),\\n                        nonlinear_solution.block(\\n                          SolutionBlocks::unfiltered_density));\\n    filter_matrix.Tvmult(\\n      filter_adjoint_unfiltered_density_multiplier_solution.block(\\n        SolutionBlocks::unfiltered_density_multiplier),\\n      nonlinear_solution.block(SolutionBlocks::unfiltered_density_multiplier));\\n \\n \\n    std::vector<double>                  old_density_values(n_q_points);\\n    std::vector<Tensor<1, dim>>          old_displacement_values(n_q_points);\\n    std::vector<double>                  old_displacement_divs(n_q_points);\\n    std::vector<SymmetricTensor<2, dim>> old_displacement_symmgrads(n_q_points);\\n    std::vector<Tensor<1, dim>> old_displacement_multiplier_values(n_q_points);\\n    std::vector<double>         old_displacement_multiplier_divs(n_q_points);\\n    std::vector<SymmetricTensor<2, dim>> old_displacement_multiplier_symmgrads(\\n      n_q_points);\\n    std::vector<double> old_lower_slack_multiplier_values(n_q_points);\\n    std::vector<double> old_upper_slack_multiplier_values(n_q_points);\\n    std::vector<double> old_lower_slack_values(n_q_points);\\n    std::vector<double> old_upper_slack_values(n_q_points);\\n    std::vector<double> old_unfiltered_density_values(n_q_points);\\n    std::vector<double> old_unfiltered_density_multiplier_values(n_q_points);\\n    std::vector<double> filtered_unfiltered_density_values(n_q_points);\\n    std::vector<double> filter_adjoint_unfiltered_density_multiplier_values(\\n      n_q_points);\\n \\n using namespace ValueExtractors;\\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n cell_matrix = 0;\\n \\n        cell->get_dof_indices(local_dof_indices);\\n \\n        fe_values.reinit(cell);\\n \\n lambda.value_list(fe_values.get_quadrature_points(), lambda_values);\\n        mu.value_list(fe_values.get_quadrature_points(), mu_values);\\n \\n        fe_values[densities<dim>].get_function_values(nonlinear_solution,\\n                                                      old_density_values);\\n        fe_values[displacements<dim>].get_function_values(\\n          nonlinear_solution, old_displacement_values);\\n        fe_values[displacements<dim>].get_function_divergences(\\n          nonlinear_solution, old_displacement_divs);\\n        fe_values[displacements<dim>].get_function_symmetric_gradients(\\n          nonlinear_solution, old_displacement_symmgrads);\\n        fe_values[displacement_multipliers<dim>].get_function_values(\\n          nonlinear_solution, old_displacement_multiplier_values);\\n        fe_values[displacement_multipliers<dim>].get_function_divergences(\\n          nonlinear_solution, old_displacement_multiplier_divs);\\n        fe_values[displacement_multipliers<dim>]\\n          .get_function_symmetric_gradients(\\n            nonlinear_solution, old_displacement_multiplier_symmgrads);\\n        fe_values[density_lower_slacks<dim>].get_function_values(\\n          nonlinear_solution, old_lower_slack_values);\\n        fe_values[density_lower_slack_multipliers<dim>].get_function_values(\\n          nonlinear_solution, old_lower_slack_multiplier_values);\\n        fe_values[density_upper_slacks<dim>].get_function_values(\\n          nonlinear_solution, old_upper_slack_values);\\n        fe_values[density_upper_slack_multipliers<dim>].get_function_values(\\n          nonlinear_solution, old_upper_slack_multiplier_values);\\n        fe_values[unfiltered_densities<dim>].get_function_values(\\n          nonlinear_solution, old_unfiltered_density_values);\\n        fe_values[unfiltered_density_multipliers<dim>].get_function_values(\\n          nonlinear_solution, old_unfiltered_density_multiplier_values);\\n        fe_values[unfiltered_densities<dim>].get_function_values(\\n          filtered_unfiltered_density_solution,\\n          filtered_unfiltered_density_values);\\n        fe_values[unfiltered_density_multipliers<dim>].get_function_values(\\n          filter_adjoint_unfiltered_density_multiplier_solution,\\n          filter_adjoint_unfiltered_density_multiplier_values);\\n \\n for (const auto q_point : fe_values.quadrature_point_indices())\\n          {\\n for (const auto i : fe_values.dof_indices())\\n              {\\n const SymmetricTensor<2, dim> displacement_phi_i_symmgrad =\\n                  fe_values[displacements<dim>].symmetric_gradient(i, q_point);\\n const double displacement_phi_i_div =\\n                  fe_values[displacements<dim>].divergence(i, q_point);\\n \\n const SymmetricTensor<2, dim>\\n                  displacement_multiplier_phi_i_symmgrad =\\n                    fe_values[displacement_multipliers<dim>].symmetric_gradient(\\n                      i, q_point);\\n const double displacement_multiplier_phi_i_div =\\n                  fe_values[displacement_multipliers<dim>].divergence(i,\\n                                                                      q_point);\\n \\n const double density_phi_i =\\n                  fe_values[densities<dim>].value(i, q_point);\\n const double unfiltered_density_phi_i =\\n                  fe_values[unfiltered_densities<dim>].value(i, q_point);\\n const double unfiltered_density_multiplier_phi_i =\\n                  fe_values[unfiltered_density_multipliers<dim>].value(i,\\n                                                                       q_point);\\n \\n const double lower_slack_multiplier_phi_i =\\n                  fe_values[density_lower_slack_multipliers<dim>].value(\\n                    i, q_point);\\n \\n const double lower_slack_phi_i =\\n                  fe_values[density_lower_slacks<dim>].value(i, q_point);\\n \\n const double upper_slack_phi_i =\\n                  fe_values[density_upper_slacks<dim>].value(i, q_point);\\n \\n const double upper_slack_multiplier_phi_i =\\n                  fe_values[density_upper_slack_multipliers<dim>].value(\\n                    i, q_point);\\n \\n \\n for (const auto j : fe_values.dof_indices())\\n                  {\\n const SymmetricTensor<2, dim> displacement_phi_j_symmgrad =\\n                      fe_values[displacements<dim>].symmetric_gradient(j,\\n                                                                       q_point);\\n const double displacement_phi_j_div =\\n                      fe_values[displacements<dim>].divergence(j, q_point);\\n \\n const SymmetricTensor<2, dim>\\n                      displacement_multiplier_phi_j_symmgrad =\\n                        fe_values[displacement_multipliers<dim>]\\n                          .symmetric_gradient(j, q_point);\\n const double displacement_multiplier_phi_j_div =\\n                      fe_values[displacement_multipliers<dim>].divergence(\\n                        j, q_point);\\n \\n const double density_phi_j =\\n                      fe_values[densities<dim>].value(j, q_point);\\n \\n const double unfiltered_density_phi_j =\\n                      fe_values[unfiltered_densities<dim>].value(j, q_point);\\n const double unfiltered_density_multiplier_phi_j =\\n                      fe_values[unfiltered_density_multipliers<dim>].value(\\n                        j, q_point);\\n \\n \\n const double lower_slack_phi_j =\\n                      fe_values[density_lower_slacks<dim>].value(j, q_point);\\n \\n const double upper_slack_phi_j =\\n                      fe_values[density_upper_slacks<dim>].value(j, q_point);\\n \\n const double lower_slack_multiplier_phi_j =\\n                      fe_values[density_lower_slack_multipliers<dim>].value(\\n                        j, q_point);\\n \\n const double upper_slack_multiplier_phi_j =\\n                      fe_values[density_upper_slack_multipliers<dim>].value(\\n                        j, q_point);\\n \\n \\n /* Equation 1 */\\n cell_matrix(i, j) +=\\n                      fe_values.JxW(q_point) *\\n                      (\\n \\n                        -density_phi_i * unfiltered_density_multiplier_phi_j\\n \\n                        + density_penalty_exponent *\\n                            (density_penalty_exponent - 1) *\\n std::pow(old_density_values[q_point],\\n                                     density_penalty_exponent - 2) *\\n                            density_phi_i * density_phi_j *\\n                            (old_displacement_multiplier_divs[q_point] *\\n                               old_displacement_divs[q_point] *\\n                               lambda_values[q_point] +\\n                             2 * mu_values[q_point] *\\n                               (old_displacement_symmgrads[q_point] *\\n                                old_displacement_multiplier_symmgrads[q_point]))\\n \\n                        + density_penalty_exponent *\\n std::pow(old_density_values[q_point],\\n                                     density_penalty_exponent - 1) *\\n                            density_phi_i *\\n                            (displacement_multiplier_phi_j_div *\\n                               old_displacement_divs[q_point] *\\n                               lambda_values[q_point] +\\n                             2 * mu_values[q_point] *\\n                               (old_displacement_symmgrads[q_point] *\\n                                displacement_multiplier_phi_j_symmgrad))\\n \\n                        + density_penalty_exponent *\\n std::pow(old_density_values[q_point],\\n                                     density_penalty_exponent - 1) *\\n                            density_phi_i *\\n                            (displacement_phi_j_div *\\n                               old_displacement_multiplier_divs[q_point] *\\n                               lambda_values[q_point] +\\n                             2 * mu_values[q_point] *\\n                               (old_displacement_multiplier_symmgrads[q_point] *\\n                                displacement_phi_j_symmgrad)));\\n \\n /* Equation 2 */\\n cell_matrix(i, j) +=\\n                      fe_values.JxW(q_point) *\\n                      (density_penalty_exponent *\\n std::pow(old_density_values[q_point],\\n                                  density_penalty_exponent - 1) *\\n                         density_phi_j *\\n                         (old_displacement_multiplier_divs[q_point] *\\n                            displacement_phi_i_div * lambda_values[q_point] +\\n                          2 * mu_values[q_point] *\\n                            (old_displacement_multiplier_symmgrads[q_point] *\\n                             displacement_phi_i_symmgrad))\\n \\n                       + std::pow(old_density_values[q_point],\\n                                  density_penalty_exponent) *\\n                           (displacement_multiplier_phi_j_div *\\n                              displacement_phi_i_div * lambda_values[q_point] +\\n                            2 * mu_values[q_point] *\\n                              (displacement_multiplier_phi_j_symmgrad *\\n                               displacement_phi_i_symmgrad))\\n \\n                      );\\n \\n /* Equation 3, which has to do with the filter and which is\\n                     * calculated elsewhere. */\\n cell_matrix(i, j) +=\\n                      fe_values.JxW(q_point) *\\n                      (-1 * unfiltered_density_phi_i *\\n                         lower_slack_multiplier_phi_j +\\n                       unfiltered_density_phi_i * upper_slack_multiplier_phi_j);\\n \\n \\n /* Equation 4: Primal feasibility */\\n cell_matrix(i, j) +=\\n                      fe_values.JxW(q_point) *\\n                      (\\n \\n                        density_penalty_exponent *\\n std::pow(old_density_values[q_point],\\n                                   density_penalty_exponent - 1) *\\n                          density_phi_j *\\n                          (old_displacement_divs[q_point] *\\n                             displacement_multiplier_phi_i_div *\\n                             lambda_values[q_point] +\\n                           2 * mu_values[q_point] *\\n                             (old_displacement_symmgrads[q_point] *\\n                              displacement_multiplier_phi_i_symmgrad))\\n \\n                        + std::pow(old_density_values[q_point],\\n                                   density_penalty_exponent) *\\n                            (displacement_phi_j_div *\\n                               displacement_multiplier_phi_i_div *\\n                               lambda_values[q_point] +\\n                             2 * mu_values[q_point] *\\n                               (displacement_phi_j_symmgrad *\\n                                displacement_multiplier_phi_i_symmgrad)));\\n \\n /* Equation 5: Primal feasibility */\\n cell_matrix(i, j) +=\\n                      -1 * fe_values.JxW(q_point) *\\n                      lower_slack_multiplier_phi_i *\\n                      (unfiltered_density_phi_j - lower_slack_phi_j);\\n \\n /* Equation 6: Primal feasibility */\\n cell_matrix(i, j) +=\\n                      -1 * fe_values.JxW(q_point) *\\n                      upper_slack_multiplier_phi_i *\\n                      (-1 * unfiltered_density_phi_j - upper_slack_phi_j);\\n \\n /* Equation 7: Primal feasibility - the part with the filter\\n                     * is added later */\\n cell_matrix(i, j) += -1 * fe_values.JxW(q_point) *\\n                                         unfiltered_density_multiplier_phi_i *\\n                                         (density_phi_j);\\n \\n /* Equation 8: Complementary slackness */\\n cell_matrix(i, j) +=\\n                      fe_values.JxW(q_point) *\\n                      (lower_slack_phi_i * lower_slack_multiplier_phi_j\\n \\n                       + lower_slack_phi_i * lower_slack_phi_j *\\n                           old_lower_slack_multiplier_values[q_point] /\\n                           old_lower_slack_values[q_point]);\\n \\n /* Equation 9: Complementary slackness */\\n cell_matrix(i, j) +=\\n                      fe_values.JxW(q_point) *\\n                      (upper_slack_phi_i * upper_slack_multiplier_phi_j\\n \\n \\n                       + upper_slack_phi_i * upper_slack_phi_j *\\n                           old_upper_slack_multiplier_values[q_point] /\\n                           old_upper_slack_values[q_point]);\\n                  }\\n              }\\n          }\\n \\n MatrixTools::local_apply_boundary_values(boundary_values,\\n                                                 local_dof_indices,\\n                                                 cell_matrix,\\n                                                 dummy_cell_rhs,\\n true);\\n \\n        constraints.distribute_local_to_global(cell_matrix,\\n                                               local_dof_indices,\\n                                               system_matrix);\\n      }\\n \\n    system_rhs = calculate_test_rhs(nonlinear_solution);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n const unsigned int i = cell->active_cell_index();\\n for (typename SparseMatrix<double>::iterator iter =\\n               filter_matrix.begin(i);\\n             iter != filter_matrix.end(i);\\n             ++iter)\\n          {\\n const unsigned int j     = iter->column();\\n const double value = iter->value() * cell->measure();\\n \\n            system_matrix\\n              .block(SolutionBlocks::unfiltered_density_multiplier,\\n                     SolutionBlocks::unfiltered_density)\\n              .add(i, j, value);\\n            system_matrix\\n              .block(SolutionBlocks::unfiltered_density,\\n                     SolutionBlocks::unfiltered_density_multiplier)\\n              .add(j, i, value);\\n          }\\n      }\\n  }\\n \\n \\n \\n \\n template <int dim>\\n BlockVector<double> SANDTopOpt<dim>::solve()\\n  {\\n TimerOutput::Scope t(timer, \\\"solver\\\");\\n \\n BlockVector<double> linear_solution;\\n    linear_solution.reinit(nonlinear_solution);\\n \\n SparseDirectUMFPACK A_direct;\\n    A_direct.initialize(system_matrix);\\n    A_direct.vmult(linear_solution, system_rhs);\\n \\n    constraints.distribute(linear_solution);\\n \\n return linear_solution;\\n  }\\n \\n \\n \\n \\n \\n template <int dim>\\n  std::pair<double, double> SANDTopOpt<dim>::calculate_max_step_size(\\n const BlockVector<double> &state,\\n const BlockVector<double> &step) const\\n {\\n double       fraction_to_boundary;\\n const double min_fraction_to_boundary = .8;\\n const double max_fraction_to_boundary = 1. - 1e-5;\\n \\n if (min_fraction_to_boundary < 1 - barrier_size)\\n      {\\n if (1 - barrier_size < max_fraction_to_boundary)\\n          fraction_to_boundary = 1 - barrier_size;\\n else\\n          fraction_to_boundary = max_fraction_to_boundary;\\n      }\\n else\\n      fraction_to_boundary = min_fraction_to_boundary;\\n \\n double step_size_s_low  = 0;\\n double step_size_z_low  = 0;\\n double step_size_s_high = 1;\\n double step_size_z_high = 1;\\n double step_size_s, step_size_z;\\n \\n const int max_bisection_method_steps = 50;\\n for (unsigned int k = 0; k < max_bisection_method_steps; ++k)\\n      {\\n        step_size_s = (step_size_s_low + step_size_s_high) / 2;\\n        step_size_z = (step_size_z_low + step_size_z_high) / 2;\\n \\n const BlockVector<double> state_test_s =\\n          (fraction_to_boundary * state) + (step_size_s * step);\\n \\n const BlockVector<double> state_test_z =\\n          (fraction_to_boundary * state) + (step_size_z * step);\\n \\n const bool accept_s =\\n          (state_test_s.block(SolutionBlocks::density_lower_slack)\\n             .is_non_negative()) &&\\n          (state_test_s.block(SolutionBlocks::density_upper_slack)\\n             .is_non_negative());\\n const bool accept_z =\\n          (state_test_z.block(SolutionBlocks::density_lower_slack_multiplier)\\n             .is_non_negative()) &&\\n          (state_test_z.block(SolutionBlocks::density_upper_slack_multiplier)\\n             .is_non_negative());\\n \\n if (accept_s)\\n          step_size_s_low = step_size_s;\\n else\\n          step_size_s_high = step_size_s;\\n \\n if (accept_z)\\n          step_size_z_low = step_size_z;\\n else\\n          step_size_z_high = step_size_z;\\n      }\\n \\n return {step_size_s_low, step_size_z_low};\\n  }\\n \\n \\n \\n template <int dim>\\n BlockVector<double> SANDTopOpt<dim>::calculate_test_rhs(\\n const BlockVector<double> &test_solution) const\\n {\\n BlockVector<double> test_rhs;\\n    test_rhs.reinit(system_rhs);\\n \\n MappingQ<dim>         mapping(1);\\n const QGauss<dim>     quadrature_formula(fe.degree + 1);\\n const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);\\n FEValues<dim>         fe_values(mapping,\\n                            fe,\\n                            quadrature_formula,\\n update_values | update_gradients |\\n update_quadrature_points | update_JxW_values);\\n FEFaceValues<dim>     fe_face_values(mapping,\\n                                     fe,\\n                                     face_quadrature_formula,\\n update_values | update_quadrature_points |\\n update_normal_vectors |\\n update_JxW_values);\\n \\n const unsigned int dofs_per_cell = fe.dofs_per_cell;\\n const unsigned int n_q_points    = quadrature_formula.size();\\n \\n Vector<double>     cell_rhs(dofs_per_cell);\\n FullMatrix<double> dummy_cell_matrix(dofs_per_cell, dofs_per_cell);\\n \\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n    std::vector<double> lambda_values(n_q_points);\\n    std::vector<double> mu_values(n_q_points);\\n \\n const Functions::ConstantFunction<dim> lambda(1.), mu(1.);\\n    std::vector<Tensor<1, dim>>            rhs_values(n_q_points);\\n \\n \\n BlockVector<double> filtered_unfiltered_density_solution = test_solution;\\n BlockVector<double> filter_adjoint_unfiltered_density_multiplier_solution =\\n      test_solution;\\n    filtered_unfiltered_density_solution.block(\\n      SolutionBlocks::unfiltered_density) = 0;\\n    filter_adjoint_unfiltered_density_multiplier_solution.block(\\n      SolutionBlocks::unfiltered_density_multiplier) = 0;\\n \\n    filter_matrix.vmult(filtered_unfiltered_density_solution.block(\\n                          SolutionBlocks::unfiltered_density),\\n                        test_solution.block(\\n                          SolutionBlocks::unfiltered_density));\\n    filter_matrix.Tvmult(\\n      filter_adjoint_unfiltered_density_multiplier_solution.block(\\n        SolutionBlocks::unfiltered_density_multiplier),\\n      test_solution.block(SolutionBlocks::unfiltered_density_multiplier));\\n \\n \\n    std::vector<double>                  old_density_values(n_q_points);\\n    std::vector<Tensor<1, dim>>          old_displacement_values(n_q_points);\\n    std::vector<double>                  old_displacement_divs(n_q_points);\\n    std::vector<SymmetricTensor<2, dim>> old_displacement_symmgrads(n_q_points);\\n    std::vector<Tensor<1, dim>> old_displacement_multiplier_values(n_q_points);\\n    std::vector<double>         old_displacement_multiplier_divs(n_q_points);\\n    std::vector<SymmetricTensor<2, dim>> old_displacement_multiplier_symmgrads(\\n      n_q_points);\\n    std::vector<double> old_lower_slack_multiplier_values(n_q_points);\\n    std::vector<double> old_upper_slack_multiplier_values(n_q_points);\\n    std::vector<double> old_lower_slack_values(n_q_points);\\n    std::vector<double> old_upper_slack_values(n_q_points);\\n    std::vector<double> old_unfiltered_density_values(n_q_points);\\n    std::vector<double> old_unfiltered_density_multiplier_values(n_q_points);\\n    std::vector<double> filtered_unfiltered_density_values(n_q_points);\\n    std::vector<double> filter_adjoint_unfiltered_density_multiplier_values(\\n      n_q_points);\\n \\n using namespace ValueExtractors;\\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n        cell_rhs = 0;\\n \\n        cell->get_dof_indices(local_dof_indices);\\n \\n        fe_values.reinit(cell);\\n \\n lambda.value_list(fe_values.get_quadrature_points(), lambda_values);\\n        mu.value_list(fe_values.get_quadrature_points(), mu_values);\\n \\n        fe_values[densities<dim>].get_function_values(test_solution,\\n                                                      old_density_values);\\n        fe_values[displacements<dim>].get_function_values(\\n          test_solution, old_displacement_values);\\n        fe_values[displacements<dim>].get_function_divergences(\\n          test_solution, old_displacement_divs);\\n        fe_values[displacements<dim>].get_function_symmetric_gradients(\\n          test_solution, old_displacement_symmgrads);\\n        fe_values[displacement_multipliers<dim>].get_function_values(\\n          test_solution, old_displacement_multiplier_values);\\n        fe_values[displacement_multipliers<dim>].get_function_divergences(\\n          test_solution, old_displacement_multiplier_divs);\\n        fe_values[displacement_multipliers<dim>]\\n          .get_function_symmetric_gradients(\\n            test_solution, old_displacement_multiplier_symmgrads);\\n        fe_values[density_lower_slacks<dim>].get_function_values(\\n          test_solution, old_lower_slack_values);\\n        fe_values[density_lower_slack_multipliers<dim>].get_function_values(\\n          test_solution, old_lower_slack_multiplier_values);\\n        fe_values[density_upper_slacks<dim>].get_function_values(\\n          test_solution, old_upper_slack_values);\\n        fe_values[density_upper_slack_multipliers<dim>].get_function_values(\\n          test_solution, old_upper_slack_multiplier_values);\\n        fe_values[unfiltered_densities<dim>].get_function_values(\\n          test_solution, old_unfiltered_density_values);\\n        fe_values[unfiltered_density_multipliers<dim>].get_function_values(\\n          test_solution, old_unfiltered_density_multiplier_values);\\n        fe_values[unfiltered_densities<dim>].get_function_values(\\n          filtered_unfiltered_density_solution,\\n          filtered_unfiltered_density_values);\\n        fe_values[unfiltered_density_multipliers<dim>].get_function_values(\\n          filter_adjoint_unfiltered_density_multiplier_solution,\\n          filter_adjoint_unfiltered_density_multiplier_values);\\n \\n for (const auto q_point : fe_values.quadrature_point_indices())\\n          {\\n for (const auto i : fe_values.dof_indices())\\n              {\\n const SymmetricTensor<2, dim> displacement_phi_i_symmgrad =\\n                  fe_values[displacements<dim>].symmetric_gradient(i, q_point);\\n const double displacement_phi_i_div =\\n                  fe_values[displacements<dim>].divergence(i, q_point);\\n \\n const SymmetricTensor<2, dim>\\n                  displacement_multiplier_phi_i_symmgrad =\\n                    fe_values[displacement_multipliers<dim>].symmetric_gradient(\\n                      i, q_point);\\n const double displacement_multiplier_phi_i_div =\\n                  fe_values[displacement_multipliers<dim>].divergence(i,\\n                                                                      q_point);\\n \\n \\n const double density_phi_i =\\n                  fe_values[densities<dim>].value(i, q_point);\\n const double unfiltered_density_phi_i =\\n                  fe_values[unfiltered_densities<dim>].value(i, q_point);\\n const double unfiltered_density_multiplier_phi_i =\\n                  fe_values[unfiltered_density_multipliers<dim>].value(i,\\n                                                                       q_point);\\n \\n const double lower_slack_multiplier_phi_i =\\n                  fe_values[density_lower_slack_multipliers<dim>].value(\\n                    i, q_point);\\n \\n const double lower_slack_phi_i =\\n                  fe_values[density_lower_slacks<dim>].value(i, q_point);\\n \\n const double upper_slack_phi_i =\\n                  fe_values[density_upper_slacks<dim>].value(i, q_point);\\n \\n const double upper_slack_multiplier_phi_i =\\n                  fe_values[density_upper_slack_multipliers<dim>].value(\\n                    i, q_point);\\n \\n /* Equation 1: This equation, along with equations\\n                 * 2 and 3, are the variational derivatives of the\\n                 * Lagrangian with respect to the decision\\n                 * variables - the density, displacement, and\\n                 * unfiltered density. */\\n                cell_rhs(i) +=\\n                  -1 * fe_values.JxW(q_point) *\\n                  (density_penalty_exponent *\\n std::pow(old_density_values[q_point],\\n                              density_penalty_exponent - 1) *\\n                     density_phi_i *\\n                     (old_displacement_multiplier_divs[q_point] *\\n                        old_displacement_divs[q_point] *\\n                        lambda_values[q_point] +\\n                      2 * mu_values[q_point] *\\n                        (old_displacement_symmgrads[q_point] *\\n                         old_displacement_multiplier_symmgrads[q_point])) -\\n                   density_phi_i *\\n                     old_unfiltered_density_multiplier_values[q_point]);\\n \\n /* Equation 2; the boundary terms will be added further down\\n                 * below. */\\n                cell_rhs(i) +=\\n                  -1 * fe_values.JxW(q_point) *\\n                  (std::pow(old_density_values[q_point],\\n                            density_penalty_exponent) *\\n                   (old_displacement_multiplier_divs[q_point] *\\n                      displacement_phi_i_div * lambda_values[q_point] +\\n                    2 * mu_values[q_point] *\\n                      (old_displacement_multiplier_symmgrads[q_point] *\\n                       displacement_phi_i_symmgrad)));\\n \\n /* Equation 3 */\\n                cell_rhs(i) +=\\n                  -1 * fe_values.JxW(q_point) *\\n                  (unfiltered_density_phi_i *\\n                     filter_adjoint_unfiltered_density_multiplier_values\\n                       [q_point] +\\n                   unfiltered_density_phi_i *\\n                     old_upper_slack_multiplier_values[q_point] +\\n                   -1 * unfiltered_density_phi_i *\\n                     old_lower_slack_multiplier_values[q_point]);\\n \\n \\n \\n /* Equation 4; boundary term will again be dealt\\n                 * with below. This equation being driven to 0\\n                 * ensures that the elasticity equation is met as\\n                 * a constraint. */\\n                cell_rhs(i) += -1 * fe_values.JxW(q_point) *\\n                               (std::pow(old_density_values[q_point],\\n                                         density_penalty_exponent) *\\n                                (old_displacement_divs[q_point] *\\n                                   displacement_multiplier_phi_i_div *\\n                                   lambda_values[q_point] +\\n                                 2 * mu_values[q_point] *\\n                                   (displacement_multiplier_phi_i_symmgrad *\\n                                    old_displacement_symmgrads[q_point])));\\n \\n /* Equation 5: This equation sets the lower slack\\n                 * variable equal to the unfiltered density,\\n                 * giving a minimum density of 0. */\\n                cell_rhs(i) += fe_values.JxW(q_point) *\\n                               (lower_slack_multiplier_phi_i *\\n                                (old_unfiltered_density_values[q_point] -\\n                                 old_lower_slack_values[q_point]));\\n \\n /* Equation 6: This equation sets the upper slack\\n                 * variable equal to one minus the unfiltered\\n                 * density. */\\n                cell_rhs(i) += fe_values.JxW(q_point) *\\n                               (upper_slack_multiplier_phi_i *\\n                                (1 - old_unfiltered_density_values[q_point] -\\n                                 old_upper_slack_values[q_point]));\\n \\n /* Equation 7: This is the difference between the\\n                 * density and the filter applied to the\\n                 * unfiltered density. This being driven to 0 by\\n                 * the Newton steps ensures that the filter is\\n                 * applied correctly. */\\n                cell_rhs(i) += fe_values.JxW(q_point) *\\n                               (unfiltered_density_multiplier_phi_i *\\n                                (old_density_values[q_point] -\\n                                 filtered_unfiltered_density_values[q_point]));\\n \\n /* Equation 8: This along with equation 9 give the\\n                 * requirement that @f$s*z = \\\\alpha@f$ for the barrier\\n                 * size alpha, and gives complementary slackness\\n                 * from KKT conditions when @f$\\\\alpha@f$ goes to 0. */\\n                cell_rhs(i) +=\\n                  -1 * fe_values.JxW(q_point) *\\n                  (lower_slack_phi_i *\\n                   (old_lower_slack_multiplier_values[q_point] -\\n                    barrier_size / old_lower_slack_values[q_point]));\\n \\n /* Equation 9 */\\n                cell_rhs(i) +=\\n                  -1 * fe_values.JxW(q_point) *\\n                  (upper_slack_phi_i *\\n                   (old_upper_slack_multiplier_values[q_point] -\\n                    barrier_size / old_upper_slack_values[q_point]));\\n              }\\n          }\\n \\n for (const auto &face : cell->face_iterators())\\n          {\\n if (face->at_boundary() &&\\n                face->boundary_id() == BoundaryIds::down_force)\\n              {\\n                fe_face_values.reinit(cell, face);\\n \\n for (const auto face_q_point :\\n                     fe_face_values.quadrature_point_indices())\\n                  {\\n for (const auto i : fe_face_values.dof_indices())\\n                      {\\n Tensor<1, dim> traction;\\n                        traction[1] = -1.;\\n \\n                        cell_rhs(i) +=\\n                          -1 *\\n                          (traction * fe_face_values[displacements<dim>].value(\\n                                        i, face_q_point)) *\\n                          fe_face_values.JxW(face_q_point);\\n \\n                        cell_rhs(i) +=\\n                          (traction *\\n                           fe_face_values[displacement_multipliers<dim>].value(\\n                             i, face_q_point)) *\\n                          fe_face_values.JxW(face_q_point);\\n                      }\\n                  }\\n              }\\n          }\\n \\n MatrixTools::local_apply_boundary_values(boundary_values,\\n                                                 local_dof_indices,\\n                                                 dummy_cell_matrix,\\n                                                 cell_rhs,\\n true);\\n \\n        constraints.distribute_local_to_global(cell_rhs,\\n                                               local_dof_indices,\\n                                               test_rhs);\\n      }\\n \\n return test_rhs;\\n  }\\n \\n \\n \\n template <int dim>\\n double SANDTopOpt<dim>::calculate_exact_merit(\\n const BlockVector<double> &test_solution)\\n  {\\n TimerOutput::Scope t(timer, \\\"merit function\\\");\\n \\n double objective_function_merit = 0;\\n    {\\n MappingQ<dim>         mapping(1);\\n const QGauss<dim>     quadrature_formula(fe.degree + 1);\\n const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);\\n FEValues<dim>         fe_values(mapping,\\n                              fe,\\n                              quadrature_formula,\\n update_values | update_gradients |\\n update_quadrature_points | update_JxW_values);\\n FEFaceValues<dim>     fe_face_values(mapping,\\n                                       fe,\\n                                       face_quadrature_formula,\\n update_values |\\n update_quadrature_points |\\n update_normal_vectors |\\n update_JxW_values);\\n \\n const unsigned int n_face_q_points = face_quadrature_formula.size();\\n \\n      std::vector<Tensor<1, dim>> displacement_face_values(n_face_q_points);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n        {\\n for (const auto &face : cell->face_iterators())\\n            {\\n if (face->at_boundary() &&\\n                  face->boundary_id() == BoundaryIds::down_force)\\n                {\\n                  fe_face_values.reinit(cell, face);\\n                  fe_face_values[ValueExtractors::displacements<dim>]\\n                    .get_function_values(test_solution,\\n                                         displacement_face_values);\\n for (unsigned int face_q_point = 0;\\n                       face_q_point < n_face_q_points;\\n                       ++face_q_point)\\n                    {\\n Tensor<1, dim> traction;\\n                      traction[1] = -1.;\\n \\n                      objective_function_merit +=\\n                        (traction * displacement_face_values[face_q_point]) *\\n                        fe_face_values.JxW(face_q_point);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n \\n for (const auto &cell : triangulation.active_cell_iterators())\\n      {\\n        objective_function_merit =\\n          objective_function_merit -\\n          barrier_size * cell->measure() *\\n std::log(test_solution.block(\\n              SolutionBlocks::density_lower_slack)[cell->active_cell_index()]);\\n        objective_function_merit =\\n          objective_function_merit -\\n          barrier_size * cell->measure() *\\n std::log(test_solution.block(\\n              SolutionBlocks::density_upper_slack)[cell->active_cell_index()]);\\n      }\\n \\n const BlockVector<double> test_rhs = calculate_test_rhs(test_solution);\\n \\n const double elasticity_constraint_merit =\\n      penalty_multiplier *\\n      test_rhs.block(SolutionBlocks::displacement_multiplier).l1_norm();\\n const double filter_constraint_merit =\\n      penalty_multiplier *\\n      test_rhs.block(SolutionBlocks::unfiltered_density_multiplier).l1_norm();\\n const double lower_slack_merit =\\n      penalty_multiplier *\\n      test_rhs.block(SolutionBlocks::density_lower_slack_multiplier).l1_norm();\\n const double upper_slack_merit =\\n      penalty_multiplier *\\n      test_rhs.block(SolutionBlocks::density_upper_slack_multiplier).l1_norm();\\n \\n const double total_merit =\\n      objective_function_merit + elasticity_constraint_merit +\\n      filter_constraint_merit + lower_slack_merit + upper_slack_merit;\\n return total_merit;\\n  }\\n \\n \\n \\n \\n \\n \\n template <int dim>\\n BlockVector<double> SANDTopOpt<dim>::find_max_step()\\n  {\\n    assemble_system();\\n BlockVector<double> step = solve();\\n \\n \\n const std::vector<unsigned int> decision_variables = {\\n      SolutionBlocks::density,\\n      SolutionBlocks::displacement,\\n      SolutionBlocks::unfiltered_density,\\n      SolutionBlocks::density_upper_slack,\\n      SolutionBlocks::density_lower_slack};\\n double hess_part = 0;\\n double grad_part = 0;\\n for (const unsigned int decision_variable_i : decision_variables)\\n      {\\n for (const unsigned int decision_variable_j : decision_variables)\\n          {\\n Vector<double> temp_vector(step.block(decision_variable_i).size());\\n            system_matrix.block(decision_variable_i, decision_variable_j)\\n              .vmult(temp_vector, step.block(decision_variable_j));\\n            hess_part += step.block(decision_variable_i) * temp_vector;\\n          }\\n        grad_part -= system_rhs.block(decision_variable_i) *\\n                     step.block(decision_variable_i);\\n      }\\n \\n const std::vector<unsigned int> equality_constraint_multipliers = {\\n      SolutionBlocks::displacement_multiplier,\\n      SolutionBlocks::unfiltered_density_multiplier,\\n      SolutionBlocks::density_lower_slack_multiplier,\\n      SolutionBlocks::density_upper_slack_multiplier};\\n double constraint_norm = 0;\\n for (const unsigned int multiplier_i : equality_constraint_multipliers)\\n      constraint_norm += system_rhs.block(multiplier_i).linfty_norm();\\n \\n \\n double test_penalty_multiplier;\\n if (hess_part > 0)\\n      test_penalty_multiplier =\\n        (grad_part + .5 * hess_part) / (.05 * constraint_norm);\\n else\\n      test_penalty_multiplier = (grad_part) / (.05 * constraint_norm);\\n \\n    penalty_multiplier = std::max(penalty_multiplier, test_penalty_multiplier);\\n \\n const std::pair<double, double> max_step_sizes =\\n      calculate_max_step_size(nonlinear_solution, step);\\n const double step_size_s = max_step_sizes.first;\\n const double step_size_z = max_step_sizes.second;\\n \\n    step.block(SolutionBlocks::density) *= step_size_s;\\n    step.block(SolutionBlocks::displacement) *= step_size_s;\\n    step.block(SolutionBlocks::unfiltered_density) *= step_size_s;\\n    step.block(SolutionBlocks::displacement_multiplier) *= step_size_z;\\n    step.block(SolutionBlocks::unfiltered_density_multiplier) *= step_size_z;\\n    step.block(SolutionBlocks::density_lower_slack) *= step_size_s;\\n    step.block(SolutionBlocks::density_lower_slack_multiplier) *= step_size_z;\\n    step.block(SolutionBlocks::density_upper_slack) *= step_size_s;\\n    step.block(SolutionBlocks::density_upper_slack_multiplier) *= step_size_z;\\n \\n return step;\\n  }\\n \\n \\n \\n \\n template <int dim>\\n BlockVector<double>\\n  SANDTopOpt<dim>::compute_scaled_step(const BlockVector<double> &state,\\n const BlockVector<double> &max_step,\\n const double descent_requirement)\\n  {\\n const double merit_derivative =\\n      (calculate_exact_merit(state + 1e-4 * max_step) -\\n       calculate_exact_merit(state)) /\\n      1e-4;\\n double       step_size                 = 1;\\n unsigned int max_linesearch_iterations = 10;\\n for (unsigned int k = 0; k < max_linesearch_iterations; ++k)\\n      {\\n if (calculate_exact_merit(state + step_size * max_step) <\\n            calculate_exact_merit(state) +\\n              step_size * descent_requirement * merit_derivative)\\n break;\\n else\\n          step_size = step_size / 2;\\n      }\\n return state + (step_size * max_step);\\n  }\\n \\n \\n \\n template <int dim>\\n bool SANDTopOpt<dim>::check_convergence(const BlockVector<double> &state)\\n  {\\n const BlockVector<double> test_rhs      = calculate_test_rhs(state);\\n const double              test_rhs_norm = test_rhs.l1_norm();\\n \\n const double convergence_condition = 1e-2;\\n const double target_norm           = convergence_condition * barrier_size;\\n \\n    std::cout << \\\"    Checking convergence. Current rhs norm is \\\"\\n              << test_rhs_norm << \\\", target is \\\" << target_norm << std::endl;\\n \\n return (test_rhs_norm < target_norm);\\n  }\\n \\n \\n \\n template <int dim>\\n void SANDTopOpt<dim>::output_results(const unsigned int iteration) const\\n {\\n    std::vector<std::string> solution_names(1, \\\"density\\\");\\n    std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n      data_component_interpretation(\\n        1, DataComponentInterpretation::component_is_scalar);\\n for (unsigned int i = 0; i < dim; ++i)\\n      {\\n        solution_names.emplace_back(\\\"displacement\\\");\\n        data_component_interpretation.push_back(\\n DataComponentInterpretation::component_is_part_of_vector);\\n      }\\n    solution_names.emplace_back(\\\"unfiltered_density\\\");\\n    data_component_interpretation.push_back(\\n DataComponentInterpretation::component_is_scalar);\\n for (unsigned int i = 0; i < dim; ++i)\\n      {\\n        solution_names.emplace_back(\\\"displacement_multiplier\\\");\\n        data_component_interpretation.push_back(\\n DataComponentInterpretation::component_is_part_of_vector);\\n      }\\n    solution_names.emplace_back(\\\"unfiltered_density_multiplier\\\");\\n    data_component_interpretation.push_back(\\n DataComponentInterpretation::component_is_scalar);\\n    solution_names.emplace_back(\\\"low_slack\\\");\\n    data_component_interpretation.push_back(\\n DataComponentInterpretation::component_is_scalar);\\n    solution_names.emplace_back(\\\"low_slack_multiplier\\\");\\n    data_component_interpretation.push_back(\\n DataComponentInterpretation::component_is_scalar);\\n    solution_names.emplace_back(\\\"high_slack\\\");\\n    data_component_interpretation.push_back(\\n DataComponentInterpretation::component_is_scalar);\\n    solution_names.emplace_back(\\\"high_slack_multiplier\\\");\\n    data_component_interpretation.push_back(\\n DataComponentInterpretation::component_is_scalar);\\n \\n DataOut<dim> data_out;\\n    data_out.attach_dof_handler(dof_handler);\\n    data_out.add_data_vector(nonlinear_solution,\\n                             solution_names,\\n DataOut<dim>::type_dof_data,\\n                             data_component_interpretation);\\n    data_out.build_patches();\\n \\n    std::ofstream output(\\\"solution\\\" + std::to_string(iteration) + \\\".vtu\\\");\\n    data_out.write_vtu(output);\\n  }\\n \\n \\n template <int dim>\\n void SANDTopOpt<dim>::write_as_stl()\\n  {\\n static_assert(dim == 2,\\n \\\"This function is not implemented for anything \\\"\\n \\\"other than the 2d case.\\\");\\n \\n    std::ofstream stlfile;\\n    stlfile.open(\\\"bridge.stl\\\");\\n \\n    stlfile << \\\"solid bridge\\\\n\\\" << std::scientific;\\n double height = .25;\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n if (nonlinear_solution.block(\\n              SolutionBlocks::density)[cell->active_cell_index()] > 0.5)\\n          {\\n const Tensor<1, dim> edge_directions[2] = {cell->vertex(1) -\\n                                                         cell->vertex(0),\\n                                                       cell->vertex(2) -\\n                                                         cell->vertex(0)};\\n const Tensor<2, dim> edge_tensor(\\n              {{edge_directions[0][0], edge_directions[0][1]},\\n               {edge_directions[1][0], edge_directions[1][1]}});\\n const bool is_right_handed_cell = (determinant(edge_tensor) > 0);\\n \\n if (is_right_handed_cell)\\n              {\\n /* Write one side at z = 0. */\\n                stlfile << \\\"   facet normal \\\" << 0.000000e+00 << ' '\\n                        << 0.000000e+00 << ' ' << -1.000000e+00 << '\\\\n';\\n                stlfile << \\\"      outer loop\\\\n\\\";\\n                stlfile << \\\"         vertex \\\" << cell->vertex(0)[0] << ' '\\n                        << cell->vertex(0)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n                stlfile << \\\"         vertex \\\" << cell->vertex(2)[0] << ' '\\n                        << cell->vertex(2)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n                stlfile << \\\"         vertex \\\" << cell->vertex(1)[0] << ' '\\n                        << cell->vertex(1)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n                stlfile << \\\"      endloop\\\\n\\\";\\n                stlfile << \\\"   endfacet\\\\n\\\";\\n                stlfile << \\\"   facet normal \\\" << 0.000000e+00 << ' '\\n                        << 0.000000e+00 << ' ' << -1.000000e+00 << '\\\\n';\\n                stlfile << \\\"      outer loop\\\\n\\\";\\n                stlfile << \\\"         vertex \\\" << cell->vertex(1)[0] << ' '\\n                        << cell->vertex(1)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n                stlfile << \\\"         vertex \\\" << cell->vertex(2)[0] << ' '\\n                        << cell->vertex(2)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n                stlfile << \\\"         vertex \\\" << cell->vertex(3)[0] << ' '\\n                        << cell->vertex(3)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n                stlfile << \\\"      endloop\\\\n\\\";\\n                stlfile << \\\"   endfacet\\\\n\\\";\\n \\n /* Write one side at z = height. */\\n                stlfile << \\\"   facet normal \\\" << 0.000000e+00 << ' '\\n                        << 0.000000e+00 << ' ' << 1.000000e+00 << '\\\\n';\\n                stlfile << \\\"      outer loop\\\\n\\\";\\n                stlfile << \\\"         vertex \\\" << cell->vertex(0)[0] << ' '\\n                        << cell->vertex(0)[1] << ' ' << height << '\\\\n';\\n                stlfile << \\\"         vertex \\\" << cell->vertex(1)[0] << ' '\\n                        << cell->vertex(1)[1] << ' ' << height << '\\\\n';\\n                stlfile << \\\"         vertex \\\" << cell->vertex(2)[0] << ' '\\n                        << cell->vertex(2)[1] << ' ' << height << '\\\\n';\\n                stlfile << \\\"      endloop\\\\n\\\";\\n                stlfile << \\\"   endfacet\\\\n\\\";\\n                stlfile << \\\"   facet normal \\\" << 0.000000e+00 << ' '\\n                        << 0.000000e+00 << ' ' << 1.000000e+00 << '\\\\n';\\n                stlfile << \\\"      outer loop\\\\n\\\";\\n                stlfile << \\\"         vertex \\\" << cell->vertex(1)[0] << ' '\\n                        << cell->vertex(1)[1] << ' ' << height << '\\\\n';\\n                stlfile << \\\"         vertex \\\" << cell->vertex(3)[0] << ' '\\n                        << cell->vertex(3)[1] << ' ' << height << '\\\\n';\\n                stlfile << \\\"         vertex \\\" << cell->vertex(2)[0] << ' '\\n                        << cell->vertex(2)[1] << ' ' << height << '\\\\n';\\n                stlfile << \\\"      endloop\\\\n\\\";\\n                stlfile << \\\"   endfacet\\\\n\\\";\\n              }\\n else /* The cell has a left-handed set up */\\n              {\\n /* Write one side at z = 0. */\\n                stlfile << \\\"   facet normal \\\" << 0.000000e+00 << ' '\\n                        << 0.000000e+00 << ' ' << -1.000000e+00 << '\\\\n';\\n                stlfile << \\\"      outer loop\\\\n\\\";\\n                stlfile << \\\"         vertex \\\" << cell->vertex(0)[0] << ' '\\n                        << cell->vertex(0)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n                stlfile << \\\"         vertex \\\" << cell->vertex(1)[0] << ' '\\n                        << cell->vertex(1)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n                stlfile << \\\"         vertex \\\" << cell->vertex(2)[0] << ' '\\n                        << cell->vertex(2)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n                stlfile << \\\"      endloop\\\\n\\\";\\n                stlfile << \\\"   endfacet\\\\n\\\";\\n                stlfile << \\\"   facet normal \\\" << 0.000000e+00 << ' '\\n                        << 0.000000e+00 << ' ' << -1.000000e+00 << '\\\\n';\\n                stlfile << \\\"      outer loop\\\\n\\\";\\n                stlfile << \\\"         vertex \\\" << cell->vertex(1)[0] << ' '\\n                        << cell->vertex(1)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n                stlfile << \\\"         vertex \\\" << cell->vertex(3)[0] << ' '\\n                        << cell->vertex(3)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n                stlfile << \\\"         vertex \\\" << cell->vertex(2)[0] << ' '\\n                        << cell->vertex(2)[1] << ' ' << 0.000000e+00 << '\\\\n';\\n                stlfile << \\\"      endloop\\\\n\\\";\\n                stlfile << \\\"   endfacet\\\\n\\\";\\n \\n /* Write one side at z = height. */\\n                stlfile << \\\"   facet normal \\\" << 0.000000e+00 << ' '\\n                        << 0.000000e+00 << ' ' << 1.000000e+00 << '\\\\n';\\n                stlfile << \\\"      outer loop\\\\n\\\";\\n                stlfile << \\\"         vertex \\\" << cell->vertex(0)[0] << ' '\\n                        << cell->vertex(0)[1] << ' ' << height << '\\\\n';\\n                stlfile << \\\"         vertex \\\" << cell->vertex(2)[0] << ' '\\n                        << cell->vertex(2)[1] << ' ' << height << '\\\\n';\\n                stlfile << \\\"         vertex \\\" << cell->vertex(1)[0] << ' '\\n                        << cell->vertex(1)[1] << ' ' << height << '\\\\n';\\n                stlfile << \\\"      endloop\\\\n\\\";\\n                stlfile << \\\"   endfacet\\\\n\\\";\\n                stlfile << \\\"   facet normal \\\" << 0.000000e+00 << ' '\\n                        << 0.000000e+00 << ' ' << 1.000000e+00 << '\\\\n';\\n                stlfile << \\\"      outer loop\\\\n\\\";\\n                stlfile << \\\"         vertex \\\" << cell->vertex(1)[0] << ' '\\n                        << cell->vertex(1)[1] << ' ' << height << '\\\\n';\\n                stlfile << \\\"         vertex \\\" << cell->vertex(2)[0] << ' '\\n                        << cell->vertex(2)[1] << ' ' << height << '\\\\n';\\n                stlfile << \\\"         vertex \\\" << cell->vertex(3)[0] << ' '\\n                        << cell->vertex(3)[1] << ' ' << height << '\\\\n';\\n                stlfile << \\\"      endloop\\\\n\\\";\\n                stlfile << \\\"   endfacet\\\\n\\\";\\n              }\\n \\n for (unsigned int face_number = 0;\\n                 face_number < GeometryInfo<dim>::faces_per_cell;\\n                 ++face_number)\\n              {\\n const typename DoFHandler<dim>::face_iterator face =\\n                  cell->face(face_number);\\n \\n if ((face->at_boundary()) ||\\n                    (!face->at_boundary() &&\\n                     (nonlinear_solution.block(\\n                        0)[cell->neighbor(face_number)->active_cell_index()] <\\n                      0.5)))\\n                  {\\n const Tensor<1, dim> normal_vector =\\n                      (face->center() - cell->center());\\n const double normal_norm = normal_vector.norm();\\n if ((face->vertex(0)[0] - face->vertex(0)[0]) *\\n                            (face->vertex(1)[1] - face->vertex(0)[1]) *\\n                            0.000000e+00 +\\n                          (face->vertex(0)[1] - face->vertex(0)[1]) * (0 - 0) *\\n                            normal_vector[0] +\\n                          (height - 0) *\\n                            (face->vertex(1)[0] - face->vertex(0)[0]) *\\n                            normal_vector[1] -\\n                          (face->vertex(0)[0] - face->vertex(0)[0]) * (0 - 0) *\\n                            normal_vector[1] -\\n                          (face->vertex(0)[1] - face->vertex(0)[1]) *\\n                            (face->vertex(1)[0] - face->vertex(0)[0]) *\\n                            normal_vector[0] -\\n                          (height - 0) *\\n                            (face->vertex(1)[1] - face->vertex(0)[1]) * 0 >\\n                        0)\\n                      {\\n                        stlfile << \\\"   facet normal \\\"\\n                                << normal_vector[0] / normal_norm << ' '\\n                                << normal_vector[1] / normal_norm << ' '\\n                                << 0.000000e+00 << '\\\\n';\\n                        stlfile << \\\"      outer loop\\\\n\\\";\\n                        stlfile << \\\"         vertex \\\" << face->vertex(0)[0]\\n                                << ' ' << face->vertex(0)[1] << ' '\\n                                << 0.000000e+00 << '\\\\n';\\n                        stlfile << \\\"         vertex \\\" << face->vertex(0)[0]\\n                                << ' ' << face->vertex(0)[1] << ' ' << height\\n                                << '\\\\n';\\n                        stlfile << \\\"         vertex \\\" << face->vertex(1)[0]\\n                                << ' ' << face->vertex(1)[1] << ' '\\n                                << 0.000000e+00 << '\\\\n';\\n                        stlfile << \\\"      endloop\\\\n\\\";\\n                        stlfile << \\\"   endfacet\\\\n\\\";\\n                        stlfile << \\\"   facet normal \\\"\\n                                << normal_vector[0] / normal_norm << ' '\\n                                << normal_vector[1] / normal_norm << ' '\\n                                << 0.000000e+00 << '\\\\n';\\n                        stlfile << \\\"      outer loop\\\\n\\\";\\n                        stlfile << \\\"         vertex \\\" << face->vertex(0)[0]\\n                                << ' ' << face->vertex(0)[1] << ' ' << height\\n                                << '\\\\n';\\n                        stlfile << \\\"         vertex \\\" << face->vertex(1)[0]\\n                                << ' ' << face->vertex(1)[1] << ' ' << height\\n                                << '\\\\n';\\n                        stlfile << \\\"         vertex \\\" << face->vertex(1)[0]\\n                                << ' ' << face->vertex(1)[1] << ' '\\n                                << 0.000000e+00 << '\\\\n';\\n                        stlfile << \\\"      endloop\\\\n\\\";\\n                        stlfile << \\\"   endfacet\\\\n\\\";\\n                      }\\n else\\n                      {\\n                        stlfile << \\\"   facet normal \\\"\\n                                << normal_vector[0] / normal_norm << ' '\\n                                << normal_vector[1] / normal_norm << ' '\\n                                << 0.000000e+00 << '\\\\n';\\n                        stlfile << \\\"      outer loop\\\\n\\\";\\n                        stlfile << \\\"         vertex \\\" << face->vertex(0)[0]\\n                                << ' ' << face->vertex(0)[1] << ' '\\n                                << 0.000000e+00 << '\\\\n';\\n                        stlfile << \\\"         vertex \\\" << face->vertex(1)[0]\\n                                << ' ' << face->vertex(1)[1] << ' '\\n                                << 0.000000e+00 << '\\\\n';\\n                        stlfile << \\\"         vertex \\\" << face->vertex(0)[0]\\n                                << ' ' << face->vertex(0)[1] << ' ' << height\\n                                << '\\\\n';\\n                        stlfile << \\\"      endloop\\\\n\\\";\\n                        stlfile << \\\"   endfacet\\\\n\\\";\\n                        stlfile << \\\"   facet normal \\\"\\n                                << normal_vector[0] / normal_norm << ' '\\n                                << normal_vector[1] / normal_norm << ' '\\n                                << 0.000000e+00 << '\\\\n';\\n                        stlfile << \\\"      outer loop\\\\n\\\";\\n                        stlfile << \\\"         vertex \\\" << face->vertex(0)[0]\\n                                << ' ' << face->vertex(0)[1] << ' ' << height\\n                                << '\\\\n';\\n                        stlfile << \\\"         vertex \\\" << face->vertex(1)[0]\\n                                << ' ' << face->vertex(1)[1] << ' '\\n                                << 0.000000e+00 << '\\\\n';\\n                        stlfile << \\\"         vertex \\\" << face->vertex(1)[0]\\n                                << ' ' << face->vertex(1)[1] << ' ' << height\\n                                << '\\\\n';\\n                        stlfile << \\\"      endloop\\\\n\\\";\\n                        stlfile << \\\"   endfacet\\\\n\\\";\\n                      }\\n                  }\\n              }\\n          }\\n      }\\n    stlfile << \\\"endsolid bridge\\\";\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void SANDTopOpt<dim>::run()\\n  {\\n    std::cout << \\\"filter r is: \\\" << filter_r << std::endl;\\n \\n    {\\n TimerOutput::Scope t(timer, \\\"setup\\\");\\n \\n create_triangulation();\\n \\n      dof_handler.distribute_dofs(fe);\\n DoFRenumbering::component_wise(dof_handler);\\n \\n      setup_boundary_values();\\n      setup_block_system();\\n      setup_filter_matrix();\\n    }\\n \\n    barrier_size                  = 25;\\n const double min_barrier_size = .0005;\\n \\n const unsigned int max_uphill_steps    = 8;\\n const double       descent_requirement = .0001;\\n \\n \\n unsigned int       iteration_number = 0;\\n const unsigned int max_iterations   = 10000;\\n \\n do\\n      {\\n        std::cout << \\\"Starting outer step in iteration \\\" << iteration_number\\n                  << \\\" with barrier parameter \\\" << barrier_size << std::endl;\\n \\n do\\n          {\\n            std::cout << \\\"  Starting inner step in iteration \\\"\\n                      << iteration_number\\n                      << \\\" with merit function penalty multiplier \\\"\\n                      << penalty_multiplier << std::endl;\\n \\n bool watchdog_step_found = false;\\n \\n const BlockVector<double> watchdog_state = nonlinear_solution;\\n BlockVector<double>       first_step;\\n double target_merit     = numbers::signaling_nan<double>();\\n double merit_derivative = numbers::signaling_nan<double>();\\n \\n for (unsigned int k = 0; k < max_uphill_steps; ++k)\\n              {\\n                ++iteration_number;\\n const BlockVector<double> update_step = find_max_step();\\n \\n if (k == 0)\\n                  {\\n                    first_step = update_step;\\n                    merit_derivative =\\n                      ((calculate_exact_merit(watchdog_state +\\n                                              .0001 * first_step) -\\n                        calculate_exact_merit(watchdog_state)) /\\n                       .0001);\\n                    target_merit = calculate_exact_merit(watchdog_state) +\\n                                   descent_requirement * merit_derivative;\\n                  }\\n \\n                nonlinear_solution += update_step;\\n const double current_merit =\\n                  calculate_exact_merit(nonlinear_solution);\\n \\n                std::cout << \\\"    current watchdog state merit is: \\\"\\n                          << current_merit << \\\"; target merit is \\\"\\n                          << target_merit << std::endl;\\n \\n if (current_merit < target_merit)\\n                  {\\n                    watchdog_step_found = true;\\n                    std::cout << \\\"    found workable step after \\\" << k + 1\\n                              << \\\" iterations\\\" << std::endl;\\n break;\\n                  }\\n              }\\n \\n \\n \\n if (watchdog_step_found == false)\\n              {\\n                ++iteration_number;\\n const BlockVector<double> update_step = find_max_step();\\n const BlockVector<double> stretch_state =\\n                  compute_scaled_step(nonlinear_solution,\\n                                      update_step,\\n                                      descent_requirement);\\n \\n if ((calculate_exact_merit(nonlinear_solution) <\\n                     calculate_exact_merit(watchdog_state)) ||\\n                    (calculate_exact_merit(stretch_state) < target_merit))\\n                  {\\n                    std::cout << \\\"    Taking scaled step from end of watchdog\\\"\\n                              << std::endl;\\n                    nonlinear_solution = stretch_state;\\n                  }\\n else\\n                  {\\n                    std::cout\\n                      << \\\"    Taking scaled step from beginning of watchdog\\\"\\n                      << std::endl;\\n if (calculate_exact_merit(stretch_state) >\\n                        calculate_exact_merit(watchdog_state))\\n                      {\\n                        nonlinear_solution =\\n                          compute_scaled_step(watchdog_state,\\n                                              first_step,\\n                                              descent_requirement);\\n                      }\\n else\\n                      {\\n                        ++iteration_number;\\n                        nonlinear_solution = stretch_state;\\n const BlockVector<double> stretch_step =\\n                          find_max_step();\\n                        nonlinear_solution =\\n                          compute_scaled_step(nonlinear_solution,\\n                                              stretch_step,\\n                                              descent_requirement);\\n                      }\\n                  }\\n              }\\n \\n            output_results(iteration_number);\\n          }\\n while ((iteration_number < max_iterations) &&\\n               (check_convergence(nonlinear_solution) == false));\\n \\n \\n const double barrier_size_multiplier = .8;\\n const double barrier_size_exponent   = 1.2;\\n \\n        barrier_size =\\n std::max(std::min(barrier_size * barrier_size_multiplier,\\n std::pow(barrier_size, barrier_size_exponent)),\\n                   min_barrier_size);\\n \\n        std::cout << std::endl;\\n      }\\n while (((barrier_size > min_barrier_size) ||\\n            (check_convergence(nonlinear_solution) == false)) &&\\n           (iteration_number < max_iterations));\\n \\n    write_as_stl();\\n  }\\n} // namespace SAND\\n \\n \\nint main()\\n{\\n try\\n    {\\n      SAND::SANDTopOpt<2> elastic_problem_2d;\\n      elastic_problem_2d.run();\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n \\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n return 0;\\n}\\naffine_constraints.h\\nblock_sparse_matrix.h\\nblock_vector.h\\nBlockVectorBase::l1_normreal_type l1_norm() const\\nDataOutInterface::write_vtuvoid write_vtu(std::ostream &out) constDefinition data_out_base.cc:7692\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nIndexSet::n_elementssize_type n_elements() constDefinition index_set.h:1934\\nIndexSet::nth_index_in_setsize_type nth_index_in_set(const size_type local_index) constDefinition index_set.h:1982\\nSparseDirectUMFPACK::vmultvoid vmult(Vector< double > &dst, const Vector< double > &src) constDefinition sparse_direct.cc:795\\nTensor::normnumbers::NumberTraits< Number >::real_type norm() const\\nTensor::clearconstexpr void clear()\\ndof_handler.h\\ndof_renumbering.h\\ndof_tools.h\\nfe_values.h\\nfe_dgq.h\\nfe_q.h\\nfe_system.h\\nfull_matrix.h\\nfunction.h\\ngrid_refinement.h\\ntria.h\\ngrid_generator.h\\nlinear_operator.h\\nmatrix_tools.h\\nDifferentiation::SD::OptimizerType::lambda@ lambda\\nGridGenerator::Airfoil::create_triangulationvoid create_triangulation(Triangulation< dim, dim > &tria, const AdditionalData &additional_data=AdditionalData())\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\nPhysics::Elasticity::Kinematics::eSymmetricTensor< 2, dim, Number > e(const Tensor< 2, dim, Number > &F)\\nTrilinosWrappers::internal::endVectorType::value_type * end(VectorType &V)Definition trilinos_sparse_matrix.cc:64\\nTrilinosWrappers::internal::beginVectorType::value_type * begin(VectorType &V)Definition trilinos_sparse_matrix.cc:50\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\ndata_out.h\\npackaged_operation.h\\nquadrature_lib.h\\nsignaling_nan.h\\nsparse_direct.h\\ntensor.h\\ntimer.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"