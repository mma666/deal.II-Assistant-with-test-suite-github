"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_29.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-29 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-29 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-29 tutorial program\\n\\n\\nThis tutorial depends on step-4.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nProblem setting\\nThe test case\\n\\n The commented program\\n\\nInclude files\\nThe DirichletBoundaryValues class\\nThe ParameterReader class\\n\\nParameterReader::declare_parameters\\nParameterReader::read_parameters\\n\\nThe ComputeIntensity class\\nThe UltrasoundProblem class\\n\\nUltrasoundProblem::make_grid\\nUltrasoundProblem::setup_system\\nUltrasoundProblem::assemble_system\\nUltrasoundProblem::solve\\nUltrasoundProblem::output_results\\nUltrasoundProblem::run\\nThe main function\\n\\n\\n\\n Results\\n\\nPossibilities for extensions\\n\\n The plain program\\n   \\n\\n\\n This program was contributed by Moritz Allmaras at Texas A&M University. Some of the work on this tutorial program has been funded by NSF under grant DMS-0604778. \\nNote: In order to run this program, deal.II must be configured to use the UMFPACK sparse direct solver. Refer to the ReadMe for instructions how to do this.\\n Introduction\\nA question that comes up frequently is how to solve problems involving complex valued functions with deal.II. For many problems, instead of working with complex valued finite elements directly, it is often more convenient to split complex valued functions into their real and imaginary parts and use separate scalar finite element fields for discretizing each one of them. Basically this amounts to viewing a single complex valued equation as a system of two real valued equations. This short example demonstrates how this can be implemented in deal.II by using an FE_system object to stack two finite element fields representing real and imaginary parts. (The opposite approach, keeping everything complex-valued, is demonstrated in a different tutorial program: see step-58 for this.) When split into real and imaginary parts, the equations covered here fall into the class of vector-valued problems. A toplevel overview of this topic can be found in the Handling vector valued problems topic.\\nIn addition to this discussion, we also discuss the ParameterHandler class, which provides a convenient way for reading parameters from a configuration file at runtime without the need to recompile the program code.\\nProblem setting\\nThe original purpose of this program is to simulate the focusing properties of an ultrasound wave generated by a transducer lens with variable geometry. Recent applications in medical imaging use ultrasound waves not only for imaging purposes, but also to excite certain local effects in a material, like changes in optical properties, that can then be measured by other imaging techniques. A vital ingredient for these methods is the ability to focus the intensity of the ultrasound wave in a particular part of the material, ideally in a point, to be able to examine the properties of the material at that particular location.\\nTo derive a model for this problem, we think of ultrasound as a pressure wave governed by the wave equation:   \\n\\\\[\\n        \\\\frac{\\\\partial^2 U}{\\\\partial t^2}       -       c^2 \\\\Delta U = 0\\n\\\\]\\n\\n where \\\\(c\\\\) is the wave speed (that for simplicity we assume to be constant),  \\\\(U\\n= U(x,t),\\\\;x \\\\in \\\\Omega,\\\\;t\\\\in\\\\mathrm{R}\\\\). The boundary \\\\(\\\\Gamma=\\\\partial\\\\Omega\\\\) is divided into two parts \\\\(\\\\Gamma_1\\\\) and \\\\(\\\\Gamma_2=\\\\Gamma\\\\setminus\\\\Gamma_1\\\\), with \\\\(\\\\Gamma_1\\\\) representing the transducer lens and \\\\(\\\\Gamma_2\\\\) an absorbing boundary (that is, we want to choose boundary conditions on \\\\(\\\\Gamma_2\\\\) in such a way that they imitate a larger domain). On \\\\(\\\\Gamma_1\\\\), the transducer generates a wave of constant frequency \\\\({\\\\omega}>0\\\\) and constant amplitude (that we chose to be 1 here):   \\n\\\\[\\nU(x,t) = \\\\cos{\\\\omega t}, \\\\qquad x\\\\in \\\\Gamma_1\\n\\\\]\\n\\nIf there are no other (interior or boundary) sources, and since the only source has frequency \\\\(\\\\omega\\\\), then the solution admits a separation of variables of the form  \\\\(U(x,t) = \\\\textrm{Re}\\\\left(u(x)\\\\,e^{i\\\\omega\\nt})\\\\right)\\\\). The complex-valued function \\\\(u(x)\\\\) describes the spatial dependency of amplitude and phase (relative to the source) of the waves of frequency \\\\({\\\\omega}\\\\), with the amplitude being the quantity that we are interested in. By plugging this form of the solution into the wave equation, we see that for \\\\(u\\\\) we have    \\n\\\\begin{eqnarray*}\\n-\\\\omega^2 u(x) - c^2\\\\Delta u(x) &=& 0, \\\\qquad x\\\\in\\\\Omega,\\\\\\\\\\nu(x) &=& 1,  \\\\qquad x\\\\in\\\\Gamma_1.\\n\\\\end{eqnarray*}\\n\\nFor finding suitable conditions on \\\\(\\\\Gamma_2\\\\) that model an absorbing boundary, consider a wave of the form \\\\(V(x,t)=e^{i(k\\\\cdot x -\\\\omega t)}\\\\) with frequency \\\\({\\\\omega}\\\\) traveling in direction \\\\(k\\\\in {\\\\mathrm{R}^2}\\\\). In order for \\\\(V\\\\) to solve the wave equation, \\\\(|k|={\\\\frac{\\\\omega}{c}}\\\\) must hold. Suppose that this wave hits the boundary in \\\\(x_0\\\\in\\\\Gamma_2\\\\) at a right angle, i.e. \\\\(n=\\\\frac{k}{|k|}\\\\) with \\\\(n\\\\) denoting the outer unit normal of \\\\(\\\\Omega\\\\) in \\\\(x_0\\\\). Then at \\\\(x_0\\\\), this wave satisfies the equation   \\n\\\\[\\nc (n\\\\cdot\\\\nabla V) + \\\\frac{\\\\partial V}{\\\\partial t} = (i\\\\, c\\\\, |k| - i\\\\, \\\\omega) V = 0.\\n\\\\]\\n\\n Hence, by enforcing the boundary condition   \\n\\\\[\\nc (n\\\\cdot\\\\nabla U) + \\\\frac{\\\\partial U}{\\\\partial t} = 0, \\\\qquad x\\\\in\\\\Gamma_2,\\n\\\\]\\n\\n waves that hit the boundary \\\\(\\\\Gamma_2\\\\) at a right angle will be perfectly absorbed. On the other hand, those parts of the wave field that do not hit a boundary at a right angle do not satisfy this condition and enforcing it as a boundary condition will yield partial reflections, i.e. only parts of the wave will pass through the boundary as if it wasn't here whereas the remaining fraction of the wave will be reflected back into the domain.\\nIf we are willing to accept this as a sufficient approximation to an absorbing boundary we finally arrive at the following problem for \\\\(u\\\\):     \\n\\\\begin{eqnarray*}\\n-\\\\omega^2 u - c^2\\\\Delta u &=& 0, \\\\qquad x\\\\in\\\\Omega,\\\\\\\\\\nc (n\\\\cdot\\\\nabla u) + i\\\\,\\\\omega\\\\,u &=&0, \\\\qquad x\\\\in\\\\Gamma_2,\\\\\\\\\\nu &=& 1,  \\\\qquad x\\\\in\\\\Gamma_1.\\n\\\\end{eqnarray*}\\n\\n This is a Helmholtz equation (similar to the one in step-7, but this time with ''the bad sign'') with Dirichlet data on \\\\(\\\\Gamma_1\\\\) and mixed boundary conditions on \\\\(\\\\Gamma_2\\\\). Because of the condition on \\\\(\\\\Gamma_2\\\\), we cannot just treat the equations for real and imaginary parts of \\\\(u\\\\) separately. What we can do however is to view the PDE for \\\\(u\\\\) as a system of two PDEs for the real and imaginary parts of \\\\(u\\\\), with the boundary condition on \\\\(\\\\Gamma_2\\\\) representing the coupling terms between the two components of the system. This works along the following lines: Let \\\\(v=\\\\textrm{Re}\\\\;u,\\\\; w=\\\\textrm{Im}\\\\;u\\\\), then in terms of \\\\(v\\\\) and \\\\(w\\\\) we have the following system:                \\n\\\\begin{eqnarray*}\\n  \\\\left.\\\\begin{array}{ccc}\\n    -\\\\omega^2 v - c^2\\\\Delta v &=& 0 \\\\quad\\\\\\\\\\n    -\\\\omega^2 w - c^2\\\\Delta w &=& 0 \\\\quad\\n  \\\\end{array}\\\\right\\\\} &\\\\;& x\\\\in\\\\Omega,\\n        \\\\\\\\\\n  \\\\left.\\\\begin{array}{ccc}\\n    c (n\\\\cdot\\\\nabla v) - \\\\omega\\\\,w &=& 0 \\\\quad\\\\\\\\\\n    c (n\\\\cdot\\\\nabla w) + \\\\omega\\\\,v &=& 0 \\\\quad\\n  \\\\end{array}\\\\right\\\\} &\\\\;& x\\\\in\\\\Gamma_2,\\n        \\\\\\\\\\n        \\\\left.\\\\begin{array}{ccc}\\n    v &=& 1 \\\\quad\\\\\\\\\\n    w &=& 0 \\\\quad\\n  \\\\end{array}\\\\right\\\\} &\\\\;& x\\\\in\\\\Gamma_1.\\n\\\\end{eqnarray*}\\n\\nFor test functions \\\\(\\\\phi,\\\\psi\\\\) with \\\\(\\\\phi|_{\\\\Gamma_1}=\\\\psi|_{\\\\Gamma_1}=0\\\\), after the usual multiplication, integration over \\\\(\\\\Omega\\\\) and applying integration by parts, we get the weak formulation        \\n\\\\begin{eqnarray*}\\n-\\\\omega^2 \\\\langle \\\\phi, v \\\\rangle_{\\\\mathrm{L}^2(\\\\Omega)}\\n+ c^2 \\\\langle \\\\nabla \\\\phi, \\\\nabla v \\\\rangle_{\\\\mathrm{L}^2(\\\\Omega)}\\n- c \\\\omega \\\\langle \\\\phi, w \\\\rangle_{\\\\mathrm{L}^2(\\\\Gamma_2)} &=& 0, \\\\\\\\\\n-\\\\omega^2 \\\\langle \\\\psi, w \\\\rangle_{\\\\mathrm{L}^2(\\\\Omega)}\\n+ c^2 \\\\langle \\\\nabla \\\\psi, \\\\nabla w \\\\rangle_{\\\\mathrm{L}^2(\\\\Omega)}\\n+ c \\\\omega \\\\langle \\\\psi, v \\\\rangle_{\\\\mathrm{L}^2(\\\\Gamma_2)} &=& 0.\\n\\\\end{eqnarray*}\\n\\nWe choose finite element spaces \\\\(V_h\\\\) and \\\\(W_h\\\\) with bases  \\\\(\\\\{\\\\phi_j\\\\}_{j=1}^n,\\n\\\\{\\\\psi_j\\\\}_{j=1}^n\\\\) and look for approximate solutions   \\n\\\\[\\nv_h = \\\\sum_{j=1}^n \\\\alpha_j \\\\phi_j, \\\\;\\\\; w_h = \\\\sum_{j=1}^n \\\\beta_j \\\\psi_j.\\n\\\\]\\n\\n Plugging into the variational form yields the equation system                        \\n\\\\[\\n\\\\renewcommand{\\\\arraystretch}{2.0}\\n\\\\left.\\\\begin{array}{ccc}\\n\\\\sum_{j=1}^n\\n\\\\left(\\n-\\\\omega^2 \\\\langle \\\\phi_i, \\\\phi_j \\\\rangle_{\\\\mathrm{L}^2(\\\\Omega)}\\n+ c^2 \\\\langle \\\\nabla \\\\phi_i, \\\\nabla \\\\phi_j \\\\rangle_{\\\\mathrm{L}^2(\\\\Omega)}\\n\\\\right)\\n\\\\alpha_j\\n- \\\\left(\\nc\\\\omega \\\\langle \\\\phi_i,\\\\psi_j\\\\rangle_{\\\\mathrm{L}^2(\\\\Gamma_2)}\\\\right)\\\\beta_j\\n&=& 0 \\\\\\\\\\n\\\\sum_{j=1}^n\\n\\\\left(\\n-\\\\omega^2 \\\\langle \\\\psi_i, \\\\psi_j \\\\rangle_{\\\\mathrm{L}^2(\\\\Omega)}\\n+ c^2 \\\\langle \\\\nabla \\\\psi_i, \\\\nabla \\\\psi_j \\\\rangle_{\\\\mathrm{L}^2(\\\\Omega)}\\n\\\\right)\\\\beta_j\\n+ \\\\left(\\nc\\\\omega \\\\langle\\n\\\\psi_i,\\\\phi_j\\\\rangle_{\\\\mathrm{L}^2(\\\\Gamma_2)}\\n\\\\right)\\\\alpha_j\\n&=& 0\\n\\\\end{array}\\\\right\\\\}\\\\;\\\\;\\\\forall\\\\; i =1,\\\\ldots,n.\\n\\\\]\\n\\n In matrix notation:                        \\n\\\\[\\n\\\\renewcommand{\\\\arraystretch}{2.0}\\n\\\\left(\\n\\\\begin{array}{cc}\\n-\\\\omega^2 \\\\langle \\\\phi_i, \\\\phi_j \\\\rangle_{\\\\mathrm{L}^2(\\\\Omega)}\\n+ c^2 \\\\langle \\\\nabla \\\\phi_i, \\\\nabla \\\\phi_j \\\\rangle_{\\\\mathrm{L}^2(\\\\Omega)}\\n& -c\\\\omega \\\\langle \\\\phi_i,\\\\psi_j\\\\rangle_{\\\\mathrm{L}^2(\\\\Gamma_2)} \\\\\\\\\\nc\\\\omega \\\\langle \\\\psi_i,\\\\phi_j\\\\rangle_{\\\\mathrm{L}^2(\\\\Gamma_2)}\\n& -\\\\omega^2 \\\\langle \\\\psi_{i}, \\\\psi_j \\\\rangle_{\\\\mathrm{L}^2(\\\\Omega)}\\n+ c^2 \\\\langle \\\\nabla \\\\psi_{i}, \\\\nabla \\\\psi_j  \\\\rangle_{\\\\mathrm{L}^2(\\\\Omega)}\\n\\\\end{array}\\n\\\\right)\\n\\\\left(\\n\\\\begin{array}{c}\\n\\\\alpha \\\\\\\\ \\\\beta\\n\\\\end{array}\\n\\\\right)\\n=\\n\\\\left(\\n\\\\begin{array}{c}\\n0 \\\\\\\\ 0\\n\\\\end{array}\\n\\\\right)\\n\\\\]\\n\\n (One should not be fooled by the right hand side being zero here, that is because we haven't included the Dirichlet boundary data yet.) Because of the alternating sign in the off-diagonal blocks, we can already see that this system is non-symmetric, in fact it is even indefinite. Of course, there is no necessity to choose the spaces \\\\(V_h\\\\) and \\\\(W_h\\\\) to be the same. However, we expect real and imaginary part of the solution to have similar properties and will therefore indeed take \\\\(V_h=W_h\\\\) in the implementation, and also use the same basis functions \\\\(\\\\phi_i = \\\\psi_i\\\\) for both spaces. The reason for the notation using different symbols is just that it allows us to distinguish between shape functions for \\\\(v\\\\) and \\\\(w\\\\), as this distinction plays an important role in the implementation.\\nThe test case\\nFor the computations, we will consider wave propagation in the unit square, with ultrasound generated by a transducer lens that is shaped like a segment of the circle with center at \\\\((0.5, d)\\\\) and a radius slightly greater than \\\\(d\\\\); this shape should lead to a focusing of the sound wave at the center of the circle. Varying \\\\(d\\\\) changes the \\\"focus\\\" of the lens and affects the spatial distribution of the intensity of \\\\(u\\\\), where our main concern is how well \\\\(|u|=\\\\sqrt{v^2+w^2}\\\\) is focused.\\nIn the program below, we will implement the complex-valued Helmholtz equations using the formulation with split real and imaginary parts. We will also discuss how to generate a domain that looks like a square with a slight bulge simulating the transducer (in the UltrasoundProblem<dim>::make_grid() function), and how to generate graphical output that not only contains the solution components \\\\(v\\\\) and \\\\(w\\\\), but also the magnitude \\\\(\\\\sqrt{v^2+w^2}\\\\) directly in the output file (in UltrasoundProblem<dim>::output_results()). Finally, we use the ParameterHandler class to easily read parameters like the focal distance \\\\(d\\\\), wave speed \\\\(c\\\\), frequency \\\\(\\\\omega\\\\), and a number of other parameters from an input file at run-time, rather than fixing those parameters in the source code where we would have to re-compile every time we want to change parameters.\\n The commented program\\n Include files\\nThe following header files have all been discussed before:\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/manifold_lib.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/matrix_tools.h>\\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 \\n\\u00a0 #include <iostream>\\n\\u00a0 #include <fstream>\\n\\u00a0 \\nThis header file contains the necessary declarations for the ParameterHandler class that we will use to read our parameters from a configuration file :\\n\\u00a0 #include <deal.II/base/parameter_handler.h>\\n\\u00a0 \\nFor solving the linear system, we'll use the sparse LU-decomposition provided by UMFPACK (see the SparseDirectUMFPACK class), for which the following header file is needed. Note that in order to compile this tutorial program, the deal.II-library needs to be built with UMFPACK support, which is enabled by default:\\n\\u00a0 #include <deal.II/lac/sparse_direct.h>\\n\\u00a0 \\nThe FESystem class allows us to stack several FE-objects to one compound, vector-valued finite element field. The necessary declarations for this class are provided in this header file :\\n\\u00a0 #include <deal.II/fe/fe_system.h>\\n\\u00a0 \\nFinally, include the header file that declares the Timer class that we will use to determine how much time each of the operations of our program takes:\\n\\u00a0 #include <deal.II/base/timer.h>\\n\\u00a0 \\nAs the last step at the beginning of this program, we put everything that is in this program into its namespace and, within it, make everything that is in the deal.II namespace globally available, without the need to prefix everything with dealii:::\\n\\u00a0 namespace Step29\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n The DirichletBoundaryValues class\\nFirst we define a class for the function representing the Dirichlet boundary values. This has been done many times before and therefore does not need much explanation.\\nSince there are two values \\\\(v\\\\) and \\\\(w\\\\) that need to be prescribed at the boundary, we have to tell the base class that this is a vector-valued function with two components, and the vector_value function and its cousin vector_value_list must return vectors with two entries. In our case the function is very simple, it just returns 1 for the real part \\\\(v\\\\) and 0 for the imaginary part \\\\(w\\\\) regardless of the point where it is evaluated.\\n\\u00a0   template <int dim>\\n\\u00a0   class DirichletBoundaryValues : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     DirichletBoundaryValues()\\n\\u00a0       : Function<dim>(2)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     virtual void vector_value(const Point<dim> & /*p*/,\\n\\u00a0                               Vector<double> &values) const override\\n\\u00a0     {\\n\\u00a0       AssertDimension(values.size(), 2);\\n\\u00a0 \\n\\u00a0       values(0) = 1;\\n\\u00a0       values(1) = 0;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     virtual void\\n\\u00a0     vector_value_list(const std::vector<Point<dim>> &points,\\n\\u00a0                       std::vector<Vector<double>>   &value_list) const override\\n\\u00a0     {\\n\\u00a0       AssertDimension(value_list.size(), points.size());\\n\\u00a0 \\n\\u00a0       for (unsigned int p = 0; p < points.size(); ++p)\\n\\u00a0         DirichletBoundaryValues<dim>::vector_value(points[p], value_list[p]);\\n\\u00a0     }\\n\\u00a0   };\\n\\u00a0 \\nFunctionDefinition function.h:152\\nFunction::vector_value_listvirtual void vector_value_list(const std::vector< Point< dim > > &points, std::vector< Vector< RangeNumberType > > &values) const\\nFunction::vector_valuevirtual void vector_value(const Point< dim > &p, Vector< RangeNumberType > &values) const\\nPointDefinition point.h:111\\nVectorDefinition vector.h:120\\nAssertDimension#define AssertDimension(dim1, dim2)Definition exceptions.h:1985\\n The ParameterReader class\\nThe next class is responsible for preparing the ParameterHandler object and reading parameters from an input file. It includes a function declare_parameters that declares all the necessary parameters and a read_parameters function that is called from outside to initiate the parameter reading process.\\n\\u00a0   class ParameterReader : public Subscriptor\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     ParameterReader(ParameterHandler &);\\n\\u00a0     void read_parameters(const std::string &);\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void              declare_parameters();\\n\\u00a0     ParameterHandler &prm;\\n\\u00a0   };\\n\\u00a0 \\nParameterHandlerDefinition parameter_handler.h:855\\nSubscriptorDefinition subscriptor.h:60\\nThe constructor stores a reference to the ParameterHandler object that is passed to it:\\n\\u00a0   ParameterReader::ParameterReader(ParameterHandler &paramhandler)\\n\\u00a0     : prm(paramhandler)\\n\\u00a0   {}\\n\\u00a0 \\n ParameterReader::declare_parameters\\nThe declare_parameters function declares all the parameters that our ParameterHandler object will be able to read from input files, along with their types, range conditions and the subsections they appear in. We will wrap all the entries that go into a section in a pair of braces to force the editor to indent them by one level, making it simpler to read which entries together form a section:\\n\\u00a0   void ParameterReader::declare_parameters()\\n\\u00a0   {\\nParameters for mesh and geometry include the number of global refinement steps that are applied to the initial coarse mesh and the focal distance \\\\(d\\\\) of the transducer lens. For the number of refinement steps, we allow integer values in the range \\\\([0,\\\\infty)\\\\), where the omitted second argument to the Patterns::Integer object denotes the half-open interval. For the focal distance any number greater than zero is accepted:\\n\\u00a0     prm.enter_subsection(\\\"Mesh & geometry parameters\\\");\\n\\u00a0     {\\n\\u00a0       prm.declare_entry(\\\"Number of refinements\\\",\\n\\u00a0                         \\\"6\\\",\\n\\u00a0                         Patterns::Integer(0),\\n\\u00a0                         \\\"Number of global mesh refinement steps \\\"\\n\\u00a0                         \\\"applied to initial coarse grid\\\");\\n\\u00a0 \\n\\u00a0       prm.declare_entry(\\\"Focal distance\\\",\\n\\u00a0                         \\\"0.3\\\",\\n\\u00a0                         Patterns::Double(0),\\n\\u00a0                         \\\"Distance of the focal point of the lens \\\"\\n\\u00a0                         \\\"to the x-axis\\\");\\n\\u00a0     }\\n\\u00a0     prm.leave_subsection();\\n\\u00a0 \\nPatterns::DoubleDefinition patterns.h:291\\nPatterns::IntegerDefinition patterns.h:188\\nThe next subsection is devoted to the physical parameters appearing in the equation, which are the frequency \\\\(\\\\omega\\\\) and wave speed \\\\(c\\\\). Again, both need to lie in the half-open interval \\\\([0,\\\\infty)\\\\) represented by calling the Patterns::Double class with only the left end-point as argument:\\n\\u00a0     prm.enter_subsection(\\\"Physical constants\\\");\\n\\u00a0     {\\n\\u00a0       prm.declare_entry(\\\"c\\\", \\\"1.5e5\\\", Patterns::Double(0), \\\"Wave speed\\\");\\n\\u00a0 \\n\\u00a0       prm.declare_entry(\\\"omega\\\", \\\"5.0e7\\\", Patterns::Double(0), \\\"Frequency\\\");\\n\\u00a0     }\\n\\u00a0     prm.leave_subsection();\\n\\u00a0 \\n\\u00a0 \\nLast but not least we would like to be able to change some properties of the output, like filename and format, through entries in the configuration file, which is the purpose of the last subsection:\\n\\u00a0     prm.enter_subsection(\\\"Output parameters\\\");\\n\\u00a0     {\\n\\u00a0       prm.declare_entry(\\\"Output filename\\\",\\n\\u00a0                         \\\"solution\\\",\\n\\u00a0                         Patterns::Anything(),\\n\\u00a0                         \\\"Name of the output file (without extension)\\\");\\n\\u00a0 \\nPatterns::AnythingDefinition patterns.h:1021\\nSince different output formats may require different parameters for generating output (like for example, postscript output needs viewpoint angles, line widths, colors etc), it would be cumbersome if we had to declare all these parameters by hand for every possible output format supported in the library. Instead, each output format has a FormatFlags::declare_parameters function, which declares all the parameters specific to that format in an own subsection. The following call of DataOutInterface<1>::declare_parameters executes declare_parameters for all available output formats, so that for each format an own subsection will be created with parameters declared for that particular output format. (The actual value of the template parameter in the call, <1> above, does not matter here: the function does the same work independent of the dimension, but happens to be in a template-parameter-dependent class.) To find out what parameters there are for which output format, you can either consult the documentation of the DataOutBase class, or simply run this program without a parameter file present. It will then create a file with all declared parameters set to their default values, which can conveniently serve as a starting point for setting the parameters to the values you desire.\\n\\u00a0       DataOutInterface<1>::declare_parameters(prm);\\n\\u00a0     }\\n\\u00a0     prm.leave_subsection();\\n\\u00a0   }\\n\\u00a0 \\nDataOutInterface::declare_parametersstatic void declare_parameters(ParameterHandler &prm)Definition data_out_base.cc:8913\\n ParameterReader::read_parameters\\nThis is the main function in the ParameterReader class. It gets called from outside, first declares all the parameters, and then reads them from the input file whose filename is provided by the caller. After the call to this function is complete, the prm object can be used to retrieve the values of the parameters read in from the file :\\n\\u00a0   void ParameterReader::read_parameters(const std::string &parameter_file)\\n\\u00a0   {\\n\\u00a0     declare_parameters();\\n\\u00a0 \\n\\u00a0     prm.parse_input(parameter_file);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n The ComputeIntensity class\\nAs mentioned in the introduction, the quantity that we are really after is the spatial distribution of the intensity of the ultrasound wave, which corresponds to \\\\(|u|=\\\\sqrt{v^2+w^2}\\\\). Now we could just be content with having \\\\(v\\\\) and \\\\(w\\\\) in our output, and use a suitable visualization or postprocessing tool to derive \\\\(|u|\\\\) from the solution we computed. However, there is also a way to output data derived from the solution in deal.II, and we are going to make use of this mechanism here.\\nSo far we have always used the DataOut::add_data_vector function to add vectors containing output data to a DataOut object. There is a special version of this function that in addition to the data vector has an additional argument of type DataPostprocessor. What happens when this function is used for output is that at each point where output data is to be generated, the DataPostprocessor::evaluate_scalar_field() or DataPostprocessor::evaluate_vector_field() function of the specified DataPostprocessor object is invoked to compute the output quantities from the values, the gradients and the second derivatives of the finite element function represented by the data vector (in the case of face related data, normal vectors are available as well). Hence, this allows us to output any quantity that can locally be derived from the values of the solution and its derivatives. Of course, the ultrasound intensity \\\\(|u|\\\\) is such a quantity and its computation doesn't even involve any derivatives of \\\\(v\\\\) or \\\\(w\\\\).\\nIn practice, the DataPostprocessor class only provides an interface to this functionality, and we need to derive our own class from it in order to implement the functions specified by the interface. In the most general case one has to implement several member functions but if the output quantity is a single scalar then some of this boilerplate code can be handled by a more specialized class, DataPostprocessorScalar and we can derive from that one instead. This is what the ComputeIntensity class does:\\n\\u00a0   template <int dim>\\n\\u00a0   class ComputeIntensity : public DataPostprocessorScalar<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     ComputeIntensity();\\n\\u00a0 \\n\\u00a0     virtual void evaluate_vector_field(\\n\\u00a0       const DataPostprocessorInputs::Vector<dim> &inputs,\\n\\u00a0       std::vector<Vector<double>> &computed_quantities) const override;\\n\\u00a0   };\\n\\u00a0 \\nDataPostprocessorScalarDefinition data_postprocessor.h:716\\nDataPostprocessor::evaluate_vector_fieldvirtual void evaluate_vector_field(const DataPostprocessorInputs::Vector< dim > &input_data, std::vector< Vector< double > > &computed_quantities) constDefinition data_postprocessor.cc:59\\nDataPostprocessorInputs::VectorDefinition data_postprocessor.h:400\\nIn the constructor, we need to call the constructor of the base class with two arguments. The first denotes the name by which the single scalar quantity computed by this class should be represented in output files. In our case, the postprocessor has \\\\(|u|\\\\) as output, so we use \\\"Intensity\\\".\\nThe second argument is a set of flags that indicate which data is needed by the postprocessor in order to compute the output quantities. This can be any subset of update_values, update_gradients and update_hessians (and, in the case of face data, also update_normal_vectors), which are documented in UpdateFlags. Of course, computation of the derivatives requires additional resources, so only the flags for data that are really needed should be given here, just as we do when we use FEValues objects. In our case, only the function values of \\\\(v\\\\) and \\\\(w\\\\) are needed to compute \\\\(|u|\\\\), so we're good with the update_values flag.\\n\\u00a0   template <int dim>\\n\\u00a0   ComputeIntensity<dim>::ComputeIntensity()\\n\\u00a0     : DataPostprocessorScalar<dim>(\\\"Intensity\\\", update_values)\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nThe actual postprocessing happens in the following function. Its input is an object that stores values of the function (which is here vector-valued) representing the data vector given to DataOut::add_data_vector, evaluated at all evaluation points where we generate output, and some tensor objects representing derivatives (that we don't use here since \\\\(|u|\\\\) is computed from just \\\\(v\\\\) and \\\\(w\\\\)). The derived quantities are returned in the computed_quantities vector. Remember that this function may only use data for which the respective update flag is specified by get_needed_update_flags. For example, we may not use the derivatives here, since our implementation of get_needed_update_flags requests that only function values are provided.\\n\\u00a0   template <int dim>\\n\\u00a0   void ComputeIntensity<dim>::evaluate_vector_field(\\n\\u00a0     const DataPostprocessorInputs::Vector<dim> &inputs,\\n\\u00a0     std::vector<Vector<double>>                &computed_quantities) const\\n\\u00a0   {\\n\\u00a0     AssertDimension(computed_quantities.size(), inputs.solution_values.size());\\n\\u00a0 \\nThe computation itself is straightforward: We iterate over each entry in the output vector and compute \\\\(|u|\\\\) from the corresponding values of \\\\(v\\\\) and \\\\(w\\\\). We do this by creating a complex number \\\\(u\\\\) and then calling std::abs() on the result. (One may be tempted to call std::norm(), but in a historical quirk, the C++ committee decided that std::norm() should return the square of the absolute value \\u2013 thereby not satisfying the properties mathematicians require of something called a \\\"norm\\\".)\\n\\u00a0     for (unsigned int p = 0; p < computed_quantities.size(); ++p)\\n\\u00a0       {\\n\\u00a0         AssertDimension(computed_quantities[p].size(), 1);\\n\\u00a0         AssertDimension(inputs.solution_values[p].size(), 2);\\n\\u00a0 \\n\\u00a0         const std::complex<double> u(inputs.solution_values[p](0),\\n\\u00a0                                      inputs.solution_values[p](1));\\n\\u00a0 \\n\\u00a0         computed_quantities[p](0) = std::abs(u);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nstd::abs::VectorizedArray< Number, width > abs(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6927\\n The UltrasoundProblem class\\nFinally here is the main class of this program. It's member functions are very similar to the previous examples, in particular step-4, and the list of member variables does not contain any major surprises either. The ParameterHandler object that is passed to the constructor is stored as a reference to allow easy access to the parameters from all functions of the class. Since we are working with vector valued finite elements, the FE object we are using is of type FESystem.\\n\\u00a0   template <int dim>\\n\\u00a0   class UltrasoundProblem\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     UltrasoundProblem(ParameterHandler &);\\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void make_grid();\\n\\u00a0     void setup_system();\\n\\u00a0     void assemble_system();\\n\\u00a0     void solve();\\n\\u00a0     void output_results() const;\\n\\u00a0 \\n\\u00a0     ParameterHandler &prm;\\n\\u00a0 \\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0     DoFHandler<dim>     dof_handler;\\n\\u00a0     const FESystem<dim> fe;\\n\\u00a0 \\n\\u00a0     SparsityPattern      sparsity_pattern;\\n\\u00a0     SparseMatrix<double> system_matrix;\\n\\u00a0     Vector<double>       solution, system_rhs;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nDoFHandlerDefinition dof_handler.h:317\\nFESystemDefinition fe_system.h:208\\nSparseMatrixDefinition sparse_matrix.h:520\\nSparsityPatternDefinition sparsity_pattern.h:343\\nTriangulationDefinition tria.h:1323\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\nThe constructor takes the ParameterHandler object and stores it in a reference. It also initializes the DoF-Handler and the finite element system, which consists of two copies of the scalar \\\\(Q_1\\\\) field, one for \\\\(v\\\\) and one for \\\\(w\\\\). In other words, we want the finite element space \\\\(Q_1\\\\times Q_1 = Q_1^2\\\\), which is easily constructed and passed as the constructor argument to the FESystem class (i.e., the type of the fe member being initialized here):\\n\\u00a0   template <int dim>\\n\\u00a0   UltrasoundProblem<dim>::UltrasoundProblem(ParameterHandler &param)\\n\\u00a0     : prm(param)\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0     , fe(FE_Q<dim>(1) ^ 2)\\n\\u00a0   {}\\n\\u00a0 \\nFE_QDefinition fe_q.h:554\\n UltrasoundProblem::make_grid\\nHere we set up the grid for our domain. As mentioned in the exposition, the geometry is just a unit square (in 2d) with the part of the boundary that represents the transducer lens replaced by a sector of a circle.\\n\\u00a0   template <int dim>\\n\\u00a0   void UltrasoundProblem<dim>::make_grid()\\n\\u00a0   {\\nFirst we generate some logging output and start a timer so we can compute execution time when this function is done:\\n\\u00a0     std::cout << \\\"Generating grid... \\\";\\n\\u00a0     Timer timer;\\n\\u00a0 \\nTimerDefinition timer.h:117\\nThen we query the values for the focal distance of the transducer lens and the number of mesh refinement steps from our ParameterHandler object:\\n\\u00a0     prm.enter_subsection(\\\"Mesh & geometry parameters\\\");\\n\\u00a0 \\n\\u00a0     const double       focal_distance = prm.get_double(\\\"Focal distance\\\");\\n\\u00a0     const unsigned int n_refinements = prm.get_integer(\\\"Number of refinements\\\");\\n\\u00a0 \\n\\u00a0     prm.leave_subsection();\\n\\u00a0 \\nNext, two points are defined for position and focal point of the transducer lens, which is the center of the circle whose segment will form the transducer part of the boundary. Notice that this is the only point in the program where things are slightly different in 2d and 3d. Even though this tutorial only deals with the 2d case, the necessary additions to make this program functional in 3d are so minimal that we opt for including them:\\n\\u00a0     const Point<dim> transducer =\\n\\u00a0       (dim == 2) ? Point<dim>(0.5, 0.0) : Point<dim>(0.5, 0.5, 0.0);\\n\\u00a0     const Point<dim> focal_point = (dim == 2) ?\\n\\u00a0                                      Point<dim>(0.5, focal_distance) :\\n\\u00a0                                      Point<dim>(0.5, 0.5, focal_distance);\\n\\u00a0 \\n\\u00a0 \\nAs initial coarse grid we take a simple unit square with 5 subdivisions in each direction. The number of subdivisions is chosen so that the line segment \\\\([0.4,0.6]\\\\) that we want to designate as the transducer boundary is spanned by a single face. Then we step through all cells to find the faces where the transducer is to be located, which in fact is just the single edge from 0.4 to 0.6 on the x-axis. This is where we want the refinements to be made according to a circle shaped boundary, so we mark this edge with a different manifold indicator. Since we will Dirichlet boundary conditions on the transducer, we also change its boundary indicator.\\n\\u00a0     GridGenerator::subdivided_hyper_cube(triangulation, 5, 0, 1);\\n\\u00a0 \\n\\u00a0     for (auto &cell : triangulation.cell_iterators())\\n\\u00a0       for (const auto &face : cell->face_iterators())\\n\\u00a0         if (face->at_boundary() &&\\n\\u00a0             ((face->center() - transducer).norm_square() < 0.01))\\n\\u00a0           {\\n\\u00a0             face->set_boundary_id(1);\\n\\u00a0             face->set_manifold_id(1);\\n\\u00a0           }\\ncenterPoint< 3 > centerDefinition data_out_base.cc:267\\nGridGenerator::subdivided_hyper_cubevoid subdivided_hyper_cube(Triangulation< dim, spacedim > &tria, const unsigned int repetitions, const double left=0., const double right=1., const bool colorize=false)\\nFor the circle part of the transducer lens, a SphericalManifold object is used (which, of course, in 2d just represents a circle), with center computed as above.\\n\\u00a0     triangulation.set_manifold(1, SphericalManifold<dim>(focal_point));\\n\\u00a0 \\nSphericalManifoldDefinition manifold_lib.h:263\\nTriangulation::set_manifoldvoid set_manifold(const types::manifold_id number, const Manifold< dim, spacedim > &manifold_object)\\nNow global refinement is executed. Cells near the transducer location will be automatically refined according to the circle shaped boundary of the transducer lens:\\n\\u00a0     triangulation.refine_global(n_refinements);\\n\\u00a0 \\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nLastly, we generate some more logging output. We stop the timer and query the number of CPU seconds elapsed since the beginning of the function:\\n\\u00a0     timer.stop();\\n\\u00a0     std::cout << \\\"done (\\\" << timer.cpu_time() << \\\"s)\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     std::cout << \\\"  Number of active cells:  \\\" << triangulation.n_active_cells()\\n\\u00a0               << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\n UltrasoundProblem::setup_system\\nInitialization of the system matrix, sparsity patterns and vectors are the same as in previous examples and therefore do not need further comment. As in the previous function, we also output the run time of what we do here:\\n\\u00a0   template <int dim>\\n\\u00a0   void UltrasoundProblem<dim>::setup_system()\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"Setting up system... \\\";\\n\\u00a0     Timer timer;\\n\\u00a0 \\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0 \\n\\u00a0     DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());\\n\\u00a0     DoFTools::make_sparsity_pattern(dof_handler, dsp);\\n\\u00a0     sparsity_pattern.copy_from(dsp);\\n\\u00a0 \\n\\u00a0     system_matrix.reinit(sparsity_pattern);\\n\\u00a0     system_rhs.reinit(dof_handler.n_dofs());\\n\\u00a0     solution.reinit(dof_handler.n_dofs());\\n\\u00a0 \\n\\u00a0     timer.stop();\\n\\u00a0     std::cout << \\\"done (\\\" << timer.cpu_time() << \\\"s)\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     std::cout << \\\"  Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n\\u00a0               << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\n UltrasoundProblem::assemble_system\\nAs before, this function takes care of assembling the system matrix and right hand side vector:\\n\\u00a0   template <int dim>\\n\\u00a0   void UltrasoundProblem<dim>::assemble_system()\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"Assembling system matrix... \\\";\\n\\u00a0     Timer timer;\\n\\u00a0 \\nFirst we query wavespeed and frequency from the ParameterHandler object and store them in local variables, as they will be used frequently throughout this function.\\n\\u00a0     prm.enter_subsection(\\\"Physical constants\\\");\\n\\u00a0 \\n\\u00a0     const double omega = prm.get_double(\\\"omega\\\"), c = prm.get_double(\\\"c\\\");\\n\\u00a0 \\n\\u00a0     prm.leave_subsection();\\n\\u00a0 \\nAs usual, for computing integrals ordinary Gauss quadrature rule is used. Since our bilinear form involves boundary integrals on \\\\(\\\\Gamma_2\\\\), we also need a quadrature rule for surface integration on the faces, which are \\\\(dim-1\\\\) dimensional:\\n\\u00a0     const QGauss<dim>     quadrature_formula(fe.degree + 1);\\n\\u00a0     const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);\\n\\u00a0 \\n\\u00a0     const unsigned int n_q_points      = quadrature_formula.size(),\\n\\u00a0                        n_face_q_points = face_quadrature_formula.size(),\\n\\u00a0                        dofs_per_cell   = fe.n_dofs_per_cell();\\n\\u00a0 \\nQGaussDefinition quadrature_lib.h:40\\nThe FEValues objects will evaluate the shape functions for us. For the part of the bilinear form that involves integration on \\\\(\\\\Omega\\\\), we'll need the values and gradients of the shape functions, and of course the quadrature weights. For the terms involving the boundary integrals, only shape function values and the quadrature weights are necessary.\\n\\u00a0     FEValues<dim> fe_values(fe,\\n\\u00a0                             quadrature_formula,\\n\\u00a0                             update_values | update_gradients |\\n\\u00a0                               update_JxW_values);\\n\\u00a0 \\n\\u00a0     FEFaceValues<dim> fe_face_values(fe,\\n\\u00a0                                      face_quadrature_formula,\\n\\u00a0                                      update_values | update_JxW_values);\\n\\u00a0 \\nFEFaceValuesDefinition fe_values.h:322\\nFEValuesDefinition fe_values.h:63\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nAs usual, the system matrix is assembled cell by cell, and we need a matrix for storing the local cell contributions as well as an index vector to transfer the cell contributions to the appropriate location in the global system matrix after.\\n\\u00a0     FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\nFullMatrixDefinition full_matrix.h:79\\nOn each cell, we first need to reset the local contribution matrix and request the FEValues object to compute the shape functions for the current cell:\\n\\u00a0         cell_matrix = 0;\\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0         for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0           {\\n\\u00a0             for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0               {\\nAt this point, it is important to keep in mind that we are dealing with a finite element system with two components. Due to the way we constructed this FESystem, namely as the Cartesian product of two scalar finite element fields, each shape function has only a single nonzero component (they are, in deal.II lingo, primitive). Hence, each shape function can be viewed as one of the \\\\(\\\\phi\\\\)'s or \\\\(\\\\psi\\\\)'s from the introduction, and similarly the corresponding degrees of freedom can be attributed to either \\\\(\\\\alpha\\\\) or \\\\(\\\\beta\\\\). As we iterate through all the degrees of freedom on the current cell however, they do not come in any particular order, and so we cannot decide right away whether the DoFs with index \\\\(i\\\\) and \\\\(j\\\\) belong to the real or imaginary part of our solution. On the other hand, if you look at the form of the system matrix in the introduction, this distinction is crucial since it will determine to which block in the system matrix the contribution of the current pair of DoFs will go and hence which quantity we need to compute from the given two shape functions. Fortunately, the FESystem object can provide us with this information, namely it has a function FESystem::system_to_component_index(), that for each local DoF index returns a pair of integers of which the first indicates to which component of the system the DoF belongs. The second integer of the pair indicates which index the DoF has in the scalar base finite element field, but this information is not relevant here. If you want to know more about this function and the underlying scheme behind primitive vector valued elements, take a look at step-8 or the Handling vector valued problems topic, where these topics are explained in depth.\\n\\u00a0                 if (fe.system_to_component_index(i).first ==\\n\\u00a0                     fe.system_to_component_index(j).first)\\n\\u00a0                   {\\nIf both DoFs \\\\(i\\\\) and \\\\(j\\\\) belong to same component, i.e. their shape functions are both \\\\(\\\\phi\\\\)'s or both \\\\(\\\\psi\\\\)'s, the contribution will end up in one of the diagonal blocks in our system matrix, and since the corresponding entries are computed by the same formula, we do not bother if they actually are \\\\(\\\\phi\\\\) or \\\\(\\\\psi\\\\) shape functions. We can simply compute the entry by iterating over all quadrature points and adding up their contributions, where values and gradients of the shape functions are supplied by our FEValues object.\\n\\u00a0                     for (unsigned int q_point = 0; q_point < n_q_points;\\n\\u00a0                          ++q_point)\\n\\u00a0                       cell_matrix(i, j) +=\\n\\u00a0                         (((fe_values.shape_value(i, q_point) *\\n\\u00a0                            fe_values.shape_value(j, q_point)) *\\n\\u00a0                             (-omega * omega) +\\n\\u00a0                           (fe_values.shape_grad(i, q_point) *\\n\\u00a0                            fe_values.shape_grad(j, q_point)) *\\n\\u00a0                             c * c) *\\n\\u00a0                          fe_values.JxW(q_point));\\n\\u00a0 \\nYou might think that we would have to specify which component of the shape function we'd like to evaluate when requesting shape function values or gradients from the FEValues object. However, as the shape functions are primitive, they have only one nonzero component, and the FEValues class is smart enough to figure out that we are definitely interested in this one nonzero component.\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0 \\nWe also have to add contributions due to boundary terms. To this end, we loop over all faces of the current cell and see if first it is at the boundary, and second has the correct boundary indicator associated with \\\\(\\\\Gamma_2\\\\), the part of the boundary where we have absorbing boundary conditions:\\n\\u00a0         for (const auto face_no : cell->face_indices())\\n\\u00a0           if (cell->face(face_no)->at_boundary() &&\\n\\u00a0               (cell->face(face_no)->boundary_id() == 0))\\n\\u00a0             {\\nThese faces will certainly contribute to the off-diagonal blocks of the system matrix, so we ask the FEFaceValues object to provide us with the shape function values on this face:\\n\\u00a0               fe_face_values.reinit(cell, face_no);\\n\\u00a0 \\n\\u00a0 \\nNext, we loop through all DoFs of the current cell to find pairs that belong to different components and both have support on the current face_no:\\n\\u00a0               for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0                 for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0                   if ((fe.system_to_component_index(i).first !=\\n\\u00a0                        fe.system_to_component_index(j).first) &&\\n\\u00a0                       fe.has_support_on_face(i, face_no) &&\\n\\u00a0                       fe.has_support_on_face(j, face_no))\\nThe check whether shape functions have support on a face is not strictly necessary: if we don't check for it we would simply add up terms to the local cell matrix that happen to be zero because at least one of the shape functions happens to be zero. However, we can save that work by adding the checks above.\\nIn either case, these DoFs will contribute to the boundary integrals in the off-diagonal blocks of the system matrix. To compute the integral, we loop over all the quadrature points on the face and sum up the contribution weighted with the quadrature weights that the face quadrature rule provides. In contrast to the entries on the diagonal blocks, here it does matter which one of the shape functions is a \\\\(\\\\psi\\\\) and which one is a \\\\(\\\\phi\\\\), since that will determine the sign of the entry. We account for this by a simple conditional statement that determines the correct sign. Since we already checked that DoF \\\\(i\\\\) and \\\\(j\\\\) belong to different components, it suffices here to test for one of them to which component it belongs.\\n\\u00a0                     for (unsigned int q_point = 0; q_point < n_face_q_points;\\n\\u00a0                          ++q_point)\\n\\u00a0                       cell_matrix(i, j) +=\\n\\u00a0                         ((fe.system_to_component_index(i).first == 0) ? -1 :\\n\\u00a0                                                                         1) *\\n\\u00a0                         fe_face_values.shape_value(i, q_point) *\\n\\u00a0                         fe_face_values.shape_value(j, q_point) * c * omega *\\n\\u00a0                         fe_face_values.JxW(q_point);\\n\\u00a0             }\\n\\u00a0 \\nNow we are done with this cell and have to transfer its contributions from the local to the global system matrix. To this end, we first get a list of the global indices of the this cells DoFs...\\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0 \\n\\u00a0 \\n...and then add the entries to the system matrix one by one:\\n\\u00a0         for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0           for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0             system_matrix.add(local_dof_indices[i],\\n\\u00a0                               local_dof_indices[j],\\n\\u00a0                               cell_matrix(i, j));\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0 \\nThe only thing left are the Dirichlet boundary values on \\\\(\\\\Gamma_1\\\\), which is characterized by the boundary indicator 1. The Dirichlet values are provided by the DirichletBoundaryValues class we defined above:\\n\\u00a0     std::map<types::global_dof_index, double> boundary_values;\\n\\u00a0     VectorTools::interpolate_boundary_values(dof_handler,\\n\\u00a0                                              1,\\n\\u00a0                                              DirichletBoundaryValues<dim>(),\\n\\u00a0                                              boundary_values);\\n\\u00a0 \\n\\u00a0     MatrixTools::apply_boundary_values(boundary_values,\\n\\u00a0                                        system_matrix,\\n\\u00a0                                        solution,\\n\\u00a0                                        system_rhs);\\n\\u00a0 \\n\\u00a0     timer.stop();\\n\\u00a0     std::cout << \\\"done (\\\" << timer.cpu_time() << \\\"s)\\\" << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nMatrixTools::apply_boundary_valuesvoid apply_boundary_values(const std::map< types::global_dof_index, number > &boundary_values, SparseMatrix< number > &matrix, Vector< number > &solution, Vector< number > &right_hand_side, const bool eliminate_columns=true)Definition matrix_tools.cc:75\\nVectorTools::interpolate_boundary_valuesvoid interpolate_boundary_values(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const std::map< types::boundary_id, const Function< spacedim, number > * > &function_map, std::map< types::global_dof_index, number > &boundary_values, const ComponentMask &component_mask={})\\n UltrasoundProblem::solve\\nAs already mentioned in the introduction, the system matrix is neither symmetric nor definite, and so it is not quite obvious how to come up with an iterative solver and a preconditioner that do a good job on this matrix. (For more on this topic, see also the Possibilities for extensions section below.) We chose instead to go a different way and solve the linear system with the sparse LU decomposition provided by UMFPACK. This is often a good first choice for 2d problems and works reasonably well even for moderately large numbers of DoFs. The deal.II interface to UMFPACK is implemented in the SparseDirectUMFPACK class, which is very easy to use and allows us to solve our linear system with just 3 lines of code.\\nNote again that for compiling this example program, you need to have the deal.II library built with UMFPACK support.\\n\\u00a0   template <int dim>\\n\\u00a0   void UltrasoundProblem<dim>::solve()\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"Solving linear system... \\\";\\n\\u00a0     Timer timer;\\n\\u00a0 \\nThe code to solve the linear system is short: First, we allocate an object of the right type. The following call to SparseDirectUMFPACK::solve() takes as argument the matrix to decompose, and a vector that upon input equals the right hand side of the linear system to be solved, and upon output contains the solution of the linear system. To satisfy this input/output requirement, we first assign the right hand side vector to the solution variable.\\n\\u00a0     SparseDirectUMFPACK A_direct;\\n\\u00a0 \\n\\u00a0     solution = system_rhs;\\n\\u00a0     A_direct.solve(system_matrix, solution);\\n\\u00a0 \\n\\u00a0     timer.stop();\\n\\u00a0     std::cout << \\\"done (\\\" << timer.cpu_time() << \\\"s)\\\" << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nSparseDirectUMFPACKDefinition sparse_direct.h:92\\nSparseDirectUMFPACK::solvevoid solve(Vector< double > &rhs_and_solution, const bool transpose=false) constDefinition sparse_direct.cc:377\\n UltrasoundProblem::output_results\\nHere we output our solution \\\\(v\\\\) and \\\\(w\\\\) as well as the derived quantity \\\\(|u|\\\\) in the format specified in the parameter file. Most of the work for deriving \\\\(|u|\\\\) from \\\\(v\\\\) and \\\\(w\\\\) was already done in the implementation of the ComputeIntensity class, so that the output routine is rather straightforward and very similar to what is done in the previous tutorials.\\n\\u00a0   template <int dim>\\n\\u00a0   void UltrasoundProblem<dim>::output_results() const\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"Generating output... \\\";\\n\\u00a0     Timer timer;\\n\\u00a0 \\nDefine objects of our ComputeIntensity class and a DataOut object:\\n\\u00a0     ComputeIntensity<dim> intensities;\\n\\u00a0     DataOut<dim>          data_out;\\n\\u00a0 \\n\\u00a0     data_out.attach_dof_handler(dof_handler);\\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nNext we query the output-related parameters from the ParameterHandler. The DataOut::parse_parameters call acts as a counterpart to the DataOutInterface<1>::declare_parameters call in ParameterReader::declare_parameters. It collects all the output format related parameters from the ParameterHandler and sets the corresponding properties of the DataOut object accordingly.\\n\\u00a0     prm.enter_subsection(\\\"Output parameters\\\");\\n\\u00a0 \\n\\u00a0     const std::string output_filename = prm.get(\\\"Output filename\\\");\\n\\u00a0     data_out.parse_parameters(prm);\\n\\u00a0 \\n\\u00a0     prm.leave_subsection();\\n\\u00a0 \\nNow we put together the filename from the base name provided by the ParameterHandler and the suffix which is provided by the DataOut class (the default suffix is set to the right type that matches the one set in the .prm file through parse_parameters()):\\n\\u00a0     const std::string filename = output_filename + data_out.default_suffix();\\n\\u00a0 \\n\\u00a0     std::ofstream output(filename);\\n\\u00a0 \\nThe solution vectors \\\\(v\\\\) and \\\\(w\\\\) are added to the DataOut object in the usual way:\\n\\u00a0     std::vector<std::string> solution_names;\\n\\u00a0     solution_names.emplace_back(\\\"Re_u\\\");\\n\\u00a0     solution_names.emplace_back(\\\"Im_u\\\");\\n\\u00a0 \\n\\u00a0     data_out.add_data_vector(solution, solution_names);\\n\\u00a0 \\nFor the intensity, we just call add_data_vector again, but this with our ComputeIntensity object as the second argument, which effectively adds \\\\(|u|\\\\) to the output data:\\n\\u00a0     data_out.add_data_vector(solution, intensities);\\n\\u00a0 \\nThe last steps are as before. Note that the actual output format is now determined by what is stated in the input file, i.e. one can change the output format without having to re-compile this program:\\n\\u00a0     data_out.build_patches();\\n\\u00a0     data_out.write(output);\\n\\u00a0 \\n\\u00a0     timer.stop();\\n\\u00a0     std::cout << \\\"done (\\\" << timer.cpu_time() << \\\"s)\\\" << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n UltrasoundProblem::run\\nHere we simply execute our functions one after the other:\\n\\u00a0   template <int dim>\\n\\u00a0   void UltrasoundProblem<dim>::run()\\n\\u00a0   {\\n\\u00a0     make_grid();\\n\\u00a0     setup_system();\\n\\u00a0     assemble_system();\\n\\u00a0     solve();\\n\\u00a0     output_results();\\n\\u00a0   }\\n\\u00a0 } // namespace Step29\\n\\u00a0 \\n\\u00a0 \\n The main function\\nFinally the main function of the program. It has the same structure as in almost all of the other tutorial programs. The only exception is that we define ParameterHandler and ParameterReader objects, and let the latter read in the parameter values from a textfile called step-29.prm. The values so read are then handed over to an instance of the UltrasoundProblem class:\\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       using namespace dealii;\\n\\u00a0       using namespace Step29;\\n\\u00a0 \\n\\u00a0       ParameterHandler prm;\\n\\u00a0       ParameterReader  param(prm);\\n\\u00a0       param.read_parameters(\\\"step-29.prm\\\");\\n\\u00a0 \\n\\u00a0       UltrasoundProblem<2> ultrasound_problem(prm);\\n\\u00a0       ultrasound_problem.run();\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nThe current program reads its run-time parameters from an input file called step-29.prm that looks like this: subsection Mesh & geometry parameters\\n  # Distance of the focal point of the lens to the x-axis\\n  set Focal distance        = 0.3\\n \\n  # Number of global mesh refinement steps applied to initial coarse grid\\n  set Number of refinements = 5\\nend\\n \\n \\nsubsection Physical constants\\n  # Wave speed\\n  set c     = 1.5e5\\n \\n  # Frequency\\n  set omega = 3.0e7\\nend\\n \\n \\nsubsection Output parameters\\n  # Name of the output file (without extension)\\n  set Output file   = solution\\n \\n  # A name for the output format to be used\\n  set Output format = vtu\\nend\\nAs can be seen, we set \\\\(d=0.3\\\\), which amounts to a focus of the transducer lens at \\\\(x=0.5\\\\), \\\\(y=0.3\\\\). The coarse mesh is refined 5 times, resulting in 160x160 cells, and the output is written in vtu format. The parameter reader understands many more parameters pertaining in particular to the generation of output, but we need none of these parameters here and therefore stick with their default values.\\nHere's the console output of the program in debug mode:\\n> make run\\n[ 33%] Building CXX object CMakeFiles/step-29.dir/step-29.cc.o\\n[ 66%] Linking CXX executable @ref step_29 \\\"step-29\\\"\\n[ 66%] Built target @ref step_29 \\\"step-29\\\"\\n[100%] Run @ref step_29 \\\"step-29\\\" with Debug configuration\\nGenerating grid... done (0.675234s)\\n  Number of active cells:  25600\\nSetting up system... done (0.375661s)\\n  Number of degrees of freedom: 51842\\nAssembling system matrix... done (1.96864s)\\nSolving linear system... done (0.861862s)\\nGenerating output... done (1.66913s)\\n[100%] Built target run\\n(Of course, execution times will differ if you run the program locally.) The fact that most of the time is spent on assembling the system matrix and generating output is due to the many assertions that need to be checked in debug mode. In release mode these parts of the program run much faster whereas solving the linear system is hardly sped up at all:\\n> make run\\n[ 33%] Building CXX object CMakeFiles/step-29.dir/step-29.cc.o\\n[ 66%] Linking CXX executable @ref step_29 \\\"step-29\\\"\\n[ 66%] Built target @ref step_29 \\\"step-29\\\"\\n[100%] Run @ref step_29 \\\"step-29\\\" with Release configuration\\nGenerating grid... done (0.005207s)\\n  Number of active cells:  25600\\nSetting up system... done (0.018111s)\\n  Number of degrees of freedom: 51842\\nAssembling system matrix... done (0.021501s)\\nSolving linear system... done (0.590303s)\\nGenerating output... done (0.090787s)\\n[100%] Built target run\\nThe graphical output of the program looks as follows:\\n\\n\\n  \\n\\n \\n\\nThe first two pictures show the real and imaginary parts of \\\\(u\\\\), whereas the last shows the intensity \\\\(|u|\\\\). One can clearly see that the intensity is focused around the focal point of the lens (0.5, 0.3), and that the focus is rather sharp in \\\\(x\\\\)-direction but more blurred in \\\\(y\\\\)-direction, which is a consequence of the geometry of the focusing lens, its finite aperture, and the wave nature of the problem.\\nBecause colorful graphics are always fun, and to stress the focusing effects some more, here is another set of images highlighting how well the intensity is actually focused in \\\\(x\\\\)-direction:\\n\\n\\n  \\n\\nAs a final note, the structure of the program makes it easy to determine which parts of the program scale nicely as the mesh is refined and which parts don't. Here are the run times for 5, 6, and 7 global refinements:\\n> make run\\n[ 66%] Built target @ref step_29 \\\"step-29\\\"\\n[100%] Run @ref step_29 \\\"step-29\\\" with Release configuration\\nGenerating grid... done (0.008767s)\\n  Number of active cells:  25600\\nSetting up system... done (0.007043s)\\n  Number of degrees of freedom: 51842\\nAssembling system matrix... done (0.020942s)\\nSolving linear system... done (0.585853s)\\nGenerating output... done (0.092681s)\\n[100%] Built target run\\n \\n> make run\\n[ 66%] Built target @ref step_29 \\\"step-29\\\"\\n[100%] Run @ref step_29 \\\"step-29\\\" with Release configuration\\nGenerating grid... done (0.027986s)\\n  Number of active cells:  102400\\nSetting up system... done (0.070022s)\\n  Number of degrees of freedom: 206082\\nAssembling system matrix... done (0.075252s)\\nSolving linear system... done (4.13989s)\\nGenerating output... done (0.369556s)\\n[100%] Built target run\\n \\n> make run\\n[ 66%] Built target @ref step_29 \\\"step-29\\\"\\n[100%] Run @ref step_29 \\\"step-29\\\" with Release configuration\\nGenerating grid... done (0.186439s)\\n  Number of active cells:  409600\\nSetting up system... done (0.272828s)\\n  Number of degrees of freedom: 821762\\nAssembling system matrix... done (0.316252s)\\nSolving linear system... done (33.1424s)\\nGenerating output... done (1.36328s)\\n[100%] Built target run\\nEach time we refine the mesh once more, so the number of cells and degrees of freedom roughly quadruples from each step to the next. As can be seen, generating the grid, setting up degrees of freedom, assembling the linear system, and generating output scale pretty closely to linear, whereas solving the linear system is an operation that requires 8 times more time each time the number of degrees of freedom is increased by a factor of 4, i.e. it is \\\\({\\\\cal O}(N^{3/2})\\\\). This can be explained by the fact that (using optimal ordering) the bandwidth of a finite element matrix is \\\\(B={\\\\cal O}(N^{(dim-1)/dim})\\\\), and the effort to solve a banded linear system using LU decomposition is \\\\({\\\\cal O}(BN)\\\\). This also explains why the program does run in 3d as well (after changing the dimension on the UltrasoundProblem object), but scales very badly and takes extraordinary patience before it finishes solving the linear system on a mesh with appreciable resolution, even though all the other parts of the program scale very nicely.\\n Possibilities for extensions\\nAn obvious possible extension for this program is to run it in 3d \\u2014 after all, the world around us is three-dimensional, and ultrasound beams propagate in three-dimensional media. You can try this by simply changing the template parameter of the principal class in main() and running it. This won't get you very far, though: certainly not if you do 5 global refinement steps as set in the parameter file. You'll simply run out of memory as both the mesh (with its \\\\((2^5)^3 \\\\cdot 5^3=2^{15}\\\\cdot 125 \\\\approx 4\\\\cdot 10^6\\\\) cells) and in particular the sparse direct solver take too much memory. You can solve with 3 global refinement steps, however, if you have a bit of time: in early 2011, the direct solve takes about half an hour. What you'll notice, however, is that the solution is completely wrong: the mesh size is simply not small enough to resolve the solution's waves accurately, and you can see this in plots of the solution. Consequently, this is one of the cases where adaptivity is indispensable if you don't just want to throw a bigger (presumably parallel) machine at the problem.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2007 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Author: Moritz Allmaras, Texas A&M University, 2007\\n */\\n \\n \\n \\n \\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/function.h>\\n \\n#include <deal.II/lac/vector.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n \\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/manifold_lib.h>\\n \\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_values.h>\\n \\n#include <deal.II/numerics/matrix_tools.h>\\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/vector_tools.h>\\n \\n#include <iostream>\\n#include <fstream>\\n \\n#include <deal.II/base/parameter_handler.h>\\n \\n#include <deal.II/lac/sparse_direct.h>\\n \\n#include <deal.II/fe/fe_system.h>\\n \\n#include <deal.II/base/timer.h>\\n \\nnamespace Step29\\n{\\n using namespace dealii;\\n \\n \\n \\n template <int dim>\\n class DirichletBoundaryValues : public Function<dim>\\n  {\\n public:\\n    DirichletBoundaryValues()\\n      : Function<dim>(2)\\n    {}\\n \\n virtual void vector_value(const Point<dim> & /*p*/,\\n Vector<double> &values) const override\\n {\\n AssertDimension(values.size(), 2);\\n \\n      values(0) = 1;\\n      values(1) = 0;\\n    }\\n \\n virtual void\\n    vector_value_list(const std::vector<Point<dim>> &points,\\n                      std::vector<Vector<double>>   &value_list) const override\\n {\\n AssertDimension(value_list.size(), points.size());\\n \\n for (unsigned int p = 0; p < points.size(); ++p)\\n        DirichletBoundaryValues<dim>::vector_value(points[p], value_list[p]);\\n    }\\n  };\\n \\n \\n class ParameterReader : public Subscriptor\\n  {\\n public:\\n    ParameterReader(ParameterHandler &);\\n void read_parameters(const std::string &);\\n \\n private:\\n void              declare_parameters();\\n ParameterHandler &prm;\\n  };\\n \\n  ParameterReader::ParameterReader(ParameterHandler &paramhandler)\\n    : prm(paramhandler)\\n  {}\\n \\n \\n void ParameterReader::declare_parameters()\\n  {\\n    prm.enter_subsection(\\\"Mesh & geometry parameters\\\");\\n    {\\n      prm.declare_entry(\\\"Number of refinements\\\",\\n \\\"6\\\",\\n Patterns::Integer(0),\\n \\\"Number of global mesh refinement steps \\\"\\n \\\"applied to initial coarse grid\\\");\\n \\n      prm.declare_entry(\\\"Focal distance\\\",\\n \\\"0.3\\\",\\n Patterns::Double(0),\\n \\\"Distance of the focal point of the lens \\\"\\n \\\"to the x-axis\\\");\\n    }\\n    prm.leave_subsection();\\n \\n    prm.enter_subsection(\\\"Physical constants\\\");\\n    {\\n      prm.declare_entry(\\\"c\\\", \\\"1.5e5\\\", Patterns::Double(0), \\\"Wave speed\\\");\\n \\n      prm.declare_entry(\\\"omega\\\", \\\"5.0e7\\\", Patterns::Double(0), \\\"Frequency\\\");\\n    }\\n    prm.leave_subsection();\\n \\n \\n    prm.enter_subsection(\\\"Output parameters\\\");\\n    {\\n      prm.declare_entry(\\\"Output filename\\\",\\n \\\"solution\\\",\\n Patterns::Anything(),\\n \\\"Name of the output file (without extension)\\\");\\n \\n DataOutInterface<1>::declare_parameters(prm);\\n    }\\n    prm.leave_subsection();\\n  }\\n \\n \\n void ParameterReader::read_parameters(const std::string &parameter_file)\\n  {\\n    declare_parameters();\\n \\n    prm.parse_input(parameter_file);\\n  }\\n \\n \\n \\n \\n \\n \\n template <int dim>\\n class ComputeIntensity : public DataPostprocessorScalar<dim>\\n  {\\n public:\\n    ComputeIntensity();\\n \\n virtual void evaluate_vector_field(\\n const DataPostprocessorInputs::Vector<dim> &inputs,\\n      std::vector<Vector<double>> &computed_quantities) const override;\\n  };\\n \\n template <int dim>\\n  ComputeIntensity<dim>::ComputeIntensity()\\n    : DataPostprocessorScalar<dim>(\\\"Intensity\\\", update_values)\\n  {}\\n \\n \\n template <int dim>\\n void ComputeIntensity<dim>::evaluate_vector_field(\\n const DataPostprocessorInputs::Vector<dim> &inputs,\\n    std::vector<Vector<double>>                &computed_quantities) const\\n {\\n AssertDimension(computed_quantities.size(), inputs.solution_values.size());\\n \\n for (unsigned int p = 0; p < computed_quantities.size(); ++p)\\n      {\\n AssertDimension(computed_quantities[p].size(), 1);\\n AssertDimension(inputs.solution_values[p].size(), 2);\\n \\n const std::complex<double> u(inputs.solution_values[p](0),\\n                                     inputs.solution_values[p](1));\\n \\n        computed_quantities[p](0) = std::abs(u);\\n      }\\n  }\\n \\n \\n \\n template <int dim>\\n class UltrasoundProblem\\n  {\\n public:\\n    UltrasoundProblem(ParameterHandler &);\\n void run();\\n \\n private:\\n void make_grid();\\n void setup_system();\\n void assemble_system();\\n void solve();\\n void output_results() const;\\n \\n ParameterHandler &prm;\\n \\n Triangulation<dim> triangulation;\\n DoFHandler<dim>     dof_handler;\\n const FESystem<dim> fe;\\n \\n SparsityPattern      sparsity_pattern;\\n SparseMatrix<double> system_matrix;\\n Vector<double>       solution, system_rhs;\\n  };\\n \\n \\n \\n template <int dim>\\n  UltrasoundProblem<dim>::UltrasoundProblem(ParameterHandler &param)\\n    : prm(param)\\n    , dof_handler(triangulation)\\n    , fe(FE_Q<dim>(1) ^ 2)\\n  {}\\n \\n \\n template <int dim>\\n void UltrasoundProblem<dim>::make_grid()\\n  {\\n    std::cout << \\\"Generating grid... \\\";\\n Timer timer;\\n \\n    prm.enter_subsection(\\\"Mesh & geometry parameters\\\");\\n \\n const double       focal_distance = prm.get_double(\\\"Focal distance\\\");\\n const unsigned int n_refinements = prm.get_integer(\\\"Number of refinements\\\");\\n \\n    prm.leave_subsection();\\n \\n const Point<dim> transducer =\\n      (dim == 2) ? Point<dim>(0.5, 0.0) : Point<dim>(0.5, 0.5, 0.0);\\n const Point<dim> focal_point = (dim == 2) ?\\n Point<dim>(0.5, focal_distance) :\\n Point<dim>(0.5, 0.5, focal_distance);\\n \\n \\n GridGenerator::subdivided_hyper_cube(triangulation, 5, 0, 1);\\n \\n for (auto &cell : triangulation.cell_iterators())\\n      for (const auto &face : cell->face_iterators())\\n        if (face->at_boundary() &&\\n            ((face->center() - transducer).norm_square() < 0.01))\\n          {\\n            face->set_boundary_id(1);\\n            face->set_manifold_id(1);\\n          }\\n triangulation.set_manifold(1, SphericalManifold<dim>(focal_point));\\n \\n triangulation.refine_global(n_refinements);\\n \\n    timer.stop();\\n    std::cout << \\\"done (\\\" << timer.cpu_time() << \\\"s)\\\" << std::endl;\\n \\n    std::cout << \\\"  Number of active cells:  \\\" << triangulation.n_active_cells()\\n              << std::endl;\\n  }\\n \\n \\n template <int dim>\\n void UltrasoundProblem<dim>::setup_system()\\n  {\\n    std::cout << \\\"Setting up system... \\\";\\n Timer timer;\\n \\n    dof_handler.distribute_dofs(fe);\\n \\n DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());\\n DoFTools::make_sparsity_pattern(dof_handler, dsp);\\n    sparsity_pattern.copy_from(dsp);\\n \\n    system_matrix.reinit(sparsity_pattern);\\n    system_rhs.reinit(dof_handler.n_dofs());\\n    solution.reinit(dof_handler.n_dofs());\\n \\n    timer.stop();\\n    std::cout << \\\"done (\\\" << timer.cpu_time() << \\\"s)\\\" << std::endl;\\n \\n    std::cout << \\\"  Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n              << std::endl;\\n  }\\n \\n \\n \\n template <int dim>\\n void UltrasoundProblem<dim>::assemble_system()\\n  {\\n    std::cout << \\\"Assembling system matrix... \\\";\\n Timer timer;\\n \\n \\n    prm.enter_subsection(\\\"Physical constants\\\");\\n \\n const double omega = prm.get_double(\\\"omega\\\"), c = prm.get_double(\\\"c\\\");\\n \\n    prm.leave_subsection();\\n \\n const QGauss<dim>     quadrature_formula(fe.degree + 1);\\n const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);\\n \\n const unsigned int n_q_points      = quadrature_formula.size(),\\n                       n_face_q_points = face_quadrature_formula.size(),\\n                       dofs_per_cell   = fe.n_dofs_per_cell();\\n \\n FEValues<dim> fe_values(fe,\\n                            quadrature_formula,\\n update_values | update_gradients |\\n update_JxW_values);\\n \\n FEFaceValues<dim> fe_face_values(fe,\\n                                     face_quadrature_formula,\\n update_values | update_JxW_values);\\n \\n FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n cell_matrix = 0;\\n        fe_values.reinit(cell);\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n          {\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n              {\\n if (fe.system_to_component_index(i).first ==\\n                    fe.system_to_component_index(j).first)\\n                  {\\n \\n for (unsigned int q_point = 0; q_point < n_q_points;\\n                         ++q_point)\\n cell_matrix(i, j) +=\\n                        (((fe_values.shape_value(i, q_point) *\\n                           fe_values.shape_value(j, q_point)) *\\n                            (-omega * omega) +\\n                          (fe_values.shape_grad(i, q_point) *\\n                           fe_values.shape_grad(j, q_point)) *\\n                            c * c) *\\n                         fe_values.JxW(q_point));\\n \\n                  }\\n              }\\n          }\\n \\n \\n for (const auto face_no : cell->face_indices())\\n          if (cell->face(face_no)->at_boundary() &&\\n              (cell->face(face_no)->boundary_id() == 0))\\n            {\\n              fe_face_values.reinit(cell, face_no);\\n \\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n if ((fe.system_to_component_index(i).first !=\\n                       fe.system_to_component_index(j).first) &&\\n                      fe.has_support_on_face(i, face_no) &&\\n                      fe.has_support_on_face(j, face_no))\\n \\n for (unsigned int q_point = 0; q_point < n_face_q_points;\\n                         ++q_point)\\n cell_matrix(i, j) +=\\n                        ((fe.system_to_component_index(i).first == 0) ? -1 :\\n                                                                        1) *\\n                        fe_face_values.shape_value(i, q_point) *\\n                        fe_face_values.shape_value(j, q_point) * c * omega *\\n                        fe_face_values.JxW(q_point);\\n            }\\n \\n        cell->get_dof_indices(local_dof_indices);\\n \\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n            system_matrix.add(local_dof_indices[i],\\n                              local_dof_indices[j],\\n cell_matrix(i, j));\\n      }\\n \\n \\n    std::map<types::global_dof_index, double> boundary_values;\\n VectorTools::interpolate_boundary_values(dof_handler,\\n                                             1,\\n                                             DirichletBoundaryValues<dim>(),\\n                                             boundary_values);\\n \\n MatrixTools::apply_boundary_values(boundary_values,\\n                                       system_matrix,\\n                                       solution,\\n                                       system_rhs);\\n \\n    timer.stop();\\n    std::cout << \\\"done (\\\" << timer.cpu_time() << \\\"s)\\\" << std::endl;\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void UltrasoundProblem<dim>::solve()\\n  {\\n    std::cout << \\\"Solving linear system... \\\";\\n Timer timer;\\n \\n SparseDirectUMFPACK A_direct;\\n \\n    solution = system_rhs;\\n    A_direct.solve(system_matrix, solution);\\n \\n    timer.stop();\\n    std::cout << \\\"done (\\\" << timer.cpu_time() << \\\"s)\\\" << std::endl;\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void UltrasoundProblem<dim>::output_results() const\\n {\\n    std::cout << \\\"Generating output... \\\";\\n Timer timer;\\n \\n    ComputeIntensity<dim> intensities;\\n DataOut<dim>          data_out;\\n \\n    data_out.attach_dof_handler(dof_handler);\\n \\n    prm.enter_subsection(\\\"Output parameters\\\");\\n \\n const std::string output_filename = prm.get(\\\"Output filename\\\");\\n    data_out.parse_parameters(prm);\\n \\n    prm.leave_subsection();\\n \\n const std::string filename = output_filename + data_out.default_suffix();\\n \\n    std::ofstream output(filename);\\n \\n    std::vector<std::string> solution_names;\\n    solution_names.emplace_back(\\\"Re_u\\\");\\n    solution_names.emplace_back(\\\"Im_u\\\");\\n \\n    data_out.add_data_vector(solution, solution_names);\\n \\n    data_out.add_data_vector(solution, intensities);\\n \\n    data_out.build_patches();\\n    data_out.write(output);\\n \\n    timer.stop();\\n    std::cout << \\\"done (\\\" << timer.cpu_time() << \\\"s)\\\" << std::endl;\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void UltrasoundProblem<dim>::run()\\n  {\\n    make_grid();\\n    setup_system();\\n    assemble_system();\\n    solve();\\n    output_results();\\n  }\\n} // namespace Step29\\n \\n \\n \\nint main()\\n{\\n try\\n    {\\n using namespace dealii;\\n using namespace Step29;\\n \\n ParameterHandler prm;\\n      ParameterReader  param(prm);\\n      param.read_parameters(\\\"step-29.prm\\\");\\n \\n      UltrasoundProblem<2> ultrasound_problem(prm);\\n      ultrasound_problem.run();\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n return 0;\\n}\\nDataOutInterface::parse_parametersvoid parse_parameters(ParameterHandler &prm)Definition data_out_base.cc:8970\\nDataOutInterface::default_suffixstd::string default_suffix(const DataOutBase::OutputFormat output_format=DataOutBase::default_format) constDefinition data_out_base.cc:8900\\nDataOutInterface::writevoid write(std::ostream &out, const DataOutBase::OutputFormat output_format=DataOutBase::default_format) constDefinition data_out_base.cc:8787\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nTimer::cpu_timedouble cpu_time() constDefinition timer.cc:234\\nTimer::stopdouble stop()Definition timer.cc:193\\ndof_handler.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nfe_values.h\\nfe_q.h\\nfe_system.h\\nfull_matrix.h\\nfunction.h\\nmanifold_lib.h\\ntria.h\\ngrid_generator.h\\nmatrix_tools.h\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\ntypes::boundary_idunsigned int boundary_idDefinition types.h:144\\ndata_out.h\\nparameter_handler.h\\nquadrature_lib.h\\nsparse_direct.h\\nsparse_matrix.h\\nDataPostprocessorInputs::Vector::solution_valuesstd::vector<::Vector< double > > solution_valuesDefinition data_postprocessor.h:410\\ntimer.h\\nvector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"