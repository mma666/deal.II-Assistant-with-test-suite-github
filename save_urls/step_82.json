"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_82.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-82 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-82 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-82 tutorial program\\n\\n\\nThis tutorial depends on step-47.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nProblem Statement\\nDiscretization\\n\\nFinite element spaces\\nJumps, averages, and discrete reconstruction of differential operators\\nMotivation for the lifting operators\\nLDG approximations\\n\\nImplementation\\n\\nComputation of the lifting terms\\n\\nTest case\\n\\n The commented program\\n\\nInclude files\\nThe BiLaplacianLDGLift class template\\nEquation data\\nImplementation of the BiLaplacianLDGLift class\\n\\nBiLaplacianLDGLift::BiLaplacianLDGLift\\nBiLaplacianLDGLift::make_grid\\nBiLaplacianLDGLift::setup_system\\nBiLaplacianLDGLift::assemble_system\\nBiLaplacianLDGLift::assemble_matrix\\nBiLaplacianLDGLift::assemble_rhs\\nBiLaplacianLDGLift::solve\\nBiLaplacianLDGLift::compute_errors\\nBiLaplacianLDGLift::output_results\\nBiLaplacianLDGLift::assemble_local_matrix\\nBiLaplacianLDGLift::compute_discrete_hessians\\nBiLaplacianLDGLift::run\\n\\nThe main function\\n\\n\\n Results\\n\\nPossible extensions\\n\\nNon-homogeneous Dirichlet boundary conditions\\n\\n\\n The plain program\\n   \\n This program was contributed by Andrea Bonito (Texas A&M University) and Diane Guignard (University of Ottawa).\\n This material is based upon work supported by the National Science Foundation under Grant No. DMS-1817691. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation. \\nNoteIf you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation:   \\n Introduction\\nProblem Statement\\nIn this example, we consider the local discontinuous Galerkin (LDG) method for approximating the solution to the bi-Laplacian problem,     \\n\\\\begin{align*}\\n\\\\Delta^2 u & = f \\\\quad \\\\mbox{in } \\\\Omega, \\\\\\\\\\n\\\\nabla u & = \\\\mathbf{0} \\\\quad \\\\mbox{on } \\\\partial\\\\Omega, \\\\\\\\\\nu & = 0 \\\\quad \\\\mbox{on } \\\\partial\\\\Omega,\\n\\\\end{align*}\\n\\n where \\\\(\\\\Omega\\\\subset\\\\mathbb{R}^d\\\\) \\\\((d=2,3)\\\\) is an open bounded Lipschitz domain and \\\\(f\\\\in L^2(\\\\Omega)\\\\). This is the same problem we have already considered in step-47, but we will take here a different approach towards solving it: Rather than using continuous finite elements and the interior penalty method, we consider discontinuous finite elements and the local discontinuous Galerkin method defined using lifting operators.\\nThe weak formulation of this problem reads as follows: find \\\\(u\\\\in H_0^2(\\\\Omega)\\\\) such that   \\n\\\\[\\n\\\\int_{\\\\Omega}D^2u:D^2v = \\\\int_{\\\\Omega}fv \\\\qquad \\\\forall \\\\, v\\\\in H_0^2(\\\\Omega),\\n\\\\]\\n\\n where \\\\(D^2v\\\\) denotes the Hessian of \\\\(v\\\\) and \\\\(H_0^2(\\\\Omega)\\\\dealcoloneq\\\\{v\\\\in H^2(\\\\Omega): \\\\,\\\\, v=0 \\\\mbox{ and } \\\\nabla v=\\\\mathbf{0} \\\\,\\\\, \\\\mbox{ on } \\\\partial\\\\Omega\\\\}\\\\). Using so-called lifting operators as well as the Nitsche approach to impose the homogeneous Dirichlet boundary conditions, the LDG approximation of this problem consists of replacing the Hessians by discrete Hessians (see below) and adding penalty terms involving properly scaled jump terms. In particular, the versatility of the method described below is of particular interest for nonlinear problems or problems with intricate weak formulations for which the design of discrete algorithms is challenging.\\nDiscretization\\nFinite element spaces\\nFor \\\\(h>0\\\\), let \\\\(\\\\mathcal{T}_h\\\\) be a partition of \\\\(\\\\Omega\\\\) into quadrilateral (hexahedral if \\\\(d=3\\\\)) elements \\\\(K\\\\) of diameter \\\\(h_{K}\\\\leq h\\\\) and let \\\\(\\\\mathcal{E}_h=\\\\mathcal{E}_h^0\\\\cup\\\\mathcal{E}_h^b\\\\) denote the set of (interior and boundary) faces. We restrict the discussion to conforming subdivisions to avoid technicalities already addressed in previous tutorials. The diameter of \\\\(e \\\\in \\\\mathcal{E}_h\\\\) is denoted \\\\(h_e\\\\). For any integer \\\\(k\\\\ge 2\\\\), we introduce the (discontinuous) finite element space   \\n\\\\[\\n\\\\mathbb{V}_h\\\\dealcoloneq\\\\left\\\\{v_h\\\\in L^2(\\\\Omega): \\\\,\\\\, v_h|_K\\\\circ F_{K}\\\\in\\\\mathbb{Q}_k \\\\quad \\\\forall \\\\, K \\\\in\\\\mathcal{T}_h \\\\right\\\\},\\n\\\\]\\n\\n where \\\\(F_{K}\\\\) is the map from the reference element \\\\(\\\\hat{K}\\\\) (unit square/cube) to the physical element \\\\(K\\\\). For \\\\(v_h\\\\in\\\\mathbb{V}_h\\\\), the piecewise differential operators are denoted with a subscript \\\\(h\\\\), for instance \\\\(\\\\nabla_h v_h|_K=\\\\nabla(v_h|_K)\\\\) and \\\\(D_h^2 v_h=\\\\nabla_h\\\\nabla_h v_h\\\\). For \\\\(e\\\\in\\\\mathcal{E}_h\\\\), we assign a normal \\\\(\\\\mathbf{n}_e\\\\). The choice of normal is irrelevant except that when \\\\(e\\\\) is a boundary face, \\\\(\\\\mathbf{n}_e\\\\) is the normal pointing outward \\\\(\\\\Omega\\\\).\\nJumps, averages, and discrete reconstruction of differential operators\\nThe piecewise differential operators do not have enough information to be accurate approximations of their continuous counterparts. They are missing inter-element information.\\nThis leads to the introductions of jump and average operators:           \\n\\\\[\\n\\\\jump{v_h}|_e \\\\dealcoloneq\\n\\\\left\\\\{\\\\begin{array}{ll}\\nv_h|_{K_1}-v_h|_{K_2} & e\\\\in\\\\mathcal{E}_h^0 \\\\\\\\\\nv_h|_{K_1} & e\\\\in\\\\mathcal{E}_h^b\\n\\\\end{array}\\\\right. \\\\quad \\\\mbox{and} \\\\quad \\\\average{v_h}|_e \\\\dealcoloneq\\n\\\\left\\\\{\\\\begin{array}{ll}\\n\\\\frac{1}{2}(v_h|_{K_1}+v_h|_{K_2}) & e\\\\in\\\\mathcal{E}_h^0 \\\\\\\\\\nv_h|_{K_1} & e\\\\in\\\\mathcal{E}_h^b,\\n\\\\end{array}\\\\right.\\n\\\\]\\n\\n respectively, where \\\\(K_1\\\\) and \\\\(K_2\\\\) are the two elements adjacent to \\\\(e\\\\) so that \\\\(\\\\mathbf{n}_e\\\\) points from \\\\(K_1\\\\) to \\\\(K_2\\\\) (with obvious modification when \\\\(e\\\\) is a boundary edge). These are the same operators that we have previously used not only in step-47, but also in other tutorials related to discontinuous Galerkin methods (e.g., step-12).\\nWith these notations, we are now in position to define the discrete/reconstructed Hessian \\\\(H_h(v_h)\\\\in\\\\left[L^2(\\\\Omega)\\\\right]^{d\\\\times d}\\\\) of \\\\(v_h\\\\in\\\\mathbb{V}_h\\\\); that is, something that will take the role of \\\\(D^2 v\\\\) in the definition of the weak formulation above when moving from the continuous to the discrete formulation. We first consider two local lifting operators \\\\(r_e:[L^2(e)]^d\\\\rightarrow[\\\\mathbb{V}_h]^{d\\\\times d}\\\\) and \\\\(b_e:L^2(e)\\\\rightarrow[\\\\mathbb{V}_h]^{d\\\\times d}\\\\) defined for \\\\(e\\\\in\\\\mathcal{E}_h\\\\) by, respectively,    \\n\\\\[\\nr_e\\\\left(\\\\boldsymbol{\\\\phi}\\\\right) \\\\in [\\\\mathbb{V}_h]^{d\\\\times d}: \\\\,\\n\\\\int_{\\\\Omega} \\\\tau_h : r_e\\\\left(\\\\boldsymbol{\\\\phi}\\\\right) = \\\\int_e\\\\average{\\\\tau_h}\\\\mathbf{n}_e\\\\cdot\\\\boldsymbol{\\\\phi} \\\\qquad \\\\forall \\\\, \\\\tau_h\\\\in [\\\\mathbb{V}_h]^{d\\\\times d}\\n\\\\]\\n\\n and    \\n\\\\[\\nb_e(\\\\phi) \\\\in [\\\\mathbb{V}_h]^{d\\\\times d}: \\\\,\\n\\\\int_{\\\\Omega} \\\\tau_h : b_e(\\\\phi) = \\\\int_e\\\\average{{\\\\rm div}\\\\, \\\\tau_h}\\\\cdot\\\\mathbf{n}_e\\\\phi \\\\qquad \\\\forall \\\\, \\\\tau_h\\\\in [\\\\mathbb{V}_h]^{d\\\\times d}.\\n\\\\]\\n\\n We have \\\\({\\\\rm supp}\\\\,(r_e\\\\left(\\\\boldsymbol{\\\\phi}\\\\right))={\\\\rm supp}\\\\,(b_e(\\\\phi))=\\\\omega_e\\\\), where \\\\(\\\\omega_e\\\\) denotes the patch of (one or two) elements having \\\\(e\\\\) as part of their boundaries.\\nThe discrete Hessian operator \\\\(H_h:\\\\mathbb{V}_h\\\\rightarrow\\\\left[L^2(\\\\Omega)\\\\right]^{2\\\\times 2}\\\\) is then given by   \\n\\\\[\\nH_h(v_h) \\\\dealcoloneq D_h^2 v_h -R_h(\\\\jump{\\\\nabla_h v_h})+B_h(\\\\jump{v_h}) \\\\dealcoloneq D_h^2 v_h - \\\\sum_{e\\\\in\\\\mathcal{E}_h}r_e\\\\left(\\\\jump{\\\\nabla_h v_h}\\\\right)+\\\\sum_{e\\\\in\\\\mathcal{E}_h}b_e\\\\left(\\\\jump{v_h}\\\\right).\\n\\\\]\\n\\nNoteIn general, the polynomial degree of the finite element space for the two lifting terms do not need to be the same as the one used for the approximate solution. A different polynomial degree for each lifting term can also be considered.\\nNote that other differential operators (e.g., gradient or divergence) can be reconstructed in a similar fashion, see for instance [176].\\nMotivation for the lifting operators\\nThe discrete Hessian \\\\(H_h\\\\) is designed such that it weakly converges to the continuous Hessian \\\\(D^2\\\\), see the note in the next section for a precise statement. As already mentioned above, the broken Hessian is not a suitable candidate as it contains no information about inter-element jumps. We provide here an informal discussion motivating the definition of the two lifting operators and we refer to [179] and [37] for more details (although the definitions are slightly different unless the mesh is affine). The goal is then to construct a discrete operator \\\\(H_h\\\\) such that for all \\\\(\\\\tau\\\\in [C_0^{\\\\infty}(\\\\Omega)]^{d\\\\times d}\\\\) we have   \\n\\\\[\\n\\\\int_{\\\\Omega}H_h(v_h):\\\\tau\\\\longrightarrow \\\\int_{\\\\Omega}D^2v:\\\\tau \\\\qquad \\\\mbox{as } \\\\,\\\\, h\\\\rightarrow 0\\n\\\\]\\n\\n for any sequence \\\\(\\\\{v_h\\\\}_{h>0}\\\\) in \\\\(\\\\mathbb{V}_h\\\\) such that \\\\(v_h\\\\rightarrow v\\\\) in \\\\(L^2(\\\\Omega)\\\\) as \\\\(h\\\\rightarrow 0\\\\) for some \\\\(v\\\\in H^2(\\\\Omega)\\\\). Let \\\\(\\\\tau\\\\in [C_0^{\\\\infty}(\\\\Omega)]^{d\\\\times d}\\\\). Integrating by parts twice we get   \\n\\\\[\\n\\\\int_{\\\\Omega}D^2v:\\\\tau = -\\\\int_{\\\\Omega}\\\\nabla v\\\\cdot \\\\mbox{div}(\\\\tau) = \\\\int_{\\\\Omega}v \\\\mbox{ div}(\\\\mbox{div}(\\\\tau))\\n\\\\]\\n\\n while   \\n\\\\[\\n\\\\int_{\\\\Omega}v_h \\\\mbox{ div}(\\\\mbox{div}(\\\\tau)) \\\\longrightarrow \\\\int_{\\\\Omega}v \\\\mbox{ div}(\\\\mbox{div}(\\\\tau)) \\\\qquad \\\\mbox{as } \\\\,\\\\, h\\\\rightarrow 0.\\n\\\\]\\n\\n Now, we integrate two times by parts the left term, taking into account that \\\\(v_h\\\\) is not necessarily continuous across interior faces. For any \\\\(K\\\\in\\\\mathcal{T}_h\\\\) we have   \\n\\\\[\\n\\\\int_K v_h \\\\mbox{ div}(\\\\mbox{div}(\\\\tau)) = -\\\\int_K \\\\nabla v_h\\\\cdot \\\\mbox{div}(\\\\tau) + \\\\int_{\\\\partial K} v_h \\\\mbox{ div}(\\\\tau)\\\\cdot \\\\mathbf{n}_K =\\\\int_K D^2v_h:\\\\tau - \\\\int_{\\\\partial K}\\\\nabla v_h\\\\cdot (\\\\tau\\\\mathbf{n}_K) + \\\\int_{\\\\partial K} v_h \\\\mbox{ div}(\\\\tau)\\\\cdot \\\\mathbf{n}_K,\\n\\\\]\\n\\n where \\\\(\\\\mathbf{n}_K\\\\) denotes the outward unit normal to \\\\(K\\\\). Then, summing over the elements \\\\(K\\\\in\\\\mathcal{T}_h\\\\) and using that \\\\(\\\\tau\\\\) is smooth, we obtain   \\n\\\\[\\n\\\\int_{\\\\Omega} v_h \\\\mbox{ div}(\\\\mbox{div}(\\\\tau)) = \\\\int_{\\\\Omega} D_h^2v_h:\\\\tau - \\\\sum_{e\\\\in\\\\mathcal{E}_h}\\\\int_e\\\\jump{\\\\nabla_h v_h}\\\\cdot \\\\average{\\\\tau}\\\\mathbf{n}_e + \\\\sum_{e\\\\in\\\\mathcal{E}_h}\\\\int_e v_h \\\\average{\\\\mbox{div}(\\\\tau)}\\\\cdot \\\\mathbf{n}_e\\n\\\\]\\n\\n which reveals the motivation for the definition of the two lifting operators: if \\\\(\\\\tau\\\\) was an admissible test function, then the right-hand side would be equal to \\\\(\\\\int_{\\\\Omega}H_h(v_h):\\\\tau\\\\) and we would have shown the desired (weak) convergence. Actually, if we add and subtract \\\\(\\\\tau_h\\\\), the Lagrange interpolant of \\\\(\\\\tau\\\\) in \\\\([\\\\mathbb{V}_h\\\\cap H_0^1(\\\\Omega)]^{d\\\\times d}\\\\), we can show that the right-hand side is indeed equal to \\\\(\\\\int_{\\\\Omega}H_h(v_h):\\\\tau\\\\) up to terms that tends to zero as \\\\(h\\\\rightarrow 0\\\\) under appropriate assumptions on \\\\(v_h\\\\).\\nIt is worth mentioning that defining \\\\(H_h\\\\) without the lifting operators \\\\(r_e\\\\) and \\\\(b_e\\\\) for \\\\(e\\\\in\\\\mathcal{E}_h^b\\\\) would not affect the weak convergence property (the integrals over boundary faces are zero since \\\\(\\\\tau\\\\) is compactly supported in \\\\(\\\\Omega\\\\)). However, they are included in \\\\(H_h\\\\) to ensure that the solution of the discrete problem introduced in the next section satisfies the homogeneous Dirichlet boundary conditions in the limit \\\\(h\\\\rightarrow 0\\\\).\\nLDG approximations\\nThe proposed LDG approximation of the bi-Laplacian problem reads: find \\\\(u_h\\\\in\\\\mathbb{V}_h\\\\) such that   \\n\\\\[\\nA_h(u_h,v_h)\\\\dealcoloneq a_h(u_h,v_h)+j_h(u_h,v_h) = F_h(v_h) \\\\qquad \\\\forall \\\\, v_h\\\\in\\\\mathbb{V}_h,\\n\\\\]\\n\\n where     \\n\\\\begin{align*}\\n        a_h(u_h,v_h) & \\\\dealcoloneq \\\\int_{\\\\Omega}H_h(u_h):H_h(v_h), \\\\\\\\\\n        j_h(u_h,v_h) & \\\\dealcoloneq \\\\gamma_1\\\\sum_{e\\\\in\\\\mathcal{E}_h}h_e^{-1}\\\\int_e\\\\jump{\\\\nabla_h u_h}\\\\cdot\\\\jump{\\\\nabla_h v_h}+\\\\gamma_0\\\\sum_{e\\\\in\\\\mathcal{E}_h}h_e^{-3}\\\\int_e\\\\jump{u_h}\\\\jump{v_h}, \\\\\\\\\\n        F_h(v_h) & \\\\dealcoloneq \\\\int_{\\\\Omega}fv_h.\\n\\\\end{align*}\\n\\n Here, \\\\(\\\\gamma_0,\\\\gamma_1>0\\\\) are penalty parameters.\\nLet \\\\(\\\\{\\\\varphi_i\\\\}_{i=1}^{N_h}\\\\) be the standard basis functions that generate \\\\(\\\\mathbb{V}_h\\\\). We can then express the solution as \\\\(u_h=\\\\sum_{j=1}^{N_h}U_j\\\\varphi_j\\\\) and the problem reads: find \\\\(\\\\boldsymbol{U}=(U_j)_{j=1}^{N_h}\\\\in\\\\mathbb{R}^{N_h}\\\\) such that   \\n\\\\[\\nA\\\\boldsymbol{U} = \\\\boldsymbol{F},\\n\\\\]\\n\\n where \\\\(A=(A_{ij})_{i,j=1}^{N_h}\\\\in\\\\mathbb{R}^{N_h\\\\times N_h}\\\\) and \\\\(\\\\boldsymbol{F}=(F_i)_{i=1}^{N_h}\\\\in\\\\mathbb{R}^{N_h}\\\\) are defined by   \\n\\\\[\\nA_{ij}\\\\dealcoloneq A_h(\\\\varphi_j,\\\\varphi_i) \\\\quad \\\\text{and} \\\\quad F_i\\\\dealcoloneq F_h(\\\\varphi_i), \\\\qquad 1\\\\leq i,j \\\\leq N_h.\\n\\\\]\\n\\nNoteThe sparsity pattern associated with the above LDG method is slightly larger than that of, e.g., the symmetric interior penalty discontinuous Galerkin (SIPG) method. This is because the lifting operators in \\\\(H_h\\\\) extend shape functions defined on one cell to the neighboring cell where it may overlap with the lifted shape functions from a neighbor of the neighbor. However, we have the following interesting properties: \\n\\nThe bilinear form \\\\(A_h(\\\\cdot,\\\\cdot)\\\\) is coercive with respect to the DG \\\\(H^2\\\\) norm   \\n\\\\[\\n  \\\\|v_h\\\\|_{H_h^2(\\\\Omega)}^2\\\\dealcoloneq\\\\|D_h^2v_h\\\\|_{L^2(\\\\Omega)}^2+\\\\sum_{e\\\\in\\\\mathcal{E}_h}h_e^{-1}\\\\|\\\\jump{\\\\nabla_h v_h}\\\\|_{L^2(e)}^2+\\\\sum_{e\\\\in\\\\mathcal{E}_h}h_e^{-3}\\\\|\\\\jump{v_h}\\\\|_{L^2(e)}^2\\n  \\\\]\\n\\n for any choice of penalty parameters \\\\(\\\\gamma_0,\\\\gamma_1>0\\\\). In other words, the stability of the method is ensured for any positive parameters. This is in contrast with interior penalty methods for which they need to be large enough. (See also the discussions about penalty parameters in the step-39, step-47, and step-74 programs.) \\n\\nIf \\\\(\\\\{v_h\\\\}_{h>0}\\\\subset \\\\mathbb{V}_h\\\\) is a sequence uniformly bounded in the \\\\(\\\\|\\\\cdot\\\\|_{H_h^2(\\\\Omega)}\\\\) norm such that \\\\(v_h\\\\rightarrow v\\\\) in \\\\(L^2(\\\\Omega)\\\\) as \\\\(h\\\\rightarrow 0\\\\) for some \\\\(v\\\\in H^2(\\\\Omega)\\\\), then the discrete Hessian \\\\(H_h(v_h)\\\\) weakly converges to \\\\(D^2v\\\\) in \\\\([L^2(\\\\Omega)]^{2\\\\times 2}\\\\) as \\\\(h\\\\rightarrow 0\\\\). Note that the uniform boundedness assumption implies that the limit \\\\(v\\\\) belongs to \\\\(H_0^2(\\\\Omega)\\\\). \\n\\nThe use of a reconstructed operator simplifies the design of the numerical algorithm. In particular, no integration by parts is needed to derive the discrete problem. This strategy of replacing differential operators by appropriate discrete counter-parts can be applied to nonlinear and more general problems, for instance variational problems without a readily accessible strong formulation. It has been used for instance in [38] and [39] in the context of large bending deformation of plates.  \\n\\n\\nAs in step-47, we could consider \\\\(C^0\\\\) finite element approximations by replacing FE_DGQ<dim> by FE_Q<dim> (and include the appropriate header file deal.II/fe/fe_q.h) in the program below. In this case, the jump of the basis functions across any interior face is zero, and thus \\\\(b_e\\\\left(\\\\jump{\\\\varphi_i}\\\\right)=\\\\mathbf{0}\\\\) for all \\\\(e\\\\in\\\\mathcal{E}_h^0\\\\), and could be dropped to save computational time. While an overkill for the bi-Laplacian problem, the flexibility of fully discontinuous methods combined with reconstructed differential operators is advantageous for nonlinear problems.\\nImplementation\\nAs customary, we assemble the matrix \\\\(A\\\\) and the right-hand side \\\\(\\\\boldsymbol{F}\\\\) by looping over the elements \\\\(K\\\\in\\\\mathcal{T}_h\\\\). Since we are using discontinuous finite elements, the support of each \\\\(\\\\varphi_i\\\\) is only one element \\\\(K\\\\in\\\\mathcal{T}_h\\\\). However, due to the lifting operators, the support of \\\\(H_h(\\\\varphi_i)\\\\) is \\\\(K\\\\) plus all the neighbors of \\\\(K\\\\) (recall that for \\\\(e\\\\in \\\\mathcal{E}_h\\\\), the support of the lifting operators \\\\(r_e\\\\) and \\\\(b_e\\\\) is \\\\(\\\\omega_e\\\\)). Therefore, when integrating over a cell \\\\(K_c\\\\), we need to consider the following interactions (case \\\\(d=2\\\\))\\n\\n\\n \\u00a0 \\n\\ndofs \\\\(K_c\\\\) \\\\(\\\\leftrightarrow\\\\) dofs \\\\(K_c\\\\) \\u00a0 (stored in stiffness_matrix_cc)  \\n\\ndofs \\\\(K_c\\\\) \\\\(\\\\leftrightarrow\\\\) dofs \\\\(K_{n_k}\\\\) \\u00a0 (stored in stiffness_matrix_cn and stiffness_matrix_nc)  \\n\\ndofs \\\\(K_{n_k}\\\\) \\\\(\\\\leftrightarrow\\\\) dofs \\\\(K_{n_k}\\\\) \\u00a0 (stored in stiffness_matrix_nn)  \\n\\ndofs \\\\(K_{n_k}\\\\) \\\\(\\\\leftrightarrow\\\\) dofs \\\\(K_{n_l}\\\\), \\\\(k\\\\ne l\\\\) \\u00a0 (stored in stiffness_matrix_n1n2 and stiffness_matrix_n2n1)  \\n\\n\\n\\nThe last of these accounts that the lifted shape functions from one of the neighbor cells may overlap on \\\\(K_c\\\\) with the lifted shape functions of another neighbor cell, as mentioned above. In other words, we need to compute the discrete Hessian of all the basis functions with support on \\\\(K_c\\\\) as well as all the basis functions with support on the neighboring cells of \\\\(K_c\\\\). This is done in the function compute_discrete_hessians. A cell \\\\(K_c\\\\) can have fewer than four neighbors (six when \\\\(d=3\\\\)) when at least one face \\\\(e\\\\subset\\\\partial K_c\\\\) is part of the boundary of the domain. It can also have more neighbors when hanging nodes are present. To simplify the presentation we do not discuss the latter.\\nDue to the local support of the basis functions, many of the terms of the discrete Hessian are zero. For any basis function \\\\(\\\\varphi^c\\\\) with support on \\\\(K_c\\\\) we have \\\\(r_e\\\\left(\\\\jump{\\\\nabla_h\\\\varphi^c}\\\\right)\\\\not\\\\equiv 0\\\\) only if \\\\(e\\\\subset\\\\partial K_c\\\\), and similarly for \\\\(b_e\\\\left(\\\\jump{\\\\varphi^c}\\\\right)\\\\). Therefore, the discrete Hessian of \\\\(\\\\varphi^c\\\\) reduces to   \\n\\\\[\\nH_h(\\\\varphi^c)=D_h^2\\\\varphi^c-\\\\sum_{e\\\\subset\\\\partial K}r_e\\\\left(\\\\jump{\\\\nabla_h \\\\varphi^c}\\\\right)+\\\\sum_{e\\\\subset\\\\partial K}b_e\\\\left(\\\\jump{\\\\varphi^c}\\\\right).\\n\\\\]\\n\\n Furthermore, since we integrate on \\\\(K_c\\\\), we only need to evaluate the discrete Hessian at quadrature points \\\\(x_q\\\\) that belong to \\\\(K_c\\\\), namely \\\\(H_h(\\\\varphi^c)(x_q)\\\\). We store this information in   \\n\\\\[\\n{\\\\rm compute\\\\_discrete\\\\_hessians[i][q]}, \\\\qquad 0\\\\leq {\\\\rm i} < {\\\\rm n\\\\_dofs}, \\\\,\\\\, 0\\\\leq {\\\\rm q} < {\\\\rm n\\\\_q\\\\_points},\\n\\\\]\\n\\n where n_dofs = fe_values.dofs_per_cell is the number of degrees of freedom per cell and n_q_points = quad.size() is the number of quadrature points on \\\\(K_c\\\\). For any basis function \\\\(\\\\varphi^n\\\\) with support on a neighboring cell, the discrete Hessian \\\\(H_h(\\\\varphi^n)\\\\) evaluated on \\\\(K_c\\\\) contains only the two lifting terms, but not the term involving \\\\(D^2_h\\\\varphi^n\\\\), since \\\\(\\\\varphi^n|_{K}\\\\equiv 0\\\\). Moreover, only the lifting over the common face \\\\(e\\\\) is nonzero on \\\\(K_c\\\\), namely for all \\\\(x_q\\\\in K_c\\\\)   \\n\\\\[\\nH_h(\\\\varphi^n)(x_q)=-r_e\\\\left(\\\\jump{\\\\nabla_h\\\\varphi^n}\\\\right)(x_q)+b_e\\\\left(\\\\jump{\\\\varphi^n}\\\\right)(x_q).\\n\\\\]\\n\\n This information is stored in   \\n\\\\[\\n{\\\\rm compute\\\\_discrete\\\\_hessians\\\\_neigh[face\\\\_no][i][q]}, \\\\qquad 0\\\\leq {\\\\rm face\\\\_no} < {\\\\rm n\\\\_faces}, \\\\,\\\\, 0\\\\leq {\\\\rm i} < {\\\\rm n\\\\_dofs}, \\\\,\\\\, 0\\\\leq {\\\\rm q} < {\\\\rm n\\\\_q\\\\_points},\\n\\\\]\\n\\n where n_dofs and n_q_points are as above, and n_faces = GeometryInfo<dim>::faces_per_cell is the number of faces of \\\\(K_c\\\\). As we shall see in the next section, we will only need to solve half of the local problems for the lifting terms.\\nNoteThe variable discrete_hessians_neigh is of size n_faces x n_dofs x n_q_points. However, we only need to consider the interior faces, namely we do not need to fill discrete_hessians_neigh[face_no][i][q] whenever face_no corresponds to a boundary face. We could then save a little bit of storage by considering \\\\(0\\\\leq {\\\\rm face\\\\_no} < {\\\\rm n\\\\_faces}\\\\) with n_faces the actual number of neighboring cells, i.e., not counting the boundary faces. By doing so, we could also avoid testing if a face lies on the boundary in the assembly of the matrix.\\nComputation of the lifting terms\\nWe now describe the computation of the lifting operators \\\\(r_e\\\\) and \\\\(b_e\\\\) on each cell \\\\(K_c\\\\). This turns out to be a bit cumbersome, but it follows similar schemes as other reconstruction operators \\u2013 see, for example, the \\\"weak Galerkin\\\" approach on step-61 or the \\\"hybridizable discontinuous Galerkin\\\" method in step-51. We focus on \\\\(b_e\\\\) for an interior face \\\\(e\\\\in\\\\mathcal{E}_h^0\\\\), but the other cases are treated similarly.\\nWe have \\\\(e=\\\\partial K_c\\\\cap \\\\partial K_n\\\\) for some neighbor \\\\(K_n\\\\) of \\\\(K_c\\\\). For a basis function \\\\(\\\\varphi\\\\in\\\\mathbb{V}_h\\\\) with support on \\\\(K_c\\\\) or \\\\(K_n\\\\) (for the other basis functions we have \\\\(b_e\\\\left(\\\\jump{\\\\varphi}\\\\right)\\\\equiv 0\\\\)), we write \\\\(b_e\\\\left(\\\\jump{\\\\varphi}\\\\right)\\\\in[\\\\mathbb{V}_h]^{d\\\\times d}\\\\) as   \\n\\\\[\\nb_e\\\\left(\\\\jump{\\\\varphi}\\\\right)=\\\\sum_{n=1}^{N_c+N_n}B_n\\\\psi_n,\\n\\\\]\\n\\n where \\\\(\\\\{\\\\psi_n\\\\}_{n=1}^{N_c}\\\\) and \\\\(\\\\{\\\\psi_n\\\\}_{n=N_c+1}^{N_c+N_n}\\\\) are the basis functions of \\\\([\\\\mathbb{V}_h]^{d\\\\times d}\\\\) which have support on \\\\(K_c\\\\) and \\\\(K_n\\\\), respectively. The coefficients \\\\(\\\\boldsymbol{B}=(B_n)_{n=1}^{N_c+N_n}\\\\in\\\\mathbb{R}^{N_c+N_c}\\\\) of the lifting operator \\\\(b_e\\\\) are obtain upon solving the linear system   \\n\\\\[\\nM\\\\boldsymbol{B}=\\\\boldsymbol{G},\\n\\\\]\\n\\n where the components of the (local) mass matrix and the right-hand side are given respectively by   \\n\\\\[\\nM_{mn}\\\\dealcoloneq\\\\int_{\\\\Omega}\\\\psi_n:\\\\psi_m \\\\quad \\\\mbox{and} \\\\quad G_m\\\\dealcoloneq\\\\int_e\\\\average{{\\\\rm div}\\\\, \\\\psi_m}\\\\cdot \\\\mathbf{n}_e\\\\jump{\\\\varphi}, \\\\qquad 1\\\\leq m,n \\\\leq N_c+N_n.\\n\\\\]\\n\\n Note that this system has the decoupled form          \\n\\\\[\\n\\\\left[\\\\begin{array}{cc}\\nM_c & \\\\mathbf{0} \\\\\\\\\\n\\\\mathbf{0} & M_n\\n\\\\end{array}\\\\right]\\\\left[\\\\begin{array}{c}\\n\\\\boldsymbol{B}_c \\\\\\\\ \\\\boldsymbol{B}_n\\n\\\\end{array}\\\\right]=\\\\left[\\\\begin{array}{c}\\n\\\\boldsymbol{G}_c \\\\\\\\ \\\\boldsymbol{G}_n\\n\\\\end{array}\\\\right]\\n\\\\]\\n\\n with \\\\(M_c\\\\in\\\\mathbb{R}^{N_c\\\\times N_c}\\\\), \\\\(M_n\\\\in\\\\mathbb{R}^{N_n\\\\times N_n}\\\\), \\\\(\\\\boldsymbol{B}_c,\\\\boldsymbol{G}_c\\\\in\\\\mathbb{R}^{N_c}\\\\), and \\\\(\\\\boldsymbol{B}_n,\\\\boldsymbol{G}_n\\\\in\\\\mathbb{R}^{N_n}\\\\).\\nIn fact, since we evaluate the discrete Hessians at quadrature points \\\\(x_q\\\\in K_c\\\\) and \\\\(\\\\psi_n|_{K_c}\\\\equiv 0\\\\) for \\\\(n=N_c+1,\\\\ldots,N_c+N_n\\\\), we have   \\n\\\\[\\nb_e\\\\left(\\\\jump{\\\\varphi}\\\\right)(x_q)=\\\\sum_{n=1}^{N_c+N_n}B_n\\\\psi_n(x_q)=\\\\sum_{n=1}^{N_c}B_n\\\\psi_n(x_q).\\n\\\\]\\n\\n As a consequence, only the coefficients \\\\(B_n\\\\), \\\\(n=1,\\\\ldots,N_c\\\\), are needed.\\nTo compute the components \\\\(G_m\\\\), \\\\(m=1,\\\\ldots,N_c\\\\), we take advantage of the relation   \\n\\\\[\\n\\\\mathbf{n}_e\\\\jump{\\\\varphi}=\\\\mathbf{n}_{K_c}\\\\varphi|_{K_c}+\\\\mathbf{n}_{K_n}\\\\varphi|_{K_n},\\n\\\\]\\n\\n where \\\\(\\\\mathbf{n}_{K_c}\\\\) (resp. \\\\(\\\\mathbf{n}_{K_n}\\\\)) denotes the outward unit normal to \\\\(K_c\\\\) (resp. \\\\(K_n\\\\)). Therefore, if \\\\(\\\\varphi=\\\\varphi^c\\\\), namely \\\\(\\\\varphi\\\\) has support on the current cell \\\\(K_c\\\\), then   \\n\\\\[\\nG_m=\\\\int_e\\\\average{{\\\\rm div}\\\\, \\\\psi_m}\\\\cdot\\\\mathbf{n}_e\\\\jump{\\\\varphi^c}=\\\\frac{1}{2}\\\\int_e{\\\\rm div}\\\\, \\\\psi_m\\\\cdot\\\\mathbf{n}_{K_c}\\\\varphi^c,\\n\\\\]\\n\\n while if \\\\(\\\\varphi=\\\\varphi^n\\\\), namely \\\\(\\\\varphi\\\\) has support on the neighboring cell \\\\(K_n\\\\), then   \\n\\\\[\\nG_m=\\\\int_e\\\\average{{\\\\rm div}\\\\, \\\\psi_m}\\\\cdot\\\\mathbf{n}_e\\\\jump{\\\\varphi^n}=\\\\frac{1}{2}\\\\int_e{\\\\rm div}\\\\, \\\\psi_m\\\\cdot\\\\mathbf{n}_{K_n}\\\\varphi^n.\\n\\\\]\\n\\n The factor \\\\(\\\\frac{1}{2}\\\\) comes from the average operator as \\\\(e\\\\) is assumed to be an interior face.\\nTest case\\nThe performance of the numerical algorithm will be assessed using a manufactured solution \\\\(u:(0,1)^d\\\\rightarrow\\\\mathbb{R}\\\\) given by   \\n\\\\[\\nu(x,y)=x^2(1-x)^2y^2(1-y)^2\\n\\\\]\\n\\n if \\\\(d=2\\\\), while if \\\\(d=3\\\\) we take   \\n\\\\[\\nu(x,y,z)=x^2(1-x)^2y^2(1-y)^2z^2(1-z)^2.\\n\\\\]\\n\\nFor different values of \\\\(h\\\\), we will report the error \\\\(u-u_h\\\\) measured in the discrete \\\\(H^2\\\\) metric (defined above but extended to piecewise \\\\(H^2\\\\) functions), the discrete \\\\(H^1\\\\) metric   \\n\\\\[\\n\\\\|v\\\\|_{H_h^1(\\\\Omega)}^2 \\\\dealcoloneq \\\\|\\\\nabla_h v\\\\|_{L^2(\\\\Omega)}^2+\\\\sum_{e\\\\in\\\\mathcal{E}_h}h_e^{-1}\\\\|\\\\jump{v}\\\\|_{L^2(e)}^2, \\\\quad v\\\\in \\\\prod_{K\\\\in\\\\mathcal{T}_h}H^1(K),\\n\\\\]\\n\\n as well as the \\\\(L^2\\\\) metric.\\n The commented program\\n Include files\\nAll the include files have already been discussed in previous tutorials.\\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/tria_accessor.h>\\n\\u00a0 #include <deal.II/grid/tria_iterator.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_accessor.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_dgq.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 #include <deal.II/fe/fe_system.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\nThe following three header files are for the solvers. The linear system is solved using a direct method while the conjugate gradient method is used to solve the local problems for the lifting terms.\\n\\u00a0 #include <deal.II/lac/sparse_direct.h>\\n\\u00a0 #include <deal.II/lac/solver_cg.h>\\n\\u00a0 #include <deal.II/lac/precondition.h>\\n\\u00a0 \\n\\u00a0 #include <fstream>\\n\\u00a0 #include <iostream>\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 namespace Step82\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n The BiLaplacianLDGLift class template\\nThe main class of this program is similar to that of step-3 or step-20, as well as many other tutorial programs. The key function here is compute_discrete_hessians() which, as its name suggests, computes the discrete Hessians needed for the assembly of the matrix \\\\(A\\\\).\\n\\u00a0   template <int dim>\\n\\u00a0   class BiLaplacianLDGLift\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     BiLaplacianLDGLift(const unsigned int n_refinements,\\n\\u00a0                        const unsigned int fe_degree,\\n\\u00a0                        const double       penalty_jump_grad,\\n\\u00a0                        const double       penalty_jump_val);\\n\\u00a0 \\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void make_grid();\\n\\u00a0     void setup_system();\\n\\u00a0     void assemble_system();\\n\\u00a0     void assemble_matrix();\\n\\u00a0     void assemble_rhs();\\n\\u00a0 \\n\\u00a0     void solve();\\n\\u00a0 \\n\\u00a0     void compute_errors();\\n\\u00a0     void output_results() const;\\n\\u00a0 \\nAs indicated by its name, the function assemble_local_matrix() is used for the assembly of the (local) mass matrix used to compute the two lifting terms (see the matrix \\\\(\\\\boldsymbol{M}_c\\\\) introduced in the introduction when describing the computation of \\\\(b_e\\\\)). The function compute_discrete_hessians() computes the required discrete Hessians: the discrete Hessians of the basis functions with support on the current cell (stored in the output variable discrete_hessians) and the basis functions with support on a neighbor of the current cell (stored in the output variable discrete_hessians_neigh). More precisely, discrete_hessians[i][q_point] stores \\\\(H_h(\\\\varphi_i)(x_q)\\\\), where \\\\(\\\\varphi_i\\\\) is a basis function with support on cell, while discrete_hessians_neigh[face_no][i][q_point] stores \\\\(H_h(\\\\varphi_i)(x_q)\\\\), where \\\\(\\\\varphi_i\\\\) is a basis function of the neighboring cell adjacent to the face face=cell->face(face_no).\\n\\u00a0     void assemble_local_matrix(const FEValues<dim> &fe_values_lift,\\n\\u00a0                                const unsigned int   n_q_points,\\n\\u00a0                                FullMatrix<double>  &local_matrix);\\n\\u00a0 \\n\\u00a0     void compute_discrete_hessians(\\n\\u00a0       const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0       std::vector<std::vector<Tensor<2, dim>>>             &discrete_hessians,\\n\\u00a0       std::vector<std::vector<std::vector<Tensor<2, dim>>>>\\n\\u00a0         &discrete_hessians_neigh);\\n\\u00a0 \\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0 \\n\\u00a0     const unsigned int n_refinements;\\n\\u00a0 \\n\\u00a0     const FE_DGQ<dim> fe;\\n\\u00a0     DoFHandler<dim>   dof_handler;\\n\\u00a0 \\nDoFHandlerDefinition dof_handler.h:317\\nFEValuesDefinition fe_values.h:63\\nFE_DGQDefinition fe_dgq.h:112\\nFullMatrixDefinition full_matrix.h:79\\nTensorDefinition tensor.h:471\\nTriangulationDefinition tria.h:1323\\nDoFHandler::active_cell_iteratortypename ActiveSelector::active_cell_iterator active_cell_iteratorDefinition dof_handler.h:440\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\nWe also need a variable that describes the finite element space \\\\([\\\\mathbb{V}_h]^{d\\\\times d}\\\\) used for the two lifting operators. The other member variables below are as in most of the other tutorial programs.\\n\\u00a0     const FESystem<dim> fe_lift;\\n\\u00a0 \\n\\u00a0     SparsityPattern      sparsity_pattern;\\n\\u00a0     SparseMatrix<double> matrix;\\n\\u00a0     Vector<double>       rhs;\\n\\u00a0     Vector<double>       solution;\\n\\u00a0 \\nFESystemDefinition fe_system.h:208\\nSparseMatrixDefinition sparse_matrix.h:520\\nSparsityPatternDefinition sparsity_pattern.h:343\\nVectorDefinition vector.h:120\\nFinally, the last two variables correspond to the penalty coefficients \\\\(\\\\gamma_1\\\\) and \\\\(\\\\gamma_0\\\\) for the jump of \\\\(\\\\nabla_hu_h\\\\) and \\\\(u_h\\\\), respectively.\\n\\u00a0     const double penalty_jump_grad;\\n\\u00a0     const double penalty_jump_val;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n Equation data\\nThis class implement the right-hand side \\\\(f=\\\\Delta^2 u\\\\) corresponding to the manufactured solution \\\\(u\\\\) defined in the introduction.\\n\\u00a0   template <int dim>\\n\\u00a0   class RightHandSide : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     RightHandSide()\\n\\u00a0       : Function<dim>()\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component = 0) const override;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double RightHandSide<dim>::value(const Point<dim> &p,\\n\\u00a0                                    const unsigned int /*component*/) const\\n\\u00a0   {\\n\\u00a0     double return_value = 0.0;\\n\\u00a0 \\n\\u00a0     if (dim == 2)\\n\\u00a0       {\\n\\u00a0         return_value = 24.0 * Utilities::fixed_power<2>(p[1] * (1.0 - p[1])) +\\n\\u00a0                        +24.0 * Utilities::fixed_power<2>(p[0] * (1.0 - p[0])) +\\n\\u00a0                        2.0 * (2.0 - 12.0 * p[0] + 12.0 * p[0] * p[0]) *\\n\\u00a0                          (2.0 - 12.0 * p[1] + 12.0 * p[1] * p[1]);\\n\\u00a0       }\\n\\u00a0     else if (dim == 3)\\n\\u00a0       {\\n\\u00a0         return_value = 24.0 * Utilities::fixed_power<2>(p[1] * (1.0 - p[1]) *\\n\\u00a0                                                         p[2] * (1.0 - p[2])) +\\n\\u00a0                        24.0 * Utilities::fixed_power<2>(p[0] * (1.0 - p[0]) *\\n\\u00a0                                                         p[2] * (1.0 - p[2])) +\\n\\u00a0                        24.0 * Utilities::fixed_power<2>(p[0] * (1.0 - p[0]) *\\n\\u00a0                                                         p[1] * (1.0 - p[1])) +\\n\\u00a0                        2.0 * (2.0 - 12.0 * p[0] + 12.0 * p[0] * p[0]) *\\n\\u00a0                          (2.0 - 12.0 * p[1] + 12.0 * p[1] * p[1]) *\\n\\u00a0                          Utilities::fixed_power<2>(p[2] * (1.0 - p[2])) +\\n\\u00a0                        2.0 * (2.0 - 12.0 * p[0] + 12.0 * p[0] * p[0]) *\\n\\u00a0                          (2.0 - 12.0 * p[2] + 12.0 * p[2] * p[2]) *\\n\\u00a0                          Utilities::fixed_power<2>(p[1] * (1.0 - p[1])) +\\n\\u00a0                        2.0 * (2.0 - 12.0 * p[1] + 12.0 * p[1] * p[1]) *\\n\\u00a0                          (2.0 - 12.0 * p[2] + 12.0 * p[2] * p[2]) *\\n\\u00a0                          Utilities::fixed_power<2>(p[0] * (1.0 - p[0]));\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       DEAL_II_NOT_IMPLEMENTED();\\n\\u00a0 \\n\\u00a0     return return_value;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFunctionDefinition function.h:152\\nFunction::valuevirtual RangeNumberType value(const Point< dim > &p, const unsigned int component=0) const\\nPointDefinition point.h:111\\nDEAL_II_NOT_IMPLEMENTED#define DEAL_II_NOT_IMPLEMENTED()Definition exceptions.h:1814\\nUtilities::fixed_powerconstexpr T fixed_power(const T t)Definition utilities.h:942\\nThis class implement the manufactured (exact) solution \\\\(u\\\\). To compute the errors, we need the value of \\\\(u\\\\) as well as its gradient and its Hessian.\\n\\u00a0   template <int dim>\\n\\u00a0   class ExactSolution : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     ExactSolution()\\n\\u00a0       : Function<dim>()\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component = 0) const override;\\n\\u00a0 \\n\\u00a0     virtual Tensor<1, dim>\\n\\u00a0     gradient(const Point<dim>  &p,\\n\\u00a0              const unsigned int component = 0) const override;\\n\\u00a0 \\n\\u00a0     virtual SymmetricTensor<2, dim>\\n\\u00a0     hessian(const Point<dim>  &p,\\n\\u00a0             const unsigned int component = 0) const override;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double ExactSolution<dim>::value(const Point<dim> &p,\\n\\u00a0                                    const unsigned int /*component*/) const\\n\\u00a0   {\\n\\u00a0     double return_value = 0.0;\\n\\u00a0 \\n\\u00a0     if (dim == 2)\\n\\u00a0       {\\n\\u00a0         return_value =\\n\\u00a0           Utilities::fixed_power<2>(p[0] * (1.0 - p[0]) * p[1] * (1.0 - p[1]));\\n\\u00a0       }\\n\\u00a0     else if (dim == 3)\\n\\u00a0       {\\n\\u00a0         return_value = Utilities::fixed_power<2>(\\n\\u00a0           p[0] * (1.0 - p[0]) * p[1] * (1.0 - p[1]) * p[2] * (1.0 - p[2]));\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       DEAL_II_NOT_IMPLEMENTED();\\n\\u00a0 \\n\\u00a0     return return_value;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   Tensor<1, dim>\\n\\u00a0   ExactSolution<dim>::gradient(const Point<dim> &p,\\n\\u00a0                                const unsigned int /*component*/) const\\n\\u00a0   {\\n\\u00a0     Tensor<1, dim> return_gradient;\\n\\u00a0 \\n\\u00a0     if (dim == 2)\\n\\u00a0       {\\n\\u00a0         return_gradient[0] =\\n\\u00a0           (2.0 * p[0] - 6.0 * Utilities::fixed_power<2>(p[0]) +\\n\\u00a0            4.0 * Utilities::fixed_power<3>(p[0])) *\\n\\u00a0           Utilities::fixed_power<2>(p[1] * (1.0 - p[1]));\\n\\u00a0         return_gradient[1] =\\n\\u00a0           (2.0 * p[1] - 6.0 * Utilities::fixed_power<2>(p[1]) +\\n\\u00a0            4.0 * Utilities::fixed_power<3>(p[1])) *\\n\\u00a0           Utilities::fixed_power<2>(p[0] * (1.0 - p[0]));\\n\\u00a0       }\\n\\u00a0     else if (dim == 3)\\n\\u00a0       {\\n\\u00a0         return_gradient[0] =\\n\\u00a0           (2.0 * p[0] - 6.0 * Utilities::fixed_power<2>(p[0]) +\\n\\u00a0            4.0 * Utilities::fixed_power<3>(p[0])) *\\n\\u00a0           Utilities::fixed_power<2>(p[1] * (1.0 - p[1]) * p[2] * (1.0 - p[2]));\\n\\u00a0         return_gradient[1] =\\n\\u00a0           (2.0 * p[1] - 6.0 * Utilities::fixed_power<2>(p[1]) +\\n\\u00a0            4.0 * Utilities::fixed_power<3>(p[1])) *\\n\\u00a0           Utilities::fixed_power<2>(p[0] * (1.0 - p[0]) * p[2] * (1.0 - p[2]));\\n\\u00a0         return_gradient[2] =\\n\\u00a0           (2.0 * p[2] - 6.0 * Utilities::fixed_power<2>(p[2]) +\\n\\u00a0            4.0 * Utilities::fixed_power<3>(p[2])) *\\n\\u00a0           Utilities::fixed_power<2>(p[0] * (1.0 - p[0]) * p[1] * (1.0 - p[1]));\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       DEAL_II_NOT_IMPLEMENTED();\\n\\u00a0 \\n\\u00a0     return return_gradient;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   SymmetricTensor<2, dim>\\n\\u00a0   ExactSolution<dim>::hessian(const Point<dim> &p,\\n\\u00a0                               const unsigned int /*component*/) const\\n\\u00a0   {\\n\\u00a0     SymmetricTensor<2, dim> return_hessian;\\n\\u00a0 \\n\\u00a0     if (dim == 2)\\n\\u00a0       {\\n\\u00a0         return_hessian[0][0] = (2.0 - 12.0 * p[0] + 12.0 * p[0] * p[0]) *\\n\\u00a0                                Utilities::fixed_power<2>(p[1] * (1.0 - p[1]));\\n\\u00a0         return_hessian[0][1] =\\n\\u00a0           (2.0 * p[0] - 6.0 * Utilities::fixed_power<2>(p[0]) +\\n\\u00a0            4.0 * Utilities::fixed_power<3>(p[0])) *\\n\\u00a0           (2.0 * p[1] - 6.0 * Utilities::fixed_power<2>(p[1]) +\\n\\u00a0            4.0 * Utilities::fixed_power<3>(p[1]));\\n\\u00a0         return_hessian[1][1] = (2.0 - 12.0 * p[1] + 12.0 * p[1] * p[1]) *\\n\\u00a0                                Utilities::fixed_power<2>(p[0] * (1.0 - p[0]));\\n\\u00a0       }\\n\\u00a0     else if (dim == 3)\\n\\u00a0       {\\n\\u00a0         return_hessian[0][0] =\\n\\u00a0           (2.0 - 12.0 * p[0] + 12.0 * p[0] * p[0]) *\\n\\u00a0           Utilities::fixed_power<2>(p[1] * (1.0 - p[1]) * p[2] * (1.0 - p[2]));\\n\\u00a0         return_hessian[0][1] =\\n\\u00a0           (2.0 * p[0] - 6.0 * Utilities::fixed_power<2>(p[0]) +\\n\\u00a0            4.0 * Utilities::fixed_power<3>(p[0])) *\\n\\u00a0           (2.0 * p[1] - 6.0 * Utilities::fixed_power<2>(p[1]) +\\n\\u00a0            4.0 * Utilities::fixed_power<3>(p[1])) *\\n\\u00a0           Utilities::fixed_power<2>(p[2] * (1.0 - p[2]));\\n\\u00a0         return_hessian[0][2] =\\n\\u00a0           (2.0 * p[0] - 6.0 * Utilities::fixed_power<2>(p[0]) +\\n\\u00a0            4.0 * Utilities::fixed_power<3>(p[0])) *\\n\\u00a0           (2.0 * p[2] - 6.0 * Utilities::fixed_power<2>(p[2]) +\\n\\u00a0            4.0 * Utilities::fixed_power<3>(p[2])) *\\n\\u00a0           Utilities::fixed_power<2>(p[1] * (1.0 - p[1]));\\n\\u00a0         return_hessian[1][1] =\\n\\u00a0           (2.0 - 12.0 * p[1] + 12.0 * p[1] * p[1]) *\\n\\u00a0           Utilities::fixed_power<2>(p[0] * (1.0 - p[0]) * p[2] * (1.0 - p[2]));\\n\\u00a0         return_hessian[1][2] =\\n\\u00a0           (2.0 * p[1] - 6.0 * Utilities::fixed_power<2>(p[1]) +\\n\\u00a0            4.0 * Utilities::fixed_power<3>(p[1])) *\\n\\u00a0           (2.0 * p[2] - 6.0 * Utilities::fixed_power<2>(p[2]) +\\n\\u00a0            4.0 * Utilities::fixed_power<3>(p[2])) *\\n\\u00a0           Utilities::fixed_power<2>(p[0] * (1.0 - p[0]));\\n\\u00a0         return_hessian[2][2] =\\n\\u00a0           (2.0 - 12.0 * p[2] + 12.0 * p[2] * p[2]) *\\n\\u00a0           Utilities::fixed_power<2>(p[0] * (1.0 - p[0]) * p[1] * (1.0 - p[1]));\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       DEAL_II_NOT_IMPLEMENTED();\\n\\u00a0 \\n\\u00a0     return return_hessian;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFunction::hessianvirtual SymmetricTensor< 2, dim, RangeNumberType > hessian(const Point< dim > &p, const unsigned int component=0) const\\nFunction::gradientvirtual Tensor< 1, dim, RangeNumberType > gradient(const Point< dim > &p, const unsigned int component=0) const\\nSymmetricTensorDefinition symmetric_tensor.h:719\\n Implementation of the BiLaplacianLDGLift class\\n BiLaplacianLDGLift::BiLaplacianLDGLift\\nIn the constructor, we set the polynomial degree of the two finite element spaces, we associate the corresponding DoF handlers to the triangulation, and we set the two penalty coefficients.\\n\\u00a0   template <int dim>\\n\\u00a0   BiLaplacianLDGLift<dim>::BiLaplacianLDGLift(const unsigned int n_refinements,\\n\\u00a0                                               const unsigned int fe_degree,\\n\\u00a0                                               const double penalty_jump_grad,\\n\\u00a0                                               const double penalty_jump_val)\\n\\u00a0     : n_refinements(n_refinements)\\n\\u00a0     , fe(fe_degree)\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0     , fe_lift(FE_DGQ<dim>(fe_degree), dim * dim)\\n\\u00a0     , penalty_jump_grad(penalty_jump_grad)\\n\\u00a0     , penalty_jump_val(penalty_jump_val)\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n BiLaplacianLDGLift::make_grid\\nTo build a mesh for \\\\(\\\\Omega=(0,1)^d\\\\), we simply call the function GridGenerator::hyper_cube and then refine it using refine_global. The number of refinements is hard-coded here.\\n\\u00a0   template <int dim>\\n\\u00a0   void BiLaplacianLDGLift<dim>::make_grid()\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"Building the mesh.............\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     GridGenerator::hyper_cube(triangulation, 0.0, 1.0);\\n\\u00a0 \\n\\u00a0     triangulation.refine_global(n_refinements);\\n\\u00a0 \\n\\u00a0     std::cout << \\\"Number of active cells: \\\" << triangulation.n_active_cells()\\n\\u00a0               << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nGridGenerator::hyper_cubevoid hyper_cube(Triangulation< dim, spacedim > &tria, const double left=0., const double right=1., const bool colorize=false)\\n BiLaplacianLDGLift::setup_system\\nIn the following function, we set up the degrees of freedom, the sparsity pattern, the size of the matrix \\\\(A\\\\), and the size of the solution and right-hand side vectors \\\\(\\\\boldsymbol{U}\\\\) and \\\\(\\\\boldsymbol{F}\\\\). For the sparsity pattern, we cannot directly use the function DoFTools::make_flux_sparsity_pattern (as we would do for instance for the SIPG method) because we need to take into account the interactions of a neighboring cell with another neighboring cell as described in the introduction. The extended sparsity pattern is built by iterating over all the active cells. For the current cell, we collect all its degrees of freedom as well as the degrees of freedom of all its neighboring cells, and then couple everything with everything.\\n\\u00a0   template <int dim>\\n\\u00a0   void BiLaplacianLDGLift<dim>::setup_system()\\n\\u00a0   {\\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0 \\n\\u00a0     std::cout << \\\"Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n\\u00a0               << std::endl;\\n\\u00a0 \\n\\u00a0     DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());\\n\\u00a0 \\n\\u00a0     const auto dofs_per_cell = fe.dofs_per_cell;\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         std::vector<types::global_dof_index> dofs(dofs_per_cell);\\n\\u00a0         cell->get_dof_indices(dofs);\\n\\u00a0 \\n\\u00a0         for (unsigned int f = 0; f < cell->n_faces(); ++f)\\n\\u00a0           if (!cell->face(f)->at_boundary())\\n\\u00a0             {\\n\\u00a0               const auto neighbor_cell = cell->neighbor(f);\\n\\u00a0 \\n\\u00a0               std::vector<types::global_dof_index> tmp(dofs_per_cell);\\n\\u00a0               neighbor_cell->get_dof_indices(tmp);\\n\\u00a0 \\n\\u00a0               dofs.insert(std::end(dofs), std::begin(tmp), std::end(tmp));\\n\\u00a0             }\\n\\u00a0 \\n\\u00a0         for (const auto i : dofs)\\n\\u00a0           for (const auto j : dofs)\\n\\u00a0             {\\n\\u00a0               dsp.add(i, j);\\n\\u00a0               dsp.add(j, i);\\n\\u00a0             }\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     sparsity_pattern.copy_from(dsp);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     matrix.reinit(sparsity_pattern);\\n\\u00a0     rhs.reinit(dof_handler.n_dofs());\\n\\u00a0 \\n\\u00a0     solution.reinit(dof_handler.n_dofs());\\n\\u00a0 \\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nLAPACKSupport::matrix@ matrixContents is actually a matrix.Definition lapack_support.h:57\\nstdSTL namespace.\\ntypesDefinition types.h:32\\nAt the end of the function, we output this sparsity pattern as a scalable vector graphic. You can visualize it by loading this file in most web browsers:\\n\\u00a0     std::ofstream out(\\\"sparsity-pattern.svg\\\");\\n\\u00a0     sparsity_pattern.print_svg(out);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n BiLaplacianLDGLift::assemble_system\\nThis function simply calls the two functions responsible for the assembly of the matrix and the right-hand side.\\n\\u00a0   template <int dim>\\n\\u00a0   void BiLaplacianLDGLift<dim>::assemble_system()\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"Assembling the system.............\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     assemble_matrix();\\n\\u00a0     assemble_rhs();\\n\\u00a0 \\n\\u00a0     std::cout << \\\"Done. \\\" << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n BiLaplacianLDGLift::assemble_matrix\\nThis function assembles the matrix \\\\(A\\\\) whose entries are defined by \\\\(A_{ij}=A_h(\\\\varphi_j,\\\\varphi_i)\\\\) which involves the product of discrete Hessians and the penalty terms.\\n\\u00a0   template <int dim>\\n\\u00a0   void BiLaplacianLDGLift<dim>::assemble_matrix()\\n\\u00a0   {\\n\\u00a0     matrix = 0;\\n\\u00a0 \\n\\u00a0     const QGauss<dim>     quad(fe.degree + 1);\\n\\u00a0     const QGauss<dim - 1> quad_face(fe.degree + 1);\\n\\u00a0 \\n\\u00a0     const unsigned int n_q_points      = quad.size();\\n\\u00a0     const unsigned int n_q_points_face = quad_face.size();\\n\\u00a0 \\n\\u00a0     FEValues<dim> fe_values(fe, quad, update_hessians | update_JxW_values);\\n\\u00a0 \\n\\u00a0     FEFaceValues<dim> fe_face(\\n\\u00a0       fe, quad_face, update_values | update_gradients | update_normal_vectors);\\n\\u00a0 \\n\\u00a0     FEFaceValues<dim> fe_face_neighbor(\\n\\u00a0       fe, quad_face, update_values | update_gradients | update_normal_vectors);\\n\\u00a0 \\n\\u00a0     const unsigned int n_dofs = fe_values.dofs_per_cell;\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(n_dofs);\\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices_neighbor(n_dofs);\\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices_neighbor_2(n_dofs);\\n\\u00a0 \\nFEFaceValuesDefinition fe_values.h:322\\nQGaussDefinition quadrature_lib.h:40\\nupdate_hessians@ update_hessiansSecond derivatives of shape functions.Definition fe_update_flags.h:87\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_normal_vectors@ update_normal_vectorsNormal vectors.Definition fe_update_flags.h:141\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nAs indicated in the introduction, the following matrices are used for the contributions of the products of the discrete Hessians.\\n\\u00a0     FullMatrix<double> stiffness_matrix_cc(n_dofs,\\n\\u00a0                                            n_dofs); // interactions cell / cell\\n\\u00a0     FullMatrix<double> stiffness_matrix_cn(\\n\\u00a0       n_dofs, n_dofs); // interactions cell / neighbor\\n\\u00a0     FullMatrix<double> stiffness_matrix_nc(\\n\\u00a0       n_dofs, n_dofs); // interactions neighbor / cell\\n\\u00a0     FullMatrix<double> stiffness_matrix_nn(\\n\\u00a0       n_dofs, n_dofs); // interactions neighbor / neighbor\\n\\u00a0     FullMatrix<double> stiffness_matrix_n1n2(\\n\\u00a0       n_dofs, n_dofs); // interactions neighbor1 / neighbor2\\n\\u00a0     FullMatrix<double> stiffness_matrix_n2n1(\\n\\u00a0       n_dofs, n_dofs); // interactions neighbor2 / neighbor1\\n\\u00a0 \\nThe following matrices are used for the contributions of the two penalty terms:\\n\\u00a0     FullMatrix<double> ip_matrix_cc(n_dofs, n_dofs); // interactions cell / cell\\n\\u00a0     FullMatrix<double> ip_matrix_cn(n_dofs,\\n\\u00a0                                     n_dofs); // interactions cell / neighbor\\n\\u00a0     FullMatrix<double> ip_matrix_nc(n_dofs,\\n\\u00a0                                     n_dofs); // interactions neighbor / cell\\n\\u00a0     FullMatrix<double> ip_matrix_nn(n_dofs,\\n\\u00a0                                     n_dofs); // interactions neighbor / neighbor\\n\\u00a0 \\n\\u00a0     std::vector<std::vector<Tensor<2, dim>>> discrete_hessians(\\n\\u00a0       n_dofs, std::vector<Tensor<2, dim>>(n_q_points));\\n\\u00a0     std::vector<std::vector<std::vector<Tensor<2, dim>>>>\\n\\u00a0       discrete_hessians_neigh(GeometryInfo<dim>::faces_per_cell,\\n\\u00a0                               discrete_hessians);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0 \\nGeometryInfoDefinition geometry_info.h:1964\\nWe now compute all the discrete Hessians that are not vanishing on the current cell, i.e., the discrete Hessian of all the basis functions with support on the current cell or on one of its neighbors.\\n\\u00a0         compute_discrete_hessians(cell,\\n\\u00a0                                   discrete_hessians,\\n\\u00a0                                   discrete_hessians_neigh);\\n\\u00a0 \\nFirst, we compute and add the interactions of the degrees of freedom of the current cell.\\n\\u00a0         stiffness_matrix_cc = 0;\\n\\u00a0         for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0           {\\n\\u00a0             const double dx = fe_values.JxW(q);\\n\\u00a0 \\n\\u00a0             for (unsigned int i = 0; i < n_dofs; ++i)\\n\\u00a0               for (unsigned int j = 0; j < n_dofs; ++j)\\n\\u00a0                 {\\n\\u00a0                   const Tensor<2, dim> &H_i = discrete_hessians[i][q];\\n\\u00a0                   const Tensor<2, dim> &H_j = discrete_hessians[j][q];\\n\\u00a0 \\n\\u00a0                   stiffness_matrix_cc(i, j) += scalar_product(H_j, H_i) * dx;\\n\\u00a0                 }\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         for (unsigned int i = 0; i < n_dofs; ++i)\\n\\u00a0           for (unsigned int j = 0; j < n_dofs; ++j)\\n\\u00a0             {\\n\\u00a0               matrix(local_dof_indices[i], local_dof_indices[j]) +=\\n\\u00a0                 stiffness_matrix_cc(i, j);\\n\\u00a0             }\\n\\u00a0 \\nNext, we compute and add the interactions of the degrees of freedom of the current cell with those of its neighbors. Note that the interactions of the degrees of freedom of a neighbor with those of the same neighbor are included here.\\n\\u00a0         for (unsigned int face_no = 0; face_no < cell->n_faces(); ++face_no)\\n\\u00a0           {\\n\\u00a0             const typename DoFHandler<dim>::face_iterator face =\\n\\u00a0               cell->face(face_no);\\n\\u00a0 \\n\\u00a0             const bool at_boundary = face->at_boundary();\\n\\u00a0             if (!at_boundary)\\n\\u00a0               {\\nDoFHandler::face_iteratortypename ActiveSelector::face_iterator face_iteratorDefinition dof_handler.h:486\\nThere is nothing to be done if boundary face (the liftings of the Dirichlet BCs are accounted for in the assembly of the RHS; in fact, nothing to be done in this program since we prescribe homogeneous BCs).\\n\\u00a0                 const typename DoFHandler<dim>::active_cell_iterator\\n\\u00a0                   neighbor_cell = cell->neighbor(face_no);\\n\\u00a0                 neighbor_cell->get_dof_indices(local_dof_indices_neighbor);\\n\\u00a0 \\n\\u00a0                 stiffness_matrix_cn = 0;\\n\\u00a0                 stiffness_matrix_nc = 0;\\n\\u00a0                 stiffness_matrix_nn = 0;\\n\\u00a0                 for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0                   {\\n\\u00a0                     const double dx = fe_values.JxW(q);\\n\\u00a0 \\n\\u00a0                     for (unsigned int i = 0; i < n_dofs; ++i)\\n\\u00a0                       {\\n\\u00a0                         for (unsigned int j = 0; j < n_dofs; ++j)\\n\\u00a0                           {\\n\\u00a0                             const Tensor<2, dim> &H_i = discrete_hessians[i][q];\\n\\u00a0                             const Tensor<2, dim> &H_j = discrete_hessians[j][q];\\n\\u00a0 \\n\\u00a0                             const Tensor<2, dim> &H_i_neigh =\\n\\u00a0                               discrete_hessians_neigh[face_no][i][q];\\n\\u00a0                             const Tensor<2, dim> &H_j_neigh =\\n\\u00a0                               discrete_hessians_neigh[face_no][j][q];\\n\\u00a0 \\n\\u00a0                             stiffness_matrix_cn(i, j) +=\\n\\u00a0                               scalar_product(H_j_neigh, H_i) * dx;\\n\\u00a0                             stiffness_matrix_nc(i, j) +=\\n\\u00a0                               scalar_product(H_j, H_i_neigh) * dx;\\n\\u00a0                             stiffness_matrix_nn(i, j) +=\\n\\u00a0                               scalar_product(H_j_neigh, H_i_neigh) * dx;\\n\\u00a0                           }\\n\\u00a0                       }\\n\\u00a0                   }\\n\\u00a0 \\n\\u00a0                 for (unsigned int i = 0; i < n_dofs; ++i)\\n\\u00a0                   {\\n\\u00a0                     for (unsigned int j = 0; j < n_dofs; ++j)\\n\\u00a0                       {\\n\\u00a0                         matrix(local_dof_indices[i],\\n\\u00a0                                local_dof_indices_neighbor[j]) +=\\n\\u00a0                           stiffness_matrix_cn(i, j);\\n\\u00a0                         matrix(local_dof_indices_neighbor[i],\\n\\u00a0                                local_dof_indices[j]) +=\\n\\u00a0                           stiffness_matrix_nc(i, j);\\n\\u00a0                         matrix(local_dof_indices_neighbor[i],\\n\\u00a0                                local_dof_indices_neighbor[j]) +=\\n\\u00a0                           stiffness_matrix_nn(i, j);\\n\\u00a0                       }\\n\\u00a0                   }\\n\\u00a0 \\n\\u00a0               } // boundary check\\n\\u00a0           }     // for face\\n\\u00a0 \\nWe now compute and add the interactions of the degrees of freedom of a neighboring cells with those of another neighboring cell (this is where we need the extended sparsity pattern).\\n\\u00a0         for (unsigned int face_no = 0; face_no < cell->n_faces() - 1; ++face_no)\\n\\u00a0           {\\n\\u00a0             const typename DoFHandler<dim>::face_iterator face =\\n\\u00a0               cell->face(face_no);\\n\\u00a0 \\n\\u00a0             const bool at_boundary = face->at_boundary();\\n\\u00a0             if (!at_boundary)\\n\\u00a0               { // nothing to be done if boundary face (the liftings of the\\nDirichlet BCs are accounted for in the assembly of the RHS; in fact, nothing to be done in this program since we prescribe homogeneous BCs)\\n\\u00a0                 for (unsigned int face_no_2 = face_no + 1;\\n\\u00a0                      face_no_2 < cell->n_faces();\\n\\u00a0                      ++face_no_2)\\n\\u00a0                   {\\n\\u00a0                     const typename DoFHandler<dim>::face_iterator face_2 =\\n\\u00a0                       cell->face(face_no_2);\\n\\u00a0 \\n\\u00a0                     const bool at_boundary_2 = face_2->at_boundary();\\n\\u00a0                     if (!at_boundary_2)\\n\\u00a0                       {\\n\\u00a0                         const typename DoFHandler<dim>::active_cell_iterator\\n\\u00a0                           neighbor_cell = cell->neighbor(face_no);\\n\\u00a0                         neighbor_cell->get_dof_indices(\\n\\u00a0                           local_dof_indices_neighbor);\\n\\u00a0                         const typename DoFHandler<dim>::active_cell_iterator\\n\\u00a0                           neighbor_cell_2 = cell->neighbor(face_no_2);\\n\\u00a0                         neighbor_cell_2->get_dof_indices(\\n\\u00a0                           local_dof_indices_neighbor_2);\\n\\u00a0 \\n\\u00a0                         stiffness_matrix_n1n2 = 0;\\n\\u00a0                         stiffness_matrix_n2n1 = 0;\\n\\u00a0 \\n\\u00a0                         for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0                           {\\n\\u00a0                             const double dx = fe_values.JxW(q);\\n\\u00a0 \\n\\u00a0                             for (unsigned int i = 0; i < n_dofs; ++i)\\n\\u00a0                               for (unsigned int j = 0; j < n_dofs; ++j)\\n\\u00a0                                 {\\n\\u00a0                                   const Tensor<2, dim> &H_i_neigh =\\n\\u00a0                                     discrete_hessians_neigh[face_no][i][q];\\n\\u00a0                                   const Tensor<2, dim> &H_j_neigh =\\n\\u00a0                                     discrete_hessians_neigh[face_no][j][q];\\n\\u00a0 \\n\\u00a0                                   const Tensor<2, dim> &H_i_neigh2 =\\n\\u00a0                                     discrete_hessians_neigh[face_no_2][i][q];\\n\\u00a0                                   const Tensor<2, dim> &H_j_neigh2 =\\n\\u00a0                                     discrete_hessians_neigh[face_no_2][j][q];\\n\\u00a0 \\n\\u00a0                                   stiffness_matrix_n1n2(i, j) +=\\n\\u00a0                                     scalar_product(H_j_neigh2, H_i_neigh) * dx;\\n\\u00a0                                   stiffness_matrix_n2n1(i, j) +=\\n\\u00a0                                     scalar_product(H_j_neigh, H_i_neigh2) * dx;\\n\\u00a0                                 }\\n\\u00a0                           }\\n\\u00a0 \\n\\u00a0                         for (unsigned int i = 0; i < n_dofs; ++i)\\n\\u00a0                           for (unsigned int j = 0; j < n_dofs; ++j)\\n\\u00a0                             {\\n\\u00a0                               matrix(local_dof_indices_neighbor[i],\\n\\u00a0                                      local_dof_indices_neighbor_2[j]) +=\\n\\u00a0                                 stiffness_matrix_n1n2(i, j);\\n\\u00a0                               matrix(local_dof_indices_neighbor_2[i],\\n\\u00a0                                      local_dof_indices_neighbor[j]) +=\\n\\u00a0                                 stiffness_matrix_n2n1(i, j);\\n\\u00a0                             }\\n\\u00a0                       } // boundary check face_2\\n\\u00a0                   }     // for face_2\\n\\u00a0               }         // boundary check face_1\\n\\u00a0           }             // for face_1\\n\\u00a0 \\n\\u00a0 \\nFinally, we compute and add the two penalty terms.\\n\\u00a0         for (unsigned int face_no = 0; face_no < cell->n_faces(); ++face_no)\\n\\u00a0           {\\n\\u00a0             const typename DoFHandler<dim>::face_iterator face =\\n\\u00a0               cell->face(face_no);\\n\\u00a0 \\n\\u00a0             const double mesh_inv = 1.0 / face->diameter(); // h_e^{-1}\\n\\u00a0             const double mesh3_inv =\\n\\u00a0               1.0 / Utilities::fixed_power<3>(face->diameter()); // h_e^{-3}\\n\\u00a0 \\n\\u00a0             fe_face.reinit(cell, face_no);\\n\\u00a0 \\n\\u00a0             ip_matrix_cc = 0; // filled in any case (boundary or interior face)\\n\\u00a0 \\n\\u00a0             const bool at_boundary = face->at_boundary();\\n\\u00a0             if (at_boundary)\\n\\u00a0               {\\n\\u00a0                 for (unsigned int q = 0; q < n_q_points_face; ++q)\\n\\u00a0                   {\\n\\u00a0                     const double dx = fe_face.JxW(q);\\n\\u00a0 \\n\\u00a0                     for (unsigned int i = 0; i < n_dofs; ++i)\\n\\u00a0                       for (unsigned int j = 0; j < n_dofs; ++j)\\n\\u00a0                         {\\n\\u00a0                           ip_matrix_cc(i, j) += penalty_jump_grad * mesh_inv *\\n\\u00a0                                                 fe_face.shape_grad(j, q) *\\n\\u00a0                                                 fe_face.shape_grad(i, q) * dx;\\n\\u00a0                           ip_matrix_cc(i, j) += penalty_jump_val * mesh3_inv *\\n\\u00a0                                                 fe_face.shape_value(j, q) *\\n\\u00a0                                                 fe_face.shape_value(i, q) * dx;\\n\\u00a0                         }\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0             else\\n\\u00a0               { // interior face\\n\\u00a0 \\n\\u00a0                 const typename DoFHandler<dim>::active_cell_iterator\\n\\u00a0                                    neighbor_cell = cell->neighbor(face_no);\\n\\u00a0                 const unsigned int face_no_neighbor =\\n\\u00a0                   cell->neighbor_of_neighbor(face_no);\\n\\u00a0 \\nIn the next step, we need to have a global way to compare the cells in order to not calculate the same jump term twice:\\n\\u00a0                 if (neighbor_cell->id() < cell->id())\\n\\u00a0                   continue; // skip this face (already considered)\\n\\u00a0                 else\\n\\u00a0                   {\\n\\u00a0                     fe_face_neighbor.reinit(neighbor_cell, face_no_neighbor);\\n\\u00a0                     neighbor_cell->get_dof_indices(local_dof_indices_neighbor);\\n\\u00a0 \\n\\u00a0                     ip_matrix_cn = 0;\\n\\u00a0                     ip_matrix_nc = 0;\\n\\u00a0                     ip_matrix_nn = 0;\\n\\u00a0 \\n\\u00a0                     for (unsigned int q = 0; q < n_q_points_face; ++q)\\n\\u00a0                       {\\n\\u00a0                         const double dx = fe_face.JxW(q);\\n\\u00a0 \\n\\u00a0                         for (unsigned int i = 0; i < n_dofs; ++i)\\n\\u00a0                           {\\n\\u00a0                             for (unsigned int j = 0; j < n_dofs; ++j)\\n\\u00a0                               {\\n\\u00a0                                 ip_matrix_cc(i, j) +=\\n\\u00a0                                   penalty_jump_grad * mesh_inv *\\n\\u00a0                                   fe_face.shape_grad(j, q) *\\n\\u00a0                                   fe_face.shape_grad(i, q) * dx;\\n\\u00a0                                 ip_matrix_cc(i, j) +=\\n\\u00a0                                   penalty_jump_val * mesh3_inv *\\n\\u00a0                                   fe_face.shape_value(j, q) *\\n\\u00a0                                   fe_face.shape_value(i, q) * dx;\\n\\u00a0 \\n\\u00a0                                 ip_matrix_cn(i, j) -=\\n\\u00a0                                   penalty_jump_grad * mesh_inv *\\n\\u00a0                                   fe_face_neighbor.shape_grad(j, q) *\\n\\u00a0                                   fe_face.shape_grad(i, q) * dx;\\n\\u00a0                                 ip_matrix_cn(i, j) -=\\n\\u00a0                                   penalty_jump_val * mesh3_inv *\\n\\u00a0                                   fe_face_neighbor.shape_value(j, q) *\\n\\u00a0                                   fe_face.shape_value(i, q) * dx;\\n\\u00a0 \\n\\u00a0                                 ip_matrix_nc(i, j) -=\\n\\u00a0                                   penalty_jump_grad * mesh_inv *\\n\\u00a0                                   fe_face.shape_grad(j, q) *\\n\\u00a0                                   fe_face_neighbor.shape_grad(i, q) * dx;\\n\\u00a0                                 ip_matrix_nc(i, j) -=\\n\\u00a0                                   penalty_jump_val * mesh3_inv *\\n\\u00a0                                   fe_face.shape_value(j, q) *\\n\\u00a0                                   fe_face_neighbor.shape_value(i, q) * dx;\\n\\u00a0 \\n\\u00a0                                 ip_matrix_nn(i, j) +=\\n\\u00a0                                   penalty_jump_grad * mesh_inv *\\n\\u00a0                                   fe_face_neighbor.shape_grad(j, q) *\\n\\u00a0                                   fe_face_neighbor.shape_grad(i, q) * dx;\\n\\u00a0                                 ip_matrix_nn(i, j) +=\\n\\u00a0                                   penalty_jump_val * mesh3_inv *\\n\\u00a0                                   fe_face_neighbor.shape_value(j, q) *\\n\\u00a0                                   fe_face_neighbor.shape_value(i, q) * dx;\\n\\u00a0                               }\\n\\u00a0                           }\\n\\u00a0                       }\\n\\u00a0                   } // face not visited yet\\n\\u00a0 \\n\\u00a0               } // boundary check\\n\\u00a0 \\n\\u00a0             for (unsigned int i = 0; i < n_dofs; ++i)\\n\\u00a0               {\\n\\u00a0                 for (unsigned int j = 0; j < n_dofs; ++j)\\n\\u00a0                   {\\n\\u00a0                     matrix(local_dof_indices[i], local_dof_indices[j]) +=\\n\\u00a0                       ip_matrix_cc(i, j);\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0             if (!at_boundary)\\n\\u00a0               {\\n\\u00a0                 for (unsigned int i = 0; i < n_dofs; ++i)\\n\\u00a0                   {\\n\\u00a0                     for (unsigned int j = 0; j < n_dofs; ++j)\\n\\u00a0                       {\\n\\u00a0                         matrix(local_dof_indices[i],\\n\\u00a0                                local_dof_indices_neighbor[j]) +=\\n\\u00a0                           ip_matrix_cn(i, j);\\n\\u00a0                         matrix(local_dof_indices_neighbor[i],\\n\\u00a0                                local_dof_indices[j]) += ip_matrix_nc(i, j);\\n\\u00a0                         matrix(local_dof_indices_neighbor[i],\\n\\u00a0                                local_dof_indices_neighbor[j]) +=\\n\\u00a0                           ip_matrix_nn(i, j);\\n\\u00a0                       }\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0           } // for face\\n\\u00a0       }     // for cell\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n BiLaplacianLDGLift::assemble_rhs\\nThis function assemble the right-hand side of the system. Since we consider homogeneous Dirichlet boundary conditions, imposed weakly in the bilinear form using the Nitsche approach, it only involves the contribution of the forcing term \\\\(\\\\int_{\\\\Omega}fv_h\\\\).\\n\\u00a0   template <int dim>\\n\\u00a0   void BiLaplacianLDGLift<dim>::assemble_rhs()\\n\\u00a0   {\\n\\u00a0     rhs = 0;\\n\\u00a0 \\n\\u00a0     const QGauss<dim> quad(fe.degree + 1);\\n\\u00a0     FEValues<dim>     fe_values(\\n\\u00a0       fe, quad, update_values | update_quadrature_points | update_JxW_values);\\n\\u00a0 \\n\\u00a0     const unsigned int n_dofs     = fe_values.dofs_per_cell;\\n\\u00a0     const unsigned int n_quad_pts = quad.size();\\n\\u00a0 \\n\\u00a0     const RightHandSide<dim> right_hand_side;\\n\\u00a0 \\n\\u00a0     Vector<double>                       local_rhs(n_dofs);\\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(n_dofs);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0 \\n\\u00a0         local_rhs = 0;\\n\\u00a0         for (unsigned int q = 0; q < n_quad_pts; ++q)\\n\\u00a0           {\\n\\u00a0             const double dx = fe_values.JxW(q);\\n\\u00a0 \\n\\u00a0             for (unsigned int i = 0; i < n_dofs; ++i)\\n\\u00a0               {\\n\\u00a0                 local_rhs(i) +=\\n\\u00a0                   right_hand_side.value(fe_values.quadrature_point(q)) *\\n\\u00a0                   fe_values.shape_value(i, q) * dx;\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         for (unsigned int i = 0; i < n_dofs; ++i)\\n\\u00a0           rhs(local_dof_indices[i]) += local_rhs(i);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\n BiLaplacianLDGLift::solve\\nTo solve the linear system \\\\(A\\\\boldsymbol{U}=\\\\boldsymbol{F}\\\\), we proceed as in step-74 and use a direct method. We could as well use an iterative method, for instance the conjugate gradient method as in step-3.\\n\\u00a0   template <int dim>\\n\\u00a0   void BiLaplacianLDGLift<dim>::solve()\\n\\u00a0   {\\n\\u00a0     SparseDirectUMFPACK A_direct;\\n\\u00a0     A_direct.initialize(matrix);\\n\\u00a0     A_direct.vmult(solution, rhs);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nSparseDirectUMFPACKDefinition sparse_direct.h:92\\nSparseDirectUMFPACK::initializevoid initialize(const SparsityPattern &sparsity_pattern)Definition sparse_direct.cc:67\\n BiLaplacianLDGLift::compute_errors\\nThis function computes the discrete \\\\(H^2\\\\), \\\\(H^1\\\\) and \\\\(L^2\\\\) norms of the error \\\\(u-u_h\\\\), where \\\\(u\\\\) is the exact solution and \\\\(u_h\\\\) is the approximate solution. See the introduction for the definition of the norms.\\n\\u00a0   template <int dim>\\n\\u00a0   void BiLaplacianLDGLift<dim>::compute_errors()\\n\\u00a0   {\\n\\u00a0     double error_H2 = 0;\\n\\u00a0     double error_H1 = 0;\\n\\u00a0     double error_L2 = 0;\\n\\u00a0 \\n\\u00a0     const QGauss<dim>     quad(fe.degree + 1);\\n\\u00a0     const QGauss<dim - 1> quad_face(fe.degree + 1);\\n\\u00a0 \\n\\u00a0     FEValues<dim> fe_values(fe,\\n\\u00a0                             quad,\\n\\u00a0                             update_values | update_gradients | update_hessians |\\n\\u00a0                               update_quadrature_points | update_JxW_values);\\n\\u00a0 \\n\\u00a0     FEFaceValues<dim> fe_face(fe,\\n\\u00a0                               quad_face,\\n\\u00a0                               update_values | update_gradients |\\n\\u00a0                                 update_quadrature_points | update_JxW_values);\\n\\u00a0 \\n\\u00a0     FEFaceValues<dim> fe_face_neighbor(fe,\\n\\u00a0                                        quad_face,\\n\\u00a0                                        update_values | update_gradients);\\n\\u00a0 \\n\\u00a0     const unsigned int n_q_points      = quad.size();\\n\\u00a0     const unsigned int n_q_points_face = quad_face.size();\\n\\u00a0 \\nWe introduce some variables for the exact solution...\\n\\u00a0     const ExactSolution<dim> u_exact;\\n\\u00a0 \\n...and for the approximate solution:\\n\\u00a0     std::vector<double>         solution_values_cell(n_q_points);\\n\\u00a0     std::vector<Tensor<1, dim>> solution_gradients_cell(n_q_points);\\n\\u00a0     std::vector<Tensor<2, dim>> solution_hessians_cell(n_q_points);\\n\\u00a0 \\n\\u00a0     std::vector<double>         solution_values(n_q_points_face);\\n\\u00a0     std::vector<double>         solution_values_neigh(n_q_points_face);\\n\\u00a0     std::vector<Tensor<1, dim>> solution_gradients(n_q_points_face);\\n\\u00a0     std::vector<Tensor<1, dim>> solution_gradients_neigh(n_q_points_face);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0         fe_values.get_function_values(solution, solution_values_cell);\\n\\u00a0         fe_values.get_function_gradients(solution, solution_gradients_cell);\\n\\u00a0         fe_values.get_function_hessians(solution, solution_hessians_cell);\\n\\u00a0 \\nWe first add the bulk terms.\\n\\u00a0         for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0           {\\n\\u00a0             const double dx = fe_values.JxW(q);\\n\\u00a0 \\n\\u00a0             error_H2 += (u_exact.hessian(fe_values.quadrature_point(q)) -\\n\\u00a0                          solution_hessians_cell[q])\\n\\u00a0                           .norm_square() *\\n\\u00a0                         dx;\\n\\u00a0             error_H1 += (u_exact.gradient(fe_values.quadrature_point(q)) -\\n\\u00a0                          solution_gradients_cell[q])\\n\\u00a0                           .norm_square() *\\n\\u00a0                         dx;\\n\\u00a0             error_L2 += Utilities::fixed_power<2>(\\n\\u00a0                           u_exact.value(fe_values.quadrature_point(q)) -\\n\\u00a0                           solution_values_cell[q]) *\\n\\u00a0                         dx;\\n\\u00a0           } // for quadrature points\\n\\u00a0 \\nWe then add the face contributions.\\n\\u00a0         for (unsigned int face_no = 0; face_no < cell->n_faces(); ++face_no)\\n\\u00a0           {\\n\\u00a0             const typename DoFHandler<dim>::face_iterator face =\\n\\u00a0               cell->face(face_no);\\n\\u00a0 \\n\\u00a0             const double mesh_inv = 1.0 / face->diameter(); // h^{-1}\\n\\u00a0             const double mesh3_inv =\\n\\u00a0               1.0 / Utilities::fixed_power<3>(face->diameter()); // h^{-3}\\n\\u00a0 \\n\\u00a0             fe_face.reinit(cell, face_no);\\n\\u00a0 \\n\\u00a0             fe_face.get_function_values(solution, solution_values);\\n\\u00a0             fe_face.get_function_gradients(solution, solution_gradients);\\n\\u00a0 \\n\\u00a0             const bool at_boundary = face->at_boundary();\\n\\u00a0             if (at_boundary)\\n\\u00a0               {\\n\\u00a0                 for (unsigned int q = 0; q < n_q_points_face; ++q)\\n\\u00a0                   {\\n\\u00a0                     const double dx = fe_face.JxW(q);\\n\\u00a0                     const double u_exact_q =\\n\\u00a0                       u_exact.value(fe_face.quadrature_point(q));\\n\\u00a0                     const Tensor<1, dim> u_exact_grad_q =\\n\\u00a0                       u_exact.gradient(fe_face.quadrature_point(q));\\n\\u00a0 \\n\\u00a0                     error_H2 +=\\n\\u00a0                       mesh_inv *\\n\\u00a0                       (u_exact_grad_q - solution_gradients[q]).norm_square() *\\n\\u00a0                       dx;\\n\\u00a0                     error_H2 += mesh3_inv *\\n\\u00a0                                 Utilities::fixed_power<2>(u_exact_q -\\n\\u00a0                                                           solution_values[q]) *\\n\\u00a0                                 dx;\\n\\u00a0                     error_H1 += mesh_inv *\\n\\u00a0                                 Utilities::fixed_power<2>(u_exact_q -\\n\\u00a0                                                           solution_values[q]) *\\n\\u00a0                                 dx;\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0             else\\n\\u00a0               { // interior face\\n\\u00a0 \\n\\u00a0                 const typename DoFHandler<dim>::active_cell_iterator\\n\\u00a0                                    neighbor_cell = cell->neighbor(face_no);\\n\\u00a0                 const unsigned int face_no_neighbor =\\n\\u00a0                   cell->neighbor_of_neighbor(face_no);\\n\\u00a0 \\nTensor::norm_squareconstexpr numbers::NumberTraits< Number >::real_type norm_square() const\\nIn the next step, we need to have a global way to compare the cells in order to not calculate the same jump term twice:\\n\\u00a0                 if (neighbor_cell->id() < cell->id())\\n\\u00a0                   continue; // skip this face (already considered)\\n\\u00a0                 else\\n\\u00a0                   {\\n\\u00a0                     fe_face_neighbor.reinit(neighbor_cell, face_no_neighbor);\\n\\u00a0 \\n\\u00a0                     fe_face.get_function_values(solution, solution_values);\\n\\u00a0                     fe_face_neighbor.get_function_values(solution,\\n\\u00a0                                                          solution_values_neigh);\\n\\u00a0                     fe_face.get_function_gradients(solution,\\n\\u00a0                                                    solution_gradients);\\n\\u00a0                     fe_face_neighbor.get_function_gradients(\\n\\u00a0                       solution, solution_gradients_neigh);\\n\\u00a0 \\n\\u00a0                     for (unsigned int q = 0; q < n_q_points_face; ++q)\\n\\u00a0                       {\\n\\u00a0                         const double dx = fe_face.JxW(q);\\n\\u00a0 \\nTo compute the jump term, we use the fact that \\\\(\\\\jump{u}=0\\\\) and \\\\(\\\\jump{\\\\nabla u}=\\\\mathbf{0}\\\\) since  \\\\(u\\\\in\\n   H^2(\\\\Omega)\\\\).\\n\\u00a0                         error_H2 +=\\n\\u00a0                           mesh_inv *\\n\\u00a0                           (solution_gradients_neigh[q] - solution_gradients[q])\\n\\u00a0                             .norm_square() *\\n\\u00a0                           dx;\\n\\u00a0                         error_H2 +=\\n\\u00a0                           mesh3_inv *\\n\\u00a0                           Utilities::fixed_power<2>(solution_values_neigh[q] -\\n\\u00a0                                                     solution_values[q]) *\\n\\u00a0                           dx;\\n\\u00a0                         error_H1 +=\\n\\u00a0                           mesh_inv *\\n\\u00a0                           Utilities::fixed_power<2>(solution_values_neigh[q] -\\n\\u00a0                                                     solution_values[q]) *\\n\\u00a0                           dx;\\n\\u00a0                       }\\n\\u00a0                   } // face not visited yet\\n\\u00a0 \\n\\u00a0               } // boundary check\\n\\u00a0 \\n\\u00a0           } // for face\\n\\u00a0 \\n\\u00a0       } // for cell\\n\\u00a0 \\n\\u00a0     error_H2 = std::sqrt(error_H2);\\n\\u00a0     error_H1 = std::sqrt(error_H1);\\n\\u00a0     error_L2 = std::sqrt(error_L2);\\n\\u00a0 \\n\\u00a0     std::cout << \\\"DG H2 norm of the error: \\\" << error_H2 << std::endl;\\n\\u00a0     std::cout << \\\"DG H1 norm of the error: \\\" << error_H1 << std::endl;\\n\\u00a0     std::cout << \\\"   L2 norm of the error: \\\" << error_L2 << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nstd::sqrt::VectorizedArray< Number, width > sqrt(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6869\\n BiLaplacianLDGLift::output_results\\nThis function, which writes the solution to a vtk file, is copied from step-3.\\n\\u00a0   template <int dim>\\n\\u00a0   void BiLaplacianLDGLift<dim>::output_results() const\\n\\u00a0   {\\n\\u00a0     DataOut<dim> data_out;\\n\\u00a0     data_out.attach_dof_handler(dof_handler);\\n\\u00a0     data_out.add_data_vector(solution, \\\"solution\\\");\\n\\u00a0     data_out.build_patches();\\n\\u00a0 \\n\\u00a0     std::ofstream output(\\\"solution.vtk\\\");\\n\\u00a0     data_out.write_vtk(output);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\n BiLaplacianLDGLift::assemble_local_matrix\\nAs already mentioned above, this function is used to assemble the (local) mass matrices needed for the computations of the lifting terms. We reiterate that only the basis functions with support on the current cell are considered.\\n\\u00a0   template <int dim>\\n\\u00a0   void BiLaplacianLDGLift<dim>::assemble_local_matrix(\\n\\u00a0     const FEValues<dim> &fe_values_lift,\\n\\u00a0     const unsigned int   n_q_points,\\n\\u00a0     FullMatrix<double>  &local_matrix)\\n\\u00a0   {\\n\\u00a0     const FEValuesExtractors::Tensor<2> tau_ext(0);\\n\\u00a0 \\n\\u00a0     const unsigned int n_dofs = fe_values_lift.dofs_per_cell;\\n\\u00a0 \\n\\u00a0     local_matrix = 0;\\n\\u00a0     for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0       {\\n\\u00a0         const double dx = fe_values_lift.JxW(q);\\n\\u00a0 \\n\\u00a0         for (unsigned int m = 0; m < n_dofs; ++m)\\n\\u00a0           for (unsigned int n = 0; n < n_dofs; ++n)\\n\\u00a0             {\\n\\u00a0               local_matrix(m, n) +=\\n\\u00a0                 scalar_product(fe_values_lift[tau_ext].value(n, q),\\n\\u00a0                                fe_values_lift[tau_ext].value(m, q)) *\\n\\u00a0                 dx;\\n\\u00a0             }\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFEValuesExtractors::TensorDefinition fe_values_extractors.h:244\\n BiLaplacianLDGLift::compute_discrete_hessians\\nThis function is the main novelty of this program. It computes the discrete Hessian \\\\(H_h(\\\\varphi)\\\\) for all the basis functions \\\\(\\\\varphi\\\\) of \\\\(\\\\mathbb{V}_h\\\\) supported on the current cell and those supported on a neighboring cell. The first argument indicates the current cell (referring to the global DoFHandler object), while the other two arguments are output variables that are filled by this function.\\nIn the following, we need to evaluate finite element shape functions for the fe_lift finite element on the current cell. Like for example in step-61, this \\\"lift\\\" space is defined on every cell individually; as a consequence, there is no global DoFHandler associated with this because we simply have no need for such a DoFHandler. That leaves the question of what we should initialize the FEValues and FEFaceValues objects with when we ask them to evaluate shape functions of fe_lift on a concrete cell. If we simply provide the first argument to this function, cell, to FEValues::reinit(), we will receive an error message that the given cell belongs to a DoFHandler that has a different finite element associated with it than the fe_lift object we want to evaluate. Fortunately, there is a relatively easy solution: We can call FEValues::reinit() with a cell that points into a triangulation \\u2013 the same cell, but not associated with a DoFHandler, and consequently no finite element space. In that case, FEValues::reinit() will skip the check that would otherwise lead to an error message. All we have to do is to convert the DoFHandler cell iterator into a Triangulation cell iterator; see the first couple of lines of the function below to see how this can be done.\\n\\u00a0   template <int dim>\\n\\u00a0   void BiLaplacianLDGLift<dim>::compute_discrete_hessians(\\n\\u00a0     const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0     std::vector<std::vector<Tensor<2, dim>>>             &discrete_hessians,\\n\\u00a0     std::vector<std::vector<std::vector<Tensor<2, dim>>>>\\n\\u00a0       &discrete_hessians_neigh)\\n\\u00a0   {\\n\\u00a0     const typename Triangulation<dim>::cell_iterator cell_lift =\\n\\u00a0       static_cast<typename Triangulation<dim>::cell_iterator>(cell);\\n\\u00a0 \\n\\u00a0     const QGauss<dim>     quad(fe.degree + 1);\\n\\u00a0     const QGauss<dim - 1> quad_face(fe.degree + 1);\\n\\u00a0 \\n\\u00a0     const unsigned int n_q_points      = quad.size();\\n\\u00a0     const unsigned int n_q_points_face = quad_face.size();\\n\\u00a0 \\nTriaIteratorDefinition tria_iterator.h:574\\nThe information we need from the basis functions of \\\\(\\\\mathbb{V}_h\\\\): fe_values is needed to add the broken Hessian part of the discrete Hessian, while fe_face and fe_face_neighbor are used to compute the right-hand sides for the local problems.\\n\\u00a0     FEValues<dim> fe_values(fe, quad, update_hessians | update_JxW_values);\\n\\u00a0 \\n\\u00a0     FEFaceValues<dim> fe_face(\\n\\u00a0       fe, quad_face, update_values | update_gradients | update_normal_vectors);\\n\\u00a0 \\n\\u00a0     FEFaceValues<dim> fe_face_neighbor(\\n\\u00a0       fe, quad_face, update_values | update_gradients | update_normal_vectors);\\n\\u00a0 \\n\\u00a0     const unsigned int n_dofs = fe_values.dofs_per_cell;\\n\\u00a0 \\nThe information needed from the basis functions of the finite element space for the lifting terms: fe_values_lift is used for the (local) mass matrix (see \\\\(\\\\boldsymbol{M}_c\\\\) in the introduction), while fe_face_lift is used to compute the right-hand sides (see \\\\(\\\\boldsymbol{G}_c\\\\) for \\\\(b_e\\\\)).\\n\\u00a0     FEValues<dim> fe_values_lift(fe_lift,\\n\\u00a0                                  quad,\\n\\u00a0                                  update_values | update_JxW_values);\\n\\u00a0 \\n\\u00a0     FEFaceValues<dim> fe_face_lift(\\n\\u00a0       fe_lift, quad_face, update_values | update_gradients | update_JxW_values);\\n\\u00a0 \\n\\u00a0     const FEValuesExtractors::Tensor<2> tau_ext(0);\\n\\u00a0 \\n\\u00a0     const unsigned int n_dofs_lift = fe_values_lift.dofs_per_cell;\\n\\u00a0     FullMatrix<double> local_matrix_lift(n_dofs_lift, n_dofs_lift);\\n\\u00a0 \\n\\u00a0     Vector<double> local_rhs_re(n_dofs_lift), local_rhs_be(n_dofs_lift),\\n\\u00a0       coeffs_re(n_dofs_lift), coeffs_be(n_dofs_lift), coeffs_tmp(n_dofs_lift);\\n\\u00a0 \\n\\u00a0     SolverControl            solver_control(1000, 1e-12);\\n\\u00a0     SolverCG<Vector<double>> solver(solver_control);\\n\\u00a0 \\n\\u00a0     double factor_avg; // 0.5 for interior faces, 1.0 for boundary faces\\n\\u00a0 \\n\\u00a0     fe_values.reinit(cell);\\n\\u00a0     fe_values_lift.reinit(cell_lift);\\n\\u00a0 \\nSolverCGDefinition solver_cg.h:179\\nSolverControlDefinition solver_control.h:67\\nWe start by assembling the (local) mass matrix used for the computation of the lifting terms \\\\(r_e\\\\) and \\\\(b_e\\\\).\\n\\u00a0     assemble_local_matrix(fe_values_lift, n_q_points, local_matrix_lift);\\n\\u00a0 \\n\\u00a0     for (unsigned int i = 0; i < n_dofs; ++i)\\n\\u00a0       for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0         {\\n\\u00a0           discrete_hessians[i][q] = 0;\\n\\u00a0 \\n\\u00a0           for (unsigned int face_no = 0;\\n\\u00a0                face_no < discrete_hessians_neigh.size();\\n\\u00a0                ++face_no)\\n\\u00a0             {\\n\\u00a0               discrete_hessians_neigh[face_no][i][q] = 0;\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0 \\nIn this loop, we compute the discrete Hessian at each quadrature point \\\\(x_q\\\\) of cell for each basis function supported on cell, namely we fill-in the variable discrete_hessians[i][q]. For the lifting terms, we need to add the contribution of all the faces of cell.\\n\\u00a0     for (unsigned int i = 0; i < n_dofs; ++i)\\n\\u00a0       {\\n\\u00a0         coeffs_re = 0;\\n\\u00a0         coeffs_be = 0;\\n\\u00a0 \\n\\u00a0         for (unsigned int face_no = 0; face_no < cell->n_faces(); ++face_no)\\n\\u00a0           {\\n\\u00a0             const typename DoFHandler<dim>::face_iterator face =\\n\\u00a0               cell->face(face_no);\\n\\u00a0 \\n\\u00a0             const bool at_boundary = face->at_boundary();\\n\\u00a0 \\nRecall that by convention, the average of a function across a boundary face \\\\(e\\\\) reduces to the trace of the function on the only element adjacent to \\\\(e\\\\), namely there is no factor \\\\(\\\\frac{1}{2}\\\\). We distinguish between the two cases (the current face lies in the interior or on the boundary of the domain) using the variable factor_avg.\\n\\u00a0             factor_avg = 0.5;\\n\\u00a0             if (at_boundary)\\n\\u00a0               {\\n\\u00a0                 factor_avg = 1.0;\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0             fe_face.reinit(cell, face_no);\\n\\u00a0             fe_face_lift.reinit(cell_lift, face_no);\\n\\u00a0 \\n\\u00a0             local_rhs_re = 0;\\n\\u00a0             for (unsigned int q = 0; q < n_q_points_face; ++q)\\n\\u00a0               {\\n\\u00a0                 const double         dx     = fe_face_lift.JxW(q);\\n\\u00a0                 const Tensor<1, dim> normal = fe_face.normal_vector(\\n\\u00a0                   q); // same as fe_face_lift.normal_vector(q)\\n\\u00a0 \\n\\u00a0                 for (unsigned int m = 0; m < n_dofs_lift; ++m)\\n\\u00a0                   {\\n\\u00a0                     local_rhs_re(m) +=\\n\\u00a0                       factor_avg *\\n\\u00a0                       (fe_face_lift[tau_ext].value(m, q) * normal) *\\n\\u00a0                       fe_face.shape_grad(i, q) * dx;\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0 \\nHere, local_rhs_be(m) corresponds to \\\\(G_m\\\\) introduced in the comments about the implementation of the lifting \\\\(b_e\\\\) in the case \\\\(\\\\varphi=\\\\varphi^c\\\\).\\n\\u00a0             local_rhs_be = 0;\\n\\u00a0             for (unsigned int q = 0; q < n_q_points_face; ++q)\\n\\u00a0               {\\n\\u00a0                 const double         dx     = fe_face_lift.JxW(q);\\n\\u00a0                 const Tensor<1, dim> normal = fe_face.normal_vector(\\n\\u00a0                   q); // same as fe_face_lift.normal_vector(q)\\n\\u00a0 \\n\\u00a0                 for (unsigned int m = 0; m < n_dofs_lift; ++m)\\n\\u00a0                   {\\n\\u00a0                     local_rhs_be(m) += factor_avg *\\n\\u00a0                                        fe_face_lift[tau_ext].divergence(m, q) *\\n\\u00a0                                        normal * fe_face.shape_value(i, q) * dx;\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0             coeffs_tmp = 0;\\n\\u00a0             solver.solve(local_matrix_lift,\\n\\u00a0                          coeffs_tmp,\\n\\u00a0                          local_rhs_re,\\n\\u00a0                          PreconditionIdentity());\\n\\u00a0             coeffs_re += coeffs_tmp;\\n\\u00a0 \\n\\u00a0             coeffs_tmp = 0;\\n\\u00a0             solver.solve(local_matrix_lift,\\n\\u00a0                          coeffs_tmp,\\n\\u00a0                          local_rhs_be,\\n\\u00a0                          PreconditionIdentity());\\n\\u00a0             coeffs_be += coeffs_tmp;\\n\\u00a0 \\n\\u00a0           } // for face\\n\\u00a0 \\n\\u00a0         for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0           {\\n\\u00a0             discrete_hessians[i][q] += fe_values.shape_hessian(i, q);\\n\\u00a0 \\n\\u00a0             for (unsigned int m = 0; m < n_dofs_lift; ++m)\\n\\u00a0               {\\n\\u00a0                 discrete_hessians[i][q] -=\\n\\u00a0                   coeffs_re[m] * fe_values_lift[tau_ext].value(m, q);\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0             for (unsigned int m = 0; m < n_dofs_lift; ++m)\\n\\u00a0               {\\n\\u00a0                 discrete_hessians[i][q] +=\\n\\u00a0                   coeffs_be[m] * fe_values_lift[tau_ext].value(m, q);\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0       } // for dof i\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nPreconditionIdentityDefinition precondition.h:220\\nIn this loop, we compute the discrete Hessian at each quadrature point \\\\(x_q\\\\) of cell for each basis function supported on a neighboring neighbor_cell of cell, namely we fill-in the variable discrete_hessians_neigh[face_no][i][q]. For the lifting terms, we only need to add the contribution of the face adjacent to cell and neighbor_cell.\\n\\u00a0     for (unsigned int face_no = 0; face_no < cell->n_faces(); ++face_no)\\n\\u00a0       {\\n\\u00a0         const typename DoFHandler<dim>::face_iterator face =\\n\\u00a0           cell->face(face_no);\\n\\u00a0 \\n\\u00a0         const bool at_boundary = face->at_boundary();\\n\\u00a0 \\n\\u00a0         if (!at_boundary)\\n\\u00a0           {\\nFor non-homogeneous Dirichlet BCs, we would need to compute the lifting of the prescribed BC (see the \\\"Possible Extensions\\\" section for more details).\\n\\u00a0             const typename DoFHandler<2, dim>::active_cell_iterator\\n\\u00a0                                neighbor_cell = cell->neighbor(face_no);\\n\\u00a0             const unsigned int face_no_neighbor =\\n\\u00a0               cell->neighbor_of_neighbor(face_no);\\n\\u00a0             fe_face_neighbor.reinit(neighbor_cell, face_no_neighbor);\\n\\u00a0 \\n\\u00a0             for (unsigned int i = 0; i < n_dofs; ++i)\\n\\u00a0               {\\n\\u00a0                 coeffs_re = 0;\\n\\u00a0                 coeffs_be = 0;\\n\\u00a0 \\n\\u00a0                 fe_face_lift.reinit(cell_lift, face_no);\\n\\u00a0 \\n\\u00a0                 local_rhs_re = 0;\\n\\u00a0                 for (unsigned int q = 0; q < n_q_points_face; ++q)\\n\\u00a0                   {\\n\\u00a0                     const double         dx = fe_face_lift.JxW(q);\\n\\u00a0                     const Tensor<1, dim> normal =\\n\\u00a0                       fe_face_neighbor.normal_vector(q);\\n\\u00a0 \\n\\u00a0                     for (unsigned int m = 0; m < n_dofs_lift; ++m)\\n\\u00a0                       {\\n\\u00a0                         local_rhs_re(m) +=\\n\\u00a0                           0.5 * (fe_face_lift[tau_ext].value(m, q) * normal) *\\n\\u00a0                           fe_face_neighbor.shape_grad(i, q) * dx;\\n\\u00a0                       }\\n\\u00a0                   }\\n\\u00a0 \\nHere, local_rhs_be(m) corresponds to \\\\(G_m\\\\) introduced in the comments about the implementation of the lifting \\\\(b_e\\\\) in the case \\\\(\\\\varphi=\\\\varphi^n\\\\).\\n\\u00a0                 local_rhs_be = 0;\\n\\u00a0                 for (unsigned int q = 0; q < n_q_points_face; ++q)\\n\\u00a0                   {\\n\\u00a0                     const double         dx = fe_face_lift.JxW(q);\\n\\u00a0                     const Tensor<1, dim> normal =\\n\\u00a0                       fe_face_neighbor.normal_vector(q);\\n\\u00a0 \\n\\u00a0                     for (unsigned int m = 0; m < n_dofs_lift; ++m)\\n\\u00a0                       {\\n\\u00a0                         local_rhs_be(m) +=\\n\\u00a0                           0.5 * fe_face_lift[tau_ext].divergence(m, q) *\\n\\u00a0                           normal * fe_face_neighbor.shape_value(i, q) * dx;\\n\\u00a0                       }\\n\\u00a0                   }\\n\\u00a0 \\n\\u00a0                 solver.solve(local_matrix_lift,\\n\\u00a0                              coeffs_re,\\n\\u00a0                              local_rhs_re,\\n\\u00a0                              PreconditionIdentity());\\n\\u00a0                 solver.solve(local_matrix_lift,\\n\\u00a0                              coeffs_be,\\n\\u00a0                              local_rhs_be,\\n\\u00a0                              PreconditionIdentity());\\n\\u00a0 \\n\\u00a0                 for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0                   {\\n\\u00a0                     for (unsigned int m = 0; m < n_dofs_lift; ++m)\\n\\u00a0                       {\\n\\u00a0                         discrete_hessians_neigh[face_no][i][q] -=\\n\\u00a0                           coeffs_re[m] * fe_values_lift[tau_ext].value(m, q);\\n\\u00a0                       }\\n\\u00a0 \\n\\u00a0                     for (unsigned int m = 0; m < n_dofs_lift; ++m)\\n\\u00a0                       {\\n\\u00a0                         discrete_hessians_neigh[face_no][i][q] +=\\n\\u00a0                           coeffs_be[m] * fe_values_lift[tau_ext].value(m, q);\\n\\u00a0                       }\\n\\u00a0                   }\\n\\u00a0 \\n\\u00a0               } // for dof i\\n\\u00a0           }     // boundary check\\n\\u00a0       }         // for face\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n BiLaplacianLDGLift::run\\n\\u00a0   template <int dim>\\n\\u00a0   void BiLaplacianLDGLift<dim>::run()\\n\\u00a0   {\\n\\u00a0     make_grid();\\n\\u00a0 \\n\\u00a0     setup_system();\\n\\u00a0     assemble_system();\\n\\u00a0 \\n\\u00a0     solve();\\n\\u00a0 \\n\\u00a0     compute_errors();\\n\\u00a0     output_results();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 } // namespace Step82\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n The main function\\nThis is the main function. We define here the number of mesh refinements, the polynomial degree for the two finite element spaces (for the solution and the two liftings) and the two penalty coefficients. We can also change the dimension to run the code in 3d.\\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       const unsigned int n_ref = 3; // number of mesh refinements\\n\\u00a0 \\n\\u00a0       const unsigned int degree =\\n\\u00a0         2; // FE degree for u_h and the two lifting terms\\n\\u00a0 \\n\\u00a0       const double penalty_grad =\\n\\u00a0         1.0; // penalty coefficient for the jump of the gradients\\n\\u00a0       const double penalty_val =\\n\\u00a0         1.0; // penalty coefficient for the jump of the values\\n\\u00a0 \\n\\u00a0       Step82::BiLaplacianLDGLift<2> problem(n_ref,\\n\\u00a0                                             degree,\\n\\u00a0                                             penalty_grad,\\n\\u00a0                                             penalty_val);\\n\\u00a0 \\n\\u00a0       problem.run();\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nWhen running the program, the sparsity pattern is written to an svg file, the solution is written to a vtk file, and some results are printed to the console. With the current setup, the output should read\\nNumber of active cells: 64\\nNumber of degrees of freedom: 576\\nAssembling the system.............\\nDone.\\nDG H2 norm of the error: 0.0151063\\nDG H1 norm of the error: 0.000399747\\n   L2 norm of the error: 5.33856e-05\\nThis corresponds to the bi-Laplacian problem with the manufactured solution mentioned above for \\\\(d=2\\\\), 3 refinements of the mesh, degree \\\\(k=2\\\\), and \\\\(\\\\gamma_0=\\\\gamma_1=1\\\\) for the penalty coefficients. By changing the number of refinements, we get the following results:\\n\\n\\nn_ref n_cells n_dofs error H2  rate error H1 rate error L2 rate  \\n\\n1 4 36 5.651e-02 \\u2013 3.366e-03 \\u2013 3.473e-04 \\u2013  \\n\\n2 16 144 3.095e-02 0.87 1.284e-03 1.39 1.369e-04 1.34  \\n\\n3 64 576 1.511e-02 1.03 3.997e-04 1.68 5.339e-05 1.36  \\n\\n4 256 2304 7.353e-03 1.04 1.129e-04 1.82 1.691e-05 1.66  \\n\\n5 1024 9216 3.609e-03 1.03 3.024e-05 1.90 4.789e-06 1.82  \\n\\n6 4096 36864 1.785e-03 1.02 7.850e-06 1.95 1.277e-06 1.91  \\n\\nThis matches the expected optimal convergence rates for the \\\\(H^2\\\\) and \\\\(H^1\\\\) norms, but is sub-optimal for the \\\\(L_2\\\\) norm. Incidentally, this also matches the results seen in step-47 when using polynomial degree \\\\(k=2\\\\).\\nIndeed, just like in step-47, we can regain the optimal convergence order if we set the polynomial degree of the finite elements to \\\\(k=3\\\\) or higher. Here are the numbers for \\\\(k=3\\\\):\\n\\n\\nn_ref  n_cells  n_dofs  error H2  rate  error H1  rate  error L2  rate  \\n\\n1  4  36  1.451e-02  \\u2013  5.494e-04  \\u2013  3.035e-05  \\u2013  \\n\\n2  16  144  3.565e-03  2.02  6.870e-05  3.00  2.091e-06  3.86  \\n\\n3  64  576  8.891e-04  2.00  8.584e-06  3.00  1.352e-07  3.95  \\n\\n4  256  2304  2.223e-04  2.00  1.073e-06  3.00  8.594e-09  3.98  \\n\\n5  1024  9216  5.560e-05  2.00  1.341e-07  3.00  5.418e-10  3.99  \\n\\n6  4096  36864  1.390e-05  2.00  1.676e-08  3.00  3.245e-11  4.06  \\n\\nPossible extensions\\nThe code can be easily adapted to deal with the following cases:\\n\\n\\nNon-homogeneous Dirichlet boundary conditions on (part of) the boundary \\\\(\\\\partial \\\\Omega\\\\) of \\\\(\\\\Omega\\\\). \\n\\nHanging-nodes (proceed as in step-14 to not visit a sub-face twice when computing the lifting terms in compute_discrete_hessians and the penalty terms in assemble_matrix). \\n\\nLDG method for the Poisson problem (use the discrete gradient consisting of the broken gradient and the lifting of the jump of \\\\(u_h\\\\)). \\n\\nWe give below additional details for the first of these points.\\nNon-homogeneous Dirichlet boundary conditions\\nIf we prescribe non-homogeneous Dirichlet conditions, say   \\n\\\\[\\n\\\\nabla u=\\\\mathbf{g} \\\\quad \\\\mbox{and} \\\\quad u=g \\\\qquad \\\\mbox{on } \\\\partial \\\\Omega,\\n\\\\]\\n\\n then the right-hand side \\\\(\\\\boldsymbol{F}\\\\) of the linear system needs to be modified as follows   \\n\\\\[\\nF_i:=\\\\int_{\\\\Omega}f\\\\varphi_i-\\\\sum_{e\\\\in\\\\mathcal{E}_h^b}\\\\int_{\\\\Omega}r_e(\\\\mathbf{g}):H_h(\\\\varphi_i)+\\\\sum_{e\\\\in\\\\mathcal{E}_h^b}\\\\int_{\\\\Omega}b_e(g):H_h(\\\\varphi_i)+\\\\gamma_1\\\\sum_{e\\\\in\\\\mathcal{E}_h^b}h_e^{-1}\\\\int_e\\\\mathbf{g}\\\\cdot\\\\nabla\\\\varphi_i+\\\\gamma_0\\\\sum_{e\\\\in\\\\mathcal{E}_h^b}h_e^{-3}\\\\int_e g\\\\varphi_i, \\\\qquad 1\\\\leq i \\\\leq N_h.\\n\\\\]\\n\\n Note that for any given index \\\\(i\\\\), many of the terms are zero. Indeed, for \\\\(e\\\\in \\\\mathcal{E}_h^b\\\\) we have \\\\({\\\\rm supp}\\\\,(r_e(\\\\mathbf{g}))={\\\\rm supp}\\\\,(b_e(g))=K\\\\), where \\\\(K\\\\) is the element for which \\\\(e\\\\subset\\\\partial K\\\\). Therefore, the liftings \\\\(r_e(\\\\mathbf{g})\\\\) and \\\\(b_e(g)\\\\) contribute to \\\\(F_i\\\\) only if \\\\(\\\\varphi_i\\\\) has support on \\\\(K\\\\) or a neighbor of \\\\(K\\\\). In other words, when integrating on a cell \\\\(K\\\\), we need to add   \\n\\\\[\\n\\\\int_{K}f\\\\varphi_i+\\\\sum_{e\\\\in\\\\mathcal{E}_h^b, e\\\\subset\\\\partial K}\\\\left[-\\\\int_{K}r_e(\\\\mathbf{g}):H_h(\\\\varphi_i)+\\\\int_{K}b_e(g):H_h(\\\\varphi_i)+\\\\gamma_1h_e^{-1}\\\\int_e\\\\mathbf{g}\\\\cdot\\\\nabla\\\\varphi_i+\\\\gamma_0h_e^{-3}\\\\int_e g\\\\varphi_i\\\\right]\\n\\\\]\\n\\n to \\\\(F_i\\\\) for the indices \\\\(i\\\\) such that \\\\(\\\\varphi_i\\\\) has support on \\\\(K\\\\) and   \\n\\\\[\\n\\\\sum_{e\\\\in\\\\mathcal{E}_h^b, e\\\\subset\\\\partial K}\\\\left[-\\\\int_{K}r_e(\\\\mathbf{g}):H_h(\\\\varphi_i)+\\\\int_{K}b_e(g):H_h(\\\\varphi_i)\\\\right]\\n\\\\]\\n\\n to \\\\(F_i\\\\) for the indices \\\\(i\\\\) such that \\\\(\\\\varphi_i\\\\) has support on a neighbor of \\\\(K\\\\).\\nNoteNote that we can easily consider the case where Dirichlet boundary conditions are imposed only on a subset \\\\(\\\\emptyset\\\\neq\\\\Gamma_D\\\\subset\\\\partial \\\\Omega\\\\). In this case, we simply need to replace \\\\(\\\\mathcal{E}_h^b\\\\) by \\\\(\\\\mathcal{E}_h^D\\\\subset\\\\mathcal{E}_h^b\\\\) consisting of the faces belonging to \\\\(\\\\Gamma_D\\\\). This also affects the matrix \\\\(A\\\\) (simply replace \\\\(\\\\mathcal{E}_h=\\\\mathcal{E}_h^0\\\\cup\\\\mathcal{E}_h^b\\\\) by \\\\(\\\\mathcal{E}_h=\\\\mathcal{E}_h^0\\\\cup\\\\mathcal{E}_h^D\\\\)).\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2021 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Authors: Andrea Bonito and Diane Guignard, 2021.\\n */\\n \\n \\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/tria_accessor.h>\\n#include <deal.II/grid/tria_iterator.h>\\n \\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_accessor.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/fe/fe_dgq.h>\\n#include <deal.II/fe/fe_values.h>\\n#include <deal.II/fe/fe_system.h>\\n \\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/function.h>\\n \\n#include <deal.II/numerics/data_out.h>\\n \\n#include <deal.II/lac/vector.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/sparse_direct.h>\\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/precondition.h>\\n \\n#include <fstream>\\n#include <iostream>\\n \\n \\nnamespace Step82\\n{\\n using namespace dealii;\\n \\n \\n template <int dim>\\n class BiLaplacianLDGLift\\n  {\\n public:\\n    BiLaplacianLDGLift(const unsigned int n_refinements,\\n const unsigned int fe_degree,\\n const double       penalty_jump_grad,\\n const double       penalty_jump_val);\\n \\n void run();\\n \\n private:\\n void make_grid();\\n void setup_system();\\n void assemble_system();\\n void assemble_matrix();\\n void assemble_rhs();\\n \\n void solve();\\n \\n void compute_errors();\\n void output_results() const;\\n \\n void assemble_local_matrix(const FEValues<dim> &fe_values_lift,\\n const unsigned int   n_q_points,\\n FullMatrix<double>  &local_matrix);\\n \\n void compute_discrete_hessians(\\n const typename DoFHandler<dim>::active_cell_iterator &cell,\\n      std::vector<std::vector<Tensor<2, dim>>>             &discrete_hessians,\\n      std::vector<std::vector<std::vector<Tensor<2, dim>>>>\\n        &discrete_hessians_neigh);\\n \\n Triangulation<dim> triangulation;\\n \\n const unsigned int n_refinements;\\n \\n const FE_DGQ<dim> fe;\\n DoFHandler<dim>   dof_handler;\\n \\n const FESystem<dim> fe_lift;\\n \\n SparsityPattern      sparsity_pattern;\\n SparseMatrix<double> matrix;\\n Vector<double>       rhs;\\n Vector<double>       solution;\\n \\n const double penalty_jump_grad;\\n const double penalty_jump_val;\\n  };\\n \\n \\n \\n \\n template <int dim>\\n class RightHandSide : public Function<dim>\\n  {\\n public:\\n    RightHandSide()\\n      : Function<dim>()\\n    {}\\n \\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n  };\\n \\n \\n \\n template <int dim>\\n double RightHandSide<dim>::value(const Point<dim> &p,\\n const unsigned int /*component*/) const\\n {\\n double return_value = 0.0;\\n \\n if (dim == 2)\\n      {\\n        return_value = 24.0 * Utilities::fixed_power<2>(p[1] * (1.0 - p[1])) +\\n                       +24.0 * Utilities::fixed_power<2>(p[0] * (1.0 - p[0])) +\\n                       2.0 * (2.0 - 12.0 * p[0] + 12.0 * p[0] * p[0]) *\\n                         (2.0 - 12.0 * p[1] + 12.0 * p[1] * p[1]);\\n      }\\n else if (dim == 3)\\n      {\\n        return_value = 24.0 * Utilities::fixed_power<2>(p[1] * (1.0 - p[1]) *\\n                                                        p[2] * (1.0 - p[2])) +\\n                       24.0 * Utilities::fixed_power<2>(p[0] * (1.0 - p[0]) *\\n                                                        p[2] * (1.0 - p[2])) +\\n                       24.0 * Utilities::fixed_power<2>(p[0] * (1.0 - p[0]) *\\n                                                        p[1] * (1.0 - p[1])) +\\n                       2.0 * (2.0 - 12.0 * p[0] + 12.0 * p[0] * p[0]) *\\n                         (2.0 - 12.0 * p[1] + 12.0 * p[1] * p[1]) *\\n Utilities::fixed_power<2>(p[2] * (1.0 - p[2])) +\\n                       2.0 * (2.0 - 12.0 * p[0] + 12.0 * p[0] * p[0]) *\\n                         (2.0 - 12.0 * p[2] + 12.0 * p[2] * p[2]) *\\n Utilities::fixed_power<2>(p[1] * (1.0 - p[1])) +\\n                       2.0 * (2.0 - 12.0 * p[1] + 12.0 * p[1] * p[1]) *\\n                         (2.0 - 12.0 * p[2] + 12.0 * p[2] * p[2]) *\\n Utilities::fixed_power<2>(p[0] * (1.0 - p[0]));\\n      }\\n else\\n DEAL_II_NOT_IMPLEMENTED();\\n \\n return return_value;\\n  }\\n \\n \\n \\n template <int dim>\\n class ExactSolution : public Function<dim>\\n  {\\n public:\\n    ExactSolution()\\n      : Function<dim>()\\n    {}\\n \\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n \\n virtual Tensor<1, dim>\\n gradient(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n \\n virtual SymmetricTensor<2, dim>\\n hessian(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n  };\\n \\n \\n \\n template <int dim>\\n double ExactSolution<dim>::value(const Point<dim> &p,\\n const unsigned int /*component*/) const\\n {\\n double return_value = 0.0;\\n \\n if (dim == 2)\\n      {\\n        return_value =\\n Utilities::fixed_power<2>(p[0] * (1.0 - p[0]) * p[1] * (1.0 - p[1]));\\n      }\\n else if (dim == 3)\\n      {\\n        return_value = Utilities::fixed_power<2>(\\n          p[0] * (1.0 - p[0]) * p[1] * (1.0 - p[1]) * p[2] * (1.0 - p[2]));\\n      }\\n else\\n DEAL_II_NOT_IMPLEMENTED();\\n \\n return return_value;\\n  }\\n \\n \\n \\n template <int dim>\\n Tensor<1, dim>\\n  ExactSolution<dim>::gradient(const Point<dim> &p,\\n const unsigned int /*component*/) const\\n {\\n Tensor<1, dim> return_gradient;\\n \\n if (dim == 2)\\n      {\\n        return_gradient[0] =\\n          (2.0 * p[0] - 6.0 * Utilities::fixed_power<2>(p[0]) +\\n           4.0 * Utilities::fixed_power<3>(p[0])) *\\n Utilities::fixed_power<2>(p[1] * (1.0 - p[1]));\\n        return_gradient[1] =\\n          (2.0 * p[1] - 6.0 * Utilities::fixed_power<2>(p[1]) +\\n           4.0 * Utilities::fixed_power<3>(p[1])) *\\n Utilities::fixed_power<2>(p[0] * (1.0 - p[0]));\\n      }\\n else if (dim == 3)\\n      {\\n        return_gradient[0] =\\n          (2.0 * p[0] - 6.0 * Utilities::fixed_power<2>(p[0]) +\\n           4.0 * Utilities::fixed_power<3>(p[0])) *\\n Utilities::fixed_power<2>(p[1] * (1.0 - p[1]) * p[2] * (1.0 - p[2]));\\n        return_gradient[1] =\\n          (2.0 * p[1] - 6.0 * Utilities::fixed_power<2>(p[1]) +\\n           4.0 * Utilities::fixed_power<3>(p[1])) *\\n Utilities::fixed_power<2>(p[0] * (1.0 - p[0]) * p[2] * (1.0 - p[2]));\\n        return_gradient[2] =\\n          (2.0 * p[2] - 6.0 * Utilities::fixed_power<2>(p[2]) +\\n           4.0 * Utilities::fixed_power<3>(p[2])) *\\n Utilities::fixed_power<2>(p[0] * (1.0 - p[0]) * p[1] * (1.0 - p[1]));\\n      }\\n else\\n DEAL_II_NOT_IMPLEMENTED();\\n \\n return return_gradient;\\n  }\\n \\n \\n \\n template <int dim>\\n SymmetricTensor<2, dim>\\n  ExactSolution<dim>::hessian(const Point<dim> &p,\\n const unsigned int /*component*/) const\\n {\\n SymmetricTensor<2, dim> return_hessian;\\n \\n if (dim == 2)\\n      {\\n        return_hessian[0][0] = (2.0 - 12.0 * p[0] + 12.0 * p[0] * p[0]) *\\n Utilities::fixed_power<2>(p[1] * (1.0 - p[1]));\\n        return_hessian[0][1] =\\n          (2.0 * p[0] - 6.0 * Utilities::fixed_power<2>(p[0]) +\\n           4.0 * Utilities::fixed_power<3>(p[0])) *\\n          (2.0 * p[1] - 6.0 * Utilities::fixed_power<2>(p[1]) +\\n           4.0 * Utilities::fixed_power<3>(p[1]));\\n        return_hessian[1][1] = (2.0 - 12.0 * p[1] + 12.0 * p[1] * p[1]) *\\n Utilities::fixed_power<2>(p[0] * (1.0 - p[0]));\\n      }\\n else if (dim == 3)\\n      {\\n        return_hessian[0][0] =\\n          (2.0 - 12.0 * p[0] + 12.0 * p[0] * p[0]) *\\n Utilities::fixed_power<2>(p[1] * (1.0 - p[1]) * p[2] * (1.0 - p[2]));\\n        return_hessian[0][1] =\\n          (2.0 * p[0] - 6.0 * Utilities::fixed_power<2>(p[0]) +\\n           4.0 * Utilities::fixed_power<3>(p[0])) *\\n          (2.0 * p[1] - 6.0 * Utilities::fixed_power<2>(p[1]) +\\n           4.0 * Utilities::fixed_power<3>(p[1])) *\\n Utilities::fixed_power<2>(p[2] * (1.0 - p[2]));\\n        return_hessian[0][2] =\\n          (2.0 * p[0] - 6.0 * Utilities::fixed_power<2>(p[0]) +\\n           4.0 * Utilities::fixed_power<3>(p[0])) *\\n          (2.0 * p[2] - 6.0 * Utilities::fixed_power<2>(p[2]) +\\n           4.0 * Utilities::fixed_power<3>(p[2])) *\\n Utilities::fixed_power<2>(p[1] * (1.0 - p[1]));\\n        return_hessian[1][1] =\\n          (2.0 - 12.0 * p[1] + 12.0 * p[1] * p[1]) *\\n Utilities::fixed_power<2>(p[0] * (1.0 - p[0]) * p[2] * (1.0 - p[2]));\\n        return_hessian[1][2] =\\n          (2.0 * p[1] - 6.0 * Utilities::fixed_power<2>(p[1]) +\\n           4.0 * Utilities::fixed_power<3>(p[1])) *\\n          (2.0 * p[2] - 6.0 * Utilities::fixed_power<2>(p[2]) +\\n           4.0 * Utilities::fixed_power<3>(p[2])) *\\n Utilities::fixed_power<2>(p[0] * (1.0 - p[0]));\\n        return_hessian[2][2] =\\n          (2.0 - 12.0 * p[2] + 12.0 * p[2] * p[2]) *\\n Utilities::fixed_power<2>(p[0] * (1.0 - p[0]) * p[1] * (1.0 - p[1]));\\n      }\\n else\\n DEAL_II_NOT_IMPLEMENTED();\\n \\n return return_hessian;\\n  }\\n \\n \\n \\n \\n \\n template <int dim>\\n  BiLaplacianLDGLift<dim>::BiLaplacianLDGLift(const unsigned int n_refinements,\\n const unsigned int fe_degree,\\n const double penalty_jump_grad,\\n const double penalty_jump_val)\\n    : n_refinements(n_refinements)\\n    , fe(fe_degree)\\n    , dof_handler(triangulation)\\n    , fe_lift(FE_DGQ<dim>(fe_degree), dim * dim)\\n    , penalty_jump_grad(penalty_jump_grad)\\n    , penalty_jump_val(penalty_jump_val)\\n  {}\\n \\n \\n \\n \\n template <int dim>\\n void BiLaplacianLDGLift<dim>::make_grid()\\n  {\\n    std::cout << \\\"Building the mesh.............\\\" << std::endl;\\n \\n GridGenerator::hyper_cube(triangulation, 0.0, 1.0);\\n \\n triangulation.refine_global(n_refinements);\\n \\n    std::cout << \\\"Number of active cells: \\\" << triangulation.n_active_cells()\\n              << std::endl;\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void BiLaplacianLDGLift<dim>::setup_system()\\n  {\\n    dof_handler.distribute_dofs(fe);\\n \\n    std::cout << \\\"Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n              << std::endl;\\n \\n DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());\\n \\n const auto dofs_per_cell = fe.dofs_per_cell;\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n        std::vector<types::global_dof_index> dofs(dofs_per_cell);\\n        cell->get_dof_indices(dofs);\\n \\n for (unsigned int f = 0; f < cell->n_faces(); ++f)\\n if (!cell->face(f)->at_boundary())\\n            {\\n const auto neighbor_cell = cell->neighbor(f);\\n \\n              std::vector<types::global_dof_index> tmp(dofs_per_cell);\\n              neighbor_cell->get_dof_indices(tmp);\\n \\n              dofs.insert(std::end(dofs), std::begin(tmp), std::end(tmp));\\n            }\\n \\n for (const auto i : dofs)\\n          for (const auto j : dofs)\\n            {\\n              dsp.add(i, j);\\n              dsp.add(j, i);\\n            }\\n      }\\n \\n    sparsity_pattern.copy_from(dsp);\\n \\n \\n matrix.reinit(sparsity_pattern);\\n    rhs.reinit(dof_handler.n_dofs());\\n \\n    solution.reinit(dof_handler.n_dofs());\\n \\n    std::ofstream out(\\\"sparsity-pattern.svg\\\");\\n    sparsity_pattern.print_svg(out);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void BiLaplacianLDGLift<dim>::assemble_system()\\n  {\\n    std::cout << \\\"Assembling the system.............\\\" << std::endl;\\n \\n    assemble_matrix();\\n    assemble_rhs();\\n \\n    std::cout << \\\"Done. \\\" << std::endl;\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void BiLaplacianLDGLift<dim>::assemble_matrix()\\n  {\\n matrix = 0;\\n \\n const QGauss<dim>     quad(fe.degree + 1);\\n const QGauss<dim - 1> quad_face(fe.degree + 1);\\n \\n const unsigned int n_q_points      = quad.size();\\n const unsigned int n_q_points_face = quad_face.size();\\n \\n FEValues<dim> fe_values(fe, quad, update_hessians | update_JxW_values);\\n \\n FEFaceValues<dim> fe_face(\\n      fe, quad_face, update_values | update_gradients | update_normal_vectors);\\n \\n FEFaceValues<dim> fe_face_neighbor(\\n      fe, quad_face, update_values | update_gradients | update_normal_vectors);\\n \\n const unsigned int n_dofs = fe_values.dofs_per_cell;\\n \\n    std::vector<types::global_dof_index> local_dof_indices(n_dofs);\\n    std::vector<types::global_dof_index> local_dof_indices_neighbor(n_dofs);\\n    std::vector<types::global_dof_index> local_dof_indices_neighbor_2(n_dofs);\\n \\n FullMatrix<double> stiffness_matrix_cc(n_dofs,\\n                                           n_dofs); // interactions cell / cell\\n FullMatrix<double> stiffness_matrix_cn(\\n      n_dofs, n_dofs); // interactions cell / neighbor\\n FullMatrix<double> stiffness_matrix_nc(\\n      n_dofs, n_dofs); // interactions neighbor / cell\\n FullMatrix<double> stiffness_matrix_nn(\\n      n_dofs, n_dofs); // interactions neighbor / neighbor\\n FullMatrix<double> stiffness_matrix_n1n2(\\n      n_dofs, n_dofs); // interactions neighbor1 / neighbor2\\n FullMatrix<double> stiffness_matrix_n2n1(\\n      n_dofs, n_dofs); // interactions neighbor2 / neighbor1\\n \\n FullMatrix<double> ip_matrix_cc(n_dofs, n_dofs); // interactions cell / cell\\n FullMatrix<double> ip_matrix_cn(n_dofs,\\n                                    n_dofs); // interactions cell / neighbor\\n FullMatrix<double> ip_matrix_nc(n_dofs,\\n                                    n_dofs); // interactions neighbor / cell\\n FullMatrix<double> ip_matrix_nn(n_dofs,\\n                                    n_dofs); // interactions neighbor / neighbor\\n \\n    std::vector<std::vector<Tensor<2, dim>>> discrete_hessians(\\n      n_dofs, std::vector<Tensor<2, dim>>(n_q_points));\\n    std::vector<std::vector<std::vector<Tensor<2, dim>>>>\\n      discrete_hessians_neigh(GeometryInfo<dim>::faces_per_cell,\\n                              discrete_hessians);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n        fe_values.reinit(cell);\\n        cell->get_dof_indices(local_dof_indices);\\n \\n        compute_discrete_hessians(cell,\\n                                  discrete_hessians,\\n                                  discrete_hessians_neigh);\\n \\n        stiffness_matrix_cc = 0;\\n for (unsigned int q = 0; q < n_q_points; ++q)\\n          {\\n const double dx = fe_values.JxW(q);\\n \\n for (unsigned int i = 0; i < n_dofs; ++i)\\n for (unsigned int j = 0; j < n_dofs; ++j)\\n                {\\n const Tensor<2, dim> &H_i = discrete_hessians[i][q];\\n const Tensor<2, dim> &H_j = discrete_hessians[j][q];\\n \\n                  stiffness_matrix_cc(i, j) += scalar_product(H_j, H_i) * dx;\\n                }\\n          }\\n \\n for (unsigned int i = 0; i < n_dofs; ++i)\\n for (unsigned int j = 0; j < n_dofs; ++j)\\n            {\\n matrix(local_dof_indices[i], local_dof_indices[j]) +=\\n                stiffness_matrix_cc(i, j);\\n            }\\n \\n for (unsigned int face_no = 0; face_no < cell->n_faces(); ++face_no)\\n          {\\n const typename DoFHandler<dim>::face_iterator face =\\n              cell->face(face_no);\\n \\n const bool at_boundary = face->at_boundary();\\n if (!at_boundary)\\n              {\\n \\n const typename DoFHandler<dim>::active_cell_iterator\\n                  neighbor_cell = cell->neighbor(face_no);\\n                neighbor_cell->get_dof_indices(local_dof_indices_neighbor);\\n \\n                stiffness_matrix_cn = 0;\\n                stiffness_matrix_nc = 0;\\n                stiffness_matrix_nn = 0;\\n for (unsigned int q = 0; q < n_q_points; ++q)\\n                  {\\n const double dx = fe_values.JxW(q);\\n \\n for (unsigned int i = 0; i < n_dofs; ++i)\\n                      {\\n for (unsigned int j = 0; j < n_dofs; ++j)\\n                          {\\n const Tensor<2, dim> &H_i = discrete_hessians[i][q];\\n const Tensor<2, dim> &H_j = discrete_hessians[j][q];\\n \\n const Tensor<2, dim> &H_i_neigh =\\n                              discrete_hessians_neigh[face_no][i][q];\\n const Tensor<2, dim> &H_j_neigh =\\n                              discrete_hessians_neigh[face_no][j][q];\\n \\n                            stiffness_matrix_cn(i, j) +=\\n                              scalar_product(H_j_neigh, H_i) * dx;\\n                            stiffness_matrix_nc(i, j) +=\\n                              scalar_product(H_j, H_i_neigh) * dx;\\n                            stiffness_matrix_nn(i, j) +=\\n                              scalar_product(H_j_neigh, H_i_neigh) * dx;\\n                          }\\n                      }\\n                  }\\n \\n for (unsigned int i = 0; i < n_dofs; ++i)\\n                  {\\n for (unsigned int j = 0; j < n_dofs; ++j)\\n                      {\\n matrix(local_dof_indices[i],\\n                               local_dof_indices_neighbor[j]) +=\\n                          stiffness_matrix_cn(i, j);\\n matrix(local_dof_indices_neighbor[i],\\n                               local_dof_indices[j]) +=\\n                          stiffness_matrix_nc(i, j);\\n matrix(local_dof_indices_neighbor[i],\\n                               local_dof_indices_neighbor[j]) +=\\n                          stiffness_matrix_nn(i, j);\\n                      }\\n                  }\\n \\n              } // boundary check\\n          }     // for face\\n \\n for (unsigned int face_no = 0; face_no < cell->n_faces() - 1; ++face_no)\\n          {\\n const typename DoFHandler<dim>::face_iterator face =\\n              cell->face(face_no);\\n \\n const bool at_boundary = face->at_boundary();\\n if (!at_boundary)\\n              { // nothing to be done if boundary face (the liftings of the\\n \\n \\n for (unsigned int face_no_2 = face_no + 1;\\n                     face_no_2 < cell->n_faces();\\n                     ++face_no_2)\\n                  {\\n const typename DoFHandler<dim>::face_iterator face_2 =\\n                      cell->face(face_no_2);\\n \\n const bool at_boundary_2 = face_2->at_boundary();\\n if (!at_boundary_2)\\n                      {\\n const typename DoFHandler<dim>::active_cell_iterator\\n                          neighbor_cell = cell->neighbor(face_no);\\n                        neighbor_cell->get_dof_indices(\\n                          local_dof_indices_neighbor);\\n const typename DoFHandler<dim>::active_cell_iterator\\n                          neighbor_cell_2 = cell->neighbor(face_no_2);\\n                        neighbor_cell_2->get_dof_indices(\\n                          local_dof_indices_neighbor_2);\\n \\n                        stiffness_matrix_n1n2 = 0;\\n                        stiffness_matrix_n2n1 = 0;\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n                          {\\n const double dx = fe_values.JxW(q);\\n \\n for (unsigned int i = 0; i < n_dofs; ++i)\\n for (unsigned int j = 0; j < n_dofs; ++j)\\n                                {\\n const Tensor<2, dim> &H_i_neigh =\\n                                    discrete_hessians_neigh[face_no][i][q];\\n const Tensor<2, dim> &H_j_neigh =\\n                                    discrete_hessians_neigh[face_no][j][q];\\n \\n const Tensor<2, dim> &H_i_neigh2 =\\n                                    discrete_hessians_neigh[face_no_2][i][q];\\n const Tensor<2, dim> &H_j_neigh2 =\\n                                    discrete_hessians_neigh[face_no_2][j][q];\\n \\n                                  stiffness_matrix_n1n2(i, j) +=\\n                                    scalar_product(H_j_neigh2, H_i_neigh) * dx;\\n                                  stiffness_matrix_n2n1(i, j) +=\\n                                    scalar_product(H_j_neigh, H_i_neigh2) * dx;\\n                                }\\n                          }\\n \\n for (unsigned int i = 0; i < n_dofs; ++i)\\n for (unsigned int j = 0; j < n_dofs; ++j)\\n                            {\\n matrix(local_dof_indices_neighbor[i],\\n                                     local_dof_indices_neighbor_2[j]) +=\\n                                stiffness_matrix_n1n2(i, j);\\n matrix(local_dof_indices_neighbor_2[i],\\n                                     local_dof_indices_neighbor[j]) +=\\n                                stiffness_matrix_n2n1(i, j);\\n                            }\\n                      } // boundary check face_2\\n                  }     // for face_2\\n              }         // boundary check face_1\\n          }             // for face_1\\n \\n \\n for (unsigned int face_no = 0; face_no < cell->n_faces(); ++face_no)\\n          {\\n const typename DoFHandler<dim>::face_iterator face =\\n              cell->face(face_no);\\n \\n const double mesh_inv = 1.0 / face->diameter(); // h_e^{-1}\\n const double mesh3_inv =\\n              1.0 / Utilities::fixed_power<3>(face->diameter()); // h_e^{-3}\\n \\n            fe_face.reinit(cell, face_no);\\n \\n            ip_matrix_cc = 0; // filled in any case (boundary or interior face)\\n \\n const bool at_boundary = face->at_boundary();\\n if (at_boundary)\\n              {\\n for (unsigned int q = 0; q < n_q_points_face; ++q)\\n                  {\\n const double dx = fe_face.JxW(q);\\n \\n for (unsigned int i = 0; i < n_dofs; ++i)\\n for (unsigned int j = 0; j < n_dofs; ++j)\\n                        {\\n                          ip_matrix_cc(i, j) += penalty_jump_grad * mesh_inv *\\n                                                fe_face.shape_grad(j, q) *\\n                                                fe_face.shape_grad(i, q) * dx;\\n                          ip_matrix_cc(i, j) += penalty_jump_val * mesh3_inv *\\n                                                fe_face.shape_value(j, q) *\\n                                                fe_face.shape_value(i, q) * dx;\\n                        }\\n                  }\\n              }\\n else\\n              { // interior face\\n \\n const typename DoFHandler<dim>::active_cell_iterator\\n                                   neighbor_cell = cell->neighbor(face_no);\\n const unsigned int face_no_neighbor =\\n                  cell->neighbor_of_neighbor(face_no);\\n \\n if (neighbor_cell->id() < cell->id())\\n continue; // skip this face (already considered)\\n else\\n                  {\\n                    fe_face_neighbor.reinit(neighbor_cell, face_no_neighbor);\\n                    neighbor_cell->get_dof_indices(local_dof_indices_neighbor);\\n \\n                    ip_matrix_cn = 0;\\n                    ip_matrix_nc = 0;\\n                    ip_matrix_nn = 0;\\n \\n for (unsigned int q = 0; q < n_q_points_face; ++q)\\n                      {\\n const double dx = fe_face.JxW(q);\\n \\n for (unsigned int i = 0; i < n_dofs; ++i)\\n                          {\\n for (unsigned int j = 0; j < n_dofs; ++j)\\n                              {\\n                                ip_matrix_cc(i, j) +=\\n                                  penalty_jump_grad * mesh_inv *\\n                                  fe_face.shape_grad(j, q) *\\n                                  fe_face.shape_grad(i, q) * dx;\\n                                ip_matrix_cc(i, j) +=\\n                                  penalty_jump_val * mesh3_inv *\\n                                  fe_face.shape_value(j, q) *\\n                                  fe_face.shape_value(i, q) * dx;\\n \\n                                ip_matrix_cn(i, j) -=\\n                                  penalty_jump_grad * mesh_inv *\\n                                  fe_face_neighbor.shape_grad(j, q) *\\n                                  fe_face.shape_grad(i, q) * dx;\\n                                ip_matrix_cn(i, j) -=\\n                                  penalty_jump_val * mesh3_inv *\\n                                  fe_face_neighbor.shape_value(j, q) *\\n                                  fe_face.shape_value(i, q) * dx;\\n \\n                                ip_matrix_nc(i, j) -=\\n                                  penalty_jump_grad * mesh_inv *\\n                                  fe_face.shape_grad(j, q) *\\n                                  fe_face_neighbor.shape_grad(i, q) * dx;\\n                                ip_matrix_nc(i, j) -=\\n                                  penalty_jump_val * mesh3_inv *\\n                                  fe_face.shape_value(j, q) *\\n                                  fe_face_neighbor.shape_value(i, q) * dx;\\n \\n                                ip_matrix_nn(i, j) +=\\n                                  penalty_jump_grad * mesh_inv *\\n                                  fe_face_neighbor.shape_grad(j, q) *\\n                                  fe_face_neighbor.shape_grad(i, q) * dx;\\n                                ip_matrix_nn(i, j) +=\\n                                  penalty_jump_val * mesh3_inv *\\n                                  fe_face_neighbor.shape_value(j, q) *\\n                                  fe_face_neighbor.shape_value(i, q) * dx;\\n                              }\\n                          }\\n                      }\\n                  } // face not visited yet\\n \\n              } // boundary check\\n \\n for (unsigned int i = 0; i < n_dofs; ++i)\\n              {\\n for (unsigned int j = 0; j < n_dofs; ++j)\\n                  {\\n matrix(local_dof_indices[i], local_dof_indices[j]) +=\\n                      ip_matrix_cc(i, j);\\n                  }\\n              }\\n \\n if (!at_boundary)\\n              {\\n for (unsigned int i = 0; i < n_dofs; ++i)\\n                  {\\n for (unsigned int j = 0; j < n_dofs; ++j)\\n                      {\\n matrix(local_dof_indices[i],\\n                               local_dof_indices_neighbor[j]) +=\\n                          ip_matrix_cn(i, j);\\n matrix(local_dof_indices_neighbor[i],\\n                               local_dof_indices[j]) += ip_matrix_nc(i, j);\\n matrix(local_dof_indices_neighbor[i],\\n                               local_dof_indices_neighbor[j]) +=\\n                          ip_matrix_nn(i, j);\\n                      }\\n                  }\\n              }\\n \\n          } // for face\\n      }     // for cell\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void BiLaplacianLDGLift<dim>::assemble_rhs()\\n  {\\n    rhs = 0;\\n \\n const QGauss<dim> quad(fe.degree + 1);\\n FEValues<dim>     fe_values(\\n      fe, quad, update_values | update_quadrature_points | update_JxW_values);\\n \\n const unsigned int n_dofs     = fe_values.dofs_per_cell;\\n const unsigned int n_quad_pts = quad.size();\\n \\n const RightHandSide<dim> right_hand_side;\\n \\n Vector<double>                       local_rhs(n_dofs);\\n    std::vector<types::global_dof_index> local_dof_indices(n_dofs);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n        fe_values.reinit(cell);\\n        cell->get_dof_indices(local_dof_indices);\\n \\n        local_rhs = 0;\\n for (unsigned int q = 0; q < n_quad_pts; ++q)\\n          {\\n const double dx = fe_values.JxW(q);\\n \\n for (unsigned int i = 0; i < n_dofs; ++i)\\n              {\\n                local_rhs(i) +=\\n                  right_hand_side.value(fe_values.quadrature_point(q)) *\\n                  fe_values.shape_value(i, q) * dx;\\n              }\\n          }\\n \\n for (unsigned int i = 0; i < n_dofs; ++i)\\n          rhs(local_dof_indices[i]) += local_rhs(i);\\n      }\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void BiLaplacianLDGLift<dim>::solve()\\n  {\\n SparseDirectUMFPACK A_direct;\\n    A_direct.initialize(matrix);\\n    A_direct.vmult(solution, rhs);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void BiLaplacianLDGLift<dim>::compute_errors()\\n  {\\n double error_H2 = 0;\\n double error_H1 = 0;\\n double error_L2 = 0;\\n \\n const QGauss<dim>     quad(fe.degree + 1);\\n const QGauss<dim - 1> quad_face(fe.degree + 1);\\n \\n FEValues<dim> fe_values(fe,\\n                            quad,\\n update_values | update_gradients | update_hessians |\\n update_quadrature_points | update_JxW_values);\\n \\n FEFaceValues<dim> fe_face(fe,\\n                              quad_face,\\n update_values | update_gradients |\\n update_quadrature_points | update_JxW_values);\\n \\n FEFaceValues<dim> fe_face_neighbor(fe,\\n                                       quad_face,\\n update_values | update_gradients);\\n \\n const unsigned int n_q_points      = quad.size();\\n const unsigned int n_q_points_face = quad_face.size();\\n \\n const ExactSolution<dim> u_exact;\\n \\n    std::vector<double>         solution_values_cell(n_q_points);\\n    std::vector<Tensor<1, dim>> solution_gradients_cell(n_q_points);\\n    std::vector<Tensor<2, dim>> solution_hessians_cell(n_q_points);\\n \\n    std::vector<double>         solution_values(n_q_points_face);\\n    std::vector<double>         solution_values_neigh(n_q_points_face);\\n    std::vector<Tensor<1, dim>> solution_gradients(n_q_points_face);\\n    std::vector<Tensor<1, dim>> solution_gradients_neigh(n_q_points_face);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n        fe_values.reinit(cell);\\n \\n        fe_values.get_function_values(solution, solution_values_cell);\\n        fe_values.get_function_gradients(solution, solution_gradients_cell);\\n        fe_values.get_function_hessians(solution, solution_hessians_cell);\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n          {\\n const double dx = fe_values.JxW(q);\\n \\n            error_H2 += (u_exact.hessian(fe_values.quadrature_point(q)) -\\n                         solution_hessians_cell[q])\\n                          .norm_square() *\\n dx;\\n            error_H1 += (u_exact.gradient(fe_values.quadrature_point(q)) -\\n                         solution_gradients_cell[q])\\n                          .norm_square() *\\n dx;\\n            error_L2 += Utilities::fixed_power<2>(\\n                          u_exact.value(fe_values.quadrature_point(q)) -\\n                          solution_values_cell[q]) *\\n dx;\\n          } // for quadrature points\\n \\n for (unsigned int face_no = 0; face_no < cell->n_faces(); ++face_no)\\n          {\\n const typename DoFHandler<dim>::face_iterator face =\\n              cell->face(face_no);\\n \\n const double mesh_inv = 1.0 / face->diameter(); // h^{-1}\\n const double mesh3_inv =\\n              1.0 / Utilities::fixed_power<3>(face->diameter()); // h^{-3}\\n \\n            fe_face.reinit(cell, face_no);\\n \\n            fe_face.get_function_values(solution, solution_values);\\n            fe_face.get_function_gradients(solution, solution_gradients);\\n \\n const bool at_boundary = face->at_boundary();\\n if (at_boundary)\\n              {\\n for (unsigned int q = 0; q < n_q_points_face; ++q)\\n                  {\\n const double dx = fe_face.JxW(q);\\n const double u_exact_q =\\n                      u_exact.value(fe_face.quadrature_point(q));\\n const Tensor<1, dim> u_exact_grad_q =\\n                      u_exact.gradient(fe_face.quadrature_point(q));\\n \\n                    error_H2 +=\\n                      mesh_inv *\\n                      (u_exact_grad_q - solution_gradients[q]).norm_square() *\\n dx;\\n                    error_H2 += mesh3_inv *\\n Utilities::fixed_power<2>(u_exact_q -\\n                                                          solution_values[q]) *\\n dx;\\n                    error_H1 += mesh_inv *\\n Utilities::fixed_power<2>(u_exact_q -\\n                                                          solution_values[q]) *\\n dx;\\n                  }\\n              }\\n else\\n              { // interior face\\n \\n const typename DoFHandler<dim>::active_cell_iterator\\n                                   neighbor_cell = cell->neighbor(face_no);\\n const unsigned int face_no_neighbor =\\n                  cell->neighbor_of_neighbor(face_no);\\n \\n if (neighbor_cell->id() < cell->id())\\n continue; // skip this face (already considered)\\n else\\n                  {\\n                    fe_face_neighbor.reinit(neighbor_cell, face_no_neighbor);\\n \\n                    fe_face.get_function_values(solution, solution_values);\\n                    fe_face_neighbor.get_function_values(solution,\\n                                                         solution_values_neigh);\\n                    fe_face.get_function_gradients(solution,\\n                                                   solution_gradients);\\n                    fe_face_neighbor.get_function_gradients(\\n                      solution, solution_gradients_neigh);\\n \\n for (unsigned int q = 0; q < n_q_points_face; ++q)\\n                      {\\n const double dx = fe_face.JxW(q);\\n \\n                        error_H2 +=\\n                          mesh_inv *\\n                          (solution_gradients_neigh[q] - solution_gradients[q])\\n                            .norm_square() *\\n dx;\\n                        error_H2 +=\\n                          mesh3_inv *\\n Utilities::fixed_power<2>(solution_values_neigh[q] -\\n                                                    solution_values[q]) *\\n dx;\\n                        error_H1 +=\\n                          mesh_inv *\\n Utilities::fixed_power<2>(solution_values_neigh[q] -\\n                                                    solution_values[q]) *\\n dx;\\n                      }\\n                  } // face not visited yet\\n \\n              } // boundary check\\n \\n          } // for face\\n \\n      } // for cell\\n \\n    error_H2 = std::sqrt(error_H2);\\n    error_H1 = std::sqrt(error_H1);\\n    error_L2 = std::sqrt(error_L2);\\n \\n    std::cout << \\\"DG H2 norm of the error: \\\" << error_H2 << std::endl;\\n    std::cout << \\\"DG H1 norm of the error: \\\" << error_H1 << std::endl;\\n    std::cout << \\\"   L2 norm of the error: \\\" << error_L2 << std::endl;\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void BiLaplacianLDGLift<dim>::output_results() const\\n {\\n DataOut<dim> data_out;\\n    data_out.attach_dof_handler(dof_handler);\\n    data_out.add_data_vector(solution, \\\"solution\\\");\\n    data_out.build_patches();\\n \\n    std::ofstream output(\\\"solution.vtk\\\");\\n    data_out.write_vtk(output);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void BiLaplacianLDGLift<dim>::assemble_local_matrix(\\n const FEValues<dim> &fe_values_lift,\\n const unsigned int   n_q_points,\\n FullMatrix<double>  &local_matrix)\\n  {\\n const FEValuesExtractors::Tensor<2> tau_ext(0);\\n \\n const unsigned int n_dofs = fe_values_lift.dofs_per_cell;\\n \\n    local_matrix = 0;\\n for (unsigned int q = 0; q < n_q_points; ++q)\\n      {\\n const double dx = fe_values_lift.JxW(q);\\n \\n for (unsigned int m = 0; m < n_dofs; ++m)\\n for (unsigned int n = 0; n < n_dofs; ++n)\\n            {\\n              local_matrix(m, n) +=\\n                scalar_product(fe_values_lift[tau_ext].value(n, q),\\n                               fe_values_lift[tau_ext].value(m, q)) *\\n dx;\\n            }\\n      }\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void BiLaplacianLDGLift<dim>::compute_discrete_hessians(\\n const typename DoFHandler<dim>::active_cell_iterator &cell,\\n    std::vector<std::vector<Tensor<2, dim>>>             &discrete_hessians,\\n    std::vector<std::vector<std::vector<Tensor<2, dim>>>>\\n      &discrete_hessians_neigh)\\n  {\\n const typename Triangulation<dim>::cell_iterator cell_lift =\\n static_cast<typename Triangulation<dim>::cell_iterator>(cell);\\n \\n const QGauss<dim>     quad(fe.degree + 1);\\n const QGauss<dim - 1> quad_face(fe.degree + 1);\\n \\n const unsigned int n_q_points      = quad.size();\\n const unsigned int n_q_points_face = quad_face.size();\\n \\n FEValues<dim> fe_values(fe, quad, update_hessians | update_JxW_values);\\n \\n FEFaceValues<dim> fe_face(\\n      fe, quad_face, update_values | update_gradients | update_normal_vectors);\\n \\n FEFaceValues<dim> fe_face_neighbor(\\n      fe, quad_face, update_values | update_gradients | update_normal_vectors);\\n \\n const unsigned int n_dofs = fe_values.dofs_per_cell;\\n \\n FEValues<dim> fe_values_lift(fe_lift,\\n                                 quad,\\n update_values | update_JxW_values);\\n \\n FEFaceValues<dim> fe_face_lift(\\n      fe_lift, quad_face, update_values | update_gradients | update_JxW_values);\\n \\n const FEValuesExtractors::Tensor<2> tau_ext(0);\\n \\n const unsigned int n_dofs_lift = fe_values_lift.dofs_per_cell;\\n FullMatrix<double> local_matrix_lift(n_dofs_lift, n_dofs_lift);\\n \\n Vector<double> local_rhs_re(n_dofs_lift), local_rhs_be(n_dofs_lift),\\n      coeffs_re(n_dofs_lift), coeffs_be(n_dofs_lift), coeffs_tmp(n_dofs_lift);\\n \\n SolverControl            solver_control(1000, 1e-12);\\n SolverCG<Vector<double>> solver(solver_control);\\n \\n double factor_avg; // 0.5 for interior faces, 1.0 for boundary faces\\n \\n    fe_values.reinit(cell);\\n    fe_values_lift.reinit(cell_lift);\\n \\n    assemble_local_matrix(fe_values_lift, n_q_points, local_matrix_lift);\\n \\n for (unsigned int i = 0; i < n_dofs; ++i)\\n for (unsigned int q = 0; q < n_q_points; ++q)\\n        {\\n          discrete_hessians[i][q] = 0;\\n \\n for (unsigned int face_no = 0;\\n               face_no < discrete_hessians_neigh.size();\\n               ++face_no)\\n            {\\n              discrete_hessians_neigh[face_no][i][q] = 0;\\n            }\\n        }\\n \\n for (unsigned int i = 0; i < n_dofs; ++i)\\n      {\\n        coeffs_re = 0;\\n        coeffs_be = 0;\\n \\n for (unsigned int face_no = 0; face_no < cell->n_faces(); ++face_no)\\n          {\\n const typename DoFHandler<dim>::face_iterator face =\\n              cell->face(face_no);\\n \\n const bool at_boundary = face->at_boundary();\\n \\n            factor_avg = 0.5;\\n if (at_boundary)\\n              {\\n                factor_avg = 1.0;\\n              }\\n \\n            fe_face.reinit(cell, face_no);\\n            fe_face_lift.reinit(cell_lift, face_no);\\n \\n            local_rhs_re = 0;\\n for (unsigned int q = 0; q < n_q_points_face; ++q)\\n              {\\n const double dx     = fe_face_lift.JxW(q);\\n const Tensor<1, dim> normal = fe_face.normal_vector(\\n                  q); // same as fe_face_lift.normal_vector(q)\\n \\n for (unsigned int m = 0; m < n_dofs_lift; ++m)\\n                  {\\n                    local_rhs_re(m) +=\\n                      factor_avg *\\n                      (fe_face_lift[tau_ext].value(m, q) * normal) *\\n                      fe_face.shape_grad(i, q) * dx;\\n                  }\\n              }\\n \\n            local_rhs_be = 0;\\n for (unsigned int q = 0; q < n_q_points_face; ++q)\\n              {\\n const double dx     = fe_face_lift.JxW(q);\\n const Tensor<1, dim> normal = fe_face.normal_vector(\\n                  q); // same as fe_face_lift.normal_vector(q)\\n \\n for (unsigned int m = 0; m < n_dofs_lift; ++m)\\n                  {\\n                    local_rhs_be(m) += factor_avg *\\n                                       fe_face_lift[tau_ext].divergence(m, q) *\\n                                       normal * fe_face.shape_value(i, q) * dx;\\n                  }\\n              }\\n \\n            coeffs_tmp = 0;\\n            solver.solve(local_matrix_lift,\\n                         coeffs_tmp,\\n                         local_rhs_re,\\n PreconditionIdentity());\\n            coeffs_re += coeffs_tmp;\\n \\n            coeffs_tmp = 0;\\n            solver.solve(local_matrix_lift,\\n                         coeffs_tmp,\\n                         local_rhs_be,\\n PreconditionIdentity());\\n            coeffs_be += coeffs_tmp;\\n \\n          } // for face\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n          {\\n            discrete_hessians[i][q] += fe_values.shape_hessian(i, q);\\n \\n for (unsigned int m = 0; m < n_dofs_lift; ++m)\\n              {\\n                discrete_hessians[i][q] -=\\n                  coeffs_re[m] * fe_values_lift[tau_ext].value(m, q);\\n              }\\n \\n for (unsigned int m = 0; m < n_dofs_lift; ++m)\\n              {\\n                discrete_hessians[i][q] +=\\n                  coeffs_be[m] * fe_values_lift[tau_ext].value(m, q);\\n              }\\n          }\\n      } // for dof i\\n \\n \\n \\n for (unsigned int face_no = 0; face_no < cell->n_faces(); ++face_no)\\n      {\\n const typename DoFHandler<dim>::face_iterator face =\\n          cell->face(face_no);\\n \\n const bool at_boundary = face->at_boundary();\\n \\n if (!at_boundary)\\n          {\\n \\n const typename DoFHandler<2, dim>::active_cell_iterator\\n                               neighbor_cell = cell->neighbor(face_no);\\n const unsigned int face_no_neighbor =\\n              cell->neighbor_of_neighbor(face_no);\\n            fe_face_neighbor.reinit(neighbor_cell, face_no_neighbor);\\n \\n for (unsigned int i = 0; i < n_dofs; ++i)\\n              {\\n                coeffs_re = 0;\\n                coeffs_be = 0;\\n \\n                fe_face_lift.reinit(cell_lift, face_no);\\n \\n                local_rhs_re = 0;\\n for (unsigned int q = 0; q < n_q_points_face; ++q)\\n                  {\\n const double dx = fe_face_lift.JxW(q);\\n const Tensor<1, dim> normal =\\n                      fe_face_neighbor.normal_vector(q);\\n \\n for (unsigned int m = 0; m < n_dofs_lift; ++m)\\n                      {\\n                        local_rhs_re(m) +=\\n                          0.5 * (fe_face_lift[tau_ext].value(m, q) * normal) *\\n                          fe_face_neighbor.shape_grad(i, q) * dx;\\n                      }\\n                  }\\n \\n                local_rhs_be = 0;\\n for (unsigned int q = 0; q < n_q_points_face; ++q)\\n                  {\\n const double dx = fe_face_lift.JxW(q);\\n const Tensor<1, dim> normal =\\n                      fe_face_neighbor.normal_vector(q);\\n \\n for (unsigned int m = 0; m < n_dofs_lift; ++m)\\n                      {\\n                        local_rhs_be(m) +=\\n                          0.5 * fe_face_lift[tau_ext].divergence(m, q) *\\n                          normal * fe_face_neighbor.shape_value(i, q) * dx;\\n                      }\\n                  }\\n \\n                solver.solve(local_matrix_lift,\\n                             coeffs_re,\\n                             local_rhs_re,\\n PreconditionIdentity());\\n                solver.solve(local_matrix_lift,\\n                             coeffs_be,\\n                             local_rhs_be,\\n PreconditionIdentity());\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n                  {\\n for (unsigned int m = 0; m < n_dofs_lift; ++m)\\n                      {\\n                        discrete_hessians_neigh[face_no][i][q] -=\\n                          coeffs_re[m] * fe_values_lift[tau_ext].value(m, q);\\n                      }\\n \\n for (unsigned int m = 0; m < n_dofs_lift; ++m)\\n                      {\\n                        discrete_hessians_neigh[face_no][i][q] +=\\n                          coeffs_be[m] * fe_values_lift[tau_ext].value(m, q);\\n                      }\\n                  }\\n \\n              } // for dof i\\n          }     // boundary check\\n      }         // for face\\n  }\\n \\n \\n \\n template <int dim>\\n void BiLaplacianLDGLift<dim>::run()\\n  {\\n    make_grid();\\n \\n    setup_system();\\n    assemble_system();\\n \\n    solve();\\n \\n    compute_errors();\\n    output_results();\\n  }\\n \\n} // namespace Step82\\n \\n \\n \\n \\nint main()\\n{\\n try\\n    {\\n const unsigned int n_ref = 3; // number of mesh refinements\\n \\n const unsigned int degree =\\n        2; // FE degree for u_h and the two lifting terms\\n \\n const double penalty_grad =\\n        1.0; // penalty coefficient for the jump of the gradients\\n const double penalty_val =\\n        1.0; // penalty coefficient for the jump of the values\\n \\n      Step82::BiLaplacianLDGLift<2> problem(n_ref,\\n                                            degree,\\n                                            penalty_grad,\\n                                            penalty_val);\\n \\n      problem.run();\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n \\n return 0;\\n}\\nDataOutInterface::write_vtkvoid write_vtk(std::ostream &out) constDefinition data_out_base.cc:7681\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nDoFHandler::reinitvoid reinit(const Triangulation< dim, spacedim > &tria)\\nFEValuesBase::dofs_per_cellconst unsigned int dofs_per_cellDefinition fe_values_base.h:192\\nFEValuesBase::JxWdouble JxW(const unsigned int q_point) const\\nFEValues::reinitvoid reinit(const TriaIterator< DoFCellAccessor< dim, spacedim, level_dof_access > > &cell)\\nSparseDirectUMFPACK::vmultvoid vmult(Vector< double > &dst, const Vector< double > &src) constDefinition sparse_direct.cc:795\\ndof_accessor.h\\ndof_handler.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nfe_values.h\\nfe_dgq.h\\nfe_system.h\\nfull_matrix.h\\nfunction.h\\ntria.h\\ngrid_generator.h\\nDataOutBase::dx@ dxDefinition data_out_base.h:1627\\ninternal::EvaluatorQuantity::hessian@ hessian\\ninternal::EvaluatorQuantity::value@ value\\ninternal::EvaluatorQuantity::gradient@ gradient\\ndata_out.h\\nprecondition.h\\nquadrature_lib.h\\nsolver_cg.h\\nsparse_direct.h\\nsparse_matrix.h\\ntria_accessor.h\\ntria_iterator.h\\nvector.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"