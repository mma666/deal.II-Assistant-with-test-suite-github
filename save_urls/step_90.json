"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_90.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-90 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-90 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-90 tutorial program\\n\\n\\nThis tutorial depends on step-85.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nA non-trivial surface\\nModel problem\\nManufactured exact solution\\nThe Trace Finite Element Method\\nDiscrete Level Set Function\\n\\n The commented program\\n\\nExact surface\\nExact solution\\nExact forcing\\nScratch and Copy objects for TraceFEM\\nNormal-gradient stabilization form of TraceFEM\\nLaplace\\u2014Beltrami solver\\nGeometric approximation\\nAssembly and surface accumulation\\n\\n\\n Results\\n\\nConvergence test \\nParallel scalability\\n\\n The plain program\\n   \\n This program was contributed by Vladimir Yushutin and Timo Heister, Clemson University, 2023.\\nThis material is based upon work partly supported by the National Science Foundation Award DMS-2028346, OAC-2015848, EAR-1925575, and by the Computational Infrastructure in Geodynamics initiative (CIG), through the NSF under Award EAR-0949446, EAR-1550901, EAR-2149126 via the University of California \\u2013 Davis. \\n Introduction\\nIn this tutorial, we implement the trace finite element method (TraceFEM) in deal.II. TraceFEM solves PDEs posed on a possibly evolving \\\\((dim-1)\\\\)-dimensional surface \\\\(\\\\Gamma\\\\) employing a fixed uniform background mesh of a \\\\(dim\\\\)-dimensional domain in which the surface is embedded. Such surface PDEs arise in problems involving material films with complex properties and in other situations in which a non-trivial condition is imposed on either a stationary or a moving interface. Here we consider a steady, complex, non-trivial surface and the prototypical Laplace-Beltrami equation which is a counterpart of the Poisson problem on flat domains.\\nBeing an unfitted method, TraceFEM allows to circumvent the need of remeshing of an evolving surface if it is implicitly given by the zero contour of a level-set function. At the same time, it easily provides with an extension of the discrete solution to a neighborhood of the surface which turns out to be very handy in case of non-stationary interfaces and films. Certainly, this flexibility comes with a price: one needs to design the nodes and weights for a quadrature customized for each implicit intersection of the zero level-set and the background mesh. Moreover, these intersections may be of arbitrary shape and size manifesting in the so-called \\\"small cut\\\" problem and requiring addition of a stabilization form that restores well-conditioning of the problem.\\nTwo aspects are of our focus. First, the surface approximation is separated from the discretization of the surface PDE, e.g., a \\\\(Q_2\\\\) discrete level-set and a \\\\(Q_1\\\\) solution are possible on the same bulk triangulation. Second, we make sure that the performance of TraceFEM in the parallel implementation corresponds to that of a classical fitted FEM for a two-dimensional problem. We demonstrate how to achieve both goals by using a combination of MeshWorker and NonMatching capabilities.\\nA natural alternative to TraceFEM in solving surface PDEs is the parametric surface finite element method. The latter method relies on an explicit parametrization of the surface which may be not feasible especially for evolving interfaces with an unknown in advance shape - in this sense, TraceFEM is a technique inspired by the level-set description of interfaces. However, the parametric surface finite element method, when applicable, enjoys many well-known properties of fitted methods on flat domains provided the geometric errors - which a present for both methods - are taken under control.\\nA non-trivial surface\\nA fitted FEM on a flat two-dimensional domain, if discretized by piecewise linears with \\\\(N\\\\) degrees of freedom, typically results in \\\\(O(h)=O(N^{-1/2})\\\\) convergence rate of the energy error; requires \\\\(O(N)\\\\) storage for the degrees of freedom; and, more importantly, takes \\\\(O(N)\\\\) of construction time to create them, i.e. to mesh the domain. TraceFEM, although solving a two-dimensional problem, relies on the inherently three-dimensional mesh on which the level-set function must be defined and, if implemented naively, suffers from the increased storage and the increased construction time in terms of the active degrees of freedom \\\\(N_a\\\\) that actually enters the scheme with, hopefully, \\\\(O(N_a^{-1/2})\\\\) error. To combat these possible bottlenecks, we create iteratively a mesh which is localized near the zero contour line of the level set function, i.e near the surface, to restore the aforementioned two-dimensional performance typical for fitted FEM, see the first three typical iterations of this methodology below.\\n\\n\\n\\nIterative localization of the zero contour of a typical level set\\nThe cells colored by red cary the active degrees of freedom (total number \\\\(N_a\\\\)) as the level set is not sign-definite at support points. Notice also that the mesh is graded: any cell has at most 4 neighbors adjacent to each of 6 faces.\\nOnce a desired geometry approximation \\\\(\\\\Gamma_h\\\\) is achieved using the iterative approach above, we can start forming the linear system using the constructed normals and quadratures. For the purposes of the tutorial we choose a non-trivial surface \\\\(\\\\Gamma\\\\) given by   \\n\\\\begin{equation*}\\n  \\\\frac{x^2}{4}+ y^2 + \\\\frac{4  z^2} {(1 + 0.5  \\\\sin(\\\\pi  x))^{2}} = 1\\n\\\\end{equation*}\\n\\n The OY and OX views of this tamarind-shaped, exact surface \\\\(\\\\Gamma\\\\) are shown below along with the mesh after three iterations (the approximation \\\\(\\\\Gamma_h\\\\) is not shown).\\n\\n\\n\\nOY(left) and OZ(right) cross-sections of the background mesh along with the exact surface\\nModel problem\\nWe would like to solve the simplest possible problem defined on a surface, namely the Laplace\\u2013Beltrami equation,   \\n\\\\begin{equation*}\\n -\\\\Delta_\\\\Gamma u + c u = f \\\\qquad  \\\\text{in }\\\\, \\\\Gamma,\\n\\\\end{equation*}\\n\\n where we take \\\\(c=1\\\\) for concreteness. We added the term \\\\(cu\\\\) to the left-hand side so the problem becomes well-posed in the absence of any boundary; an alternative could be to take \\\\(c=0\\\\) but impose the zero mean condition.\\nManufactured exact solution\\nWe choose the test solution and the right-hand side forcing as the restriction to \\\\(\\\\Gamma\\\\) of    \\n\\\\begin{equation*}\\n u(x,y,z)=xy\\\\,,\\\\quad\\n f(x,y,z)=xy + 2.0\\\\,\\\\mathbf{n}_x \\\\mathbf{n}_y + \\\\kappa  (y \\\\mathbf{n}_x + x\\\\mathbf{n}_y),\\n\\\\end{equation*}\\n\\n where the latter is manufactured using the exact normal \\\\(\\\\mathbf{n}\\\\), the exact Hessian \\\\(\\\\nabla^2\\\\mathbf{n}\\\\) and the mean curvature, \\\\(\\\\kappa=\\\\mathrm{div} n\\\\) of the surface. Note that we do not need to impose any boundary conditions as the surface \\\\(\\\\Gamma\\\\) is closed.\\nThe Trace Finite Element Method\\nTraceFEM is an unfitted method: the surface \\\\(\\\\Gamma\\\\) is immersed into a regular, uniform background mesh that stays fixed even if the surface would be evolving. To solve Laplace\\u2013Beltrami equation, we first construct a surface approximation \\\\(\\\\Gamma_h\\\\) by intersecting implicitly the cells of the background mesh with the iso surface of an approximation of the level-set field. We note that we never actually create any two-dimensional meshes for the surface but only compute approximate quadrature points and surface normals. Next we distribute degrees of freedom over a thin subdomain \\\\(\\\\Omega_h\\\\) that completely covers \\\\(\\\\Gamma_h\\\\) and that consists of the intersected cells \\\\(\\\\mathcal{T}_\\\\Gamma^h\\\\),   \\n\\\\begin{equation*}\\n \\\\mathcal{T}_\\\\Gamma^h = \\\\{ T \\\\in \\\\mathcal{T}^{h} : T \\\\cap \\\\Gamma_h \\\\neq \\\\emptyset \\\\}.\\n\\\\end{equation*}\\n\\n The finite element space where we want to find our numerical solution, \\\\(u_h\\\\), is now   \\n\\\\begin{equation*}\\n V_h = \\\\{ v \\\\in C(\\\\Omega_h) : v \\\\in Q_p(T), \\\\, T \\\\in \\\\mathcal{T}_\\\\Gamma^h \\\\},\\n\\\\end{equation*}\\n\\n where \\\\(\\\\Omega_h\\\\) is the union of all intersected cells from \\\\(\\\\bigcup_{T \\\\in \\\\mathcal{T}_\\\\Gamma^h} \\\\overline{T}\\\\).\\nTo create \\\\(V_h\\\\), we first add an FE_Q and an FE_Nothing element to an hp::FECollection. We then iterate over each cell \\\\(T\\\\) and, depending on whether \\\\(T\\\\) belongs to \\\\(\\\\mathcal{T}_\\\\Gamma^h\\\\) or not, we set the active_fe_index to either 0 or 1. To determine whether a cell is intersected or not, we use the class NonMatching::MeshClassifier.\\nA natural candidate for a weak formulation involves the following (bi)linear forms    \\n\\\\begin{align*}\\n a_h(u_h, v_h) =  (\\\\nabla_{\\\\Gamma_h} u_h, \\\\nabla_{\\\\Gamma_h} v_h)_{\\\\Gamma_h}+(u_h, v_h)_{\\\\Gamma_h}\\\\,,\\\\qquad\\n L_h(v_h)      =  (f^e,v_h)_{\\\\Gamma_h}.\\n\\\\end{align*}\\n\\n where \\\\(f^e\\\\) is an extension (non-necessarily the the so-called normal extension) of \\\\(f\\\\) from \\\\(\\\\Gamma\\\\) to \\\\(\\\\Omega_h\\\\). Note that the right-hand side \\\\(f\\\\) of the Laplace-Beltrami problem is defined on the exact surface \\\\(\\\\Gamma\\\\) only and we need to specify how to evaluate its action on the perturbed approximate geometry \\\\(\\\\Gamma_h\\\\) which is immersed in \\\\(\\\\Omega_h\\\\). For the purposes of this test, the forcing \\\\(f\\\\) is manufactured using \\\\(u=xy\\\\) and the level-set function and, therefore, is a function of Cartesian coordinates \\\\(x\\\\), \\\\(y\\\\), \\\\(z\\\\). The latter is identified with \\\\(f^e\\\\) on \\\\(\\\\Gamma_h\\\\) and it is not the normal extension of the function \\\\(f\\\\).\\nHowever, the so-called \\\"small-cut problem\\\" may arise and one should introduce the stabilized version of TraceFEM: Find \\\\(u_h \\\\in V_h\\\\) such that   \\n\\\\begin{equation*}\\n a_h(u_h,v_h) + s_h(u_h, v_h) = L_h(v_h), \\\\quad \\\\forall v_h \\\\in V_\\\\Omega^h.\\n\\\\end{equation*}\\n\\n Here the normal-gradient stabilization \\\\(s_h\\\\) involves the three-dimensional integration over whole (but intersected) cells and is given by   \\n\\\\begin{equation*}\\n s_h(u_h,v_h) = h^{-1}(\\\\mathbf{n}_h\\\\cdot\\\\nabla u_h, \\\\mathbf{n}_h\\\\cdot\\\\nabla v_h)_{\\\\Omega_h},\\n\\\\end{equation*}\\n\\n Note that the \\\\(h^{-1}\\\\) scaling may be relaxed for sufficiently smooth solutions such as the manufactured one, but we choose the strong scaling to demonstrate the extreme case [168].\\nDiscrete Level Set Function\\nIn TraceFEM we construct the approximation \\\\(\\\\Gamma_h\\\\) using the interpolant \\\\(\\\\psi_h\\\\) of the exact level-set function on the bulk triangulation:   \\n\\\\begin{align*}\\n \\\\Gamma_h &= \\\\{x \\\\in \\\\mathbb{R}^{\\\\text{3}} : \\\\psi_h(x) = 0 \\\\}.\\n\\\\end{align*}\\n\\n The exact normal vector \\\\(\\\\mathbf{n}\\\\) is approximated by \\\\(\\\\mathbf{n}_h=\\\\nabla\\\\psi_h/\\\\|\\\\nabla\\\\psi_h\\\\|\\\\) which, together with approximate quadrature for the integration over \\\\(\\\\Gamma_h\\\\), leads to the so-called \\\"geometrical error\\\". Luckily, one can show [168] that the method converges optimally for the model problem if the same element space \\\\(V_h\\\\) is employed for the discrete functions and for the interpolation of the level set function as if the exact domain would have been used. Furthermore, deal.II allows to choose independently the discrete space for the solution and a higher-order discrete space for the level set function for a more accurate geometric approximation.\\n The commented program\\n\\u00a0 #include <deal.II/base/convergence_table.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/base/numbers.h>\\n\\u00a0 #include <deal.II/base/point.h>\\n\\u00a0 #include <deal.II/base/quadrature.h>\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/tensor.h>\\n\\u00a0 #include <deal.II/base/timer.h>\\n\\u00a0 #include <deal.II/distributed/grid_refinement.h>\\n\\u00a0 #include <deal.II/distributed/tria.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 #include <deal.II/fe/fe_nothing.h>\\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_update_flags.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 #include <deal.II/fe/mapping_q1.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_tools.h>\\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/hp/fe_collection.h>\\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/precondition.h>\\n\\u00a0 #include <deal.II/lac/solver_cg.h>\\n\\u00a0 #include <deal.II/lac/solver_control.h>\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/sparse_direct.h>\\n\\u00a0 #include <deal.II/lac/sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/sparsity_tools.h>\\n\\u00a0 #include <deal.II/lac/trilinos_precondition.h>\\n\\u00a0 #include <deal.II/lac/trilinos_solver.h>\\n\\u00a0 #include <deal.II/lac/trilinos_sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/trilinos_vector.h>\\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 #include <deal.II/meshworker/mesh_loop.h>\\n\\u00a0 #include <deal.II/meshworker/scratch_data.h>\\n\\u00a0 #include <deal.II/non_matching/fe_immersed_values.h>\\n\\u00a0 #include <deal.II/non_matching/fe_values.h>\\n\\u00a0 #include <deal.II/non_matching/mesh_classifier.h>\\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/error_estimator.h>\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 \\n\\u00a0 using namespace dealii;\\n\\u00a0 using VectorType = TrilinosWrappers::MPI::Vector;\\n\\u00a0 using MatrixType = TrilinosWrappers::SparseMatrix;\\n\\u00a0 namespace Step90\\n\\u00a0 {\\nTrilinosWrappers::MPI::VectorDefinition trilinos_vector.h:405\\nTrilinosWrappers::SparseMatrixDefinition trilinos_sparse_matrix.h:550\\ndealiiDefinition namespace_dealii.h:25\\nhpDefinition hp.h:117\\nnumbersDefinition numbers.h:230\\nThe parallelization in this tutorial relies on the Trilinos library. We will grant to some cells empty finite element spaces FE_Nothing as done in step-85, but this time active DoFs will be only assigned to cell which are intersected by the surface approximation.\\n\\u00a0   enum class ActiveFEIndex : types::fe_index\\n\\u00a0   {\\n\\u00a0     lagrange = 0,\\n\\u00a0     nothing  = 1\\n\\u00a0   };\\n\\u00a0 \\ntypes::fe_indexunsigned short int fe_indexDefinition types.h:59\\n Exact surface\\nThe following class defines the surface using the implicit level set representation. The exact surface normal uses the Cartesian gradient of the level set function. The exact Hessian is needed for the construction of the test case only.\\n\\u00a0   template <int dim>\\n\\u00a0   class TamarindShape : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     TamarindShape()\\n\\u00a0       : Function<dim>()\\n\\u00a0     {}\\n\\u00a0     double value(const Point<dim>  &point,\\n\\u00a0                  const unsigned int component = 0) const override\\n\\u00a0     {\\n\\u00a0       AssertIndexRange(component, this->n_components);\\n\\u00a0       (void)component;\\n\\u00a0       Assert(dim == 3, ExcNotImplemented());\\n\\u00a0 \\n\\u00a0       return 0.25 * Utilities::pow(point[0], 2) + Utilities::pow(point[1], 2) +\\n\\u00a0              4.0 * Utilities::pow(point[2], 2) *\\n\\u00a0                std::pow(1.0 + 0.5 * std::sin(numbers::PI * point[0]), -2) -\\n\\u00a0              1.0;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     Tensor<1, dim> gradient(const Point<dim>  &point,\\n\\u00a0                             const unsigned int component = 0) const override\\n\\u00a0     {\\n\\u00a0       AssertIndexRange(component, this->n_components);\\n\\u00a0       (void)component;\\n\\u00a0       Assert(dim == 3, ExcNotImplemented());\\n\\u00a0 \\n\\u00a0       Tensor<1, dim> grad;\\n\\u00a0       grad[0] = 0.5 * point[0] +\\n\\u00a0                 (-2.0) * 4.0 * Utilities::pow(point[2], 2) *\\n\\u00a0                   std::pow(1.0 + 0.5 * std::sin(numbers::PI * point[0]), -3) *\\n\\u00a0                   (0.5 * numbers::PI * std::cos(numbers::PI * point[0]));\\n\\u00a0       grad[1] = 2.0 * point[1];\\n\\u00a0       grad[2] = (2.0) * 4.0 * point[2] *\\n\\u00a0                 std::pow(1.0 + 0.5 * std::sin(numbers::PI * point[0]), -2);\\n\\u00a0 \\n\\u00a0       return grad;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     SymmetricTensor<2, dim>\\n\\u00a0     hessian(const Point<dim>  &point,\\n\\u00a0             const unsigned int component = 0) const override\\n\\u00a0     {\\n\\u00a0       AssertIndexRange(component, this->n_components);\\n\\u00a0       (void)component;\\n\\u00a0       Assert(dim == 3, ExcNotImplemented());\\n\\u00a0 \\n\\u00a0       SymmetricTensor<2, dim> hessian;\\n\\u00a0 \\n\\u00a0       hessian[0][0] =\\n\\u00a0         0.5 +\\n\\u00a0         8.0 * Utilities::pow(point[2], 2) *\\n\\u00a0           (3.0 * std::pow(1.0 + 0.5 * std::sin(numbers::PI * point[0]), -4) *\\n\\u00a0              Utilities::pow(0.5 * numbers::PI *\\n\\u00a0                               std::cos(numbers::PI * point[0]),\\n\\u00a0                             2) +\\n\\u00a0            std::pow(1.0 + 0.5 * std::sin(numbers::PI * point[0]), -3) * 0.5 *\\n\\u00a0              numbers::PI * numbers::PI * std::sin(numbers::PI * point[0]));\\n\\u00a0       hessian[0][1] = 0.0;\\n\\u00a0       hessian[0][2] =\\n\\u00a0         (-8.0) * point[2] *\\n\\u00a0         std::pow(1.0 + 0.5 * std::sin(numbers::PI * point[0]), -3) *\\n\\u00a0         numbers::PI * std::cos(numbers::PI * point[0]);\\n\\u00a0 \\n\\u00a0       hessian[1][1] = 2.0;\\n\\u00a0       hessian[1][2] = 0.0;\\n\\u00a0 \\n\\u00a0       hessian[2][2] =\\n\\u00a0         8.0 * std::pow(1.0 + 0.5 * std::sin(numbers::PI * point[0]), -2);\\n\\u00a0 \\n\\u00a0       return hessian;\\n\\u00a0     }\\n\\u00a0   };\\n\\u00a0 \\nFunctionDefinition function.h:152\\nFunction::hessianvirtual SymmetricTensor< 2, dim, RangeNumberType > hessian(const Point< dim > &p, const unsigned int component=0) const\\nFunction::gradientvirtual Tensor< 1, dim, RangeNumberType > gradient(const Point< dim > &p, const unsigned int component=0) const\\nFunction::valuevirtual RangeNumberType value(const Point< dim > &p, const unsigned int component=0) const\\nPointDefinition point.h:111\\nSymmetricTensorDefinition symmetric_tensor.h:719\\nTensorDefinition tensor.h:471\\nStandardExceptions::ExcNotImplementedstatic ::ExceptionBase & ExcNotImplemented()\\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\nAssertIndexRange#define AssertIndexRange(index, range)Definition exceptions.h:2053\\nOpenCASCADE::pointPoint< spacedim > point(const gp_Pnt &p, const double tolerance=1e-10)Definition utilities.cc:191\\nUtilities::powconstexpr T pow(const T base, const int iexp)Definition utilities.h:966\\ninternal::EvaluatorQuantity::hessian@ hessian\\nnumbers::PIstatic constexpr double PIDefinition numbers.h:259\\nstd::cos::VectorizedArray< Number, width > cos(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6609\\nstd::sin::VectorizedArray< Number, width > sin(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6589\\nstd::pow::VectorizedArray< Number, width > pow(const ::VectorizedArray< Number, width > &, const Number p)Definition vectorization.h:6885\\n Exact solution\\nThe following class defines the chosen exact solution and its surface gradient. The exact solution we try to reproduce is \\\\(u=xy\\\\) and it may be evaluated away from \\\\(\\\\Gamma\\\\) as any other function of Cartesian points. Also note that the gradient() method returns the surface gradient \\\\(\\\\nabla_\\\\Gamma u\\\\) of the exact solution.\\n\\u00a0   template <int dim>\\n\\u00a0   class AnalyticalSolution : public Function<dim>\\n\\u00a0   {\\n\\u00a0   private:\\n\\u00a0     const TamarindShape<dim> tamarind;\\n\\u00a0 \\n\\u00a0   public:\\n\\u00a0     AnalyticalSolution()\\n\\u00a0       : Function<dim>()\\n\\u00a0     {}\\n\\u00a0     double value(const Point<dim>  &point,\\n\\u00a0                  const unsigned int component = 0) const override;\\n\\u00a0 \\n\\u00a0     Tensor<1, dim> gradient(const Point<dim>  &point,\\n\\u00a0                             const unsigned int component = 0) const override;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double AnalyticalSolution<dim>::value(const Point<dim>  &point,\\n\\u00a0                                         const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     AssertIndexRange(component, this->n_components);\\n\\u00a0     (void)component;\\n\\u00a0     return point[0] * point[1];\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   Tensor<1, dim>\\n\\u00a0   AnalyticalSolution<dim>::gradient(const Point<dim>  &point,\\n\\u00a0                                     const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     AssertIndexRange(component, this->n_components);\\n\\u00a0     (void)component;\\n\\u00a0 \\n\\u00a0     const Tensor<1, dim> grad   = tamarind.gradient(point, component);\\n\\u00a0     const Tensor<1, dim> normal = grad / grad.norm();\\n\\u00a0 \\n\\u00a0     Tensor<1, dim> projector_first_column = -normal[0] * normal;\\n\\u00a0     projector_first_column[0] += 1.0;\\n\\u00a0 \\n\\u00a0     Tensor<1, dim> projector_second_column = -normal[1] * normal;\\n\\u00a0     projector_second_column[1] += 1.0;\\n\\u00a0 \\n\\u00a0     Tensor<1, dim> surface_gradient =\\n\\u00a0       point[1] * projector_first_column + point[0] * projector_second_column;\\n\\u00a0 \\n\\u00a0     return surface_gradient;\\n\\u00a0   }\\n\\u00a0 \\nTensor::normnumbers::NumberTraits< Number >::real_type norm() const\\n Exact forcing\\nWe choose the right hand side equal to the evaluation of the surface Laplacian for a manufactured solution \\\\(u\\\\). This corresponds to the exact forcing \\\\(f=-\\\\Delta_\\\\Gamma u+u\\\\):\\n\\u00a0   template <int dim>\\n\\u00a0   class RightHandSide : public Function<dim>\\n\\u00a0   {\\n\\u00a0     const TamarindShape<dim> tamarind;\\n\\u00a0 \\n\\u00a0   public:\\n\\u00a0     RightHandSide()\\n\\u00a0       : Function<dim>()\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component = 0) const override;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double RightHandSide<dim>::value(const Point<dim>  &point,\\n\\u00a0                                    const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     AssertIndexRange(component, this->n_components);\\n\\u00a0     (void)component;\\n\\u00a0     Assert(dim == 3, ExcNotImplemented());\\n\\u00a0 \\n\\u00a0     const Tensor<1, dim>          grad    = tamarind.gradient(point, component);\\n\\u00a0     const Tensor<1, dim>          normal  = grad / grad.norm();\\n\\u00a0     const SymmetricTensor<2, dim> hessian = tamarind.hessian(point, component);\\n\\u00a0 \\n\\u00a0     double mean_curv = 0.0;\\n\\u00a0     for (int j = 0; j < 3; j++)\\n\\u00a0       for (int k = 0; k < 3; k++)\\n\\u00a0         mean_curv += ((j == k ? 1 : 0) - normal[j] * normal[k]) * hessian[j][k];\\n\\u00a0     mean_curv /= grad.norm();\\n\\u00a0 \\n\\u00a0     return point[0] * point[1] + 2.0 * normal[0] * normal[1] +\\n\\u00a0            mean_curv * (point[1] * normal[0] + point[0] * normal[1]);\\n\\u00a0   }\\n\\u00a0 \\n Scratch and Copy objects for TraceFEM\\nSince the assembly procedure will be performed via MeshWorker, we need a Scratch object that handles the Non-Matching FEValues effectively. The input arguments of its constructor are discussed in the solver class below.\\n\\u00a0   template <int dim>\\n\\u00a0   struct ScratchData\\n\\u00a0   {\\n\\u00a0     ScratchData(const Mapping<dim>                     &mapping,\\n\\u00a0                 const hp::FECollection<dim>            &fe_collection,\\n\\u00a0                 const NonMatching::MeshClassifier<dim> &mesh_classifier,\\n\\u00a0                 const DoFHandler<dim>                  &level_set_dof_handler,\\n\\u00a0                 const VectorType                       &level_set,\\n\\u00a0                 const NonMatching::RegionUpdateFlags nonmatching_update_flags,\\n\\u00a0                 const Quadrature<dim>               &quadrature,\\n\\u00a0                 const Quadrature<1>                 &quadrature_edge,\\n\\u00a0                 const UpdateFlags cell_update_flags = update_values |\\n\\u00a0                                                       update_gradients |\\n\\u00a0                                                       update_quadrature_points |\\n\\u00a0                                                       update_JxW_values)\\n\\u00a0       : fe_values(\\n\\u00a0           mapping,\\n\\u00a0           fe_collection[static_cast<types::fe_index>(ActiveFEIndex::lagrange)],\\n\\u00a0           quadrature,\\n\\u00a0           cell_update_flags)\\n\\u00a0       , region_update_flags(nonmatching_update_flags)\\n\\u00a0       , quadrature_1D(quadrature_edge)\\n\\u00a0       , fe_collection(fe_collection)\\n\\u00a0       , mesh_classifier(mesh_classifier)\\n\\u00a0       , level_set_dof_handler(level_set_dof_handler)\\n\\u00a0       , level_set(level_set)\\n\\u00a0       , level_set_fe_values(mapping,\\n\\u00a0                             level_set_dof_handler.get_fe(),\\n\\u00a0                             quadrature,\\n\\u00a0                             cell_update_flags)\\n\\u00a0       , non_matching_fe_values(fe_collection,\\n\\u00a0                                quadrature_edge,\\n\\u00a0                                nonmatching_update_flags,\\n\\u00a0                                mesh_classifier,\\n\\u00a0                                level_set_dof_handler,\\n\\u00a0                                level_set)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     ScratchData(const ScratchData<dim> &scratch_data)\\n\\u00a0       : fe_values(scratch_data.fe_values.get_mapping(),\\n\\u00a0                   scratch_data.fe_values.get_fe(),\\n\\u00a0                   scratch_data.fe_values.get_quadrature(),\\n\\u00a0                   scratch_data.fe_values.get_update_flags())\\n\\u00a0       , region_update_flags(scratch_data.region_update_flags)\\n\\u00a0       , quadrature_1D(scratch_data.quadrature_1D)\\n\\u00a0       , fe_collection(scratch_data.fe_collection)\\n\\u00a0       , mesh_classifier(scratch_data.mesh_classifier)\\n\\u00a0       , level_set_dof_handler(scratch_data.level_set_dof_handler)\\n\\u00a0       , level_set(scratch_data.level_set)\\n\\u00a0       , level_set_fe_values(scratch_data.level_set_fe_values.get_mapping(),\\n\\u00a0                             scratch_data.level_set_fe_values.get_fe(),\\n\\u00a0                             scratch_data.level_set_fe_values.get_quadrature(),\\n\\u00a0                             scratch_data.level_set_fe_values.get_update_flags())\\n\\u00a0       , non_matching_fe_values(fe_collection,\\n\\u00a0                                quadrature_1D,\\n\\u00a0                                region_update_flags,\\n\\u00a0                                mesh_classifier,\\n\\u00a0                                level_set_dof_handler,\\n\\u00a0                                level_set)\\n\\u00a0     {}\\n\\u00a0 \\nDoFHandlerDefinition dof_handler.h:317\\nMappingAbstract base class for mapping classes.Definition mapping.h:318\\nNonMatching::MeshClassifierDefinition mesh_classifier.h:109\\nQuadratureDefinition quadrature.h:123\\nhp::FECollectionDefinition fe_collection.h:61\\nUpdateFlagsUpdateFlagsDefinition fe_update_flags.h:64\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\ntypesDefinition types.h:32\\nNonMatching::RegionUpdateFlagsDefinition fe_values.h:58\\nThe following FEValues object is used for the standard quadrature on cells involving the FE space of the solution. In TraceFEM, we need this quadrature due to the stabilization term. In addition, a cell quadrature for the FE space of the level set is defined.\\n\\u00a0     FEValues<dim>                           fe_values;\\n\\u00a0     const NonMatching::RegionUpdateFlags    region_update_flags;\\n\\u00a0     const Quadrature<1>                    &quadrature_1D;\\n\\u00a0     const hp::FECollection<dim>            &fe_collection;\\n\\u00a0     const NonMatching::MeshClassifier<dim> &mesh_classifier;\\n\\u00a0     const DoFHandler<dim>                  &level_set_dof_handler;\\n\\u00a0     const VectorType                       &level_set;\\n\\u00a0     FEValues<dim>                           level_set_fe_values;\\n\\u00a0     NonMatching::FEValues<dim>              non_matching_fe_values;\\n\\u00a0   };\\n\\u00a0 \\nFEValuesDefinition fe_values.h:63\\nNonMatching::FEValuesDefinition fe_values.h:144\\nThe MeshWorker framework also requires a \\\"copy\\\" data structure that is filled by the worker function working on a cell or face, and whose contents are then later copied into global matrices and vectors. This CopyData object is customized for TraceFEM. In particular, the implementation of the normal-gradient volume stabilization relies on it.\\n\\u00a0   template <int dim>\\n\\u00a0   struct CopyData\\n\\u00a0   {\\n\\u00a0     FullMatrix<double>                   cell_matrix;\\n\\u00a0     Vector<double>                       cell_rhs;\\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices;\\n\\u00a0 \\n\\u00a0     void reinit(const typename DoFHandler<dim>::active_cell_iterator &cell)\\n\\u00a0     {\\n\\u00a0       const unsigned int dofs_per_cell = cell->get_fe().n_dofs_per_cell();\\n\\u00a0       cell_matrix.reinit(dofs_per_cell, dofs_per_cell);\\n\\u00a0       cell_rhs.reinit(dofs_per_cell);\\n\\u00a0       local_dof_indices.resize(dofs_per_cell);\\n\\u00a0       cell->get_dof_indices(local_dof_indices);\\n\\u00a0     }\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   struct CopyDataError\\n\\u00a0   {\\n\\u00a0     unsigned int cell_index;\\n\\u00a0     double       cell_L2_error_sqr;\\n\\u00a0     double       cell_H1_error_sqr;\\n\\u00a0     double       cell_stab_sqr;\\n\\u00a0 \\n\\u00a0     void reinit(const typename DoFHandler<dim>::active_cell_iterator &cell)\\n\\u00a0     {\\n\\u00a0       cell_index        = cell->active_cell_index();\\n\\u00a0       cell_L2_error_sqr = 0.0;\\n\\u00a0       cell_H1_error_sqr = 0.0;\\n\\u00a0       cell_stab_sqr     = 0.0;\\n\\u00a0     }\\n\\u00a0   };\\n\\u00a0 \\nDoFHandler::get_feconst FiniteElement< dim, spacedim > & get_fe(const types::fe_index index=0) const\\nFiniteElementData::n_dofs_per_cellunsigned int n_dofs_per_cell() const\\nFullMatrixDefinition full_matrix.h:79\\nVectorDefinition vector.h:120\\ncell_indexunsigned int cell_indexDefinition grid_tools_topology.cc:783\\nDoFHandler::active_cell_iteratortypename ActiveSelector::active_cell_iterator active_cell_iteratorDefinition dof_handler.h:440\\ninternal::reinitvoid reinit(MatrixBlock< MatrixType > &v, const BlockSparsityPattern &p)Definition matrix_block.h:617\\n Normal-gradient stabilization form of TraceFEM\\nThe following class corresponds to the stabilization form, its contribution to the global matrix and to the error. More specifically, the method needs_cell_worker() indicates whether the bilinear form of the stabilization, unlike the main bilinear form of Laplace-Beltrami operator, needs the bulk cell quadratures. The cell worker which is useful in an accumulation by MeshWorkers is provided by the assemble_cell_worker() method. The remaining method evaluate_cell_worker() computes the stabilization error for the solution \\\\(u_h\\\\), i.e \\\\(s_h(u_h,u_h)\\\\). Also note that the method needs_cell_worker() indicates that the assembly and the evaluation of the form does require a bulk cell quadrature. This methodology may be utilized in the MeshWorker. The stabilization scaling is specified by  \\\\(\\\\mathrm{stabilization\\\\_parameter}\\\\cdot\\n   h^\\\\mathrm{stabilization\\\\_exponent}\\\\). For elliptic problems with smooth solutions we can choose any \\\\(-1\\\\leq \\\\mathrm{stabilization\\\\_exponent} \\\\leq 1\\\\) and a sufficiently large \\\\(\\\\mathrm{stabilization\\\\_parameter}\\\\) that depends of \\\\(\\\\Gamma\\\\).\\n\\u00a0   template <int dim>\\n\\u00a0   class NormalGradientVolumeStabilization\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     NormalGradientVolumeStabilization()\\n\\u00a0       : stabilization_parameter(1.0)\\n\\u00a0       , stabilization_exponent(-1.0)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     bool needs_cell_worker() const\\n\\u00a0     {\\n\\u00a0       return true;\\n\\u00a0     }\\n\\u00a0 \\nWe define the stabilization form here assuming that ScratchData and CopyData arguments are initialized properly. The local contribution of the stabilization from this cell to the global matrix is given in assemble_cell_worker() and, later in evaluate_cell_worker(), the local bilinear form of the stabilization is evaluated on the solution. Note the gradients of the discrete level set are computed in the bulk cell quadrature points, which, upon normalization, give the discrete normal vector in a bulk cell.\\n\\u00a0     void assemble_cell_worker(\\n\\u00a0       VectorType                                           &level_set,\\n\\u00a0       const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0       ScratchData<dim>                                     &scratch_data,\\n\\u00a0       CopyData<dim>                                        &copy_data) const\\n\\u00a0     {\\n\\u00a0       const FEValues<dim> &fe_values = scratch_data.fe_values;\\n\\u00a0       const FEValues<dim> &level_set_fe_values =\\n\\u00a0         scratch_data.level_set_fe_values;\\n\\u00a0 \\n\\u00a0       const std::vector<double> &JxW_cell = fe_values.get_JxW_values();\\n\\u00a0 \\n\\u00a0       std::vector<Tensor<1, dim>> grad_level_set(\\n\\u00a0         level_set_fe_values.get_quadrature().size());\\n\\u00a0       level_set_fe_values.get_function_gradients(level_set, grad_level_set);\\n\\u00a0 \\n\\u00a0       const double factor =\\n\\u00a0         stabilization_parameter *\\n\\u00a0         std::pow(cell->minimum_vertex_distance(), stabilization_exponent);\\n\\u00a0       for (const unsigned int q : fe_values.quadrature_point_indices())\\n\\u00a0         {\\n\\u00a0           const Tensor<1, dim> &normal =\\n\\u00a0             grad_level_set[q] / grad_level_set[q].norm();\\n\\u00a0           for (const unsigned int i : fe_values.dof_indices())\\n\\u00a0             for (const unsigned int j : fe_values.dof_indices())\\n\\u00a0               copy_data.cell_matrix(i, j) +=\\n\\u00a0                 factor * (normal * fe_values.shape_grad(i, q)) *\\n\\u00a0                 (normal * fe_values.shape_grad(j, q)) * JxW_cell[q];\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     void evaluate_cell_worker(\\n\\u00a0       VectorType                                           &solution,\\n\\u00a0       VectorType                                           &level_set,\\n\\u00a0       const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0       ScratchData<dim>                                     &scratch_data,\\n\\u00a0       CopyDataError<dim>                                   &copy_data) const\\n\\u00a0     {\\n\\u00a0       double                     cell_stab_sqr = 0.0;\\n\\u00a0       const FEValues<dim>       &fe_values     = scratch_data.fe_values;\\n\\u00a0       const std::vector<double> &JxW_cell      = fe_values.get_JxW_values();\\n\\u00a0       const unsigned int n_q_points = fe_values.get_quadrature_points().size();\\n\\u00a0       const FEValues<dim> &level_set_fe_values =\\n\\u00a0         scratch_data.level_set_fe_values;\\n\\u00a0 \\n\\u00a0       std::vector<Tensor<1, dim>> level_set_grad(n_q_points);\\n\\u00a0       level_set_fe_values.get_function_gradients(level_set, level_set_grad);\\n\\u00a0 \\n\\u00a0       std::vector<Tensor<1, dim>> sol_grad(n_q_points);\\n\\u00a0       fe_values.get_function_gradients(solution, sol_grad);\\n\\u00a0 \\n\\u00a0       const double factor =\\n\\u00a0         stabilization_parameter *\\n\\u00a0         std::pow(cell->minimum_vertex_distance(), stabilization_exponent);\\n\\u00a0 \\n\\u00a0       for (const unsigned int q : fe_values.quadrature_point_indices())\\n\\u00a0         {\\n\\u00a0           const Tensor<1, dim> normal =\\n\\u00a0             level_set_grad[q] / level_set_grad[q].norm();\\n\\u00a0 \\n\\u00a0           const double stabilization_at_point = normal * sol_grad[q];\\n\\u00a0           cell_stab_sqr +=\\n\\u00a0             factor * Utilities::pow(stabilization_at_point, 2) * JxW_cell[q];\\n\\u00a0         }\\n\\u00a0       copy_data.cell_stab_sqr = cell_stab_sqr;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     const double stabilization_parameter;\\n\\u00a0     const double stabilization_exponent;\\n\\u00a0   };\\n\\u00a0 \\nFEValuesBase::get_JxW_valuesconst std::vector< double > & get_JxW_values() const\\nint\\nLocalIntegrators::Divergence::normdouble norm(const FEValuesBase< dim > &fe, const ArrayView< const std::vector< Tensor< 1, dim > > > &Du)Definition divergence.h:471\\n Laplace\\u2013Beltrami solver\\nThe main class whose method run() performs the computation. One may adjust main parameters of TraceFEM in the constructor. The other methods are discussed below.\\n\\u00a0   template <int dim>\\n\\u00a0   class LaplaceBeltramiSolver\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     LaplaceBeltramiSolver();\\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void make_grid();\\n\\u00a0 \\n\\u00a0     void localize_surface();\\n\\u00a0 \\n\\u00a0     void setup_discrete_level_set();\\n\\u00a0 \\n\\u00a0     void distribute_dofs();\\n\\u00a0 \\n\\u00a0     void initialize_matrices();\\n\\u00a0 \\n\\u00a0     void assemble_system();\\n\\u00a0 \\n\\u00a0     void solve();\\n\\u00a0 \\n\\u00a0     void mark_intersected();\\n\\u00a0 \\n\\u00a0     void refine_grid();\\n\\u00a0 \\n\\u00a0     void compute_errors();\\n\\u00a0 \\n\\u00a0     void output_level_set(unsigned int);\\n\\u00a0 \\n\\u00a0     void output_solution();\\n\\u00a0 \\n\\u00a0     MPI_Comm mpi_communicator;\\n\\u00a0 \\nMPI_Comm\\nThe surface of interest corresponds to the zero contour of the following exact level set function:\\n\\u00a0     const TamarindShape<dim> tamarind;\\n\\u00a0 \\nThe manufactured solution to the Laplace\\u2013Beltrami problem and the corresponding right-hand side:\\n\\u00a0     const AnalyticalSolution<dim> analytical_solution;\\n\\u00a0     const RightHandSide<dim>      right_hand_side;\\n\\u00a0 \\nThere is a single triangulation which is shared by the discretizations of the solution and of the level set.\\n\\u00a0     parallel::distributed::Triangulation<dim, dim> triangulation;\\n\\u00a0     ConditionalOStream                             pcout;\\n\\u00a0     TimerOutput                                    computing_timer;\\n\\u00a0 \\nConditionalOStreamDefinition conditional_ostream.h:80\\nTimerOutputDefinition timer.h:549\\nparallel::distributed::TriangulationDefinition tria.h:268\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\nWe need two separate FE spaces. The first manages the TraceFEM space which is active on intersected elements. The second manages the discrete level set function that describes the geometry of the surface. Also, the degrees of the FE spaces and the corresponding DoFHandler objects are given in the following:\\n\\u00a0     const unsigned int    fe_degree;\\n\\u00a0     hp::FECollection<dim> fe_collection;\\n\\u00a0     DoFHandler<dim>       dof_handler;\\n\\u00a0 \\n\\u00a0     const unsigned int level_set_fe_degree;\\n\\u00a0     const FE_Q<dim>    level_set_fe;\\n\\u00a0     DoFHandler<dim>    level_set_dof_handler;\\n\\u00a0 \\n\\u00a0     const MappingQ1<dim> mapping;\\n\\u00a0 \\nFE_QDefinition fe_q.h:554\\nMappingQ1Definition mapping_q1.h:55\\nSince we will adaptively refine the bulk triangulation, two constraints are needed: one for the solution space and another for the level set space.\\n\\u00a0     AffineConstraints<double> constraints;\\n\\u00a0     AffineConstraints<double> level_set_constraints;\\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nDiscrete vectors initialized with dof_handler and level_set_dof_handler.\\n\\u00a0     VectorType    completely_distributed_solution;\\n\\u00a0     VectorType    locally_relevant_solution;\\n\\u00a0     VectorType    locally_relevant_exact;\\n\\u00a0     VectorType    level_set;\\n\\u00a0     Vector<float> active_fe_indicator;\\n\\u00a0 \\nThe following NonMatching::MeshClassifier object is used to separate intersected elements and non-intersected ones. We will then use different finite elements from an hp::FECollection for these two categories:\\n\\u00a0     NonMatching::MeshClassifier<dim> mesh_classifier;\\n\\u00a0 \\nThe first bulk quadrature is required for the for TraceFEM stabilization, while the integration over implicit surface is based on the last, one-dimensional rule.\\n\\u00a0     const QGauss<dim> cell_quadrature;\\n\\u00a0     const QGauss<1>   quadrature_1D;\\n\\u00a0 \\nQGaussDefinition quadrature_lib.h:40\\nAny TraceFEM needs a stabilization, and we choose the normal-gradient, volume stabilization.\\n\\u00a0     const NormalGradientVolumeStabilization<dim> stabilization_scheme;\\n\\u00a0 \\nDiscrete right-hand side and the final matrix corresponding to dof_handler.\\n\\u00a0     VectorType      global_rhs;\\n\\u00a0     MatrixType      global_matrix;\\n\\u00a0     SparsityPattern sparsity_pattern;\\n\\u00a0     IndexSet        locally_owned_dofs;\\n\\u00a0     IndexSet        locally_relevant_dofs;\\n\\u00a0 \\nIndexSetDefinition index_set.h:70\\nSparsityPatternDefinition sparsity_pattern.h:343\\nDepending on the type of the quadrature, surface, face or volume, we need to define different update flags.\\n\\u00a0     NonMatching::RegionUpdateFlags surface_update_flags;\\n\\u00a0 \\nThe following variables are used to display the results of the convergence test:\\n\\u00a0     ConvergenceTable convergence_table;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   LaplaceBeltramiSolver<dim>::LaplaceBeltramiSolver()\\n\\u00a0     : mpi_communicator(MPI_COMM_WORLD)\\n\\u00a0     , tamarind()\\n\\u00a0     , analytical_solution()\\n\\u00a0     , right_hand_side()\\n\\u00a0     , triangulation(mpi_communicator)\\n\\u00a0     , pcout(std::cout,\\n\\u00a0             (Utilities::MPI::this_mpi_process(mpi_communicator) == 0))\\n\\u00a0     , computing_timer(mpi_communicator,\\n\\u00a0                       pcout,\\n\\u00a0                       TimerOutput::never,\\n\\u00a0                       TimerOutput::wall_times)\\n\\u00a0     , fe_degree(1)\\n\\u00a0     , fe_collection(FE_Q<dim>(fe_degree), FE_Nothing<dim>())\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0     , level_set_fe_degree(1)\\n\\u00a0     , level_set_fe(level_set_fe_degree)\\n\\u00a0     , level_set_dof_handler(triangulation)\\n\\u00a0     , mapping()\\n\\u00a0     , mesh_classifier(level_set_dof_handler, level_set)\\n\\u00a0     , cell_quadrature(fe_degree + 1)\\n\\u00a0     , quadrature_1D(fe_degree + 1)\\n\\u00a0     , stabilization_scheme()\\n\\u00a0   {\\n\\u00a0     surface_update_flags.surface =\\n\\u00a0       update_values | update_gradients | update_JxW_values |\\n\\u00a0       update_quadrature_points | update_normal_vectors;\\n\\u00a0   }\\n\\u00a0 \\nConvergenceTableDefinition convergence_table.h:64\\nFE_NothingDefinition fe_nothing.h:131\\nupdate_normal_vectors@ update_normal_vectorsNormal vectors.Definition fe_update_flags.h:141\\nInitializeLibrary::MPI@ MPI\\nUtilitiesDefinition communication_pattern_base.h:30\\nstdSTL namespace.\\n Geometric approximation\\nLet us start with a function that creates the background mesh, using a domain size chosen to avoid situations in which level set function vanishes at mesh vertices. The initial refinement helps the level set to approximate the surface meaningfully.\\nIn following next method we construct the discrete level set and determine which cells are intersected. Note that all cells, intersected and non-intersected, have a corresponding active_fe_indicator. Similarly, the exact level set function is approximated on the whole triangulation and postprocessed afterward resulting on a surface approximation with no gaps.\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceBeltramiSolver<dim>::make_grid()\\n\\u00a0   {\\n\\u00a0     pcout << \\\"Creating background mesh...\\\"\\n\\u00a0           << \\\"\\\\n\\\"\\n\\u00a0           << std::flush;\\n\\u00a0     const double cube_side = 2.008901281;\\n\\u00a0     GridGenerator::hyper_cube(triangulation, -cube_side, cube_side);\\n\\u00a0     triangulation.refine_global(3);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceBeltramiSolver<dim>::setup_discrete_level_set()\\n\\u00a0   {\\n\\u00a0     pcout\\n\\u00a0       << \\\"Setting up discrete level set function and reclassifying cells... \\\"\\n\\u00a0       << \\\"\\\\n\\\"\\n\\u00a0       << std::flush;\\n\\u00a0     TimerOutput::Scope t(computing_timer, \\\"setup_level_set\\\");\\n\\u00a0 \\n\\u00a0     active_fe_indicator.reinit(triangulation.n_active_cells());\\n\\u00a0     level_set_dof_handler.distribute_dofs(level_set_fe);\\n\\u00a0     level_set_constraints.clear();\\n\\u00a0     const IndexSet level_set_locally_relevant_dofs =\\n\\u00a0       DoFTools::extract_locally_relevant_dofs(level_set_dof_handler);\\n\\u00a0     level_set_constraints.reinit(level_set_locally_relevant_dofs);\\n\\u00a0     DoFTools::make_hanging_node_constraints(level_set_dof_handler,\\n\\u00a0                                             level_set_constraints);\\n\\u00a0     level_set_constraints.close();\\n\\u00a0 \\nTimerOutput::ScopeDefinition timer.h:557\\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nDoFTools::make_hanging_node_constraintsvoid make_hanging_node_constraints(const DoFHandler< dim, spacedim > &dof_handler, AffineConstraints< number > &constraints)Definition dof_tools_constraints.cc:3073\\nDoFTools::extract_locally_relevant_dofsIndexSet extract_locally_relevant_dofs(const DoFHandler< dim, spacedim > &dof_handler)Definition dof_tools.cc:1164\\nGridGenerator::hyper_cubevoid hyper_cube(Triangulation< dim, spacedim > &tria, const double left=0., const double right=1., const bool colorize=false)\\nHere is where the geometric information enters the code. Next, using the discrete level set, we mark the cell which are intersected by its zero contour. Finally, once the triangulation's cells are classified, we determine which cells are active.\\n\\u00a0     VectorType tmp_sol(level_set_dof_handler.locally_owned_dofs(),\\n\\u00a0                        mpi_communicator);\\n\\u00a0     VectorTools::interpolate(level_set_dof_handler, tamarind, tmp_sol);\\n\\u00a0     level_set_constraints.distribute(tmp_sol);\\n\\u00a0 \\n\\u00a0     level_set.reinit(level_set_locally_relevant_dofs,\\n\\u00a0                      level_set_dof_handler.locally_owned_dofs(),\\n\\u00a0                      mpi_communicator);\\n\\u00a0     level_set = tmp_sol;\\n\\u00a0 \\n\\u00a0     mesh_classifier.reclassify();\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators() |\\n\\u00a0                               IteratorFilters::LocallyOwnedCell())\\n\\u00a0       {\\n\\u00a0         if (mesh_classifier.location_to_level_set(cell) ==\\n\\u00a0             NonMatching::LocationToLevelSet::intersected)\\n\\u00a0           cell->set_active_fe_index(\\n\\u00a0             static_cast<types::fe_index>(ActiveFEIndex::lagrange));\\n\\u00a0         else\\n\\u00a0           cell->set_active_fe_index(\\n\\u00a0             static_cast<types::fe_index>(ActiveFEIndex::nothing));\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\nIteratorFiltersDefinition filtered_iterator.h:54\\nNonMatchingDefinition mapping.h:54\\nVectorTools::interpolatevoid interpolate(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const Function< spacedim, typename VectorType::value_type > &function, VectorType &vec, const ComponentMask &component_mask={})\\nThe method fills in the indicator telling which cells are intersected. It is used in the adaptive refinement near the surface.\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceBeltramiSolver<dim>::mark_intersected()\\n\\u00a0   {\\n\\u00a0     pcout << \\\"Determining cells with active FE index...\\\"\\n\\u00a0           << \\\"\\\\n\\\"\\n\\u00a0           << std::flush;\\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators() |\\n\\u00a0                               IteratorFilters::LocallyOwnedCell())\\n\\u00a0       {\\n\\u00a0         if (mesh_classifier.location_to_level_set(cell) ==\\n\\u00a0             NonMatching::LocationToLevelSet::intersected)\\n\\u00a0           active_fe_indicator[cell->active_cell_index()] = 1.0;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nWe refine only intersected cells with active_fe_indicator=1. We are calling GridRefinement::refine_and_coarsen_fixed_fraction() instead of the GridRefinement::refine_and_coarsen_fixed_number() function called in most other tutorials because the number of non-intersected cells also grows interfering with the number of active, intersected cells.\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceBeltramiSolver<dim>::refine_grid()\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope t(computing_timer, \\\"refine\\\");\\n\\u00a0     pcout << \\\"Refining near surface...\\\"\\n\\u00a0           << \\\"\\\\n\\\"\\n\\u00a0           << std::flush;\\n\\u00a0     parallel::distributed::GridRefinement::refine_and_coarsen_fixed_fraction(\\n\\u00a0       triangulation, active_fe_indicator, 1.0, 0.0);\\n\\u00a0 \\n\\u00a0     triangulation.execute_coarsening_and_refinement();\\n\\u00a0   }\\n\\u00a0 \\nparallel::distributed::Triangulation::execute_coarsening_and_refinementvirtual void execute_coarsening_and_refinement() overrideDefinition tria.cc:3320\\nparallel::distributed::GridRefinement::refine_and_coarsen_fixed_fractionvoid refine_and_coarsen_fixed_fraction(::Triangulation< dim, spacedim > &tria, const ::Vector< Number > &criteria, const double top_fraction_of_error, const double bottom_fraction_of_error, const VectorTools::NormType norm_type=VectorTools::L1_norm)Definition grid_refinement.cc:576\\nAs the surface is properly approximated by several adaptive steps, we may now distribute the degrees of freedom on cells which are intersected by the discrete approximation. Next, we initialize matrices for active DoFs and apply the constraints for the solution.\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceBeltramiSolver<dim>::distribute_dofs()\\n\\u00a0   {\\n\\u00a0     pcout << \\\"Distributing degrees of freedom... \\\"\\n\\u00a0           << \\\"\\\\n\\\"\\n\\u00a0           << std::flush;\\n\\u00a0     dof_handler.distribute_dofs(fe_collection);\\n\\u00a0     locally_owned_dofs = dof_handler.locally_owned_dofs();\\n\\u00a0     locally_relevant_dofs =\\n\\u00a0       DoFTools::extract_locally_relevant_dofs(dof_handler);\\n\\u00a0     completely_distributed_solution.reinit(dof_handler.locally_owned_dofs(),\\n\\u00a0                                            mpi_communicator);\\n\\u00a0     locally_relevant_solution.reinit(locally_owned_dofs,\\n\\u00a0                                      locally_relevant_dofs,\\n\\u00a0                                      mpi_communicator);\\n\\u00a0     global_rhs.reinit(locally_owned_dofs, mpi_communicator);\\n\\u00a0 \\n\\u00a0     const unsigned int dof_handler_size = dof_handler.n_dofs();\\n\\u00a0     const unsigned int level_set_dof_handler_size =\\n\\u00a0       level_set_dof_handler.n_dofs();\\n\\u00a0 \\n\\u00a0     convergence_table.add_value(\\\"LevelSet dofs\\\", level_set_dof_handler_size);\\n\\u00a0     convergence_table.evaluate_convergence_rates(\\n\\u00a0       \\\"LevelSet dofs\\\", ConvergenceTable::reduction_rate_log2);\\n\\u00a0 \\n\\u00a0     convergence_table.add_value(\\\"Active dofs\\\", dof_handler_size);\\n\\u00a0     convergence_table.evaluate_convergence_rates(\\n\\u00a0       \\\"Active dofs\\\", ConvergenceTable::reduction_rate_log2);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceBeltramiSolver<dim>::initialize_matrices()\\n\\u00a0   {\\n\\u00a0     pcout << \\\"Initializing the matrix... \\\"\\n\\u00a0           << \\\"\\\\n\\\"\\n\\u00a0           << std::flush;\\n\\u00a0 \\n\\u00a0     DynamicSparsityPattern dsp(dof_handler.n_dofs(),\\n\\u00a0                                dof_handler.n_dofs(),\\n\\u00a0                                locally_relevant_dofs);\\n\\u00a0     constraints.reinit(locally_owned_dofs, locally_relevant_dofs);\\n\\u00a0 \\n\\u00a0     DoFTools::make_hanging_node_constraints(dof_handler, constraints);\\n\\u00a0     constraints.close();\\n\\u00a0     DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints);\\n\\u00a0 \\n\\u00a0     SparsityTools::distribute_sparsity_pattern(dsp,\\n\\u00a0                                                locally_owned_dofs,\\n\\u00a0                                                mpi_communicator,\\n\\u00a0                                                locally_relevant_dofs);\\n\\u00a0     global_matrix.reinit(locally_owned_dofs,\\n\\u00a0                          locally_owned_dofs,\\n\\u00a0                          dsp,\\n\\u00a0                          mpi_communicator);\\n\\u00a0   }\\n\\u00a0 \\nConvergenceTable::reduction_rate_log2@ reduction_rate_log2Definition convergence_table.h:88\\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nSparsityTools::distribute_sparsity_patternvoid distribute_sparsity_pattern(DynamicSparsityPattern &dsp, const IndexSet &locally_owned_rows, const MPI_Comm mpi_comm, const IndexSet &locally_relevant_rows)Definition sparsity_tools.cc:1020\\n Assembly and surface accumulation\\nWe use a MeshWorker to assemble the linear problem efficiently. This cell worker does not do anything for non-intersected cells.\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceBeltramiSolver<dim>::assemble_system()\\n\\u00a0   {\\n\\u00a0     pcout << \\\"Assembling... \\\"\\n\\u00a0           << \\\"\\\\n\\\"\\n\\u00a0           << std::flush;\\n\\u00a0     TimerOutput::Scope t(computing_timer, \\\"assembly\\\");\\n\\u00a0 \\n\\u00a0     const auto cell_worker =\\n\\u00a0       [&](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0           ScratchData<dim>                                     &scratch_data,\\n\\u00a0           CopyData<dim>                                        &copy_data) {\\n\\u00a0         if (mesh_classifier.location_to_level_set(cell) ==\\n\\u00a0               NonMatching::LocationToLevelSet::intersected &&\\n\\u00a0             cell->is_locally_owned())\\n\\u00a0           {\\nNonMatching::LocationToLevelSet::intersected@ intersected\\nOnce we know that the cell is intersected, we construct the unfitted quadratures for the solutions FE space on the cell.\\n\\u00a0             scratch_data.non_matching_fe_values.reinit(cell);\\n\\u00a0             copy_data.reinit(cell);\\n\\u00a0             copy_data.cell_matrix = 0;\\n\\u00a0             copy_data.cell_rhs    = 0;\\n\\u00a0             const std::optional<NonMatching::FEImmersedSurfaceValues<dim>>\\n\\u00a0               &surface_fe_values =\\n\\u00a0                 scratch_data.non_matching_fe_values.get_surface_fe_values();\\n\\u00a0             const std::vector<double> &JxW_surface =\\n\\u00a0               surface_fe_values->get_JxW_values();\\n\\u00a0 \\nThe accumulation of the surface integrals, including the forcing, is performed here.\\n\\u00a0             for (unsigned int q : surface_fe_values->quadrature_point_indices())\\n\\u00a0               {\\n\\u00a0                 const Tensor<1, dim> &normal =\\n\\u00a0                   surface_fe_values->normal_vector(q);\\n\\u00a0 \\n\\u00a0                 for (const unsigned int i : surface_fe_values->dof_indices())\\n\\u00a0                   {\\n\\u00a0                     copy_data.cell_rhs(i) +=\\n\\u00a0                       surface_fe_values->shape_value(i, q) *\\n\\u00a0                       right_hand_side.value(\\n\\u00a0                         surface_fe_values->quadrature_point(q)) *\\n\\u00a0                       JxW_surface[q];\\n\\u00a0 \\n\\u00a0                     for (const unsigned int j :\\n\\u00a0                          surface_fe_values->dof_indices())\\n\\u00a0                       {\\n\\u00a0                         copy_data.cell_matrix(i, j) +=\\n\\u00a0                           (surface_fe_values->shape_value(i, q) *\\n\\u00a0                            surface_fe_values->shape_value(j, q)) *\\n\\u00a0                           JxW_surface[q];\\n\\u00a0                         copy_data.cell_matrix(i, j) +=\\n\\u00a0                           (surface_fe_values->shape_grad(i, q) -\\n\\u00a0                            (normal * surface_fe_values->shape_grad(i, q)) *\\n\\u00a0                              normal) *\\n\\u00a0                           (surface_fe_values->shape_grad(j, q) -\\n\\u00a0                            (normal * surface_fe_values->shape_grad(j, q)) *\\n\\u00a0                              normal) *\\n\\u00a0                           JxW_surface[q];\\n\\u00a0                       }\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0 \\nThe normal-gradient volume stabilization form needs a bulk cell integration while other types of stabilization may need face quadratures, for example. So we check it first. The cell was provided by the solution's DoFHandler, so we recast it as a level set's DoFHandler cell. However, it is the same geometric entity of the common triangulation.\\n\\u00a0             if (stabilization_scheme.needs_cell_worker())\\n\\u00a0               {\\n\\u00a0                 typename DoFHandler<dim>::active_cell_iterator level_set_cell =\\n\\u00a0                   cell->as_dof_handler_iterator(level_set_dof_handler);\\n\\u00a0                 scratch_data.fe_values.reinit(cell);\\n\\u00a0                 scratch_data.level_set_fe_values.reinit(level_set_cell);\\n\\u00a0                 stabilization_scheme.assemble_cell_worker(level_set,\\n\\u00a0                                                           cell,\\n\\u00a0                                                           scratch_data,\\n\\u00a0                                                           copy_data);\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0       };\\n\\u00a0 \\nNext, the copier worker distributes the local contributions from the CopyData taking into account the constraints. Finally, the MeshWorker goes over all cells provided by the solutions' DoFHandler. Note that this includes non-intersected cells as well, but the cell worker does nothing on them.\\n\\u00a0     const auto copier = [&](const CopyData<dim> &c) {\\n\\u00a0       constraints.distribute_local_to_global(c.cell_matrix,\\n\\u00a0                                              c.cell_rhs,\\n\\u00a0                                              c.local_dof_indices,\\n\\u00a0                                              global_matrix,\\n\\u00a0                                              global_rhs);\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     ScratchData<dim> scratch_data(mapping,\\n\\u00a0                                   fe_collection,\\n\\u00a0                                   mesh_classifier,\\n\\u00a0                                   level_set_dof_handler,\\n\\u00a0                                   level_set,\\n\\u00a0                                   surface_update_flags,\\n\\u00a0                                   cell_quadrature,\\n\\u00a0                                   quadrature_1D);\\n\\u00a0 \\n\\u00a0     CopyData<dim> copy_data;\\n\\u00a0 \\n\\u00a0     MeshWorker::mesh_loop(dof_handler.begin_active(),\\n\\u00a0                           dof_handler.end(),\\n\\u00a0                           cell_worker,\\n\\u00a0                           copier,\\n\\u00a0                           scratch_data,\\n\\u00a0                           copy_data,\\n\\u00a0                           MeshWorker::assemble_own_cells);\\n\\u00a0 \\n\\u00a0     global_matrix.compress(VectorOperation::add);\\n\\u00a0     global_rhs.compress(VectorOperation::add);\\n\\u00a0   }\\n\\u00a0 \\nMeshWorker::mesh_loopvoid mesh_loop(const CellIteratorType &begin, const CellIteratorType &end, const CellWorkerFunctionType &cell_worker, const CopierType &copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const AssembleFlags flags=assemble_own_cells, const BoundaryWorkerFunctionType &boundary_worker=BoundaryWorkerFunctionType(), const FaceWorkerFunctionType &face_worker=FaceWorkerFunctionType(), const unsigned int queue_length=2 *MultithreadInfo::n_threads(), const unsigned int chunk_size=8)Definition mesh_loop.h:281\\nMeshWorker::assemble_own_cells@ assemble_own_cellsDefinition assemble_flags.h:49\\nVectorOperation::add@ addDefinition vector_operation.h:53\\nIn the following, we solve the resulting linear system of equations. We either use a direct solver or AMG.\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceBeltramiSolver<dim>::solve()\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope t(computing_timer, \\\"solve\\\");\\n\\u00a0     bool               apply_direct_solver = false;\\n\\u00a0     const double       relative_error      = 1e-9 * global_rhs.l2_norm();\\n\\u00a0     unsigned int       n_iterations        = 0;\\n\\u00a0     if (apply_direct_solver)\\n\\u00a0       {\\n\\u00a0         pcout << \\\"Solving directly... \\\" << '\\\\n' << std::flush;\\n\\u00a0         SolverControl solver_control(100, relative_error);\\n\\u00a0         TrilinosWrappers::SolverDirect::AdditionalData data;\\n\\u00a0         TrilinosWrappers::SolverDirect trilinos(solver_control, data);\\n\\u00a0         trilinos.solve(global_matrix,\\n\\u00a0                        completely_distributed_solution,\\n\\u00a0                        global_rhs);\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       {\\n\\u00a0         Timer timer;\\n\\u00a0         pcout << \\\"Solving with AMG... \\\"\\n\\u00a0               << \\\"\\\\n\\\"\\n\\u00a0               << std::flush;\\n\\u00a0         const unsigned int max_iterations = 500;\\n\\u00a0         SolverControl      solver_control(max_iterations, relative_error);\\n\\u00a0         std::vector<std::vector<bool>> constant_modes;\\n\\u00a0         DoFTools::extract_constant_modes(dof_handler,\\n\\u00a0                                          ComponentMask(),\\n\\u00a0                                          constant_modes);\\n\\u00a0         TrilinosWrappers::PreconditionAMG preconditioner_stiffness;\\n\\u00a0         TrilinosWrappers::PreconditionAMG::AdditionalData Amg_data;\\n\\u00a0         Amg_data.constant_modes        = constant_modes;\\n\\u00a0         Amg_data.elliptic              = true;\\n\\u00a0         Amg_data.higher_order_elements = false;\\n\\u00a0         Amg_data.smoother_sweeps       = 2;\\n\\u00a0         Amg_data.aggregation_threshold = 0.02;\\n\\u00a0         Amg_data.output_details        = true;\\n\\u00a0         preconditioner_stiffness.initialize(global_matrix);\\n\\u00a0 \\n\\u00a0         SolverCG<VectorType> cg(solver_control);\\n\\u00a0         cg.solve(global_matrix,\\n\\u00a0                  completely_distributed_solution,\\n\\u00a0                  global_rhs,\\n\\u00a0                  preconditioner_stiffness);\\n\\u00a0         n_iterations = solver_control.last_step();\\n\\u00a0       }\\n\\u00a0     constraints.distribute(completely_distributed_solution);\\n\\u00a0     locally_relevant_solution = completely_distributed_solution;\\n\\u00a0 \\n\\u00a0     convergence_table.add_value(\\\"Iterations\\\", n_iterations);\\n\\u00a0   }\\n\\u00a0 \\nComponentMaskDefinition component_mask.h:81\\nSolverCGDefinition solver_cg.h:179\\nSolverControlDefinition solver_control.h:67\\nTimerDefinition timer.h:117\\nTrilinosWrappers::PreconditionAMGDefinition trilinos_precondition.h:1321\\nTrilinosWrappers::SolverDirectDefinition trilinos_solver.h:486\\nDoFTools::extract_constant_modesvoid extract_constant_modes(const DoFHandler< dim, spacedim > &dof_handler, const ComponentMask &component_mask, std::vector< std::vector< bool > > &constant_modes)Definition dof_tools.cc:1416\\nTrilinosWrappers::PreconditionAMG::AdditionalDataDefinition trilinos_precondition.h:1330\\nTrilinosWrappers::PreconditionAMG::AdditionalData::constant_modesstd::vector< std::vector< bool > > constant_modesDefinition trilinos_precondition.h:1500\\nTrilinosWrappers::SolverDirect::AdditionalDataDefinition trilinos_solver.h:493\\nSimilarly to what we do in the assembly() function, a MeshWorker is used to accumulate errors including the stabilization term. At the end, we collect the results, and print them out.\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceBeltramiSolver<dim>::compute_errors()\\n\\u00a0   {\\n\\u00a0     pcout << \\\"Evaluating errors on the surface...\\\"\\n\\u00a0           << \\\"\\\\n\\\"\\n\\u00a0           << std::flush;\\n\\u00a0     TimerOutput::Scope t(computing_timer, \\\"eval_errors\\\");\\n\\u00a0     double             error_L2_sqr   = 0.0;\\n\\u00a0     double             error_H1_sqr   = 0.0;\\n\\u00a0     double             error_stab_sqr = 0.0;\\n\\u00a0     const auto         cell_worker    = [&](const auto &cell,\\n\\u00a0                                  auto       &scratch_data,\\n\\u00a0                                  auto       &copy_data) {\\n\\u00a0       if (mesh_classifier.location_to_level_set(cell) ==\\n\\u00a0             NonMatching::LocationToLevelSet::intersected &&\\n\\u00a0           cell->is_locally_owned())\\n\\u00a0         {\\n\\u00a0           double cell_L2_error_sqr = 0.0;\\n\\u00a0           double cell_H1_error_sqr = 0.0;\\n\\u00a0 \\n\\u00a0           copy_data.reinit(cell);\\n\\u00a0           scratch_data.non_matching_fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0           const std::optional<NonMatching::FEImmersedSurfaceValues<dim>>\\n\\u00a0             &surface_fe_values =\\n\\u00a0               scratch_data.non_matching_fe_values.get_surface_fe_values();\\n\\u00a0           const std::vector<double> &JxW_surface =\\n\\u00a0             surface_fe_values->get_JxW_values();\\n\\u00a0           const unsigned int n_q_points =\\n\\u00a0             surface_fe_values->n_quadrature_points;\\n\\u00a0 \\n\\u00a0           std::vector<double> sol(n_q_points);\\n\\u00a0           surface_fe_values->get_function_values(locally_relevant_solution,\\n\\u00a0                                                  sol);\\n\\u00a0 \\n\\u00a0           std::vector<Tensor<1, dim>> sol_grad(n_q_points);\\n\\u00a0           surface_fe_values->get_function_gradients(locally_relevant_solution,\\n\\u00a0                                                     sol_grad);\\n\\u00a0 \\n\\u00a0           for (const unsigned int q :\\n\\u00a0                surface_fe_values->quadrature_point_indices())\\n\\u00a0             {\\n\\u00a0               const Point<dim> &point = surface_fe_values->quadrature_point(q);\\n\\u00a0               const Tensor<1, dim> &normal =\\n\\u00a0                 surface_fe_values->normal_vector(q);\\n\\u00a0               const double error_at_point =\\n\\u00a0                 sol.at(q) - analytical_solution.value(point);\\n\\u00a0               const Tensor<1, dim> grad_error_at_point =\\n\\u00a0                 (sol_grad.at(q) - (normal * sol_grad.at(q)) * normal -\\n\\u00a0                  analytical_solution.gradient(point));\\n\\u00a0 \\n\\u00a0               cell_L2_error_sqr +=\\n\\u00a0                 Utilities::pow(error_at_point, 2) * JxW_surface[q];\\n\\u00a0               cell_H1_error_sqr +=\\n\\u00a0                 grad_error_at_point * grad_error_at_point * JxW_surface[q];\\n\\u00a0             }\\n\\u00a0           copy_data.cell_L2_error_sqr = cell_L2_error_sqr;\\n\\u00a0           copy_data.cell_H1_error_sqr = cell_H1_error_sqr;\\n\\u00a0 \\n\\u00a0           if (stabilization_scheme.needs_cell_worker())\\n\\u00a0             {\\n\\u00a0               typename DoFHandler<dim>::active_cell_iterator level_set_cell =\\n\\u00a0                 cell->as_dof_handler_iterator(level_set_dof_handler);\\n\\u00a0               scratch_data.fe_values.reinit(cell);\\n\\u00a0               scratch_data.level_set_fe_values.reinit(level_set_cell);\\n\\u00a0               stabilization_scheme.evaluate_cell_worker(\\n\\u00a0                 locally_relevant_solution,\\n\\u00a0                 level_set,\\n\\u00a0                 cell,\\n\\u00a0                 scratch_data,\\n\\u00a0                 copy_data);\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     const auto copier = [&](const auto &copy_data) {\\n\\u00a0       if (copy_data.cell_index < active_fe_indicator.size())\\n\\u00a0         {\\n\\u00a0           error_L2_sqr += copy_data.cell_L2_error_sqr;\\n\\u00a0           error_H1_sqr += copy_data.cell_H1_error_sqr;\\n\\u00a0           error_stab_sqr += copy_data.cell_stab_sqr;\\n\\u00a0         }\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     ScratchData<dim> scratch_data(mapping,\\n\\u00a0                                   fe_collection,\\n\\u00a0                                   mesh_classifier,\\n\\u00a0                                   level_set_dof_handler,\\n\\u00a0                                   level_set,\\n\\u00a0                                   surface_update_flags,\\n\\u00a0                                   cell_quadrature,\\n\\u00a0                                   quadrature_1D);\\n\\u00a0 \\n\\u00a0     CopyDataError<dim> copy_data;\\n\\u00a0 \\n\\u00a0     MeshWorker::mesh_loop(dof_handler.begin_active(),\\n\\u00a0                           dof_handler.end(),\\n\\u00a0                           cell_worker,\\n\\u00a0                           copier,\\n\\u00a0                           scratch_data,\\n\\u00a0                           copy_data,\\n\\u00a0                           MeshWorker::assemble_own_cells);\\n\\u00a0 \\n\\u00a0     const double error_L2 =\\n\\u00a0       std::sqrt(Utilities::MPI::sum(error_L2_sqr, mpi_communicator));\\n\\u00a0     const double error_semiH1 =\\n\\u00a0       std::sqrt(Utilities::MPI::sum(error_H1_sqr, mpi_communicator));\\n\\u00a0     const double error_stab =\\n\\u00a0       std::sqrt(Utilities::MPI::sum(error_stab_sqr, mpi_communicator));\\n\\u00a0 \\n\\u00a0     convergence_table.add_value(\\\"L2 Error\\\", error_L2);\\n\\u00a0     convergence_table.evaluate_convergence_rates(\\n\\u00a0       \\\"L2 Error\\\", ConvergenceTable::reduction_rate_log2);\\n\\u00a0     convergence_table.set_scientific(\\\"L2 Error\\\", true);\\n\\u00a0 \\n\\u00a0     convergence_table.add_value(\\\"H1 error\\\", error_semiH1);\\n\\u00a0     convergence_table.evaluate_convergence_rates(\\n\\u00a0       \\\"H1 error\\\", ConvergenceTable::reduction_rate_log2);\\n\\u00a0     convergence_table.set_scientific(\\\"H1 error\\\", true);\\n\\u00a0 \\n\\u00a0     convergence_table.add_value(\\\"Stab norm\\\", error_stab);\\n\\u00a0     convergence_table.evaluate_convergence_rates(\\n\\u00a0       \\\"Stab norm\\\", ConvergenceTable::reduction_rate_log2);\\n\\u00a0     convergence_table.set_scientific(\\\"Stab norm\\\", true);\\n\\u00a0   }\\n\\u00a0 \\nUtilities::MPI::sumT sum(const T &t, const MPI_Comm mpi_communicator)\\nstd::sqrt::VectorizedArray< Number, width > sqrt(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6869\\nThe following two methods perform VTK output of the preliminary mesh refinements for the geometry approximation and of the TraceFEM solution. The important difference between the two is that the non-intersected cells are excluded from the output saving considerable amount of time and storage.\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceBeltramiSolver<dim>::output_level_set(const unsigned int cycle)\\n\\u00a0   {\\n\\u00a0     pcout << \\\"Writing vtu file for surface... \\\" << '\\\\n' << std::flush;\\n\\u00a0     TimerOutput::Scope t(computing_timer, \\\"output_level_set\\\");\\n\\u00a0     DataOut<dim>       data_out;\\n\\u00a0     data_out.add_data_vector(level_set_dof_handler, level_set, \\\"level_set\\\");\\n\\u00a0     data_out.add_data_vector(active_fe_indicator, \\\"ref_indicator\\\");\\n\\u00a0     data_out.build_patches();\\n\\u00a0 \\n\\u00a0     data_out.write_vtu_in_parallel(\\\"surface_\\\" + std::to_string(cycle) + \\\".vtu\\\",\\n\\u00a0                                    mpi_communicator);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceBeltramiSolver<dim>::output_solution()\\n\\u00a0   {\\n\\u00a0     pcout << \\\"Writing vtu file... \\\" << std::flush;\\n\\u00a0     TimerOutput::Scope t(computing_timer, \\\"output_solution\\\");\\n\\u00a0     Vector<double>     exact(dof_handler.locally_owned_dofs().size());\\n\\u00a0 \\n\\u00a0     VectorTools::interpolate(dof_handler, analytical_solution, exact);\\n\\u00a0     DataOut<dim> data_out;\\n\\u00a0     data_out.add_data_vector(dof_handler,\\n\\u00a0                              locally_relevant_solution,\\n\\u00a0                              \\\"solution\\\");\\n\\u00a0     data_out.add_data_vector(dof_handler, exact, \\\"exact\\\");\\n\\u00a0     data_out.add_data_vector(level_set_dof_handler, level_set, \\\"level_set\\\");\\n\\u00a0 \\n\\u00a0     data_out.set_cell_selection(\\n\\u00a0       [this](const typename Triangulation<dim>::cell_iterator &cell) {\\n\\u00a0         return cell->is_active() && cell->is_locally_owned() &&\\n\\u00a0                mesh_classifier.location_to_level_set(cell) ==\\n\\u00a0                  NonMatching::LocationToLevelSet::intersected;\\n\\u00a0       });\\n\\u00a0     data_out.build_patches();\\n\\u00a0 \\n\\u00a0     data_out.write_vtu_in_parallel(\\\"solution.vtu\\\", mpi_communicator);\\n\\u00a0   }\\n\\u00a0 \\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOutDefinition data_out.h:147\\nTriaIteratorDefinition tria_iterator.h:574\\nThe method localize_surface() generates iteratively a surface approximation as described above. Once the surface approximation is constructed, the main logic of the solver is executed as presented in the method run().\\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceBeltramiSolver<dim>::localize_surface()\\n\\u00a0   {\\n\\u00a0     unsigned int preliminary_levels = 3;\\n\\u00a0     for (unsigned int localization_cycle = 0;\\n\\u00a0          localization_cycle < preliminary_levels;\\n\\u00a0          ++localization_cycle)\\n\\u00a0       {\\n\\u00a0         pcout << std::endl\\n\\u00a0               << \\\"Preliminary refinement #\\\" << localization_cycle << std::endl;\\n\\u00a0         setup_discrete_level_set();\\n\\u00a0         mark_intersected();\\n\\u00a0         output_level_set(localization_cycle);\\n\\u00a0         refine_grid();\\n\\u00a0       }\\n\\u00a0     computing_timer.reset();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void LaplaceBeltramiSolver<dim>::run()\\n\\u00a0   {\\n\\u00a0     make_grid();\\n\\u00a0     localize_surface();\\n\\u00a0     const unsigned int convergence_levels = 3;\\n\\u00a0     for (unsigned int cycle = 0; cycle < convergence_levels; ++cycle)\\n\\u00a0       {\\n\\u00a0         pcout << std::endl << \\\"Convergence refinement #\\\" << cycle << std::endl;\\n\\u00a0         setup_discrete_level_set();\\n\\u00a0         distribute_dofs();\\n\\u00a0         initialize_matrices();\\n\\u00a0         assemble_system();\\n\\u00a0         solve();\\n\\u00a0         compute_errors();\\n\\u00a0         if (Utilities::MPI::this_mpi_process(mpi_communicator) == 0)\\n\\u00a0           convergence_table.write_text(pcout.get_stream());\\n\\u00a0 \\n\\u00a0         computing_timer.print_summary();\\n\\u00a0         computing_timer.reset();\\n\\u00a0         if (cycle < convergence_levels - 1)\\n\\u00a0           {\\n\\u00a0             mark_intersected();\\n\\u00a0             refine_grid();\\n\\u00a0           }\\n\\u00a0         else\\n\\u00a0           output_solution();\\n\\u00a0 \\n\\u00a0         computing_timer.print_summary();\\n\\u00a0         computing_timer.reset();\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 } // namespace Step90\\n\\u00a0 \\n\\u00a0 int main(int argc, char *argv[])\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       using namespace dealii;\\n\\u00a0       using namespace Step90;\\n\\u00a0       Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);\\n\\u00a0       LaplaceBeltramiSolver<3>         LB_solver;\\n\\u00a0       LB_solver.run();\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0 \\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\nUtilities::MPI::MPI_InitFinalizeDefinition mpi.h:1081\\nUtilities::MPI::this_mpi_processunsigned int this_mpi_process(const MPI_Comm mpi_communicator)Definition mpi.cc:107\\n Results\\nThe numerical solution \\\\(u_h\\\\) for a very fine mesh \\\\(\\\\Gamma_h\\\\) is shown below by plotting in Paraview the zero contour of the approximate level set \\\\(\\\\psi_h\\\\) and restricting the discrete solution \\\\(u_h\\\\) to the resulting surface approximation \\\\(\\\\Gamma_h\\\\).\\n\\n\\n\\nNext, we demonstrate the corresponding set of intersected cells with active degrees of freedom. Note that not all cells are of the same refinement level which is attributed to the insufficiently fine initial uniform grid.\\n\\n\\n\\nConvergence test \\nThe results of the convergence study are shown in the following table. The experimental orders of convergence (EOC) are reported for the surface errors and the stabilization.\\n\\n\\nCycle   DOFS   Rate   Iterations   \\\\(L^2\\\\)-Error   EOC   \\\\(H^1\\\\)-Error   EOC   \\\\(s_h^{1/2}(u_h)\\\\)   EOC    \\n\\n0   12370   -   15   7.6322e-02   -   3.6212e-01   -   2.2423e-01   -    \\n\\n1   49406   2.00   18   1.1950e-02   2.68   1.4752e-01   1.30   1.1238e-01   1.00    \\n\\n2   196848   1.99   19   1.7306e-03   2.79   7.4723e-02   0.98   6.1131e-02   0.88    \\n\\n3   785351   2.00   22   3.6276e-04   2.25   3.9329e-02   0.93   3.0185e-02   1.02    \\n\\n4   3136501   2.00   25   7.5910e-05   2.26   1.9694e-02   1.00   1.4875e-02   1.02    \\n\\n5   12536006   2.00   26   1.7279e-05   2.14   9.8443e-03   1.00   7.4067e-03   1.01    \\n\\n6   50122218   2.00   30   4.3891e-06   1.98   4.9219e-03   1.00   3.7042e-03   1.00   \\n\\nIn this test we refine the mesh near the surface and, as a result, the number of degrees of freedom scales in the two-dimensional fashion. The optimal rates of error convergence in \\\\(L^2(\\\\Gamma)\\\\) and \\\\(H^1(\\\\Gamma)\\\\) norms are clearly observable. We also note the first order convergence of the stabilization \\\\(s_h^{1/2}(u_h)=\\\\sqrt{s_h(u_h, u_h)}\\\\) evaluated at the solution \\\\(u_h\\\\).\\nParallel scalability\\nThe weak and strong scalability test results are shown in the following figure. Clearly, the refine() method is responsible for the certain lack of parallel scalability.\\n\\n\\n\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * This program was contributed by Vladimir Yushutin and Timo Heister, Clemson\\n * University, 2023.\\n */\\n \\n#include <deal.II/base/convergence_table.h>\\n#include <deal.II/base/function.h>\\n#include <deal.II/base/numbers.h>\\n#include <deal.II/base/point.h>\\n#include <deal.II/base/quadrature.h>\\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/tensor.h>\\n#include <deal.II/base/timer.h>\\n#include <deal.II/distributed/grid_refinement.h>\\n#include <deal.II/distributed/tria.h>\\n#include <deal.II/dofs/dof_tools.h>\\n#include <deal.II/fe/fe_nothing.h>\\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_update_flags.h>\\n#include <deal.II/fe/fe_values.h>\\n#include <deal.II/fe/mapping_q1.h>\\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_tools.h>\\n#include <deal.II/grid/tria.h>\\n#include <deal.II/hp/fe_collection.h>\\n#include <deal.II/lac/affine_constraints.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/precondition.h>\\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/solver_control.h>\\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/lac/sparse_direct.h>\\n#include <deal.II/lac/sparsity_pattern.h>\\n#include <deal.II/lac/sparsity_tools.h>\\n#include <deal.II/lac/trilinos_precondition.h>\\n#include <deal.II/lac/trilinos_solver.h>\\n#include <deal.II/lac/trilinos_sparse_matrix.h>\\n#include <deal.II/lac/trilinos_vector.h>\\n#include <deal.II/lac/vector.h>\\n#include <deal.II/meshworker/mesh_loop.h>\\n#include <deal.II/meshworker/scratch_data.h>\\n#include <deal.II/non_matching/fe_immersed_values.h>\\n#include <deal.II/non_matching/fe_values.h>\\n#include <deal.II/non_matching/mesh_classifier.h>\\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/error_estimator.h>\\n#include <deal.II/numerics/vector_tools.h>\\n \\nusing namespace dealii;\\nusing VectorType = TrilinosWrappers::MPI::Vector;\\nusing MatrixType = TrilinosWrappers::SparseMatrix;\\nnamespace Step90\\n{\\n enum class ActiveFEIndex : types::fe_index\\n  {\\n    lagrange = 0,\\n    nothing  = 1\\n  };\\n \\n template <int dim>\\n class TamarindShape : public Function<dim>\\n  {\\n public:\\n    TamarindShape()\\n      : Function<dim>()\\n    {}\\n double value(const Point<dim>  &point,\\n const unsigned int component = 0) const override\\n {\\n AssertIndexRange(component, this->n_components);\\n      (void)component;\\n Assert(dim == 3, ExcNotImplemented());\\n \\n return 0.25 * Utilities::pow(point[0], 2) + Utilities::pow(point[1], 2) +\\n             4.0 * Utilities::pow(point[2], 2) *\\n std::pow(1.0 + 0.5 * std::sin(numbers::PI * point[0]), -2) -\\n             1.0;\\n    }\\n \\n Tensor<1, dim> gradient(const Point<dim>  &point,\\n const unsigned int component = 0) const override\\n {\\n AssertIndexRange(component, this->n_components);\\n      (void)component;\\n Assert(dim == 3, ExcNotImplemented());\\n \\n Tensor<1, dim> grad;\\n      grad[0] = 0.5 * point[0] +\\n                (-2.0) * 4.0 * Utilities::pow(point[2], 2) *\\n std::pow(1.0 + 0.5 * std::sin(numbers::PI * point[0]), -3) *\\n                  (0.5 * numbers::PI * std::cos(numbers::PI * point[0]));\\n      grad[1] = 2.0 * point[1];\\n      grad[2] = (2.0) * 4.0 * point[2] *\\n std::pow(1.0 + 0.5 * std::sin(numbers::PI * point[0]), -2);\\n \\n return grad;\\n    }\\n \\n SymmetricTensor<2, dim>\\n hessian(const Point<dim>  &point,\\n const unsigned int component = 0) const override\\n {\\n AssertIndexRange(component, this->n_components);\\n      (void)component;\\n Assert(dim == 3, ExcNotImplemented());\\n \\n SymmetricTensor<2, dim> hessian;\\n \\n hessian[0][0] =\\n        0.5 +\\n        8.0 * Utilities::pow(point[2], 2) *\\n          (3.0 * std::pow(1.0 + 0.5 * std::sin(numbers::PI * point[0]), -4) *\\n Utilities::pow(0.5 * numbers::PI *\\n std::cos(numbers::PI * point[0]),\\n                            2) +\\n std::pow(1.0 + 0.5 * std::sin(numbers::PI * point[0]), -3) * 0.5 *\\n numbers::PI * numbers::PI * std::sin(numbers::PI * point[0]));\\n hessian[0][1] = 0.0;\\n hessian[0][2] =\\n        (-8.0) * point[2] *\\n std::pow(1.0 + 0.5 * std::sin(numbers::PI * point[0]), -3) *\\n numbers::PI * std::cos(numbers::PI * point[0]);\\n \\n hessian[1][1] = 2.0;\\n hessian[1][2] = 0.0;\\n \\n hessian[2][2] =\\n        8.0 * std::pow(1.0 + 0.5 * std::sin(numbers::PI * point[0]), -2);\\n \\n return hessian;\\n    }\\n  };\\n \\n template <int dim>\\n class AnalyticalSolution : public Function<dim>\\n  {\\n private:\\n const TamarindShape<dim> tamarind;\\n \\n public:\\n    AnalyticalSolution()\\n      : Function<dim>()\\n    {}\\n double value(const Point<dim>  &point,\\n const unsigned int component = 0) const override;\\n \\n Tensor<1, dim> gradient(const Point<dim>  &point,\\n const unsigned int component = 0) const override;\\n  };\\n \\n template <int dim>\\n double AnalyticalSolution<dim>::value(const Point<dim>  &point,\\n const unsigned int component) const\\n {\\n AssertIndexRange(component, this->n_components);\\n    (void)component;\\n return point[0] * point[1];\\n  }\\n \\n template <int dim>\\n Tensor<1, dim>\\n  AnalyticalSolution<dim>::gradient(const Point<dim>  &point,\\n const unsigned int component) const\\n {\\n AssertIndexRange(component, this->n_components);\\n    (void)component;\\n \\n const Tensor<1, dim> grad   = tamarind.gradient(point, component);\\n const Tensor<1, dim> normal = grad / grad.norm();\\n \\n Tensor<1, dim> projector_first_column = -normal[0] * normal;\\n    projector_first_column[0] += 1.0;\\n \\n Tensor<1, dim> projector_second_column = -normal[1] * normal;\\n    projector_second_column[1] += 1.0;\\n \\n Tensor<1, dim> surface_gradient =\\n point[1] * projector_first_column + point[0] * projector_second_column;\\n \\n return surface_gradient;\\n  }\\n \\n template <int dim>\\n class RightHandSide : public Function<dim>\\n  {\\n const TamarindShape<dim> tamarind;\\n \\n public:\\n    RightHandSide()\\n      : Function<dim>()\\n    {}\\n \\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n  };\\n \\n template <int dim>\\n double RightHandSide<dim>::value(const Point<dim>  &point,\\n const unsigned int component) const\\n {\\n AssertIndexRange(component, this->n_components);\\n    (void)component;\\n Assert(dim == 3, ExcNotImplemented());\\n \\n const Tensor<1, dim>          grad    = tamarind.gradient(point, component);\\n const Tensor<1, dim>          normal  = grad / grad.norm();\\n const SymmetricTensor<2, dim> hessian = tamarind.hessian(point, component);\\n \\n double mean_curv = 0.0;\\n for (int j = 0; j < 3; j++)\\n for (int k = 0; k < 3; k++)\\n        mean_curv += ((j == k ? 1 : 0) - normal[j] * normal[k]) * hessian[j][k];\\n    mean_curv /= grad.norm();\\n \\n return point[0] * point[1] + 2.0 * normal[0] * normal[1] +\\n           mean_curv * (point[1] * normal[0] + point[0] * normal[1]);\\n  }\\n \\n template <int dim>\\n struct ScratchData\\n  {\\n    ScratchData(const Mapping<dim>                     &mapping,\\n const hp::FECollection<dim>            &fe_collection,\\n const NonMatching::MeshClassifier<dim> &mesh_classifier,\\n const DoFHandler<dim>                  &level_set_dof_handler,\\n const VectorType                       &level_set,\\n const NonMatching::RegionUpdateFlags nonmatching_update_flags,\\n const Quadrature<dim>               &quadrature,\\n const Quadrature<1>                 &quadrature_edge,\\n const UpdateFlags cell_update_flags = update_values |\\n update_gradients |\\n update_quadrature_points |\\n update_JxW_values)\\n      : fe_values(\\n          mapping,\\n          fe_collection[static_cast<types::fe_index>(ActiveFEIndex::lagrange)],\\n          quadrature,\\n          cell_update_flags)\\n      , region_update_flags(nonmatching_update_flags)\\n      , quadrature_1D(quadrature_edge)\\n      , fe_collection(fe_collection)\\n      , mesh_classifier(mesh_classifier)\\n      , level_set_dof_handler(level_set_dof_handler)\\n      , level_set(level_set)\\n      , level_set_fe_values(mapping,\\n                            level_set_dof_handler.get_fe(),\\n                            quadrature,\\n                            cell_update_flags)\\n      , non_matching_fe_values(fe_collection,\\n                               quadrature_edge,\\n                               nonmatching_update_flags,\\n                               mesh_classifier,\\n                               level_set_dof_handler,\\n                               level_set)\\n    {}\\n \\n    ScratchData(const ScratchData<dim> &scratch_data)\\n      : fe_values(scratch_data.fe_values.get_mapping(),\\n                  scratch_data.fe_values.get_fe(),\\n                  scratch_data.fe_values.get_quadrature(),\\n                  scratch_data.fe_values.get_update_flags())\\n      , region_update_flags(scratch_data.region_update_flags)\\n      , quadrature_1D(scratch_data.quadrature_1D)\\n      , fe_collection(scratch_data.fe_collection)\\n      , mesh_classifier(scratch_data.mesh_classifier)\\n      , level_set_dof_handler(scratch_data.level_set_dof_handler)\\n      , level_set(scratch_data.level_set)\\n      , level_set_fe_values(scratch_data.level_set_fe_values.get_mapping(),\\n                            scratch_data.level_set_fe_values.get_fe(),\\n                            scratch_data.level_set_fe_values.get_quadrature(),\\n                            scratch_data.level_set_fe_values.get_update_flags())\\n      , non_matching_fe_values(fe_collection,\\n                               quadrature_1D,\\n                               region_update_flags,\\n                               mesh_classifier,\\n                               level_set_dof_handler,\\n                               level_set)\\n    {}\\n \\n FEValues<dim>                           fe_values;\\n const NonMatching::RegionUpdateFlags    region_update_flags;\\n const Quadrature<1>                    &quadrature_1D;\\n const hp::FECollection<dim>            &fe_collection;\\n const NonMatching::MeshClassifier<dim> &mesh_classifier;\\n const DoFHandler<dim>                  &level_set_dof_handler;\\n const VectorType                       &level_set;\\n FEValues<dim>                           level_set_fe_values;\\n NonMatching::FEValues<dim>              non_matching_fe_values;\\n  };\\n \\n template <int dim>\\n struct CopyData\\n  {\\n FullMatrix<double> cell_matrix;\\n Vector<double>                       cell_rhs;\\n    std::vector<types::global_dof_index> local_dof_indices;\\n \\n void reinit(const typename DoFHandler<dim>::active_cell_iterator &cell)\\n    {\\n const unsigned int dofs_per_cell = cell->get_fe().n_dofs_per_cell();\\n cell_matrix.reinit(dofs_per_cell, dofs_per_cell);\\n      cell_rhs.reinit(dofs_per_cell);\\n      local_dof_indices.resize(dofs_per_cell);\\n      cell->get_dof_indices(local_dof_indices);\\n    }\\n  };\\n \\n template <int dim>\\n struct CopyDataError\\n  {\\n unsigned int cell_index;\\n double       cell_L2_error_sqr;\\n double       cell_H1_error_sqr;\\n double       cell_stab_sqr;\\n \\n void reinit(const typename DoFHandler<dim>::active_cell_iterator &cell)\\n    {\\n cell_index        = cell->active_cell_index();\\n      cell_L2_error_sqr = 0.0;\\n      cell_H1_error_sqr = 0.0;\\n      cell_stab_sqr     = 0.0;\\n    }\\n  };\\n \\n template <int dim>\\n class NormalGradientVolumeStabilization\\n  {\\n public:\\n    NormalGradientVolumeStabilization()\\n      : stabilization_parameter(1.0)\\n      , stabilization_exponent(-1.0)\\n    {}\\n \\n bool needs_cell_worker() const\\n {\\n return true;\\n    }\\n \\n void assemble_cell_worker(\\n      VectorType                                           &level_set,\\n const typename DoFHandler<dim>::active_cell_iterator &cell,\\n      ScratchData<dim>                                     &scratch_data,\\n      CopyData<dim>                                        &copy_data) const\\n {\\n const FEValues<dim> &fe_values = scratch_data.fe_values;\\n const FEValues<dim> &level_set_fe_values =\\n        scratch_data.level_set_fe_values;\\n \\n const std::vector<double> &JxW_cell = fe_values.get_JxW_values();\\n \\n      std::vector<Tensor<1, dim>> grad_level_set(\\n        level_set_fe_values.get_quadrature().size());\\n      level_set_fe_values.get_function_gradients(level_set, grad_level_set);\\n \\n const double factor =\\n        stabilization_parameter *\\n std::pow(cell->minimum_vertex_distance(), stabilization_exponent);\\n for (const unsigned int q : fe_values.quadrature_point_indices())\\n        {\\n const Tensor<1, dim> &normal =\\n            grad_level_set[q] / grad_level_set[q].norm();\\n for (const unsigned int i : fe_values.dof_indices())\\n            for (const unsigned int j : fe_values.dof_indices())\\n              copy_data.cell_matrix(i, j) +=\\n                factor * (normal * fe_values.shape_grad(i, q)) *\\n                (normal * fe_values.shape_grad(j, q)) * JxW_cell[q];\\n        }\\n    }\\n \\n void evaluate_cell_worker(\\n      VectorType                                           &solution,\\n      VectorType                                           &level_set,\\n const typename DoFHandler<dim>::active_cell_iterator &cell,\\n      ScratchData<dim>                                     &scratch_data,\\n      CopyDataError<dim>                                   &copy_data) const\\n {\\n double                     cell_stab_sqr = 0.0;\\n const FEValues<dim>       &fe_values     = scratch_data.fe_values;\\n const std::vector<double> &JxW_cell      = fe_values.get_JxW_values();\\n const unsigned int n_q_points = fe_values.get_quadrature_points().size();\\n const FEValues<dim> &level_set_fe_values =\\n        scratch_data.level_set_fe_values;\\n \\n      std::vector<Tensor<1, dim>> level_set_grad(n_q_points);\\n      level_set_fe_values.get_function_gradients(level_set, level_set_grad);\\n \\n      std::vector<Tensor<1, dim>> sol_grad(n_q_points);\\n      fe_values.get_function_gradients(solution, sol_grad);\\n \\n const double factor =\\n        stabilization_parameter *\\n std::pow(cell->minimum_vertex_distance(), stabilization_exponent);\\n \\n for (const unsigned int q : fe_values.quadrature_point_indices())\\n        {\\n const Tensor<1, dim> normal =\\n            level_set_grad[q] / level_set_grad[q].norm();\\n \\n const double stabilization_at_point = normal * sol_grad[q];\\n          cell_stab_sqr +=\\n            factor * Utilities::pow(stabilization_at_point, 2) * JxW_cell[q];\\n        }\\n      copy_data.cell_stab_sqr = cell_stab_sqr;\\n    }\\n \\n private:\\n const double stabilization_parameter;\\n const double stabilization_exponent;\\n  };\\n \\n template <int dim>\\n class LaplaceBeltramiSolver\\n  {\\n public:\\n    LaplaceBeltramiSolver();\\n void run();\\n \\n private:\\n void make_grid();\\n \\n void localize_surface();\\n \\n void setup_discrete_level_set();\\n \\n void distribute_dofs();\\n \\n void initialize_matrices();\\n \\n void assemble_system();\\n \\n void solve();\\n \\n void mark_intersected();\\n \\n void refine_grid();\\n \\n void compute_errors();\\n \\n void output_level_set(unsigned int);\\n \\n void output_solution();\\n \\n MPI_Comm mpi_communicator;\\n \\n const TamarindShape<dim> tamarind;\\n \\n const AnalyticalSolution<dim> analytical_solution;\\n const RightHandSide<dim>      right_hand_side;\\n \\n parallel::distributed::Triangulation<dim, dim> triangulation;\\n ConditionalOStream                             pcout;\\n TimerOutput                                    computing_timer;\\n \\n const unsigned int    fe_degree;\\n hp::FECollection<dim> fe_collection;\\n DoFHandler<dim>       dof_handler;\\n \\n const unsigned int level_set_fe_degree;\\n const FE_Q<dim>    level_set_fe;\\n DoFHandler<dim>    level_set_dof_handler;\\n \\n const MappingQ1<dim> mapping;\\n \\n AffineConstraints<double> constraints;\\n AffineConstraints<double> level_set_constraints;\\n \\n    VectorType    completely_distributed_solution;\\n    VectorType    locally_relevant_solution;\\n    VectorType    locally_relevant_exact;\\n    VectorType    level_set;\\n Vector<float> active_fe_indicator;\\n \\n NonMatching::MeshClassifier<dim> mesh_classifier;\\n \\n const QGauss<dim> cell_quadrature;\\n const QGauss<1>   quadrature_1D;\\n \\n const NormalGradientVolumeStabilization<dim> stabilization_scheme;\\n \\n    VectorType      global_rhs;\\n    MatrixType      global_matrix;\\n SparsityPattern sparsity_pattern;\\n IndexSet        locally_owned_dofs;\\n IndexSet        locally_relevant_dofs;\\n \\n NonMatching::RegionUpdateFlags surface_update_flags;\\n \\n ConvergenceTable convergence_table;\\n  };\\n \\n template <int dim>\\n  LaplaceBeltramiSolver<dim>::LaplaceBeltramiSolver()\\n    : mpi_communicator(MPI_COMM_WORLD)\\n    , tamarind()\\n    , analytical_solution()\\n    , right_hand_side()\\n    , triangulation(mpi_communicator)\\n    , pcout(std::cout,\\n            (Utilities::MPI::this_mpi_process(mpi_communicator) == 0))\\n    , computing_timer(mpi_communicator,\\n                      pcout,\\n TimerOutput::never,\\n TimerOutput::wall_times)\\n    , fe_degree(1)\\n    , fe_collection(FE_Q<dim>(fe_degree), FE_Nothing<dim>())\\n    , dof_handler(triangulation)\\n    , level_set_fe_degree(1)\\n    , level_set_fe(level_set_fe_degree)\\n    , level_set_dof_handler(triangulation)\\n    , mapping()\\n    , mesh_classifier(level_set_dof_handler, level_set)\\n    , cell_quadrature(fe_degree + 1)\\n    , quadrature_1D(fe_degree + 1)\\n    , stabilization_scheme()\\n  {\\n    surface_update_flags.surface =\\n update_values | update_gradients | update_JxW_values |\\n update_quadrature_points | update_normal_vectors;\\n  }\\n \\n template <int dim>\\n void LaplaceBeltramiSolver<dim>::make_grid()\\n  {\\n    pcout << \\\"Creating background mesh...\\\"\\n          << \\\"\\\\n\\\"\\n          << std::flush;\\n const double cube_side = 2.008901281;\\n GridGenerator::hyper_cube(triangulation, -cube_side, cube_side);\\n triangulation.refine_global(3);\\n  }\\n \\n template <int dim>\\n void LaplaceBeltramiSolver<dim>::setup_discrete_level_set()\\n  {\\n    pcout\\n      << \\\"Setting up discrete level set function and reclassifying cells... \\\"\\n      << \\\"\\\\n\\\"\\n      << std::flush;\\n TimerOutput::Scope t(computing_timer, \\\"setup_level_set\\\");\\n \\n    active_fe_indicator.reinit(triangulation.n_active_cells());\\n    level_set_dof_handler.distribute_dofs(level_set_fe);\\n    level_set_constraints.clear();\\n const IndexSet level_set_locally_relevant_dofs =\\n DoFTools::extract_locally_relevant_dofs(level_set_dof_handler);\\n    level_set_constraints.reinit(level_set_locally_relevant_dofs);\\n DoFTools::make_hanging_node_constraints(level_set_dof_handler,\\n                                            level_set_constraints);\\n    level_set_constraints.close();\\n \\n    VectorType tmp_sol(level_set_dof_handler.locally_owned_dofs(),\\n                       mpi_communicator);\\n VectorTools::interpolate(level_set_dof_handler, tamarind, tmp_sol);\\n    level_set_constraints.distribute(tmp_sol);\\n \\n    level_set.reinit(level_set_locally_relevant_dofs,\\n                     level_set_dof_handler.locally_owned_dofs(),\\n                     mpi_communicator);\\n    level_set = tmp_sol;\\n \\n    mesh_classifier.reclassify();\\n \\n for (const auto &cell : dof_handler.active_cell_iterators() |\\n IteratorFilters::LocallyOwnedCell())\\n      {\\n if (mesh_classifier.location_to_level_set(cell) ==\\n NonMatching::LocationToLevelSet::intersected)\\n          cell->set_active_fe_index(\\n static_cast<types::fe_index>(ActiveFEIndex::lagrange));\\n else\\n          cell->set_active_fe_index(\\n static_cast<types::fe_index>(ActiveFEIndex::nothing));\\n      }\\n  }\\n \\n template <int dim>\\n void LaplaceBeltramiSolver<dim>::mark_intersected()\\n  {\\n    pcout << \\\"Determining cells with active FE index...\\\"\\n          << \\\"\\\\n\\\"\\n          << std::flush;\\n for (const auto &cell : dof_handler.active_cell_iterators() |\\n IteratorFilters::LocallyOwnedCell())\\n      {\\n if (mesh_classifier.location_to_level_set(cell) ==\\n NonMatching::LocationToLevelSet::intersected)\\n          active_fe_indicator[cell->active_cell_index()] = 1.0;\\n      }\\n  }\\n \\n \\n template <int dim>\\n void LaplaceBeltramiSolver<dim>::refine_grid()\\n  {\\n TimerOutput::Scope t(computing_timer, \\\"refine\\\");\\n    pcout << \\\"Refining near surface...\\\"\\n          << \\\"\\\\n\\\"\\n          << std::flush;\\n parallel::distributed::GridRefinement::refine_and_coarsen_fixed_fraction(\\n triangulation, active_fe_indicator, 1.0, 0.0);\\n \\n triangulation.execute_coarsening_and_refinement();\\n  }\\n \\n template <int dim>\\n void LaplaceBeltramiSolver<dim>::distribute_dofs()\\n  {\\n    pcout << \\\"Distributing degrees of freedom... \\\"\\n          << \\\"\\\\n\\\"\\n          << std::flush;\\n    dof_handler.distribute_dofs(fe_collection);\\n    locally_owned_dofs = dof_handler.locally_owned_dofs();\\n    locally_relevant_dofs =\\n DoFTools::extract_locally_relevant_dofs(dof_handler);\\n    completely_distributed_solution.reinit(dof_handler.locally_owned_dofs(),\\n                                           mpi_communicator);\\n    locally_relevant_solution.reinit(locally_owned_dofs,\\n                                     locally_relevant_dofs,\\n                                     mpi_communicator);\\n    global_rhs.reinit(locally_owned_dofs, mpi_communicator);\\n \\n const unsigned int dof_handler_size = dof_handler.n_dofs();\\n const unsigned int level_set_dof_handler_size =\\n      level_set_dof_handler.n_dofs();\\n \\n    convergence_table.add_value(\\\"LevelSet dofs\\\", level_set_dof_handler_size);\\n    convergence_table.evaluate_convergence_rates(\\n \\\"LevelSet dofs\\\", ConvergenceTable::reduction_rate_log2);\\n \\n    convergence_table.add_value(\\\"Active dofs\\\", dof_handler_size);\\n    convergence_table.evaluate_convergence_rates(\\n \\\"Active dofs\\\", ConvergenceTable::reduction_rate_log2);\\n  }\\n \\n template <int dim>\\n void LaplaceBeltramiSolver<dim>::initialize_matrices()\\n  {\\n    pcout << \\\"Initializing the matrix... \\\"\\n          << \\\"\\\\n\\\"\\n          << std::flush;\\n \\n DynamicSparsityPattern dsp(dof_handler.n_dofs(),\\n                               dof_handler.n_dofs(),\\n                               locally_relevant_dofs);\\n    constraints.reinit(locally_owned_dofs, locally_relevant_dofs);\\n \\n DoFTools::make_hanging_node_constraints(dof_handler, constraints);\\n    constraints.close();\\n DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints);\\n \\n SparsityTools::distribute_sparsity_pattern(dsp,\\n                                               locally_owned_dofs,\\n                                               mpi_communicator,\\n                                               locally_relevant_dofs);\\n    global_matrix.reinit(locally_owned_dofs,\\n                         locally_owned_dofs,\\n                         dsp,\\n                         mpi_communicator);\\n  }\\n \\n template <int dim>\\n void LaplaceBeltramiSolver<dim>::assemble_system()\\n  {\\n    pcout << \\\"Assembling... \\\"\\n          << \\\"\\\\n\\\"\\n          << std::flush;\\n TimerOutput::Scope t(computing_timer, \\\"assembly\\\");\\n \\n const auto cell_worker =\\n      [&](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n          ScratchData<dim>                                     &scratch_data,\\n          CopyData<dim>                                        &copy_data) {\\n if (mesh_classifier.location_to_level_set(cell) ==\\n NonMatching::LocationToLevelSet::intersected &&\\n            cell->is_locally_owned())\\n          {\\n            scratch_data.non_matching_fe_values.reinit(cell);\\n            copy_data.reinit(cell);\\n            copy_data.cell_matrix = 0;\\n            copy_data.cell_rhs    = 0;\\n const std::optional<NonMatching::FEImmersedSurfaceValues<dim>>\\n              &surface_fe_values =\\n                scratch_data.non_matching_fe_values.get_surface_fe_values();\\n const std::vector<double> &JxW_surface =\\n              surface_fe_values->get_JxW_values();\\n \\n for (unsigned int q : surface_fe_values->quadrature_point_indices())\\n              {\\n const Tensor<1, dim> &normal =\\n                  surface_fe_values->normal_vector(q);\\n \\n for (const unsigned int i : surface_fe_values->dof_indices())\\n                  {\\n                    copy_data.cell_rhs(i) +=\\n                      surface_fe_values->shape_value(i, q) *\\n                      right_hand_side.value(\\n                        surface_fe_values->quadrature_point(q)) *\\n                      JxW_surface[q];\\n \\n for (const unsigned int j :\\n                         surface_fe_values->dof_indices())\\n                      {\\n                        copy_data.cell_matrix(i, j) +=\\n                          (surface_fe_values->shape_value(i, q) *\\n                           surface_fe_values->shape_value(j, q)) *\\n                          JxW_surface[q];\\n                        copy_data.cell_matrix(i, j) +=\\n                          (surface_fe_values->shape_grad(i, q) -\\n                           (normal * surface_fe_values->shape_grad(i, q)) *\\n                             normal) *\\n                          (surface_fe_values->shape_grad(j, q) -\\n                           (normal * surface_fe_values->shape_grad(j, q)) *\\n                             normal) *\\n                          JxW_surface[q];\\n                      }\\n                  }\\n              }\\n \\n if (stabilization_scheme.needs_cell_worker())\\n              {\\n typename DoFHandler<dim>::active_cell_iterator level_set_cell =\\n                  cell->as_dof_handler_iterator(level_set_dof_handler);\\n                scratch_data.fe_values.reinit(cell);\\n                scratch_data.level_set_fe_values.reinit(level_set_cell);\\n                stabilization_scheme.assemble_cell_worker(level_set,\\n                                                          cell,\\n                                                          scratch_data,\\n                                                          copy_data);\\n              }\\n          }\\n      };\\n \\n const auto copier = [&](const CopyData<dim> &c) {\\n      constraints.distribute_local_to_global(c.cell_matrix,\\n                                             c.cell_rhs,\\n                                             c.local_dof_indices,\\n                                             global_matrix,\\n                                             global_rhs);\\n    };\\n \\n    ScratchData<dim> scratch_data(mapping,\\n                                  fe_collection,\\n                                  mesh_classifier,\\n                                  level_set_dof_handler,\\n                                  level_set,\\n                                  surface_update_flags,\\n                                  cell_quadrature,\\n                                  quadrature_1D);\\n \\n    CopyData<dim> copy_data;\\n \\n MeshWorker::mesh_loop(dof_handler.begin_active(),\\n                          dof_handler.end(),\\n                          cell_worker,\\n                          copier,\\n                          scratch_data,\\n                          copy_data,\\n MeshWorker::assemble_own_cells);\\n \\n    global_matrix.compress(VectorOperation::add);\\n    global_rhs.compress(VectorOperation::add);\\n  }\\n \\n template <int dim>\\n void LaplaceBeltramiSolver<dim>::solve()\\n  {\\n TimerOutput::Scope t(computing_timer, \\\"solve\\\");\\n bool               apply_direct_solver = false;\\n const double       relative_error      = 1e-9 * global_rhs.l2_norm();\\n unsigned int       n_iterations        = 0;\\n if (apply_direct_solver)\\n      {\\n        pcout << \\\"Solving directly... \\\" << '\\\\n' << std::flush;\\n SolverControl solver_control(100, relative_error);\\n TrilinosWrappers::SolverDirect::AdditionalData data;\\n TrilinosWrappers::SolverDirect trilinos(solver_control, data);\\n        trilinos.solve(global_matrix,\\n                       completely_distributed_solution,\\n                       global_rhs);\\n      }\\n else\\n      {\\n Timer timer;\\n        pcout << \\\"Solving with AMG... \\\"\\n              << \\\"\\\\n\\\"\\n              << std::flush;\\n const unsigned int max_iterations = 500;\\n SolverControl      solver_control(max_iterations, relative_error);\\n        std::vector<std::vector<bool>> constant_modes;\\n DoFTools::extract_constant_modes(dof_handler,\\n ComponentMask(),\\n                                         constant_modes);\\n TrilinosWrappers::PreconditionAMG preconditioner_stiffness;\\n TrilinosWrappers::PreconditionAMG::AdditionalData Amg_data;\\n        Amg_data.constant_modes        = constant_modes;\\n        Amg_data.elliptic              = true;\\n        Amg_data.higher_order_elements = false;\\n        Amg_data.smoother_sweeps       = 2;\\n        Amg_data.aggregation_threshold = 0.02;\\n        Amg_data.output_details        = true;\\n        preconditioner_stiffness.initialize(global_matrix);\\n \\n SolverCG<VectorType> cg(solver_control);\\n        cg.solve(global_matrix,\\n                 completely_distributed_solution,\\n                 global_rhs,\\n                 preconditioner_stiffness);\\n        n_iterations = solver_control.last_step();\\n      }\\n    constraints.distribute(completely_distributed_solution);\\n    locally_relevant_solution = completely_distributed_solution;\\n \\n    convergence_table.add_value(\\\"Iterations\\\", n_iterations);\\n  }\\n \\n template <int dim>\\n void LaplaceBeltramiSolver<dim>::compute_errors()\\n  {\\n    pcout << \\\"Evaluating errors on the surface...\\\"\\n          << \\\"\\\\n\\\"\\n          << std::flush;\\n TimerOutput::Scope t(computing_timer, \\\"eval_errors\\\");\\n double             error_L2_sqr   = 0.0;\\n double             error_H1_sqr   = 0.0;\\n double             error_stab_sqr = 0.0;\\n const auto         cell_worker    = [&](const auto &cell,\\n auto       &scratch_data,\\n auto       &copy_data) {\\n if (mesh_classifier.location_to_level_set(cell) ==\\n NonMatching::LocationToLevelSet::intersected &&\\n          cell->is_locally_owned())\\n        {\\n double cell_L2_error_sqr = 0.0;\\n double cell_H1_error_sqr = 0.0;\\n \\n          copy_data.reinit(cell);\\n          scratch_data.non_matching_fe_values.reinit(cell);\\n \\n const std::optional<NonMatching::FEImmersedSurfaceValues<dim>>\\n            &surface_fe_values =\\n              scratch_data.non_matching_fe_values.get_surface_fe_values();\\n const std::vector<double> &JxW_surface =\\n            surface_fe_values->get_JxW_values();\\n const unsigned int n_q_points =\\n            surface_fe_values->n_quadrature_points;\\n \\n          std::vector<double> sol(n_q_points);\\n          surface_fe_values->get_function_values(locally_relevant_solution,\\n                                                 sol);\\n \\n          std::vector<Tensor<1, dim>> sol_grad(n_q_points);\\n          surface_fe_values->get_function_gradients(locally_relevant_solution,\\n                                                    sol_grad);\\n \\n for (const unsigned int q :\\n               surface_fe_values->quadrature_point_indices())\\n            {\\n const Point<dim> &point = surface_fe_values->quadrature_point(q);\\n const Tensor<1, dim> &normal =\\n                surface_fe_values->normal_vector(q);\\n const double error_at_point =\\n                sol.at(q) - analytical_solution.value(point);\\n const Tensor<1, dim> grad_error_at_point =\\n                (sol_grad.at(q) - (normal * sol_grad.at(q)) * normal -\\n                 analytical_solution.gradient(point));\\n \\n              cell_L2_error_sqr +=\\n Utilities::pow(error_at_point, 2) * JxW_surface[q];\\n              cell_H1_error_sqr +=\\n                grad_error_at_point * grad_error_at_point * JxW_surface[q];\\n            }\\n          copy_data.cell_L2_error_sqr = cell_L2_error_sqr;\\n          copy_data.cell_H1_error_sqr = cell_H1_error_sqr;\\n \\n if (stabilization_scheme.needs_cell_worker())\\n            {\\n typename DoFHandler<dim>::active_cell_iterator level_set_cell =\\n                cell->as_dof_handler_iterator(level_set_dof_handler);\\n              scratch_data.fe_values.reinit(cell);\\n              scratch_data.level_set_fe_values.reinit(level_set_cell);\\n              stabilization_scheme.evaluate_cell_worker(\\n                locally_relevant_solution,\\n                level_set,\\n                cell,\\n                scratch_data,\\n                copy_data);\\n            }\\n        }\\n    };\\n \\n const auto copier = [&](const auto &copy_data) {\\n if (copy_data.cell_index < active_fe_indicator.size())\\n        {\\n          error_L2_sqr += copy_data.cell_L2_error_sqr;\\n          error_H1_sqr += copy_data.cell_H1_error_sqr;\\n          error_stab_sqr += copy_data.cell_stab_sqr;\\n        }\\n    };\\n \\n    ScratchData<dim> scratch_data(mapping,\\n                                  fe_collection,\\n                                  mesh_classifier,\\n                                  level_set_dof_handler,\\n                                  level_set,\\n                                  surface_update_flags,\\n                                  cell_quadrature,\\n                                  quadrature_1D);\\n \\n    CopyDataError<dim> copy_data;\\n \\n MeshWorker::mesh_loop(dof_handler.begin_active(),\\n                          dof_handler.end(),\\n                          cell_worker,\\n                          copier,\\n                          scratch_data,\\n                          copy_data,\\n MeshWorker::assemble_own_cells);\\n \\n const double error_L2 =\\n std::sqrt(Utilities::MPI::sum(error_L2_sqr, mpi_communicator));\\n const double error_semiH1 =\\n std::sqrt(Utilities::MPI::sum(error_H1_sqr, mpi_communicator));\\n const double error_stab =\\n std::sqrt(Utilities::MPI::sum(error_stab_sqr, mpi_communicator));\\n \\n    convergence_table.add_value(\\\"L2 Error\\\", error_L2);\\n    convergence_table.evaluate_convergence_rates(\\n \\\"L2 Error\\\", ConvergenceTable::reduction_rate_log2);\\n    convergence_table.set_scientific(\\\"L2 Error\\\", true);\\n \\n    convergence_table.add_value(\\\"H1 error\\\", error_semiH1);\\n    convergence_table.evaluate_convergence_rates(\\n \\\"H1 error\\\", ConvergenceTable::reduction_rate_log2);\\n    convergence_table.set_scientific(\\\"H1 error\\\", true);\\n \\n    convergence_table.add_value(\\\"Stab norm\\\", error_stab);\\n    convergence_table.evaluate_convergence_rates(\\n \\\"Stab norm\\\", ConvergenceTable::reduction_rate_log2);\\n    convergence_table.set_scientific(\\\"Stab norm\\\", true);\\n  }\\n \\n template <int dim>\\n void LaplaceBeltramiSolver<dim>::output_level_set(const unsigned int cycle)\\n  {\\n    pcout << \\\"Writing vtu file for surface... \\\" << '\\\\n' << std::flush;\\n TimerOutput::Scope t(computing_timer, \\\"output_level_set\\\");\\n DataOut<dim>       data_out;\\n    data_out.add_data_vector(level_set_dof_handler, level_set, \\\"level_set\\\");\\n    data_out.add_data_vector(active_fe_indicator, \\\"ref_indicator\\\");\\n    data_out.build_patches();\\n \\n    data_out.write_vtu_in_parallel(\\\"surface_\\\" + std::to_string(cycle) + \\\".vtu\\\",\\n                                   mpi_communicator);\\n  }\\n \\n template <int dim>\\n void LaplaceBeltramiSolver<dim>::output_solution()\\n  {\\n    pcout << \\\"Writing vtu file... \\\" << std::flush;\\n TimerOutput::Scope t(computing_timer, \\\"output_solution\\\");\\n Vector<double>     exact(dof_handler.locally_owned_dofs().size());\\n \\n VectorTools::interpolate(dof_handler, analytical_solution, exact);\\n DataOut<dim> data_out;\\n    data_out.add_data_vector(dof_handler,\\n                             locally_relevant_solution,\\n \\\"solution\\\");\\n    data_out.add_data_vector(dof_handler, exact, \\\"exact\\\");\\n    data_out.add_data_vector(level_set_dof_handler, level_set, \\\"level_set\\\");\\n \\n    data_out.set_cell_selection(\\n      [this](const typename Triangulation<dim>::cell_iterator &cell) {\\n return cell->is_active() && cell->is_locally_owned() &&\\n               mesh_classifier.location_to_level_set(cell) ==\\n NonMatching::LocationToLevelSet::intersected;\\n      });\\n    data_out.build_patches();\\n \\n    data_out.write_vtu_in_parallel(\\\"solution.vtu\\\", mpi_communicator);\\n  }\\n \\n template <int dim>\\n void LaplaceBeltramiSolver<dim>::localize_surface()\\n  {\\n unsigned int preliminary_levels = 3;\\n for (unsigned int localization_cycle = 0;\\n         localization_cycle < preliminary_levels;\\n         ++localization_cycle)\\n      {\\n        pcout << std::endl\\n              << \\\"Preliminary refinement #\\\" << localization_cycle << std::endl;\\n        setup_discrete_level_set();\\n        mark_intersected();\\n        output_level_set(localization_cycle);\\n        refine_grid();\\n      }\\n    computing_timer.reset();\\n  }\\n \\n template <int dim>\\n void LaplaceBeltramiSolver<dim>::run()\\n  {\\n    make_grid();\\n    localize_surface();\\n const unsigned int convergence_levels = 3;\\n for (unsigned int cycle = 0; cycle < convergence_levels; ++cycle)\\n      {\\n        pcout << std::endl << \\\"Convergence refinement #\\\" << cycle << std::endl;\\n        setup_discrete_level_set();\\n        distribute_dofs();\\n        initialize_matrices();\\n        assemble_system();\\n        solve();\\n        compute_errors();\\n if (Utilities::MPI::this_mpi_process(mpi_communicator) == 0)\\n          convergence_table.write_text(pcout.get_stream());\\n \\n        computing_timer.print_summary();\\n        computing_timer.reset();\\n if (cycle < convergence_levels - 1)\\n          {\\n            mark_intersected();\\n            refine_grid();\\n          }\\n else\\n          output_solution();\\n \\n        computing_timer.print_summary();\\n        computing_timer.reset();\\n      }\\n  }\\n} // namespace Step90\\n \\nint main(int argc, char *argv[])\\n{\\n try\\n    {\\n using namespace dealii;\\n using namespace Step90;\\n Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);\\n      LaplaceBeltramiSolver<3>         LB_solver;\\n      LB_solver.run();\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n \\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n \\n return 0;\\n}\\naffine_constraints.h\\npoint.h\\nDataOutInterface::write_vtu_in_parallelvoid write_vtu_in_parallel(const std::string &filename, const MPI_Comm comm) constDefinition data_out_base.cc:7715\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nDataOut::set_cell_selectionvoid set_cell_selection(const std::function< cell_iterator(const Triangulation< dim, spacedim > &)> &first_cell, const std::function< cell_iterator(const Triangulation< dim, spacedim > &, const cell_iterator &)> &next_cell)Definition data_out.cc:1273\\nDoFHandler::reinitvoid reinit(const Triangulation< dim, spacedim > &tria)\\nFEValuesBase::get_quadrature_pointsconst std::vector< Point< spacedim > > & get_quadrature_points() const\\nFEValuesBase::get_function_gradientsvoid get_function_gradients(const ReadVector< Number > &fe_function, std::vector< Tensor< 1, spacedim, Number > > &gradients) constDefinition fe_values_base.cc:851\\nFEValues::get_quadratureconst Quadrature< dim > & get_quadrature() const\\nTrilinosWrappers::PreconditionAMG::initializevoid initialize(const SparseMatrix &matrix, const AdditionalData &additional_data=AdditionalData())Definition trilinos_precondition_ml.cc:221\\nVector::reinitvirtual void reinit(const size_type N, const bool omit_zeroing_entries=false)\\nconvergence_table.h\\ngrid_refinement.h\\ntria.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nerror_estimator.h\\nfe_values.h\\nfe_collection.h\\nfe_immersed_values.h\\nfe_nothing.h\\nfe_q.h\\nfe_update_flags.h\\nfull_matrix.h\\nfunction.h\\ntria.h\\ngrid_generator.h\\ngrid_tools.h\\nquadrature.h\\nmapping_q1.h\\nmesh_classifier.h\\nmesh_loop.h\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\nPhysics::Elasticity::Kinematics::eSymmetricTensor< 2, dim, Number > e(const Tensor< 2, dim, Number > &F)\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\ninternal::EvaluatorQuantity::value@ value\\ninternal::EvaluatorQuantity::gradient@ gradient\\nfe_values.h\\nnumbers.h\\ndata_out.h\\nprecondition.h\\nquadrature_lib.h\\nscratch_data.h\\nsolver_cg.h\\nsolver_control.h\\nsparse_direct.h\\nsparse_matrix.h\\nsparsity_pattern.h\\nsparsity_tools.h\\nTrilinosWrappers::PreconditionAMG::AdditionalData::aggregation_thresholddouble aggregation_thresholdDefinition trilinos_precondition.h:1474\\nTrilinosWrappers::PreconditionAMG::AdditionalData::smoother_sweepsunsigned int smoother_sweepsDefinition trilinos_precondition.h:1512\\nTrilinosWrappers::PreconditionAMG::AdditionalData::ellipticbool ellipticDefinition trilinos_precondition.h:1445\\nTrilinosWrappers::PreconditionAMG::AdditionalData::higher_order_elementsbool higher_order_elementsDefinition trilinos_precondition.h:1451\\nTrilinosWrappers::PreconditionAMG::AdditionalData::output_detailsbool output_detailsDefinition trilinos_precondition.h:1525\\ntensor.h\\ntimer.h\\ntrilinos_precondition.h\\ntrilinos_solver.h\\ntrilinos_sparse_matrix.h\\ntrilinos_vector.h\\nvector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"