"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_19.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-19 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-19 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-19 tutorial program\\n\\n\\nThis tutorial depends on step-6.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nTime discretization\\nSpatial discretization\\nDealing with particles programmatically\\nThe test case\\n\\n The commented program\\n\\nInclude files\\nGlobal definitions\\nThe main class\\nThe CathodeRaySimulator class implementation\\n\\nThe CathodeRaySimulator constructor\\nThe CathodeRaySimulator::make_grid function\\nThe CathodeRaySimulator::setup_system function\\nThe CathodeRaySimulator::assemble_system function\\nCathodeRaySimulator::solve\\nCathodeRaySimulator::refine_grid\\nCathodeRaySimulator::create_particles\\nCathodeRaySimulator::move_particles\\nCathodeRaySimulator::track_lost_particle\\nCathodeRaySimulator::update_timestep_size\\nThe CathodeRaySimulator::output_results() function\\nCathodeRaySimulator::run\\n\\nThe main function\\n\\n\\n Results\\n\\nPossibilities for extensions\\n\\n More statistics about electrons \\n A better-synchronized visualization \\n A better time integrator \\n Parallelization \\n\\n\\n The plain program\\n   \\n\\n\\n\\n This program was contributed by Wolfgang Bangerth, Rene Gassmoeller, and Peter Munch.\\nWolfgang Bangerth acknowledges support through NSF awards DMS-1821210, EAR-1550901, and OAC-1835673. \\nNoteSupport for particles exists in deal.II primarily due to the initial efforts of Rene Gassmoeller. Please acknowledge this work by citing the publication [93] if you use particle functionality in your own work.\\n Introduction\\nThe finite element method in general, and deal.II in particular, were invented to solve partial differential equations \\u2013 in other words, to solve continuum mechanics problems. On the other hand, sometimes one wants to solve problems in which it is useful to track individual objects (\\\"particles\\\") and how their positions evolve. If this simply leads to a set of ordinary differential equations, for example if you want to track the positions of the planets in the solar system over time, then deal.II is clearly not the right tool. On the other hand, if this evolution is due to the interaction with the solution of partial differential equations, or if having a mesh to determine which particles interact with others (such as in the smoothed particle hydrodynamics (SPH) method), then deal.II has support for you.\\nThe case we will consider here is how electrically charged particles move through an electric field. As motivation, we will consider cathode rays: Electrons emitted by a heated piece of metal that is negatively charged (the \\\"cathode\\\"), and that are then accelerated by an electric field towards the positively charged electrode (the \\\"anode\\\"). The anode is typically ring-shaped so that the majority of electrons can fly through the hole in the form of an electron beam. In the olden times, they might then have illuminated the screen of a TV built from a cathode ray tube. Today, instead, electron beams are useful in X-ray machines, electron beam lithography, electron beam welding, and a number of other areas.\\nThe equations we will then consider are as follows: First, we need to describe the electric field. This is most easily accomplished by noting that the electric potential \\\\(V\\\\) satisfied the equation   \\n\\\\[\\n  -\\\\epsilon_0 \\\\Delta V = \\\\rho\\n\\\\]\\n\\n where \\\\(\\\\epsilon_0\\\\) is the dielectric constant of vacuum, and \\\\(\\\\rho\\\\) is the charge density. This is augmented by boundary conditions that we will choose as follows:      \\n\\\\begin{align*}\\n  V &= -V_0 && \\\\text{on}\\\\; \\\\Gamma_\\\\text{cathode}\\\\subset\\\\partial\\\\Omega \\\\\\\\\\n  V &= +V_0 && \\\\text{on}\\\\; \\\\Gamma_\\\\text{anode}\\\\subset\\\\partial\\\\Omega \\\\\\\\\\n  \\\\epsilon\\\\frac{\\\\partial V}{\\\\partial n} &= 0\\n   && \\\\text{on}\\\\; \\\\partial\\\\Omega\\\\setminus\\\\Gamma_\\\\text{cathode}\\\\setminus\\\\Gamma_\\\\text{anode}.\\n\\\\end{align*}\\n\\n In other words, we prescribe voltages \\\\(+V_0\\\\) and \\\\(-V_0\\\\) at the two electrodes and insulating (Neumann) boundary conditions elsewhere. Since the dynamics of the particles are purely due to the electric field \\\\(\\\\mathbf E=\\\\nabla V\\\\), we could as well have prescribed \\\\(2V_0\\\\) and \\\\(0\\\\) at the two electrodes \\u2013 all that matters is the voltage difference at the two electrodes.\\nGiven this electric potential \\\\(V\\\\) and the electric field \\\\(\\\\mathbf E=\\\\nabla V\\\\), we can describe the trajectory of the \\\\(i\\\\)th particle using the differential equation   \\n\\\\[\\n  m {\\\\ddot {\\\\mathbf x}}_i = e\\\\mathbf E,\\n\\\\]\\n\\n where \\\\(m,e\\\\) are the mass and electric charge of each particle. In practice, it is convenient to write this as a system of first-order differential equations in the position \\\\(\\\\mathbf x\\\\) and velocity \\\\(\\\\mathbf v\\\\):    \\n\\\\begin{align*}\\n  {\\\\dot {\\\\mathbf v}}_i &= \\\\frac{e\\\\mathbf E}{m}, \\\\\\\\\\n  {\\\\dot {\\\\mathbf x}}_i &= {\\\\mathbf v}_i.\\n\\\\end{align*}\\n\\n The deal.II class we will use to deal with particles, Particles::ParticleHandler, stores particles in a way so that the position \\\\(\\\\mathbf x_i\\\\) is part of the Particles::ParticleHandler data structures. (It stores particles sorted by cell they are in, and consequently needs to know where each particle is.) The velocity \\\\(\\\\mathbf v_i\\\\), on the other hand, is of no concern to Particles::ParticleHandler and consequently we will store it as a \\\"property\\\" of each particle that we will update in each time step. Properties can also be used to store any other quantity we might care about each particle: its charge, or if they were larger than just an electron, its color, mass, attitude in space, chemical composition, etc.\\nThere remain two things to discuss to complete the model: Where particles start and what the charge density \\\\(\\\\rho\\\\) is.\\nFirst, historically, cathode rays used very large electric fields to pull electrons out of the metal. This produces only a relatively small current. One can do better by heating the cathode: a statistical fraction of electrons in that case have enough thermal energy to leave the metal; the electric field then just has to be strong enough to pull them away from the attraction of their host body. We will model this in the following way: We will create a new particle if (i) the electric field points away from the electrode, i.e., if \\\\(\\\\mathbf E \\\\cdot \\\\mathbf n < 0\\\\) where \\\\(\\\\mathbf n\\\\) is the normal vector at a face pointing out of the domain (into the electrode), and (ii) the electric field exceeds a threshold value \\\\(|\\\\mathbf E|\\\\ge E_\\\\text{threshold}\\\\). This is surely not a sufficiently accurate model for what really happens, but is good enough for our current tutorial program.\\nSecond, in principle we would have to model the charge density via   \\n\\\\[\\n  \\\\rho(\\\\mathbf x) = \\\\sum_i e\\\\delta(\\\\mathbf x-\\\\mathbf x_i).\\n\\\\]\\n\\n The issue now is that in reality, a cathode ray tube in an old television yields a current of somewhere around a few milli-Amperes. In the much higher energy beams of particle accelerators, the current may only be a few nano-Ampere. But an Ampere is \\\\(6\\\\times 10^{18}\\\\) electrons flowing per second. Now, as you will see in the results section, we really only simulate a few microseconds ( \\\\(10^{-6}\\\\) seconds), but that still results in very very large numbers of electrons \\u2013 far more than we can hope to simulate with a program as small as the current one. As a consequence, let us presume that each particle represents \\\\(N\\\\) electrons. Then the particle mass and charge are also \\\\(Nm\\\\) and \\\\(Ne\\\\) and the equations we have to solve are   \\n\\\\[\\n  (Nm) {\\\\ddot {\\\\mathbf x}}_i = (Ne)\\\\mathbf E,\\n\\\\]\\n\\n which is of course exactly the same as above after dividing both sides by \\\\(N\\\\). On the other hand, the charge density for these \\\"clumps\\\" of electrons is given by   \\n\\\\[\\n  \\\\rho(\\\\mathbf x) = \\\\sum_i (Ne)\\\\delta(\\\\mathbf x-\\\\mathbf x_i).\\n\\\\]\\n\\n It is this form that we will implement in the program, where \\\\(N\\\\) is chosen rather large in the program to ensure that the particles actually affect the electric field. (This may not be realistic in practice: In most cases, there are just not enough electrons to actually affect the overall electric field. But realism is not our goal here.)\\nAs a final thought about the model, one may wonder why the equation for the electric field (or, rather, the electric potential) has no time derivative whereas the equations for the electron positions do. In essence, this is a modeling assumption: We assume that the particles move so slowly that at any given time the electric field is in equilibrium. This is saying, in other words, that the velocity of the electrons is much less than the speed of light. In yet other words, we can rephrase this in terms of the electrode voltage \\\\(V_0\\\\): Since every volt of electric potential accelerates electrons by approximately 600 km/s (neglecting relativistic effects), requiring \\\\(|\\\\mathbf v_i\\\\|\\\\ll c\\\\) is equivalent to saying that \\\\(2V_0 \\\\ll 500 \\\\text{V}\\\\). Under this assumption (and the assumption that the total number of electrons is small), one can also neglect the creation of magnetic fields by the moving charges, which would otherwise also affect the movement of the electrons.\\nTime discretization\\nThe equations outlined above then form a set of coupled differential equations. Let us bring them all together in one place again to make that clear:       \\n\\\\begin{align*}\\n  -\\\\epsilon_0 \\\\Delta V &= \\\\sum_i e\\\\delta(\\\\mathbf x-\\\\mathbf x_i)\\n  \\\\\\\\\\n  {\\\\dot {\\\\mathbf x}}_i &= {\\\\mathbf v}_i,\\n  \\\\\\\\\\n  {\\\\dot {\\\\mathbf v}}_i &= \\\\frac{e\\\\mathbf E}{m} = \\\\frac{e\\\\mathbf \\\\nabla V}{m}.\\n\\\\end{align*}\\n\\n Because of the awkward dependence of the electric potential on the particle locations, we don't want to solve this as a coupled system but instead use a decoupled approach where we first solve for the potential in each time step and then the particle locations. (One could also do it the other way around, of course.) This is very much in the same spirit as we do in step-21, step-31, and step-32, to name just a few, and can all be understood in the context of the operator splitting methods discussed in step-58.\\nSo, if we denote by an upper index \\\\(n\\\\) the time step, and if we use a simple time discretization for the ODE, then this means that we have to solve the following set of equations in each time step:       \\n\\\\begin{align*}\\n  -\\\\epsilon_0 \\\\Delta V^{(n)} &= \\\\sum_i e\\\\delta(\\\\mathbf x-\\\\mathbf x_i^{(n-1)})\\n  \\\\\\\\\\n  \\\\frac{{\\\\mathbf v}_i^{(n)}-{\\\\mathbf v}_i^{(n-1)}}{\\\\Delta t} &= \\\\frac{e\\\\nabla V^{(n)}}{m}\\n  \\\\\\\\\\n  \\\\frac{{\\\\mathbf x}_i^{(n)}-{\\\\mathbf x}_i^{(n-1)}}{\\\\Delta t} &= {\\\\mathbf v}_i^{(n)}.\\n\\\\end{align*}\\n\\n This scheme can be understood in the framework of operator splitting methods (specifically, the \\\"Lie splitting\\\" method) wherein a coupled system is solved by updating one variable at a time, using either the old values of other variables (e.g., using \\\\(\\\\mathbf x_i^{(n-1)}\\\\) in the first equation) or the values of variables that have already been updated in a previous sub-step (e.g., using \\\\(V^{(n)}\\\\) in the second equation). There are of course many better ways to do a time discretization (for example the simple leapfrog scheme when updating the velocity, or more general Strang splitting methods for the coupled system) but this isn't the point of the tutorial program, and so we will be content with what we have here. (We will comment on a piece of this puzzle in the possibilities for extensions section of this program, however.)\\nThere remains the question of how we should choose the time step size \\\\(\\\\Delta t\\\\). The limitation here is that the Particles::ParticleHandler class needs to keep track of which cell each particle is in. This is particularly an issue if we are running computations in parallel (say, in step-70) because in that case every process only stores those cells it owns plus one layer of \\\"ghost cells\\\". That's not relevant here, but in general we should make sure that over the course of each time step, a particle moves only from one cell to any of its immediate neighbors (face, edge, or vertex neighbors). If we can ensure that, then Particles::ParticleHandler is guaranteed to be able to figure out which cell a particle ends up in. To do this, a useful rule of thumb is that we should choose the time step so that for all particles the expected distance the particle moves by is less than one cell diameter:   \\n\\\\[\\n  \\\\Delta t \\\\le \\\\frac{h_i}{\\\\|\\\\mathbf v_i\\\\|} \\\\qquad\\\\qquad \\\\forall i,\\n\\\\]\\n\\n or equivalently   \\n\\\\[\\n  \\\\Delta t \\\\le \\\\min_i \\\\frac{h_i}{\\\\|\\\\mathbf v_i\\\\|}.\\n\\\\]\\n\\n Here, \\\\(h_i\\\\) is the length of the shortest edge of the cell on which particle \\\\(i\\\\) is located \\u2013 in essence, a measure of the size of a cell.\\nOn the other hand, a particle might already be at the boundary of one cell and the neighboring cell might be once further refined. So then the time to cross that neighboring cell would actually be half the amount above, suggesting   \\n\\\\[\\n  \\\\Delta t \\\\le \\\\min_i \\\\frac{\\\\tfrac 12 h_i}{\\\\|\\\\mathbf v_i\\\\|}.\\n\\\\]\\n\\nBut even that is not good enough: The formula above updates the particle positions in each time using the formula   \\n\\\\[\\n\\\\frac{{\\\\mathbf x}_i^{(n)}-{\\\\mathbf x}_i^{(n-1)}}{\\\\Delta t} = {\\\\mathbf v}_i^{(n)},\\n\\\\]\\n\\n that is, using the current velocity \\\\({\\\\mathbf v}_i^{n}\\\\). But we don't have the current velocity yet at the time when we need to choose \\\\(\\\\Delta t\\\\) \\u2013 which is after we have updated the potential \\\\(V^{(n)}\\\\) but before we update the velocity from \\\\({\\\\mathbf v}_i^{(n-1)}\\\\) to \\\\({\\\\mathbf v}_i^{(n)}\\\\). All we have is \\\\({\\\\mathbf v}_i^{(n-1)}\\\\). So we need an additional safety factor for our final choice:    \\n\\\\[\\n  \\\\Delta t^{(n)} =\\n  c_\\\\text{safety} \\\\min_i \\\\frac{\\\\tfrac 12 h_i}{\\\\|\\\\mathbf v_i^{(n-1)}\\\\|}.\\n\\\\]\\n\\n How large should \\\\(c_\\\\text{safety}\\\\) be? That depends on how much of underestimate \\\\(\\\\|\\\\mathbf v_i^{(n-1)}\\\\|\\\\) might be compared to \\\\(\\\\|\\\\mathbf v_i^{(n)}\\\\|\\\\), and that is actually quite easy to assess: A particle created in one time step with zero velocity will roughly pick up equal velocity increments in each successive time step if the electric field it encounters along the way were roughly constant. So the maximal difference between \\\\(\\\\|\\\\mathbf v_i^{(n-1)}\\\\|\\\\) and \\\\(\\\\|\\\\mathbf v_i^{(n)}\\\\|\\\\) would be a factor of two. As a consequence, we will choose \\\\(c_\\\\text{safety}=0.5\\\\).\\nThere is only one other case we ought to consider: What happens in the very first time step? There, any particles to be moved along have just been created, but they have a zero velocity. So we don't know what velocity we should choose for them. Of course, in all other time steps there are also particles that have just been created, but in general, the particles with the highest velocity limit the time step size and so the newly created particles with their zero velocity don't matter. But if we only have such particles?\\nIn that case, we can use the following approximation: If a particle starts at \\\\(\\\\mathbf v^{(0)}=0\\\\), then the update formula tells us that   \\n\\\\[\\n  {\\\\mathbf v}_i^{(1)} = \\\\frac{e\\\\nabla V^{(1)}}{m} \\\\Delta t,\\n\\\\]\\n\\n and consequently   \\n\\\\[\\n    \\\\frac{{\\\\mathbf x}_i^{(1)}-{\\\\mathbf x}_i^{(0)}}{\\\\Delta t} = {\\\\mathbf v}_i^{(1)},\\n\\\\]\\n\\n which we can write as   \\n\\\\[\\n    {\\\\mathbf x}_i^{(1)} - {\\\\mathbf x}_i^{(0)} = \\\\frac{e\\\\nabla V^{(1)}}{m} \\\\Delta t^2.\\n\\\\]\\n\\n Not wanting to move a particle by more than \\\\(\\\\frac 12 h_i\\\\) then implies that we should choose the time step as      \\n\\\\[\\n  \\\\Delta t\\n  \\\\le\\n  \\\\min_i\\n  \\\\sqrt{ \\\\frac{h_i m}{e \\\\|\\\\nabla V^{(1)}\\\\| }}.\\n\\\\]\\n\\n Using the same argument about neighboring cells possibly being smaller by a factor of two then leads to the final formula for time step zero:      \\n\\\\[\\n  \\\\Delta t\\n  =\\n  \\\\min_i\\n  \\\\sqrt{ \\\\frac{\\\\frac 12 h_i m}{e \\\\|\\\\nabla V^{(1)}\\\\| } }.\\n\\\\]\\n\\nStrictly speaking, we would have to evaluate the electric potential \\\\(V^{(1)}\\\\) at the location of each particle, but a good enough approximation is to use the maximum of the values at the vertices of the respective cell. (Why the vertices and not the midpoint? Because the gradient of the solution of the Laplace equation, i.e., the electric field, is largest in corner singularities which are located at the vertices of cells.) This has the advantage that we can make good use of the FEValues functionality which can recycle pre-computed material as long as the quadrature points are the same from one cell to the next.\\nWe could always run this kind of scheme to estimate the difference between \\\\(\\\\mathbf v_i^{(n-1)}\\\\) and \\\\(\\\\mathbf v_i^{(n)}\\\\), but it relies on evaluating the electric field \\\\(\\\\mathbf E\\\\) on each cell, and that is expensive. As a consequence, we will limit this approach to the very first time step.\\nSpatial discretization\\nHaving discussed the time discretization, the discussion of the spatial discretization is going to be short: We use quadratic finite elements, i.e., the space \\\\(Q_2\\\\), to approximate the electric potential \\\\(V\\\\). The mesh is adapted a couple of times during the initial time step. All of this is entirely standard if you have read step-6, and the implementation does not provide for any kind of surprise.\\nDealing with particles programmatically\\nAdding and moving particles is, in practice, not very difficult in deal.II. To add one, the create_particles() function of this program simply uses a code snippet of the following form: Particles::Particle<dim> new_particle;\\nnew_particle.set_location(location);\\nnew_particle.set_reference_location\\n    (mapping.transform_real_to_unit_cell(cell, location));\\nnew_particle.set_id(n_current_particles);\\n \\nparticle_handler.insert_particle(new_particle, cell);\\nParticles::ParticleDefinition particle.h:94\\nParticles::Particle::set_reference_locationvoid set_reference_location(const Point< dim > &new_reference_location)Definition particle.h:572\\nParticles::Particle::set_idvoid set_id(const types::particle_index &new_id)Definition particle.h:599\\nParticles::Particle::set_locationvoid set_location(const Point< spacedim > &new_location)Definition particle.h:545\\n In other words, it is not all that different from inserting an object into a std::set or std::map: Create the object, set its properties (here, the current location, its reference cell location, and its id) and call insert_particle. The only thing that may be surprising is the reference location: In order to evaluate things such as \\\\(\\\\nabla V(\\\\mathbf x_i)\\\\), it is necessary to evaluate finite element fields at locations \\\\(\\\\mathbf x_i\\\\). But this requires evaluating the finite element shape functions at points on the reference cell \\\\(\\\\hat{\\\\mathbf x}_i\\\\). To make this efficient, every particle doesn't just store its location and the cell it is on, but also what location that point corresponds to in the cell's reference coordinate system.\\nUpdating a particle's position is then no more difficult: One just has to call particle->set_location(new_location);\\n We do this in the move_particles() function. The only difference is that we then have to tell the Particles::ParticleHandler class to also find what cell that position corresponds to (and, when computing in parallel, which process owns this cell). For efficiency reason, this is most easily done after updating all particles' locations, and is achieved via the Particles::ParticleHandler::sort_particles_into_subdomains_and_cells() function.\\nThere are, of course, times where a particle may leave the domain in question. In that case, Particles::ParticleHandler::sort_particles_into_subdomains_and_cells() can not find a surrounding cell and simply deletes the particle. But, it is often useful to track the number of particles that have been lost this way, and for this the Particles::ParticleHandler class offers a \\\"signal\\\" that one can attach to. We show how to do this in the constructor of the main class to count how many particles were lost in each time step. Specifically, the way this works is that the Particles::ParticleHandler class has a \\\"signal\\\" to which one can attach a function that will be executed whenever the signal is triggered. Here, this looks as follows: particle_handler.signals.particle_lost.connect(\\n  [this](const typename Particles::ParticleIterator<dim> &        particle,\\n const typename Triangulation<dim>::active_cell_iterator &cell)\\n  {\\n    this->track_lost_particle(particle, cell);\\n  });\\nParticles::ParticleIteratorDefinition particle_iterator.h:39\\nTriaActiveIteratorDefinition tria_iterator.h:755\\n That's a bit of a mouthful, but what's happening is this: We declare a lambda function that \\\"captures\\\" the this pointer (so that we can access member functions of the surrounding object inside the lambda function), and that takes two arguments:\\nA reference to the particle that has been \\\"lost\\\".\\nA reference to the cell it was on last. The lambda function then simply calls the CathodeRaySimulator::track_lost_particle function with these arguments. When we attach this lambda function to the signal, the Particles::ParticleHandler::sort_particles_into_subdomains_and_cells() function will trigger the signal for every particle for which it can't find a new home. This gives us the chance to record where the particle is, and to record statistics on it.\\n\\nNoteIn this tutorial program, we insert particles by hand and at locations we specifically choose based on conditions that include the solution of the electrostatic problem. But there are other cases where one primarily wants to use particles as passive objects, for example to trace and visualize the flow field of a fluid flow problem. In those cases, there are numerous functions in the Particles::Generators namespace that can generate particles automatically. One of the functions of this namespace is also used in the step-70 tutorial program, for example.\\nThe test case\\nThe test case here is not meant to be a realistic depiction of a cathode ray tube, but it has the right general characteristics and the point is, in any case, only to demonstrate how one would implement deal.II codes that use particles.\\nThe following picture shows the geometry that we're going to use:\\n\\n \\nIn this picture, the parts of the boundary marked in red and blue are the cathode, held at an electric potential \\\\(V=-V_0\\\\). The part of the cathode shown in red is the part that is heated, leading to electrons leaving the metal and then being accelerated by the electric field (a few electric field lines are also shown). The green part of the boundary is the anode, held at \\\\(V=+V_0\\\\). The rest of the boundary satisfies a Neumann boundary condition.\\nThis setup mimics real devices. The re-entrant corner results in an electric potential \\\\(V\\\\) whose derivative (the electric field \\\\(\\\\mathbf E\\\\)) has a singularity \\u2013 in other words, it becomes very large in the vicinity of the corner, allowing it to rip electrons away from the metal. These electrons are then accelerated towards the (green) anode which has a hole in the middle through which the electrons can escape the device and fly on to hit the screen, where they excite the \\\"phosphor\\\" to then emit the light that we see from these old-style TV screens. The non-heated part of the cathode is not subject to the emission of electrons \\u2013 in the code, we will mark this as the \\\"focussing element\\\" of the tube, because its negative electric voltage repels the electrons and makes sure that they do not just fly away from the heated part of the cathode perpendicular to the boundary, but in fact bend their paths towards the anode on the right.\\nThe electric field lines also shown in the picture illustrate that the electric field connects the negative and positive electrodes, respectively. The accelerating force the electrons experience is along these field lines. Finally, the picture shows the mesh used in the computation, illustrating that there are singularities at the tip of the re-rentrant corner as well as at all places where the boundary conditions change; these singularities are visible because the mesh is refined in these locations.\\nOf practical interest is to figure out which fraction of the electrons emitted from the cathode actually make it through the hole in the anode \\u2013 electrons that just bounce into the anode itself are not actually doing anything useful other than converting electricity into heat. As a consequence, in the track_lost_particle() function (which is called for each particle that leaves the domain, see above), we will estimate where it might have left the domain and report this in the output.\\nNoteIt is worth repeating that neither the geometry used here, nor in fact any other aspect of this program is intended to represent anything even half-way realistic. Tutorial programs are our tools to teach how deal.II works, and we often use situations for which we have some kind of intuition since this helps us interpret the output of a program, but that's about the extent to which we intend the program to do anything of use besides being a teaching tool.\\n The commented program\\n Include files\\nThe majority of the include files used in this program are well known from step-6 and similar programs:\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/precondition.h>\\n\\u00a0 #include <deal.II/lac/solver_cg.h>\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_refinement.h>\\n\\u00a0 #include <deal.II/grid/grid_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/mapping_q.h>\\n\\u00a0 #include <deal.II/matrix_free/fe_point_evaluation.h>\\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 #include <deal.II/numerics/error_estimator.h>\\n\\u00a0 \\n\\u00a0 \\nThe ones that are new are only the following three: The first declares the DiscreteTime class that helps us keep track of time in a time-dependent simulation. The latter two provide all of the particle functionality, namely a way to keep track of particles located on a mesh (the Particles::ParticleHandler class) and the ability to output these particles' locations and their properties for the purposes of visualization (the Particles::DataOut class).\\n\\u00a0 #include <deal.II/base/discrete_time.h>\\n\\u00a0 #include <deal.II/particles/particle_handler.h>\\n\\u00a0 #include <deal.II/particles/data_out.h>\\n\\u00a0 \\n\\u00a0 #include <fstream>\\n\\u00a0 \\n\\u00a0 using namespace dealii;\\n\\u00a0 \\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n Global definitions\\nAs is customary, we put everything that corresponds to the details of the program into a namespace of its own. At the top, we define a few constants for which we would rather use symbolic names than hard-coded numbers.\\nSpecifically, we define numbers for boundary indicators for the various parts of the geometry, as well as the physical properties of electrons and other specifics of the setup we use here.\\nFor the boundary indicators, let us start enumerating at some random value 101. The principle here is to use numbers that are uncommon. If there are pre-defined boundary indicators previously set by the GridGenerator functions, they will likely be small integers starting from zero, but not in this rather randomly chosen range. Using numbers such as those below avoids the possibility for conflicts, and also reduces the temptation to just spell these numbers out in the program (because you will probably never remember which is which, whereas you might have been tempted if they had started at 0).\\n\\u00a0 namespace Step19\\n\\u00a0 {\\n\\u00a0   namespace BoundaryIds\\n\\u00a0   {\\n\\u00a0     constexpr types::boundary_id open          = 101;\\n\\u00a0     constexpr types::boundary_id cathode       = 102;\\n\\u00a0     constexpr types::boundary_id focus_element = 103;\\n\\u00a0     constexpr types::boundary_id anode         = 104;\\n\\u00a0   } // namespace BoundaryIds\\n\\u00a0 \\n\\u00a0   namespace Constants\\n\\u00a0   {\\n\\u00a0     constexpr double electron_mass   = 9.1093837015e-31;\\n\\u00a0     constexpr double electron_charge = 1.602176634e-19;\\n\\u00a0 \\n\\u00a0     constexpr double V0 = 1;\\n\\u00a0 \\n\\u00a0     constexpr double E_threshold = 0.05;\\n\\u00a0 \\n\\u00a0     constexpr double electrons_per_particle = 3e15;\\n\\u00a0   } // namespace Constants\\n\\u00a0 \\n\\u00a0 \\nunsigned int\\n The main class\\nThe following is then the main class of this program. It has, fundamentally, the same structure as step-6 and many other tutorial programs. This includes the majority of the member functions (with the purpose of the rest probably self-explanatory from their names) as well as only a small number of member variables beyond those of step-6, all of which are related to dealing with particles.\\n\\u00a0   template <int dim>\\n\\u00a0   class CathodeRaySimulator\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     CathodeRaySimulator();\\n\\u00a0 \\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void make_grid();\\n\\u00a0     void setup_system();\\n\\u00a0     void assemble_system();\\n\\u00a0     void solve_field();\\n\\u00a0     void refine_grid();\\n\\u00a0 \\n\\u00a0     void create_particles();\\n\\u00a0     void move_particles();\\n\\u00a0     void track_lost_particle(\\n\\u00a0       const Particles::ParticleIterator<dim>                  &particle,\\n\\u00a0       const typename Triangulation<dim>::active_cell_iterator &cell);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     void update_timestep_size();\\n\\u00a0     void output_results() const;\\n\\u00a0 \\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0     const MappingQ<dim>       mapping;\\n\\u00a0     const FE_Q<dim>           fe;\\n\\u00a0     DoFHandler<dim>           dof_handler;\\n\\u00a0     AffineConstraints<double> constraints;\\n\\u00a0 \\n\\u00a0     SparseMatrix<double> system_matrix;\\n\\u00a0     SparsityPattern      sparsity_pattern;\\n\\u00a0 \\n\\u00a0     Vector<double> solution;\\n\\u00a0     Vector<double> system_rhs;\\n\\u00a0 \\n\\u00a0     Particles::ParticleHandler<dim> particle_handler;\\n\\u00a0     types::particle_index           next_unused_particle_id;\\n\\u00a0     types::particle_index           n_recently_lost_particles;\\n\\u00a0     types::particle_index           n_total_lost_particles;\\n\\u00a0     types::particle_index           n_particles_lost_through_anode;\\n\\u00a0 \\n\\u00a0     DiscreteTime time;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nDiscreteTimeDefinition discrete_time.h:233\\nDoFHandlerDefinition dof_handler.h:317\\nFE_QDefinition fe_q.h:554\\nMappingQDefinition mapping_q.h:110\\nParticles::ParticleHandlerDefinition particle_handler.h:63\\nSparseMatrixDefinition sparse_matrix.h:520\\nSparsityPatternDefinition sparsity_pattern.h:343\\nTriangulationDefinition tria.h:1323\\nVectorDefinition vector.h:120\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\n The CathodeRaySimulator class implementation\\n The CathodeRaySimulator constructor\\nSo then let us get started on the implementation. What the constructor does is really only a straight-forward initialization of all of the member variables at the top. The only two worth mentioning are the particle_handler, which is handed a reference to the triangulation on which the particles will live (currently of course still empty, but the particle handler stores the reference and will use it once particles are added \\u2013 which happens after the triangulation is built). The other piece of information it gets is how many \\\"properties\\\" each particle needs to store. Here, all we need each particle to remember is its current velocity, i.e., a vector with dim components. There are, however, other intrinsic properties that each particle has and that the Particles::ParticleHandler class automatically and always makes sure are available; in particular, these are the current location of a particle, the cell it is on, it's reference location within that cell, and the particle's ID.\\nThe only other variable of interest is time, an object of type DiscreteTime. It keeps track of the current time we are in a time-dependent simulation, and is initialized with the start time (zero) and end time ( \\\\(10^{-4}\\\\)). We will later set the time step size in update_timestep_size().\\nThe body of the constructor consists of a piece of code we have already discussed in the introduction. Namely, we make sure that the track_lost_particle() function is called by the particle_handler object every time a particle leaves the domain.\\n\\u00a0   template <int dim>\\n\\u00a0   CathodeRaySimulator<dim>::CathodeRaySimulator()\\n\\u00a0     : mapping(1)\\n\\u00a0     , fe(2)\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0     , particle_handler(triangulation, mapping, /*n_properties=*/dim)\\n\\u00a0     , next_unused_particle_id(0)\\n\\u00a0     , n_recently_lost_particles(0)\\n\\u00a0     , n_total_lost_particles(0)\\n\\u00a0     , n_particles_lost_through_anode(0)\\n\\u00a0     , time(0, 1e-4)\\n\\u00a0   {\\n\\u00a0     particle_handler.signals.particle_lost.connect(\\n\\u00a0       [this](const typename Particles::ParticleIterator<dim>         &particle,\\n\\u00a0              const typename Triangulation<dim>::active_cell_iterator &cell) {\\n\\u00a0         this->track_lost_particle(particle, cell);\\n\\u00a0       });\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n The CathodeRaySimulator::make_grid function\\nThe next function is then responsible for generating the mesh on which we want to solve. Recall how the domain looks like: \\n \\nWe subdivide this geometry into a mesh of \\\\(4\\\\times 2\\\\) cells that looks like this:  *---*---*---*---*\\n\\\\   |   |   |   |\\n *--*---*---*---*\\n/   |   |   |   |\\n*---*---*---*---*\\n  The way this is done is by first defining where the \\\\(15=5\\\\times 3\\\\) vertices are located \\u2013 here, we say that they are on integer points with the middle one on the left side moved to the right by a value of delta=0.5.\\nIn the following, we then have to say which vertices together form the 8 cells. The following code is then entirely equivalent to what we also do in step-14:\\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::make_grid()\\n\\u00a0   {\\n\\u00a0     static_assert(dim == 2,\\n\\u00a0                   \\\"This function is currently only implemented for 2d.\\\");\\n\\u00a0 \\n\\u00a0     const double       delta = 0.5;\\n\\u00a0     const unsigned int nx    = 5;\\n\\u00a0     const unsigned int ny    = 3;\\n\\u00a0 \\n\\u00a0     const std::vector<Point<dim>> vertices \\n\\u00a0       = {{0, 0},\\n\\u00a0          {1, 0},\\n\\u00a0          {2, 0},\\n\\u00a0          {3, 0},\\n\\u00a0          {4, 0},\\n\\u00a0          {delta, 1},\\n\\u00a0          {1, 1},\\n\\u00a0          {2, 1},\\n\\u00a0          {3, 1},\\n\\u00a0          {4, 1},\\n\\u00a0          {0, 2},\\n\\u00a0          {1, 2},\\n\\u00a0          {2, 2},\\n\\u00a0          {3, 2},\\n\\u00a0          {4, 2}};\\n\\u00a0     AssertDimension(vertices.size(), nx * ny);\\n\\u00a0 \\n\\u00a0     const std::vector<unsigned int> cell_vertices[(nx - 1) * (ny - 1)] = {\\n\\u00a0       {0, 1, nx + 0, nx + 1},\\n\\u00a0       {1, 2, nx + 1, nx + 2},\\n\\u00a0       {2, 3, nx + 2, nx + 3},\\n\\u00a0       {3, 4, nx + 3, nx + 4},\\n\\u00a0 \\n\\u00a0       {5, nx + 1, 2 * nx + 0, 2 * nx + 1},\\n\\u00a0       {nx + 1, nx + 2, 2 * nx + 1, 2 * nx + 2},\\n\\u00a0       {nx + 2, nx + 3, 2 * nx + 2, 2 * nx + 3},\\n\\u00a0       {nx + 3, nx + 4, 2 * nx + 3, 2 * nx + 4}};\\n\\u00a0 \\nverticesPoint< 3 > vertices[4]Definition data_out_base.cc:272\\nAssertDimension#define AssertDimension(dim1, dim2)Definition exceptions.h:1985\\nWith these arrays out of the way, we can move to slightly higher higher-level data structures. We create a vector of CellData objects that store for each cell to be created the vertices in question as well as the material id (which we will here simply set to zero since we don't use it in the program).\\nThis information is then handed to the Triangulation::create_triangulation() function, and the mesh is twice globally refined. As discussed in the corresponding place in step-14, the inputs to Triangulation::create_triangulation() need to be consistently oriented, which a function in namespace GridTools does for us.\\n\\u00a0     std::vector<CellData<dim>> cells((nx - 1) * (ny - 1), CellData<dim>());\\n\\u00a0     for (unsigned int i = 0; i < cells.size(); ++i)\\n\\u00a0       {\\n\\u00a0         cells[i].vertices    = cell_vertices[i];\\n\\u00a0         cells[i].material_id = 0;\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     GridTools::consistently_order_cells(cells);\\n\\u00a0     triangulation.create_triangulation(\\n\\u00a0       vertices,\\n\\u00a0       cells,\\n\\u00a0       SubCellData()); // No boundary information\\n\\u00a0 \\n\\u00a0     triangulation.refine_global(2);\\n\\u00a0 \\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nparallel::distributed::Triangulation::create_triangulationvirtual void create_triangulation(const std::vector< Point< spacedim > > &vertices, const std::vector< CellData< dim > > &cells, const SubCellData &subcelldata) overrideDefinition tria.cc:1798\\nGridTools::consistently_order_cellsvoid consistently_order_cells(std::vector< CellData< dim > > &cells)Definition grid_tools_topology.cc:1615\\nCellDataDefinition tria_description.h:79\\nSubCellDataDefinition tria_description.h:238\\nThe remaining part of the function loops over all cells and their faces, and if a face is at the boundary determines which boundary indicator should be applied to it. The various conditions should make sense if you compare the code with the picture of the geometry above.\\nOnce done with this step, we refine the mesh once more globally.\\n\\u00a0     for (auto &cell : triangulation.active_cell_iterators())\\n\\u00a0       for (auto &face : cell->face_iterators())\\n\\u00a0         if (face->at_boundary())\\n\\u00a0           {\\n\\u00a0             if ((face->center()[0] > 0) && (face->center()[0] < 0.5) &&\\n\\u00a0                 (face->center()[1] > 0) && (face->center()[1] < 2))\\n\\u00a0               face->set_boundary_id(BoundaryIds::cathode);\\n\\u00a0             else if ((face->center()[0] > 0) && (face->center()[0] < 2))\\n\\u00a0               face->set_boundary_id(BoundaryIds::focus_element);\\n\\u00a0             else if ((face->center()[0] > 4 - 1e-12) &&\\n\\u00a0                      ((face->center()[1] > 1.5) || (face->center()[1] < 0.5)))\\n\\u00a0               face->set_boundary_id(BoundaryIds::anode);\\n\\u00a0             else\\n\\u00a0               face->set_boundary_id(BoundaryIds::open);\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0     triangulation.refine_global(1);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\ncenterPoint< 3 > centerDefinition data_out_base.cc:267\\n The CathodeRaySimulator::setup_system function\\nThe next function in this program deals with setting up the various objects related to solving the partial differential equations. It is in essence a copy of the corresponding function in step-6 and requires no further discussion.\\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::setup_system()\\n\\u00a0   {\\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0 \\n\\u00a0     solution.reinit(dof_handler.n_dofs());\\n\\u00a0     system_rhs.reinit(dof_handler.n_dofs());\\n\\u00a0 \\n\\u00a0     constraints.clear();\\n\\u00a0     DoFTools::make_hanging_node_constraints(dof_handler, constraints);\\n\\u00a0 \\n\\u00a0     VectorTools::interpolate_boundary_values(dof_handler,\\n\\u00a0                                              BoundaryIds::cathode,\\n\\u00a0                                              Functions::ConstantFunction<dim>(\\n\\u00a0                                                -Constants::V0),\\n\\u00a0                                              constraints);\\n\\u00a0     VectorTools::interpolate_boundary_values(dof_handler,\\n\\u00a0                                              BoundaryIds::focus_element,\\n\\u00a0                                              Functions::ConstantFunction<dim>(\\n\\u00a0                                                -Constants::V0),\\n\\u00a0                                              constraints);\\n\\u00a0     VectorTools::interpolate_boundary_values(dof_handler,\\n\\u00a0                                              BoundaryIds::anode,\\n\\u00a0                                              Functions::ConstantFunction<dim>(\\n\\u00a0                                                +Constants::V0),\\n\\u00a0                                              constraints);\\n\\u00a0     constraints.close();\\n\\u00a0 \\n\\u00a0     DynamicSparsityPattern dsp(dof_handler.n_dofs());\\n\\u00a0     DoFTools::make_sparsity_pattern(dof_handler,\\n\\u00a0                                     dsp,\\n\\u00a0                                     constraints,\\n\\u00a0                                     /*keep_constrained_dofs = */ false);\\n\\u00a0     sparsity_pattern.copy_from(dsp);\\n\\u00a0 \\n\\u00a0     system_matrix.reinit(sparsity_pattern);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nFunctions::ConstantFunctionDefinition function.h:410\\nDoFTools::make_hanging_node_constraintsvoid make_hanging_node_constraints(const DoFHandler< dim, spacedim > &dof_handler, AffineConstraints< number > &constraints)Definition dof_tools_constraints.cc:3073\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nVectorTools::interpolate_boundary_valuesvoid interpolate_boundary_values(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const std::map< types::boundary_id, const Function< spacedim, number > * > &function_map, std::map< types::global_dof_index, number > &boundary_values, const ComponentMask &component_mask={})\\n The CathodeRaySimulator::assemble_system function\\nThe function that computes the matrix entries is again in essence a copy of the corresponding function in step-6:\\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::assemble_system()\\n\\u00a0   {\\n\\u00a0     system_matrix = 0;\\n\\u00a0     system_rhs    = 0;\\n\\u00a0 \\n\\u00a0     const QGauss<dim> quadrature_formula(fe.degree + 1);\\n\\u00a0 \\n\\u00a0     FEValues<dim> fe_values(fe,\\n\\u00a0                             quadrature_formula,\\n\\u00a0                             update_values | update_gradients |\\n\\u00a0                               update_quadrature_points | update_JxW_values);\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell = fe.dofs_per_cell;\\n\\u00a0 \\n\\u00a0     FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0     Vector<double>     cell_rhs(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         cell_matrix = 0;\\n\\u00a0         cell_rhs    = 0;\\n\\u00a0 \\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0         for (const unsigned int q_index : fe_values.quadrature_point_indices())\\n\\u00a0           for (const unsigned int i : fe_values.dof_indices())\\n\\u00a0             {\\n\\u00a0               for (const unsigned int j : fe_values.dof_indices())\\n\\u00a0                 cell_matrix(i, j) +=\\n\\u00a0                   (fe_values.shape_grad(i, q_index) * // grad phi_i(x_q)\\n\\u00a0                    fe_values.shape_grad(j, q_index) * // grad phi_j(x_q)\\n\\u00a0                    fe_values.JxW(q_index));           // dx\\n\\u00a0             }\\n\\u00a0 \\nFEValuesDefinition fe_values.h:63\\nFullMatrixDefinition full_matrix.h:79\\nQGaussDefinition quadrature_lib.h:40\\nint\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nThe only interesting part of this function is how it forms the right hand side of the linear system. Recall that the right hand side of the PDE is   \\n\\\\[\\n   \\\\sum_p (N e)\\\\delta(\\\\mathbf x-\\\\mathbf x_p),\\n   \\\\]\\n\\n where we have used \\\\(p\\\\) to index the particles here to avoid confusion with the shape function \\\\(\\\\varphi_i\\\\); \\\\(\\\\mathbf x_p\\\\) is the position of the \\\\(p\\\\)th particle.\\nWhen multiplied by a test function \\\\(\\\\varphi_i\\\\) and integrated over the domain results in a right hand side vector     \\n\\\\begin{align*}\\n   F_i &= \\\\int_\\\\Omega \\\\varphi_i (\\\\mathbf x)\\\\left[\\n   \\\\sum_p (N e)\\\\delta(\\\\mathbf x-\\\\mathbf x_p) \\\\right] dx\\n   \\\\\\\\  &=  \\\\sum_p (N e) \\\\varphi_i(\\\\mathbf x_p).\\n   \\\\end{align*}\\n\\n Note that the final line no longer contains an integral, and consequently also no occurrence of \\\\(dx\\\\) which would require the appearance of the JxW symbol in our code.\\nFor a given cell \\\\(K\\\\), this cell's contribution to the right hand side is then   \\n\\\\begin{align*}\\n   F_i^K &= \\\\sum_{p, \\\\mathbf x_p\\\\in K} (N e) \\\\varphi_i(\\\\mathbf x_p),\\n   \\\\end{align*}\\n\\n i.e., we only have to worry about those particles that are actually located on the current cell \\\\(K\\\\).\\nIn practice, what we do here is the following: If there are any particles on the current cell, then we first obtain an iterator range pointing to the first particle of that cell as well as the particle past the last one on this cell (or the end iterator) \\u2013 i.e., a half-open range as is common for C++ functions. Knowing now the list of particles, we query their reference locations (with respect to the reference cell), evaluate the shape functions in these reference locations, and compute the force according to the formula above (without any FEValues::JxW).\\nNoteIt is worth pointing out that calling the Particles::ParticleHandler::particles_in_cell() and Particles::ParticleHandler::n_particles_in_cell() functions is not very efficient on problems with a large number of particles. But it illustrates the easiest way to write this algorithm, and so we are willing to incur this cost for the moment for expository purposes. We discuss the issue in more detail in the \\\"possibilities for extensions\\\" section below, and use a better approach in step-70, for example.\\n\\u00a0         if (particle_handler.n_particles_in_cell(cell) > 0)\\n\\u00a0           for (const auto &particle : particle_handler.particles_in_cell(cell))\\n\\u00a0             {\\n\\u00a0               const Point<dim> &reference_location =\\n\\u00a0                 particle.get_reference_location();\\n\\u00a0               for (const unsigned int i : fe_values.dof_indices())\\n\\u00a0                 cell_rhs(i) +=\\n\\u00a0                   (fe.shape_value(i, reference_location) * // phi_i(x_p)\\n\\u00a0                    (-Constants::electrons_per_particle *   // N\\n\\u00a0                     Constants::electron_charge));          // e\\n\\u00a0             }\\n\\u00a0 \\nPointDefinition point.h:111\\nFinally, we can copy the contributions of this cell into the global matrix and right hand side vector:\\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0         constraints.distribute_local_to_global(\\n\\u00a0           cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n CathodeRaySimulator::solve\\nThe function that solves the linear system is then again exactly as in step-6:\\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::solve_field()\\n\\u00a0   {\\n\\u00a0     SolverControl            solver_control(1000, 1e-12);\\n\\u00a0     SolverCG<Vector<double>> solver(solver_control);\\n\\u00a0 \\n\\u00a0     PreconditionSSOR<SparseMatrix<double>> preconditioner;\\n\\u00a0     preconditioner.initialize(system_matrix, 1.2);\\n\\u00a0 \\n\\u00a0     solver.solve(system_matrix, solution, system_rhs, preconditioner);\\n\\u00a0 \\n\\u00a0     constraints.distribute(solution);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nPreconditionSSORDefinition precondition.h:1778\\nPreconditionSSOR::initializevoid initialize(const MatrixType &A, const AdditionalData &parameters=AdditionalData())\\nSolverCGDefinition solver_cg.h:179\\nSolverControlDefinition solver_control.h:67\\n CathodeRaySimulator::refine_grid\\nThe final field-related function is the one that refines the grid. We will call it a number of times in the first time step to obtain a mesh that is well-adapted to the structure of the solution and, in particular, resolves the various singularities in the solution that are due to re-entrant corners and places where the boundary condition type changes. You might want to refer to step-6 again for more details:\\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::refine_grid()\\n\\u00a0   {\\n\\u00a0     Vector<float> estimated_error_per_cell(triangulation.n_active_cells());\\n\\u00a0 \\n\\u00a0     KellyErrorEstimator<dim>::estimate(dof_handler,\\n\\u00a0                                        QGauss<dim - 1>(fe.degree + 1),\\n\\u00a0                                        {},\\n\\u00a0                                        solution,\\n\\u00a0                                        estimated_error_per_cell);\\n\\u00a0 \\n\\u00a0     GridRefinement::refine_and_coarsen_fixed_number(triangulation,\\n\\u00a0                                                     estimated_error_per_cell,\\n\\u00a0                                                     0.1,\\n\\u00a0                                                     0.03);\\n\\u00a0 \\n\\u00a0     triangulation.execute_coarsening_and_refinement();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nKellyErrorEstimator::estimatestatic void estimate(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const Quadrature< dim - 1 > &quadrature, const std::map< types::boundary_id, const Function< spacedim, Number > * > &neumann_bc, const ReadVector< Number > &solution, Vector< float > &error, const ComponentMask &component_mask={}, const Function< spacedim > *coefficients=nullptr, const unsigned int n_threads=numbers::invalid_unsigned_int, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id, const types::material_id material_id=numbers::invalid_material_id, const Strategy strategy=cell_diameter_over_24)\\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nparallel::distributed::Triangulation::execute_coarsening_and_refinementvirtual void execute_coarsening_and_refinement() overrideDefinition tria.cc:3320\\nGridRefinement::refine_and_coarsen_fixed_numbervoid refine_and_coarsen_fixed_number(Triangulation< dim, spacedim > &triangulation, const Vector< Number > &criteria, const double top_fraction_of_cells, const double bottom_fraction_of_cells, const unsigned int max_n_cells=std::numeric_limits< unsigned int >::max())Definition grid_refinement.cc:318\\n CathodeRaySimulator::create_particles\\nLet us now turn to the functions that deal with particles. The first one is about the creation of particles. As mentioned in the introduction, we want to create a particle at points of the cathode if the electric field \\\\(\\\\mathbf E=\\\\nabla V\\\\) exceeds a certain threshold, i.e., if \\\\(|\\\\mathbf E| \\\\ge E_\\\\text{threshold}\\\\), and if furthermore the electric field points into the domain (i.e., if \\\\(\\\\mathbf E \\\\cdot \\\\mathbf n < 0\\\\)). As is common in the finite element method, we evaluate fields (and their derivatives) at specific evaluation points; typically, these are \\\"quadrature points\\\", and so we create a \\\"quadrature formula\\\" that we will use to designate the points at which we want to evaluate the solution. Here, we will simply take QMidpoint implying that we will only check the threshold condition at the midpoints of faces. We then use this to initialize an object of type FEFaceValues to evaluate the solution at these points.\\nAll of this will then be used in a loop over all cells, their faces, and specifically those faces that are at the boundary and, moreover, the cathode part of the boundary.\\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::create_particles()\\n\\u00a0   {\\n\\u00a0     FEFaceValues<dim> fe_face_values(fe,\\n\\u00a0                                      QMidpoint<dim - 1>(),\\n\\u00a0                                      update_quadrature_points |\\n\\u00a0                                        update_gradients |\\n\\u00a0                                        update_normal_vectors);\\n\\u00a0 \\n\\u00a0     std::vector<Tensor<1, dim>> solution_gradients(\\n\\u00a0       fe_face_values.n_quadrature_points);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       for (const auto &face : cell->face_iterators())\\n\\u00a0         if (face->at_boundary() &&\\n\\u00a0             (face->boundary_id() == BoundaryIds::cathode))\\n\\u00a0           {\\n\\u00a0             fe_face_values.reinit(cell, face);\\n\\u00a0 \\nFEFaceValuesDefinition fe_values.h:322\\nQMidpointDefinition quadrature_lib.h:162\\nupdate_normal_vectors@ update_normal_vectorsNormal vectors.Definition fe_update_flags.h:141\\nSo we have found a face on the cathode. Next, we let the FEFaceValues object compute the gradient of the solution at each \\\"quadrature\\\" point, and extract the electric field vector from the gradient in the form of a Tensor variable through the methods discussed in the vector-valued problems documentation topic.\\n\\u00a0             const FEValuesExtractors::Scalar electric_potential(0);\\n\\u00a0             fe_face_values[electric_potential].get_function_gradients(\\n\\u00a0               solution, solution_gradients);\\n\\u00a0             for (const unsigned int q_point :\\n\\u00a0                  fe_face_values.quadrature_point_indices())\\n\\u00a0               {\\n\\u00a0                 const Tensor<1, dim> E = solution_gradients[q_point];\\n\\u00a0 \\nTensorDefinition tensor.h:471\\nFEValuesExtractors::ScalarDefinition fe_values_extractors.h:95\\nElectrons can only escape the cathode if the electric field strength exceeds a threshold and, crucially, if the electric field points into the domain. Once we have that checked, we create a new Particles::Particle object at this location and insert it into the Particles::ParticleHandler object with a unique ID.\\nThe only thing that may be not obvious here is that we also associate with this particle the location in the reference coordinates of the cell we are currently on. This is done because we will in downstream functions compute quantities such as the electric field at the location of the particle (e.g., to compute the forces that act on it when updating its position in each time step). Evaluating a finite element field at arbitrary coordinates is quite an expensive operation because shape functions are really only defined on the reference cell, and so when asking for the electric field at an arbitrary point requires us first to determine what the reference coordinates of that point are. To avoid having to do this over and over, we determine these coordinates once and for all and then store these reference coordinates directly with the particle.\\n\\u00a0                 if ((E * fe_face_values.normal_vector(q_point) < 0) &&\\n\\u00a0                     (E.norm() > Constants::E_threshold))\\n\\u00a0                   {\\n\\u00a0                     const Point<dim> &location =\\n\\u00a0                       fe_face_values.quadrature_point(q_point);\\n\\u00a0 \\n\\u00a0                     Particles::Particle<dim> new_particle;\\n\\u00a0                     new_particle.set_location(location);\\n\\u00a0                     new_particle.set_reference_location(\\n\\u00a0                       mapping.transform_real_to_unit_cell(cell, location));\\n\\u00a0                     new_particle.set_id(next_unused_particle_id);\\n\\u00a0                     particle_handler.insert_particle(new_particle, cell);\\n\\u00a0 \\n\\u00a0                     ++next_unused_particle_id;\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0 \\nAt the end of all of these insertions, we let the particle_handler update some internal statistics about the particles it stores.\\n\\u00a0     particle_handler.update_cached_numbers();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n CathodeRaySimulator::move_particles\\nThe second particle-related function is the one that moves the particles in each time step. To do this, we have to loop over all cells, the particles in each cell, and evaluate the electric field at each of the particles' positions.\\nThe approach used here is conceptually the same used in the assemble_system() function: We loop over all cells, find the particles located there (with the same caveat about the inefficiency of the algorithm used here to find these particles), and use FEPointEvaluation object to evaluate the gradient at these positions:\\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::move_particles()\\n\\u00a0   {\\n\\u00a0     const double dt = time.get_next_step_size();\\n\\u00a0 \\n\\u00a0     Vector<double>            solution_values(fe.n_dofs_per_cell());\\n\\u00a0     FEPointEvaluation<1, dim> evaluator(mapping, fe, update_gradients);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       if (particle_handler.n_particles_in_cell(cell) > 0)\\n\\u00a0         {\\n\\u00a0           const typename Particles::ParticleHandler<\\n\\u00a0             dim>::particle_iterator_range particles_in_cell =\\n\\u00a0             particle_handler.particles_in_cell(cell);\\n\\u00a0 \\n\\u00a0           std::vector<Point<dim>> particle_positions;\\n\\u00a0           for (const auto &particle : particles_in_cell)\\n\\u00a0             particle_positions.push_back(particle.get_reference_location());\\n\\u00a0 \\n\\u00a0           cell->get_dof_values(solution, solution_values);\\n\\u00a0 \\nFEPointEvaluationDefinition fe_point_evaluation.h:1126\\nParticlesDefinition data_out.h:29\\nThen we can ask the FEPointEvaluation object for the gradients of the solution (i.e., the electric field \\\\(\\\\mathbf E\\\\)) at these locations and loop over the individual particles:\\n\\u00a0           evaluator.reinit(cell, particle_positions);\\n\\u00a0           evaluator.evaluate(make_array_view(solution_values),\\n\\u00a0                              EvaluationFlags::gradients);\\n\\u00a0 \\n\\u00a0           {\\n\\u00a0             typename Particles::ParticleHandler<dim>::particle_iterator\\n\\u00a0               particle = particles_in_cell.begin();\\n\\u00a0             for (unsigned int particle_index = 0;\\n\\u00a0                  particle != particles_in_cell.end();\\n\\u00a0                  ++particle, ++particle_index)\\n\\u00a0               {\\n\\u00a0                 const Tensor<1, dim> &E =\\n\\u00a0                   evaluator.get_gradient(particle_index);\\n\\u00a0 \\nmake_array_viewArrayView< std::remove_reference_t< typename std::iterator_traits< Iterator >::reference >, MemorySpaceType > make_array_view(const Iterator begin, const Iterator end)Definition array_view.h:949\\nEvaluationFlags::gradients@ gradientsDefinition evaluation_flags.h:54\\nHaving now obtained the electric field at the location of one of the particles, we use this to update first the velocity and then the position. To do so, let us first get the old velocity out of the properties stored with the particle, compute the acceleration, update the velocity, and store this new velocity again in the properties of the particle. Recall that this corresponds to the first of the following set of update equations discussed in the introduction:       \\n\\\\begin{align*}\\n   \\\\frac{{\\\\mathbf v}_i^{(n)}\\n   -{\\\\mathbf v}_i^{(n-1)}}{\\\\Delta t}\\n   &= \\\\frac{e\\\\nabla V^{(n)}}{m}\\n   \\\\\\\\ \\\\frac{{\\\\mathbf x}_i^{(n)}-{\\\\mathbf x}_i^{(n-1)}}\\n   {\\\\Delta t} &= {\\\\mathbf v}_i^{(n)}.\\n   \\\\end{align*}\\n\\n\\u00a0                 const Tensor<1, dim> old_velocity(particle->get_properties());\\n\\u00a0 \\n\\u00a0                 const Tensor<1, dim> acceleration =\\n\\u00a0                   Constants::electron_charge / Constants::electron_mass * E;\\n\\u00a0 \\n\\u00a0                 const Tensor<1, dim> new_velocity =\\n\\u00a0                   old_velocity + acceleration * dt;\\n\\u00a0 \\n\\u00a0                 particle->set_properties(new_velocity);\\n\\u00a0 \\nWith the new velocity, we can then also update the location of the particle and tell the particle about it.\\n\\u00a0                 const Point<dim> new_location =\\n\\u00a0                   particle->get_location() + dt * new_velocity;\\n\\u00a0                 particle->set_location(new_location);\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0         }\\n\\u00a0 \\nHaving updated the locations and properties (i.e., velocities) of all particles, we need to make sure that the particle_handler again knows which cells they are in, and what their locations in the coordinate system of the reference cell are. The following function does that. (It also makes sure that, in parallel computations, particles are moved from one processor to another processor if a particle moves from the subdomain owned by the former to the subdomain owned by the latter.)\\n\\u00a0     particle_handler.sort_particles_into_subdomains_and_cells();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n CathodeRaySimulator::track_lost_particle\\nThe final particle-related function is the one that is called whenever a particle is lost from the simulation. This typically happens if it leaves the domain. If that happens, this function is called both the cell (which we can ask for its new location) and the cell it was previously on. The function then keeps track of updating the number of particles lost in this time step, the total number of lost particles, and then estimates whether the particle left through the hole in the middle of the anode. We do so by first checking whether the cell it was in last had an \\\\(x\\\\) coordinate to the left of the right boundary (located at \\\\(x=4\\\\)) and the particle now has a position to the right of the right boundary. If that is so, we compute a direction vector of its motion that is normalized so that the \\\\(x\\\\) component of the direction vector is equal to \\\\(1\\\\). With this direction vector, we can compute where it would have intersected the line \\\\(x=4\\\\). If this intersect is between \\\\(0.5\\\\) and \\\\(1.5\\\\), then we claim that the particle left through the hole and increment a counter.\\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::track_lost_particle(\\n\\u00a0     const typename Particles::ParticleIterator<dim>         &particle,\\n\\u00a0     const typename Triangulation<dim>::active_cell_iterator &cell)\\n\\u00a0   {\\n\\u00a0     ++n_recently_lost_particles;\\n\\u00a0     ++n_total_lost_particles;\\n\\u00a0 \\n\\u00a0     const Point<dim> current_location              = particle->get_location();\\n\\u00a0     const Point<dim> approximate_previous_location = cell->center();\\n\\u00a0 \\n\\u00a0     if ((approximate_previous_location[0] < 4) && (current_location[0] > 4))\\n\\u00a0       {\\n\\u00a0         const Tensor<1, dim> direction =\\n\\u00a0           (current_location - approximate_previous_location) /\\n\\u00a0           (current_location[0] - approximate_previous_location[0]);\\n\\u00a0 \\n\\u00a0         const double right_boundary_intercept =\\n\\u00a0           approximate_previous_location[1] +\\n\\u00a0           (4 - approximate_previous_location[0]) * direction[1];\\n\\u00a0         if ((right_boundary_intercept > 0.5) &&\\n\\u00a0             (right_boundary_intercept < 1.5))\\n\\u00a0           ++n_particles_lost_through_anode;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n CathodeRaySimulator::update_timestep_size\\nAs discussed at length in the introduction, we need to respect a time step condition whereby particles can not move further than one cell in one time step. To ensure that this is the case, we again first compute the maximal speed of all particles on each cell, and divide the cell size by that speed. We then compute the next time step size as the minimum of this quantity over all cells, using the safety factor discussed in the introduction, and set this as the desired time step size using the DiscreteTime::set_desired_time_step_size() function.\\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::update_timestep_size()\\n\\u00a0   {\\n\\u00a0     if (time.get_step_number() > 0)\\n\\u00a0       {\\n\\u00a0         double min_cell_size_over_velocity = std::numeric_limits<double>::max();\\n\\u00a0 \\n\\u00a0         for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0           if (particle_handler.n_particles_in_cell(cell) > 0)\\n\\u00a0             {\\n\\u00a0               const double cell_size = cell->minimum_vertex_distance();\\n\\u00a0 \\n\\u00a0               double max_particle_velocity(0.0);\\n\\u00a0 \\n\\u00a0               for (const auto &particle :\\n\\u00a0                    particle_handler.particles_in_cell(cell))\\n\\u00a0                 {\\n\\u00a0                   const Tensor<1, dim> velocity(particle.get_properties());\\n\\u00a0                   max_particle_velocity =\\n\\u00a0                     std::max(max_particle_velocity, velocity.norm());\\n\\u00a0                 }\\n\\u00a0 \\n\\u00a0               if (max_particle_velocity > 0)\\n\\u00a0                 min_cell_size_over_velocity =\\n\\u00a0                   std::min(min_cell_size_over_velocity,\\n\\u00a0                            cell_size / max_particle_velocity);\\n\\u00a0             }\\n\\u00a0 \\n\\u00a0         constexpr double c_safety = 0.5;\\n\\u00a0         time.set_desired_next_step_size(c_safety * 0.5 *\\n\\u00a0                                         min_cell_size_over_velocity);\\n\\u00a0       }\\nstd::min::VectorizedArray< Number, width > min(const ::VectorizedArray< Number, width > &, const ::VectorizedArray< Number, width > &)Definition vectorization.h:6960\\nstd::max::VectorizedArray< Number, width > max(const ::VectorizedArray< Number, width > &, const ::VectorizedArray< Number, width > &)Definition vectorization.h:6943\\nAs mentioned in the introduction, we have to treat the very first time step differently since there, particles are not available yet or do not yet have the information associated that we need for the computation of a reasonable step length. The formulas below follow the discussion in the introduction.\\n\\u00a0     else\\n\\u00a0       {\\n\\u00a0         const QTrapezoid<dim> vertex_quadrature;\\n\\u00a0         FEValues<dim> fe_values(fe, vertex_quadrature, update_gradients);\\n\\u00a0 \\n\\u00a0         std::vector<Tensor<1, dim>> field_gradients(vertex_quadrature.size());\\n\\u00a0 \\n\\u00a0         double min_timestep = std::numeric_limits<double>::max();\\n\\u00a0 \\n\\u00a0         for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0           if (particle_handler.n_particles_in_cell(cell) > 0)\\n\\u00a0             {\\n\\u00a0               const double cell_size = cell->minimum_vertex_distance();\\n\\u00a0 \\n\\u00a0               fe_values.reinit(cell);\\n\\u00a0               fe_values.get_function_gradients(solution, field_gradients);\\n\\u00a0 \\n\\u00a0               double max_E = 0;\\n\\u00a0               for (const auto q_point : fe_values.quadrature_point_indices())\\n\\u00a0                 max_E = std::max(max_E, field_gradients[q_point].norm());\\n\\u00a0 \\n\\u00a0               if (max_E > 0)\\n\\u00a0                 min_timestep =\\n\\u00a0                   std::min(min_timestep,\\n\\u00a0                            std::sqrt(0.5 * cell_size *\\n\\u00a0                                      Constants::electron_mass /\\n\\u00a0                                      Constants::electron_charge / max_E));\\n\\u00a0             }\\n\\u00a0 \\n\\u00a0         time.set_desired_next_step_size(min_timestep);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nQTrapezoidDefinition quadrature_lib.h:191\\nstdSTL namespace.\\nstd::sqrt::VectorizedArray< Number, width > sqrt(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6869\\n The CathodeRaySimulator::output_results() function\\nThe final function implementing pieces of the overall algorithm is the one that generates graphical output. In the current context, we want to output both the electric potential field as well as the particle locations and velocities. But we also want to output the electric field, i.e., the gradient of the solution.\\ndeal.II has a general way how one can compute derived quantities from the solution and output those as well. Here, this is the electric field, but it could also be some other quantity \\u2013 say, the norm of the electric field, or in fact anything else one could want to compute from the solution \\\\(V_h(\\\\mathbf x)\\\\) or its derivatives. This general solution uses the DataPostprocessor class and, in cases like the one here where we want to output a quantity that represents a vector field, the DataPostprocessorVector class.\\nRather than try and explain how this class works, let us simply refer to the documentation of the DataPostprocessorVector class that has essentially this case as a well-documented example.\\n\\u00a0   template <int dim>\\n\\u00a0   class ElectricFieldPostprocessor : public DataPostprocessorVector<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     ElectricFieldPostprocessor()\\n\\u00a0       : DataPostprocessorVector<dim>(\\\"electric_field\\\", update_gradients)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     virtual void evaluate_scalar_field(\\n\\u00a0       const DataPostprocessorInputs::Scalar<dim> &input_data,\\n\\u00a0       std::vector<Vector<double>> &computed_quantities) const override\\n\\u00a0     {\\n\\u00a0       AssertDimension(input_data.solution_gradients.size(),\\n\\u00a0                       computed_quantities.size());\\n\\u00a0 \\n\\u00a0       for (unsigned int p = 0; p < input_data.solution_gradients.size(); ++p)\\n\\u00a0         {\\n\\u00a0           AssertDimension(computed_quantities[p].size(), dim);\\n\\u00a0           for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0             computed_quantities[p][d] = input_data.solution_gradients[p][d];\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nDataPostprocessorVectorDefinition data_postprocessor.h:978\\nDataPostprocessor::evaluate_scalar_fieldvirtual void evaluate_scalar_field(const DataPostprocessorInputs::Scalar< dim > &input_data, std::vector< Vector< double > > &computed_quantities) constDefinition data_postprocessor.cc:48\\nDataPostprocessorInputs::ScalarDefinition data_postprocessor.h:322\\nWith this, the output_results() function becomes relatively straightforward: We use the DataOut class as we have in almost every one of the previous tutorial programs to output the solution (the \\\"electric potential\\\") and we use the postprocessor defined above to also output its gradient (the \\\"electric\\n   field\\\"). This all is then written into a file in VTU format after also associating the current time and time step number with this file, and providing physical units for the two fields to be output.\\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::output_results() const\\n\\u00a0   {\\n\\u00a0     {\\n\\u00a0       ElectricFieldPostprocessor<dim> electric_field;\\n\\u00a0       DataOut<dim>                    data_out;\\n\\u00a0       data_out.attach_dof_handler(dof_handler);\\n\\u00a0       data_out.add_data_vector(solution, \\\"electric_potential\\\");\\n\\u00a0       data_out.add_data_vector(solution, electric_field);\\n\\u00a0       data_out.build_patches();\\n\\u00a0 \\n\\u00a0       DataOutBase::VtkFlags output_flags;\\n\\u00a0       output_flags.time  = time.get_current_time();\\n\\u00a0       output_flags.cycle = time.get_step_number();\\n\\u00a0       output_flags.physical_units[\\\"electric_potential\\\"] = \\\"V\\\";\\n\\u00a0       output_flags.physical_units[\\\"electric_field\\\"]     = \\\"V/m\\\";\\n\\u00a0 \\n\\u00a0       data_out.set_flags(output_flags);\\n\\u00a0 \\n\\u00a0       std::ofstream output(\\\"solution-\\\" +\\n\\u00a0                            Utilities::int_to_string(time.get_step_number(), 4) +\\n\\u00a0                            \\\".vtu\\\");\\n\\u00a0       data_out.write_vtu(output);\\n\\u00a0     }\\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nUtilities::int_to_stringstd::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)Definition utilities.cc:470\\nDataOutBase::VtkFlagsDefinition data_out_base.h:1127\\nDataOutBase::VtkFlags::timedouble timeDefinition data_out_base.h:1138\\nOutput the particle positions and properties is not more complicated. The Particles::DataOut class plays the role of the DataOut class for particles, and all we have to do is tell that class where to take particles from and how to interpret the dim components of the properties \\u2013 namely, as a single vector indicating the velocity, rather than as dim scalar properties. The rest is then the same as above:\\n\\u00a0     {\\n\\u00a0       Particles::DataOut<dim> particle_out;\\n\\u00a0       particle_out.build_patches(\\n\\u00a0         particle_handler,\\n\\u00a0         std::vector<std::string>(dim, \\\"velocity\\\"),\\n\\u00a0         std::vector<DataComponentInterpretation::DataComponentInterpretation>(\\n\\u00a0           dim, DataComponentInterpretation::component_is_part_of_vector));\\n\\u00a0 \\n\\u00a0       DataOutBase::VtkFlags output_flags;\\n\\u00a0       output_flags.time                       = time.get_current_time();\\n\\u00a0       output_flags.cycle                      = time.get_step_number();\\n\\u00a0       output_flags.physical_units[\\\"velocity\\\"] = \\\"m/s\\\";\\n\\u00a0 \\n\\u00a0       particle_out.set_flags(output_flags);\\n\\u00a0 \\n\\u00a0       std::ofstream output(\\\"particles-\\\" +\\n\\u00a0                            Utilities::int_to_string(time.get_step_number(), 4) +\\n\\u00a0                            \\\".vtu\\\");\\n\\u00a0       particle_out.write_vtu(output);\\n\\u00a0     }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nParticles::DataOutDefinition data_out.h:44\\nParticles::DataOut::build_patchesvoid build_patches(const Particles::ParticleHandler< dim, spacedim > &particles, const std::vector< std::string > &data_component_names={}, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretations={})Definition data_out.cc:27\\nDataComponentInterpretation::component_is_part_of_vector@ component_is_part_of_vectorDefinition data_component_interpretation.h:58\\n CathodeRaySimulator::run\\nThe last member function of the principal class of this program is then the driver. At the top, it refines the mesh a number of times by solving the problem (with no particles yet created) on a sequence of finer and finer meshes.\\n\\u00a0   template <int dim>\\n\\u00a0   void CathodeRaySimulator<dim>::run()\\n\\u00a0   {\\n\\u00a0     make_grid();\\n\\u00a0 \\n\\u00a0     const unsigned int n_pre_refinement_cycles = 3;\\n\\u00a0     for (unsigned int refinement_cycle = 0;\\n\\u00a0          refinement_cycle < n_pre_refinement_cycles;\\n\\u00a0          ++refinement_cycle)\\n\\u00a0       {\\n\\u00a0         setup_system();\\n\\u00a0         assemble_system();\\n\\u00a0         solve_field();\\n\\u00a0         refine_grid();\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0 \\nNow do the loop over time. The sequence of steps follows closely the outline of the algorithm discussed in the introduction. As discussed in great detail in the documentation of the DiscreteTime class, while we move the field and particle information forward by one time step, the time stored in the time variable is not consistent with where (some of) these quantities are (in the diction of DiscreteTime, this is the \\\"update\\n   stage\\\"). The call to time.advance_time() makes everything consistent again by setting the time variable to the time at which the field and particles already are, and once we are in this \\\"consistent stage\\\", we can generate graphical output and write information about the current state of the simulation to screen.\\n\\u00a0     setup_system();\\n\\u00a0     do\\n\\u00a0       {\\n\\u00a0         std::cout << \\\"Timestep \\\" << time.get_step_number() + 1 << std::endl;\\n\\u00a0         std::cout << \\\"  Field degrees of freedom:                 \\\"\\n\\u00a0                   << dof_handler.n_dofs() << std::endl;\\n\\u00a0 \\n\\u00a0         assemble_system();\\n\\u00a0         solve_field();\\n\\u00a0 \\n\\u00a0         create_particles();\\n\\u00a0         std::cout << \\\"  Total number of particles in simulation:  \\\"\\n\\u00a0                   << particle_handler.n_global_particles() << std::endl;\\n\\u00a0 \\n\\u00a0         n_recently_lost_particles = 0;\\n\\u00a0         update_timestep_size();\\n\\u00a0         move_particles();\\n\\u00a0 \\n\\u00a0         time.advance_time();\\n\\u00a0 \\n\\u00a0         output_results();\\n\\u00a0 \\n\\u00a0         std::cout << \\\"  Number of particles lost this time step:  \\\"\\n\\u00a0                   << n_recently_lost_particles << std::endl;\\n\\u00a0         if (n_total_lost_particles > 0)\\n\\u00a0           std::cout << \\\"  Fraction of particles lost through anode: \\\"\\n\\u00a0                     << 1. * n_particles_lost_through_anode /\\n\\u00a0                          n_total_lost_particles\\n\\u00a0                     << std::endl;\\n\\u00a0 \\n\\u00a0         std::cout << std::endl\\n\\u00a0                   << \\\"  Now at t=\\\" << time.get_current_time()\\n\\u00a0                   << \\\", dt=\\\" << time.get_previous_step_size() << '.'\\n\\u00a0                   << std::endl\\n\\u00a0                   << std::endl;\\n\\u00a0       }\\n\\u00a0     while (time.is_at_end() == false);\\n\\u00a0   }\\n\\u00a0 } // namespace Step19\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n The main function\\nThe final function of the program is then again the main() function. It is unchanged in all tutorial programs since step-6 and so there is nothing new to discuss:\\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       Step19::CathodeRaySimulator<2> cathode_ray_simulator_2d;\\n\\u00a0       cathode_ray_simulator_2d.run();\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0 \\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nWhen this program is run, it produces output that looks as follows: Timestep 1\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  20\\n  Number of particles lost this time step:  0\\n \\n  Now at t=2.12647e-07, dt=2.12647e-07.\\n \\nTimestep 2\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  40\\n  Number of particles lost this time step:  0\\n \\n  Now at t=4.14362e-07, dt=2.01715e-07.\\n \\nTimestep 3\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  60\\n  Number of particles lost this time step:  0\\n \\n  Now at t=5.23066e-07, dt=1.08704e-07.\\n \\nTimestep 4\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  80\\n  Number of particles lost this time step:  0\\n \\n  Now at t=6.08431e-07, dt=8.53649e-08.\\n \\n \\n...\\n \\n \\nTimestep 1000\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  394\\n  Number of particles lost this time step:  2\\n  Fraction of particles lost through anode: 0.823188\\n \\n  Now at t=3.83822e-05, dt=4.18519e-08.\\n \\nTimestep 1001\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  392\\n  Number of particles lost this time step:  0\\n  Fraction of particles lost through anode: 0.823188\\n \\n  Now at t=3.84244e-05, dt=4.22178e-08.\\n \\n \\n...\\n \\n \\nTimestep 2478\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  364\\n  Number of particles lost this time step:  0\\n  Fraction of particles lost through anode: 0.867745\\n \\n  Now at t=9.99509e-05, dt=4.20455e-08.\\n \\nTimestep 2479\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  364\\n  Number of particles lost this time step:  2\\n  Fraction of particles lost through anode: 0.867871\\n \\n  Now at t=9.99929e-05, dt=4.20105e-08.\\n \\nTimestep 2480\\n  Field degrees of freedom:                 4989\\n  Total number of particles in simulation:  362\\n  Number of particles lost this time step:  2\\n  Fraction of particles lost through anode: 0.867047\\n \\n  Now at t=0.0001, dt=7.11401e-09.\\nPicking a random few time steps, we can visualize the solution in the form of streamlines for the electric field and dots for the electrons (the pictures were created with an earlier version of the program and are no longer exact representations of the solution as currently computed \\u2013 but they are conceptually still correct):    \\n Solution at time step 0 (t=0 seconds). \\n   \\n Solution at time step 1400 (t=0.000068 seconds). \\n   \\n Solution at time step 700 (t=0.000035 seconds). \\n   \\n Solution at time step 2092 (t=0.0001 seconds). \\n That said, a more appropriate way to visualize the results of this program are by creating a video that shows how these electrons move, and how the electric field changes in response to their motion (again showing results of an earlier version of the program):\\n\\n\\n\\n\\n\\nWhat you can see here is how the \\\"focus element\\\" of the boundary with its negative voltage repels the electrons and makes sure that they do not just fly away perpendicular from the cathode (as they do in the initial part of their trajectories). It also shows how the electric field lines move around over time, in response to the charges flying by \\u2013 in other words, the feedback the particles have on the electric field that itself drives the motion of the electrons.\\nThe movie suggests that electrons move in \\\"bunches\\\" or \\\"bursts\\\". One element of this appearance is an artifact of how the movie was created: Every frame of the movie corresponds to one time step, but the time step length varies. More specifically, the fastest particle moving through the smallest cell determines the length of the time step (see the discussion in the introduction), and consequently time steps are small whenever a (fast) particle moves through the small cells at the right edge of the domain; time steps are longer again once the particle has left the domain. This slowing-accelerating effect can easily be visualized by plotting the time step length shown in the screen output.\\nThe second part of this is real, however: The simulation creates a large group of particles in the beginning, and fewer after about the 300th time step. This is probably because of the negative charge of the particles in the simulation: They reduce the magnitude of the electric field at the (also negatively charged electrode) and consequently reduce the number of points on the cathode at which the magnitude exceeds the threshold necessary to draw an electron out of the electrode.\\n Possibilities for extensions\\nMore statistics about electrons \\nAt the end of the day, we are rarely interested in the solution of an equation, but in numbers that can be extracted from it \\u2013 in other words, we want to postprocess* the solution (see the results section of step-4 for an extensive discussion of this concept). Here, what one would likely be most interested in assessing are some statistics about the particles.\\nThe program already computes the fraction of the electrons that leave the domain through the hole in the anode. But there are other quantities one might be interested in. For example, the average velocity of these particles. It would not be very difficult to obtain each particle's velocity from its properties, in the same way as we do in the move_particles() function, and compute statistics from it.\\nA better-synchronized visualization \\nAs discussed above, there is a varying time difference between different frames of the video because we create output for every time step. A better way to create movies would be to generate a new output file in fixed time intervals, regardless of how many time steps lie between each such point.\\nA better time integrator \\nThe problem we are considering in this program is a coupled, multiphysics problem. But the way we solve it is by first computing the (electric) potential field and then updating first the particle velocity and finally the particle locations. This is what is called an \\\"operator-splitting method\\\", a concept we will investigate in more detail in step-58.\\nWhile it is awkward to think of a way to solve this problem that does not involve splitting the problem into a PDE piece and a particles piece, one can (and probably should!) think of a better way to update the particle locations. Specifically, the equations we use to update the particle location are     \\n\\\\begin{align*}\\n  \\\\frac{{\\\\mathbf v}_i^{(n)}-{\\\\mathbf v}_i^{(n-1)}}{\\\\Delta t} &= \\\\frac{e\\\\nabla V^{(n)}}{m}\\n  \\\\\\\\\\n  \\\\frac{{\\\\mathbf x}_i^{(n)}-{\\\\mathbf x}_i^{(n-1)}}{\\\\Delta t} &= {\\\\mathbf v}_i^{(n)}.\\n\\\\end{align*}\\n\\n This corresponds to a Lie splitting where we first update one variable (the velocity) and then, using the already-updated value of the one variable to update the other (the position). It is well understood that the Lie splitting incurs a first order error accuracy in the time step (i.e., the error introduced by the splitting is \\\\({\\\\cal O}(\\\\Delta t)\\\\)) that we know we should avoid because we can do better. Independently, of course, we incur an error of the same rate a second time because we use an Euler-like scheme for each of the two updates (we replace the time derivative by a simple finite difference quotient containing the old and new value, and we evaluate the right hand side only at the end time of the interval, at \\\\(t_n\\\\)), and a better scheme would also use a better way to do this kind of update.\\nBetter strategies would replace the Lie splitting by something like a Strang splitting, and the update of the particle position and velocity by a scheme such as the leapfrog scheme or more generally symplectic integrators such as the Verlet scheme.\\nParallelization \\nIn release mode, the program runs in about 3.5 minutes on one of the author's laptops at the time of writing this. That's acceptable. But what if we wanted to make the simulation three-dimensional? If we wanted to not use a maximum of around 100 particles at any given time (as happens with the parameters used here) but 100,000? If we needed a substantially finer mesh?\\nIn those cases, one would want to run the program not just on a single processor, but in fact on as many as one has available. This requires parallelization of both the PDE solution as well as over particles. In practice, while there are substantial challenges to making this efficient and scale well, these challenges are all addressed in deal.II itself, and have been demonstrated on simulations running on 10,000 or more cores. For example, step-40 shows how to parallelize the finite element part, and step-70 shows how one can then also parallelize the particles part.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2020 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Authors: Wolfgang Bangerth, Rene Gassmoeller, Peter Munch, 2020.\\n */\\n \\n \\n \\n \\n#include <deal.II/base/quadrature_lib.h>\\n \\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/precondition.h>\\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/lac/vector.h>\\n#include <deal.II/lac/affine_constraints.h>\\n \\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_refinement.h>\\n#include <deal.II/grid/grid_tools.h>\\n \\n#include <deal.II/fe/mapping_q.h>\\n#include <deal.II/matrix_free/fe_point_evaluation.h>\\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_values.h>\\n \\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/vector_tools.h>\\n#include <deal.II/numerics/error_estimator.h>\\n \\n \\n#include <deal.II/base/discrete_time.h>\\n#include <deal.II/particles/particle_handler.h>\\n#include <deal.II/particles/data_out.h>\\n \\n#include <fstream>\\n \\nusing namespace dealii;\\n \\n \\n \\nnamespace Step19\\n{\\n namespace BoundaryIds\\n  {\\n constexpr types::boundary_id open          = 101;\\n constexpr types::boundary_id cathode       = 102;\\n constexpr types::boundary_id focus_element = 103;\\n constexpr types::boundary_id anode         = 104;\\n  } // namespace BoundaryIds\\n \\n namespace Constants\\n  {\\n constexpr double electron_mass   = 9.1093837015e-31;\\n constexpr double electron_charge = 1.602176634e-19;\\n \\n constexpr double V0 = 1;\\n \\n constexpr double E_threshold = 0.05;\\n \\n constexpr double electrons_per_particle = 3e15;\\n  } // namespace Constants\\n \\n \\n \\n template <int dim>\\n class CathodeRaySimulator\\n  {\\n public:\\n    CathodeRaySimulator();\\n \\n void run();\\n \\n private:\\n void make_grid();\\n void setup_system();\\n void assemble_system();\\n void solve_field();\\n void refine_grid();\\n \\n void create_particles();\\n void move_particles();\\n void track_lost_particle(\\n const Particles::ParticleIterator<dim>                  &particle,\\n const typename Triangulation<dim>::active_cell_iterator &cell);\\n \\n \\n void update_timestep_size();\\n void output_results() const;\\n \\n Triangulation<dim> triangulation;\\n const MappingQ<dim>       mapping;\\n const FE_Q<dim>           fe;\\n DoFHandler<dim>           dof_handler;\\n AffineConstraints<double> constraints;\\n \\n SparseMatrix<double> system_matrix;\\n SparsityPattern      sparsity_pattern;\\n \\n Vector<double> solution;\\n Vector<double> system_rhs;\\n \\n Particles::ParticleHandler<dim> particle_handler;\\n types::particle_index           next_unused_particle_id;\\n types::particle_index           n_recently_lost_particles;\\n types::particle_index           n_total_lost_particles;\\n types::particle_index           n_particles_lost_through_anode;\\n \\n DiscreteTime time;\\n  };\\n \\n \\n \\n \\n \\n template <int dim>\\n  CathodeRaySimulator<dim>::CathodeRaySimulator()\\n    : mapping(1)\\n    , fe(2)\\n    , dof_handler(triangulation)\\n    , particle_handler(triangulation, mapping, /*n_properties=*/dim)\\n    , next_unused_particle_id(0)\\n    , n_recently_lost_particles(0)\\n    , n_total_lost_particles(0)\\n    , n_particles_lost_through_anode(0)\\n    , time(0, 1e-4)\\n  {\\n    particle_handler.signals.particle_lost.connect(\\n      [this](const typename Particles::ParticleIterator<dim>         &particle,\\n const typename Triangulation<dim>::active_cell_iterator &cell) {\\n        this->track_lost_particle(particle, cell);\\n      });\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::make_grid()\\n  {\\n static_assert(dim == 2,\\n \\\"This function is currently only implemented for 2d.\\\");\\n \\n const double       delta = 0.5;\\n const unsigned int nx    = 5;\\n const unsigned int ny    = 3;\\n \\n const std::vector<Point<dim>> vertices \\n      = {{0, 0},\\n         {1, 0},\\n         {2, 0},\\n         {3, 0},\\n         {4, 0},\\n         {delta, 1},\\n         {1, 1},\\n         {2, 1},\\n         {3, 1},\\n         {4, 1},\\n         {0, 2},\\n         {1, 2},\\n         {2, 2},\\n         {3, 2},\\n         {4, 2}};\\n AssertDimension(vertices.size(), nx * ny);\\n \\n const std::vector<unsigned int> cell_vertices[(nx - 1) * (ny - 1)] = {\\n      {0, 1, nx + 0, nx + 1},\\n      {1, 2, nx + 1, nx + 2},\\n      {2, 3, nx + 2, nx + 3},\\n      {3, 4, nx + 3, nx + 4},\\n \\n      {5, nx + 1, 2 * nx + 0, 2 * nx + 1},\\n      {nx + 1, nx + 2, 2 * nx + 1, 2 * nx + 2},\\n      {nx + 2, nx + 3, 2 * nx + 2, 2 * nx + 3},\\n      {nx + 3, nx + 4, 2 * nx + 3, 2 * nx + 4}};\\n \\n    std::vector<CellData<dim>> cells((nx - 1) * (ny - 1), CellData<dim>());\\n for (unsigned int i = 0; i < cells.size(); ++i)\\n      {\\n        cells[i].vertices    = cell_vertices[i];\\n        cells[i].material_id = 0;\\n      }\\n \\n GridTools::consistently_order_cells(cells);\\n triangulation.create_triangulation(\\n vertices,\\n      cells,\\n SubCellData()); // No boundary information\\n \\n triangulation.refine_global(2);\\n \\n for (auto &cell : triangulation.active_cell_iterators())\\n      for (auto &face : cell->face_iterators())\\n        if (face->at_boundary())\\n          {\\n if ((face->center()[0] > 0) && (face->center()[0] < 0.5) &&\\n                (face->center()[1] > 0) && (face->center()[1] < 2))\\n              face->set_boundary_id(BoundaryIds::cathode);\\n else if ((face->center()[0] > 0) && (face->center()[0] < 2))\\n              face->set_boundary_id(BoundaryIds::focus_element);\\n else if ((face->center()[0] > 4 - 1e-12) &&\\n                     ((face->center()[1] > 1.5) || (face->center()[1] < 0.5)))\\n              face->set_boundary_id(BoundaryIds::anode);\\n else\\n              face->set_boundary_id(BoundaryIds::open);\\n          }\\n \\n triangulation.refine_global(1);\\n  }\\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::setup_system()\\n  {\\n    dof_handler.distribute_dofs(fe);\\n \\n    solution.reinit(dof_handler.n_dofs());\\n    system_rhs.reinit(dof_handler.n_dofs());\\n \\n    constraints.clear();\\n DoFTools::make_hanging_node_constraints(dof_handler, constraints);\\n \\n VectorTools::interpolate_boundary_values(dof_handler,\\n                                             BoundaryIds::cathode,\\n Functions::ConstantFunction<dim>(\\n                                               -Constants::V0),\\n                                             constraints);\\n VectorTools::interpolate_boundary_values(dof_handler,\\n                                             BoundaryIds::focus_element,\\n Functions::ConstantFunction<dim>(\\n                                               -Constants::V0),\\n                                             constraints);\\n VectorTools::interpolate_boundary_values(dof_handler,\\n                                             BoundaryIds::anode,\\n Functions::ConstantFunction<dim>(\\n                                               +Constants::V0),\\n                                             constraints);\\n    constraints.close();\\n \\n DynamicSparsityPattern dsp(dof_handler.n_dofs());\\n DoFTools::make_sparsity_pattern(dof_handler,\\n                                    dsp,\\n                                    constraints,\\n /*keep_constrained_dofs = */ false);\\n    sparsity_pattern.copy_from(dsp);\\n \\n    system_matrix.reinit(sparsity_pattern);\\n  }\\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::assemble_system()\\n  {\\n    system_matrix = 0;\\n    system_rhs    = 0;\\n \\n const QGauss<dim> quadrature_formula(fe.degree + 1);\\n \\n FEValues<dim> fe_values(fe,\\n                            quadrature_formula,\\n update_values | update_gradients |\\n update_quadrature_points | update_JxW_values);\\n \\n const unsigned int dofs_per_cell = fe.dofs_per_cell;\\n \\n FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n Vector<double>     cell_rhs(dofs_per_cell);\\n \\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n cell_matrix = 0;\\n        cell_rhs    = 0;\\n \\n        fe_values.reinit(cell);\\n \\n for (const unsigned int q_index : fe_values.quadrature_point_indices())\\n          for (const unsigned int i : fe_values.dof_indices())\\n            {\\n for (const unsigned int j : fe_values.dof_indices())\\n cell_matrix(i, j) +=\\n                  (fe_values.shape_grad(i, q_index) * // grad phi_i(x_q)\\n                   fe_values.shape_grad(j, q_index) * // grad phi_j(x_q)\\n                   fe_values.JxW(q_index));           // dx\\n            }\\n \\n if (particle_handler.n_particles_in_cell(cell) > 0)\\n for (const auto &particle : particle_handler.particles_in_cell(cell))\\n            {\\n const Point<dim> &reference_location =\\n                particle.get_reference_location();\\n for (const unsigned int i : fe_values.dof_indices())\\n                cell_rhs(i) +=\\n                  (fe.shape_value(i, reference_location) * // phi_i(x_p)\\n                   (-Constants::electrons_per_particle *   // N\\n                    Constants::electron_charge));          // e\\n            }\\n \\n        cell->get_dof_indices(local_dof_indices);\\n        constraints.distribute_local_to_global(\\n          cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);\\n      }\\n  }\\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::solve_field()\\n  {\\n SolverControl            solver_control(1000, 1e-12);\\n SolverCG<Vector<double>> solver(solver_control);\\n \\n PreconditionSSOR<SparseMatrix<double>> preconditioner;\\n    preconditioner.initialize(system_matrix, 1.2);\\n \\n    solver.solve(system_matrix, solution, system_rhs, preconditioner);\\n \\n    constraints.distribute(solution);\\n  }\\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::refine_grid()\\n  {\\n Vector<float> estimated_error_per_cell(triangulation.n_active_cells());\\n \\n KellyErrorEstimator<dim>::estimate(dof_handler,\\n QGauss<dim - 1>(fe.degree + 1),\\n                                       {},\\n                                       solution,\\n                                       estimated_error_per_cell);\\n \\n GridRefinement::refine_and_coarsen_fixed_number(triangulation,\\n                                                    estimated_error_per_cell,\\n                                                    0.1,\\n                                                    0.03);\\n \\n triangulation.execute_coarsening_and_refinement();\\n  }\\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::create_particles()\\n  {\\n FEFaceValues<dim> fe_face_values(fe,\\n QMidpoint<dim - 1>(),\\n update_quadrature_points |\\n update_gradients |\\n update_normal_vectors);\\n \\n    std::vector<Tensor<1, dim>> solution_gradients(\\n      fe_face_values.n_quadrature_points);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      for (const auto &face : cell->face_iterators())\\n        if (face->at_boundary() &&\\n            (face->boundary_id() == BoundaryIds::cathode))\\n          {\\n            fe_face_values.reinit(cell, face);\\n \\n const FEValuesExtractors::Scalar electric_potential(0);\\n            fe_face_values[electric_potential].get_function_gradients(\\n              solution, solution_gradients);\\n for (const unsigned int q_point :\\n                 fe_face_values.quadrature_point_indices())\\n              {\\n const Tensor<1, dim> E = solution_gradients[q_point];\\n \\n if ((E * fe_face_values.normal_vector(q_point) < 0) &&\\n                    (E.norm() > Constants::E_threshold))\\n                  {\\n const Point<dim> &location =\\n                      fe_face_values.quadrature_point(q_point);\\n \\n Particles::Particle<dim> new_particle;\\n                    new_particle.set_location(location);\\n                    new_particle.set_reference_location(\\n                      mapping.transform_real_to_unit_cell(cell, location));\\n                    new_particle.set_id(next_unused_particle_id);\\n                    particle_handler.insert_particle(new_particle, cell);\\n \\n                    ++next_unused_particle_id;\\n                  }\\n              }\\n          }\\n \\n    particle_handler.update_cached_numbers();\\n  }\\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::move_particles()\\n  {\\n const double dt = time.get_next_step_size();\\n \\n Vector<double>            solution_values(fe.n_dofs_per_cell());\\n FEPointEvaluation<1, dim> evaluator(mapping, fe, update_gradients);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      if (particle_handler.n_particles_in_cell(cell) > 0)\\n        {\\n const typename Particles::ParticleHandler<\\n            dim>::particle_iterator_range particles_in_cell =\\n            particle_handler.particles_in_cell(cell);\\n \\n          std::vector<Point<dim>> particle_positions;\\n for (const auto &particle : particles_in_cell)\\n            particle_positions.push_back(particle.get_reference_location());\\n \\n          cell->get_dof_values(solution, solution_values);\\n \\n          evaluator.reinit(cell, particle_positions);\\n          evaluator.evaluate(make_array_view(solution_values),\\n EvaluationFlags::gradients);\\n \\n          {\\n typename Particles::ParticleHandler<dim>::particle_iterator\\n              particle = particles_in_cell.begin();\\n for (unsigned int particle_index = 0;\\n                 particle != particles_in_cell.end();\\n                 ++particle, ++particle_index)\\n              {\\n const Tensor<1, dim> &E =\\n                  evaluator.get_gradient(particle_index);\\n \\n const Tensor<1, dim> old_velocity(particle->get_properties());\\n \\n const Tensor<1, dim> acceleration =\\n                  Constants::electron_charge / Constants::electron_mass * E;\\n \\n const Tensor<1, dim> new_velocity =\\n                  old_velocity + acceleration * dt;\\n \\n                particle->set_properties(new_velocity);\\n \\n const Point<dim> new_location =\\n                  particle->get_location() + dt * new_velocity;\\n                particle->set_location(new_location);\\n              }\\n          }\\n        }\\n \\n    particle_handler.sort_particles_into_subdomains_and_cells();\\n  }\\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::track_lost_particle(\\n const typename Particles::ParticleIterator<dim>         &particle,\\n const typename Triangulation<dim>::active_cell_iterator &cell)\\n  {\\n    ++n_recently_lost_particles;\\n    ++n_total_lost_particles;\\n \\n const Point<dim> current_location              = particle->get_location();\\n const Point<dim> approximate_previous_location = cell->center();\\n \\n if ((approximate_previous_location[0] < 4) && (current_location[0] > 4))\\n      {\\n const Tensor<1, dim> direction =\\n          (current_location - approximate_previous_location) /\\n          (current_location[0] - approximate_previous_location[0]);\\n \\n const double right_boundary_intercept =\\n          approximate_previous_location[1] +\\n          (4 - approximate_previous_location[0]) * direction[1];\\n if ((right_boundary_intercept > 0.5) &&\\n            (right_boundary_intercept < 1.5))\\n          ++n_particles_lost_through_anode;\\n      }\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::update_timestep_size()\\n  {\\n if (time.get_step_number() > 0)\\n      {\\n double min_cell_size_over_velocity = std::numeric_limits<double>::max();\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n          if (particle_handler.n_particles_in_cell(cell) > 0)\\n            {\\n const double cell_size = cell->minimum_vertex_distance();\\n \\n double max_particle_velocity(0.0);\\n \\n for (const auto &particle :\\n                   particle_handler.particles_in_cell(cell))\\n                {\\n const Tensor<1, dim> velocity(particle.get_properties());\\n                  max_particle_velocity =\\n std::max(max_particle_velocity, velocity.norm());\\n                }\\n \\n if (max_particle_velocity > 0)\\n                min_cell_size_over_velocity =\\n std::min(min_cell_size_over_velocity,\\n                           cell_size / max_particle_velocity);\\n            }\\n \\n constexpr double c_safety = 0.5;\\n        time.set_desired_next_step_size(c_safety * 0.5 *\\n                                        min_cell_size_over_velocity);\\n      }\\n else\\n      {\\n const QTrapezoid<dim> vertex_quadrature;\\n FEValues<dim> fe_values(fe, vertex_quadrature, update_gradients);\\n \\n        std::vector<Tensor<1, dim>> field_gradients(vertex_quadrature.size());\\n \\n double min_timestep = std::numeric_limits<double>::max();\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n          if (particle_handler.n_particles_in_cell(cell) > 0)\\n            {\\n const double cell_size = cell->minimum_vertex_distance();\\n \\n              fe_values.reinit(cell);\\n              fe_values.get_function_gradients(solution, field_gradients);\\n \\n double max_E = 0;\\n for (const auto q_point : fe_values.quadrature_point_indices())\\n                max_E = std::max(max_E, field_gradients[q_point].norm());\\n \\n if (max_E > 0)\\n                min_timestep =\\n std::min(min_timestep,\\n std::sqrt(0.5 * cell_size *\\n                                     Constants::electron_mass /\\n                                     Constants::electron_charge / max_E));\\n            }\\n \\n        time.set_desired_next_step_size(min_timestep);\\n      }\\n  }\\n \\n \\n \\n \\n template <int dim>\\n class ElectricFieldPostprocessor : public DataPostprocessorVector<dim>\\n  {\\n public:\\n    ElectricFieldPostprocessor()\\n      : DataPostprocessorVector<dim>(\\\"electric_field\\\", update_gradients)\\n    {}\\n \\n virtual void evaluate_scalar_field(\\n const DataPostprocessorInputs::Scalar<dim> &input_data,\\n      std::vector<Vector<double>> &computed_quantities) const override\\n {\\n AssertDimension(input_data.solution_gradients.size(),\\n                      computed_quantities.size());\\n \\n for (unsigned int p = 0; p < input_data.solution_gradients.size(); ++p)\\n        {\\n AssertDimension(computed_quantities[p].size(), dim);\\n for (unsigned int d = 0; d < dim; ++d)\\n            computed_quantities[p][d] = input_data.solution_gradients[p][d];\\n        }\\n    }\\n  };\\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::output_results() const\\n {\\n    {\\n      ElectricFieldPostprocessor<dim> electric_field;\\n DataOut<dim>                    data_out;\\n      data_out.attach_dof_handler(dof_handler);\\n      data_out.add_data_vector(solution, \\\"electric_potential\\\");\\n      data_out.add_data_vector(solution, electric_field);\\n      data_out.build_patches();\\n \\n DataOutBase::VtkFlags output_flags;\\n      output_flags.time  = time.get_current_time();\\n      output_flags.cycle = time.get_step_number();\\n      output_flags.physical_units[\\\"electric_potential\\\"] = \\\"V\\\";\\n      output_flags.physical_units[\\\"electric_field\\\"]     = \\\"V/m\\\";\\n \\n      data_out.set_flags(output_flags);\\n \\n      std::ofstream output(\\\"solution-\\\" +\\n Utilities::int_to_string(time.get_step_number(), 4) +\\n \\\".vtu\\\");\\n      data_out.write_vtu(output);\\n    }\\n \\n    {\\n Particles::DataOut<dim> particle_out;\\n      particle_out.build_patches(\\n        particle_handler,\\n        std::vector<std::string>(dim, \\\"velocity\\\"),\\n        std::vector<DataComponentInterpretation::DataComponentInterpretation>(\\n          dim, DataComponentInterpretation::component_is_part_of_vector));\\n \\n DataOutBase::VtkFlags output_flags;\\n      output_flags.time                       = time.get_current_time();\\n      output_flags.cycle                      = time.get_step_number();\\n      output_flags.physical_units[\\\"velocity\\\"] = \\\"m/s\\\";\\n \\n      particle_out.set_flags(output_flags);\\n \\n      std::ofstream output(\\\"particles-\\\" +\\n Utilities::int_to_string(time.get_step_number(), 4) +\\n \\\".vtu\\\");\\n      particle_out.write_vtu(output);\\n    }\\n  }\\n \\n \\n \\n template <int dim>\\n void CathodeRaySimulator<dim>::run()\\n  {\\n    make_grid();\\n \\n const unsigned int n_pre_refinement_cycles = 3;\\n for (unsigned int refinement_cycle = 0;\\n         refinement_cycle < n_pre_refinement_cycles;\\n         ++refinement_cycle)\\n      {\\n        setup_system();\\n        assemble_system();\\n        solve_field();\\n        refine_grid();\\n      }\\n \\n \\n    setup_system();\\n do\\n      {\\n        std::cout << \\\"Timestep \\\" << time.get_step_number() + 1 << std::endl;\\n        std::cout << \\\"  Field degrees of freedom:                 \\\"\\n                  << dof_handler.n_dofs() << std::endl;\\n \\n        assemble_system();\\n        solve_field();\\n \\n        create_particles();\\n        std::cout << \\\"  Total number of particles in simulation:  \\\"\\n                  << particle_handler.n_global_particles() << std::endl;\\n \\n        n_recently_lost_particles = 0;\\n        update_timestep_size();\\n        move_particles();\\n \\n        time.advance_time();\\n \\n        output_results();\\n \\n        std::cout << \\\"  Number of particles lost this time step:  \\\"\\n                  << n_recently_lost_particles << std::endl;\\n if (n_total_lost_particles > 0)\\n          std::cout << \\\"  Fraction of particles lost through anode: \\\"\\n                    << 1. * n_particles_lost_through_anode /\\n                         n_total_lost_particles\\n                    << std::endl;\\n \\n        std::cout << std::endl\\n                  << \\\"  Now at t=\\\" << time.get_current_time()\\n                  << \\\", dt=\\\" << time.get_previous_step_size() << '.'\\n                  << std::endl\\n                  << std::endl;\\n      }\\n while (time.is_at_end() == false);\\n  }\\n} // namespace Step19\\n \\n \\n \\n \\nint main()\\n{\\n try\\n    {\\n      Step19::CathodeRaySimulator<2> cathode_ray_simulator_2d;\\n      cathode_ray_simulator_2d.run();\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n \\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n return 0;\\n}\\naffine_constraints.h\\nDataOutInterface::write_vtuvoid write_vtu(std::ostream &out) constDefinition data_out_base.cc:7692\\nDataOutInterface::set_flagsvoid set_flags(const FlagType &flags)Definition data_out_base.cc:8863\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nParticles::ParticleHandler::particles_in_cellparticle_iterator_range particles_in_cell(const typename Triangulation< dim, spacedim >::active_cell_iterator &cell)Definition particle_handler.cc:449\\ndiscrete_time.h\\ndof_handler.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nerror_estimator.h\\nfe_values.h\\nfe_point_evaluation.h\\nfe_q.h\\nfull_matrix.h\\ngrid_refinement.h\\ntria.h\\ngrid_tools.h\\nmapping_q.h\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\nLocalIntegrators::Divergence::normdouble norm(const FEValuesBase< dim > &fe, const ArrayView< const std::vector< Tensor< 1, dim > > > &Du)Definition divergence.h:471\\nPhysics::Elasticity::Kinematics::ESymmetricTensor< 2, dim, Number > E(const Tensor< 2, dim, Number > &F)\\nPhysics::Elasticity::Kinematics::eSymmetricTensor< 2, dim, Number > e(const Tensor< 2, dim, Number > &F)\\nPhysics::Elasticity::Kinematics::dSymmetricTensor< 2, dim, Number > d(const Tensor< 2, dim, Number > &F, const Tensor< 2, dim, Number > &dF_dt)\\nVectorTools::EvaluationFlags::max@ maxDefinition vector_tools_evaluate.h:55\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\ntypes::boundary_idunsigned int boundary_idDefinition types.h:144\\ntypes::particle_indexunsigned int particle_indexDefinition property_pool.h:64\\ndata_out.h\\nparticle_handler.h\\ndata_out.h\\nprecondition.h\\nquadrature_lib.h\\nsolver_cg.h\\nsparse_matrix.h\\nDataOutBase::VtkFlags::cycleunsigned int cycleDefinition data_out_base.h:1150\\nDataOutBase::VtkFlags::physical_unitsstd::map< std::string, std::string > physical_unitsDefinition data_out_base.h:1224\\nDataPostprocessorInputs::Scalar::solution_gradientsstd::vector< Tensor< 1, spacedim > > solution_gradientsDefinition data_postprocessor.h:343\\nvector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"