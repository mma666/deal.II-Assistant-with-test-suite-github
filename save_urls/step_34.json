"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_34.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-34 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-34 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-34 tutorial program\\n\\n\\nThis tutorial depends on step-4.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\n Irrotational flow \\nThe numerical approximation\\n Collocation boundary element method \\n Treating the singular integrals. \\nImplementation\\nTestcase\\n\\n The commented program\\n\\nInclude files\\nSingle and double layer operator kernels\\nThe BEMProblem class\\n\\nBEMProblem::BEMProblem and BEMProblem::read_parameters\\nBEMProblem::read_domain\\nBEMProblem::refine_and_resize\\nBEMProblem::assemble_system\\nBEMProblem::solve_system\\nBEMProblem::compute_errors\\nBEMProblem::compute_exterior_solution\\nBEMProblem::output_results\\nBEMProblem::run\\n\\nThe main() function\\n\\n\\n Results\\n\\nPossibilities for extensions\\n\\n The plain program\\n   \\n\\n\\nThis program was contributed by Luca Heltai (thanks to Michael Gratton for pointing out what the exact solution should have been in the three dimensional case). \\nNoteIf you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation:   \\n\\nIntroduction\\nIrrotational flow \\nThe incompressible motion of an inviscid fluid past a body (for example air past an airplane wing, or air or water past a propeller) is usually modeled by the Euler equations of fluid dynamics:\\n\\n\\\\begin{align*}\\n  \\\\frac{\\\\partial }{\\\\partial t}\\\\mathbf{v} + (\\\\mathbf{v}\\\\cdot\\\\nabla)\\\\mathbf{v}\\n  &=\\n  -\\\\frac{1}{\\\\rho}\\\\nabla p + \\\\mathbf{g}\\n  \\\\qquad &\\\\text{in } \\\\mathbb{R}^n \\\\backslash \\\\Omega\\n  \\\\\\\\\\n  \\\\nabla \\\\cdot \\\\mathbf{v}&=0\\n  &\\\\text{in } \\\\mathbb{R}^n\\\\backslash\\\\Omega\\n\\\\end{align*}\\n\\n where the fluid density \\\\(\\\\rho\\\\) and the acceleration \\\\(\\\\mathbf{g}\\\\) due to external forces are given and the velocity \\\\(\\\\mathbf{v}\\\\) and the pressure \\\\(p\\\\) are the unknowns. Here \\\\(\\\\Omega\\\\) is a closed bounded region representing the body around which the fluid moves.\\nThe above equations can be derived from Navier-Stokes equations assuming that the effects due to viscosity are negligible compared to those due to the pressure gradient, inertial forces and the external forces. This is the opposite case of the Stokes equations discussed in step-22 which are the limit case of dominant viscosity, i.e. where the velocity is so small that inertia forces can be neglected. On the other hand, owing to the assumed incompressibility, the equations are not suited for very high speed gas flows where compressibility and the equation of state of the gas have to be taken into account, leading to the Euler equations of gas dynamics, a hyperbolic system.\\nFor the purpose of this tutorial program, we will consider only stationary flow without external forces:         \\n\\\\begin{align*}\\n  (\\\\mathbf{v}\\\\cdot\\\\nabla)\\\\mathbf{v}\\n  &=\\n  -\\\\frac{1}{\\\\rho}\\\\nabla p\\n  \\\\qquad &\\\\text{in } \\\\mathbb{R}^n \\\\backslash \\\\Omega\\n  \\\\\\\\\\n  \\\\nabla \\\\cdot \\\\mathbf{v}&=0\\n  &\\\\text{in } \\\\mathbb{R}^n\\\\backslash\\\\Omega\\n\\\\end{align*}\\n\\nUniqueness of the solution of the Euler equations is ensured by adding the boundary conditions       \\n\\\\[\\n  \\\\label{eq:boundary-conditions}\\n  \\\\begin{aligned}\\n    \\\\mathbf{n}\\\\cdot\\\\mathbf{v}& = 0 \\\\qquad && \\\\text{ on } \\\\partial\\\\Omega \\\\\\\\\\n    \\\\mathbf{v}& = \\\\mathbf{v}_\\\\infty && \\\\text{ when } |\\\\mathbf{x}| \\\\to \\\\infty,\\n  \\\\end{aligned}\\n\\\\]\\n\\nwhich is to say that the body is at rest in our coordinate systems and is not permeable, and that the fluid has (constant) velocity \\\\(\\\\mathbf{v}_\\\\infty\\\\) at infinity. An alternative viewpoint is that our coordinate system moves along with the body whereas the background fluid is at rest at infinity. Notice that we define the normal \\\\(\\\\mathbf{n}\\\\) as the outer normal to the domain \\\\(\\\\Omega\\\\), which is the opposite of the outer normal to the integration domain.\\nFor both stationary and non stationary flow, the solution process starts by solving for the velocity in the second equation and substituting in the first equation in order to find the pressure. The solution of the stationary Euler equations is typically performed in order to understand the behavior of the given (possibly complex) geometry when a prescribed motion is enforced on the system.\\nThe first step in this process is to change the frame of reference from a coordinate system moving along with the body to one in which the body moves through a fluid that is at rest at infinity. This can be expressed by introducing a new velocity \\\\(\\\\mathbf{\\\\tilde{v}}=\\\\mathbf{v}-\\\\mathbf{v}_\\\\infty\\\\) for which we find that the same equations hold (because  \\\\(\\\\nabla\\\\cdot\\n\\\\mathbf{v}_\\\\infty=0\\\\)) and we have boundary conditions       \\n\\\\[\\n  \\\\label{eq:boundary-conditions-tilde}\\n  \\\\begin{aligned}\\n    \\\\mathbf{n}\\\\cdot\\\\mathbf{\\\\tilde{v}}& = -\\\\mathbf{n}\\\\cdot\\\\mathbf{v}_\\\\infty \\\\qquad && \\\\text{ on } \\\\partial\\\\Omega \\\\\\\\\\n    \\\\mathbf{\\\\tilde{v}}& = 0 && \\\\text{ when } |\\\\mathbf{x}| \\\\to \\\\infty,\\n  \\\\end{aligned}\\n\\\\]\\n\\nIf we assume that the fluid is irrotational, i.e.,  \\\\(\\\\nabla \\\\times\\n\\\\mathbf{v}=0\\\\) in \\\\(\\\\mathbb{R}^n\\\\backslash\\\\Omega\\\\), we can represent the velocity, and consequently also the perturbation velocity, as the gradient of a scalar function:   \\n\\\\[\\n  \\\\mathbf{\\\\tilde{v}}=\\\\nabla\\\\phi,\\n\\\\]\\n\\n and so the second part of Euler equations above can be rewritten as the homogeneous Laplace equation for the unknown \\\\(\\\\phi\\\\):       \\n\\\\begin{align*}\\n\\\\label{laplace}\\n\\\\Delta\\\\phi &= 0 \\\\qquad &&\\\\text{in}\\\\ \\\\mathbb{R}^n\\\\backslash\\\\Omega,\\n           \\\\\\\\\\n           \\\\mathbf{n}\\\\cdot\\\\nabla\\\\phi &= -\\\\mathbf{n}\\\\cdot\\\\mathbf{v}_\\\\infty\\n           && \\\\text{on}\\\\ \\\\partial\\\\Omega\\n\\\\end{align*}\\n\\n while the momentum equation reduces to Bernoulli's equation that expresses the pressure \\\\(p\\\\) as a function of the potential \\\\(\\\\phi\\\\):   \\n\\\\[\\n\\\\frac{p}{\\\\rho} +\\\\frac{1}{2} | \\\\nabla \\\\phi |^2 = 0 \\\\in \\\\Omega.\\n\\\\]\\n\\nSo we can solve the problem by solving the Laplace equation for the potential. We recall that the following functions, called fundamental solutions of the Laplace equation,\\n\\n\\\\[ \\\\begin{aligned}\\n\\\\label{eq:3} G(\\\\mathbf{y}-\\\\mathbf{x}) = &\\n-\\\\frac{1}{2\\\\pi}\\\\ln|\\\\mathbf{y}-\\\\mathbf{x}| \\\\qquad && \\\\text{for } n=2 \\\\\\\\\\nG(\\\\mathbf{y}-\\\\mathbf{x}) = &\\n\\\\frac{1}{4\\\\pi}\\\\frac{1}{|\\\\mathbf{y}-\\\\mathbf{x}|}&& \\\\text{for } n=3,\\n\\\\end{aligned}\\n\\\\]\\n\\nsatisfy in a distributional sense the equation:\\n\\n\\\\[\\n-\\\\Delta_y G(\\\\mathbf{y}-\\\\mathbf{x}) = \\\\delta(\\\\mathbf{y}-\\\\mathbf{x}),\\n\\\\]\\n\\nwhere the derivative is done in the variable \\\\(\\\\mathbf{y}\\\\). By using the usual Green identities, our problem can be written on the boundary \\\\(\\\\partial\\\\Omega = \\\\Gamma\\\\) only. We recall the general definition of the second Green identity:\\n\\n\\\\[\\\\label{green}\\n  \\\\int_{\\\\omega}\\n  (-\\\\Delta u)v\\\\,dx + \\\\int_{\\\\partial\\\\omega} \\\\frac{\\\\partial u}{\\\\partial \\\\tilde{\\\\mathbf{n}} }v \\\\,ds\\n  =\\n  \\\\int_{\\\\omega}\\n  (-\\\\Delta v)u\\\\,dx + \\\\int_{\\\\partial\\\\omega} u\\\\frac{\\\\partial v}{\\\\partial \\\\tilde{\\\\mathbf{n}}} \\\\,ds,\\n\\\\]\\n\\nwhere \\\\(\\\\tilde{\\\\mathbf{n}}\\\\) is the normal to the surface of \\\\(\\\\omega\\\\) pointing outwards from the domain of integration \\\\(\\\\omega\\\\).\\nIn our case the domain of integration is the domain \\\\(\\\\mathbb{R}^n\\\\backslash\\\\Omega\\\\), whose boundary is  \\\\( \\\\Gamma_\\\\infty \\\\cup\\n\\\\Gamma\\\\), where the \\\"boundary\\\" at infinity is defined as\\n\\n\\\\[\\n\\\\Gamma_\\\\infty \\\\dealcoloneq \\\\lim_{r\\\\to\\\\infty} \\\\partial B_r(0).\\n\\\\]\\n\\nIn our program the normals are defined as outer to the domain \\\\(\\\\Omega\\\\), that is, they are in fact inner to the integration domain, and some care is required in defining the various integrals with the correct signs for the normals, i.e. replacing \\\\(\\\\tilde{\\\\mathbf{n}}\\\\) by \\\\(-\\\\mathbf{n}\\\\).\\nIf we substitute \\\\(u\\\\) and \\\\(v\\\\) in the Green identity with the solution \\\\(\\\\phi\\\\) and with the fundamental solution of the Laplace equation respectively, as long as \\\\(\\\\mathbf{x}\\\\) is chosen in the region \\\\(\\\\mathbb{R}^n\\\\backslash\\\\Omega\\\\), we obtain:       \\n\\\\[\\n  \\\\phi(\\\\mathbf{x}) -\\n  \\\\int_{\\\\Gamma\\\\cup\\\\Gamma_\\\\infty}\\\\frac{\\\\partial G(\\\\mathbf{y}-\\\\mathbf{x})}{\\\\partial \\\\mathbf{n}_y}\\\\phi(\\\\mathbf{y})\\\\,ds_y\\n  =\\n  -\\\\int_{\\\\Gamma\\\\cup\\\\Gamma_\\\\infty}G(\\\\mathbf{y}-\\\\mathbf{x})\\\\frac{\\\\partial \\\\phi}{\\\\partial \\\\mathbf{n}_y}(\\\\mathbf{y})\\\\,ds_y\\n  \\\\qquad \\\\forall\\\\mathbf{x}\\\\in \\\\mathbb{R}^n\\\\backslash\\\\Omega\\n\\\\]\\n\\nwhere the normals are now pointing inward the domain of integration.\\nNotice that in the above equation, we also have the integrals on the portion of the boundary at \\\\(\\\\Gamma_\\\\infty\\\\). Using the boundary conditions of our problem, we have that \\\\(\\\\nabla \\\\phi\\\\) is zero at infinity (which simplifies the integral on \\\\(\\\\Gamma_\\\\infty\\\\) on the right hand side).\\nThe integral on \\\\(\\\\Gamma_\\\\infty\\\\) that appears on the left hand side can be treated by observing that \\\\(\\\\nabla\\\\phi=0\\\\) implies that \\\\(\\\\phi\\\\) at infinity is necessarily constant. We define its value to be \\\\(\\\\phi_\\\\infty\\\\). It is an easy exercise to prove that\\n\\n\\\\[\\n-\\\\int_{\\\\Gamma_\\\\infty} \\\\frac{\\\\partial G(\\\\mathbf{y}-\\\\mathbf{x})}\\n{\\\\partial \\\\mathbf{n}_y}\\\\phi_\\\\infty \\\\,ds_y =\\n\\\\lim_{r\\\\to\\\\infty} \\\\int_{\\\\partial B_r(0)} \\\\frac{\\\\mathbf{r}}{r} \\\\cdot \\\\nabla G(\\\\mathbf{y}-\\\\mathbf{x})\\n\\\\phi_\\\\infty \\\\,ds_y = -\\\\phi_\\\\infty.\\n\\\\]\\n\\nUsing this result, we can reduce the above equation only on the boundary \\\\(\\\\Gamma\\\\) using the so-called Single and Double Layer Potential operators:\\n\\n\\\\[\\\\label{integral}\\n  \\\\phi(\\\\mathbf{x}) - (D\\\\phi)(\\\\mathbf{x}) = \\\\phi_\\\\infty\\n  -\\\\left(S \\\\frac{\\\\partial \\\\phi}{\\\\partial n_y}\\\\right)(\\\\mathbf{x})\\n  \\\\qquad \\\\forall\\\\mathbf{x}\\\\in \\\\mathbb{R}^n\\\\backslash\\\\Omega.\\n\\\\]\\n\\n(The name of these operators comes from the fact that they describe the electric potential in \\\\(\\\\mathbb{R}^n\\\\) due to a single thin sheet of charges along a surface, and due to a double sheet of charges and anti-charges along the surface, respectively.)\\nIn our case, we know the Neumann values of \\\\(\\\\phi\\\\) on the boundary: \\\\(\\\\mathbf{n}\\\\cdot\\\\nabla\\\\phi = -\\\\mathbf{n}\\\\cdot\\\\mathbf{v}_\\\\infty\\\\). Consequently,     \\n\\\\[\\n  \\\\phi(\\\\mathbf{x}) - (D\\\\phi)(\\\\mathbf{x}) = \\\\phi_\\\\infty +\\n   \\\\left(S[\\\\mathbf{n}\\\\cdot\\\\mathbf{v}_\\\\infty]\\\\right)(\\\\mathbf{x})\\n   \\\\qquad \\\\forall\\\\mathbf{x} \\\\in \\\\mathbb{R}^n\\\\backslash\\\\Omega.\\n\\\\]\\n\\n If we take the limit for \\\\(\\\\mathbf{x}\\\\) tending to \\\\(\\\\Gamma\\\\) of the above equation, using well known properties of the single and double layer operators, we obtain an equation for \\\\(\\\\phi\\\\) just on the boundary \\\\(\\\\Gamma\\\\) of \\\\(\\\\Omega\\\\):\\n\\n\\\\[\\\\label{SD}\\n  \\\\alpha(\\\\mathbf{x})\\\\phi(\\\\mathbf{x}) - (D\\\\phi)(\\\\mathbf{x}) = \\\\phi_\\\\infty +\\n  \\\\left(S [\\\\mathbf{n}\\\\cdot\\\\mathbf{v}_\\\\infty]\\\\right)(\\\\mathbf{x})\\n  \\\\quad \\\\mathbf{x}\\\\in \\\\partial\\\\Omega,\\n\\\\]\\n\\nwhich is the Boundary Integral Equation (BIE) we were looking for, where the quantity \\\\(\\\\alpha(\\\\mathbf{x})\\\\) is the fraction of angle or solid angle by which the point \\\\(\\\\mathbf{x}\\\\) sees the domain of integration \\\\(\\\\mathbb{R}^n\\\\backslash\\\\Omega\\\\).\\nIn particular, at points \\\\(\\\\mathbf{x}\\\\) where the boundary \\\\(\\\\partial\\\\Omega\\\\) is differentiable (i.e. smooth) we have \\\\(\\\\alpha(\\\\mathbf{x})=\\\\frac 12\\\\), but the value may be smaller or larger at points where the boundary has a corner or an edge.\\nSubstituting the single and double layer operators we get:        \\n\\\\[\\n  \\\\alpha(\\\\mathbf{x}) \\\\phi(\\\\mathbf{x})\\n  + \\\\frac{1}{2\\\\pi}\\\\int_{\\\\partial \\\\Omega}  \\\\frac{\\n  (\\\\mathbf{y}-\\\\mathbf{x})\\\\cdot\\\\mathbf{n}_y  }{ |\\\\mathbf{y}-\\\\mathbf{x}|^2 }\\n  \\\\phi(\\\\mathbf{y}) \\\\,ds_y\\n  = \\\\phi_\\\\infty\\n    -\\\\frac{1}{2\\\\pi}\\\\int_{\\\\partial \\\\Omega}  \\\\ln|\\\\mathbf{y}-\\\\mathbf{x}| \\\\, \\\\mathbf{n}\\\\cdot\\\\mathbf{v_\\\\infty}\\\\,ds_y\\n\\\\]\\n\\n for two dimensional flows and      \\n\\\\[\\n  \\\\alpha(\\\\mathbf{x}) \\\\phi(\\\\mathbf{x})\\n   + \\\\frac{1}{4\\\\pi}\\\\int_{\\\\partial \\\\Omega} \\\\frac{ (\\\\mathbf{y}-\\\\mathbf{x})\\\\cdot\\\\mathbf{n}_y  }{ |\\\\mathbf{y}-\\\\mathbf{x}|^3 }\\\\phi(\\\\mathbf{y})\\\\,ds_y\\n  = \\\\phi_\\\\infty +\\n  \\\\frac{1}{4\\\\pi}\\\\int_{\\\\partial \\\\Omega} \\\\frac{1}{|\\\\mathbf{y}-\\\\mathbf{x}|} \\\\, \\\\mathbf{n}\\\\cdot\\\\mathbf{v_\\\\infty}\\\\,ds_y\\n\\\\]\\n\\n for three dimensional flows, where the normal derivatives of the fundamental solutions have been written in a form that makes computation easier. In either case, \\\\(\\\\phi\\\\) is the solution of an integral equation posed entirely on the boundary since both \\\\(\\\\mathbf{x},\\\\mathbf{y}\\\\in\\\\partial\\\\Omega\\\\).\\nNotice that the fraction of angle (in 2d) or solid angle (in 3d) \\\\(\\\\alpha(\\\\mathbf{x})\\\\) by which the point \\\\(\\\\mathbf{x}\\\\) sees the domain \\\\(\\\\Omega\\\\) can be defined using the double layer potential itself:      \\n\\\\[\\n\\\\alpha(\\\\mathbf{x}) \\\\dealcoloneq 1 -\\n\\\\frac{1}{2(n-1)\\\\pi}\\\\int_{\\\\partial \\\\Omega} \\\\frac{ (\\\\mathbf{y}-\\\\mathbf{x})\\\\cdot\\\\mathbf{n}_y  }\\n{ |\\\\mathbf{y}-\\\\mathbf{x}|^{n} }\\\\phi(\\\\mathbf{y})\\\\,ds_y = 1+\\n\\\\int_{\\\\partial \\\\Omega} \\\\frac{ \\\\partial G(\\\\mathbf{y}-\\\\mathbf{x}) }{\\\\partial \\\\mathbf{n}_y} \\\\, ds_y.\\n\\\\]\\n\\nThe reason why this is possible can be understood if we consider the fact that the solution of a pure Neumann problem is known up to an arbitrary constant \\\\(c\\\\), which means that, if we set the Neumann data to be zero, then any constant \\\\(\\\\phi = \\\\phi_\\\\infty\\\\) will be a solution. Inserting the constant solution and the Neumann boundary condition in the boundary integral equation, we have          \\n\\\\begin{align*}\\n\\\\alpha\\\\left(\\\\mathbf{x}\\\\right)\\\\phi\\\\left(\\\\mathbf{x}\\\\right)\\n&=\\\\int_{\\\\Omega}\\\\phi\\\\left(\\\\mathbf{y}\\\\right)\\\\delta\\\\left(\\\\mathbf{y}-\\\\mathbf{x}\\\\right)\\\\, dy\\\\\\\\\\n\\\\Rightarrow\\n\\\\alpha\\\\left(\\\\mathbf{x}\\\\right)\\\\phi_\\\\infty\\n&=\\\\phi_\\\\infty\\\\int_{\\\\Gamma\\\\cup\\\\Gamma_\\\\infty}\\\\frac{ \\\\partial G(\\\\mathbf{y}-\\\\mathbf{x}) }{\\\\partial \\\\mathbf{n}_y} \\\\, ds_y\\n=\\\\phi_\\\\infty\\\\left[\\\\int_{\\\\Gamma_\\\\infty}\\\\frac{ \\\\partial G(\\\\mathbf{y}-\\\\mathbf{x}) }{\\\\partial \\\\mathbf{n}_y} \\\\, ds_y\\n+\\\\int_{\\\\Gamma}\\\\frac{ \\\\partial G(\\\\mathbf{y}-\\\\mathbf{x}) }{\\\\partial \\\\mathbf{n}_y} \\\\, ds_y\\n\\\\right]\\n\\\\end{align*}\\n\\n The integral on \\\\(\\\\Gamma_\\\\infty\\\\) is unity, see above, so division by the constant \\\\(\\\\phi_\\\\infty\\\\) gives us the explicit expression above for \\\\(\\\\alpha(\\\\mathbf{x})\\\\).\\nWhile this example program is really only focused on the solution of the boundary integral equation, in a realistic setup one would still need to solve for the velocities. To this end, note that we have just computed \\\\(\\\\phi(\\\\mathbf{x})\\\\) for all \\\\(\\\\mathbf{x}\\\\in\\\\partial\\\\Omega\\\\). In the next step, we can compute (analytically, if we want) the solution \\\\(\\\\phi(\\\\mathbf{x})\\\\) in all of \\\\(\\\\mathbb{R}^n\\\\backslash\\\\Omega\\\\). To this end, recall that we had         \\n\\\\[\\n  \\\\phi(\\\\mathbf{x})\\n  =\\n  \\\\phi_\\\\infty +\\n  (D\\\\phi)(\\\\mathbf{x})\\n  +\\n  \\\\left(S[\\\\mathbf{n}\\\\cdot\\\\mathbf{v}_\\\\infty]\\\\right)(\\\\mathbf{x})\\n  \\\\qquad \\\\forall\\\\mathbf{x}\\\\in \\\\mathbb{R}^n\\\\backslash\\\\Omega.\\n\\\\]\\n\\n where now we have everything that is on the right hand side ( \\\\(S\\\\) and \\\\(D\\\\) are integrals we can evaluate, the normal velocity on the boundary is given, and \\\\(\\\\phi\\\\) on the boundary we have just computed). Finally, we can then recover the velocity as \\\\(\\\\mathbf{\\\\tilde v}=\\\\nabla \\\\phi\\\\).\\nNotice that the evaluation of the above formula for  \\\\(\\\\mathbf{x} \\\\in\\n\\\\Omega\\\\) should yield zero as a result, since the integration of the Dirac delta \\\\(\\\\delta(\\\\mathbf{x})\\\\) in the domain \\\\(\\\\mathbb{R}^n\\\\backslash\\\\Omega\\\\) is always zero by definition.\\nAs a final test, let us verify that this velocity indeed satisfies the momentum balance equation for a stationary flow field, i.e., whether \\\\(\\\\mathbf{v}\\\\cdot\\\\nabla\\\\mathbf{v} = -\\\\frac 1\\\\rho \\\\nabla p\\\\) where  \\\\(\\\\mathbf{v}=\\\\mathbf{\\\\tilde\\nv}+\\\\mathbf{v}_\\\\infty=\\\\nabla\\\\phi+\\\\mathbf{v}_\\\\infty\\\\) for some (unknown) pressure \\\\(p\\\\) and a given constant \\\\(\\\\rho\\\\). In other words, we would like to verify that Bernoulli's law as stated above indeed holds. To show this, we use that the left hand side of this equation equates to        \\n\\\\begin{align*}\\n  \\\\mathbf{v}\\\\cdot\\\\nabla\\\\mathbf{v}\\n  &=\\n  [(\\\\nabla\\\\phi+\\\\mathbf{v}_\\\\infty)\\\\cdot\\\\nabla] (\\\\nabla\\\\phi+\\\\mathbf{v}_\\\\infty)\\n  \\\\\\\\\\n  &=\\n  [(\\\\nabla\\\\phi+\\\\mathbf{v}_\\\\infty)\\\\cdot\\\\nabla] (\\\\nabla\\\\phi)\\n\\\\end{align*}\\n\\n where we have used that \\\\(\\\\mathbf{v}_\\\\infty\\\\) is constant. We would like to write this expression as the gradient of something (remember that \\\\(\\\\rho\\\\) is a constant). The next step is more convenient if we consider the components of the equation individually (summation over indices that appear twice is implied):             \\n\\\\begin{align*}\\n  [\\\\mathbf{v}\\\\cdot\\\\nabla\\\\mathbf{v}]_i\\n  &=\\n  (\\\\partial_j\\\\phi+v_{\\\\infty,j}) \\\\partial_j \\\\partial_i\\\\phi\\n  \\\\\\\\\\n  &=\\n  \\\\partial_j [(\\\\partial_j\\\\phi+v_{\\\\infty,j}) \\\\partial_i\\\\phi]\\n  -\\n  \\\\partial_j [(\\\\partial_j\\\\phi+v_{\\\\infty,j})] \\\\partial_i\\\\phi\\n  \\\\\\\\\\n  &=\\n  \\\\partial_j [(\\\\partial_j\\\\phi+v_{\\\\infty,j}) \\\\partial_i\\\\phi]\\n\\\\end{align*}\\n\\n because \\\\(\\\\partial_j \\\\partial_j\\\\phi = \\\\Delta \\\\phi = 0\\\\) and  \\\\(\\\\textrm{div}\\n\\\\ \\\\mathbf{v}_\\\\infty=0\\\\). Next,                               \\n\\\\begin{align*}\\n  [\\\\mathbf{v}\\\\cdot\\\\nabla\\\\mathbf{v}]_i\\n  &=\\n  \\\\partial_j [(\\\\partial_j\\\\phi+v_{\\\\infty,j}) \\\\partial_i\\\\phi]\\n  \\\\\\\\\\n  &=\\n  \\\\partial_j [(\\\\partial_j\\\\phi) (\\\\partial_i\\\\phi)]\\n  +\\n  \\\\partial_j [v_{\\\\infty,j} \\\\partial_i\\\\phi]\\n  \\\\\\\\\\n  &=\\n  \\\\partial_j [(\\\\partial_j\\\\phi) (\\\\partial_i\\\\phi)]\\n  +\\n  \\\\partial_j [v_{\\\\infty,j}] \\\\partial_i\\\\phi\\n  +\\n  v_{\\\\infty,j} \\\\partial_j \\\\partial_i\\\\phi\\n  \\\\\\\\\\n  &=\\n  \\\\partial_j [(\\\\partial_j\\\\phi) (\\\\partial_i\\\\phi)]\\n  +\\n  v_{\\\\infty,j} \\\\partial_j \\\\partial_i\\\\phi\\n  \\\\\\\\\\n  &=\\n  \\\\partial_i \\\\partial_j [(\\\\partial_j\\\\phi) \\\\phi]\\n  -\\n  \\\\partial_j [\\\\partial_i (\\\\partial_j\\\\phi) \\\\phi]\\n  +\\n  \\\\partial_i [v_{\\\\infty,j} \\\\partial_j \\\\phi]\\n  -\\n  \\\\partial_i [v_{\\\\infty,j}] \\\\partial_j \\\\phi\\n\\\\end{align*}\\n\\n Again, the last term disappears because \\\\(\\\\mathbf{v}_\\\\infty\\\\) is constant and we can merge the first and third term into one:            \\n\\\\begin{align*}\\n  [\\\\mathbf{v}\\\\cdot\\\\nabla\\\\mathbf{v}]_i\\n  &=\\n  \\\\partial_i (\\\\partial_j [(\\\\partial_j\\\\phi) \\\\phi + v_{\\\\infty,j} \\\\partial_j \\\\phi])\\n  -\\n  \\\\partial_j [\\\\partial_i (\\\\partial_j\\\\phi) \\\\phi]\\n  \\\\\\\\\\n  &=\\n  \\\\partial_i [(\\\\partial_j\\\\phi)(\\\\partial_j \\\\phi) + v_{\\\\infty,j} \\\\partial_j \\\\phi]\\n  -\\n  \\\\partial_j [\\\\partial_i (\\\\partial_j\\\\phi) \\\\phi]\\n\\\\end{align*}\\n\\nWe now only need to massage that last term a bit more. Using the product rule, we get       \\n\\\\begin{align*}\\n  \\\\partial_j [\\\\partial_i (\\\\partial_j\\\\phi) \\\\phi]\\n  &=\\n  \\\\partial_i [\\\\partial_j \\\\partial_j\\\\phi] \\\\phi\\n  +\\n  \\\\partial_i [\\\\partial_j \\\\phi] (\\\\partial_j \\\\phi).\\n\\\\end{align*}\\n\\n The first of these terms is zero (because, again, the summation over \\\\(j\\\\) gives \\\\(\\\\Delta\\\\phi\\\\), which is zero). The last term can be written as  \\\\(\\\\frac 12\\n\\\\partial_i [(\\\\partial_j\\\\phi)(\\\\partial_j\\\\phi)]\\\\) which is in the desired gradient form. As a consequence, we can now finally state that                     \\n\\\\begin{align*}\\n  [\\\\mathbf{v}\\\\cdot\\\\nabla\\\\mathbf{v}]_i\\n  &=\\n  \\\\partial_i (\\\\partial_j [(\\\\partial_j\\\\phi) \\\\phi + v_{\\\\infty,j} \\\\partial_j \\\\phi])\\n  -\\n  \\\\partial_j [\\\\partial_i (\\\\partial_j\\\\phi) \\\\phi]\\n  \\\\\\\\\\n  &=\\n  \\\\partial_i\\n  \\\\left[\\n    (\\\\partial_j\\\\phi)(\\\\partial_j \\\\phi) + v_{\\\\infty,j} \\\\partial_j \\\\phi\\n    -\\n    \\\\frac 12 (\\\\partial_j\\\\phi)(\\\\partial_j\\\\phi)\\n  \\\\right],\\n  \\\\\\\\\\n  &=\\n  \\\\partial_i\\n  \\\\left[\\n    \\\\frac 12 (\\\\partial_j\\\\phi)(\\\\partial_j \\\\phi) + v_{\\\\infty,j} \\\\partial_j \\\\phi\\n  \\\\right],\\n\\\\end{align*}\\n\\n or in vector form:         \\n\\\\[\\n  \\\\mathbf{v}\\\\cdot\\\\nabla\\\\mathbf{v}\\n  =\\n  \\\\nabla\\n  \\\\left[\\n    \\\\frac 12 \\\\mathbf{\\\\tilde v}^2\\n    + \\\\mathbf{v}_{\\\\infty} \\\\cdot \\\\mathbf{\\\\tilde v}\\n  \\\\right],\\n\\\\]\\n\\n or in other words:                 \\n\\\\[\\n  p\\n  =\\n  -\\\\rho\\n  \\\\left[\\n    \\\\frac 12 \\\\mathbf{\\\\tilde v}^2\\n    + \\\\mathbf{v}_{\\\\infty} \\\\cdot \\\\mathbf{\\\\tilde v}\\n  \\\\right]\\n  =\\n  -\\\\rho\\n  \\\\left[\\n    \\\\frac 12 \\\\mathbf{v}^2\\n    -\\n    \\\\frac 12 \\\\mathbf{v}_{\\\\infty}^2\\n  \\\\right]\\n  .\\n\\\\]\\n\\n Because the pressure is only determined up to a constant (it appears only with a gradient in the equations), an equally valid definition is      \\n\\\\[\\n  p\\n  =\\n  -\\\\frac 12 \\\\rho \\\\mathbf{v}^2\\n  .\\n\\\\]\\n\\n This is exactly Bernoulli's law mentioned above.\\nThe numerical approximation\\nNumerical approximations of Boundary Integral Equations (BIE) are commonly referred to as the boundary element method or panel method (the latter expression being used mostly in the computational fluid dynamics community). The goal of the following test problem is to solve the integral formulation of the Laplace equation with Neumann boundary conditions, using a circle and a sphere respectively in two and three space dimensions, illustrating along the way the features that allow one to treat boundary element problems almost as easily as finite element problems using the deal.II library.\\nTo this end, let \\\\(\\\\mathcal{T}_h = \\\\bigcup_i K_i\\\\) be a subdivision of the manifold \\\\(\\\\Gamma = \\\\partial \\\\Omega\\\\) into \\\\(M\\\\) line segments if \\\\(n=2\\\\), or \\\\(M\\\\) quadrilaterals if \\\\(n=3\\\\). We will call each individual segment or quadrilateral an element or cell, independently of the dimension \\\\(n\\\\) of the surrounding space \\\\(\\\\mathbb{R}^n\\\\). We define the finite dimensional space \\\\(V_h\\\\) as     \\n\\\\[\\n  \\\\label{eq:definition-Vh}\\n  V_h \\\\dealcoloneq \\\\{ v \\\\in C^0(\\\\Gamma) \\\\text{ s.t. } v|_{K_i} \\\\in \\\\mathcal{Q}^1(K_i),\\n  \\\\forall i\\\\},\\n\\\\]\\n\\n with basis functions \\\\(\\\\psi_i(\\\\mathbf{x})\\\\) for which we will use the usual FE_Q finite element, with the catch that this time it is defined on a manifold of codimension one (which we do by using the second template argument that is usually defaulted to equal the first; here, we will create objects FE_Q<dim-1,dim> to indicate that we have dim-1 dimensional cells in a dim dimensional space). An element \\\\(\\\\phi_h\\\\) of \\\\(V_h\\\\) is uniquely identified by the vector \\\\(\\\\boldsymbol{\\\\phi}\\\\) of its coefficients \\\\(\\\\phi_i\\\\), that is:     \\n\\\\[\\n  \\\\label{eq:definition-of-element}\\n  \\\\phi_h(\\\\mathbf{x}) \\\\dealcoloneq \\\\phi_i \\\\psi_i(\\\\mathbf{x}), \\\\qquad\\n  \\\\boldsymbol{\\\\phi} \\\\dealcoloneq \\\\{ \\\\phi_i \\\\},\\n\\\\]\\n\\n where summation is implied over repeated indexes. Note that we could use discontinuous elements here \\u2014 in fact, there is no real reason to use continuous ones since the integral formulation does not imply any derivatives on our trial functions so continuity is unnecessary, and often in the literature only piecewise constant elements are used.\\nCollocation boundary element method \\nBy far, the most common approximation of boundary integral equations is by use of the collocation based boundary element method.\\nThis method requires the evaluation of the boundary integral equation at a number of collocation points which is equal to the number of unknowns of the system. The choice of these points is a delicate matter, that requires a careful study. Assume that these points are known for the moment, and call them \\\\(\\\\mathbf x_i\\\\) with \\\\(i=0...n\\\\_dofs\\\\).\\nThe problem then becomes: Given the datum \\\\(\\\\mathbf{v}_\\\\infty\\\\), find a function \\\\(\\\\phi_h\\\\) in \\\\(V_h\\\\) such that the following \\\\(n\\\\_dofs\\\\) equations are satisfied:\\n\\n\\\\begin{align*}\\n    \\\\alpha(\\\\mathbf{x}_i) \\\\phi_h(\\\\mathbf{x}_i)\\n    - \\\\int_{\\\\Gamma_y} \\\\frac{ \\\\partial G(\\\\mathbf{y}-\\\\mathbf{x}_i)}{\\\\partial\\\\mathbf{n}_y }\\n    \\\\phi_h(\\\\mathbf{y}) \\\\,ds_y =\\n    \\\\int_{\\\\Gamma_y} G(\\\\mathbf{y}-\\\\mathbf{x}_i) \\\\,\\n    \\\\mathbf{n}_y\\\\cdot\\\\mathbf{v_\\\\infty} \\\\,ds_y\\n    ,\\n\\\\end{align*}\\n\\nwhere the quantity \\\\(\\\\alpha(\\\\mathbf{x}_i)\\\\) is the fraction of (solid) angle by which the point \\\\(\\\\mathbf{x}_i\\\\) sees the domain \\\\(\\\\Omega\\\\), as explained above, and we set \\\\(\\\\phi_\\\\infty\\\\) to be zero. If the support points \\\\(\\\\mathbf{x}_i\\\\) are chosen appropriately, then the problem can be written as the following linear system:\\n\\n\\\\[\\n\\\\label{eq:linear-system}\\n(\\\\mathbf{A}+\\\\mathbf{N})\\\\boldsymbol\\\\phi = \\\\mathbf{b},\\n\\\\]\\n\\nwhere\\n\\n\\\\[\\n\\\\begin{aligned}\\n\\\\mathbf{A}_{ij}&=\\n\\\\alpha(\\\\mathbf{x}_i) \\\\psi_j(\\\\mathbf{x}_i)\\n= \\\\left (1+\\\\int_\\\\Gamma\\n\\\\frac{\\\\partial G(\\\\mathbf{y}-\\\\mathbf{x}_i)}{\\\\partial \\\\mathbf{n}_y}\\\\,ds_y \\\\right )\\n\\\\psi_j(\\\\mathbf{x}_i)\\n\\\\\\\\\\n\\\\mathbf{N}_{ij}&= - \\\\int_\\\\Gamma\\n  \\\\frac{\\\\partial G(\\\\mathbf{y}-\\\\mathbf{x}_i)}{\\\\partial \\\\mathbf{n}_y}\\n  \\\\psi_j(\\\\mathbf{y}) \\\\,ds_y\\n\\\\\\\\\\n\\\\mathbf{b}_i&= \\\\int_\\\\Gamma\\n   G(\\\\mathbf{y}-\\\\mathbf{x}_i)  \\\\, \\\\mathbf{n}_y\\\\cdot\\\\mathbf{v_\\\\infty}\\n   ds_y.\\n\\\\end{aligned}\\n\\\\]\\n\\nFrom a linear algebra point of view, the best possible choice of the collocation points is the one that renders the matrix \\\\(\\\\mathbf{A}+\\\\mathbf{N}\\\\) the most diagonally dominant. A natural choice is then to select the \\\\(\\\\mathbf{x}_i\\\\) collocation points to be the support points of the nodal basis functions \\\\(\\\\psi_i(\\\\mathbf{x})\\\\). In that case, \\\\(\\\\psi_j(\\\\mathbf{x}_i)=\\\\delta_{ij}\\\\), and as a consequence the matrix \\\\(\\\\mathbf{A}\\\\) is diagonal with entries        \\n\\\\[\\n  \\\\mathbf{A}_{ii}\\n  =\\n  1+\\\\int_\\\\Gamma\\n  \\\\frac{\\\\partial G(\\\\mathbf{y}-\\\\mathbf{x}_i)}{\\\\partial \\\\mathbf{n}_y}\\\\,ds_y\\n  =\\n  1-\\\\sum_j N_{ij},\\n\\\\]\\n\\n where we have used that \\\\(\\\\sum_j \\\\psi_j(\\\\mathbf{y})=1\\\\) for the usual Lagrange elements. With this choice of collocation points, the computation of the entries of the matrices \\\\(\\\\mathbf{A}\\\\), \\\\(\\\\mathbf{N}\\\\) and of the right hand side \\\\(\\\\mathbf{b}\\\\) requires the evaluation of singular integrals on the elements \\\\(K_i\\\\) of the triangulation \\\\(\\\\mathcal{T}_h\\\\). As usual in these cases, all integrations are performed on a reference simple domain, i.e., we assume that each element \\\\(K_i\\\\) of \\\\(\\\\mathcal{T}_h\\\\) can be expressed as a linear (in two dimensions) or bi-linear (in three dimensions) transformation of the reference boundary element \\\\(\\\\hat K \\\\dealcoloneq [0,1]^{n-1}\\\\), and we perform the integrations after a change of variables from the real element \\\\(K_i\\\\) to the reference element \\\\(\\\\hat K\\\\).\\nTreating the singular integrals. \\nIn two dimensions it is not necessary to compute the diagonal elements \\\\(\\\\mathbf{N}_{ii}\\\\) of the system matrix, since, even if the denominator goes to zero when \\\\(\\\\mathbf{x}=\\\\mathbf{y}\\\\), the numerator is always zero because \\\\(\\\\mathbf{n}_y\\\\) and \\\\((\\\\mathbf{y}-\\\\mathbf{x})\\\\) are orthogonal (on our polygonal approximation of the boundary of \\\\(\\\\Omega\\\\)), and the only singular integral arises in the computation of \\\\(\\\\mathbf{b}_i\\\\) on the i-th element of \\\\(\\\\mathcal{T}_h\\\\):     \\n\\\\[\\n  \\\\frac{1}{\\\\pi}\\n  \\\\int_{K_i}\\n  \\\\ln|\\\\mathbf{y}-\\\\mathbf{x}_i| \\\\, \\\\mathbf{n}_y\\\\cdot\\\\mathbf{v_\\\\infty} \\\\,ds_y.\\n\\\\]\\n\\nThis can be easily treated by the QGaussLogR quadrature formula.\\nSimilarly, it is possible to use the QGaussOneOverR quadrature formula to perform the singular integrations in three dimensions. The interested reader will find detailed explanations on how these quadrature rules work in their documentation.\\nThe resulting matrix \\\\(\\\\mathbf{A}+\\\\mathbf{N}\\\\) is full. Depending on its size, it might be convenient to use a direct solver or an iterative one. For the purpose of this example code, we chose to use only an iterative solver, without providing any preconditioner.\\nIf this were a production code rather than a demonstration of principles, there are techniques that are available to not store full matrices but instead store only those entries that are large and/or relevant. In the literature on boundary element methods, a plethora of methods is available that allows to determine which elements are important and which are not, leading to a significantly sparser representation of these matrices that also facilitates rapid evaluations of the scalar product between vectors and matrices. This not being the goal of this program, we leave this for more sophisticated implementations.\\nImplementation\\nThe implementation is rather straight forward. The main point that hasn't been used in any of the previous tutorial programs is that most classes in deal.II are not only templated on the dimension, but in fact on the dimension of the manifold on which we pose the differential equation as well as the dimension of the space into which this manifold is embedded. By default, the second template argument equals the first, meaning for example that we want to solve on a two-dimensional region of two-dimensional space. The triangulation class to use in this case would be Triangulation<2>, which is an equivalent way of writing Triangulation<2,2>.\\nHowever, this doesn't have to be so: in the current example, we will for example want to solve on the surface of a sphere, which is a two-dimensional manifold embedded in a three-dimensional space. Consequently, the right class will be Triangulation<2,3>, and correspondingly we will use DoFHandler<2,3> as the DoF handler class and FE_Q<2,3> for finite elements.\\nSome further details on what one can do with things that live on curved manifolds can be found in the report Tools for the Solution of PDEs Defined on Curved Manifolds with the deal.II Library by A. DeSimone, L. Heltai, C. Manigrasso. In addition, the step-38 tutorial program extends what we show here to cases where the equation posed on the manifold is not an integral operator but in fact involves derivatives.\\nTestcase\\nThe testcase we will be solving is for a circular (in 2d) or spherical (in 3d) obstacle. Meshes for these geometries will be read in from files in the current directory and an object of type SphericalManifold will then be attached to the triangulation to allow mesh refinement that respects the continuous geometry behind the discrete initial mesh.\\nFor a sphere of radius \\\\(a\\\\) translating at a velocity of \\\\(U\\\\) in the \\\\(x\\\\) direction, the potential reads   \\n\\\\begin{align*}\\n\\\\phi = -\\\\frac{1}{2}U \\\\left(\\\\frac{a}{r}\\\\right)3 r \\\\cos\\\\theta\\n\\\\end{align*}\\n\\n see, e.g. J. N. Newman, Marine Hydrodynamics, 1977, pp. 127. For unit speed and radius, and restricting \\\\((x,y,z)\\\\) to lie on the surface of the sphere, \\\\(\\\\phi = -x/2\\\\). In the test problem, the flow is \\\\((1,1,1)\\\\), so the appropriate exact solution on the surface of the sphere is the superposition of the above solution with the analogous solution along the \\\\(y\\\\) and \\\\(z\\\\) axes, or  \\\\(\\\\phi =\\n\\\\frac{1}{2}(x + y + z)\\\\).\\n The commented program\\n Include files\\nThe program starts with including a bunch of include files that we will use in the various parts of the program. Most of them have been discussed in previous tutorials already:\\n\\u00a0 #include <deal.II/base/smartpointer.h>\\n\\u00a0 #include <deal.II/base/convergence_table.h>\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/quadrature_selector.h>\\n\\u00a0 #include <deal.II/base/parameter_handler.h>\\n\\u00a0 #include <deal.II/base/parsed_function.h>\\n\\u00a0 #include <deal.II/base/utilities.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 #include <deal.II/lac/solver_control.h>\\n\\u00a0 #include <deal.II/lac/solver_gmres.h>\\n\\u00a0 #include <deal.II/lac/precondition.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_in.h>\\n\\u00a0 #include <deal.II/grid/grid_out.h>\\n\\u00a0 #include <deal.II/grid/manifold_lib.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 #include <deal.II/fe/mapping_q1.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 \\nAnd here are a few C++ standard header files that we will need:\\n\\u00a0 #include <cmath>\\n\\u00a0 #include <iostream>\\n\\u00a0 #include <fstream>\\n\\u00a0 #include <string>\\n\\u00a0 \\nThe last part of this preamble is to import everything in the dealii namespace into the one into which everything in this program will go:\\n\\u00a0 namespace Step34\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n Single and double layer operator kernels\\nFirst, let us define a bit of the boundary integral equation machinery.\\nThe following two functions are the actual calculations of the single and double layer potential kernels, that is \\\\(G\\\\) and \\\\(\\\\nabla G\\\\). They are well defined only if the vector \\\\(R = \\\\mathbf{y}-\\\\mathbf{x}\\\\) is different from zero.\\n\\u00a0   namespace LaplaceKernel\\n\\u00a0   {\\n\\u00a0     template <int dim>\\n\\u00a0     double single_layer(const Tensor<1, dim> &R)\\n\\u00a0     {\\n\\u00a0       switch (dim)\\n\\u00a0         {\\n\\u00a0           case 2:\\n\\u00a0             return (-std::log(R.norm()) / (2 * numbers::PI));\\n\\u00a0 \\n\\u00a0           case 3:\\n\\u00a0             return (1. / (R.norm() * 4 * numbers::PI));\\n\\u00a0 \\n\\u00a0           default:\\n\\u00a0             DEAL_II_NOT_IMPLEMENTED();\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     Tensor<1, dim> double_layer(const Tensor<1, dim> &R)\\n\\u00a0     {\\n\\u00a0       switch (dim)\\n\\u00a0         {\\n\\u00a0           case 2:\\n\\u00a0             return R / (-2 * numbers::PI * R.norm_square());\\n\\u00a0           case 3:\\n\\u00a0             return R / (-4 * numbers::PI * R.norm_square() * R.norm());\\n\\u00a0 \\n\\u00a0           default:\\n\\u00a0             DEAL_II_NOT_IMPLEMENTED();\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0   } // namespace LaplaceKernel\\n\\u00a0 \\n\\u00a0 \\nTensorDefinition tensor.h:471\\nTensor::normnumbers::NumberTraits< Number >::real_type norm() const\\nTensor::norm_squareconstexpr numbers::NumberTraits< Number >::real_type norm_square() const\\nDEAL_II_NOT_IMPLEMENTED#define DEAL_II_NOT_IMPLEMENTED()Definition exceptions.h:1814\\nnumbers::PIstatic constexpr double PIDefinition numbers.h:259\\nstd::log::VectorizedArray< Number, width > log(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6849\\n The BEMProblem class\\nThe structure of a boundary element method code is very similar to the structure of a finite element code, and so the member functions of this class are like those of most of the other tutorial programs. In particular, by now you should be familiar with reading parameters from an external file, and with the splitting of the different tasks into different modules. The same applies to boundary element methods, and we won't comment too much on them, except on the differences.\\n\\u00a0   template <int dim>\\n\\u00a0   class BEMProblem\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     BEMProblem(const unsigned int fe_degree      = 1,\\n\\u00a0                const unsigned int mapping_degree = 1);\\n\\u00a0 \\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void read_parameters(const std::string &filename);\\n\\u00a0 \\n\\u00a0     void read_domain();\\n\\u00a0 \\n\\u00a0     void refine_and_resize();\\n\\u00a0 \\nThe only really different function that we find here is the assembly routine. We wrote this function in the most possible general way, in order to allow for easy generalization to higher order methods and to different fundamental solutions (e.g., Stokes or Maxwell).\\nThe most noticeable difference is the fact that the final matrix is full, and that we have a nested loop inside the usual loop on cells that visits all support points of the degrees of freedom. Moreover, when the support point lies inside the cell which we are visiting, then the integral we perform becomes singular.\\nThe practical consequence is that we have two sets of quadrature formulas, finite element values and temporary storage, one for standard integration and one for the singular integration, which are used where necessary.\\n\\u00a0     void assemble_system();\\n\\u00a0 \\nThere are two options for the solution of this problem. The first is to use a direct solver, and the second is to use an iterative solver. We opt for the second option.\\nThe matrix that we assemble is not symmetric, and we opt to use the GMRES method; however the construction of an efficient preconditioner for boundary element methods is not a trivial issue. Here we use a non preconditioned GMRES solver. The options for the iterative solver, such as the tolerance, the maximum number of iterations, are selected through the parameter file.\\n\\u00a0     void solve_system();\\n\\u00a0 \\nOnce we obtained the solution, we compute the \\\\(L^2\\\\) error of the computed potential as well as the \\\\(L^\\\\infty\\\\) error of the approximation of the solid angle. The mesh we are using is an approximation of a smooth curve, therefore the computed diagonal matrix of fraction of angles or solid angles \\\\(\\\\alpha(\\\\mathbf{x})\\\\) should be constantly equal to \\\\(\\\\frac 12\\\\). In this routine we output the error on the potential and the error in the approximation of the computed angle. Notice that the latter error is actually not the error in the computation of the angle, but a measure of how well we are approximating the sphere and the circle.\\nExperimenting a little with the computation of the angles gives very accurate results for simpler geometries. To verify this you can comment out, in the read_domain() method, the tria.set_manifold(1, manifold) line, and check the alpha that is generated by the program. By removing this call, whenever the mesh is refined new nodes will be placed along the straight lines that made up the coarse mesh, rather than be pulled onto the surface that we really want to approximate. In the three dimensional case, the coarse grid of the sphere is obtained starting from a cube, and the obtained values of alphas are exactly \\\\(\\\\frac 12\\\\) on the nodes of the faces, \\\\(\\\\frac 34\\\\) on the nodes of the edges and \\\\(\\\\frac 78\\\\) on the 8 nodes of the vertices.\\n\\u00a0     void compute_errors(const unsigned int cycle);\\n\\u00a0 \\nOnce we obtained a solution on the codimension one domain, we want to interpolate it to the rest of the space. This is done by performing again the convolution of the solution with the kernel in the compute_exterior_solution() function.\\nWe would like to plot the velocity variable which is the gradient of the potential solution. The potential solution is only known on the boundary, but we use the convolution with the fundamental solution to interpolate it on a standard dim dimensional continuous finite element space. The plot of the gradient of the extrapolated solution will give us the velocity we want.\\nIn addition to the solution on the exterior domain, we also output the solution on the domain's boundary in the output_results() function, of course.\\n\\u00a0     void compute_exterior_solution();\\n\\u00a0 \\n\\u00a0     void output_results(const unsigned int cycle);\\n\\u00a0 \\nTo allow for dimension independent programming, we specialize this single function to extract the singular quadrature formula needed to integrate the singular kernels in the interior of the cells.\\n\\u00a0     Quadrature<dim - 1> get_singular_quadrature(\\n\\u00a0       const typename DoFHandler<dim - 1, dim>::active_cell_iterator &cell,\\n\\u00a0       const unsigned int index) const;\\n\\u00a0 \\n\\u00a0 \\nQuadratureDefinition quadrature.h:123\\nDoFHandler::active_cell_iteratortypename ActiveSelector::active_cell_iterator active_cell_iteratorDefinition dof_handler.h:440\\nThe usual deal.II classes can be used for boundary element methods by specifying the \\\"codimension\\\" of the problem. This is done by setting the optional second template arguments to Triangulation, FiniteElement and DoFHandler to the dimension of the embedding space. In our case we generate either 1 or 2 dimensional meshes embedded in 2 or 3 dimensional spaces.\\nThe optional argument by default is equal to the first argument, and produces the usual finite element classes that we saw in all previous examples.\\nThe class is constructed in a way to allow for arbitrary order of approximation of both the domain (through high order mappings) and the finite element space. The order of the finite element space and of the mapping can be selected in the constructor of the class.\\n\\u00a0     Triangulation<dim - 1, dim> tria;\\n\\u00a0     const FE_Q<dim - 1, dim>    fe;\\n\\u00a0     DoFHandler<dim - 1, dim>    dof_handler;\\n\\u00a0     MappingQ<dim - 1, dim>      mapping;\\n\\u00a0 \\nDoFHandlerDefinition dof_handler.h:317\\nFE_QDefinition fe_q.h:554\\nMappingQDefinition mapping_q.h:110\\nTriangulationDefinition tria.h:1323\\nIn BEM methods, the matrix that is generated is dense. Depending on the size of the problem, the final system might be solved by direct LU decomposition, or by iterative methods. In this example we use an unpreconditioned GMRES method. Building a preconditioner for BEM method is non trivial, and we don't treat this subject here.\\n\\u00a0     FullMatrix<double> system_matrix;\\n\\u00a0     Vector<double>     system_rhs;\\n\\u00a0 \\nFullMatrixDefinition full_matrix.h:79\\nVectorDefinition vector.h:120\\nThe next two variables will denote the solution \\\\(\\\\phi\\\\) as well as a vector that will hold the values of \\\\(\\\\alpha(\\\\mathbf x)\\\\) (the fraction of \\\\(\\\\Omega\\\\) visible from a point \\\\(\\\\mathbf x\\\\)) at the support points of our shape functions.\\n\\u00a0     Vector<double> phi;\\n\\u00a0     Vector<double> alpha;\\n\\u00a0 \\nThe convergence table is used to output errors in the exact solution and in the computed alphas.\\n\\u00a0     ConvergenceTable convergence_table;\\n\\u00a0 \\nConvergenceTableDefinition convergence_table.h:64\\nThe following variables are the ones that we fill through a parameter file. The new objects that we use in this example are the Functions::ParsedFunction object and the QuadratureSelector object.\\nThe Functions::ParsedFunction class allows us to easily and quickly define new function objects via parameter files, with custom definitions which can be very complex (see the documentation of that class for all the available options).\\nWe will allocate the quadrature object using the QuadratureSelector class that allows us to generate quadrature formulas based on an identifying string and on the possible degree of the formula itself. We used this to allow custom selection of the quadrature formulas for the standard integration, and to define the order of the singular quadrature rule.\\nWe also define a couple of parameters which are used in case we wanted to extend the solution to the entire domain.\\n\\u00a0     Functions::ParsedFunction<dim> wind;\\n\\u00a0     Functions::ParsedFunction<dim> exact_solution;\\n\\u00a0 \\n\\u00a0     unsigned int                         singular_quadrature_order;\\n\\u00a0     std::shared_ptr<Quadrature<dim - 1>> quadrature;\\n\\u00a0 \\n\\u00a0     SolverControl solver_control;\\n\\u00a0 \\n\\u00a0     unsigned int n_cycles;\\n\\u00a0     unsigned int external_refinement;\\n\\u00a0 \\n\\u00a0     bool run_in_this_dimension;\\n\\u00a0     bool extend_solution;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\nFunctions::ParsedFunctionDefinition parsed_function.h:83\\nSolverControlDefinition solver_control.h:67\\n BEMProblem::BEMProblem and BEMProblem::read_parameters\\nThe constructor initializes the various object in much the same way as done in the finite element programs such as step-4 or step-6. The only new ingredient here is the ParsedFunction object, which needs, at construction time, the specification of the number of components.\\nFor the exact solution the number of vector components is one, and no action is required since one is the default value for a ParsedFunction object. The wind, however, requires dim components to be specified. Notice that when declaring entries in a parameter file for the expression of the Functions::ParsedFunction, we need to specify the number of components explicitly, since the function Functions::ParsedFunction::declare_parameters is static, and has no knowledge of the number of components.\\n\\u00a0   template <int dim>\\n\\u00a0   BEMProblem<dim>::BEMProblem(const unsigned int fe_degree,\\n\\u00a0                               const unsigned int mapping_degree)\\n\\u00a0     : fe(fe_degree)\\n\\u00a0     , dof_handler(tria)\\n\\u00a0     , mapping(mapping_degree)\\n\\u00a0     , wind(dim)\\n\\u00a0     , singular_quadrature_order(5)\\n\\u00a0     , n_cycles(4)\\n\\u00a0     , external_refinement(5)\\n\\u00a0     , run_in_this_dimension(true)\\n\\u00a0     , extend_solution(true)\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void BEMProblem<dim>::read_parameters(const std::string &filename)\\n\\u00a0   {\\n\\u00a0     deallog << std::endl\\n\\u00a0             << \\\"Parsing parameter file \\\" << filename << std::endl\\n\\u00a0             << \\\"for a \\\" << dim << \\\" dimensional simulation. \\\" << std::endl;\\n\\u00a0 \\n\\u00a0     ParameterHandler prm;\\n\\u00a0 \\n\\u00a0     prm.declare_entry(\\\"Number of cycles\\\", \\\"4\\\", Patterns::Integer());\\n\\u00a0     prm.declare_entry(\\\"External refinement\\\", \\\"5\\\", Patterns::Integer());\\n\\u00a0     prm.declare_entry(\\\"Extend solution on the -2,2 box\\\",\\n\\u00a0                       \\\"true\\\",\\n\\u00a0                       Patterns::Bool());\\n\\u00a0     prm.declare_entry(\\\"Run 2d simulation\\\", \\\"true\\\", Patterns::Bool());\\n\\u00a0     prm.declare_entry(\\\"Run 3d simulation\\\", \\\"true\\\", Patterns::Bool());\\n\\u00a0 \\n\\u00a0     prm.enter_subsection(\\\"Quadrature rules\\\");\\n\\u00a0     {\\n\\u00a0       prm.declare_entry(\\n\\u00a0         \\\"Quadrature type\\\",\\n\\u00a0         \\\"gauss\\\",\\n\\u00a0         Patterns::Selection(\\n\\u00a0           QuadratureSelector<(dim - 1)>::get_quadrature_names()));\\n\\u00a0       prm.declare_entry(\\\"Quadrature order\\\", \\\"4\\\", Patterns::Integer());\\n\\u00a0       prm.declare_entry(\\\"Singular quadrature order\\\", \\\"5\\\", Patterns::Integer());\\n\\u00a0     }\\n\\u00a0     prm.leave_subsection();\\n\\u00a0 \\nParameterHandlerDefinition parameter_handler.h:855\\nParameterHandler::declare_entryvoid declare_entry(const std::string &entry, const std::string &default_value, const Patterns::PatternBase &pattern=Patterns::Anything(), const std::string &documentation=\\\"\\\", const bool has_to_be_set=false)Definition parameter_handler.cc:846\\nPatterns::BoolDefinition patterns.h:980\\nPatterns::IntegerDefinition patterns.h:188\\nPatterns::SelectionDefinition patterns.h:381\\nQuadratureSelectorDefinition quadrature_selector.h:41\\nint\\ndeallogLogStream deallogDefinition logstream.cc:36\\nstdSTL namespace.\\nFor both two and three dimensions, we set the default input data to be such that the solution is \\\\(x+y\\\\) or \\\\(x+y+z\\\\). The actually computed solution will have value zero at infinity. In this case, this coincide with the exact solution, and no additional corrections are needed, but you should be aware of the fact that we arbitrarily set \\\\(\\\\phi_\\\\infty\\\\), and the exact solution we pass to the program needs to have the same value at infinity for the error to be computed correctly.\\nThe use of the Functions::ParsedFunction object is pretty straight forward. The Functions::ParsedFunction::declare_parameters function takes an additional integer argument that specifies the number of components of the given function. Its default value is one. When the corresponding Functions::ParsedFunction::parse_parameters method is called, the calling object has to have the same number of components defined here, otherwise an exception is thrown.\\nWhen declaring entries, we declare both 2 and three dimensional functions. However only the dim-dimensional one is ultimately parsed. This allows us to have only one parameter file for both 2 and 3 dimensional problems.\\nNotice that from a mathematical point of view, the wind function on the boundary should satisfy the condition  \\\\(\\\\int_{\\\\partial\\\\Omega}\\n   \\\\mathbf{v}\\\\cdot \\\\mathbf{n} d \\\\Gamma = 0\\\\), for the problem to have a solution. If this condition is not satisfied, then no solution can be found, and the solver will not converge.\\n\\u00a0     prm.enter_subsection(\\\"Wind function 2d\\\");\\n\\u00a0     {\\n\\u00a0       Functions::ParsedFunction<2>::declare_parameters(prm, 2);\\n\\u00a0       prm.set(\\\"Function expression\\\", \\\"1; 1\\\");\\n\\u00a0     }\\n\\u00a0     prm.leave_subsection();\\n\\u00a0 \\n\\u00a0     prm.enter_subsection(\\\"Wind function 3d\\\");\\n\\u00a0     {\\n\\u00a0       Functions::ParsedFunction<3>::declare_parameters(prm, 3);\\n\\u00a0       prm.set(\\\"Function expression\\\", \\\"1; 1; 1\\\");\\n\\u00a0     }\\n\\u00a0     prm.leave_subsection();\\n\\u00a0 \\n\\u00a0     prm.enter_subsection(\\\"Exact solution 2d\\\");\\n\\u00a0     {\\n\\u00a0       Functions::ParsedFunction<2>::declare_parameters(prm);\\n\\u00a0       prm.set(\\\"Function expression\\\", \\\"x+y\\\");\\n\\u00a0     }\\n\\u00a0     prm.leave_subsection();\\n\\u00a0 \\n\\u00a0     prm.enter_subsection(\\\"Exact solution 3d\\\");\\n\\u00a0     {\\n\\u00a0       Functions::ParsedFunction<3>::declare_parameters(prm);\\n\\u00a0       prm.set(\\\"Function expression\\\", \\\"x+y+z\\\");\\n\\u00a0     }\\n\\u00a0     prm.leave_subsection();\\n\\u00a0 \\n\\u00a0 \\nFunctions::ParsedFunction::declare_parametersstatic void declare_parameters(ParameterHandler &prm, const unsigned int n_components=1)Definition parsed_function.cc:34\\nIn the solver section, we set all SolverControl parameters. The object will then be fed to the GMRES solver in the solve_system() function.\\n\\u00a0     prm.enter_subsection(\\\"Solver\\\");\\n\\u00a0     SolverControl::declare_parameters(prm);\\n\\u00a0     prm.leave_subsection();\\n\\u00a0 \\nSolverControl::declare_parametersstatic void declare_parameters(ParameterHandler &param)Definition solver_control.cc:206\\nAfter declaring all these parameters to the ParameterHandler object, let's read an input file that will give the parameters their values. We then proceed to extract these values from the ParameterHandler object:\\n\\u00a0     prm.parse_input(filename);\\n\\u00a0 \\n\\u00a0     n_cycles            = prm.get_integer(\\\"Number of cycles\\\");\\n\\u00a0     external_refinement = prm.get_integer(\\\"External refinement\\\");\\n\\u00a0     extend_solution     = prm.get_bool(\\\"Extend solution on the -2,2 box\\\");\\n\\u00a0 \\n\\u00a0     prm.enter_subsection(\\\"Quadrature rules\\\");\\n\\u00a0     {\\n\\u00a0       quadrature = std::shared_ptr<Quadrature<dim - 1>>(\\n\\u00a0         new QuadratureSelector<dim - 1>(prm.get(\\\"Quadrature type\\\"),\\n\\u00a0                                         prm.get_integer(\\\"Quadrature order\\\")));\\n\\u00a0       singular_quadrature_order = prm.get_integer(\\\"Singular quadrature order\\\");\\n\\u00a0     }\\n\\u00a0     prm.leave_subsection();\\n\\u00a0 \\n\\u00a0     prm.enter_subsection(\\\"Wind function \\\" + std::to_string(dim) + \\\"d\\\");\\n\\u00a0     {\\n\\u00a0       wind.parse_parameters(prm);\\n\\u00a0     }\\n\\u00a0     prm.leave_subsection();\\n\\u00a0 \\n\\u00a0     prm.enter_subsection(\\\"Exact solution \\\" + std::to_string(dim) + \\\"d\\\");\\n\\u00a0     {\\n\\u00a0       exact_solution.parse_parameters(prm);\\n\\u00a0     }\\n\\u00a0     prm.leave_subsection();\\n\\u00a0 \\n\\u00a0     prm.enter_subsection(\\\"Solver\\\");\\n\\u00a0     solver_control.parse_parameters(prm);\\n\\u00a0     prm.leave_subsection();\\n\\u00a0 \\n\\u00a0 \\nFinally, here's another example of how to use parameter files in dimension independent programming. If we wanted to switch off one of the two simulations, we could do this by setting the corresponding \\\"Run\\n   2d simulation\\\" or \\\"Run 3d simulation\\\" flag to false:\\n\\u00a0     run_in_this_dimension =\\n\\u00a0       prm.get_bool(\\\"Run \\\" + std::to_string(dim) + \\\"d simulation\\\");\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n BEMProblem::read_domain\\nA boundary element method triangulation is basically the same as a (dim-1) dimensional triangulation, with the difference that the vertices belong to a (dim) dimensional space.\\nSome of the mesh formats supported in deal.II use by default three dimensional points to describe meshes. These are the formats which are compatible with the boundary element method capabilities of deal.II. In particular we can use either UCD or GMSH formats. In both cases, we have to be particularly careful with the orientation of the mesh, because, unlike in the standard finite element case, no reordering or compatibility check is performed here. All meshes are considered as oriented, because they are embedded in a higher dimensional space. (See the documentation of the GridIn and of the Triangulation for further details on orientation of cells in a triangulation.) In our case, the normals to the mesh are external to both the circle in 2d or the sphere in 3d.\\nThe other detail that is required for appropriate refinement of the boundary element mesh is an accurate description of the manifold that the mesh approximates. We already saw this several times for the boundary of standard finite element meshes (for example in step-5 and step-6), and here the principle and usage is the same, except that the SphericalManifold class takes an additional template parameter that specifies the embedding space dimension.\\n\\u00a0   template <int dim>\\n\\u00a0   void BEMProblem<dim>::read_domain()\\n\\u00a0   {\\n\\u00a0     const Point<dim> center = Point<dim>();\\n\\u00a0     const SphericalManifold<dim - 1, dim> manifold(center);\\n\\u00a0 \\n\\u00a0     std::ifstream in;\\n\\u00a0     switch (dim)\\n\\u00a0       {\\n\\u00a0         case 2:\\n\\u00a0           in.open(\\\"coarse_circle.inp\\\");\\n\\u00a0           break;\\n\\u00a0 \\n\\u00a0         case 3:\\n\\u00a0           in.open(\\\"coarse_sphere.inp\\\");\\n\\u00a0           break;\\n\\u00a0 \\n\\u00a0         default:\\n\\u00a0           DEAL_II_NOT_IMPLEMENTED();\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     GridIn<dim - 1, dim> gi;\\n\\u00a0     gi.attach_triangulation(tria);\\n\\u00a0     gi.read_ucd(in);\\n\\u00a0 \\n\\u00a0     tria.set_all_manifold_ids(1);\\nGridInDefinition grid_in.h:311\\nGridIn::attach_triangulationvoid attach_triangulation(Triangulation< dim, spacedim > &tria)Definition grid_in.cc:153\\nPointDefinition point.h:111\\nSphericalManifoldDefinition manifold_lib.h:263\\ncenterPoint< 3 > centerDefinition data_out_base.cc:267\\nThe call to Triangulation::set_manifold copies the manifold (via Manifold::clone()), so we do not need to worry about invalid pointers to manifold:\\n\\u00a0     tria.set_manifold(1, manifold);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n BEMProblem::refine_and_resize\\nThis function globally refines the mesh, distributes degrees of freedom, and resizes matrices and vectors.\\n\\u00a0   template <int dim>\\n\\u00a0   void BEMProblem<dim>::refine_and_resize()\\n\\u00a0   {\\n\\u00a0     tria.refine_global(1);\\n\\u00a0 \\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0 \\n\\u00a0     const unsigned int n_dofs = dof_handler.n_dofs();\\n\\u00a0 \\n\\u00a0     system_matrix.reinit(n_dofs, n_dofs);\\n\\u00a0 \\n\\u00a0     system_rhs.reinit(n_dofs);\\n\\u00a0     phi.reinit(n_dofs);\\n\\u00a0     alpha.reinit(n_dofs);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n BEMProblem::assemble_system\\nThe following is the main function of this program, assembling the matrix that corresponds to the boundary integral equation.\\n\\u00a0   template <int dim>\\n\\u00a0   void BEMProblem<dim>::assemble_system()\\n\\u00a0   {\\nFirst we initialize an FEValues object with the quadrature formula for the integration of the kernel in non singular cells. This quadrature is selected with the parameter file, and needs to be quite precise, since the functions we are integrating are not polynomial functions.\\n\\u00a0     FEValues<dim - 1, dim> fe_v(mapping,\\n\\u00a0                                 fe,\\n\\u00a0                                 *quadrature,\\n\\u00a0                                 update_values | update_normal_vectors |\\n\\u00a0                                   update_quadrature_points | update_JxW_values);\\n\\u00a0 \\n\\u00a0     const unsigned int n_q_points = fe_v.n_quadrature_points;\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(\\n\\u00a0       fe.n_dofs_per_cell());\\n\\u00a0 \\n\\u00a0     std::vector<Vector<double>> cell_wind(n_q_points, Vector<double>(dim));\\n\\u00a0     double                      normal_wind;\\n\\u00a0 \\nFEValuesDefinition fe_values.h:63\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_normal_vectors@ update_normal_vectorsNormal vectors.Definition fe_update_flags.h:141\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nUnlike in finite element methods, if we use a collocation boundary element method, then in each assembly loop we only assemble the information that refers to the coupling between one degree of freedom (the degree associated with support point \\\\(i\\\\)) and the current cell. This is done using a vector of fe.dofs_per_cell elements, which will then be distributed to the matrix in the global row \\\\(i\\\\). The following object will hold this information:\\n\\u00a0     Vector<double> local_matrix_row_i(fe.n_dofs_per_cell());\\n\\u00a0 \\nThe index \\\\(i\\\\) runs on the collocation points, which are the support points of the \\\\(i\\\\)th basis function, while \\\\(j\\\\) runs on inner integration points.\\nWe construct a vector of support points which will be used in the local integrations:\\n\\u00a0     std::vector<Point<dim>> support_points(dof_handler.n_dofs());\\n\\u00a0     DoFTools::map_dofs_to_support_points<dim - 1, dim>(mapping,\\n\\u00a0                                                        dof_handler,\\n\\u00a0                                                        support_points);\\n\\u00a0 \\n\\u00a0 \\nDoFTools::map_dofs_to_support_pointsvoid map_dofs_to_support_points(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof_handler, std::vector< Point< spacedim > > &support_points, const ComponentMask &mask={})Definition dof_tools.cc:2380\\nAfter doing so, we can start the integration loop over all cells, where we first initialize the FEValues object and get the values of \\\\(\\\\mathbf{\\\\tilde v}\\\\) at the quadrature points (this vector field should be constant, but it doesn't hurt to be more general):\\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         fe_v.reinit(cell);\\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0 \\n\\u00a0         const std::vector<Point<dim>> &q_points = fe_v.get_quadrature_points();\\n\\u00a0         const std::vector<Tensor<1, dim>> &normals = fe_v.get_normal_vectors();\\n\\u00a0         wind.vector_value_list(q_points, cell_wind);\\n\\u00a0 \\nWe then form the integral over the current cell for all degrees of freedom (note that this includes degrees of freedom not located on the current cell, a deviation from the usual finite element integrals). The integral that we need to perform is singular if one of the local degrees of freedom is the same as the support point \\\\(i\\\\). A the beginning of the loop we therefore check whether this is the case, and we store which one is the singular index:\\n\\u00a0         for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)\\n\\u00a0           {\\n\\u00a0             local_matrix_row_i = 0;\\n\\u00a0 \\n\\u00a0             bool         is_singular    = false;\\n\\u00a0             unsigned int singular_index = numbers::invalid_unsigned_int;\\n\\u00a0 \\n\\u00a0             for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j)\\n\\u00a0               if (local_dof_indices[j] == i)\\n\\u00a0                 {\\n\\u00a0                   singular_index = j;\\n\\u00a0                   is_singular    = true;\\n\\u00a0                   break;\\n\\u00a0                 }\\n\\u00a0 \\nnumbers::invalid_unsigned_intstatic const unsigned int invalid_unsigned_intDefinition types.h:220\\nWe then perform the integral. If the index \\\\(i\\\\) is not one of the local degrees of freedom, we simply have to add the single layer terms to the right hand side, and the double layer terms to the matrix:\\n\\u00a0             if (is_singular == false)\\n\\u00a0               {\\n\\u00a0                 for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0                   {\\n\\u00a0                     normal_wind = 0;\\n\\u00a0                     for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0                       normal_wind += normals[q][d] * cell_wind[q](d);\\n\\u00a0 \\n\\u00a0                     const Tensor<1, dim> R = q_points[q] - support_points[i];\\n\\u00a0 \\n\\u00a0                     system_rhs(i) += (LaplaceKernel::single_layer(R) *\\n\\u00a0                                       normal_wind * fe_v.JxW(q));\\n\\u00a0 \\n\\u00a0                     for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j)\\n\\u00a0 \\n\\u00a0                       local_matrix_row_i(j) -=\\n\\u00a0                         ((LaplaceKernel::double_layer(R) * normals[q]) *\\n\\u00a0                          fe_v.shape_value(j, q) * fe_v.JxW(q));\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0             else\\n\\u00a0               {\\nNow we treat the more delicate case. If we are here, this means that the cell that runs on the \\\\(j\\\\) index contains support_point[i]. In this case both the single and the double layer potential are singular, and they require special treatment.\\nWhenever the integration is performed with the singularity inside the given cell, then a special quadrature formula is used that allows one to integrate arbitrary functions against a singular weight on the reference cell.\\nThe correct quadrature formula is selected by the get_singular_quadrature() function, which is explained in detail below.\\n\\u00a0                 Assert(singular_index != numbers::invalid_unsigned_int,\\n\\u00a0                        ExcInternalError());\\n\\u00a0 \\n\\u00a0                 const Quadrature<dim - 1> singular_quadrature =\\n\\u00a0                   get_singular_quadrature(cell, singular_index);\\n\\u00a0 \\n\\u00a0                 FEValues<dim - 1, dim> fe_v_singular(\\n\\u00a0                   mapping,\\n\\u00a0                   fe,\\n\\u00a0                   singular_quadrature,\\n\\u00a0                   update_jacobians | update_values | update_normal_vectors |\\n\\u00a0                     update_quadrature_points);\\n\\u00a0 \\n\\u00a0                 fe_v_singular.reinit(cell);\\n\\u00a0 \\n\\u00a0                 std::vector<Vector<double>> singular_cell_wind(\\n\\u00a0                   singular_quadrature.size(), Vector<double>(dim));\\n\\u00a0 \\n\\u00a0                 const std::vector<Tensor<1, dim>> &singular_normals =\\n\\u00a0                   fe_v_singular.get_normal_vectors();\\n\\u00a0                 const std::vector<Point<dim>> &singular_q_points =\\n\\u00a0                   fe_v_singular.get_quadrature_points();\\n\\u00a0 \\n\\u00a0                 wind.vector_value_list(singular_q_points, singular_cell_wind);\\n\\u00a0 \\n\\u00a0                 for (unsigned int q = 0; q < singular_quadrature.size(); ++q)\\n\\u00a0                   {\\n\\u00a0                     const Tensor<1, dim> R =\\n\\u00a0                       singular_q_points[q] - support_points[i];\\n\\u00a0                     double normal_wind = 0;\\n\\u00a0                     for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0                       normal_wind +=\\n\\u00a0                         (singular_cell_wind[q](d) * singular_normals[q][d]);\\n\\u00a0 \\n\\u00a0                     system_rhs(i) += (LaplaceKernel::single_layer(R) *\\n\\u00a0                                       normal_wind * fe_v_singular.JxW(q));\\n\\u00a0 \\n\\u00a0                     for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j)\\n\\u00a0                       {\\n\\u00a0                         local_matrix_row_i(j) -=\\n\\u00a0                           ((LaplaceKernel::double_layer(R) *\\n\\u00a0                             singular_normals[q]) *\\n\\u00a0                            fe_v_singular.shape_value(j, q) *\\n\\u00a0                            fe_v_singular.JxW(q));\\n\\u00a0                       }\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0 \\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\nupdate_jacobians@ update_jacobiansVolume element.Definition fe_update_flags.h:147\\nFinally, we need to add the contributions of the current cell to the global matrix.\\n\\u00a0             for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j)\\n\\u00a0               system_matrix(i, local_dof_indices[j]) += local_matrix_row_i(j);\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\nThe second part of the integral operator is the term \\\\(\\\\alpha(\\\\mathbf{x}_i) \\\\phi_j(\\\\mathbf{x}_i)\\\\). Since we use a collocation scheme, \\\\(\\\\phi_j(\\\\mathbf{x}_i)=\\\\delta_{ij}\\\\) and the corresponding matrix is a diagonal one with entries equal to \\\\(\\\\alpha(\\\\mathbf{x}_i)\\\\).\\nOne quick way to compute this diagonal matrix of the solid angles, is to use the Neumann matrix itself. It is enough to multiply the matrix with a vector of elements all equal to -1, to get the diagonal matrix of the alpha angles, or solid angles (see the formula in the introduction for this). The result is then added back onto the system matrix object to yield the final form of the matrix:\\n\\u00a0     Vector<double> ones(dof_handler.n_dofs());\\n\\u00a0     ones.add(-1.);\\n\\u00a0 \\n\\u00a0     system_matrix.vmult(alpha, ones);\\n\\u00a0     alpha.add(1);\\n\\u00a0     for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)\\n\\u00a0       system_matrix(i, i) += alpha(i);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n BEMProblem::solve_system\\nThe next function simply solves the linear system.\\n\\u00a0   template <int dim>\\n\\u00a0   void BEMProblem<dim>::solve_system()\\n\\u00a0   {\\n\\u00a0     SolverGMRES<Vector<double>> solver(solver_control);\\n\\u00a0     solver.solve(system_matrix, phi, system_rhs, PreconditionIdentity());\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nPreconditionIdentityDefinition precondition.h:220\\nSolverGMRESDefinition solver_gmres.h:353\\n BEMProblem::compute_errors\\nThe computation of the errors is exactly the same in all other example programs, and we won't comment too much. Notice how the same methods that are used in the finite element methods can be used here.\\n\\u00a0   template <int dim>\\n\\u00a0   void BEMProblem<dim>::compute_errors(const unsigned int cycle)\\n\\u00a0   {\\n\\u00a0     Vector<float> difference_per_cell(tria.n_active_cells());\\n\\u00a0     VectorTools::integrate_difference(mapping,\\n\\u00a0                                       dof_handler,\\n\\u00a0                                       phi,\\n\\u00a0                                       exact_solution,\\n\\u00a0                                       difference_per_cell,\\n\\u00a0                                       QGauss<(dim - 1)>(2 * fe.degree + 1),\\n\\u00a0                                       VectorTools::L2_norm);\\n\\u00a0     const double L2_error =\\n\\u00a0       VectorTools::compute_global_error(tria,\\n\\u00a0                                         difference_per_cell,\\n\\u00a0                                         VectorTools::L2_norm);\\n\\u00a0 \\nQGaussDefinition quadrature_lib.h:40\\nVectorTools::compute_global_errordouble compute_global_error(const Triangulation< dim, spacedim > &tria, const InVector &cellwise_error, const NormType &norm, const double exponent=2.)\\nVectorTools::L2_norm@ L2_normDefinition vector_tools_common.h:112\\nVectorTools::integrate_differencevoid integrate_difference(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const ReadVector< Number > &fe_function, const Function< spacedim, Number > &exact_solution, OutVector &difference, const Quadrature< dim > &q, const NormType &norm, const Function< spacedim, double > *weight=nullptr, const double exponent=2.)\\nThe error in the alpha vector can be computed directly using the Vector::linfty_norm() function, since on each node, the value should be \\\\(\\\\frac 12\\\\). All errors are then output and appended to our ConvergenceTable object for later computation of convergence rates:\\n\\u00a0     Vector<double> difference_per_node(alpha);\\n\\u00a0     difference_per_node.add(-.5);\\n\\u00a0 \\n\\u00a0     const double       alpha_error    = difference_per_node.linfty_norm();\\n\\u00a0     const unsigned int n_active_cells = tria.n_active_cells();\\n\\u00a0     const unsigned int n_dofs         = dof_handler.n_dofs();\\n\\u00a0 \\n\\u00a0     deallog << \\\"Cycle \\\" << cycle << ':' << std::endl\\n\\u00a0             << \\\"   Number of active cells:       \\\" << n_active_cells\\n\\u00a0             << std::endl\\n\\u00a0             << \\\"   Number of degrees of freedom: \\\" << n_dofs << std::endl;\\n\\u00a0 \\n\\u00a0     convergence_table.add_value(\\\"cycle\\\", cycle);\\n\\u00a0     convergence_table.add_value(\\\"cells\\\", n_active_cells);\\n\\u00a0     convergence_table.add_value(\\\"dofs\\\", n_dofs);\\n\\u00a0     convergence_table.add_value(\\\"L2(phi)\\\", L2_error);\\n\\u00a0     convergence_table.add_value(\\\"Linfty(alpha)\\\", alpha_error);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nSingular integration requires a careful selection of the quadrature rules. In particular the deal.II library provides quadrature rules which are tailored for logarithmic singularities (QGaussLog, QGaussLogR), as well as for 1/R singularities (QGaussOneOverR).\\nSingular integration is typically obtained by constructing weighted quadrature formulas with singular weights, so that it is possible to write\\n\\n\\\\[ \\\\int_K f(x) s(x) dx = \\\\sum_{i=1}^N w_i f(q_i) \\\\]\\n\\nwhere \\\\(s(x)\\\\) is a given singularity, and the weights and quadrature points \\\\(w_i,q_i\\\\) are carefully selected to make the formula above an equality for a certain class of functions \\\\(f(x)\\\\).\\nIn all the finite element examples we have seen so far, the weight of the quadrature itself (namely, the function \\\\(s(x)\\\\)), was always constantly equal to 1. For singular integration, we have two choices: we can use the definition above, factoring out the singularity from the integrand (i.e., integrating \\\\(f(x)\\\\) with the special quadrature rule), or we can ask the quadrature rule to \\\"normalize\\\" the weights \\\\(w_i\\\\) with \\\\(s(q_i)\\\\):\\n\\n\\\\[ \\\\int_K f(x) s(x) dx = \\\\int_K g(x) dx = \\\\sum_{i=1}^N\\n   \\\\frac{w_i}{s(q_i)} g(q_i) \\\\]\\n\\nWe use this second option, through the factor_out_singularity parameter of both QGaussLogR and QGaussOneOverR.\\nThese integrals are somewhat delicate, especially in two dimensions, due to the transformation from the real to the reference cell, where the variable of integration is scaled with the determinant of the transformation.\\nIn two dimensions this process does not result only in a factor appearing as a constant factor on the entire integral, but also on an additional integral altogether that needs to be evaluated:\\n\\n\\\\[ \\\\int_0^1 f(x)\\\\ln(x/\\\\alpha) dx = \\\\int_0^1 f(x)\\\\ln(x) dx - \\\\int_0^1\\n   f(x) \\\\ln(\\\\alpha) dx.  \\\\]\\n\\nThis process is taken care of by the constructor of the QGaussLogR class, which adds additional quadrature points and weights to take into consideration also the second part of the integral.\\nA similar reasoning should be done in the three dimensional case, since the singular quadrature is tailored on the inverse of the radius \\\\(r\\\\) in the reference cell, while our singular function lives in real space, however in the three dimensional case everything is simpler because the singularity scales linearly with the determinant of the transformation. This allows us to build the singular two dimensional quadrature rules only once and, reuse them over all cells.\\nIn the one dimensional singular integration this is not possible, since we need to know the scaling parameter for the quadrature, which is not known a priori. Here, the quadrature rule itself depends also on the size of the current cell. For this reason, it is necessary to create a new quadrature for each singular integration.\\nThe different quadrature rules are built inside the get_singular_quadrature, which is specialized for dim=2 and dim=3, and they are retrieved inside the assemble_system function. The index given as an argument is the index of the unit support point where the singularity is located.\\n\\u00a0   template <>\\n\\u00a0   Quadrature<2> BEMProblem<3>::get_singular_quadrature(\\n\\u00a0     const DoFHandler<2, 3>::active_cell_iterator &,\\n\\u00a0     const unsigned int index) const\\n\\u00a0   {\\n\\u00a0     Assert(index < fe.n_dofs_per_cell(),\\n\\u00a0            ExcIndexRange(0, fe.n_dofs_per_cell(), index));\\n\\u00a0 \\n\\u00a0     static std::vector<QGaussOneOverR<2>> quadratures;\\n\\u00a0     if (quadratures.empty())\\n\\u00a0       for (unsigned int i = 0; i < fe.n_dofs_per_cell(); ++i)\\n\\u00a0         quadratures.emplace_back(singular_quadrature_order,\\n\\u00a0                                  fe.get_unit_support_points()[i],\\n\\u00a0                                  true);\\n\\u00a0     return quadratures[index];\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <>\\n\\u00a0   Quadrature<1> BEMProblem<2>::get_singular_quadrature(\\n\\u00a0     const DoFHandler<1, 2>::active_cell_iterator &cell,\\n\\u00a0     const unsigned int                            index) const\\n\\u00a0   {\\n\\u00a0     Assert(index < fe.n_dofs_per_cell(),\\n\\u00a0            ExcIndexRange(0, fe.n_dofs_per_cell(), index));\\n\\u00a0 \\n\\u00a0     return QGaussLogR<1>(singular_quadrature_order,\\n\\u00a0                          fe.get_unit_support_points()[index],\\n\\u00a0                          1. / cell->measure(),\\n\\u00a0                          true);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nQGaussLogRDefinition quadrature_lib.h:302\\n BEMProblem::compute_exterior_solution\\nWe'd like to also know something about the value of the potential \\\\(\\\\phi\\\\) in the exterior domain: after all our motivation to consider the boundary integral problem was that we wanted to know the velocity in the exterior domain!\\nTo this end, let us assume here that the boundary element domain is contained in the box \\\\([-2,2]^{\\\\text{dim}}\\\\), and we extrapolate the actual solution inside this box using the convolution with the fundamental solution. The formula for this is given in the introduction.\\nThe reconstruction of the solution in the entire space is done on a continuous finite element grid of dimension dim. These are the usual ones, and we don't comment any further on them. At the end of the function, we output this exterior solution in, again, much the usual way.\\n\\u00a0   template <int dim>\\n\\u00a0   void BEMProblem<dim>::compute_exterior_solution()\\n\\u00a0   {\\n\\u00a0     Triangulation<dim> external_tria;\\n\\u00a0     GridGenerator::hyper_cube(external_tria, -2, 2);\\n\\u00a0 \\n\\u00a0     const FE_Q<dim> external_fe(1);\\n\\u00a0     DoFHandler<dim> external_dh(external_tria);\\n\\u00a0     Vector<double>  external_phi;\\n\\u00a0 \\n\\u00a0     external_tria.refine_global(external_refinement);\\n\\u00a0     external_dh.distribute_dofs(external_fe);\\n\\u00a0     external_phi.reinit(external_dh.n_dofs());\\n\\u00a0 \\n\\u00a0     FEValues<dim - 1, dim> fe_v(mapping,\\n\\u00a0                                 fe,\\n\\u00a0                                 *quadrature,\\n\\u00a0                                 update_values | update_normal_vectors |\\n\\u00a0                                   update_quadrature_points | update_JxW_values);\\n\\u00a0 \\n\\u00a0     const unsigned int n_q_points = fe_v.n_quadrature_points;\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> dofs(fe.n_dofs_per_cell());\\n\\u00a0 \\n\\u00a0     std::vector<double>         local_phi(n_q_points);\\n\\u00a0     std::vector<double>         normal_wind(n_q_points);\\n\\u00a0     std::vector<Vector<double>> local_wind(n_q_points, Vector<double>(dim));\\n\\u00a0 \\n\\u00a0     std::vector<Point<dim>> external_support_points(external_dh.n_dofs());\\n\\u00a0     DoFTools::map_dofs_to_support_points<dim>(StaticMappingQ1<dim>::mapping,\\n\\u00a0                                               external_dh,\\n\\u00a0                                               external_support_points);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         fe_v.reinit(cell);\\n\\u00a0 \\n\\u00a0         const std::vector<Point<dim>> &q_points = fe_v.get_quadrature_points();\\n\\u00a0         const std::vector<Tensor<1, dim>> &normals = fe_v.get_normal_vectors();\\n\\u00a0 \\n\\u00a0         cell->get_dof_indices(dofs);\\n\\u00a0         fe_v.get_function_values(phi, local_phi);\\n\\u00a0 \\n\\u00a0         wind.vector_value_list(q_points, local_wind);\\n\\u00a0 \\n\\u00a0         for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0           {\\n\\u00a0             normal_wind[q] = 0;\\n\\u00a0             for (unsigned int d = 0; d < dim; ++d)\\n\\u00a0               normal_wind[q] += normals[q][d] * local_wind[q](d);\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         for (unsigned int i = 0; i < external_dh.n_dofs(); ++i)\\n\\u00a0           for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0             {\\n\\u00a0               const Tensor<1, dim> R = q_points[q] - external_support_points[i];\\n\\u00a0 \\n\\u00a0               external_phi(i) +=\\n\\u00a0                 ((LaplaceKernel::single_layer(R) * normal_wind[q] +\\n\\u00a0                   (LaplaceKernel::double_layer(R) * normals[q]) *\\n\\u00a0                     local_phi[q]) *\\n\\u00a0                  fe_v.JxW(q));\\n\\u00a0             }\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     DataOut<dim> data_out;\\n\\u00a0 \\n\\u00a0     data_out.attach_dof_handler(external_dh);\\n\\u00a0     data_out.add_data_vector(external_phi, \\\"external_phi\\\");\\n\\u00a0     data_out.build_patches();\\n\\u00a0 \\n\\u00a0     const std::string filename = std::to_string(dim) + \\\"d_external.vtk\\\";\\n\\u00a0     std::ofstream     file(filename);\\n\\u00a0 \\n\\u00a0     data_out.write_vtk(file);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nVector::reinitvirtual void reinit(const size_type N, const bool omit_zeroing_entries=false)\\nGridGenerator::hyper_cubevoid hyper_cube(Triangulation< dim, spacedim > &tria, const double left=0., const double right=1., const bool colorize=false)\\nStaticMappingQ1Definition mapping_q1.h:92\\n BEMProblem::output_results\\nOutputting the results of our computations is a rather mechanical tasks. All the components of this function have been discussed before.\\n\\u00a0   template <int dim>\\n\\u00a0   void BEMProblem<dim>::output_results(const unsigned int cycle)\\n\\u00a0   {\\n\\u00a0     DataOut<dim - 1, dim> dataout;\\n\\u00a0 \\n\\u00a0     dataout.attach_dof_handler(dof_handler);\\n\\u00a0     dataout.add_data_vector(phi, \\\"phi\\\", DataOut<dim - 1, dim>::type_dof_data);\\n\\u00a0     dataout.add_data_vector(alpha,\\n\\u00a0                             \\\"alpha\\\",\\n\\u00a0                             DataOut<dim - 1, dim>::type_dof_data);\\n\\u00a0     dataout.build_patches(mapping,\\n\\u00a0                           mapping.get_degree(),\\n\\u00a0                           DataOut<dim - 1, dim>::curved_inner_cells);\\n\\u00a0 \\n\\u00a0     const std::string filename = std::to_string(dim) + \\\"d_boundary_solution_\\\" +\\n\\u00a0                                  std::to_string(cycle) + \\\".vtk\\\";\\n\\u00a0     std::ofstream file(filename);\\n\\u00a0 \\n\\u00a0     dataout.write_vtk(file);\\n\\u00a0 \\n\\u00a0     if (cycle == n_cycles - 1)\\n\\u00a0       {\\n\\u00a0         convergence_table.set_precision(\\\"L2(phi)\\\", 3);\\n\\u00a0         convergence_table.set_precision(\\\"Linfty(alpha)\\\", 3);\\n\\u00a0 \\n\\u00a0         convergence_table.set_scientific(\\\"L2(phi)\\\", true);\\n\\u00a0         convergence_table.set_scientific(\\\"Linfty(alpha)\\\", true);\\n\\u00a0 \\n\\u00a0         convergence_table.evaluate_convergence_rates(\\n\\u00a0           \\\"L2(phi)\\\", ConvergenceTable::reduction_rate_log2);\\n\\u00a0         convergence_table.evaluate_convergence_rates(\\n\\u00a0           \\\"Linfty(alpha)\\\", ConvergenceTable::reduction_rate_log2);\\n\\u00a0         deallog << std::endl;\\n\\u00a0         convergence_table.write_text(std::cout);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nConvergenceTable::reduction_rate_log2@ reduction_rate_log2Definition convergence_table.h:88\\n BEMProblem::run\\nThis is the main function. It should be self explanatory in its briefness:\\n\\u00a0   template <int dim>\\n\\u00a0   void BEMProblem<dim>::run()\\n\\u00a0   {\\n\\u00a0     read_parameters(\\\"parameters.prm\\\");\\n\\u00a0 \\n\\u00a0     if (run_in_this_dimension == false)\\n\\u00a0       {\\n\\u00a0         deallog << \\\"Run in dimension \\\" << dim\\n\\u00a0                 << \\\" explicitly disabled in parameter file. \\\" << std::endl;\\n\\u00a0         return;\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     read_domain();\\n\\u00a0 \\n\\u00a0     for (unsigned int cycle = 0; cycle < n_cycles; ++cycle)\\n\\u00a0       {\\n\\u00a0         refine_and_resize();\\n\\u00a0         assemble_system();\\n\\u00a0         solve_system();\\n\\u00a0         compute_errors(cycle);\\n\\u00a0         output_results(cycle);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     if (extend_solution == true)\\n\\u00a0       compute_exterior_solution();\\n\\u00a0   }\\n\\u00a0 } // namespace Step34\\n\\u00a0 \\n\\u00a0 \\n The main() function\\nThis is the main function of this program. It is exactly like all previous tutorial programs:\\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       using namespace Step34;\\n\\u00a0 \\n\\u00a0       const unsigned int degree         = 1;\\n\\u00a0       const unsigned int mapping_degree = 1;\\n\\u00a0 \\n\\u00a0       deallog.depth_console(3);\\n\\u00a0       BEMProblem<2> laplace_problem_2d(degree, mapping_degree);\\n\\u00a0       laplace_problem_2d.run();\\n\\u00a0 \\n\\u00a0       BEMProblem<3> laplace_problem_3d(degree, mapping_degree);\\n\\u00a0       laplace_problem_3d.run();\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0 \\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\nLogStream::depth_consoleunsigned int depth_console(const unsigned int n)Definition logstream.cc:349\\n Results\\nWe ran the program using the following parameters.prm file (which can also be found in the directory in which all the other source files are): # Listing of Parameters\\n# ---------------------\\nset Extend solution on the -2,2 box = true\\nset External refinement             = 5\\nset Number of cycles                = 4\\nset Run 2d simulation               = true\\nset Run 3d simulation               = true\\n\\n\\nsubsection Exact solution 2d\\n  # Any constant used inside the function which is not a variable name.\\n  set Function constants  =\\n\\n  # Separate vector valued expressions by ';' as ',' is used internally by the\\n  # function parser.\\n  set Function expression = x+y   # default: 0\\n\\n  # The name of the variables as they will be used in the function, separated\\n  # by ','.\\n  set Variable names      = x,y,t\\nend\\n\\n\\nsubsection Exact solution 3d\\n  # Any constant used inside the function which is not a variable name.\\n  set Function constants  =\\n\\n  # Separate vector valued expressions by ';' as ',' is used internally by the\\n  # function parser.\\n  set Function expression = .5*(x+y+z)   # default: 0\\n\\n  # The name of the variables as they will be used in the function, separated\\n  # by ','.\\n  set Variable names      = x,y,z,t\\nend\\n\\n\\nsubsection Quadrature rules\\n  set Quadrature order          = 4\\n  set Quadrature type           = gauss\\n  set Singular quadrature order = 5\\nend\\n\\n\\nsubsection Solver\\n  set Log frequency = 1\\n  set Log history   = false\\n  set Log result    = true\\n  set Max steps     = 100\\n  set Tolerance     = 1.e-10\\nend\\n\\n\\nsubsection Wind function 2d\\n  # Any constant used inside the function which is not a variable name.\\n  set Function constants  =\\n\\n  # Separate vector valued expressions by ';' as ',' is used internally by the\\n  # function parser.\\n  set Function expression = 1; 1  # default: 0; 0\\n\\n  # The name of the variables as they will be used in the function, separated\\n  # by ','.\\n  set Variable names      = x,y,t\\nend\\n\\n\\nsubsection Wind function 3d\\n  # Any constant used inside the function which is not a variable name.\\n  set Function constants  =\\n\\n  # Separate vector valued expressions by ';' as ',' is used internally by the\\n  # function parser.\\n  set Function expression = 1; 1; 1 # default: 0; 0; 0\\n\\n  # The name of the variables as they will be used in the function, separated\\n  # by ','.\\n  set Variable names      = x,y,z,t\\nend\\nWhen we run the program, the following is printed on screen: DEAL::\\nDEAL::Parsing parameter file parameters.prm\\nDEAL::for a 2 dimensional simulation.\\nDEAL:GMRES::Starting value 2.21576\\nDEAL:GMRES::Convergence step 1 value 2.37635e-13\\nDEAL::Cycle 0:\\nDEAL::   Number of active cells:       20\\nDEAL::   Number of degrees of freedom: 20\\nDEAL:GMRES::Starting value 3.15543\\nDEAL:GMRES::Convergence step 1 value 2.89310e-13\\nDEAL::Cycle 1:\\nDEAL::   Number of active cells:       40\\nDEAL::   Number of degrees of freedom: 40\\nDEAL:GMRES::Starting value 4.46977\\nDEAL:GMRES::Convergence step 1 value 3.11815e-13\\nDEAL::Cycle 2:\\nDEAL::   Number of active cells:       80\\nDEAL::   Number of degrees of freedom: 80\\nDEAL:GMRES::Starting value 6.32373\\nDEAL:GMRES::Convergence step 1 value 3.22474e-13\\nDEAL::Cycle 3:\\nDEAL::   Number of active cells:       160\\nDEAL::   Number of degrees of freedom: 160\\nDEAL::\\ncycle cells dofs    L2(phi)     Linfty(alpha)\\n    0    20   20 4.465e-02    - 5.000e-02    -\\n    1    40   40 1.081e-02 2.05 2.500e-02 1.00\\n    2    80   80 2.644e-03 2.03 1.250e-02 1.00\\n    3   160  160 6.529e-04 2.02 6.250e-03 1.00\\nDEAL::\\nDEAL::Parsing parameter file parameters.prm\\nDEAL::for a 3 dimensional simulation.\\nDEAL:GMRES::Starting value 2.84666\\nDEAL:GMRES::Convergence step 3 value 8.68638e-18\\nDEAL::Cycle 0:\\nDEAL::   Number of active cells:       24\\nDEAL::   Number of degrees of freedom: 26\\nDEAL:GMRES::Starting value 6.34288\\nDEAL:GMRES::Convergence step 5 value 1.38740e-11\\nDEAL::Cycle 1:\\nDEAL::   Number of active cells:       96\\nDEAL::   Number of degrees of freedom: 98\\nDEAL:GMRES::Starting value 12.9780\\nDEAL:GMRES::Convergence step 5 value 3.29225e-11\\nDEAL::Cycle 2:\\nDEAL::   Number of active cells:       384\\nDEAL::   Number of degrees of freedom: 386\\nDEAL:GMRES::Starting value 26.0874\\nDEAL:GMRES::Convergence step 6 value 1.47271e-12\\nDEAL::Cycle 3:\\nDEAL::   Number of active cells:       1536\\nDEAL::   Number of degrees of freedom: 1538\\nDEAL::\\ncycle cells dofs    L2(phi)     Linfty(alpha)\\n    0    24   26 3.437e-01    - 2.327e-01    -\\n    1    96   98 9.794e-02 1.81 1.239e-01 0.91\\n    2   384  386 2.417e-02 2.02 6.319e-02 0.97\\n    3  1536 1538 5.876e-03 2.04 3.176e-02 0.99\\nAs we can see from the convergence table in 2d, if we choose quadrature formulas which are accurate enough, then the error we obtain for \\\\(\\\\alpha(\\\\mathbf{x})\\\\) should be exactly the inverse of the number of elements. The approximation of the circle with N segments of equal size generates a regular polygon with N faces, whose angles are exactly \\\\(\\\\pi-\\\\frac {2\\\\pi}{N}\\\\), therefore the error we commit should be exactly \\\\(\\\\frac 12 - (\\\\frac 12 -\\\\frac 1N) = \\\\frac 1N\\\\). In fact this is a very good indicator that we are performing the singular integrals in an appropriate manner.\\nThe error in the approximation of the potential \\\\(\\\\phi\\\\) is largely due to approximation of the domain. A much better approximation could be obtained by using higher order mappings.\\nIf we modify the main() function, setting fe_degree and mapping_degree to two, and raise the order of the quadrature formulas in the parameter file, we obtain the following convergence table for the two dimensional simulation\\ncycle cells dofs    L2(phi)     Linfty(alpha)\\n    0    20   40 5.414e-05    - 2.306e-04    -\\n    1    40   80 3.623e-06 3.90 1.737e-05 3.73\\n    2    80  160 2.690e-07 3.75 1.253e-05 0.47\\n    3   160  320 2.916e-08 3.21 7.670e-06 0.71\\nand\\ncycle cells dofs    L2(phi)     Linfty(alpha)\\n    0    24   98 3.770e-03    - 8.956e-03    -\\n    1    96  386 1.804e-04 4.39 1.182e-03 2.92\\n    2   384 1538 9.557e-06 4.24 1.499e-04 2.98\\n    3  1536 6146 6.617e-07 3.85 1.892e-05 2.99\\nfor the three dimensional case. As we can see, convergence results are much better with higher order mapping, mainly due to a better resolution of the curved geometry. Notice that, given the same number of degrees of freedom, for example in step 3 of the Q1 case and step 2 of Q2 case in the three dimensional simulation, the error is roughly three orders of magnitude lower.\\nThe result of running these computations is a bunch of output files that we can pass to our visualization program of choice. The output files are of two kind: the potential on the boundary element surface, and the potential extended to the outer and inner domain. The combination of the two for the two dimensional case looks like\\n\\nwhile in three dimensions we show first the potential on the surface, together with a contour plot,\\n\\nand then the external contour plot of the potential, with opacity set to 25%:\\n\\n Possibilities for extensions\\nThis is the first tutorial program that considers solving equations defined on surfaces embedded in higher dimensional spaces. But the equation discussed here was relatively simple because it only involved an integral operator, not derivatives which are more difficult to define on the surface. The step-38 tutorial program considers such problems and provides the necessary tools.\\nFrom a practical perspective, the Boundary Element Method (BEM) used here suffers from two bottlenecks. The first is that assembling the matrix has a cost that is quadratic in the number of unknowns, that is \\\\({\\\\cal O}(N^2)\\\\) where \\\\(N\\\\) is the total number of unknowns. This can be seen by looking at the assemble_system() function, which has this structure: for (const auto &cell : dof_handler.active_cell_iterators())\\n  {\\n    ...\\n \\n for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)\\n      ...\\n Here, the first loop walks over all cells (one factor of \\\\(N\\\\)) whereas the inner loop contributes another factor of \\\\(N\\\\).\\nThis has to be contrasted with the finite element method for local differential operators: There, we loop over all cells (one factor of \\\\(N\\\\)) and on each cell do an amount of work that is independent of how many cells or unknowns there are. This clearly presents a bottleneck.\\nThe second bottleneck is that the system matrix is dense (i.e., is of type FullMatrix) because every degree of freedom couples with every other degree of freedom. As pointed out above, just computing this matrix with its \\\\(N^2\\\\) nonzero entries necessarily requires at least \\\\({\\\\cal O}(N^2)\\\\) operations, but it's worth pointing out that it also costs this many operations to just do one matrix-vector product. If the GMRES method used to solve the linear system requires a number of iterations that grows with the size of the problem, as is typically the case, then solving the linear system will require a number of operations that grows even faster than just \\\\({\\\\cal O}(N^2)\\\\).\\n\\\"Real\\\" boundary element methods address these issues by strategies that determine which entries of the matrix will be small and can consequently be neglected (at the cost of introducing an additional error, of course). This is possible by recognizing that the matrix entries decay with the (physical) distance between the locations where degrees of freedom \\\\(i\\\\) and \\\\(j\\\\) are defined. This can be exploited in methods such as the Fast Multipole Method (FMM) that control which matrix entries must be stored and computed to achieve a certain accuracy, and \\u2013 if done right \\u2013 result in methods in which both assembly and solution of the linear system requires less than \\\\({\\\\cal O}(N^2)\\\\) operations.\\nImplementing these methods clearly presents opportunities to extend the current program.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2009 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Authors: Luca Heltai, Cataldo Manigrasso, 2009\\n */\\n \\n \\n \\n#include <deal.II/base/smartpointer.h>\\n#include <deal.II/base/convergence_table.h>\\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/quadrature_selector.h>\\n#include <deal.II/base/parameter_handler.h>\\n#include <deal.II/base/parsed_function.h>\\n#include <deal.II/base/utilities.h>\\n \\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/vector.h>\\n#include <deal.II/lac/solver_control.h>\\n#include <deal.II/lac/solver_gmres.h>\\n#include <deal.II/lac/precondition.h>\\n \\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_in.h>\\n#include <deal.II/grid/grid_out.h>\\n#include <deal.II/grid/manifold_lib.h>\\n \\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_values.h>\\n#include <deal.II/fe/mapping_q1.h>\\n \\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/vector_tools.h>\\n \\n#include <cmath>\\n#include <iostream>\\n#include <fstream>\\n#include <string>\\n \\nnamespace Step34\\n{\\n using namespace dealii;\\n \\n \\n \\n \\n namespace LaplaceKernel\\n  {\\n template <int dim>\\n double single_layer(const Tensor<1, dim> &R)\\n    {\\n switch (dim)\\n        {\\n case 2:\\n return (-std::log(R.norm()) / (2 * numbers::PI));\\n \\n case 3:\\n return (1. / (R.norm() * 4 * numbers::PI));\\n \\n default:\\n DEAL_II_NOT_IMPLEMENTED();\\n        }\\n    }\\n \\n \\n \\n template <int dim>\\n Tensor<1, dim> double_layer(const Tensor<1, dim> &R)\\n    {\\n switch (dim)\\n        {\\n case 2:\\n return R / (-2 * numbers::PI * R.norm_square());\\n case 3:\\n return R / (-4 * numbers::PI * R.norm_square() * R.norm());\\n \\n default:\\n DEAL_II_NOT_IMPLEMENTED();\\n        }\\n    }\\n  } // namespace LaplaceKernel\\n \\n \\n \\n template <int dim>\\n class BEMProblem\\n  {\\n public:\\n    BEMProblem(const unsigned int fe_degree      = 1,\\n const unsigned int mapping_degree = 1);\\n \\n void run();\\n \\n private:\\n void read_parameters(const std::string &filename);\\n \\n void read_domain();\\n \\n void refine_and_resize();\\n \\n void assemble_system();\\n \\n void solve_system();\\n \\n void compute_errors(const unsigned int cycle);\\n \\n void compute_exterior_solution();\\n \\n void output_results(const unsigned int cycle);\\n \\n Quadrature<dim - 1> get_singular_quadrature(\\n const typename DoFHandler<dim - 1, dim>::active_cell_iterator &cell,\\n const unsigned int index) const;\\n \\n \\n \\n Triangulation<dim - 1, dim> tria;\\n const FE_Q<dim - 1, dim>    fe;\\n DoFHandler<dim - 1, dim>    dof_handler;\\n MappingQ<dim - 1, dim>      mapping;\\n \\n \\n FullMatrix<double> system_matrix;\\n Vector<double>     system_rhs;\\n \\n \\n Vector<double> phi;\\n Vector<double> alpha;\\n \\n \\n ConvergenceTable convergence_table;\\n \\n \\n Functions::ParsedFunction<dim> wind;\\n Functions::ParsedFunction<dim> exact_solution;\\n \\n unsigned int                         singular_quadrature_order;\\n    std::shared_ptr<Quadrature<dim - 1>> quadrature;\\n \\n SolverControl solver_control;\\n \\n unsigned int n_cycles;\\n unsigned int external_refinement;\\n \\n bool run_in_this_dimension;\\n bool extend_solution;\\n  };\\n \\n \\n \\n template <int dim>\\n  BEMProblem<dim>::BEMProblem(const unsigned int fe_degree,\\n const unsigned int mapping_degree)\\n    : fe(fe_degree)\\n    , dof_handler(tria)\\n    , mapping(mapping_degree)\\n    , wind(dim)\\n    , singular_quadrature_order(5)\\n    , n_cycles(4)\\n    , external_refinement(5)\\n    , run_in_this_dimension(true)\\n    , extend_solution(true)\\n  {}\\n \\n \\n template <int dim>\\n void BEMProblem<dim>::read_parameters(const std::string &filename)\\n  {\\n deallog << std::endl\\n            << \\\"Parsing parameter file \\\" << filename << std::endl\\n            << \\\"for a \\\" << dim << \\\" dimensional simulation. \\\" << std::endl;\\n \\n ParameterHandler prm;\\n \\n    prm.declare_entry(\\\"Number of cycles\\\", \\\"4\\\", Patterns::Integer());\\n    prm.declare_entry(\\\"External refinement\\\", \\\"5\\\", Patterns::Integer());\\n    prm.declare_entry(\\\"Extend solution on the -2,2 box\\\",\\n \\\"true\\\",\\n Patterns::Bool());\\n    prm.declare_entry(\\\"Run 2d simulation\\\", \\\"true\\\", Patterns::Bool());\\n    prm.declare_entry(\\\"Run 3d simulation\\\", \\\"true\\\", Patterns::Bool());\\n \\n    prm.enter_subsection(\\\"Quadrature rules\\\");\\n    {\\n      prm.declare_entry(\\n \\\"Quadrature type\\\",\\n \\\"gauss\\\",\\n Patterns::Selection(\\n QuadratureSelector<(dim - 1)>::get_quadrature_names()));\\n      prm.declare_entry(\\\"Quadrature order\\\", \\\"4\\\", Patterns::Integer());\\n      prm.declare_entry(\\\"Singular quadrature order\\\", \\\"5\\\", Patterns::Integer());\\n    }\\n    prm.leave_subsection();\\n \\n    prm.enter_subsection(\\\"Wind function 2d\\\");\\n    {\\n Functions::ParsedFunction<2>::declare_parameters(prm, 2);\\n      prm.set(\\\"Function expression\\\", \\\"1; 1\\\");\\n    }\\n    prm.leave_subsection();\\n \\n    prm.enter_subsection(\\\"Wind function 3d\\\");\\n    {\\n Functions::ParsedFunction<3>::declare_parameters(prm, 3);\\n      prm.set(\\\"Function expression\\\", \\\"1; 1; 1\\\");\\n    }\\n    prm.leave_subsection();\\n \\n    prm.enter_subsection(\\\"Exact solution 2d\\\");\\n    {\\n Functions::ParsedFunction<2>::declare_parameters(prm);\\n      prm.set(\\\"Function expression\\\", \\\"x+y\\\");\\n    }\\n    prm.leave_subsection();\\n \\n    prm.enter_subsection(\\\"Exact solution 3d\\\");\\n    {\\n Functions::ParsedFunction<3>::declare_parameters(prm);\\n      prm.set(\\\"Function expression\\\", \\\"x+y+z\\\");\\n    }\\n    prm.leave_subsection();\\n \\n \\n    prm.enter_subsection(\\\"Solver\\\");\\n SolverControl::declare_parameters(prm);\\n    prm.leave_subsection();\\n \\n    prm.parse_input(filename);\\n \\n    n_cycles            = prm.get_integer(\\\"Number of cycles\\\");\\n    external_refinement = prm.get_integer(\\\"External refinement\\\");\\n    extend_solution     = prm.get_bool(\\\"Extend solution on the -2,2 box\\\");\\n \\n    prm.enter_subsection(\\\"Quadrature rules\\\");\\n    {\\n      quadrature = std::shared_ptr<Quadrature<dim - 1>>(\\n new QuadratureSelector<dim - 1>(prm.get(\\\"Quadrature type\\\"),\\n                                        prm.get_integer(\\\"Quadrature order\\\")));\\n      singular_quadrature_order = prm.get_integer(\\\"Singular quadrature order\\\");\\n    }\\n    prm.leave_subsection();\\n \\n    prm.enter_subsection(\\\"Wind function \\\" + std::to_string(dim) + \\\"d\\\");\\n    {\\n      wind.parse_parameters(prm);\\n    }\\n    prm.leave_subsection();\\n \\n    prm.enter_subsection(\\\"Exact solution \\\" + std::to_string(dim) + \\\"d\\\");\\n    {\\n      exact_solution.parse_parameters(prm);\\n    }\\n    prm.leave_subsection();\\n \\n    prm.enter_subsection(\\\"Solver\\\");\\n    solver_control.parse_parameters(prm);\\n    prm.leave_subsection();\\n \\n \\n    run_in_this_dimension =\\n      prm.get_bool(\\\"Run \\\" + std::to_string(dim) + \\\"d simulation\\\");\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void BEMProblem<dim>::read_domain()\\n  {\\n const Point<dim> center = Point<dim>();\\n const SphericalManifold<dim - 1, dim> manifold(center);\\n \\n    std::ifstream in;\\n switch (dim)\\n      {\\n case 2:\\n          in.open(\\\"coarse_circle.inp\\\");\\n break;\\n \\n case 3:\\n          in.open(\\\"coarse_sphere.inp\\\");\\n break;\\n \\n default:\\n DEAL_II_NOT_IMPLEMENTED();\\n      }\\n \\n GridIn<dim - 1, dim> gi;\\n    gi.attach_triangulation(tria);\\n    gi.read_ucd(in);\\n \\n    tria.set_all_manifold_ids(1);\\n    tria.set_manifold(1, manifold);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void BEMProblem<dim>::refine_and_resize()\\n  {\\n    tria.refine_global(1);\\n \\n    dof_handler.distribute_dofs(fe);\\n \\n const unsigned int n_dofs = dof_handler.n_dofs();\\n \\n    system_matrix.reinit(n_dofs, n_dofs);\\n \\n    system_rhs.reinit(n_dofs);\\n    phi.reinit(n_dofs);\\n    alpha.reinit(n_dofs);\\n  }\\n \\n \\n \\n template <int dim>\\n void BEMProblem<dim>::assemble_system()\\n  {\\n FEValues<dim - 1, dim> fe_v(mapping,\\n                                fe,\\n                                *quadrature,\\n update_values | update_normal_vectors |\\n update_quadrature_points | update_JxW_values);\\n \\n const unsigned int n_q_points = fe_v.n_quadrature_points;\\n \\n    std::vector<types::global_dof_index> local_dof_indices(\\n      fe.n_dofs_per_cell());\\n \\n    std::vector<Vector<double>> cell_wind(n_q_points, Vector<double>(dim));\\n double                      normal_wind;\\n \\n Vector<double> local_matrix_row_i(fe.n_dofs_per_cell());\\n \\n \\n    std::vector<Point<dim>> support_points(dof_handler.n_dofs());\\n DoFTools::map_dofs_to_support_points<dim - 1, dim>(mapping,\\n                                                       dof_handler,\\n                                                       support_points);\\n \\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n        fe_v.reinit(cell);\\n        cell->get_dof_indices(local_dof_indices);\\n \\n const std::vector<Point<dim>> &q_points = fe_v.get_quadrature_points();\\n const std::vector<Tensor<1, dim>> &normals = fe_v.get_normal_vectors();\\n        wind.vector_value_list(q_points, cell_wind);\\n \\n for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)\\n          {\\n            local_matrix_row_i = 0;\\n \\n bool         is_singular    = false;\\n unsigned int singular_index = numbers::invalid_unsigned_int;\\n \\n for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j)\\n if (local_dof_indices[j] == i)\\n                {\\n                  singular_index = j;\\n                  is_singular    = true;\\n break;\\n                }\\n \\n if (is_singular == false)\\n              {\\n for (unsigned int q = 0; q < n_q_points; ++q)\\n                  {\\n                    normal_wind = 0;\\n for (unsigned int d = 0; d < dim; ++d)\\n                      normal_wind += normals[q][d] * cell_wind[q](d);\\n \\n const Tensor<1, dim> R = q_points[q] - support_points[i];\\n \\n                    system_rhs(i) += (LaplaceKernel::single_layer(R) *\\n                                      normal_wind * fe_v.JxW(q));\\n \\n for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j)\\n \\n                      local_matrix_row_i(j) -=\\n                        ((LaplaceKernel::double_layer(R) * normals[q]) *\\n                         fe_v.shape_value(j, q) * fe_v.JxW(q));\\n                  }\\n              }\\n else\\n              {\\n Assert(singular_index != numbers::invalid_unsigned_int,\\n                       ExcInternalError());\\n \\n const Quadrature<dim - 1> singular_quadrature =\\n                  get_singular_quadrature(cell, singular_index);\\n \\n FEValues<dim - 1, dim> fe_v_singular(\\n                  mapping,\\n                  fe,\\n                  singular_quadrature,\\n update_jacobians | update_values | update_normal_vectors |\\n update_quadrature_points);\\n \\n                fe_v_singular.reinit(cell);\\n \\n                std::vector<Vector<double>> singular_cell_wind(\\n                  singular_quadrature.size(), Vector<double>(dim));\\n \\n const std::vector<Tensor<1, dim>> &singular_normals =\\n                  fe_v_singular.get_normal_vectors();\\n const std::vector<Point<dim>> &singular_q_points =\\n                  fe_v_singular.get_quadrature_points();\\n \\n                wind.vector_value_list(singular_q_points, singular_cell_wind);\\n \\n for (unsigned int q = 0; q < singular_quadrature.size(); ++q)\\n                  {\\n const Tensor<1, dim> R =\\n                      singular_q_points[q] - support_points[i];\\n double normal_wind = 0;\\n for (unsigned int d = 0; d < dim; ++d)\\n                      normal_wind +=\\n                        (singular_cell_wind[q](d) * singular_normals[q][d]);\\n \\n                    system_rhs(i) += (LaplaceKernel::single_layer(R) *\\n                                      normal_wind * fe_v_singular.JxW(q));\\n \\n for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j)\\n                      {\\n                        local_matrix_row_i(j) -=\\n                          ((LaplaceKernel::double_layer(R) *\\n                            singular_normals[q]) *\\n                           fe_v_singular.shape_value(j, q) *\\n                           fe_v_singular.JxW(q));\\n                      }\\n                  }\\n              }\\n \\n for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j)\\n              system_matrix(i, local_dof_indices[j]) += local_matrix_row_i(j);\\n          }\\n      }\\n \\n \\n Vector<double> ones(dof_handler.n_dofs());\\n    ones.add(-1.);\\n \\n    system_matrix.vmult(alpha, ones);\\n    alpha.add(1);\\n for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)\\n      system_matrix(i, i) += alpha(i);\\n  }\\n \\n \\n \\n template <int dim>\\n void BEMProblem<dim>::solve_system()\\n  {\\n SolverGMRES<Vector<double>> solver(solver_control);\\n    solver.solve(system_matrix, phi, system_rhs, PreconditionIdentity());\\n  }\\n \\n \\n \\n template <int dim>\\n void BEMProblem<dim>::compute_errors(const unsigned int cycle)\\n  {\\n Vector<float> difference_per_cell(tria.n_active_cells());\\n VectorTools::integrate_difference(mapping,\\n                                      dof_handler,\\n                                      phi,\\n                                      exact_solution,\\n                                      difference_per_cell,\\n QGauss<(dim - 1)>(2 * fe.degree + 1),\\n VectorTools::L2_norm);\\n const double L2_error =\\n VectorTools::compute_global_error(tria,\\n                                        difference_per_cell,\\n VectorTools::L2_norm);\\n \\n Vector<double> difference_per_node(alpha);\\n    difference_per_node.add(-.5);\\n \\n const double       alpha_error    = difference_per_node.linfty_norm();\\n const unsigned int n_active_cells = tria.n_active_cells();\\n const unsigned int n_dofs         = dof_handler.n_dofs();\\n \\n deallog << \\\"Cycle \\\" << cycle << ':' << std::endl\\n            << \\\"   Number of active cells:       \\\" << n_active_cells\\n            << std::endl\\n            << \\\"   Number of degrees of freedom: \\\" << n_dofs << std::endl;\\n \\n    convergence_table.add_value(\\\"cycle\\\", cycle);\\n    convergence_table.add_value(\\\"cells\\\", n_active_cells);\\n    convergence_table.add_value(\\\"dofs\\\", n_dofs);\\n    convergence_table.add_value(\\\"L2(phi)\\\", L2_error);\\n    convergence_table.add_value(\\\"Linfty(alpha)\\\", alpha_error);\\n  }\\n \\n \\n \\n template <>\\n Quadrature<2> BEMProblem<3>::get_singular_quadrature(\\n const DoFHandler<2, 3>::active_cell_iterator &,\\n const unsigned int index) const\\n {\\n Assert(index < fe.n_dofs_per_cell(),\\n           ExcIndexRange(0, fe.n_dofs_per_cell(), index));\\n \\n static std::vector<QGaussOneOverR<2>> quadratures;\\n if (quadratures.empty())\\n for (unsigned int i = 0; i < fe.n_dofs_per_cell(); ++i)\\n        quadratures.emplace_back(singular_quadrature_order,\\n                                 fe.get_unit_support_points()[i],\\n true);\\n return quadratures[index];\\n  }\\n \\n \\n template <>\\n Quadrature<1> BEMProblem<2>::get_singular_quadrature(\\n const DoFHandler<1, 2>::active_cell_iterator &cell,\\n const unsigned int                            index) const\\n {\\n Assert(index < fe.n_dofs_per_cell(),\\n           ExcIndexRange(0, fe.n_dofs_per_cell(), index));\\n \\n return QGaussLogR<1>(singular_quadrature_order,\\n                         fe.get_unit_support_points()[index],\\n                         1. / cell->measure(),\\n true);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void BEMProblem<dim>::compute_exterior_solution()\\n  {\\n Triangulation<dim> external_tria;\\n GridGenerator::hyper_cube(external_tria, -2, 2);\\n \\n const FE_Q<dim> external_fe(1);\\n DoFHandler<dim> external_dh(external_tria);\\n Vector<double>  external_phi;\\n \\n    external_tria.refine_global(external_refinement);\\n    external_dh.distribute_dofs(external_fe);\\n    external_phi.reinit(external_dh.n_dofs());\\n \\n FEValues<dim - 1, dim> fe_v(mapping,\\n                                fe,\\n                                *quadrature,\\n update_values | update_normal_vectors |\\n update_quadrature_points | update_JxW_values);\\n \\n const unsigned int n_q_points = fe_v.n_quadrature_points;\\n \\n    std::vector<types::global_dof_index> dofs(fe.n_dofs_per_cell());\\n \\n    std::vector<double>         local_phi(n_q_points);\\n    std::vector<double>         normal_wind(n_q_points);\\n    std::vector<Vector<double>> local_wind(n_q_points, Vector<double>(dim));\\n \\n    std::vector<Point<dim>> external_support_points(external_dh.n_dofs());\\n DoFTools::map_dofs_to_support_points<dim>(StaticMappingQ1<dim>::mapping,\\n                                              external_dh,\\n                                              external_support_points);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n        fe_v.reinit(cell);\\n \\n const std::vector<Point<dim>> &q_points = fe_v.get_quadrature_points();\\n const std::vector<Tensor<1, dim>> &normals = fe_v.get_normal_vectors();\\n \\n        cell->get_dof_indices(dofs);\\n        fe_v.get_function_values(phi, local_phi);\\n \\n        wind.vector_value_list(q_points, local_wind);\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n          {\\n            normal_wind[q] = 0;\\n for (unsigned int d = 0; d < dim; ++d)\\n              normal_wind[q] += normals[q][d] * local_wind[q](d);\\n          }\\n \\n for (unsigned int i = 0; i < external_dh.n_dofs(); ++i)\\n for (unsigned int q = 0; q < n_q_points; ++q)\\n            {\\n const Tensor<1, dim> R = q_points[q] - external_support_points[i];\\n \\n              external_phi(i) +=\\n                ((LaplaceKernel::single_layer(R) * normal_wind[q] +\\n                  (LaplaceKernel::double_layer(R) * normals[q]) *\\n                    local_phi[q]) *\\n                 fe_v.JxW(q));\\n            }\\n      }\\n \\n DataOut<dim> data_out;\\n \\n    data_out.attach_dof_handler(external_dh);\\n    data_out.add_data_vector(external_phi, \\\"external_phi\\\");\\n    data_out.build_patches();\\n \\n const std::string filename = std::to_string(dim) + \\\"d_external.vtk\\\";\\n    std::ofstream     file(filename);\\n \\n    data_out.write_vtk(file);\\n  }\\n \\n \\n \\n template <int dim>\\n void BEMProblem<dim>::output_results(const unsigned int cycle)\\n  {\\n DataOut<dim - 1, dim> dataout;\\n \\n    dataout.attach_dof_handler(dof_handler);\\n    dataout.add_data_vector(phi, \\\"phi\\\", DataOut<dim - 1, dim>::type_dof_data);\\n    dataout.add_data_vector(alpha,\\n \\\"alpha\\\",\\n DataOut<dim - 1, dim>::type_dof_data);\\n    dataout.build_patches(mapping,\\n                          mapping.get_degree(),\\n DataOut<dim - 1, dim>::curved_inner_cells);\\n \\n const std::string filename = std::to_string(dim) + \\\"d_boundary_solution_\\\" +\\n                                 std::to_string(cycle) + \\\".vtk\\\";\\n    std::ofstream file(filename);\\n \\n    dataout.write_vtk(file);\\n \\n if (cycle == n_cycles - 1)\\n      {\\n        convergence_table.set_precision(\\\"L2(phi)\\\", 3);\\n        convergence_table.set_precision(\\\"Linfty(alpha)\\\", 3);\\n \\n        convergence_table.set_scientific(\\\"L2(phi)\\\", true);\\n        convergence_table.set_scientific(\\\"Linfty(alpha)\\\", true);\\n \\n        convergence_table.evaluate_convergence_rates(\\n \\\"L2(phi)\\\", ConvergenceTable::reduction_rate_log2);\\n        convergence_table.evaluate_convergence_rates(\\n \\\"Linfty(alpha)\\\", ConvergenceTable::reduction_rate_log2);\\n deallog << std::endl;\\n        convergence_table.write_text(std::cout);\\n      }\\n  }\\n \\n \\n \\n template <int dim>\\n void BEMProblem<dim>::run()\\n  {\\n    read_parameters(\\\"parameters.prm\\\");\\n \\n if (run_in_this_dimension == false)\\n      {\\n deallog << \\\"Run in dimension \\\" << dim\\n                << \\\" explicitly disabled in parameter file. \\\" << std::endl;\\n return;\\n      }\\n \\n    read_domain();\\n \\n for (unsigned int cycle = 0; cycle < n_cycles; ++cycle)\\n      {\\n        refine_and_resize();\\n        assemble_system();\\n        solve_system();\\n        compute_errors(cycle);\\n        output_results(cycle);\\n      }\\n \\n if (extend_solution == true)\\n      compute_exterior_solution();\\n  }\\n} // namespace Step34\\n \\n \\n \\nint main()\\n{\\n try\\n    {\\n using namespace Step34;\\n \\n const unsigned int degree         = 1;\\n const unsigned int mapping_degree = 1;\\n \\n deallog.depth_console(3);\\n      BEMProblem<2> laplace_problem_2d(degree, mapping_degree);\\n      laplace_problem_2d.run();\\n \\n      BEMProblem<3> laplace_problem_3d(degree, mapping_degree);\\n      laplace_problem_3d.run();\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n \\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n \\n return 0;\\n}\\nDataOutInterface::write_vtkvoid write_vtk(std::ostream &out) constDefinition data_out_base.cc:7681\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nFEValues::reinitvoid reinit(const TriaIterator< DoFCellAccessor< dim, spacedim, level_dof_access > > &cell)\\nParameterHandler::parse_inputvirtual void parse_input(std::istream &input, const std::string &filename=\\\"input file\\\", const std::string &last_line=\\\"\\\", const bool skip_undefined=false)Definition parameter_handler.cc:433\\nParameterHandler::enter_subsectionvoid enter_subsection(const std::string &subsection, const bool create_path_if_needed=true)Definition parameter_handler.cc:991\\nParameterHandler::leave_subsectionvoid leave_subsection()Definition parameter_handler.cc:1015\\nParameterHandler::get_integerlong int get_integer(const std::string &entry_string) constDefinition parameter_handler.cc:1087\\nParameterHandler::get_boolbool get_bool(const std::string &entry_name) constDefinition parameter_handler.cc:1175\\nParameterHandler::getstd::string get(const std::string &entry_string) constDefinition parameter_handler.cc:1049\\nParameterHandler::setvoid set(const std::string &entry_name, const std::string &new_value)Definition parameter_handler.cc:1214\\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nconvergence_table.h\\ndof_handler.h\\ndof_tools.h\\nfe_values.h\\nfe_q.h\\nfull_matrix.h\\nmanifold_lib.h\\ntria.h\\ngrid_generator.h\\ngrid_in.h\\ngrid_out.h\\nutilities.h\\nmapping_q1.h\\nPhysics::Elasticity::Kinematics::dSymmetricTensor< 2, dim, Number > d(const Tensor< 2, dim, Number > &F, const Tensor< 2, dim, Number > &dF_dt)\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\ninternal::TriangulationImplementation::n_active_cellsunsigned int n_active_cells(const internal::TriangulationImplementation::NumberCache< 1 > &c)Definition tria.cc:14890\\ninternal::VectorizationTypes::index@ index\\ndata_out.h\\nparameter_handler.h\\nparsed_function.h\\nprecondition.h\\nquadrature_lib.h\\nquadrature_selector.h\\nsmartpointer.h\\nsolver_control.h\\nsolver_gmres.h\\nvector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"