"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_30.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-30 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-30 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-30 tutorial program\\n\\n\\nThis tutorial depends on step-12.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nOverview\\nAnisotropic refinement\\n\\nMotivation\\n\\nImplementation\\n\\nMesh smoothing\\n\\nJump indicator\\nThe problem\\n\\n The commented program\\n\\nEquation data\\nClass: DGTransportEquation\\nClass: DGMethod\\n\\nFunction: assemble_system\\n\\nSolver\\nRefinement\\nThe Rest\\n\\n\\n Results\\n\\n\\n The plain program\\n   \\n Introduction\\nOverview\\nThis example is devoted to anisotropic refinement, which extends to possibilities of local refinement. In most parts, this is a modification of the step-12 tutorial program, we use the same DG method for a linear transport equation. This program will cover the following topics: \\n\\nAnisotropic refinement: What is the meaning of anisotropic refinement? \\n\\nImplementation: Necessary modifications of code to work with anisotropically refined meshes. \\n\\nJump indicator: A simple indicator for anisotropic refinement in the context of DG methods. \\n\\nThe discretization itself will not be discussed, and neither will implementation techniques not specific to anisotropic refinement used here. Please refer to step-12 for this.\\nPlease note, at the moment of writing this tutorial program, anisotropic refinement is only fully implemented for discontinuous Galerkin Finite Elements. This may later change (or may already have).\\nNoteWhile this program is a modification of step-12, it is an adaptation of a version of step-12 written early on in the history of deal.II when the MeshWorker framework wasn't available yet. Consequently, it bears little resemblance to the step-12 as it exists now, apart from the fact that it solves the same equation with the same discretization.\\nAnisotropic refinement\\nAll the adaptive processes in the preceding tutorial programs were based on isotropic refinement of cells, which cuts all edges in half and forms new cells of these split edges (plus some additional edges, faces and vertices, of course). In deal.II, anisotropic refinement refers to the process of splitting only part of the edges while leaving the others unchanged. Consider a simple square cell, for example:  -------*\\n|       |\\n|       |\\n|       |\\n -------*\\n After the usual refinement it will consist of four children and look like this:  ---*---*\\n|   |   |\\n ---*---*     RefinementCase<2>::cut_xy\\n|   |   |\\n ---*---*\\nRefinementCaseDefinition geometry_info.h:779\\n The new anisotropic refinement may take two forms: either we can split the edges which are parallel to the horizontal x-axis, resulting in these two child cells:  ---*---*\\n|   |   |\\n|   |   |     RefinementCase<2>::cut_x\\n|   |   |\\n ---*---*\\n or we can split the two edges which run along the y-axis, resulting again in two children, which look that way, however:  -------*\\n|       |\\n -------*     RefinementCase<2>::cut_y\\n|       |\\n -------*\\n All refinement cases of cells are described by an enumeration RefinementPossibilities::Possibilities, and the above anisotropic cases are called cut_x and cut_y for obvious reasons. The isotropic refinement case is called cut_xy in 2D and can be requested from the RefinementCase class via RefinementCase<dim>::isotropic_refinement.\\nIn 3D, there is a third axis which can be split, the z-axis, and thus we have an additional refinement case cut_z here. Isotropic refinement will now refine a cell along the x-, y- and z-axes and thus be referred to as cut_xyz. Additional cases cut_xy, cut_xz and cut_yz exist, which refine a cell along two of the axes, but not along the third one. Given a hex cell with x-axis running to the right, y-axis 'into the page' and z-axis to the top,      -----------*\\n   /           /|\\n  /           / |\\n /           /  |\\n -----------*   |\\n|           |   |\\n|           |   *\\n|           |  /\\n|           | /\\n|           |/\\n -----------*\\n we have the isotropic refinement case,      -----*-----*\\n   /     /     /|\\n   -----*-----* |\\n /     /     /| *\\n -----*-----* |/|\\n|     |     | * |\\n|     |     |/| *\\n -----*-----* |/\\n|     |     | *\\n|     |     |/\\n -----*-----*\\n \\nRefinementCase<3>::cut_xyz\\n three anisotropic cases which refine only one axis:      -----*-----*             *-----------*             *-----------*\\n   /     /     /|            /           /|            /           /|\\n  /     /     / |           *-----------* |           /           / |\\n /     /     /  |          /           /| |          /           /  *\\n -----*-----*   |         *-----------* | |         *-----------*  /|\\n|     |     |   |         |           | | |         |           | / |\\n|     |     |   *         |           | | *         |           |/  *\\n|     |     |  /          |           | |/          *-----------*  /\\n|     |     | /           |           | *           |           | /\\n|     |     |/            |           |/            |           |/\\n -----*-----*             *-----------*             *-----------*\\n \\nRefinementCase<3>::cut_x RefinementCase<3>::cut_y RefinementCase<3>::cut_z\\n and three cases which refine two of the three axes:      -----*-----*             *-----*-----*             *-----------*\\n   /     /     /|            /     /     /|            /           /|\\n   -----*-----* |           /     /     / |           *-----------* |\\n /     /     /| |          /     /     /  *          /           /| *\\n -----*-----* | |         *-----*-----*  /|         *-----------* |/|\\n|     |     | | |         |     |     | / |         |           | * |\\n|     |     | | *         |     |     |/  *         |           |/| *\\n|     |     | |/          *-----*-----*  /          *-----------* |/\\n|     |     | *           |     |     | /           |           | *\\n|     |     |/            |     |     |/            |           |/\\n -----*-----*             *-----*-----*             *-----------*\\n \\nRefinementCase<3>::cut_xy RefinementCase<3>::cut_xz RefinementCase<3>::cut_yz\\n For 1D problems, anisotropic refinement can make no difference, as there is only one coordinate direction for a cell, so it is not possible to split it in any other way than isotropically.\\nMotivation\\nAdaptive local refinement is used to obtain fine meshes which are well adapted to solving the problem at hand efficiently. In short, the size of cells which produce a large error is reduced to obtain a better approximation of the solution to the problem at hand. However, a lot of problems contain anisotropic features. Prominent examples are shocks or boundary layers in compressible viscous flows. An efficient mesh approximates these features with cells of higher aspect ratio which are oriented according to the mentioned features. Using only isotropic refinement, the aspect ratios of the original mesh cells are preserved, as they are inherited by the children of a cell. Thus, starting from an isotropic mesh, a boundary layer will be refined in order to catch the rapid variation of the flow field in the wall normal direction, thus leading to cells with very small edge lengths both in normal and tangential direction. Usually, much higher edge lengths in tangential direction and thus significantly less cells could be used without a significant loss in approximation accuracy. An anisotropic refinement process can modify the aspect ratio from mother to child cells by a factor of two for each refinement step. In the course of several refinements, the aspect ratio of the fine cells can be optimized, saving a considerable number of cells and correspondingly degrees of freedom and thus computational resources, memory as well as CPU time.\\nImplementation\\nMost of the time, when we do finite element computations, we only consider one cell at a time, for example to calculate cell contributions to the global matrix, or to interpolate boundary values. However, sometimes we have to look at how cells are related in our algorithms. Relationships between cells come in two forms: neighborship and mother-child relationship. For the case of isotropic refinement, deal.II uses certain conventions (invariants) for cell relationships that are always maintained. For example, a refined cell always has exactly \\\\(2^{dim}\\\\) children. And (except for the 1d case), two neighboring cells may differ by at most one refinement level: they are equally often refined or one of them is exactly once more refined, leaving exactly one hanging node on the common face. Almost all of the time these invariants are only of concern in the internal implementation of the library. However, there are cases where knowledge of them is also relevant to an application program.\\nIn the current context, it is worth noting that the kind of mesh refinement affects some of the most fundamental assumptions. Consequently, some of the usual code found in application programs will need modifications to exploit the features of meshes which were created using anisotropic refinement. For those interested in how deal.II evolved, it may be of interest that the loosening of such invariants required some incompatible changes. For example, the library used to have a member GeometryInfo<dim>::children_per_cell that specified how many children a cell has once it is refined. For isotropic refinement, this number is equal to \\\\(2^{dim}\\\\), as mentioned above. However, for anisotropic refinement, this number does not exist, as is can be either two or four in 2D and two, four or eight in 3D, and the member GeometryInfo<dim>::children_per_cell has consequently been removed. It has now been replaced by GeometryInfo<dim>::max_children_per_cell which specifies the maximum number of children a cell can have. How many children a refined cell has was previously available as static information, but now it depends on the actual refinement state of a cell and can be retrieved using TriaAccessor::n_children(), a call that works equally well for both isotropic and anisotropic refinement. A very similar situation can be found for faces and their subfaces: the pertinent information can be queried using GeometryInfo<dim>::max_children_per_face or face->n_children(), depending on the context.\\nAnother important aspect, and the most important one in this tutorial, is the treatment of neighbor-relations when assembling jump terms on the faces between cells. Looking at the documentation of the assemble_system functions in step-12 we notice, that we need to decide if a neighboring cell is coarser, finer or on the same (refinement) level as our current cell. These decisions do not work in the same way for anisotropic refinement as the information given by the level of a cell is not enough to completely characterize anisotropic cells; for example, are the terminal children of a two-dimensional cell that is first cut in \\\\(x\\\\)-direction and whose children are then cut in \\\\(y\\\\)-direction on level 2, or are they on level 1 as they would be if the cell would have been refined once isotropically, resulting in the same set of finest cells?\\nAfter anisotropic refinement, a coarser neighbor is not necessarily exactly one level below ours, but can pretty much have any level relative to the current one; in fact, it can even be on a higher level even though it is coarser. Thus the decisions have to be made on a different basis, whereas the intention of the decisions stays the same.\\nIn the following, we will discuss the cases that can happen when we want to compute contributions to the matrix (or right hand side) of the form   \\n\\\\[\\n  \\\\int_{\\\\partial K} \\\\varphi_i(x) \\\\varphi_j(x) \\\\; dx\\n\\\\]\\n\\n or similar; remember that we integrate terms like this using the FEFaceValues and FESubfaceValues classes. We will also show how to write code that works for both isotropic and anisotropic refinement:\\n\\n\\nFiner neighbor: If we are on an active cell and want to integrate over a face \\\\(f\\\\subset \\\\partial K\\\\), the first possibility is that the neighbor behind this face is more refined, i.e. has children occupying only part of the common face. In this case, the face under consideration has to be a refined one, which can determine by asking if (face->has_children()). If this is true, we need to loop over all subfaces and get the neighbors' child behind this subface, so that we can reinit an FEFaceValues object with the neighbor and an FESubfaceValues object with our cell and the respective subface.\\nFor isotropic refinement, this kind is reasonably simple because we know that an invariant of the isotropically refined adaptive meshes in deal.II is that neighbors can only differ by exactly one refinement level. However, this isn't quite true any more for anisotropically refined meshes, in particular in 3d; there, the active cell we are interested on the other side of \\\\(f\\\\) might not actually be a child of our neighbor, but perhaps a grandchild or even a farther offspring. Fortunately, this complexity is hidden in the internals of the library. All we need to do is call the CellAccessor::neighbor_child_on_subface() function. Still, in 3D there are two cases which need special consideration: \\n\\nIf the neighbor is refined more than once anisotropically, it might be that here are not two or four but actually three subfaces to consider. Imagine the following refinement process of the (two-dimensional) face of the (three-dimensional) neighbor cell we are considering: first the face is refined along x, later on only the left subface is refined along y.  -------*        *---*---*        *---*---*\\n|       |        |   |   |        |   |   |\\n|       |  --->  |   |   |  --->  *---*   |\\n|       |        |   |   |        |   |   |\\n -------*        *---*---*        *---*---*\\n Here the number of subfaces is three. It is important to note the subtle differences between, for a face, TriaAccessor::n_children() and TriaAccessor::n_active_descendants(). The first function returns the number of immediate children, which would be two for the above example, whereas the second returns the number of active offspring (i.e., including children, grandchildren, and further descendants), which is the correct three in the example above. Using face->n_active_descendants() works for isotropic and anisotropic as well as 2D and 3D cases, so it should always be used. It should be noted that if any of the cells behind the two small subfaces on the left side of the rightmost image is further refined, then the current cell (i.e. the side from which we are viewing this common face) is going to be refined as well: this is so because otherwise the invariant of having only one hanging node per edge would be violated.\\n\\n\\n\\nIt might be, that the neighbor is coarser, but still has children which are finer than our current cell. This situation can occur if two equally coarse cells are refined, where one of the cells has two children at the face under consideration and the other one four. The cells in the next graphic are only separated from each other to show the individual refinement cases.      -----------*     *-----------*\\n   /           /|    /           /|\\n  ############# |   +++++++++++++ |\\n #           ## |  +           ++ *\\n############# # | +++++++++++++ +/|\\n#           # # | +           + + |\\n#           # # * +           +++ *\\n#           # #/  +++++++++++++ +/\\n#           # #   +           + +\\n#           ##    +           ++\\n#############     +++++++++++++\\nHere, the left two cells resulted from an anisotropic bisection of the mother cell in \\\\(y\\\\)-direction, whereas the right four cells resulted from a simultaneous anisotropic refinement in both the \\\\(y\\\\)- and \\\\(z\\\\)-directions. The left cell marked with # has two finer neighbors marked with +, but the actual neighbor of the left cell is the complete right mother cell, as the two cells marked with + are finer and their direct mother is the one large cell. \\n\\n\\nHowever, fortunately, CellAccessor::neighbor_child_on_subface() takes care of these situations by itself, if you loop over the correct number of subfaces, in the above example this is two. The FESubfaceValues<dim>::reinit function takes care of this too, so that the resulting state is always correct. There is one little caveat, however: For reiniting the neighbors FEFaceValues object you need to know the index of the face that points toward the current cell. Usually you assume that the neighbor you get directly is as coarse or as fine as you, if it has children, thus this information can be obtained with CellAccessor::neighbor_of_neighbor(). If the neighbor is coarser, however, you would have to use the first value in CellAccessor::neighbor_of_coarser_neighbor() instead. In order to make this easy for you, there is CellAccessor::neighbor_face_no() which does the correct thing for you and returns the desired result.\\n\\n\\n\\nNeighbor is as fine as our cell: After we ruled out all cases in which there are finer children, we only need to decide, whether the neighbor is coarser here. For this, there is the CellAccessor::neighbor_is_coarser() function which returns a boolean. In order to get the relevant case of a neighbor of the same coarseness we would use else if (!cell->neighbor_is_coarser(face_no)). The code inside this block can be left untouched. However, there is one thing to mention here: If we want to use a rule, which cell should assemble certain terms on a given face we might think of the rule presented in step-12. We know that we have to leave out the part about comparing our cell's level with that of the neighbor and replace it with the test for a coarser neighbor presented above. However, we also have to consider the possibility that neighboring cells of same coarseness have the same index (on different levels). Thus we have to include the case where the cells have the same index, and give an additional condition, which of the cells should assemble the terms, e.g. we can choose the cell with lower level. The details of this concept can be seen in the implementation below.\\n\\n\\n\\nCoarser neighbor: The remaining case is obvious: If there are no refined neighbors and the neighbor is not as fine as the current cell, then it must be coarser. Thus we can leave the old condition phrase, simply using else. The CellAccessor::neighbor_of_coarser_neighbor() function takes care of all the complexity of anisotropic refinement combined with possible non standard face orientation, flip and rotation on general 3D meshes.\\n\\n\\n\\nMesh smoothing\\nWhen a triangulation is refined, cells which were not flagged for refinement may be refined nonetheless. This is due to additional smoothing algorithms which are either necessary or requested explicitly. In particular, the restriction that there be at most one hanging node on each edge frequently forces the refinement of additional cells neighboring ones that are already finer and are flagged for further refinement.\\nHowever, deal.II also implements a number of algorithms that make sure that resulting meshes are smoother than just the bare minimum, for example ensuring that there are no isolated refined cells surrounded by non-refined ones, since the additional degrees of freedom on these islands would almost all be constrained by hanging node constraints. (See the documentation of the Triangulation class and its Triangulation::MeshSmoothing member for more information on mesh smoothing.)\\nMost of the smoothing algorithms that were originally developed for the isotropic case have been adapted to work in a very similar way for both anisotropic and isotropic refinement. There are two algorithms worth mentioning, however: \\n\\nMeshSmoothing::limit_level_difference_at_vertices: In an isotropic environment, this algorithm tries to ensure a good approximation quality by reducing the difference in refinement level of cells meeting at a common vertex. However, there is no clear corresponding concept for anisotropic refinement, thus this algorithm may not be used in combination with anisotropic refinement. This restriction is enforced by an assertion which throws an error as soon as the algorithm is called on a triangulation which has been refined anisotropically.\\n\\n\\n\\nMeshSmoothing::allow_anisotropic_smoothing: If refinement is introduced to limit the number of hanging nodes, the additional cells are often not needed to improve the approximation quality. This is especially true for DG methods. If you set the flag allow_anisotropic_smoothing the smoothing algorithm tries to minimize the number of probably unneeded additional cells by using anisotropic refinement for the smoothing. If you set this smoothing flag you might get anisotropically refined cells, even if you never set a single refinement flag to anisotropic refinement. Be aware that you should only use this flag, if your code respects the possibility of anisotropic meshes. Combined with a suitable anisotropic indicator this flag can help save additional cells and thus effort. \\n\\nJump indicator\\nUsing the benefits of anisotropic refinement requires an indicator to catch anisotropic features of the solution and exploit them for the refinement process. Generally the anisotropic refinement process will consist of several steps: \\n\\nCalculate an error indicator. \\n\\nUse the error indicator to flag cells for refinement, e.g. using a fixed number or fraction of cells. Those cells will be flagged for isotropic refinement automatically. \\n\\nEvaluate a distinct anisotropic indicator only on the flagged cells. \\n\\nUse the anisotropic indicator to set a new, anisotropic refinement flag for cells where this is appropriate, leave the flags unchanged otherwise. \\n\\nCall Triangulation<dim>::execute_coarsening_and_refinement to perform the requested refinement, using the requested isotropic and anisotropic flags. \\n\\nThis approach is similar to the one we have used in step-27 for hp-refinement and has the great advantage of flexibility: Any error indicator can be used in the anisotropic process, i.e. if you have quite involved a posteriori goal-oriented error indicators available you can use them as easily as a simple Kelly error estimator. The anisotropic part of the refinement process is not influenced by this choice. Furthermore, simply leaving out the third and forth steps leads to the same isotropic refinement you used to get before any anisotropic changes in deal.II or your application program. As a last advantage, working only on cells flagged for refinement results in a faster evaluation of the anisotropic indicator, which can become noticeable on finer meshes with a lot of cells if the indicator is quite involved.\\nHere, we use a very simple approach which is only applicable to DG methods. The general idea is quite simple: DG methods allow the discrete solution to jump over the faces of a cell, whereas it is smooth within each cell. Of course, in the limit we expect that the jumps tend to zero as we refine the mesh and approximate the true solution better and better. Thus, a large jump across a given face indicates that the cell should be refined (at least) orthogonally to that face, whereas a small jump does not lead to this conclusion. It is possible, of course, that the exact solution is not smooth and that it also features a jump. In that case, however, a large jump over one face indicates, that this face is more or less parallel to the jump and in the vicinity of it, thus again we would expect a refinement orthogonal to the face under consideration to be effective.\\nThe proposed indicator calculates the average jump \\\\(K_j\\\\), i.e. the mean value of the absolute jump \\\\(|[u]|\\\\) of the discrete solution \\\\(u\\\\) over the two faces \\\\(f_i^j\\\\), \\\\(i=1,2\\\\), \\\\(j=1..d\\\\) orthogonal to coordinate direction \\\\(j\\\\) on the unit cell.   \\n\\\\[\\nK_j = \\\\frac{\\\\sum_{i=1}^2 \\\\int_{f_i^j}|[u]| dx}{\\\\sum_{i=1}^2 |f_i^j|} .\\n\\\\]\\n\\n If the average jump in one direction is larger than the average of the jumps in the other directions by a certain factor \\\\(\\\\kappa\\\\), i.e. if \\\\(K_i > \\\\kappa \\\\frac 1{d-1} \\\\sum_{j=1, j\\\\neq i}^d K_j\\\\), the cell is refined only along that particular direction \\\\(i\\\\), otherwise the cell is refined isotropically.\\nSuch a criterion is easily generalized to systems of equations: the absolute value of the jump would be replaced by an appropriate norm of the vector-valued jump.\\nThe problem\\nWe solve the linear transport equation presented in step-12. The domain is extended to cover \\\\([-1,1]\\\\times[0,1]\\\\) in 2D, where the flow field \\\\(\\\\beta\\\\) describes a counterclockwise quarter circle around the origin in the right half of the domain and is parallel to the x-axis in the left part of the domain. The inflow boundary is again located at \\\\(x=1\\\\) and along the positive part of the x-axis, and the boundary conditions are chosen as in step-12.\\n The commented program\\nThe deal.II include files have already been covered in previous examples and will thus not be further commented on.\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/timer.h>\\n\\u00a0 #include <deal.II/lac/precondition_block.h>\\n\\u00a0 #include <deal.II/lac/solver_richardson.h>\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_out.h>\\n\\u00a0 #include <deal.II/grid/grid_refinement.h>\\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 #include <deal.II/fe/mapping_q1.h>\\n\\u00a0 #include <deal.II/fe/fe_dgq.h>\\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/derivative_approximation.h>\\n\\u00a0 \\nAnd this again is C++:\\n\\u00a0 #include <array>\\n\\u00a0 #include <iostream>\\n\\u00a0 #include <fstream>\\n\\u00a0 \\nThe last step is as in all previous programs:\\n\\u00a0 namespace Step30\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n Equation data\\nThe classes describing equation data and the actual assembly of individual terms are almost entirely copied from step-12. We will comment on differences.\\n\\u00a0   template <int dim>\\n\\u00a0   class RHS : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     virtual void value_list(const std::vector<Point<dim>> &points,\\n\\u00a0                             std::vector<double>           &values,\\n\\u00a0                             const unsigned int /*component*/ = 0) const override\\n\\u00a0     {\\n\\u00a0       (void)points;\\n\\u00a0       AssertDimension(values.size(), points.size());\\n\\u00a0 \\n\\u00a0       std::fill(values.begin(), values.end(), 0.);\\n\\u00a0     }\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   class BoundaryValues : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     virtual void value_list(const std::vector<Point<dim>> &points,\\n\\u00a0                             std::vector<double>           &values,\\n\\u00a0                             const unsigned int /*component*/ = 0) const override\\n\\u00a0     {\\n\\u00a0       AssertDimension(values.size(), points.size());\\n\\u00a0 \\n\\u00a0       for (unsigned int i = 0; i < values.size(); ++i)\\n\\u00a0         {\\n\\u00a0           if (points[i][0] < 0.5)\\n\\u00a0             values[i] = 1.;\\n\\u00a0           else\\n\\u00a0             values[i] = 0.;\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   class Beta\\n\\u00a0   {\\n\\u00a0   public:\\nFunctionDefinition function.h:152\\nFunction::value_listvirtual void value_list(const std::vector< Point< dim > > &points, std::vector< RangeNumberType > &values, const unsigned int component=0) const\\nPointDefinition point.h:111\\nAssertDimension#define AssertDimension(dim1, dim2)Definition exceptions.h:1985\\nThe flow field is chosen to be a quarter circle with counterclockwise flow direction and with the origin as midpoint for the right half of the domain with positive \\\\(x\\\\) values, whereas the flow simply goes to the left in the left part of the domain at a velocity that matches the one coming in from the right. In the circular part the magnitude of the flow velocity is proportional to the distance from the origin. This is a difference to step-12, where the magnitude was 1 everywhere. the new definition leads to a linear variation of \\\\(\\\\beta\\\\) along each given face of a cell. On the other hand, the solution \\\\(u(x,y)\\\\) is exactly the same as before.\\n\\u00a0     void value_list(const std::vector<Point<dim>> &points,\\n\\u00a0                     std::vector<Point<dim>>       &values) const\\n\\u00a0     {\\n\\u00a0       AssertDimension(values.size(), points.size());\\n\\u00a0 \\n\\u00a0       for (unsigned int i = 0; i < points.size(); ++i)\\n\\u00a0         {\\n\\u00a0           if (points[i][0] > 0)\\n\\u00a0             {\\n\\u00a0               values[i][0] = -points[i][1];\\n\\u00a0               values[i][1] = points[i][0];\\n\\u00a0             }\\n\\u00a0           else\\n\\u00a0             {\\n\\u00a0               values[i]    = Point<dim>();\\n\\u00a0               values[i][0] = -points[i][1];\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n Class: DGTransportEquation\\nThis declaration of this class is utterly unaffected by our current changes.\\n\\u00a0   template <int dim>\\n\\u00a0   class DGTransportEquation\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     DGTransportEquation();\\n\\u00a0 \\n\\u00a0     void assemble_cell_term(const FEValues<dim> &fe_v,\\n\\u00a0                             FullMatrix<double>  &ui_vi_matrix,\\n\\u00a0                             Vector<double>      &cell_vector) const;\\n\\u00a0 \\n\\u00a0     void assemble_boundary_term(const FEFaceValues<dim> &fe_v,\\n\\u00a0                                 FullMatrix<double>      &ui_vi_matrix,\\n\\u00a0                                 Vector<double>          &cell_vector) const;\\n\\u00a0 \\n\\u00a0     void assemble_face_term(const FEFaceValuesBase<dim> &fe_v,\\n\\u00a0                             const FEFaceValuesBase<dim> &fe_v_neighbor,\\n\\u00a0                             FullMatrix<double>          &ui_vi_matrix,\\n\\u00a0                             FullMatrix<double>          &ue_vi_matrix,\\n\\u00a0                             FullMatrix<double>          &ui_ve_matrix,\\n\\u00a0                             FullMatrix<double>          &ue_ve_matrix) const;\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     const Beta<dim>           beta_function;\\n\\u00a0     const RHS<dim>            rhs_function;\\n\\u00a0     const BoundaryValues<dim> boundary_function;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFEFaceValuesBaseDefinition fe_values.h:202\\nFEFaceValuesDefinition fe_values.h:322\\nFEValuesDefinition fe_values.h:63\\nFullMatrixDefinition full_matrix.h:79\\nVectorDefinition vector.h:120\\nLikewise, the constructor of the class as well as the functions assembling the terms corresponding to cell interiors and boundary faces are unchanged from before. The function that assembles face terms between cells also did not change because all it does is operate on two objects of type FEFaceValuesBase (which is the base class of both FEFaceValues and FESubfaceValues). Where these objects come from, i.e. how they are initialized, is of no concern to this function: it simply assumes that the quadrature points on faces or subfaces represented by the two objects correspond to the same points in physical space.\\n\\u00a0   template <int dim>\\n\\u00a0   DGTransportEquation<dim>::DGTransportEquation()\\n\\u00a0     : beta_function()\\n\\u00a0     , rhs_function()\\n\\u00a0     , boundary_function()\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void DGTransportEquation<dim>::assemble_cell_term(\\n\\u00a0     const FEValues<dim> &fe_v,\\n\\u00a0     FullMatrix<double>  &ui_vi_matrix,\\n\\u00a0     Vector<double>      &cell_vector) const\\n\\u00a0   {\\n\\u00a0     const std::vector<double> &JxW = fe_v.get_JxW_values();\\n\\u00a0 \\n\\u00a0     std::vector<Point<dim>> beta(fe_v.n_quadrature_points);\\n\\u00a0     std::vector<double>     rhs(fe_v.n_quadrature_points);\\n\\u00a0 \\n\\u00a0     beta_function.value_list(fe_v.get_quadrature_points(), beta);\\n\\u00a0     rhs_function.value_list(fe_v.get_quadrature_points(), rhs);\\n\\u00a0 \\n\\u00a0     for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point)\\n\\u00a0       for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)\\n\\u00a0         {\\n\\u00a0           for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j)\\n\\u00a0             ui_vi_matrix(i, j) -= beta[point] * fe_v.shape_grad(i, point) *\\n\\u00a0                                   fe_v.shape_value(j, point) * JxW[point];\\n\\u00a0 \\n\\u00a0           cell_vector(i) +=\\n\\u00a0             rhs[point] * fe_v.shape_value(i, point) * JxW[point];\\n\\u00a0         }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void DGTransportEquation<dim>::assemble_boundary_term(\\n\\u00a0     const FEFaceValues<dim> &fe_v,\\n\\u00a0     FullMatrix<double>      &ui_vi_matrix,\\n\\u00a0     Vector<double>          &cell_vector) const\\n\\u00a0   {\\n\\u00a0     const std::vector<double>         &JxW     = fe_v.get_JxW_values();\\n\\u00a0     const std::vector<Tensor<1, dim>> &normals = fe_v.get_normal_vectors();\\n\\u00a0 \\n\\u00a0     std::vector<Point<dim>> beta(fe_v.n_quadrature_points);\\n\\u00a0     std::vector<double>     g(fe_v.n_quadrature_points);\\n\\u00a0 \\n\\u00a0     beta_function.value_list(fe_v.get_quadrature_points(), beta);\\n\\u00a0     boundary_function.value_list(fe_v.get_quadrature_points(), g);\\n\\u00a0 \\n\\u00a0     for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point)\\n\\u00a0       {\\n\\u00a0         const double beta_n = beta[point] * normals[point];\\n\\u00a0         if (beta_n > 0)\\n\\u00a0           for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)\\n\\u00a0             for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j)\\n\\u00a0               ui_vi_matrix(i, j) += beta_n * fe_v.shape_value(j, point) *\\n\\u00a0                                     fe_v.shape_value(i, point) * JxW[point];\\n\\u00a0         else\\n\\u00a0           for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)\\n\\u00a0             cell_vector(i) -=\\n\\u00a0               beta_n * g[point] * fe_v.shape_value(i, point) * JxW[point];\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void DGTransportEquation<dim>::assemble_face_term(\\n\\u00a0     const FEFaceValuesBase<dim> &fe_v,\\n\\u00a0     const FEFaceValuesBase<dim> &fe_v_neighbor,\\n\\u00a0     FullMatrix<double>          &ui_vi_matrix,\\n\\u00a0     FullMatrix<double>          &ue_vi_matrix,\\n\\u00a0     FullMatrix<double>          &ui_ve_matrix,\\n\\u00a0     FullMatrix<double>          &ue_ve_matrix) const\\n\\u00a0   {\\n\\u00a0     const std::vector<double>         &JxW     = fe_v.get_JxW_values();\\n\\u00a0     const std::vector<Tensor<1, dim>> &normals = fe_v.get_normal_vectors();\\n\\u00a0 \\n\\u00a0     std::vector<Point<dim>> beta(fe_v.n_quadrature_points);\\n\\u00a0 \\n\\u00a0     beta_function.value_list(fe_v.get_quadrature_points(), beta);\\n\\u00a0 \\n\\u00a0     for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point)\\n\\u00a0       {\\n\\u00a0         const double beta_n = beta[point] * normals[point];\\n\\u00a0         if (beta_n > 0)\\n\\u00a0           {\\n\\u00a0             for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)\\n\\u00a0               for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j)\\n\\u00a0                 ui_vi_matrix(i, j) += beta_n * fe_v.shape_value(j, point) *\\n\\u00a0                                       fe_v.shape_value(i, point) * JxW[point];\\n\\u00a0 \\n\\u00a0             for (unsigned int k = 0; k < fe_v_neighbor.dofs_per_cell; ++k)\\n\\u00a0               for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j)\\n\\u00a0                 ui_ve_matrix(k, j) -= beta_n * fe_v.shape_value(j, point) *\\n\\u00a0                                       fe_v_neighbor.shape_value(k, point) *\\n\\u00a0                                       JxW[point];\\n\\u00a0           }\\n\\u00a0         else\\n\\u00a0           {\\n\\u00a0             for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)\\n\\u00a0               for (unsigned int l = 0; l < fe_v_neighbor.dofs_per_cell; ++l)\\n\\u00a0                 ue_vi_matrix(i, l) += beta_n *\\n\\u00a0                                       fe_v_neighbor.shape_value(l, point) *\\n\\u00a0                                       fe_v.shape_value(i, point) * JxW[point];\\n\\u00a0 \\n\\u00a0             for (unsigned int k = 0; k < fe_v_neighbor.dofs_per_cell; ++k)\\n\\u00a0               for (unsigned int l = 0; l < fe_v_neighbor.dofs_per_cell; ++l)\\n\\u00a0                 ue_ve_matrix(k, l) -=\\n\\u00a0                   beta_n * fe_v_neighbor.shape_value(l, point) *\\n\\u00a0                   fe_v_neighbor.shape_value(k, point) * JxW[point];\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nOpenCASCADE::pointPoint< spacedim > point(const gp_Pnt &p, const double tolerance=1e-10)Definition utilities.cc:191\\nPhysics::Elasticity::Kinematics::lTensor< 2, dim, Number > l(const Tensor< 2, dim, Number > &F, const Tensor< 2, dim, Number > &dF_dt)\\n Class: DGMethod\\nThis declaration is much like that of step-12. However, we introduce a new routine (set_anisotropic_flags) and modify another one (refine_grid).\\n\\u00a0   template <int dim>\\n\\u00a0   class DGMethod\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     DGMethod(const bool anisotropic);\\n\\u00a0 \\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void setup_system();\\n\\u00a0     void assemble_system();\\n\\u00a0     void solve(Vector<double> &solution);\\n\\u00a0     void refine_grid();\\n\\u00a0     void set_anisotropic_flags();\\n\\u00a0     void output_results(const unsigned int cycle) const;\\n\\u00a0 \\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0     const MappingQ1<dim> mapping;\\nMappingQ1Definition mapping_q1.h:55\\nTriangulationDefinition tria.h:1323\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\nAgain we want to use DG elements of degree 1 (but this is only specified in the constructor). If you want to use a DG method of a different degree replace 1 in the constructor by the new degree.\\n\\u00a0     const unsigned int degree;\\n\\u00a0     const FE_DGQ<dim>  fe;\\n\\u00a0     DoFHandler<dim>    dof_handler;\\n\\u00a0 \\n\\u00a0     SparsityPattern      sparsity_pattern;\\n\\u00a0     SparseMatrix<double> system_matrix;\\nDoFHandlerDefinition dof_handler.h:317\\nFE_DGQDefinition fe_dgq.h:112\\nSparseMatrixDefinition sparse_matrix.h:520\\nSparsityPatternDefinition sparsity_pattern.h:343\\nThis is new, the threshold value used in the evaluation of the anisotropic jump indicator explained in the introduction. Its value is set to 3.0 in the constructor, but it can easily be changed to a different value greater than 1.\\n\\u00a0     const double anisotropic_threshold_ratio;\\nThis is a bool flag indicating whether anisotropic refinement shall be used or not. It is set by the constructor, which takes an argument of the same name.\\n\\u00a0     const bool anisotropic;\\n\\u00a0 \\n\\u00a0     const QGauss<dim>     quadrature;\\n\\u00a0     const QGauss<dim - 1> face_quadrature;\\n\\u00a0 \\n\\u00a0     Vector<double> solution2;\\n\\u00a0     Vector<double> right_hand_side;\\n\\u00a0 \\n\\u00a0     const DGTransportEquation<dim> dg;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   DGMethod<dim>::DGMethod(const bool anisotropic)\\n\\u00a0     : mapping()\\n\\u00a0     ,\\nQGaussDefinition quadrature_lib.h:40\\nChange here for DG methods of different degrees.\\n\\u00a0     degree(1)\\n\\u00a0     , fe(degree)\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0     , anisotropic_threshold_ratio(3.)\\n\\u00a0     , anisotropic(anisotropic)\\n\\u00a0     ,\\nAs beta is a linear function, we can choose the degree of the quadrature for which the resulting integration is correct. Thus, we choose to use degree+1 Gauss points, which enables us to integrate exactly polynomials of degree 2*degree+1, enough for all the integrals we will perform in this program.\\n\\u00a0     quadrature(degree + 1)\\n\\u00a0     , face_quadrature(degree + 1)\\n\\u00a0     , dg()\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void DGMethod<dim>::setup_system()\\n\\u00a0   {\\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0     sparsity_pattern.reinit(dof_handler.n_dofs(),\\n\\u00a0                             dof_handler.n_dofs(),\\n\\u00a0                             (GeometryInfo<dim>::faces_per_cell *\\n\\u00a0                                GeometryInfo<dim>::max_children_per_face +\\n\\u00a0                              1) *\\n\\u00a0                               fe.n_dofs_per_cell());\\n\\u00a0 \\n\\u00a0     DoFTools::make_flux_sparsity_pattern(dof_handler, sparsity_pattern);\\n\\u00a0 \\n\\u00a0     sparsity_pattern.compress();\\n\\u00a0 \\n\\u00a0     system_matrix.reinit(sparsity_pattern);\\n\\u00a0 \\n\\u00a0     solution2.reinit(dof_handler.n_dofs());\\n\\u00a0     right_hand_side.reinit(dof_handler.n_dofs());\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nDoFTools::make_flux_sparsity_patternvoid make_flux_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern)Definition dof_tools_sparsity.cc:697\\nGeometryInfoDefinition geometry_info.h:1964\\n Function: assemble_system\\nWe proceed with the assemble_system function that implements the DG discretization. This function does the same thing as the assemble_system function from step-12 (but without MeshWorker). The four cases considered for the neighbor-relations of a cell are the same as the isotropic case, namely a) cell is at the boundary, b) there are finer neighboring cells, c) the neighbor is neither coarser nor finer and d) the neighbor is coarser. However, the way in which we decide upon which case we have are modified in the way described in the introduction.\\n\\u00a0   template <int dim>\\n\\u00a0   void DGMethod<dim>::assemble_system()\\n\\u00a0   {\\n\\u00a0     const unsigned int dofs_per_cell = dof_handler.get_fe().n_dofs_per_cell();\\n\\u00a0     std::vector<types::global_dof_index> dofs(dofs_per_cell);\\n\\u00a0     std::vector<types::global_dof_index> dofs_neighbor(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     const UpdateFlags update_flags = update_values | update_gradients |\\n\\u00a0                                      update_quadrature_points |\\n\\u00a0                                      update_JxW_values;\\n\\u00a0 \\n\\u00a0     const UpdateFlags face_update_flags =\\n\\u00a0       update_values | update_quadrature_points | update_JxW_values |\\n\\u00a0       update_normal_vectors;\\n\\u00a0 \\n\\u00a0     const UpdateFlags neighbor_face_update_flags = update_values;\\n\\u00a0 \\n\\u00a0     FEValues<dim>        fe_v(mapping, fe, quadrature, update_flags);\\n\\u00a0     FEFaceValues<dim>    fe_v_face(mapping,\\n\\u00a0                                 fe,\\n\\u00a0                                 face_quadrature,\\n\\u00a0                                 face_update_flags);\\n\\u00a0     FESubfaceValues<dim> fe_v_subface(mapping,\\n\\u00a0                                       fe,\\n\\u00a0                                       face_quadrature,\\n\\u00a0                                       face_update_flags);\\n\\u00a0     FEFaceValues<dim>    fe_v_face_neighbor(mapping,\\n\\u00a0                                          fe,\\n\\u00a0                                          face_quadrature,\\n\\u00a0                                          neighbor_face_update_flags);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     FullMatrix<double> ui_vi_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0     FullMatrix<double> ue_vi_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0 \\n\\u00a0     FullMatrix<double> ui_ve_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0     FullMatrix<double> ue_ve_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0 \\n\\u00a0     Vector<double> cell_vector(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         ui_vi_matrix = 0;\\n\\u00a0         cell_vector  = 0;\\n\\u00a0 \\n\\u00a0         fe_v.reinit(cell);\\n\\u00a0 \\n\\u00a0         dg.assemble_cell_term(fe_v, ui_vi_matrix, cell_vector);\\n\\u00a0 \\n\\u00a0         cell->get_dof_indices(dofs);\\n\\u00a0 \\n\\u00a0         for (const auto face_no : cell->face_indices())\\n\\u00a0           {\\n\\u00a0             const auto face = cell->face(face_no);\\n\\u00a0 \\nFESubfaceValuesDefinition fe_values.h:488\\nUpdateFlagsUpdateFlagsDefinition fe_update_flags.h:64\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_normal_vectors@ update_normal_vectorsNormal vectors.Definition fe_update_flags.h:141\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nCase (a): The face is at the boundary.\\n\\u00a0             if (face->at_boundary())\\n\\u00a0               {\\n\\u00a0                 fe_v_face.reinit(cell, face_no);\\n\\u00a0 \\n\\u00a0                 dg.assemble_boundary_term(fe_v_face, ui_vi_matrix, cell_vector);\\n\\u00a0               }\\n\\u00a0             else\\n\\u00a0               {\\n\\u00a0                 Assert(cell->neighbor(face_no).state() == IteratorState::valid,\\n\\u00a0                        ExcInternalError());\\n\\u00a0                 const auto neighbor = cell->neighbor(face_no);\\n\\u00a0 \\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\nIteratorState::valid@ validIterator points to a valid object.Definition tria_iterator_base.h:37\\nCase (b): This is an internal face and the neighbor is refined (which we can test by asking whether the face of the current cell has children). In this case, we will need to integrate over the \\\"sub-faces\\\", i.e., the children of the face of the current cell.\\n(There is a slightly confusing corner case: If we are in 1d \\u2013 where admittedly the current program and its demonstration of anisotropic refinement is not particularly relevant \\u2013 then the faces between cells are always the same: they are just vertices. In other words, in 1d, we do not want to treat faces between cells of different level differently. The condition face->has_children() we check here ensures this: in 1d, this function always returns false, and consequently in 1d we will not ever go into this if branch. But we will have to come back to this corner case below in case (c).)\\n\\u00a0                 if (face->has_children())\\n\\u00a0                   {\\nWe need to know, which of the neighbors faces points in the direction of our cell. Using the neighbor_face_no function we get this information for both coarser and non-coarser neighbors.\\n\\u00a0                     const unsigned int neighbor2 =\\n\\u00a0                       cell->neighbor_face_no(face_no);\\n\\u00a0 \\nNow we loop over all subfaces, i.e. the children and possibly grandchildren of the current face.\\n\\u00a0                     for (unsigned int subface_no = 0;\\n\\u00a0                          subface_no < face->n_active_descendants();\\n\\u00a0                          ++subface_no)\\n\\u00a0                       {\\nTo get the cell behind the current subface we can use the neighbor_child_on_subface function. it takes care of all the complicated situations of anisotropic refinement and non-standard faces.\\n\\u00a0                         const auto neighbor_child =\\n\\u00a0                           cell->neighbor_child_on_subface(face_no, subface_no);\\n\\u00a0                         Assert(!neighbor_child->has_children(),\\n\\u00a0                                ExcInternalError());\\n\\u00a0 \\nThe remaining part of this case is unchanged.\\n\\u00a0                         ue_vi_matrix = 0;\\n\\u00a0                         ui_ve_matrix = 0;\\n\\u00a0                         ue_ve_matrix = 0;\\n\\u00a0 \\n\\u00a0                         fe_v_subface.reinit(cell, face_no, subface_no);\\n\\u00a0                         fe_v_face_neighbor.reinit(neighbor_child, neighbor2);\\n\\u00a0 \\n\\u00a0                         dg.assemble_face_term(fe_v_subface,\\n\\u00a0                                               fe_v_face_neighbor,\\n\\u00a0                                               ui_vi_matrix,\\n\\u00a0                                               ue_vi_matrix,\\n\\u00a0                                               ui_ve_matrix,\\n\\u00a0                                               ue_ve_matrix);\\n\\u00a0 \\n\\u00a0                         neighbor_child->get_dof_indices(dofs_neighbor);\\n\\u00a0 \\n\\u00a0                         for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0                           for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0                             {\\n\\u00a0                               system_matrix.add(dofs[i],\\n\\u00a0                                                 dofs_neighbor[j],\\n\\u00a0                                                 ue_vi_matrix(i, j));\\n\\u00a0                               system_matrix.add(dofs_neighbor[i],\\n\\u00a0                                                 dofs[j],\\n\\u00a0                                                 ui_ve_matrix(i, j));\\n\\u00a0                               system_matrix.add(dofs_neighbor[i],\\n\\u00a0                                                 dofs_neighbor[j],\\n\\u00a0                                                 ue_ve_matrix(i, j));\\n\\u00a0                             }\\n\\u00a0                       }\\n\\u00a0                   }\\n\\u00a0                 else\\n\\u00a0                   {\\nCase (c). We get here if this is an internal face and if the neighbor is not further refined (or, as mentioned above, we are in 1d in which case we get here for every internal face). We then need to decide whether we want to integrate over the current face. If the neighbor is in fact coarser, then we ignore the face and instead handle it when we visit the neighboring cell and look at the current face (except in 1d, where as mentioned above this is not happening):\\n\\u00a0                     if (dim > 1 && cell->neighbor_is_coarser(face_no))\\n\\u00a0                       continue;\\n\\u00a0 \\nOn the other hand, if the neighbor is more refined, then we have already handled the face in case (b) above (except in 1d). So for 2d and 3d, we just have to decide whether we want to handle a face between cells at the same level from the current side or from the neighboring side. We do this by introducing a tie-breaker: We'll just take the cell with the smaller index (within the current refinement level). In 1d, we take either the coarser cell, or if they are on the same level, the one with the smaller index within that level. This leads to a complicated condition that, hopefully, makes sense given the description above:\\n\\u00a0                     if (((dim > 1) && (cell->index() < neighbor->index())) ||\\n\\u00a0                         ((dim == 1) && ((cell->level() < neighbor->level()) ||\\n\\u00a0                                         ((cell->level() == neighbor->level()) &&\\n\\u00a0                                          (cell->index() < neighbor->index())))))\\n\\u00a0                       {\\nHere we know, that the neighbor is not coarser so we can use the usual neighbor_of_neighbor function. However, we could also use the more general neighbor_face_no function.\\n\\u00a0                         const unsigned int neighbor2 =\\n\\u00a0                           cell->neighbor_of_neighbor(face_no);\\n\\u00a0 \\n\\u00a0                         ue_vi_matrix = 0;\\n\\u00a0                         ui_ve_matrix = 0;\\n\\u00a0                         ue_ve_matrix = 0;\\n\\u00a0 \\n\\u00a0                         fe_v_face.reinit(cell, face_no);\\n\\u00a0                         fe_v_face_neighbor.reinit(neighbor, neighbor2);\\n\\u00a0 \\n\\u00a0                         dg.assemble_face_term(fe_v_face,\\n\\u00a0                                               fe_v_face_neighbor,\\n\\u00a0                                               ui_vi_matrix,\\n\\u00a0                                               ue_vi_matrix,\\n\\u00a0                                               ui_ve_matrix,\\n\\u00a0                                               ue_ve_matrix);\\n\\u00a0 \\n\\u00a0                         neighbor->get_dof_indices(dofs_neighbor);\\n\\u00a0 \\n\\u00a0                         for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0                           for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0                             {\\n\\u00a0                               system_matrix.add(dofs[i],\\n\\u00a0                                                 dofs_neighbor[j],\\n\\u00a0                                                 ue_vi_matrix(i, j));\\n\\u00a0                               system_matrix.add(dofs_neighbor[i],\\n\\u00a0                                                 dofs[j],\\n\\u00a0                                                 ui_ve_matrix(i, j));\\n\\u00a0                               system_matrix.add(dofs_neighbor[i],\\n\\u00a0                                                 dofs_neighbor[j],\\n\\u00a0                                                 ue_ve_matrix(i, j));\\n\\u00a0                             }\\n\\u00a0                       }\\n\\u00a0 \\nWe do not need to consider a case (d), as those faces are treated 'from the other side within case (b).\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0           for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0             system_matrix.add(dofs[i], dofs[j], ui_vi_matrix(i, j));\\n\\u00a0 \\n\\u00a0         for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0           right_hand_side(dofs[i]) += cell_vector(i);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n Solver\\nFor this simple problem we use the simple Richardson iteration again. The solver is completely unaffected by our anisotropic changes.\\n\\u00a0   template <int dim>\\n\\u00a0   void DGMethod<dim>::solve(Vector<double> &solution)\\n\\u00a0   {\\n\\u00a0     SolverControl                    solver_control(1000, 1e-12, false, false);\\n\\u00a0     SolverRichardson<Vector<double>> solver(solver_control);\\n\\u00a0 \\n\\u00a0     PreconditionBlockSSOR<SparseMatrix<double>> preconditioner;\\n\\u00a0 \\n\\u00a0     preconditioner.initialize(system_matrix, fe.n_dofs_per_cell());\\n\\u00a0 \\n\\u00a0     solver.solve(system_matrix, solution, right_hand_side, preconditioner);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nPreconditionBlockSSORDefinition precondition_block.h:821\\nPreconditionBlock::initializevoid initialize(const MatrixType &A, const AdditionalData parameters)\\nSolverControlDefinition solver_control.h:67\\nSolverRichardsonDefinition solver_richardson.h:66\\n Refinement\\nWe refine the grid according to the same simple refinement criterion used in step-12, namely an approximation to the gradient of the solution.\\n\\u00a0   template <int dim>\\n\\u00a0   void DGMethod<dim>::refine_grid()\\n\\u00a0   {\\n\\u00a0     Vector<float> gradient_indicator(triangulation.n_active_cells());\\n\\u00a0 \\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nWe approximate the gradient,\\n\\u00a0     DerivativeApproximation::approximate_gradient(mapping,\\n\\u00a0                                                   dof_handler,\\n\\u00a0                                                   solution2,\\n\\u00a0                                                   gradient_indicator);\\n\\u00a0 \\nDerivativeApproximation::approximate_gradientvoid approximate_gradient(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const InputVector &solution, Vector< float > &derivative_norm, const unsigned int component=0)Definition derivative_approximation.cc:1016\\nand scale it to obtain an error indicator.\\n\\u00a0     for (const auto &cell : triangulation.active_cell_iterators())\\n\\u00a0       gradient_indicator[cell->active_cell_index()] *=\\n\\u00a0         std::pow(cell->diameter(), 1 + 1.0 * dim / 2);\\nstdSTL namespace.\\nThen we use this indicator to flag the 30 percent of the cells with highest error indicator to be refined.\\n\\u00a0     GridRefinement::refine_and_coarsen_fixed_number(triangulation,\\n\\u00a0                                                     gradient_indicator,\\n\\u00a0                                                     0.3,\\n\\u00a0                                                     0.1);\\nGridRefinement::refine_and_coarsen_fixed_numbervoid refine_and_coarsen_fixed_number(Triangulation< dim, spacedim > &triangulation, const Vector< Number > &criteria, const double top_fraction_of_cells, const double bottom_fraction_of_cells, const unsigned int max_n_cells=std::numeric_limits< unsigned int >::max())Definition grid_refinement.cc:318\\nNow the refinement flags are set for those cells with a large error indicator. If nothing is done to change this, those cells will be refined isotropically. If the anisotropic flag given to this function is set, we now call the set_anisotropic_flags() function, which uses the jump indicator to reset some of the refinement flags to anisotropic refinement.\\n\\u00a0     if (anisotropic)\\n\\u00a0       set_anisotropic_flags();\\nNow execute the refinement considering anisotropic as well as isotropic refinement flags.\\n\\u00a0     triangulation.execute_coarsening_and_refinement();\\n\\u00a0   }\\n\\u00a0 \\nparallel::distributed::Triangulation::execute_coarsening_and_refinementvirtual void execute_coarsening_and_refinement() overrideDefinition tria.cc:3320\\nOnce an error indicator has been evaluated and the cells with largest error are flagged for refinement we want to loop over the flagged cells again to decide whether they need isotropic refinement or whether anisotropic refinement is more appropriate. This is the anisotropic jump indicator explained in the introduction.\\n\\u00a0   template <int dim>\\n\\u00a0   void DGMethod<dim>::set_anisotropic_flags()\\n\\u00a0   {\\nWe want to evaluate the jump over faces of the flagged cells, so we need some objects to evaluate values of the solution on faces.\\n\\u00a0     UpdateFlags face_update_flags =\\n\\u00a0       UpdateFlags(update_values | update_JxW_values);\\n\\u00a0 \\n\\u00a0     FEFaceValues<dim>    fe_v_face(mapping,\\n\\u00a0                                 fe,\\n\\u00a0                                 face_quadrature,\\n\\u00a0                                 face_update_flags);\\n\\u00a0     FESubfaceValues<dim> fe_v_subface(mapping,\\n\\u00a0                                       fe,\\n\\u00a0                                       face_quadrature,\\n\\u00a0                                       face_update_flags);\\n\\u00a0     FEFaceValues<dim>    fe_v_face_neighbor(mapping,\\n\\u00a0                                          fe,\\n\\u00a0                                          face_quadrature,\\n\\u00a0                                          update_values);\\n\\u00a0 \\nNow we need to loop over all active cells.\\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\nWe only need to consider cells which are flagged for refinement.\\n\\u00a0       if (cell->refine_flag_set())\\n\\u00a0         {\\n\\u00a0           std::array<double, dim> jump_in_coordinate_direction;\\n\\u00a0           std::array<double, dim> face_area_in_coordinate_direction;\\n\\u00a0 \\n\\u00a0           for (const auto face_no : cell->face_indices())\\n\\u00a0             {\\n\\u00a0               const auto face = cell->face(face_no);\\n\\u00a0 \\n\\u00a0               if (!face->at_boundary())\\n\\u00a0                 {\\n\\u00a0                   Assert(cell->neighbor(face_no).state() ==\\n\\u00a0                            IteratorState::valid,\\n\\u00a0                          ExcInternalError());\\n\\u00a0                   const auto neighbor = cell->neighbor(face_no);\\n\\u00a0 \\n\\u00a0                   std::vector<double> u(fe_v_face.n_quadrature_points);\\n\\u00a0                   std::vector<double> u_neighbor(fe_v_face.n_quadrature_points);\\n\\u00a0 \\nThe four cases of different neighbor relations seen in the assembly routines are repeated much in the same way here.\\n\\u00a0                   if (face->has_children())\\n\\u00a0                     {\\nThe neighbor is refined. First we store the information, which of the neighbor's faces points in the direction of our current cell. This property is inherited to the children.\\n\\u00a0                       unsigned int neighbor2 = cell->neighbor_face_no(face_no);\\nNow we loop over all subfaces,\\n\\u00a0                       for (unsigned int subface_no = 0;\\n\\u00a0                            subface_no < face->n_active_descendants();\\n\\u00a0                            ++subface_no)\\n\\u00a0                         {\\nget an iterator pointing to the cell behind the present subface...\\n\\u00a0                           const auto neighbor_child =\\n\\u00a0                             cell->neighbor_child_on_subface(face_no,\\n\\u00a0                                                             subface_no);\\n\\u00a0                           Assert(!neighbor_child->has_children(),\\n\\u00a0                                  ExcInternalError());\\n... and reinit the respective FEFaceValues and FESubFaceValues objects.\\n\\u00a0                           fe_v_subface.reinit(cell, face_no, subface_no);\\n\\u00a0                           fe_v_face_neighbor.reinit(neighbor_child, neighbor2);\\nWe obtain the function values\\n\\u00a0                           fe_v_subface.get_function_values(solution2, u);\\n\\u00a0                           fe_v_face_neighbor.get_function_values(solution2,\\n\\u00a0                                                                  u_neighbor);\\nas well as the quadrature weights, multiplied by the Jacobian determinant.\\n\\u00a0                           const std::vector<double> &JxW =\\n\\u00a0                             fe_v_subface.get_JxW_values();\\nNow we loop over all quadrature points\\n\\u00a0                           for (unsigned int x = 0;\\n\\u00a0                                x < fe_v_subface.n_quadrature_points;\\n\\u00a0                                ++x)\\n\\u00a0                             {\\nand integrate the absolute value of the jump of the solution, i.e. the absolute value of the difference between the function value seen from the current cell and the neighboring cell, respectively. We know, that the first two faces are orthogonal to the first coordinate direction on the unit cell, the second two faces are orthogonal to the second coordinate direction and so on, so we accumulate these values into vectors with dim components.\\n\\u00a0                               jump_in_coordinate_direction[face_no / 2] +=\\n\\u00a0                                 std::abs(u[x] - u_neighbor[x]) * JxW[x];\\nstd::abs::VectorizedArray< Number, width > abs(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6927\\nWe also sum up the scaled weights to obtain the measure of the face.\\n\\u00a0                               face_area_in_coordinate_direction[face_no / 2] +=\\n\\u00a0                                 JxW[x];\\n\\u00a0                             }\\n\\u00a0                         }\\n\\u00a0                     }\\n\\u00a0                   else\\n\\u00a0                     {\\n\\u00a0                       if (!cell->neighbor_is_coarser(face_no))\\n\\u00a0                         {\\nOur current cell and the neighbor have the same refinement along the face under consideration. Apart from that, we do much the same as with one of the subcells in the above case.\\n\\u00a0                           unsigned int neighbor2 =\\n\\u00a0                             cell->neighbor_of_neighbor(face_no);\\n\\u00a0 \\n\\u00a0                           fe_v_face.reinit(cell, face_no);\\n\\u00a0                           fe_v_face_neighbor.reinit(neighbor, neighbor2);\\n\\u00a0 \\n\\u00a0                           fe_v_face.get_function_values(solution2, u);\\n\\u00a0                           fe_v_face_neighbor.get_function_values(solution2,\\n\\u00a0                                                                  u_neighbor);\\n\\u00a0 \\n\\u00a0                           const std::vector<double> &JxW =\\n\\u00a0                             fe_v_face.get_JxW_values();\\n\\u00a0 \\n\\u00a0                           for (unsigned int x = 0;\\n\\u00a0                                x < fe_v_face.n_quadrature_points;\\n\\u00a0                                ++x)\\n\\u00a0                             {\\n\\u00a0                               jump_in_coordinate_direction[face_no / 2] +=\\n\\u00a0                                 std::abs(u[x] - u_neighbor[x]) * JxW[x];\\n\\u00a0                               face_area_in_coordinate_direction[face_no / 2] +=\\n\\u00a0                                 JxW[x];\\n\\u00a0                             }\\n\\u00a0                         }\\n\\u00a0                       else // i.e. neighbor is coarser than cell\\n\\u00a0                         {\\nNow the neighbor is actually coarser. This case is new, in that it did not occur in the assembly routine. Here, we have to consider it, but this is not overly complicated. We simply use the neighbor_of_coarser_neighbor function, which again takes care of anisotropic refinement and non-standard face orientation by itself.\\n\\u00a0                           std::pair<unsigned int, unsigned int>\\n\\u00a0                             neighbor_face_subface =\\n\\u00a0                               cell->neighbor_of_coarser_neighbor(face_no);\\n\\u00a0                           Assert(neighbor_face_subface.first < cell->n_faces(),\\n\\u00a0                                  ExcInternalError());\\n\\u00a0                           Assert(neighbor_face_subface.second <\\n\\u00a0                                    neighbor->face(neighbor_face_subface.first)\\n\\u00a0                                      ->n_active_descendants(),\\n\\u00a0                                  ExcInternalError());\\n\\u00a0                           Assert(neighbor->neighbor_child_on_subface(\\n\\u00a0                                    neighbor_face_subface.first,\\n\\u00a0                                    neighbor_face_subface.second) == cell,\\n\\u00a0                                  ExcInternalError());\\n\\u00a0 \\n\\u00a0                           fe_v_face.reinit(cell, face_no);\\n\\u00a0                           fe_v_subface.reinit(neighbor,\\n\\u00a0                                               neighbor_face_subface.first,\\n\\u00a0                                               neighbor_face_subface.second);\\n\\u00a0 \\n\\u00a0                           fe_v_face.get_function_values(solution2, u);\\n\\u00a0                           fe_v_subface.get_function_values(solution2,\\n\\u00a0                                                            u_neighbor);\\n\\u00a0 \\n\\u00a0                           const std::vector<double> &JxW =\\n\\u00a0                             fe_v_face.get_JxW_values();\\n\\u00a0 \\n\\u00a0                           for (unsigned int x = 0;\\n\\u00a0                                x < fe_v_face.n_quadrature_points;\\n\\u00a0                                ++x)\\n\\u00a0                             {\\n\\u00a0                               jump_in_coordinate_direction[face_no / 2] +=\\n\\u00a0                                 std::abs(u[x] - u_neighbor[x]) * JxW[x];\\n\\u00a0                               face_area_in_coordinate_direction[face_no / 2] +=\\n\\u00a0                                 JxW[x];\\n\\u00a0                             }\\n\\u00a0                         }\\n\\u00a0                     }\\n\\u00a0                 }\\n\\u00a0             }\\nNow we analyze the size of the mean jumps, which we get dividing the jumps by the measure of the respective faces.\\n\\u00a0           std::array<double, dim> average_jumps;\\n\\u00a0           double                  sum_of_average_jumps = 0.;\\n\\u00a0           for (unsigned int i = 0; i < dim; ++i)\\n\\u00a0             {\\n\\u00a0               average_jumps[i] = jump_in_coordinate_direction[i] /\\n\\u00a0                                  face_area_in_coordinate_direction[i];\\n\\u00a0               sum_of_average_jumps += average_jumps[i];\\n\\u00a0             }\\n\\u00a0 \\nNow we loop over the dim coordinate directions of the unit cell and compare the average jump over the faces orthogonal to that direction with the average jumps over faces orthogonal to the remaining direction(s). If the first is larger than the latter by a given factor, we refine only along hat axis. Otherwise we leave the refinement flag unchanged, resulting in isotropic refinement.\\n\\u00a0           for (unsigned int i = 0; i < dim; ++i)\\n\\u00a0             if (average_jumps[i] > anisotropic_threshold_ratio *\\n\\u00a0                                      (sum_of_average_jumps - average_jumps[i]))\\n\\u00a0               cell->set_refine_flag(RefinementCase<dim>::cut_axis(i));\\n\\u00a0         }\\n\\u00a0   }\\n\\u00a0 \\n The Rest\\nThe remaining part of the program very much follows the scheme of previous tutorial programs. We output the mesh in VTU format (just as we did in step-1, for example), and the visualization output in VTU format as we almost always do.\\n\\u00a0   template <int dim>\\n\\u00a0   void DGMethod<dim>::output_results(const unsigned int cycle) const\\n\\u00a0   {\\n\\u00a0     std::string refine_type;\\n\\u00a0     if (anisotropic)\\n\\u00a0       refine_type = \\\".aniso\\\";\\n\\u00a0     else\\n\\u00a0       refine_type = \\\".iso\\\";\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       const std::string filename =\\n\\u00a0         \\\"grid-\\\" + std::to_string(cycle) + refine_type + \\\".svg\\\";\\n\\u00a0       std::cout << \\\"   Writing grid to <\\\" << filename << \\\">...\\\" << std::endl;\\n\\u00a0       std::ofstream svg_output(filename);\\n\\u00a0 \\n\\u00a0       GridOut grid_out;\\n\\u00a0       grid_out.write_svg(triangulation, svg_output);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       const std::string filename =\\n\\u00a0         \\\"sol-\\\" + std::to_string(cycle) + refine_type + \\\".vtu\\\";\\n\\u00a0       std::cout << \\\"   Writing solution to <\\\" << filename << \\\">...\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::ofstream gnuplot_output(filename);\\n\\u00a0 \\n\\u00a0       DataOut<dim> data_out;\\n\\u00a0       data_out.attach_dof_handler(dof_handler);\\n\\u00a0       data_out.add_data_vector(solution2, \\\"u\\\");\\n\\u00a0 \\n\\u00a0       data_out.build_patches(degree);\\n\\u00a0 \\n\\u00a0       data_out.write_vtu(gnuplot_output);\\n\\u00a0     }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void DGMethod<dim>::run()\\n\\u00a0   {\\n\\u00a0     for (unsigned int cycle = 0; cycle < 6; ++cycle)\\n\\u00a0       {\\n\\u00a0         std::cout << \\\"Cycle \\\" << cycle << ':' << std::endl;\\n\\u00a0 \\n\\u00a0         if (cycle == 0)\\n\\u00a0           {\\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nGridOutDefinition grid_out.h:993\\nGridOut::write_svgvoid write_svg(const Triangulation< 2, 2 > &tria, std::ostream &out) constDefinition grid_out.cc:1702\\nCreate the rectangular domain.\\n\\u00a0             Point<dim> p1, p2;\\n\\u00a0             p1[0] = -1.;\\n\\u00a0             for (unsigned int i = 0; i < dim; ++i)\\n\\u00a0               p2[i] = 1.;\\nAdjust the number of cells in different directions to obtain completely isotropic cells for the original mesh.\\n\\u00a0             std::vector<unsigned int> repetitions(dim, 1);\\n\\u00a0             repetitions[0] = 2;\\n\\u00a0             GridGenerator::subdivided_hyper_rectangle(triangulation,\\n\\u00a0                                                       repetitions,\\n\\u00a0                                                       p1,\\n\\u00a0                                                       p2);\\n\\u00a0 \\n\\u00a0             triangulation.refine_global(5 - dim);\\n\\u00a0           }\\n\\u00a0         else\\n\\u00a0           refine_grid();\\n\\u00a0 \\n\\u00a0 \\n\\u00a0         std::cout << \\\"   Number of active cells:       \\\"\\n\\u00a0                   << triangulation.n_active_cells() << std::endl;\\n\\u00a0 \\n\\u00a0         setup_system();\\n\\u00a0 \\n\\u00a0         std::cout << \\\"   Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n\\u00a0                   << std::endl;\\n\\u00a0 \\n\\u00a0         Timer assemble_timer;\\n\\u00a0         assemble_system();\\n\\u00a0         std::cout << \\\"   Time of assemble_system: \\\" << assemble_timer.cpu_time()\\n\\u00a0                   << std::endl;\\n\\u00a0         solve(solution2);\\n\\u00a0 \\n\\u00a0         output_results(cycle);\\n\\u00a0 \\n\\u00a0         std::cout << std::endl;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 } // namespace Step30\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       using namespace Step30;\\n\\u00a0 \\nTimerDefinition timer.h:117\\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nGridGenerator::subdivided_hyper_rectanglevoid subdivided_hyper_rectangle(Triangulation< dim, spacedim > &tria, const std::vector< unsigned int > &repetitions, const Point< dim > &p1, const Point< dim > &p2, const bool colorize=false)\\nIf you want to run the program in 3d, simply change the following line to const unsigned int dim = 3;.\\n\\u00a0       const unsigned int dim = 2;\\n\\u00a0 \\n\\u00a0       {\\nFirst, we perform a run with isotropic refinement.\\n\\u00a0         std::cout << \\\"Performing a \\\" << dim\\n\\u00a0                   << \\\"D run with isotropic refinement...\\\" << std::endl\\n\\u00a0                   << \\\"------------------------------------------------\\\"\\n\\u00a0                   << std::endl;\\n\\u00a0         DGMethod<dim> dgmethod_iso(false);\\n\\u00a0         dgmethod_iso.run();\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0       {\\nNow we do a second run, this time with anisotropic refinement.\\n\\u00a0         std::cout << std::endl\\n\\u00a0                   << \\\"Performing a \\\" << dim\\n\\u00a0                   << \\\"D run with anisotropic refinement...\\\" << std::endl\\n\\u00a0                   << \\\"--------------------------------------------------\\\"\\n\\u00a0                   << std::endl;\\n\\u00a0         DGMethod<dim> dgmethod_aniso(true);\\n\\u00a0         dgmethod_aniso.run();\\n\\u00a0       }\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nThe output of this program consist of the console output, the SVG files containing the grids, and the solutions given in VTU format. Performing a 2D run with isotropic refinement...\\n------------------------------------------------\\nCycle 0:\\n   Number of active cells:       128\\n   Number of degrees of freedom: 512\\n   Time of assemble_system: 0.092049\\n   Writing grid to <grid-0.iso.svg>...\\n   Writing solution to <sol-0.iso.vtu>...\\n \\nCycle 1:\\n   Number of active cells:       239\\n   Number of degrees of freedom: 956\\n   Time of assemble_system: 0.109519\\n   Writing grid to <grid-1.iso.svg>...\\n   Writing solution to <sol-1.iso.vtu>...\\n \\nCycle 2:\\n   Number of active cells:       491\\n   Number of degrees of freedom: 1964\\n   Time of assemble_system: 0.08303\\n   Writing grid to <grid-2.iso.svg>...\\n   Writing solution to <sol-2.iso.vtu>...\\n \\nCycle 3:\\n   Number of active cells:       1031\\n   Number of degrees of freedom: 4124\\n   Time of assemble_system: 0.278987\\n   Writing grid to <grid-3.iso.svg>...\\n   Writing solution to <sol-3.iso.vtu>...\\n \\nCycle 4:\\n   Number of active cells:       2027\\n   Number of degrees of freedom: 8108\\n   Time of assemble_system: 0.305869\\n   Writing grid to <grid-4.iso.svg>...\\n   Writing solution to <sol-4.iso.vtu>...\\n \\nCycle 5:\\n   Number of active cells:       4019\\n   Number of degrees of freedom: 16076\\n   Time of assemble_system: 0.47616\\n   Writing grid to <grid-5.iso.svg>...\\n   Writing solution to <sol-5.iso.vtu>...\\n \\n \\nPerforming a 2D run with anisotropic refinement...\\n--------------------------------------------------\\nCycle 0:\\n   Number of active cells:       128\\n   Number of degrees of freedom: 512\\n   Time of assemble_system: 0.052866\\n   Writing grid to <grid-0.aniso.svg>...\\n   Writing solution to <sol-0.aniso.vtu>...\\n \\nCycle 1:\\n   Number of active cells:       171\\n   Number of degrees of freedom: 684\\n   Time of assemble_system: 0.050917\\n   Writing grid to <grid-1.aniso.svg>...\\n   Writing solution to <sol-1.aniso.vtu>...\\n \\nCycle 2:\\n   Number of active cells:       255\\n   Number of degrees of freedom: 1020\\n   Time of assemble_system: 0.064132\\n   Writing grid to <grid-2.aniso.svg>...\\n   Writing solution to <sol-2.aniso.vtu>...\\n \\nCycle 3:\\n   Number of active cells:       394\\n   Number of degrees of freedom: 1576\\n   Time of assemble_system: 0.119849\\n   Writing grid to <grid-3.aniso.svg>...\\n   Writing solution to <sol-3.aniso.vtu>...\\n \\nCycle 4:\\n   Number of active cells:       648\\n   Number of degrees of freedom: 2592\\n   Time of assemble_system: 0.218244\\n   Writing grid to <grid-4.aniso.svg>...\\n   Writing solution to <sol-4.aniso.vtu>...\\n \\nCycle 5:\\n   Number of active cells:       1030\\n   Number of degrees of freedom: 4120\\n   Time of assemble_system: 0.128121\\n   Writing grid to <grid-5.aniso.svg>...\\n   Writing solution to <sol-5.aniso.vtu>...\\nThis text output shows the reduction in the number of cells which results from the successive application of anisotropic refinement. After the last refinement step the savings have accumulated so much that almost four times as many cells and thus degrees of freedom are needed in the isotropic case. The time needed for assembly scales with a similar factor.\\nThe first interesting part is of course to see how the meshes look like. On the left are the isotropically refined ones, on the right the anisotropic ones (colors indicate the refinement level of cells):\\n\\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\nThe other interesting thing is, of course, to see the solution on these two sequences of meshes. Here they are, on the refinement cycles 1 and 4, clearly showing that the solution is indeed composed of discontinuous piecewise polynomials:\\n\\n\\n  \\n\\n  \\n\\nWe see, that the solution on the anisotropically refined mesh is very similar to the solution obtained on the isotropically refined mesh. Thus the anisotropic indicator seems to effectively select the appropriate cells for anisotropic refinement.\\nThe pictures also explain why the mesh is refined as it is. In the whole left part of the domain refinement is only performed along the \\\\(y\\\\)-axis of cells. In the right part of the domain the refinement is dominated by isotropic refinement, as the anisotropic feature of the solution - the jump from one to zero - is not well aligned with the mesh where the advection direction takes a turn. However, at the bottom and closest (to the observer) parts of the quarter circle this jumps again becomes more and more aligned with the mesh and the refinement algorithm reacts by creating anisotropic cells of increasing aspect ratio.\\nIt might seem that the necessary alignment of anisotropic features and the coarse mesh can decrease performance significantly for real world problems. That is not wrong in general: If one were, for example, to apply anisotropic refinement to problems in which shocks appear (e.g., the equations solved in step-69), then it many cases the shock is not aligned with the mesh and anisotropic refinement will help little unless one also introduces techniques to move the mesh in alignment with the shocks. On the other hand, many steep features of solutions are due to boundary layers. In those cases, the mesh is already aligned with the anisotropic features because it is of course aligned with the boundary itself, and anisotropic refinement will almost always increase the efficiency of computations on adapted grids for these cases.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2008 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Author: Tobias Leicht, 2007\\n */\\n \\n \\n#include <deal.II/base/function.h>\\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/timer.h>\\n#include <deal.II/lac/precondition_block.h>\\n#include <deal.II/lac/solver_richardson.h>\\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/lac/vector.h>\\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_out.h>\\n#include <deal.II/grid/grid_refinement.h>\\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_tools.h>\\n#include <deal.II/fe/fe_values.h>\\n#include <deal.II/fe/mapping_q1.h>\\n#include <deal.II/fe/fe_dgq.h>\\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/derivative_approximation.h>\\n \\n#include <array>\\n#include <iostream>\\n#include <fstream>\\n \\nnamespace Step30\\n{\\n using namespace dealii;\\n \\n template <int dim>\\n class RHS : public Function<dim>\\n  {\\n public:\\n virtual void value_list(const std::vector<Point<dim>> &points,\\n                            std::vector<double>           &values,\\n const unsigned int /*component*/ = 0) const override\\n {\\n      (void)points;\\n AssertDimension(values.size(), points.size());\\n \\n      std::fill(values.begin(), values.end(), 0.);\\n    }\\n  };\\n \\n \\n template <int dim>\\n class BoundaryValues : public Function<dim>\\n  {\\n public:\\n virtual void value_list(const std::vector<Point<dim>> &points,\\n                            std::vector<double>           &values,\\n const unsigned int /*component*/ = 0) const override\\n {\\n AssertDimension(values.size(), points.size());\\n \\n for (unsigned int i = 0; i < values.size(); ++i)\\n        {\\n if (points[i][0] < 0.5)\\n            values[i] = 1.;\\n else\\n            values[i] = 0.;\\n        }\\n    }\\n  };\\n \\n \\n template <int dim>\\n class Beta\\n  {\\n public:\\n void value_list(const std::vector<Point<dim>> &points,\\n                    std::vector<Point<dim>>       &values) const\\n {\\n AssertDimension(values.size(), points.size());\\n \\n for (unsigned int i = 0; i < points.size(); ++i)\\n        {\\n if (points[i][0] > 0)\\n            {\\n              values[i][0] = -points[i][1];\\n              values[i][1] = points[i][0];\\n            }\\n else\\n            {\\n              values[i]    = Point<dim>();\\n              values[i][0] = -points[i][1];\\n            }\\n        }\\n    }\\n  };\\n \\n \\n \\n template <int dim>\\n class DGTransportEquation\\n  {\\n public:\\n    DGTransportEquation();\\n \\n void assemble_cell_term(const FEValues<dim> &fe_v,\\n FullMatrix<double>  &ui_vi_matrix,\\n Vector<double>      &cell_vector) const;\\n \\n void assemble_boundary_term(const FEFaceValues<dim> &fe_v,\\n FullMatrix<double>      &ui_vi_matrix,\\n Vector<double>          &cell_vector) const;\\n \\n void assemble_face_term(const FEFaceValuesBase<dim> &fe_v,\\n const FEFaceValuesBase<dim> &fe_v_neighbor,\\n FullMatrix<double>          &ui_vi_matrix,\\n FullMatrix<double>          &ue_vi_matrix,\\n FullMatrix<double>          &ui_ve_matrix,\\n FullMatrix<double>          &ue_ve_matrix) const;\\n \\n private:\\n const Beta<dim>           beta_function;\\n const RHS<dim>            rhs_function;\\n const BoundaryValues<dim> boundary_function;\\n  };\\n \\n \\n \\n template <int dim>\\n  DGTransportEquation<dim>::DGTransportEquation()\\n    : beta_function()\\n    , rhs_function()\\n    , boundary_function()\\n  {}\\n \\n \\n \\n template <int dim>\\n void DGTransportEquation<dim>::assemble_cell_term(\\n const FEValues<dim> &fe_v,\\n FullMatrix<double>  &ui_vi_matrix,\\n Vector<double>      &cell_vector) const\\n {\\n const std::vector<double> &JxW = fe_v.get_JxW_values();\\n \\n    std::vector<Point<dim>> beta(fe_v.n_quadrature_points);\\n    std::vector<double>     rhs(fe_v.n_quadrature_points);\\n \\n    beta_function.value_list(fe_v.get_quadrature_points(), beta);\\n    rhs_function.value_list(fe_v.get_quadrature_points(), rhs);\\n \\n for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point)\\n for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)\\n        {\\n for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j)\\n            ui_vi_matrix(i, j) -= beta[point] * fe_v.shape_grad(i, point) *\\n                                  fe_v.shape_value(j, point) * JxW[point];\\n \\n          cell_vector(i) +=\\n            rhs[point] * fe_v.shape_value(i, point) * JxW[point];\\n        }\\n  }\\n \\n \\n template <int dim>\\n void DGTransportEquation<dim>::assemble_boundary_term(\\n const FEFaceValues<dim> &fe_v,\\n FullMatrix<double>      &ui_vi_matrix,\\n Vector<double>          &cell_vector) const\\n {\\n const std::vector<double>         &JxW     = fe_v.get_JxW_values();\\n const std::vector<Tensor<1, dim>> &normals = fe_v.get_normal_vectors();\\n \\n    std::vector<Point<dim>> beta(fe_v.n_quadrature_points);\\n    std::vector<double>     g(fe_v.n_quadrature_points);\\n \\n    beta_function.value_list(fe_v.get_quadrature_points(), beta);\\n    boundary_function.value_list(fe_v.get_quadrature_points(), g);\\n \\n for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point)\\n      {\\n const double beta_n = beta[point] * normals[point];\\n if (beta_n > 0)\\n for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)\\n for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j)\\n              ui_vi_matrix(i, j) += beta_n * fe_v.shape_value(j, point) *\\n                                    fe_v.shape_value(i, point) * JxW[point];\\n else\\n for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)\\n            cell_vector(i) -=\\n              beta_n * g[point] * fe_v.shape_value(i, point) * JxW[point];\\n      }\\n  }\\n \\n \\n template <int dim>\\n void DGTransportEquation<dim>::assemble_face_term(\\n const FEFaceValuesBase<dim> &fe_v,\\n const FEFaceValuesBase<dim> &fe_v_neighbor,\\n FullMatrix<double>          &ui_vi_matrix,\\n FullMatrix<double>          &ue_vi_matrix,\\n FullMatrix<double>          &ui_ve_matrix,\\n FullMatrix<double>          &ue_ve_matrix) const\\n {\\n const std::vector<double>         &JxW     = fe_v.get_JxW_values();\\n const std::vector<Tensor<1, dim>> &normals = fe_v.get_normal_vectors();\\n \\n    std::vector<Point<dim>> beta(fe_v.n_quadrature_points);\\n \\n    beta_function.value_list(fe_v.get_quadrature_points(), beta);\\n \\n for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point)\\n      {\\n const double beta_n = beta[point] * normals[point];\\n if (beta_n > 0)\\n          {\\n for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)\\n for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j)\\n                ui_vi_matrix(i, j) += beta_n * fe_v.shape_value(j, point) *\\n                                      fe_v.shape_value(i, point) * JxW[point];\\n \\n for (unsigned int k = 0; k < fe_v_neighbor.dofs_per_cell; ++k)\\n for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j)\\n                ui_ve_matrix(k, j) -= beta_n * fe_v.shape_value(j, point) *\\n                                      fe_v_neighbor.shape_value(k, point) *\\n                                      JxW[point];\\n          }\\n else\\n          {\\n for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)\\n for (unsigned int l = 0; l < fe_v_neighbor.dofs_per_cell; ++l)\\n                ue_vi_matrix(i, l) += beta_n *\\n                                      fe_v_neighbor.shape_value(l, point) *\\n                                      fe_v.shape_value(i, point) * JxW[point];\\n \\n for (unsigned int k = 0; k < fe_v_neighbor.dofs_per_cell; ++k)\\n for (unsigned int l = 0; l < fe_v_neighbor.dofs_per_cell; ++l)\\n                ue_ve_matrix(k, l) -=\\n                  beta_n * fe_v_neighbor.shape_value(l, point) *\\n                  fe_v_neighbor.shape_value(k, point) * JxW[point];\\n          }\\n      }\\n  }\\n \\n \\n template <int dim>\\n class DGMethod\\n  {\\n public:\\n    DGMethod(const bool anisotropic);\\n \\n void run();\\n \\n private:\\n void setup_system();\\n void assemble_system();\\n void solve(Vector<double> &solution);\\n void refine_grid();\\n void set_anisotropic_flags();\\n void output_results(const unsigned int cycle) const;\\n \\n Triangulation<dim> triangulation;\\n const MappingQ1<dim> mapping;\\n const unsigned int degree;\\n const FE_DGQ<dim>  fe;\\n DoFHandler<dim>    dof_handler;\\n \\n SparsityPattern      sparsity_pattern;\\n SparseMatrix<double> system_matrix;\\n const double anisotropic_threshold_ratio;\\n const bool anisotropic;\\n \\n const QGauss<dim>     quadrature;\\n const QGauss<dim - 1> face_quadrature;\\n \\n Vector<double> solution2;\\n Vector<double> right_hand_side;\\n \\n const DGTransportEquation<dim> dg;\\n  };\\n \\n \\n template <int dim>\\n  DGMethod<dim>::DGMethod(const bool anisotropic)\\n    : mapping()\\n    ,\\n    degree(1)\\n    , fe(degree)\\n    , dof_handler(triangulation)\\n    , anisotropic_threshold_ratio(3.)\\n    , anisotropic(anisotropic)\\n    ,\\n    quadrature(degree + 1)\\n    , face_quadrature(degree + 1)\\n    , dg()\\n  {}\\n \\n \\n \\n template <int dim>\\n void DGMethod<dim>::setup_system()\\n  {\\n    dof_handler.distribute_dofs(fe);\\n    sparsity_pattern.reinit(dof_handler.n_dofs(),\\n                            dof_handler.n_dofs(),\\n                            (GeometryInfo<dim>::faces_per_cell *\\n GeometryInfo<dim>::max_children_per_face +\\n                             1) *\\n                              fe.n_dofs_per_cell());\\n \\n DoFTools::make_flux_sparsity_pattern(dof_handler, sparsity_pattern);\\n \\n    sparsity_pattern.compress();\\n \\n    system_matrix.reinit(sparsity_pattern);\\n \\n    solution2.reinit(dof_handler.n_dofs());\\n    right_hand_side.reinit(dof_handler.n_dofs());\\n  }\\n \\n \\n template <int dim>\\n void DGMethod<dim>::assemble_system()\\n  {\\n const unsigned int dofs_per_cell = dof_handler.get_fe().n_dofs_per_cell();\\n    std::vector<types::global_dof_index> dofs(dofs_per_cell);\\n    std::vector<types::global_dof_index> dofs_neighbor(dofs_per_cell);\\n \\n const UpdateFlags update_flags = update_values | update_gradients |\\n update_quadrature_points |\\n update_JxW_values;\\n \\n const UpdateFlags face_update_flags =\\n update_values | update_quadrature_points | update_JxW_values |\\n update_normal_vectors;\\n \\n const UpdateFlags neighbor_face_update_flags = update_values;\\n \\n FEValues<dim>        fe_v(mapping, fe, quadrature, update_flags);\\n FEFaceValues<dim>    fe_v_face(mapping,\\n                                fe,\\n                                face_quadrature,\\n                                face_update_flags);\\n FESubfaceValues<dim> fe_v_subface(mapping,\\n                                      fe,\\n                                      face_quadrature,\\n                                      face_update_flags);\\n FEFaceValues<dim>    fe_v_face_neighbor(mapping,\\n                                         fe,\\n                                         face_quadrature,\\n                                         neighbor_face_update_flags);\\n \\n \\n FullMatrix<double> ui_vi_matrix(dofs_per_cell, dofs_per_cell);\\n FullMatrix<double> ue_vi_matrix(dofs_per_cell, dofs_per_cell);\\n \\n FullMatrix<double> ui_ve_matrix(dofs_per_cell, dofs_per_cell);\\n FullMatrix<double> ue_ve_matrix(dofs_per_cell, dofs_per_cell);\\n \\n Vector<double> cell_vector(dofs_per_cell);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n        ui_vi_matrix = 0;\\n        cell_vector  = 0;\\n \\n        fe_v.reinit(cell);\\n \\n        dg.assemble_cell_term(fe_v, ui_vi_matrix, cell_vector);\\n \\n        cell->get_dof_indices(dofs);\\n \\n for (const auto face_no : cell->face_indices())\\n          {\\n const auto face = cell->face(face_no);\\n \\n if (face->at_boundary())\\n              {\\n                fe_v_face.reinit(cell, face_no);\\n \\n                dg.assemble_boundary_term(fe_v_face, ui_vi_matrix, cell_vector);\\n              }\\n else\\n              {\\n Assert(cell->neighbor(face_no).state() == IteratorState::valid,\\n                       ExcInternalError());\\n const auto neighbor = cell->neighbor(face_no);\\n \\n if (face->has_children())\\n                  {\\n const unsigned int neighbor2 =\\n                      cell->neighbor_face_no(face_no);\\n \\n for (unsigned int subface_no = 0;\\n                         subface_no < face->n_active_descendants();\\n                         ++subface_no)\\n                      {\\n const auto neighbor_child =\\n                          cell->neighbor_child_on_subface(face_no, subface_no);\\n Assert(!neighbor_child->has_children(),\\n                               ExcInternalError());\\n \\n                        ue_vi_matrix = 0;\\n                        ui_ve_matrix = 0;\\n                        ue_ve_matrix = 0;\\n \\n                        fe_v_subface.reinit(cell, face_no, subface_no);\\n                        fe_v_face_neighbor.reinit(neighbor_child, neighbor2);\\n \\n                        dg.assemble_face_term(fe_v_subface,\\n                                              fe_v_face_neighbor,\\n                                              ui_vi_matrix,\\n                                              ue_vi_matrix,\\n                                              ui_ve_matrix,\\n                                              ue_ve_matrix);\\n \\n                        neighbor_child->get_dof_indices(dofs_neighbor);\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n                            {\\n                              system_matrix.add(dofs[i],\\n                                                dofs_neighbor[j],\\n                                                ue_vi_matrix(i, j));\\n                              system_matrix.add(dofs_neighbor[i],\\n                                                dofs[j],\\n                                                ui_ve_matrix(i, j));\\n                              system_matrix.add(dofs_neighbor[i],\\n                                                dofs_neighbor[j],\\n                                                ue_ve_matrix(i, j));\\n                            }\\n                      }\\n                  }\\n else\\n                  {\\n if (dim > 1 && cell->neighbor_is_coarser(face_no))\\n continue;\\n \\n if (((dim > 1) && (cell->index() < neighbor->index())) ||\\n                        ((dim == 1) && ((cell->level() < neighbor->level()) ||\\n                                        ((cell->level() == neighbor->level()) &&\\n                                         (cell->index() < neighbor->index())))))\\n                      {\\n const unsigned int neighbor2 =\\n                          cell->neighbor_of_neighbor(face_no);\\n \\n                        ue_vi_matrix = 0;\\n                        ui_ve_matrix = 0;\\n                        ue_ve_matrix = 0;\\n \\n                        fe_v_face.reinit(cell, face_no);\\n                        fe_v_face_neighbor.reinit(neighbor, neighbor2);\\n \\n                        dg.assemble_face_term(fe_v_face,\\n                                              fe_v_face_neighbor,\\n                                              ui_vi_matrix,\\n                                              ue_vi_matrix,\\n                                              ui_ve_matrix,\\n                                              ue_ve_matrix);\\n \\n                        neighbor->get_dof_indices(dofs_neighbor);\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n                            {\\n                              system_matrix.add(dofs[i],\\n                                                dofs_neighbor[j],\\n                                                ue_vi_matrix(i, j));\\n                              system_matrix.add(dofs_neighbor[i],\\n                                                dofs[j],\\n                                                ui_ve_matrix(i, j));\\n                              system_matrix.add(dofs_neighbor[i],\\n                                                dofs_neighbor[j],\\n                                                ue_ve_matrix(i, j));\\n                            }\\n                      }\\n \\n                  }\\n              }\\n          }\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n            system_matrix.add(dofs[i], dofs[j], ui_vi_matrix(i, j));\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n          right_hand_side(dofs[i]) += cell_vector(i);\\n      }\\n  }\\n \\n \\n template <int dim>\\n void DGMethod<dim>::solve(Vector<double> &solution)\\n  {\\n SolverControl                    solver_control(1000, 1e-12, false, false);\\n SolverRichardson<Vector<double>> solver(solver_control);\\n \\n PreconditionBlockSSOR<SparseMatrix<double>> preconditioner;\\n \\n    preconditioner.initialize(system_matrix, fe.n_dofs_per_cell());\\n \\n    solver.solve(system_matrix, solution, right_hand_side, preconditioner);\\n  }\\n \\n \\n template <int dim>\\n void DGMethod<dim>::refine_grid()\\n  {\\n Vector<float> gradient_indicator(triangulation.n_active_cells());\\n \\n DerivativeApproximation::approximate_gradient(mapping,\\n                                                  dof_handler,\\n                                                  solution2,\\n                                                  gradient_indicator);\\n \\n for (const auto &cell : triangulation.active_cell_iterators())\\n      gradient_indicator[cell->active_cell_index()] *=\\n std::pow(cell->diameter(), 1 + 1.0 * dim / 2);\\n GridRefinement::refine_and_coarsen_fixed_number(triangulation,\\n                                                    gradient_indicator,\\n                                                    0.3,\\n                                                    0.1);\\n if (anisotropic)\\n      set_anisotropic_flags();\\n triangulation.execute_coarsening_and_refinement();\\n  }\\n \\n template <int dim>\\n void DGMethod<dim>::set_anisotropic_flags()\\n  {\\n UpdateFlags face_update_flags =\\n UpdateFlags(update_values | update_JxW_values);\\n \\n FEFaceValues<dim>    fe_v_face(mapping,\\n                                fe,\\n                                face_quadrature,\\n                                face_update_flags);\\n FESubfaceValues<dim> fe_v_subface(mapping,\\n                                      fe,\\n                                      face_quadrature,\\n                                      face_update_flags);\\n FEFaceValues<dim>    fe_v_face_neighbor(mapping,\\n                                         fe,\\n                                         face_quadrature,\\n update_values);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      if (cell->refine_flag_set())\\n        {\\n          std::array<double, dim> jump_in_coordinate_direction;\\n          std::array<double, dim> face_area_in_coordinate_direction;\\n \\n for (const auto face_no : cell->face_indices())\\n            {\\n const auto face = cell->face(face_no);\\n \\n if (!face->at_boundary())\\n                {\\n Assert(cell->neighbor(face_no).state() ==\\n IteratorState::valid,\\n                         ExcInternalError());\\n const auto neighbor = cell->neighbor(face_no);\\n \\n                  std::vector<double> u(fe_v_face.n_quadrature_points);\\n                  std::vector<double> u_neighbor(fe_v_face.n_quadrature_points);\\n \\n if (face->has_children())\\n                    {\\n unsigned int neighbor2 = cell->neighbor_face_no(face_no);\\n for (unsigned int subface_no = 0;\\n                           subface_no < face->n_active_descendants();\\n                           ++subface_no)\\n                        {\\n const auto neighbor_child =\\n                            cell->neighbor_child_on_subface(face_no,\\n                                                            subface_no);\\n Assert(!neighbor_child->has_children(),\\n                                 ExcInternalError());\\n                          fe_v_subface.reinit(cell, face_no, subface_no);\\n                          fe_v_face_neighbor.reinit(neighbor_child, neighbor2);\\n                          fe_v_subface.get_function_values(solution2, u);\\n                          fe_v_face_neighbor.get_function_values(solution2,\\n                                                                 u_neighbor);\\n const std::vector<double> &JxW =\\n                            fe_v_subface.get_JxW_values();\\n for (unsigned int x = 0;\\n                               x < fe_v_subface.n_quadrature_points;\\n                               ++x)\\n                            {\\n                              jump_in_coordinate_direction[face_no / 2] +=\\n std::abs(u[x] - u_neighbor[x]) * JxW[x];\\n                              face_area_in_coordinate_direction[face_no / 2] +=\\n                                JxW[x];\\n                            }\\n                        }\\n                    }\\n else\\n                    {\\n if (!cell->neighbor_is_coarser(face_no))\\n                        {\\n unsigned int neighbor2 =\\n                            cell->neighbor_of_neighbor(face_no);\\n \\n                          fe_v_face.reinit(cell, face_no);\\n                          fe_v_face_neighbor.reinit(neighbor, neighbor2);\\n \\n                          fe_v_face.get_function_values(solution2, u);\\n                          fe_v_face_neighbor.get_function_values(solution2,\\n                                                                 u_neighbor);\\n \\n const std::vector<double> &JxW =\\n                            fe_v_face.get_JxW_values();\\n \\n for (unsigned int x = 0;\\n                               x < fe_v_face.n_quadrature_points;\\n                               ++x)\\n                            {\\n                              jump_in_coordinate_direction[face_no / 2] +=\\n std::abs(u[x] - u_neighbor[x]) * JxW[x];\\n                              face_area_in_coordinate_direction[face_no / 2] +=\\n                                JxW[x];\\n                            }\\n                        }\\n else // i.e. neighbor is coarser than cell\\n                        {\\n                          std::pair<unsigned int, unsigned int>\\n                            neighbor_face_subface =\\n                              cell->neighbor_of_coarser_neighbor(face_no);\\n Assert(neighbor_face_subface.first < cell->n_faces(),\\n                                 ExcInternalError());\\n Assert(neighbor_face_subface.second <\\n                                   neighbor->face(neighbor_face_subface.first)\\n                                     ->n_active_descendants(),\\n                                 ExcInternalError());\\n Assert(neighbor->neighbor_child_on_subface(\\n                                   neighbor_face_subface.first,\\n                                   neighbor_face_subface.second) == cell,\\n                                 ExcInternalError());\\n \\n                          fe_v_face.reinit(cell, face_no);\\n                          fe_v_subface.reinit(neighbor,\\n                                              neighbor_face_subface.first,\\n                                              neighbor_face_subface.second);\\n \\n                          fe_v_face.get_function_values(solution2, u);\\n                          fe_v_subface.get_function_values(solution2,\\n                                                           u_neighbor);\\n \\n const std::vector<double> &JxW =\\n                            fe_v_face.get_JxW_values();\\n \\n for (unsigned int x = 0;\\n                               x < fe_v_face.n_quadrature_points;\\n                               ++x)\\n                            {\\n                              jump_in_coordinate_direction[face_no / 2] +=\\n std::abs(u[x] - u_neighbor[x]) * JxW[x];\\n                              face_area_in_coordinate_direction[face_no / 2] +=\\n                                JxW[x];\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n          std::array<double, dim> average_jumps;\\n double                  sum_of_average_jumps = 0.;\\n for (unsigned int i = 0; i < dim; ++i)\\n            {\\n              average_jumps[i] = jump_in_coordinate_direction[i] /\\n                                 face_area_in_coordinate_direction[i];\\n              sum_of_average_jumps += average_jumps[i];\\n            }\\n \\n for (unsigned int i = 0; i < dim; ++i)\\n if (average_jumps[i] > anisotropic_threshold_ratio *\\n                                     (sum_of_average_jumps - average_jumps[i]))\\n              cell->set_refine_flag(RefinementCase<dim>::cut_axis(i));\\n        }\\n  }\\n \\n template <int dim>\\n void DGMethod<dim>::output_results(const unsigned int cycle) const\\n {\\n    std::string refine_type;\\n if (anisotropic)\\n      refine_type = \\\".aniso\\\";\\n else\\n      refine_type = \\\".iso\\\";\\n \\n    {\\n const std::string filename =\\n \\\"grid-\\\" + std::to_string(cycle) + refine_type + \\\".svg\\\";\\n      std::cout << \\\"   Writing grid to <\\\" << filename << \\\">...\\\" << std::endl;\\n      std::ofstream svg_output(filename);\\n \\n GridOut grid_out;\\n      grid_out.write_svg(triangulation, svg_output);\\n    }\\n \\n    {\\n const std::string filename =\\n \\\"sol-\\\" + std::to_string(cycle) + refine_type + \\\".vtu\\\";\\n      std::cout << \\\"   Writing solution to <\\\" << filename << \\\">...\\\"\\n                << std::endl;\\n      std::ofstream gnuplot_output(filename);\\n \\n DataOut<dim> data_out;\\n      data_out.attach_dof_handler(dof_handler);\\n      data_out.add_data_vector(solution2, \\\"u\\\");\\n \\n      data_out.build_patches(degree);\\n \\n      data_out.write_vtu(gnuplot_output);\\n    }\\n  }\\n \\n \\n \\n template <int dim>\\n void DGMethod<dim>::run()\\n  {\\n for (unsigned int cycle = 0; cycle < 6; ++cycle)\\n      {\\n        std::cout << \\\"Cycle \\\" << cycle << ':' << std::endl;\\n \\n if (cycle == 0)\\n          {\\n Point<dim> p1, p2;\\n            p1[0] = -1.;\\n for (unsigned int i = 0; i < dim; ++i)\\n              p2[i] = 1.;\\n            std::vector<unsigned int> repetitions(dim, 1);\\n            repetitions[0] = 2;\\n GridGenerator::subdivided_hyper_rectangle(triangulation,\\n                                                      repetitions,\\n                                                      p1,\\n                                                      p2);\\n \\n triangulation.refine_global(5 - dim);\\n          }\\n else\\n          refine_grid();\\n \\n \\n        std::cout << \\\"   Number of active cells:       \\\"\\n                  << triangulation.n_active_cells() << std::endl;\\n \\n        setup_system();\\n \\n        std::cout << \\\"   Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n                  << std::endl;\\n \\n Timer assemble_timer;\\n        assemble_system();\\n        std::cout << \\\"   Time of assemble_system: \\\" << assemble_timer.cpu_time()\\n                  << std::endl;\\n        solve(solution2);\\n \\n        output_results(cycle);\\n \\n        std::cout << std::endl;\\n      }\\n  }\\n} // namespace Step30\\n \\n \\n \\nint main()\\n{\\n try\\n    {\\n using namespace Step30;\\n \\n const unsigned int dim = 2;\\n \\n      {\\n        std::cout << \\\"Performing a \\\" << dim\\n                  << \\\"D run with isotropic refinement...\\\" << std::endl\\n                  << \\\"------------------------------------------------\\\"\\n                  << std::endl;\\n        DGMethod<dim> dgmethod_iso(false);\\n        dgmethod_iso.run();\\n      }\\n \\n      {\\n        std::cout << std::endl\\n                  << \\\"Performing a \\\" << dim\\n                  << \\\"D run with anisotropic refinement...\\\" << std::endl\\n                  << \\\"--------------------------------------------------\\\"\\n                  << std::endl;\\n        DGMethod<dim> dgmethod_aniso(true);\\n        dgmethod_aniso.run();\\n      }\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    };\\n \\n return 0;\\n}\\nDataOutInterface::write_vtuvoid write_vtu(std::ostream &out) constDefinition data_out_base.cc:7692\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nFEValuesBase::get_JxW_valuesconst std::vector< double > & get_JxW_values() const\\nFEValuesBase::get_quadrature_pointsconst std::vector< Point< spacedim > > & get_quadrature_points() const\\nFEValuesBase::dofs_per_cellconst unsigned int dofs_per_cellDefinition fe_values_base.h:192\\nFEValuesBase::n_quadrature_pointsconst unsigned int n_quadrature_pointsDefinition fe_values_base.h:174\\nFEValuesBase::get_normal_vectorsconst std::vector< Tensor< 1, spacedim > > & get_normal_vectors() constDefinition fe_values_base.cc:1298\\nFEValuesBase::shape_gradconst Tensor< 1, spacedim > & shape_grad(const unsigned int i, const unsigned int q_point) const\\nFEValuesBase::shape_valueconst double & shape_value(const unsigned int i, const unsigned int q_point) const\\nFullMatrix::addvoid add(const number a, const FullMatrix< number2 > &A)\\nTimer::cpu_timedouble cpu_time() constDefinition timer.cc:234\\nderivative_approximation.h\\ndof_handler.h\\ndof_tools.h\\nfe_values.h\\nfe_dgq.h\\nfunction.h\\ngrid_refinement.h\\ntria.h\\ngrid_generator.h\\ngrid_out.h\\nmapping_q1.h\\nGridTools::diameterdouble diameter(const Triangulation< dim, spacedim > &tria)Definition grid_tools_geometry.cc:43\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\nstd::pow::VectorizedArray< Number, width > pow(const ::VectorizedArray< Number, width > &, const Number p)Definition vectorization.h:6885\\ndata_out.h\\nprecondition_block.h\\nquadrature_lib.h\\nsolver_richardson.h\\nsparse_matrix.h\\ntimer.h\\nvector.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"