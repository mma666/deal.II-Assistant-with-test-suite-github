"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_14.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-14 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-14 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-14 tutorial program\\n\\n\\nThis tutorial depends on step-13.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nThe maths\\nThe software\\n\\n The commented program\\n\\nEvaluating the solution\\n\\nThe EvaluationBase class\\nThe PointValueEvaluation class\\nThe PointXDerivativeEvaluation class\\nThe GridOutput class\\n\\nThe Laplace solver classes\\n\\nThe Laplace solver base class\\nThe Laplace Solver class\\nThe PrimalSolver class\\nThe RefinementGlobal and RefinementKelly classes\\nThe RefinementWeightedKelly class\\n\\nEquation data\\n\\nThe SetUpBase and SetUp classes\\nThe CurvedRidges class\\nThe Exercise_2_3 class\\nDiscussion\\n\\nDual functionals\\n\\nThe DualFunctionalBase class\\nThe dual functional PointValueEvaluation class\\nThe dual functional PointXDerivativeEvaluation class\\n\\nExtending the LaplaceSolver namespace\\n\\nThe DualSolver class\\nThe WeightedResidual class\\n\\nEstimating errors\\n\\nError estimation driver functions\\nEstimating on a single cell\\nComputing cell term error contributions\\nComputing edge term error contributions \\u2014 1\\nComputing edge term error contributions \\u2014 2\\n\\nA simulation framework\\nThe main function\\n\\n\\n Results\\n\\nPoint values\\nComparing refinement criteria\\nEvaluation of point stresses\\n@ref step_13 \\\"step-13\\\" revisited\\nConclusions and outlook\\n\\n The plain program\\n   \\n Introduction\\nThe maths\\nThe Heidelberg group of Professor Rolf Rannacher, to which the three initial authors of the deal.II library belonged during their PhD time and partly also afterwards, has been involved with adaptivity and error estimation for finite element discretizations since the mid-1990ies. The main achievement is the development of error estimates for arbitrary functionals of the solution, and of optimal mesh refinement for its computation.\\nWe will not discuss the derivation of these concepts in too great detail, but will implement the main ideas in the present example program. For a thorough introduction into the general idea, we refer to the seminal work of Becker and Rannacher [20], [19], and the overview article of the same authors in Acta Numerica [21]; the first introduces the concept of error estimation and adaptivity for general functional output for the Laplace equation, while the second gives many examples of applications of these concepts to a large number of other, more complicated equations. For applications to individual types of equations, see also the publications by Becker [22], [23], Kanschat [124], [92], Suttmeier [198], [180], [181], [182], Bangerth [9], [13], [10], [14], and Hartmann [111], [110], [109]. All of these works, from the original introduction by Becker and Rannacher to individual contributions to particular equations, have later been summarized in a book by Bangerth and Rannacher that covers all of these topics, see [11].\\nThe basic idea is the following: in applications, one is not usually interested in the solution per se, but rather in certain aspects of it. For example, in simulations of flow problems, one may want to know the lift or drag of a body immersed in the fluid; it is this quantity that we want to know to best accuracy, and whether the rest of the solution of the describing equations is well resolved is not of primary interest. Likewise, in elasticity one might want to know about values of the stress at certain points to guess whether maximal load values of joints are safe, for example. Or, in radiative transfer problems, mean flux intensities are of interest.\\nIn all the cases just listed, it is the evaluation of a functional \\\\(J(u)\\\\) of the solution which we are interested in, rather than the values of \\\\(u\\\\) everywhere. Since the exact solution \\\\(u\\\\) is not available, but only its numerical approximation \\\\(u_h\\\\), it is sensible to ask whether the computed value \\\\(J(u_h)\\\\) is within certain limits of the exact value \\\\(J(u)\\\\), i.e. we want to bound the error with respect to this functional, \\\\(J(u)-J(u_h)\\\\).\\nFor simplicity of exposition, we henceforth assume that both the quantity of interest \\\\(J\\\\) as well as the equation are linear, and we will in particular show the derivation for the Laplace equation with homogeneous Dirichlet boundary conditions, although the concept is much more general. For this general case, we refer to the references listed above. The goal is to obtain bounds on the error, \\\\(J(e)=J(u)-J(u_h)\\\\). For this, let us denote by \\\\(z\\\\) the solution of a dual problem, defined as follows:   \\n\\\\[\\n  a(\\\\varphi,z) = J(\\\\varphi) \\\\qquad \\\\forall \\\\varphi,\\n\\\\]\\n\\n where \\\\(a(\\\\cdot,\\\\cdot)\\\\) is the bilinear form associated with the differential equation, and the test functions are chosen from the corresponding solution space. Then, taking as special test function \\\\(\\\\varphi=e\\\\) the error, we have that   \\n\\\\[\\n  J(e) = a(e,z)\\n\\\\]\\n\\n and we can, by Galerkin orthogonality, rewrite this as   \\n\\\\[\\n  J(e) = a(e,z-\\\\varphi_h)\\n\\\\]\\n\\n where \\\\(\\\\varphi_h\\\\) can be chosen from the discrete test space in whatever way we find convenient.\\nConcretely, for Laplace's equation, the error identity reads   \\n\\\\[\\n  J(e) = (\\\\nabla e, \\\\nabla(z-\\\\varphi_h)).\\n\\\\]\\n\\n Because we want to use this formula not only to compute error, but also to refine the mesh, we need to rewrite the expression above as a sum over cells where each cell's contribution can then be used as an error indicator for this cell. Thus, we split the scalar products into terms for each cell, and integrate by parts on each of them:         \\n\\\\begin{eqnarray*}\\n  J(e)\\n  &=&\\n  \\\\sum_K (\\\\nabla (u-u_h), \\\\nabla (z-\\\\varphi_h))_K\\n  \\\\\\\\\\n  &=&\\n  \\\\sum_K (-\\\\Delta (u-u_h), z-\\\\varphi_h)_K\\n  + (\\\\partial_n (u-u_h), z-z_h)_{\\\\partial K}.\\n\\\\end{eqnarray*}\\n\\n Next we use that \\\\(-\\\\Delta u=f\\\\), and that the solution of the Laplace equation is smooth enough that \\\\(\\\\partial_n u\\\\) is continuous almost everywhere \\u2013 so the terms involving \\\\(\\\\partial_n u\\\\) on one cell cancels with that on its neighbor, where the normal vector has the opposite sign. (The same is not true for \\\\(\\\\partial_n u_h\\\\), though.) At the boundary of the domain, where there is no neighbor cell with which this term could cancel, the weight \\\\(z-\\\\varphi_h\\\\) can be chosen as zero, and the whole term disappears.\\nThus, we have      \\n\\\\begin{eqnarray*}\\n  J(e)\\n  &=&\\n  \\\\sum_K (f+\\\\Delta u_h, z-\\\\varphi_h)_K\\n  - (\\\\partial_n u_h, z-\\\\varphi_h)_{\\\\partial K\\\\backslash \\\\partial\\\\Omega}.\\n\\\\end{eqnarray*}\\n\\n In a final step, note that when taking the normal derivative of \\\\(u_h\\\\), we mean the value of this quantity as taken from this side of the cell (for the usual Lagrange elements, derivatives are not continuous across edges). We then rewrite the above formula by exchanging half of the edge integral of cell \\\\(K\\\\) with the neighbor cell \\\\(K'\\\\), to obtain       \\n\\\\begin{eqnarray*}\\n  J(e)\\n  &=&\\n  \\\\sum_K (f+\\\\Delta u_h, z-\\\\varphi_h)_K\\n  - \\\\frac 12 (\\\\partial_n u_h|_K + \\\\partial_{n'} u_h|_{K'},\\n              z-\\\\varphi_h)_{\\\\partial K\\\\backslash \\\\partial\\\\Omega}.\\n\\\\end{eqnarray*}\\n\\n Using that for the normal vectors on adjacent cells we have \\\\(n'=-n\\\\), we define the jump of the normal derivative by     \\n\\\\[\\n  [\\\\partial_n u_h] \\\\dealcoloneq \\\\partial_n u_h|_K + \\\\partial_{n'} u_h|_{K'}\\n  =\\n  \\\\partial_n u_h|_K - \\\\partial_n u_h|_{K'},\\n\\\\]\\n\\n and get the final form after setting the discrete function \\\\(\\\\varphi_h\\\\), which is by now still arbitrary, to the point interpolation of the dual solution, \\\\(\\\\varphi_h=I_h z\\\\):       \\n\\\\begin{eqnarray*}\\n  J(e)\\n  &=&\\n  \\\\sum_K (f+\\\\Delta u_h, z-I_h z)_K\\n  - \\\\frac 12 ([\\\\partial_n u_h],\\n              z-I_h z)_{\\\\partial K\\\\backslash \\\\partial\\\\Omega}.\\n\\\\end{eqnarray*}\\n\\nWith this, we have obtained an exact representation of the error of the finite element discretization with respect to arbitrary (linear) functionals \\\\(J(\\\\cdot)\\\\). Its structure is a weighted form of a residual estimator, as both \\\\(f+\\\\Delta u_h\\\\) and \\\\([\\\\partial_n u_h]\\\\) are cell and edge residuals that vanish on the exact solution, and \\\\(z-I_h z\\\\) are weights indicating how important the residual on a certain cell is for the evaluation of the given functional. Furthermore, it is a cell-wise quantity, so we can use it as a mesh refinement criterion. The question is: how to evaluate it? After all, the evaluation requires knowledge of the dual solution \\\\(z\\\\), which carries the information about the quantity we want to know to best accuracy.\\nIn some, very special cases, this dual solution is known. For example, if the functional \\\\(J(\\\\cdot)\\\\) is the point evaluation, \\\\(J(\\\\varphi)=\\\\varphi(x_0)\\\\), then the dual solution has to satisfy   \\n\\\\[\\n  -\\\\Delta z = \\\\delta(x-x_0),\\n\\\\]\\n\\n with the Dirac delta function on the right hand side, and the dual solution is the Green's function with respect to the point \\\\(x_0\\\\). For simple geometries, this function is analytically known, and we could insert it into the error representation formula.\\nHowever, we do not want to restrict ourselves to such special cases. Rather, we will compute the dual solution numerically, and approximate \\\\(z\\\\) by some numerically obtained \\\\(\\\\tilde z\\\\). We note that it is not sufficient to compute this approximation \\\\(\\\\tilde z\\\\) using the same method as used for the primal solution \\\\(u_h\\\\), since then \\\\(\\\\tilde z-I_h \\\\tilde z=0\\\\), and the overall error estimate would be zero. Rather, the approximation \\\\(\\\\tilde z\\\\) has to be from a larger space than the primal finite element space. There are various ways to obtain such an approximation (see the cited literature), and we will choose to compute it with a higher order finite element space. While this is certainly not the most efficient way, it is simple since we already have all we need to do that in place, and it also allows for simple experimenting. For more efficient methods, again refer to the given literature, in particular [20], [11].\\nWith this, we end the discussion of the mathematical side of this program and turn to the actual implementation.\\nNoteThere are two steps above that do not seem necessary if all you care about is computing the error: namely, (i) the subtraction of \\\\(\\\\phi_h\\\\) from \\\\(z\\\\), and (ii) splitting the integral into a sum of cells and integrating by parts on each. Indeed, neither of these two steps change \\\\(J(e)\\\\) at all, as we only ever consider identities above until the substitution of \\\\(z\\\\) by \\\\(\\\\tilde z\\\\). In other words, if you care only about estimating the global error \\\\(J(e)\\\\), then these steps are not necessary. On the other hand, if you want to use the error estimate also as a refinement criterion for each cell of the mesh, then it is necessary to (i) break the estimate into a sum of cells, and (ii) massage the formulas in such a way that each cell's contributions have something to do with the local error. (While the contortions above do not change the value of the sum \\\\(J(e)\\\\), they change the values we compute for each cell \\\\(K\\\\).) To this end, we want to write everything in the form \\\"residual times dual weight\\\" where a \\\"residual\\\" is something that goes to zero as the approximation becomes \\\\(u_h\\\\) better and better. For example, the quantity  \\\\(\\\\partial_n\\nu_h\\\\) is not a residual, since it simply converges to the (normal component of) the gradient of the exact solution. On the other hand, \\\\([\\\\partial_n u_h]\\\\) is a residual because it converges to  \\\\([\\\\partial_n\\nu]=0\\\\). All of the steps we have taken above in developing the final form of \\\\(J(e)\\\\) have indeed had the goal of bringing the final formula into a form where each term converges to zero as the discrete solution \\\\(u_h\\\\) converges to \\\\(u\\\\). This then allows considering each cell's contribution as an \\\"error indicator\\\" that also converges to zero \\u2013 as it should as the mesh is refined.\\nThe software\\nThe step-14 example program builds heavily on the techniques already used in the step-13 program. Its implementation of the dual weighted residual error estimator explained above is done by deriving a second class, properly called DualSolver, from the Solver base class, and having a class (WeightedResidual) that joins the two again and controls the solution of the primal and dual problem, and then uses both to compute the error indicator for mesh refinement.\\nThe program continues the modular concept of the previous example, by implementing the dual functional, describing quantity of interest, by an abstract base class, and providing two different functionals which implement this interface. Adding a different quantity of interest is thus simple.\\nOne of the more fundamental differences is the handling of data. A common case is that you develop a program that solves a certain equation, and test it with different right hand sides, different domains, different coefficients and boundary values, etc. Usually, these have to match, so that exact solutions are known, or that their combination makes sense at all.\\nWe demonstrate a way how this can be achieved in a simple, yet very flexible way. We will put everything that belongs to a certain setup into one class, and provide a little C++ mortar around it, so that entire setups (domains, coefficients, right hand sides, etc.) can be exchanged by only changing something in one place.\\nGoing this way a little further, we have also centralized all the other parameters that describe how the program is to work in one place, such as the order of the finite element, the maximal number of degrees of freedom, the evaluation objects that shall be executed on the computed solutions, and so on. This allows for simpler configuration of the program, and we will show in a later program how to use a library class that can handle setting these parameters by reading an input file. The general aim is to reduce the places within a program where one may have to look when wanting to change some parameter, as it has turned out in practice that one forgets where they are as programs grow. Furthermore, putting all options describing what the program does in a certain run into a file (that can be stored with the results) helps repeatability of results more than if the various flags were set somewhere in the program, where their exact values are forgotten after the next change to this place.\\nUnfortunately, the program has become rather long. While this admittedly reduces its usefulness as an example program, we think that it is a very good starting point for development of a program for other kinds of problems, involving different equations than the Laplace equation treated here. Furthermore, it shows everything that we can show you about our way of a posteriori error estimation, and its structure should make it simple for you to adjust this method to other problems, other functionals, other geometries, coefficients, etc.\\nThe author believes that the present program is his masterpiece among the example programs, regarding the mathematical complexity, as well as the simplicity to add extensions. If you use this program as a basis for your own programs, we would kindly like to ask you to state this fact and the name of the author of the example program, Wolfgang Bangerth, in publications that arise from that, if your program consists in a considerable part of the example program.\\n The commented program\\nStart out with well known things...\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/base/thread_management.h>\\n\\u00a0 #include <deal.II/base/work_stream.h>\\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/solver_cg.h>\\n\\u00a0 #include <deal.II/lac/precondition.h>\\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_tools.h>\\n\\u00a0 #include <deal.II/grid/grid_out.h>\\n\\u00a0 #include <deal.II/grid/grid_refinement.h>\\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 #include <deal.II/fe/fe_tools.h>\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 #include <deal.II/numerics/matrix_tools.h>\\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/error_estimator.h>\\n\\u00a0 \\n\\u00a0 #include <algorithm>\\n\\u00a0 #include <fstream>\\n\\u00a0 #include <iostream>\\n\\u00a0 #include <list>\\n\\u00a0 #include <memory>\\n\\u00a0 #include <numeric>\\n\\u00a0 \\nThe last step is as in all previous programs:\\n\\u00a0 namespace Step14\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n Evaluating the solution\\nAs mentioned in the introduction, significant parts of the program have simply been taken over from the step-13 example program. We therefore only comment on those things that are new.\\nFirst, the framework for evaluation of solutions is unchanged, i.e. the base class is the same, and the class to evaluate the solution at a grid point is unchanged:\\n\\u00a0   namespace Evaluation\\n\\u00a0   {\\n The EvaluationBase class\\n\\u00a0     template <int dim>\\n\\u00a0     class EvaluationBase\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       virtual ~EvaluationBase() = default;\\n\\u00a0 \\n\\u00a0       void set_refinement_cycle(const unsigned int refinement_cycle);\\n\\u00a0 \\n\\u00a0       virtual void operator()(const DoFHandler<dim> &dof_handler,\\n\\u00a0                               const Vector<double>  &solution) const = 0;\\n\\u00a0 \\n\\u00a0     protected:\\n\\u00a0       unsigned int refinement_cycle;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void EvaluationBase<dim>::set_refinement_cycle(const unsigned int step)\\n\\u00a0     {\\n\\u00a0       refinement_cycle = step;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\nDoFHandlerDefinition dof_handler.h:317\\nVectorDefinition vector.h:120\\n The PointValueEvaluation class\\n\\u00a0     template <int dim>\\n\\u00a0     class PointValueEvaluation : public EvaluationBase<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       PointValueEvaluation(const Point<dim> &evaluation_point);\\n\\u00a0 \\n\\u00a0       virtual void operator()(const DoFHandler<dim> &dof_handler,\\n\\u00a0                               const Vector<double>  &solution) const override;\\n\\u00a0 \\n\\u00a0       DeclException1(\\n\\u00a0         ExcEvaluationPointNotFound,\\n\\u00a0         Point<dim>,\\n\\u00a0         << \\\"The evaluation point \\\" << arg1\\n\\u00a0         << \\\" was not found among the vertices of the present grid.\\\");\\n\\u00a0 \\n\\u00a0     private:\\n\\u00a0       const Point<dim> evaluation_point;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     PointValueEvaluation<dim>::PointValueEvaluation(\\n\\u00a0       const Point<dim> &evaluation_point)\\n\\u00a0       : evaluation_point(evaluation_point)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void\\n\\u00a0     PointValueEvaluation<dim>::operator()(const DoFHandler<dim> &dof_handler,\\n\\u00a0                                           const Vector<double>  &solution) const\\n\\u00a0     {\\n\\u00a0       double point_value = 1e20;\\n\\u00a0 \\n\\u00a0       bool evaluation_point_found = false;\\n\\u00a0       for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0         if (!evaluation_point_found)\\n\\u00a0           for (const auto vertex : cell->vertex_indices())\\n\\u00a0             if (cell->vertex(vertex).distance(evaluation_point) <\\n\\u00a0                 cell->diameter() * 1e-8)\\n\\u00a0               {\\n\\u00a0                 point_value = solution(cell->vertex_dof_index(vertex, 0));\\n\\u00a0 \\n\\u00a0                 evaluation_point_found = true;\\n\\u00a0                 break;\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0       AssertThrow(evaluation_point_found,\\n\\u00a0                   ExcEvaluationPointNotFound(evaluation_point));\\n\\u00a0 \\n\\u00a0       std::cout << \\\"   Point value: \\\" << point_value << std::endl;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\nPointDefinition point.h:111\\nint\\nvertex_indicesunsigned int vertex_indices[2]Definition grid_tools_topology.cc:947\\nDeclException1#define DeclException1(Exception1, type1, outsequence)Definition exceptions.h:516\\nAssertThrow#define AssertThrow(cond, exc)Definition exceptions.h:1739\\nVectorTools::point_valuevoid point_value(const DoFHandler< dim, spacedim > &dof, const VectorType &fe_function, const Point< spacedim, double > &point, Vector< typename VectorType::value_type > &value)\\n The PointXDerivativeEvaluation class\\nBesides the class implementing the evaluation of the solution at one point, we here provide one which evaluates the gradient at a grid point. Since in general the gradient of a finite element function is not continuous at a vertex, we have to be a little bit more careful here. What we do is to loop over all cells, even if we have found the point already on one cell, and use the mean value of the gradient at the vertex taken from all adjacent cells.\\nGiven the interface of the PointValueEvaluation class, the declaration of this class provides little surprise, and neither does the constructor:\\n\\u00a0     template <int dim>\\n\\u00a0     class PointXDerivativeEvaluation : public EvaluationBase<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       PointXDerivativeEvaluation(const Point<dim> &evaluation_point);\\n\\u00a0 \\n\\u00a0       virtual void operator()(const DoFHandler<dim> &dof_handler,\\n\\u00a0                               const Vector<double>  &solution) const;\\n\\u00a0 \\n\\u00a0       DeclException1(\\n\\u00a0         ExcEvaluationPointNotFound,\\n\\u00a0         Point<dim>,\\n\\u00a0         << \\\"The evaluation point \\\" << arg1\\n\\u00a0         << \\\" was not found among the vertices of the present grid.\\\");\\n\\u00a0 \\n\\u00a0     private:\\n\\u00a0       const Point<dim> evaluation_point;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     PointXDerivativeEvaluation<dim>::PointXDerivativeEvaluation(\\n\\u00a0       const Point<dim> &evaluation_point)\\n\\u00a0       : evaluation_point(evaluation_point)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\nThe more interesting things happen inside the function doing the actual evaluation:\\n\\u00a0     template <int dim>\\n\\u00a0     void PointXDerivativeEvaluation<dim>::operator()(\\n\\u00a0       const DoFHandler<dim> &dof_handler,\\n\\u00a0       const Vector<double>  &solution) const\\n\\u00a0     {\\nThis time initialize the return value with something useful, since we will have to add up a number of contributions and take the mean value afterwards...\\n\\u00a0       double point_derivative = 0;\\n\\u00a0 \\n...then have some objects of which the meaning will become clear below...\\n\\u00a0       const QTrapezoid<dim>       vertex_quadrature;\\n\\u00a0       FEValues<dim>               fe_values(dof_handler.get_fe(),\\n\\u00a0                               vertex_quadrature,\\n\\u00a0                               update_gradients | update_quadrature_points);\\n\\u00a0       std::vector<Tensor<1, dim>> solution_gradients(vertex_quadrature.size());\\n\\u00a0 \\nFEValuesDefinition fe_values.h:63\\nQTrapezoidDefinition quadrature_lib.h:191\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\n...and next loop over all cells and their vertices, and count how often the vertex has been found:\\n\\u00a0       unsigned int evaluation_point_hits = 0;\\n\\u00a0       for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0         for (const auto vertex : cell->vertex_indices())\\n\\u00a0           if (cell->vertex(vertex) == evaluation_point)\\n\\u00a0             {\\nThings are now no more as simple, since we can't get the gradient of the finite element field as before, where we simply had to pick one degree of freedom at a vertex.\\nRather, we have to evaluate the finite element field on this cell, and at a certain point. As you know, evaluating finite element fields at certain points is done through the FEValues class, so we use that. The question is: the FEValues object needs to be a given a quadrature formula and can then compute the values of finite element quantities at the quadrature points. Here, we don't want to do quadrature, we simply want to specify some points!\\nNevertheless, the same way is chosen: use a special quadrature rule with points at the vertices, since these are what we are interested in. The appropriate rule is the trapezoidal rule, so that is the reason why we used that one above.\\nThus: initialize the FEValues object on this cell,\\n\\u00a0               fe_values.reinit(cell);\\nand extract the gradients of the solution vector at the vertices:\\n\\u00a0               fe_values.get_function_gradients(solution, solution_gradients);\\n\\u00a0 \\nNow we have the gradients at all vertices, so pick out that one which belongs to the evaluation point (note that the order of vertices is not necessarily the same as that of the quadrature points):\\n\\u00a0               unsigned int q_point = 0;\\n\\u00a0               for (; q_point < solution_gradients.size(); ++q_point)\\n\\u00a0                 if (fe_values.quadrature_point(q_point) == evaluation_point)\\n\\u00a0                   break;\\n\\u00a0 \\nCheck that the evaluation point was indeed found,\\n\\u00a0               Assert(q_point < solution_gradients.size(), ExcInternalError());\\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\nand if so take the x-derivative of the gradient there as the value which we are interested in, and increase the counter indicating how often we have added to that variable:\\n\\u00a0               point_derivative += solution_gradients[q_point][0];\\n\\u00a0               ++evaluation_point_hits;\\n\\u00a0 \\nFinally break out of the innermost loop iterating over the vertices of the present cell, since if we have found the evaluation point at one vertex it cannot be at a following vertex as well:\\n\\u00a0               break;\\n\\u00a0             }\\n\\u00a0 \\nNow we have looped over all cells and vertices, so check whether the point was found:\\n\\u00a0       AssertThrow(evaluation_point_hits > 0,\\n\\u00a0                   ExcEvaluationPointNotFound(evaluation_point));\\n\\u00a0 \\nWe have simply summed up the contributions of all adjacent cells, so we still have to compute the mean value. Once this is done, report the status:\\n\\u00a0       point_derivative /= evaluation_point_hits;\\n\\u00a0       std::cout << \\\"   Point x-derivative=\\\" << point_derivative << std::endl;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n The GridOutput class\\nSince this program has a more difficult structure (it computed a dual solution in addition to a primal one), writing out the solution is no more done by an evaluation object since we want to write both solutions at once into one file, and that requires some more information than available to the evaluation classes.\\nHowever, we also want to look at the grids generated. This again can be done with one such class. Its structure is analog to the SolutionOutput class of the previous example program, so we do not discuss it here in more detail. Furthermore, everything that is used here has already been used in previous example programs.\\n\\u00a0     template <int dim>\\n\\u00a0     class GridOutput : public EvaluationBase<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       GridOutput(const std::string &output_name_base);\\n\\u00a0 \\n\\u00a0       virtual void operator()(const DoFHandler<dim> &dof_handler,\\n\\u00a0                               const Vector<double>  &solution) const override;\\n\\u00a0 \\n\\u00a0     private:\\n\\u00a0       const std::string output_name_base;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     GridOutput<dim>::GridOutput(const std::string &output_name_base)\\n\\u00a0       : output_name_base(output_name_base)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void GridOutput<dim>::operator()(const DoFHandler<dim> &dof_handler,\\n\\u00a0                                      const Vector<double> & /*solution*/) const\\n\\u00a0     {\\n\\u00a0       std::ofstream out(output_name_base + \\\"-\\\" +\\n\\u00a0                         std::to_string(this->refinement_cycle) + \\\".svg\\\");\\n\\u00a0       GridOut().write_svg(dof_handler.get_triangulation(), out);\\n\\u00a0     }\\n\\u00a0   } // namespace Evaluation\\n\\u00a0 \\n\\u00a0 \\nGridOutDefinition grid_out.h:993\\nGridOut::write_svgvoid write_svg(const Triangulation< 2, 2 > &tria, std::ostream &out) constDefinition grid_out.cc:1702\\nstdSTL namespace.\\n The Laplace solver classes\\nNext are the actual solver classes. Again, we discuss only the differences to the previous program.\\n\\u00a0   namespace LaplaceSolver\\n\\u00a0   {\\n The Laplace solver base class\\nThis class is almost unchanged, with the exception that it declares two more functions: output_solution will be used to generate output files from the actual solutions computed by derived classes, and the set_refinement_cycle function by which the testing framework sets the number of the refinement cycle to a local variable in this class; this number is later used to generate filenames for the solution output.\\n\\u00a0     template <int dim>\\n\\u00a0     class Base\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       Base(Triangulation<dim> &coarse_grid);\\n\\u00a0       virtual ~Base() = default;\\n\\u00a0 \\n\\u00a0       virtual void solve_problem() = 0;\\n\\u00a0       virtual void postprocess(\\n\\u00a0         const Evaluation::EvaluationBase<dim> &postprocessor) const = 0;\\n\\u00a0       virtual void         refine_grid()                            = 0;\\n\\u00a0       virtual unsigned int n_dofs() const                           = 0;\\n\\u00a0 \\n\\u00a0       virtual void set_refinement_cycle(const unsigned int cycle);\\n\\u00a0 \\n\\u00a0       virtual void output_solution() const = 0;\\n\\u00a0 \\n\\u00a0     protected:\\n\\u00a0       const SmartPointer<Triangulation<dim>> triangulation;\\n\\u00a0 \\n\\u00a0       unsigned int refinement_cycle;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     Base<dim>::Base(Triangulation<dim> &coarse_grid)\\n\\u00a0       : triangulation(&coarse_grid)\\n\\u00a0       , refinement_cycle(numbers::invalid_unsigned_int)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void Base<dim>::set_refinement_cycle(const unsigned int cycle)\\n\\u00a0     {\\n\\u00a0       refinement_cycle = cycle;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\nSmartPointerDefinition smartpointer.h:93\\nTriangulationDefinition tria.h:1323\\nnumbersDefinition numbers.h:230\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\n The Laplace Solver class\\nLikewise, the Solver class is entirely unchanged and will thus not be discussed.\\n\\u00a0     template <int dim>\\n\\u00a0     class Solver : public virtual Base<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       Solver(Triangulation<dim>        &triangulation,\\n\\u00a0              const FiniteElement<dim>  &fe,\\n\\u00a0              const Quadrature<dim>     &quadrature,\\n\\u00a0              const Quadrature<dim - 1> &face_quadrature,\\n\\u00a0              const Function<dim>       &boundary_values);\\n\\u00a0       virtual ~Solver() override;\\n\\u00a0 \\n\\u00a0       virtual void solve_problem() override;\\n\\u00a0 \\n\\u00a0       virtual void postprocess(\\n\\u00a0         const Evaluation::EvaluationBase<dim> &postprocessor) const override;\\n\\u00a0 \\n\\u00a0       virtual unsigned int n_dofs() const override;\\n\\u00a0 \\n\\u00a0     protected:\\n\\u00a0       const SmartPointer<const FiniteElement<dim>>  fe;\\n\\u00a0       const SmartPointer<const Quadrature<dim>>     quadrature;\\n\\u00a0       const SmartPointer<const Quadrature<dim - 1>> face_quadrature;\\n\\u00a0       DoFHandler<dim>                               dof_handler;\\n\\u00a0       Vector<double>                                solution;\\n\\u00a0       const SmartPointer<const Function<dim>>       boundary_values;\\n\\u00a0 \\n\\u00a0       virtual void assemble_rhs(Vector<double> &rhs) const = 0;\\n\\u00a0 \\n\\u00a0     private:\\n\\u00a0       struct LinearSystem\\n\\u00a0       {\\n\\u00a0         LinearSystem(const DoFHandler<dim> &dof_handler);\\n\\u00a0 \\n\\u00a0         void solve(Vector<double> &solution) const;\\n\\u00a0 \\n\\u00a0         AffineConstraints<double> hanging_node_constraints;\\n\\u00a0         SparsityPattern           sparsity_pattern;\\n\\u00a0         SparseMatrix<double>      matrix;\\n\\u00a0         Vector<double>            rhs;\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nFiniteElementDefinition fe.h:655\\nFunctionDefinition function.h:152\\nQuadratureDefinition quadrature.h:123\\nSparseMatrixDefinition sparse_matrix.h:520\\nSparsityPatternDefinition sparsity_pattern.h:343\\nThe remainder of the class is essentially a copy of step-13 as well, including the data structures and functions necessary to compute the linear system in parallel using the WorkStream framework:\\n\\u00a0       struct AssemblyScratchData\\n\\u00a0       {\\n\\u00a0         AssemblyScratchData(const FiniteElement<dim> &fe,\\n\\u00a0                             const Quadrature<dim>    &quadrature);\\n\\u00a0         AssemblyScratchData(const AssemblyScratchData &scratch_data);\\n\\u00a0 \\n\\u00a0         FEValues<dim> fe_values;\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0       struct AssemblyCopyData\\n\\u00a0       {\\n\\u00a0         FullMatrix<double>                   cell_matrix;\\n\\u00a0         std::vector<types::global_dof_index> local_dof_indices;\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0       void assemble_linear_system(LinearSystem &linear_system);\\n\\u00a0 \\n\\u00a0       void local_assemble_matrix(\\n\\u00a0         const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0         AssemblyScratchData                                  &scratch_data,\\n\\u00a0         AssemblyCopyData                                     &copy_data) const;\\n\\u00a0 \\n\\u00a0 \\n\\u00a0       void copy_local_to_global(const AssemblyCopyData &copy_data,\\n\\u00a0                                 LinearSystem           &linear_system) const;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     Solver<dim>::Solver(Triangulation<dim>        &triangulation,\\n\\u00a0                         const FiniteElement<dim>  &fe,\\n\\u00a0                         const Quadrature<dim>     &quadrature,\\n\\u00a0                         const Quadrature<dim - 1> &face_quadrature,\\n\\u00a0                         const Function<dim>       &boundary_values)\\n\\u00a0       : Base<dim>(triangulation)\\n\\u00a0       , fe(&fe)\\n\\u00a0       , quadrature(&quadrature)\\n\\u00a0       , face_quadrature(&face_quadrature)\\n\\u00a0       , dof_handler(triangulation)\\n\\u00a0       , boundary_values(&boundary_values)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     Solver<dim>::~Solver()\\n\\u00a0     {\\n\\u00a0       dof_handler.clear();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void Solver<dim>::solve_problem()\\n\\u00a0     {\\n\\u00a0       dof_handler.distribute_dofs(*fe);\\n\\u00a0       solution.reinit(dof_handler.n_dofs());\\n\\u00a0 \\n\\u00a0       LinearSystem linear_system(dof_handler);\\n\\u00a0       assemble_linear_system(linear_system);\\n\\u00a0       linear_system.solve(solution);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void Solver<dim>::postprocess(\\n\\u00a0       const Evaluation::EvaluationBase<dim> &postprocessor) const\\n\\u00a0     {\\n\\u00a0       postprocessor(dof_handler, solution);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     unsigned int Solver<dim>::n_dofs() const\\n\\u00a0     {\\n\\u00a0       return dof_handler.n_dofs();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\nFullMatrixDefinition full_matrix.h:79\\nDoFHandler::active_cell_iteratortypename ActiveSelector::active_cell_iterator active_cell_iteratorDefinition dof_handler.h:440\\nThe following few functions and constructors are verbatim copies taken from step-13:\\n\\u00a0     template <int dim>\\n\\u00a0     void Solver<dim>::assemble_linear_system(LinearSystem &linear_system)\\n\\u00a0     {\\n\\u00a0       Threads::Task<void> rhs_task =\\n\\u00a0         Threads::new_task(&Solver<dim>::assemble_rhs, *this, linear_system.rhs);\\n\\u00a0 \\n\\u00a0       auto worker =\\n\\u00a0         [this](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0                AssemblyScratchData &scratch_data,\\n\\u00a0                AssemblyCopyData    &copy_data) {\\n\\u00a0           this->local_assemble_matrix(cell, scratch_data, copy_data);\\n\\u00a0         };\\n\\u00a0 \\n\\u00a0       auto copier = [this, &linear_system](const AssemblyCopyData &copy_data) {\\n\\u00a0         this->copy_local_to_global(copy_data, linear_system);\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0       WorkStream::run(dof_handler.begin_active(),\\n\\u00a0                       dof_handler.end(),\\n\\u00a0                       worker,\\n\\u00a0                       copier,\\n\\u00a0                       AssemblyScratchData(*fe, *quadrature),\\n\\u00a0                       AssemblyCopyData());\\n\\u00a0       linear_system.hanging_node_constraints.condense(linear_system.matrix);\\n\\u00a0 \\n\\u00a0       std::map<types::global_dof_index, double> boundary_value_map;\\n\\u00a0       VectorTools::interpolate_boundary_values(dof_handler,\\n\\u00a0                                                0,\\n\\u00a0                                                *boundary_values,\\n\\u00a0                                                boundary_value_map);\\n\\u00a0 \\n\\u00a0       rhs_task.join();\\n\\u00a0       linear_system.hanging_node_constraints.condense(linear_system.rhs);\\n\\u00a0 \\n\\u00a0       MatrixTools::apply_boundary_values(boundary_value_map,\\n\\u00a0                                          linear_system.matrix,\\n\\u00a0                                          solution,\\n\\u00a0                                          linear_system.rhs);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     Solver<dim>::AssemblyScratchData::AssemblyScratchData(\\n\\u00a0       const FiniteElement<dim> &fe,\\n\\u00a0       const Quadrature<dim>    &quadrature)\\n\\u00a0       : fe_values(fe, quadrature, update_gradients | update_JxW_values)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     Solver<dim>::AssemblyScratchData::AssemblyScratchData(\\n\\u00a0       const AssemblyScratchData &scratch_data)\\n\\u00a0       : fe_values(scratch_data.fe_values.get_fe(),\\n\\u00a0                   scratch_data.fe_values.get_quadrature(),\\n\\u00a0                   update_gradients | update_JxW_values)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void Solver<dim>::local_assemble_matrix(\\n\\u00a0       const typename DoFHandler<dim>::active_cell_iterator &cell,\\n\\u00a0       AssemblyScratchData                                  &scratch_data,\\n\\u00a0       AssemblyCopyData                                     &copy_data) const\\n\\u00a0     {\\n\\u00a0       const unsigned int dofs_per_cell = fe->n_dofs_per_cell();\\n\\u00a0       const unsigned int n_q_points    = quadrature->size();\\n\\u00a0 \\n\\u00a0       copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);\\n\\u00a0 \\n\\u00a0       copy_data.local_dof_indices.resize(dofs_per_cell);\\n\\u00a0 \\n\\u00a0       scratch_data.fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0       for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n\\u00a0         for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0           for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0             copy_data.cell_matrix(i, j) +=\\n\\u00a0               (scratch_data.fe_values.shape_grad(i, q_point) *\\n\\u00a0                scratch_data.fe_values.shape_grad(j, q_point) *\\n\\u00a0                scratch_data.fe_values.JxW(q_point));\\n\\u00a0 \\n\\u00a0       cell->get_dof_indices(copy_data.local_dof_indices);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void Solver<dim>::copy_local_to_global(const AssemblyCopyData &copy_data,\\n\\u00a0                                            LinearSystem &linear_system) const\\n\\u00a0     {\\n\\u00a0       for (unsigned int i = 0; i < copy_data.local_dof_indices.size(); ++i)\\n\\u00a0         for (unsigned int j = 0; j < copy_data.local_dof_indices.size(); ++j)\\n\\u00a0           linear_system.matrix.add(copy_data.local_dof_indices[i],\\n\\u00a0                                    copy_data.local_dof_indices[j],\\n\\u00a0                                    copy_data.cell_matrix(i, j));\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\nThreads::TaskDefinition thread_management.h:489\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nThreads::new_taskTask< RT > new_task(const std::function< RT()> &function)Definition thread_management.h:1153\\nMatrixTools::apply_boundary_valuesvoid apply_boundary_values(const std::map< types::global_dof_index, number > &boundary_values, SparseMatrix< number > &matrix, Vector< number > &solution, Vector< number > &right_hand_side, const bool eliminate_columns=true)Definition matrix_tools.cc:75\\nVectorTools::interpolate_boundary_valuesvoid interpolate_boundary_values(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const std::map< types::boundary_id, const Function< spacedim, number > * > &function_map, std::map< types::global_dof_index, number > &boundary_values, const ComponentMask &component_mask={})\\nWorkStream::runvoid run(const std::vector< std::vector< Iterator > > &colored_iterators, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length=2 *MultithreadInfo::n_threads(), const unsigned int chunk_size=8)Definition work_stream.h:1272\\nNow for the functions that implement actions in the linear system class. First, the constructor initializes all data elements to their correct sizes, and sets up a number of additional data structures, such as constraints due to hanging nodes. Since setting up the hanging nodes and finding out about the nonzero elements of the matrix is independent, we do that in parallel (if the library was configured to use concurrency, at least; otherwise, the actions are performed sequentially). Note that we start only one thread, and do the second action in the main thread. Since only one thread is generated, we don't use the Threads::TaskGroup class here, but rather use the one created task object directly to wait for this particular task's exit. The approach is generally the same as the one we have used in Solver::assemble_linear_system() above.\\nNote that taking the address of the DoFTools::make_hanging_node_constraints function is a little tricky, since there are actually three functions of this name, one for each supported space dimension. Taking addresses of overloaded functions is somewhat complicated in C++, since the address-of operator & in that case returns a set of values (the addresses of all functions with that name), and selecting the right one is then the next step. If the context dictates which one to take (for example by assigning to a function pointer of known type), then the compiler can do that by itself, but if this set of pointers shall be given as the argument to a function that takes a template, the compiler could choose all without having a preference for one. We therefore have to make it clear to the compiler which one we would like to have; for this, we could use a cast, but for more clarity, we assign it to a temporary mhnc_p (short for pointer to make_hanging_node_constraints) with the right type, and using this pointer instead.\\n\\u00a0     template <int dim>\\n\\u00a0     Solver<dim>::LinearSystem::LinearSystem(const DoFHandler<dim> &dof_handler)\\n\\u00a0     {\\n\\u00a0       hanging_node_constraints.clear();\\n\\u00a0 \\n\\u00a0       void (*mhnc_p)(const DoFHandler<dim> &, AffineConstraints<double> &) =\\n\\u00a0         &DoFTools::make_hanging_node_constraints;\\n\\u00a0 \\nDoFTools::make_hanging_node_constraintsvoid make_hanging_node_constraints(const DoFHandler< dim, spacedim > &dof_handler, AffineConstraints< number > &constraints)Definition dof_tools_constraints.cc:3073\\nStart a side task then continue on the main thread\\n\\u00a0       Threads::Task<void> side_task =\\n\\u00a0         Threads::new_task(mhnc_p, dof_handler, hanging_node_constraints);\\n\\u00a0 \\n\\u00a0       DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());\\n\\u00a0       DoFTools::make_sparsity_pattern(dof_handler, dsp);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nDoFHandler::n_dofstypes::global_dof_index n_dofs() const\\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nWait for the side task to be done before going further\\n\\u00a0       side_task.join();\\n\\u00a0 \\n\\u00a0       hanging_node_constraints.close();\\n\\u00a0       hanging_node_constraints.condense(dsp);\\n\\u00a0       sparsity_pattern.copy_from(dsp);\\n\\u00a0 \\n\\u00a0       matrix.reinit(sparsity_pattern);\\n\\u00a0       rhs.reinit(dof_handler.n_dofs());\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void Solver<dim>::LinearSystem::solve(Vector<double> &solution) const\\n\\u00a0     {\\n\\u00a0       SolverControl            solver_control(5000, 1e-12);\\n\\u00a0       SolverCG<Vector<double>> cg(solver_control);\\n\\u00a0 \\n\\u00a0       PreconditionSSOR<SparseMatrix<double>> preconditioner;\\n\\u00a0       preconditioner.initialize(matrix, 1.2);\\n\\u00a0 \\n\\u00a0       cg.solve(matrix, solution, rhs, preconditioner);\\n\\u00a0 \\n\\u00a0       hanging_node_constraints.distribute(solution);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nPreconditionSSORDefinition precondition.h:1778\\nPreconditionSSOR::initializevoid initialize(const MatrixType &A, const AdditionalData &parameters=AdditionalData())\\nSolverCGDefinition solver_cg.h:179\\nSolverControlDefinition solver_control.h:67\\n The PrimalSolver class\\nThe PrimalSolver class is also mostly unchanged except for implementing the output_solution function. We keep the GlobalRefinement and RefinementKelly classes in this program, and they can then rely on the default implementation of this function which simply outputs the primal solution. The class implementing dual weighted error estimators will overload this function itself, to also output the dual solution.\\n\\u00a0     template <int dim>\\n\\u00a0     class PrimalSolver : public Solver<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       PrimalSolver(Triangulation<dim>        &triangulation,\\n\\u00a0                    const FiniteElement<dim>  &fe,\\n\\u00a0                    const Quadrature<dim>     &quadrature,\\n\\u00a0                    const Quadrature<dim - 1> &face_quadrature,\\n\\u00a0                    const Function<dim>       &rhs_function,\\n\\u00a0                    const Function<dim>       &boundary_values);\\n\\u00a0 \\n\\u00a0       virtual void output_solution() const override;\\n\\u00a0 \\n\\u00a0     protected:\\n\\u00a0       const SmartPointer<const Function<dim>> rhs_function;\\n\\u00a0       virtual void assemble_rhs(Vector<double> &rhs) const override;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     PrimalSolver<dim>::PrimalSolver(Triangulation<dim>        &triangulation,\\n\\u00a0                                     const FiniteElement<dim>  &fe,\\n\\u00a0                                     const Quadrature<dim>     &quadrature,\\n\\u00a0                                     const Quadrature<dim - 1> &face_quadrature,\\n\\u00a0                                     const Function<dim>       &rhs_function,\\n\\u00a0                                     const Function<dim>       &boundary_values)\\n\\u00a0       : Base<dim>(triangulation)\\n\\u00a0       , Solver<dim>(triangulation,\\n\\u00a0                     fe,\\n\\u00a0                     quadrature,\\n\\u00a0                     face_quadrature,\\n\\u00a0                     boundary_values)\\n\\u00a0       , rhs_function(&rhs_function)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void PrimalSolver<dim>::output_solution() const\\n\\u00a0     {\\n\\u00a0       DataOut<dim> data_out;\\n\\u00a0       data_out.attach_dof_handler(this->dof_handler);\\n\\u00a0       data_out.add_data_vector(this->solution, \\\"solution\\\");\\n\\u00a0       data_out.build_patches();\\n\\u00a0 \\n\\u00a0       std::ofstream out(\\\"solution-\\\" + std::to_string(this->refinement_cycle) +\\n\\u00a0                         \\\".vtu\\\");\\n\\u00a0       data_out.write(out, DataOutBase::vtu);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void PrimalSolver<dim>::assemble_rhs(Vector<double> &rhs) const\\n\\u00a0     {\\n\\u00a0       FEValues<dim> fe_values(*this->fe,\\n\\u00a0                               *this->quadrature,\\n\\u00a0                               update_values | update_quadrature_points |\\n\\u00a0                                 update_JxW_values);\\n\\u00a0 \\n\\u00a0       const unsigned int dofs_per_cell = this->fe->n_dofs_per_cell();\\n\\u00a0       const unsigned int n_q_points    = this->quadrature->size();\\n\\u00a0 \\n\\u00a0       Vector<double>                       cell_rhs(dofs_per_cell);\\n\\u00a0       std::vector<double>                  rhs_values(n_q_points);\\n\\u00a0       std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0       for (const auto &cell : this->dof_handler.active_cell_iterators())\\n\\u00a0         {\\n\\u00a0           cell_rhs = 0;\\n\\u00a0 \\n\\u00a0           fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0           rhs_function->value_list(fe_values.get_quadrature_points(),\\n\\u00a0                                    rhs_values);\\n\\u00a0 \\n\\u00a0           for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n\\u00a0             for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0               cell_rhs(i) += (fe_values.shape_value(i, q_point) * // phi_i(x_q)\\n\\u00a0                               rhs_values[q_point] *               // f((x_q)\\n\\u00a0                               fe_values.JxW(q_point));            // dx\\n\\u00a0 \\n\\u00a0           cell->get_dof_indices(local_dof_indices);\\n\\u00a0           for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0             rhs(local_dof_indices[i]) += cell_rhs(i);\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nDataOutBase::vtu@ vtuDefinition data_out_base.h:1667\\n The RefinementGlobal and RefinementKelly classes\\nFor the following two classes, the same applies as for most of the above: the class is taken from the previous example as-is:\\n\\u00a0     template <int dim>\\n\\u00a0     class RefinementGlobal : public PrimalSolver<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       RefinementGlobal(Triangulation<dim>        &coarse_grid,\\n\\u00a0                        const FiniteElement<dim>  &fe,\\n\\u00a0                        const Quadrature<dim>     &quadrature,\\n\\u00a0                        const Quadrature<dim - 1> &face_quadrature,\\n\\u00a0                        const Function<dim>       &rhs_function,\\n\\u00a0                        const Function<dim>       &boundary_values);\\n\\u00a0 \\n\\u00a0       virtual void refine_grid() override;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     RefinementGlobal<dim>::RefinementGlobal(\\n\\u00a0       Triangulation<dim>        &coarse_grid,\\n\\u00a0       const FiniteElement<dim>  &fe,\\n\\u00a0       const Quadrature<dim>     &quadrature,\\n\\u00a0       const Quadrature<dim - 1> &face_quadrature,\\n\\u00a0       const Function<dim>       &rhs_function,\\n\\u00a0       const Function<dim>       &boundary_values)\\n\\u00a0       : Base<dim>(coarse_grid)\\n\\u00a0       , PrimalSolver<dim>(coarse_grid,\\n\\u00a0                           fe,\\n\\u00a0                           quadrature,\\n\\u00a0                           face_quadrature,\\n\\u00a0                           rhs_function,\\n\\u00a0                           boundary_values)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void RefinementGlobal<dim>::refine_grid()\\n\\u00a0     {\\n\\u00a0       this->triangulation->refine_global(1);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     class RefinementKelly : public PrimalSolver<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       RefinementKelly(Triangulation<dim>        &coarse_grid,\\n\\u00a0                       const FiniteElement<dim>  &fe,\\n\\u00a0                       const Quadrature<dim>     &quadrature,\\n\\u00a0                       const Quadrature<dim - 1> &face_quadrature,\\n\\u00a0                       const Function<dim>       &rhs_function,\\n\\u00a0                       const Function<dim>       &boundary_values);\\n\\u00a0 \\n\\u00a0       virtual void refine_grid() override;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     RefinementKelly<dim>::RefinementKelly(\\n\\u00a0       Triangulation<dim>        &coarse_grid,\\n\\u00a0       const FiniteElement<dim>  &fe,\\n\\u00a0       const Quadrature<dim>     &quadrature,\\n\\u00a0       const Quadrature<dim - 1> &face_quadrature,\\n\\u00a0       const Function<dim>       &rhs_function,\\n\\u00a0       const Function<dim>       &boundary_values)\\n\\u00a0       : Base<dim>(coarse_grid)\\n\\u00a0       , PrimalSolver<dim>(coarse_grid,\\n\\u00a0                           fe,\\n\\u00a0                           quadrature,\\n\\u00a0                           face_quadrature,\\n\\u00a0                           rhs_function,\\n\\u00a0                           boundary_values)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void RefinementKelly<dim>::refine_grid()\\n\\u00a0     {\\n\\u00a0       Vector<float> estimated_error_per_cell(\\n\\u00a0         this->triangulation->n_active_cells());\\n\\u00a0       KellyErrorEstimator<dim>::estimate(\\n\\u00a0         this->dof_handler,\\n\\u00a0         QGauss<dim - 1>(this->fe->degree + 1),\\n\\u00a0         std::map<types::boundary_id, const Function<dim> *>(),\\n\\u00a0         this->solution,\\n\\u00a0         estimated_error_per_cell);\\n\\u00a0       GridRefinement::refine_and_coarsen_fixed_number(*this->triangulation,\\n\\u00a0                                                       estimated_error_per_cell,\\n\\u00a0                                                       0.3,\\n\\u00a0                                                       0.03);\\n\\u00a0       this->triangulation->execute_coarsening_and_refinement();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nKellyErrorEstimator::estimatestatic void estimate(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const Quadrature< dim - 1 > &quadrature, const std::map< types::boundary_id, const Function< spacedim, Number > * > &neumann_bc, const ReadVector< Number > &solution, Vector< float > &error, const ComponentMask &component_mask={}, const Function< spacedim > *coefficients=nullptr, const unsigned int n_threads=numbers::invalid_unsigned_int, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id, const types::material_id material_id=numbers::invalid_material_id, const Strategy strategy=cell_diameter_over_24)\\nQGaussDefinition quadrature_lib.h:40\\nTriangulation::execute_coarsening_and_refinementvirtual void execute_coarsening_and_refinement()\\nunsigned int\\nGridRefinement::refine_and_coarsen_fixed_numbervoid refine_and_coarsen_fixed_number(Triangulation< dim, spacedim > &triangulation, const Vector< Number > &criteria, const double top_fraction_of_cells, const double bottom_fraction_of_cells, const unsigned int max_n_cells=std::numeric_limits< unsigned int >::max())Definition grid_refinement.cc:318\\ninternal::TriangulationImplementation::n_active_cellsunsigned int n_active_cells(const internal::TriangulationImplementation::NumberCache< 1 > &c)Definition tria.cc:14890\\n The RefinementWeightedKelly class\\nThis class is a variant of the previous one, in that it allows to weight the refinement indicators we get from the library's Kelly indicator by some function. We include this class since the goal of this example program is to demonstrate automatic refinement criteria even for complex output quantities such as point values or stresses. If we did not solve a dual problem and compute the weights thereof, we would probably be tempted to give a hand-crafted weighting to the indicators to account for the fact that we are going to evaluate these quantities. This class accepts such a weighting function as argument to its constructor:\\n\\u00a0     template <int dim>\\n\\u00a0     class RefinementWeightedKelly : public PrimalSolver<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       RefinementWeightedKelly(Triangulation<dim>        &coarse_grid,\\n\\u00a0                               const FiniteElement<dim>  &fe,\\n\\u00a0                               const Quadrature<dim>     &quadrature,\\n\\u00a0                               const Quadrature<dim - 1> &face_quadrature,\\n\\u00a0                               const Function<dim>       &rhs_function,\\n\\u00a0                               const Function<dim>       &boundary_values,\\n\\u00a0                               const Function<dim>       &weighting_function);\\n\\u00a0 \\n\\u00a0       virtual void refine_grid() override;\\n\\u00a0 \\n\\u00a0     private:\\n\\u00a0       const SmartPointer<const Function<dim>> weighting_function;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     RefinementWeightedKelly<dim>::RefinementWeightedKelly(\\n\\u00a0       Triangulation<dim>        &coarse_grid,\\n\\u00a0       const FiniteElement<dim>  &fe,\\n\\u00a0       const Quadrature<dim>     &quadrature,\\n\\u00a0       const Quadrature<dim - 1> &face_quadrature,\\n\\u00a0       const Function<dim>       &rhs_function,\\n\\u00a0       const Function<dim>       &boundary_values,\\n\\u00a0       const Function<dim>       &weighting_function)\\n\\u00a0       : Base<dim>(coarse_grid)\\n\\u00a0       , PrimalSolver<dim>(coarse_grid,\\n\\u00a0                           fe,\\n\\u00a0                           quadrature,\\n\\u00a0                           face_quadrature,\\n\\u00a0                           rhs_function,\\n\\u00a0                           boundary_values)\\n\\u00a0       , weighting_function(&weighting_function)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nNow, here comes the main function, including the weighting:\\n\\u00a0     template <int dim>\\n\\u00a0     void RefinementWeightedKelly<dim>::refine_grid()\\n\\u00a0     {\\nFirst compute some residual based error indicators for all cells by a method already implemented in the library. What exactly we compute here is described in more detail in the documentation of that class.\\n\\u00a0       Vector<float> estimated_error_per_cell(\\n\\u00a0         this->triangulation->n_active_cells());\\n\\u00a0       std::map<types::boundary_id, const Function<dim> *> dummy_function_map;\\n\\u00a0       KellyErrorEstimator<dim>::estimate(this->dof_handler,\\n\\u00a0                                          *this->face_quadrature,\\n\\u00a0                                          dummy_function_map,\\n\\u00a0                                          this->solution,\\n\\u00a0                                          estimated_error_per_cell);\\n\\u00a0 \\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nNext weigh each entry in the vector of indicators by the value of the function given to the constructor, evaluated at the cell center. We need to write the result into the vector entry that corresponds to the current cell, which we can obtain by asking the cell what its index among all active cells is using CellAccessor::active_cell_index(). (In reality, this index is zero for the first cell we handle in the loop, one for the second cell, etc., and we could as well just keep track of this index using an integer counter; but using CellAccessor::active_cell_index() makes this more explicit.)\\n\\u00a0       for (const auto &cell : this->dof_handler.active_cell_iterators())\\n\\u00a0         estimated_error_per_cell(cell->active_cell_index()) *=\\n\\u00a0           weighting_function->value(cell->center());\\n\\u00a0 \\n\\u00a0       GridRefinement::refine_and_coarsen_fixed_number(*this->triangulation,\\n\\u00a0                                                       estimated_error_per_cell,\\n\\u00a0                                                       0.3,\\n\\u00a0                                                       0.03);\\n\\u00a0       this->triangulation->execute_coarsening_and_refinement();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   } // namespace LaplaceSolver\\n\\u00a0 \\n\\u00a0 \\ncenterPoint< 3 > centerDefinition data_out_base.cc:267\\n Equation data\\nIn this example program, we work with the same data sets as in the previous one, but as it may so happen that someone wants to run the program with different boundary values and right hand side functions, or on a different grid, we show a simple technique to do exactly that. For more clarity, we furthermore pack everything that has to do with equation data into a namespace of its own.\\nThe underlying assumption is that this is a research program, and that there we often have a number of test cases that consist of a domain, a right hand side, boundary values, possibly a specified coefficient, and a number of other parameters. They often vary all at the same time when shifting from one example to another. To make handling such sets of problem description parameters simple is the goal of the following.\\nBasically, the idea is this: let us have a structure for each set of data, in which we pack everything that describes a test case: here, these are two subclasses, one called BoundaryValues for the boundary values of the exact solution, and one called RightHandSide, and then a way to generate the coarse grid. Since the solution of the previous example program looked like curved ridges, we use this name here for the enclosing class. Note that the names of the two inner classes have to be the same for all enclosing test case classes, and also that we have attached the dimension template argument to the enclosing class rather than to the inner ones, to make further processing simpler. (From a language viewpoint, a namespace would be better to encapsulate these inner classes, rather than a structure. However, namespaces cannot be given as template arguments, so we use a structure to allow a second object to select from within its given argument. The enclosing structure, of course, has no member variables apart from the classes it declares, and a static function to generate the coarse mesh; it will in general never be instantiated.)\\nThe idea is then the following (this is the right time to also take a brief look at the code below): we can generate objects for boundary values and right hand side by simply giving the name of the outer class as a template argument to a class which we call here Data::SetUp, and it then creates objects for the inner classes. In this case, to get all that characterizes the curved ridge solution, we would simply generate an instance of Data::SetUp<Data::CurvedRidge>, and everything we need to know about the solution would be static member variables and functions of that object.\\nThis approach might seem like overkill in this case, but will become very handy once a certain set up is not only characterized by Dirichlet boundary values and a right hand side function, but in addition by material properties, Neumann values, different boundary descriptors, etc. In that case, the SetUp class might consist of a dozen or more objects, and each descriptor class (like the CurvedRidges class below) would have to provide them. Then, you will be happy to be able to change from one set of data to another by only changing the template argument to the SetUp class at one place, rather than at many.\\nWith this framework for different test cases, we are almost finished, but one thing remains: by now we can select statically, by changing one template argument, which data set to choose. In order to be able to do that dynamically, i.e. at run time, we need a base class. This we provide in the obvious way, see below, with virtual abstract functions. It forces us to introduce a second template parameter dim which we need for the base class (which could be avoided using some template magic, but we omit that), but that's all.\\nAdding new testcases is now simple, you don't have to touch the framework classes, only a structure like the CurvedRidges one is needed.\\n\\u00a0   namespace Data\\n\\u00a0   {\\n The SetUpBase and SetUp classes\\nBased on the above description, the SetUpBase class then looks as follows. To allow using the SmartPointer class with this class, we derived from the Subscriptor class.\\n\\u00a0     template <int dim>\\n\\u00a0     struct SetUpBase : public Subscriptor\\n\\u00a0     {\\n\\u00a0       virtual const Function<dim> &get_boundary_values() const = 0;\\n\\u00a0 \\n\\u00a0       virtual const Function<dim> &get_right_hand_side() const = 0;\\n\\u00a0 \\n\\u00a0       virtual void\\n\\u00a0       create_coarse_grid(Triangulation<dim> &coarse_grid) const = 0;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\nSubscriptorDefinition subscriptor.h:60\\nAnd now for the derived class that takes the template argument as explained above.\\nHere we pack the data elements into private variables, and allow access to them through the methods of the base class.\\n\\u00a0     template <class Traits, int dim>\\n\\u00a0     struct SetUp : public SetUpBase<dim>\\n\\u00a0     {\\n\\u00a0       virtual const Function<dim> &get_boundary_values() const override;\\n\\u00a0 \\n\\u00a0       virtual const Function<dim> &get_right_hand_side() const override;\\n\\u00a0 \\n\\u00a0 \\n\\u00a0       virtual void\\n\\u00a0       create_coarse_grid(Triangulation<dim> &coarse_grid) const override;\\n\\u00a0 \\n\\u00a0     private:\\n\\u00a0       static const typename Traits::BoundaryValues boundary_values;\\n\\u00a0       static const typename Traits::RightHandSide  right_hand_side;\\n\\u00a0     };\\n\\u00a0 \\nWe have to provide definitions for the static member variables of the above class:\\n\\u00a0     template <class Traits, int dim>\\n\\u00a0     const typename Traits::BoundaryValues SetUp<Traits, dim>::boundary_values;\\n\\u00a0     template <class Traits, int dim>\\n\\u00a0     const typename Traits::RightHandSide SetUp<Traits, dim>::right_hand_side;\\n\\u00a0 \\nAnd definitions of the member functions:\\n\\u00a0     template <class Traits, int dim>\\n\\u00a0     const Function<dim> &SetUp<Traits, dim>::get_boundary_values() const\\n\\u00a0     {\\n\\u00a0       return boundary_values;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <class Traits, int dim>\\n\\u00a0     const Function<dim> &SetUp<Traits, dim>::get_right_hand_side() const\\n\\u00a0     {\\n\\u00a0       return right_hand_side;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <class Traits, int dim>\\n\\u00a0     void SetUp<Traits, dim>::create_coarse_grid(\\n\\u00a0       Triangulation<dim> &coarse_grid) const\\n\\u00a0     {\\n\\u00a0       Traits::create_coarse_grid(coarse_grid);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n The CurvedRidges class\\nThe class that is used to describe the boundary values and right hand side of the curved ridge problem already used in the step-13 example program is then like so:\\n\\u00a0     template <int dim>\\n\\u00a0     struct CurvedRidges\\n\\u00a0     {\\n\\u00a0       class BoundaryValues : public Function<dim>\\n\\u00a0       {\\n\\u00a0       public:\\n\\u00a0         virtual double value(const Point<dim>  &p,\\n\\u00a0                              const unsigned int component) const;\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0       class RightHandSide : public Function<dim>\\n\\u00a0       {\\n\\u00a0       public:\\n\\u00a0         virtual double value(const Point<dim>  &p,\\n\\u00a0                              const unsigned int component) const;\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0       static void create_coarse_grid(Triangulation<dim> &coarse_grid);\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double CurvedRidges<dim>::BoundaryValues::value(\\n\\u00a0       const Point<dim> &p,\\n\\u00a0       const unsigned int /*component*/) const\\n\\u00a0     {\\n\\u00a0       double q = p(0);\\n\\u00a0       for (unsigned int i = 1; i < dim; ++i)\\n\\u00a0         q += std::sin(10 * p(i) + 5 * p(0) * p(0));\\n\\u00a0       const double exponential = std::exp(q);\\n\\u00a0       return exponential;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double CurvedRidges<dim>::RightHandSide::value(\\n\\u00a0       const Point<dim> &p,\\n\\u00a0       const unsigned int /*component*/) const\\n\\u00a0     {\\n\\u00a0       double q = p(0);\\n\\u00a0       for (unsigned int i = 1; i < dim; ++i)\\n\\u00a0         q += std::sin(10 * p(i) + 5 * p(0) * p(0));\\n\\u00a0       const double u  = std::exp(q);\\n\\u00a0       double       t1 = 1, t2 = 0, t3 = 0;\\n\\u00a0       for (unsigned int i = 1; i < dim; ++i)\\n\\u00a0         {\\n\\u00a0           t1 += std::cos(10 * p(i) + 5 * p(0) * p(0)) * 10 * p(0);\\n\\u00a0           t2 += 10 * std::cos(10 * p(i) + 5 * p(0) * p(0)) -\\n\\u00a0                 100 * std::sin(10 * p(i) + 5 * p(0) * p(0)) * p(0) * p(0);\\n\\u00a0           t3 += 100 * std::cos(10 * p(i) + 5 * p(0) * p(0)) *\\n\\u00a0                   std::cos(10 * p(i) + 5 * p(0) * p(0)) -\\n\\u00a0                 100 * std::sin(10 * p(i) + 5 * p(0) * p(0));\\n\\u00a0         }\\n\\u00a0       t1 = t1 * t1;\\n\\u00a0 \\n\\u00a0       return -u * (t1 + t2 + t3);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void CurvedRidges<dim>::create_coarse_grid(Triangulation<dim> &coarse_grid)\\n\\u00a0     {\\n\\u00a0       GridGenerator::hyper_cube(coarse_grid, -1, 1);\\n\\u00a0       coarse_grid.refine_global(2);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nGridGenerator::hyper_cubevoid hyper_cube(Triangulation< dim, spacedim > &tria, const double left=0., const double right=1., const bool colorize=false)\\nstd::exp::VectorizedArray< Number, width > exp(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6829\\nstd::cos::VectorizedArray< Number, width > cos(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6609\\nstd::sin::VectorizedArray< Number, width > sin(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6589\\n The Exercise_2_3 class\\nThis example program was written while giving practical courses for a lecture on adaptive finite element methods and duality based error estimates. For these courses, we had one exercise, which required to solve the Laplace equation with constant right hand side on a square domain with a square hole in the center, and zero boundary values. Since the implementation of the properties of this problem is so particularly simple here, lets do it. As the number of the exercise was 2.3, we take the liberty to retain this name for the class as well.\\n\\u00a0     template <int dim>\\n\\u00a0     struct Exercise_2_3\\n\\u00a0     {\\nWe need a class to denote the boundary values of the problem. In this case, this is simple: it's the zero function, so don't even declare a class, just an alias:\\n\\u00a0       using BoundaryValues = Functions::ZeroFunction<dim>;\\n\\u00a0 \\nFunctions::ZeroFunctionDefinition function.h:510\\nSecond, a class that denotes the right hand side. Since they are constant, just subclass the corresponding class of the library and be done:\\n\\u00a0       class RightHandSide : public Functions::ConstantFunction<dim>\\n\\u00a0       {\\n\\u00a0       public:\\n\\u00a0         RightHandSide()\\n\\u00a0           : Functions::ConstantFunction<dim>(1.)\\n\\u00a0         {}\\n\\u00a0       };\\n\\u00a0 \\nFunctions::ConstantFunctionDefinition function.h:410\\nFunctionsDefinition flow_function.h:28\\nFinally a function to generate the coarse grid. This is somewhat more complicated here, see immediately below.\\n\\u00a0       static void create_coarse_grid(Triangulation<dim> &coarse_grid);\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\nAs stated above, the grid for this example is the square [-1,1]^2 with the square [-1/2,1/2]^2 as hole in it. We create the coarse grid as 4 times 4 cells with the middle four ones missing. To understand how exactly the mesh is going to look, it may be simplest to just look at the \\\"Results\\\" section of this tutorial program first. In general, if you'd like to understand more about creating meshes either from scratch by hand, as we do here, or using other techniques, you should take a look at step-49.\\nOf course, the example has an extension to 3d, but since this function cannot be written in a dimension independent way we choose not to implement this here, but rather only specialize the template for dim=2. If you compile the program for 3d, you'll get a message from the linker that this function is not implemented for 3d, and needs to be provided.\\nFor the creation of this geometry, the library has no predefined method. In this case, the geometry is still simple enough to do the creation by hand, rather than using a mesh generator.\\n\\u00a0     template <>\\n\\u00a0     void Exercise_2_3<2>::create_coarse_grid(Triangulation<2> &coarse_grid)\\n\\u00a0     {\\nWe first define the space dimension, to allow those parts of the function that are actually dimension independent to use this variable. That makes it simpler if you later take this as a starting point to implement a 3d version of this mesh. The next step is then to have a list of vertices. Here, they are 24 (5 times 5, with the middle one omitted). It is probably best to draw a sketch here.\\n\\u00a0       const unsigned int dim = 2;\\n\\u00a0 \\n\\u00a0       const std::vector<Point<2>> vertices = {\\n\\u00a0         {-1.0, -1.0}, {-0.5, -1.0}, {+0.0, -1.0}, {+0.5, -1.0}, {+1.0, -1.0}, \\n\\u00a0         {-1.0, -0.5}, {-0.5, -0.5}, {+0.0, -0.5}, {+0.5, -0.5}, {+1.0, -0.5}, \\n\\u00a0         {-1.0, +0.0}, {-0.5, +0.0}, {+0.5, +0.0}, {+1.0, +0.0},               \\n\\u00a0         {-1.0, +0.5}, {-0.5, +0.5}, {+0.0, +0.5}, {+0.5, +0.5}, {+1.0, +0.5}, \\n\\u00a0         {-1.0, +1.0}, {-0.5, +1.0}, {+0.0, +1.0}, {+0.5, +1.0}, {+1.0, +1.0}};\\n\\u00a0 \\nverticesPoint< 3 > vertices[4]Definition data_out_base.cc:272\\nNext, we have to define the cells and the vertices they contain.\\n\\u00a0       const std::vector<std::array<int, GeometryInfo<dim>::vertices_per_cell>>\\n\\u00a0         cell_vertices = {{{0, 1, 5, 6}},\\n\\u00a0                          {{1, 2, 6, 7}},\\n\\u00a0                          {{2, 3, 7, 8}},\\n\\u00a0                          {{3, 4, 8, 9}},\\n\\u00a0                          {{5, 6, 10, 11}},\\n\\u00a0                          {{8, 9, 12, 13}},\\n\\u00a0                          {{10, 11, 14, 15}},\\n\\u00a0                          {{12, 13, 17, 18}},\\n\\u00a0                          {{14, 15, 19, 20}},\\n\\u00a0                          {{15, 16, 20, 21}},\\n\\u00a0                          {{16, 17, 21, 22}},\\n\\u00a0                          {{17, 18, 22, 23}}};\\n\\u00a0 \\n\\u00a0       const unsigned int n_cells = cell_vertices.size();\\n\\u00a0 \\ninternal::TriangulationImplementation::n_cellsunsigned int n_cells(const internal::TriangulationImplementation::NumberCache< 1 > &c)Definition tria.cc:14883\\nAgain, we generate a C++ vector type from this, but this time by looping over the cells (yes, this is boring). Additionally, we set the material indicator to zero for all the cells:\\n\\u00a0       std::vector<CellData<dim>> cells(n_cells, CellData<dim>());\\n\\u00a0       for (unsigned int i = 0; i < n_cells; ++i)\\n\\u00a0         {\\n\\u00a0           for (unsigned int j = 0; j < cell_vertices[i].size(); ++j)\\n\\u00a0             cells[i].vertices[j] = cell_vertices[i][j];\\n\\u00a0           cells[i].material_id = 0;\\n\\u00a0         }\\n\\u00a0 \\nCellDataDefinition tria_description.h:79\\nFinally pass all this information to the library to generate a triangulation. The right call for this is Triangulation::create_triangulation(), but that function wants its input in a format in which cells are consistently oriented in some way. It turns out that the mesh we describe with the vertices and cells objects above already is consistently oriented, but if you modify the code in some way it may not be any more, and so it is good practice to call a function that ensures it is \\u2013 GridTools::consistently_order_cells() does this.\\nThe last parameter of the call to Triangulation::create_triangulation() below describes what we want to do about boundary and manifold indicators on boundary faces. Here, we don't want to do anything specific (in particular, we are fine with labeling all boundaries with boundary indicator zero, and so we call the function with an empty object as the last argument:\\n\\u00a0       GridTools::consistently_order_cells(cells);\\n\\u00a0       coarse_grid.create_triangulation(vertices, cells, SubCellData());\\n\\u00a0 \\nTriangulation::create_triangulationvirtual void create_triangulation(const std::vector< Point< spacedim > > &vertices, const std::vector< CellData< dim > > &cells, const SubCellData &subcelldata)\\nGridTools::consistently_order_cellsvoid consistently_order_cells(std::vector< CellData< dim > > &cells)Definition grid_tools_topology.cc:1615\\nSubCellDataDefinition tria_description.h:238\\nAnd since we want that the evaluation point (3/4,3/4) in this example is a grid point, we refine once globally:\\n\\u00a0       coarse_grid.refine_global(1);\\n\\u00a0     }\\n\\u00a0   } // namespace Data\\n\\u00a0 \\n Discussion\\nAs you have now read through this framework, you may be wondering why we have not chosen to implement the classes implementing a certain setup (like the CurvedRidges class) directly as classes derived from Data::SetUpBase. Indeed, we could have done very well so. The only reason is that then we would have to have member variables for the solution and right hand side classes in the CurvedRidges class, as well as member functions overloading the abstract functions of the base class giving access to these member variables. The SetUp class has the sole reason to relieve us from the need to reiterate these member variables and functions that would be necessary in all such classes. In some way, the template mechanism here only provides a way to have default implementations for a number of functions that depend on external quantities and can thus not be provided using normal virtual functions, at least not without the help of templates.\\nHowever, there might be good reasons to actually implement classes derived from Data::SetUpBase, for example if the solution or right hand side classes require constructors that take arguments, which the Data::SetUpBase class cannot provide. In that case, subclassing is a worthwhile strategy. Other possibilities for special cases are to derive from Data::SetUp<SomeSetUp> where SomeSetUp denotes a class, or even to explicitly specialize Data::SetUp<SomeSetUp>. The latter allows to transparently use the way the SetUp class is used for other set-ups, but with special actions taken for special arguments.\\nA final observation favoring the approach taken here is the following: we have found numerous times that when starting a project, the number of parameters (usually boundary values, right hand side, coarse grid, just as here) was small, and the number of test cases was small as well. One then starts out by handcoding them into a number of switch statements. Over time, projects grow, and so does the number of test cases. The number of switch statements grows with that, and their length as well, and one starts to find ways to consider impossible examples where domains, boundary values, and right hand sides do not fit together any more, and starts losing the overview over the whole structure. Encapsulating everything belonging to a certain test case into a structure of its own has proven worthwhile for this, as it keeps everything that belongs to one test case in one place. Furthermore, it allows to put these things all in one or more files that are only devoted to test cases and their data, without having to bring their actual implementation into contact with the rest of the program.\\n Dual functionals\\nAs with the other components of the program, we put everything we need to describe dual functionals into a namespace of its own, and define an abstract base class that provides the interface the class solving the dual problem needs for its work.\\nWe will then implement two such classes, for the evaluation of a point value and of the derivative of the solution at that point. For these functionals we already have the corresponding evaluation objects, so they are complementary.\\n\\u00a0   namespace DualFunctional\\n\\u00a0   {\\n The DualFunctionalBase class\\nFirst start with the base class for dual functionals. Since for linear problems the characteristics of the dual problem play a role only in the right hand side, we only need to provide for a function that assembles the right hand side for a given discretization:\\n\\u00a0     template <int dim>\\n\\u00a0     class DualFunctionalBase : public Subscriptor\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       virtual void assemble_rhs(const DoFHandler<dim> &dof_handler,\\n\\u00a0                                 Vector<double>        &rhs) const = 0;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n The dual functional PointValueEvaluation class\\nAs a first application, we consider the functional corresponding to the evaluation of the solution's value at a given point which again we assume to be a vertex. Apart from the constructor that takes and stores the evaluation point, this class consists only of the function that implements assembling the right hand side.\\n\\u00a0     template <int dim>\\n\\u00a0     class PointValueEvaluation : public DualFunctionalBase<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       PointValueEvaluation(const Point<dim> &evaluation_point);\\n\\u00a0 \\n\\u00a0       virtual void assemble_rhs(const DoFHandler<dim> &dof_handler,\\n\\u00a0                                 Vector<double>        &rhs) const override;\\n\\u00a0 \\n\\u00a0       DeclException1(\\n\\u00a0         ExcEvaluationPointNotFound,\\n\\u00a0         Point<dim>,\\n\\u00a0         << \\\"The evaluation point \\\" << arg1\\n\\u00a0         << \\\" was not found among the vertices of the present grid.\\\");\\n\\u00a0 \\n\\u00a0     protected:\\n\\u00a0       const Point<dim> evaluation_point;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     PointValueEvaluation<dim>::PointValueEvaluation(\\n\\u00a0       const Point<dim> &evaluation_point)\\n\\u00a0       : evaluation_point(evaluation_point)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\nAs for doing the main purpose of the class, assembling the right hand side, let us first consider what is necessary: The right hand side of the dual problem is a vector of values J(phi_i), where J is the error functional, and phi_i is the i-th shape function. Here, J is the evaluation at the point x0, i.e. J(phi_i)=phi_i(x0).\\nNow, we have assumed that the evaluation point is a vertex. Thus, for the usual finite elements we might be using in this program, we can take for granted that at such a point exactly one shape function is nonzero, and in particular has the value one. Thus, we set the right hand side vector to all-zeros, then seek for the shape function associated with that point and set the corresponding value of the right hand side vector to one:\\n\\u00a0     template <int dim>\\n\\u00a0     void\\n\\u00a0     PointValueEvaluation<dim>::assemble_rhs(const DoFHandler<dim> &dof_handler,\\n\\u00a0                                             Vector<double>        &rhs) const\\n\\u00a0     {\\nSo, first set everything to zeros...\\n\\u00a0       rhs.reinit(dof_handler.n_dofs());\\n\\u00a0 \\n...then loop over cells and find the evaluation point among the vertices (or very close to a vertex, which may happen due to floating point round-off):\\n\\u00a0       for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0         for (const auto vertex : cell->vertex_indices())\\n\\u00a0           if (cell->vertex(vertex).distance(evaluation_point) <\\n\\u00a0               cell->diameter() * 1e-8)\\n\\u00a0             {\\nOk, found, so set corresponding entry, and leave function since we are finished:\\n\\u00a0               rhs(cell->vertex_dof_index(vertex, 0)) = 1;\\n\\u00a0               return;\\n\\u00a0             }\\n\\u00a0 \\nFinally, a sanity check: if we somehow got here, then we must have missed the evaluation point, so raise an exception unconditionally:\\n\\u00a0       AssertThrow(false, ExcEvaluationPointNotFound(evaluation_point));\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n The dual functional PointXDerivativeEvaluation class\\nAs second application, we again consider the evaluation of the x-derivative of the solution at one point. Again, the declaration of the class, and the implementation of its constructor is not too interesting:\\n\\u00a0     template <int dim>\\n\\u00a0     class PointXDerivativeEvaluation : public DualFunctionalBase<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       PointXDerivativeEvaluation(const Point<dim> &evaluation_point);\\n\\u00a0 \\n\\u00a0       virtual void assemble_rhs(const DoFHandler<dim> &dof_handler,\\n\\u00a0                                 Vector<double>        &rhs) const;\\n\\u00a0 \\n\\u00a0       DeclException1(\\n\\u00a0         ExcEvaluationPointNotFound,\\n\\u00a0         Point<dim>,\\n\\u00a0         << \\\"The evaluation point \\\" << arg1\\n\\u00a0         << \\\" was not found among the vertices of the present grid.\\\");\\n\\u00a0 \\n\\u00a0     protected:\\n\\u00a0       const Point<dim> evaluation_point;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     PointXDerivativeEvaluation<dim>::PointXDerivativeEvaluation(\\n\\u00a0       const Point<dim> &evaluation_point)\\n\\u00a0       : evaluation_point(evaluation_point)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\nWhat is interesting is the implementation of this functional: here, J(phi_i)=d/dx phi_i(x0).\\nWe could, as in the implementation of the respective evaluation object take the average of the gradients of each shape function phi_i at this evaluation point. However, we take a slightly different approach: we simply take the average over all cells that surround this point. The question which cells surrounds the evaluation point is made dependent on the mesh width by including those cells for which the distance of the cell's midpoint to the evaluation point is less than the cell's diameter.\\nTaking the average of the gradient over the area/volume of these cells leads to a dual solution which is very close to the one which would result from the point evaluation of the gradient. It is simple to justify theoretically that this does not change the method significantly.\\n\\u00a0     template <int dim>\\n\\u00a0     void PointXDerivativeEvaluation<dim>::assemble_rhs(\\n\\u00a0       const DoFHandler<dim> &dof_handler,\\n\\u00a0       Vector<double>        &rhs) const\\n\\u00a0     {\\nAgain, first set all entries to zero:\\n\\u00a0       rhs.reinit(dof_handler.n_dofs());\\n\\u00a0 \\nInitialize a FEValues object with a quadrature formula, have abbreviations for the number of quadrature points and shape functions...\\n\\u00a0       const QGauss<dim>  quadrature(dof_handler.get_fe().degree + 1);\\n\\u00a0       FEValues<dim>      fe_values(dof_handler.get_fe(),\\n\\u00a0                               quadrature,\\n\\u00a0                               update_gradients | update_quadrature_points |\\n\\u00a0                                 update_JxW_values);\\n\\u00a0       const unsigned int n_q_points    = fe_values.n_quadrature_points;\\n\\u00a0       const unsigned int dofs_per_cell = dof_handler.get_fe().dofs_per_cell;\\n\\u00a0 \\n...and have two objects that are used to store the global indices of the degrees of freedom on a cell, and the values of the gradients of the shape functions at the quadrature points:\\n\\u00a0       Vector<double>            cell_rhs(dofs_per_cell);\\n\\u00a0       std::vector<unsigned int> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\nFinally have a variable in which we will sum up the area/volume of the cells over which we integrate, by integrating the unit functions on these cells:\\n\\u00a0       double total_volume = 0;\\n\\u00a0 \\nThen start the loop over all cells, and select those cells which are close enough to the evaluation point:\\n\\u00a0       for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0         if (cell->center().distance(evaluation_point) <= cell->diameter())\\n\\u00a0           {\\nIf we have found such a cell, then initialize the FEValues object and integrate the x-component of the gradient of each shape function, as well as the unit function for the total area/volume.\\n\\u00a0             fe_values.reinit(cell);\\n\\u00a0             cell_rhs = 0;\\n\\u00a0 \\n\\u00a0             for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0               {\\n\\u00a0                 for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0                   cell_rhs(i) +=\\n\\u00a0                     fe_values.shape_grad(i, q)[0] // (d/dx phi_i(x_q))\\n\\u00a0                     * fe_values.JxW(q);           // * dx\\n\\u00a0                 total_volume += fe_values.JxW(q);\\n\\u00a0               }\\n\\u00a0 \\nIf we have the local contributions, distribute them to the global vector:\\n\\u00a0             cell->get_dof_indices(local_dof_indices);\\n\\u00a0             for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0               rhs(local_dof_indices[i]) += cell_rhs(i);\\n\\u00a0           }\\n\\u00a0 \\nAfter we have looped over all cells, check whether we have found any at all, by making sure that their volume is non-zero. If not, then the results will be botched, as the right hand side should then still be zero, so throw an exception:\\n\\u00a0       AssertThrow(total_volume > 0,\\n\\u00a0                   ExcEvaluationPointNotFound(evaluation_point));\\n\\u00a0 \\nFinally, we have by now only integrated the gradients of the shape functions, not taking their mean value. We fix this by dividing by the measure of the volume over which we have integrated:\\n\\u00a0       rhs /= total_volume;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   } // namespace DualFunctional\\n\\u00a0 \\n\\u00a0 \\n Extending the LaplaceSolver namespace\\n\\u00a0   namespace LaplaceSolver\\n\\u00a0   {\\n The DualSolver class\\nIn the same way as the PrimalSolver class above, we now implement a DualSolver. It has all the same features, the only difference is that it does not take a function object denoting a right hand side object, but now takes a DualFunctionalBase object that will assemble the right hand side vector of the dual problem. The rest of the class is rather trivial.\\nSince both primal and dual solver will use the same triangulation, but different discretizations, it now becomes clear why we have made the Base class a virtual one: since the final class will be derived from both PrimalSolver as well as DualSolver, it would have two Base instances, would we not have marked the inheritance as virtual. Since in many applications the base class would store much more information than just the triangulation which needs to be shared between primal and dual solvers, we do not usually want to use two such base classes.\\n\\u00a0     template <int dim>\\n\\u00a0     class DualSolver : public Solver<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       DualSolver(\\n\\u00a0         Triangulation<dim>                            &triangulation,\\n\\u00a0         const FiniteElement<dim>                      &fe,\\n\\u00a0         const Quadrature<dim>                         &quadrature,\\n\\u00a0         const Quadrature<dim - 1>                     &face_quadrature,\\n\\u00a0         const DualFunctional::DualFunctionalBase<dim> &dual_functional);\\n\\u00a0 \\n\\u00a0     protected:\\n\\u00a0       const SmartPointer<const DualFunctional::DualFunctionalBase<dim>>\\n\\u00a0                    dual_functional;\\n\\u00a0       virtual void assemble_rhs(Vector<double> &rhs) const override;\\n\\u00a0 \\n\\u00a0       static const Functions::ZeroFunction<dim> boundary_values;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     const Functions::ZeroFunction<dim> DualSolver<dim>::boundary_values;\\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     DualSolver<dim>::DualSolver(\\n\\u00a0       Triangulation<dim>                            &triangulation,\\n\\u00a0       const FiniteElement<dim>                      &fe,\\n\\u00a0       const Quadrature<dim>                         &quadrature,\\n\\u00a0       const Quadrature<dim - 1>                     &face_quadrature,\\n\\u00a0       const DualFunctional::DualFunctionalBase<dim> &dual_functional)\\n\\u00a0       : Base<dim>(triangulation)\\n\\u00a0       , Solver<dim>(triangulation,\\n\\u00a0                     fe,\\n\\u00a0                     quadrature,\\n\\u00a0                     face_quadrature,\\n\\u00a0                     boundary_values)\\n\\u00a0       , dual_functional(&dual_functional)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void DualSolver<dim>::assemble_rhs(Vector<double> &rhs) const\\n\\u00a0     {\\n\\u00a0       dual_functional->assemble_rhs(this->dof_handler, rhs);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n The WeightedResidual class\\nHere finally comes the main class of this program, the one that implements the dual weighted residual error estimator. It joins the primal and dual solver classes to use them for the computation of primal and dual solutions, and implements the error representation formula for use as error estimate and mesh refinement.\\nThe first few of the functions of this class are mostly overriders of the respective functions of the base class:\\n\\u00a0     template <int dim>\\n\\u00a0     class WeightedResidual : public PrimalSolver<dim>, public DualSolver<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       WeightedResidual(\\n\\u00a0         Triangulation<dim>                            &coarse_grid,\\n\\u00a0         const FiniteElement<dim>                      &primal_fe,\\n\\u00a0         const FiniteElement<dim>                      &dual_fe,\\n\\u00a0         const Quadrature<dim>                         &quadrature,\\n\\u00a0         const Quadrature<dim - 1>                     &face_quadrature,\\n\\u00a0         const Function<dim>                           &rhs_function,\\n\\u00a0         const Function<dim>                           &boundary_values,\\n\\u00a0         const DualFunctional::DualFunctionalBase<dim> &dual_functional);\\n\\u00a0 \\n\\u00a0       virtual void solve_problem() override;\\n\\u00a0 \\n\\u00a0       virtual void postprocess(\\n\\u00a0         const Evaluation::EvaluationBase<dim> &postprocessor) const override;\\n\\u00a0 \\n\\u00a0       virtual unsigned int n_dofs() const override;\\n\\u00a0 \\n\\u00a0       virtual void refine_grid() override;\\n\\u00a0 \\n\\u00a0       virtual void output_solution() const override;\\n\\u00a0 \\n\\u00a0     private:\\nIn the private section, we have two functions that are used to call the solve_problem functions of the primal and dual base classes. These two functions will be called in parallel by the solve_problem function of this class.\\n\\u00a0       void solve_primal_problem();\\n\\u00a0       void solve_dual_problem();\\nThen declare abbreviations for active cell iterators, to avoid that we have to write this lengthy name over and over again:\\n\\u00a0       using active_cell_iterator =\\n\\u00a0         typename DoFHandler<dim>::active_cell_iterator;\\n\\u00a0 \\nNext, declare a data type that we will us to store the contribution of faces to the error estimator. The idea is that we can compute the face terms from each of the two cells to this face, as they are the same when viewed from both sides. What we will do is to compute them only once, based on some rules explained below which of the two adjacent cells will be in charge to do so. We then store the contribution of each face in a map mapping faces to their values, and only collect the contributions for each cell by looping over the cells a second time and grabbing the values from the map.\\nThe data type of this map is declared here:\\n\\u00a0       using FaceIntegrals =\\n\\u00a0         typename std::map<typename DoFHandler<dim>::face_iterator, double>;\\n\\u00a0 \\nIn the computation of the error estimates on cells and faces, we need a number of helper objects, such as FEValues and FEFaceValues functions, but also temporary objects storing the values and gradients of primal and dual solutions, for example. These fields are needed in the three functions that do the integration on cells, and regular and irregular faces, respectively.\\nThere are three reasonable ways to provide these fields: first, as local variables in the function that needs them; second, as member variables of this class; third, as arguments passed to that function.\\nThese three alternatives all have drawbacks: the third that their number is not negligible and would make calling these functions a lengthy enterprise. The second has the drawback that it disallows parallelization, since the threads that will compute the error estimate have to have their own copies of these variables each, so member variables of the enclosing class will not work. The first approach, although straightforward, has a subtle but important drawback: we will call these functions over and over again, many thousands of times maybe; it now turns out that allocating vectors and other objects that need memory from the heap is an expensive business in terms of run-time, since memory allocation is expensive when several threads are involved. It is thus significantly better to allocate the memory only once, and recycle the objects as often as possible.\\nWhat to do? Our answer is to use a variant of the third strategy. In fact, this is exactly what the WorkStream concept is supposed to do (we have already introduced it above, but see also Parallel computing with multiple processors accessing shared memory). To avoid that we have to give these functions a dozen or so arguments, we pack all these variables into two structures, one which is used for the computations on cells, the other doing them on the faces. Both are then joined into the WeightedResidualScratchData class that will serve as the \\\"scratch data\\\" class of the WorkStream concept:\\n\\u00a0       struct CellData\\n\\u00a0       {\\n\\u00a0         FEValues<dim>                           fe_values;\\n\\u00a0         const SmartPointer<const Function<dim>> right_hand_side;\\n\\u00a0 \\n\\u00a0         std::vector<double> cell_residual;\\n\\u00a0         std::vector<double> rhs_values;\\n\\u00a0         std::vector<double> dual_weights;\\n\\u00a0         std::vector<double> cell_laplacians;\\n\\u00a0         CellData(const FiniteElement<dim> &fe,\\n\\u00a0                  const Quadrature<dim>    &quadrature,\\n\\u00a0                  const Function<dim>      &right_hand_side);\\n\\u00a0         CellData(const CellData &cell_data);\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0       struct FaceData\\n\\u00a0       {\\n\\u00a0         FEFaceValues<dim>    fe_face_values_cell;\\n\\u00a0         FEFaceValues<dim>    fe_face_values_neighbor;\\n\\u00a0         FESubfaceValues<dim> fe_subface_values_cell;\\n\\u00a0 \\n\\u00a0         std::vector<double>                  jump_residual;\\n\\u00a0         std::vector<double>                  dual_weights;\\n\\u00a0         typename std::vector<Tensor<1, dim>> cell_grads;\\n\\u00a0         typename std::vector<Tensor<1, dim>> neighbor_grads;\\n\\u00a0         FaceData(const FiniteElement<dim>  &fe,\\n\\u00a0                  const Quadrature<dim - 1> &face_quadrature);\\n\\u00a0         FaceData(const FaceData &face_data);\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0       struct WeightedResidualScratchData\\n\\u00a0       {\\n\\u00a0         WeightedResidualScratchData(\\n\\u00a0           const FiniteElement<dim>  &primal_fe,\\n\\u00a0           const Quadrature<dim>     &primal_quadrature,\\n\\u00a0           const Quadrature<dim - 1> &primal_face_quadrature,\\n\\u00a0           const Function<dim>       &rhs_function,\\n\\u00a0           const Vector<double>      &primal_solution,\\n\\u00a0           const Vector<double>      &dual_weights);\\n\\u00a0 \\n\\u00a0         WeightedResidualScratchData(\\n\\u00a0           const WeightedResidualScratchData &scratch_data);\\n\\u00a0 \\n\\u00a0         CellData       cell_data;\\n\\u00a0         FaceData       face_data;\\n\\u00a0         Vector<double> primal_solution;\\n\\u00a0         Vector<double> dual_weights;\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0 \\nFEFaceValuesDefinition fe_values.h:322\\nFESubfaceValuesDefinition fe_values.h:488\\nCellData::CellDataCellData(const unsigned int n_vertices=ReferenceCells::get_hypercube< structdim >().n_vertices())Definition tria_description.cc:34\\nWorkStream::run generally wants both a scratch object and a copy object. Here, for reasons similar to what we had in step-9 when discussing the computation of an approximation of the gradient, we don't actually need a \\\"copy data\\\" structure. Since WorkStream insists on having one of these, we just declare an empty structure that does nothing other than being there.\\n\\u00a0       struct WeightedResidualCopyData\\n\\u00a0       {};\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nRegarding the evaluation of the error estimator, we have one driver function that uses WorkStream::run() to call the second function on every cell:\\n\\u00a0       void estimate_error(Vector<float> &error_indicators) const;\\n\\u00a0 \\n\\u00a0       void estimate_on_one_cell(const active_cell_iterator  &cell,\\n\\u00a0                                 WeightedResidualScratchData &scratch_data,\\n\\u00a0                                 WeightedResidualCopyData    &copy_data,\\n\\u00a0                                 Vector<float>               &error_indicators,\\n\\u00a0                                 FaceIntegrals &face_integrals) const;\\n\\u00a0 \\nThen we have functions that do the actual integration of the error representation formula. They will treat the terms on the cell interiors, on those faces that have no hanging nodes, and on those faces with hanging nodes, respectively:\\n\\u00a0       void integrate_over_cell(const active_cell_iterator &cell,\\n\\u00a0                                const Vector<double>       &primal_solution,\\n\\u00a0                                const Vector<double>       &dual_weights,\\n\\u00a0                                CellData                   &cell_data,\\n\\u00a0                                Vector<float> &error_indicators) const;\\n\\u00a0 \\n\\u00a0       void integrate_over_regular_face(const active_cell_iterator &cell,\\n\\u00a0                                        const unsigned int          face_no,\\n\\u00a0                                        const Vector<double> &primal_solution,\\n\\u00a0                                        const Vector<double> &dual_weights,\\n\\u00a0                                        FaceData             &face_data,\\n\\u00a0                                        FaceIntegrals &face_integrals) const;\\n\\u00a0       void integrate_over_irregular_face(const active_cell_iterator &cell,\\n\\u00a0                                          const unsigned int          face_no,\\n\\u00a0                                          const Vector<double> &primal_solution,\\n\\u00a0                                          const Vector<double> &dual_weights,\\n\\u00a0                                          FaceData             &face_data,\\n\\u00a0                                          FaceIntegrals &face_integrals) const;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nIn the implementation of this class, we first have the constructors of the CellData and FaceData member classes, and the WeightedResidual constructor. They only initialize fields to their correct lengths, so we do not have to discuss them in too much detail:\\n\\u00a0     template <int dim>\\n\\u00a0     WeightedResidual<dim>::CellData::CellData(\\n\\u00a0       const FiniteElement<dim> &fe,\\n\\u00a0       const Quadrature<dim>    &quadrature,\\n\\u00a0       const Function<dim>      &right_hand_side)\\n\\u00a0       : fe_values(fe,\\n\\u00a0                   quadrature,\\n\\u00a0                   update_values | update_hessians | update_quadrature_points |\\n\\u00a0                     update_JxW_values)\\n\\u00a0       , right_hand_side(&right_hand_side)\\n\\u00a0       , cell_residual(quadrature.size())\\n\\u00a0       , rhs_values(quadrature.size())\\n\\u00a0       , dual_weights(quadrature.size())\\n\\u00a0       , cell_laplacians(quadrature.size())\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     WeightedResidual<dim>::CellData::CellData(const CellData &cell_data)\\n\\u00a0       : fe_values(cell_data.fe_values.get_fe(),\\n\\u00a0                   cell_data.fe_values.get_quadrature(),\\n\\u00a0                   update_values | update_hessians | update_quadrature_points |\\n\\u00a0                     update_JxW_values)\\n\\u00a0       , right_hand_side(cell_data.right_hand_side)\\n\\u00a0       , cell_residual(cell_data.cell_residual)\\n\\u00a0       , rhs_values(cell_data.rhs_values)\\n\\u00a0       , dual_weights(cell_data.dual_weights)\\n\\u00a0       , cell_laplacians(cell_data.cell_laplacians)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     WeightedResidual<dim>::FaceData::FaceData(\\n\\u00a0       const FiniteElement<dim>  &fe,\\n\\u00a0       const Quadrature<dim - 1> &face_quadrature)\\n\\u00a0       : fe_face_values_cell(fe,\\n\\u00a0                             face_quadrature,\\n\\u00a0                             update_values | update_gradients |\\n\\u00a0                               update_JxW_values | update_normal_vectors)\\n\\u00a0       , fe_face_values_neighbor(fe,\\n\\u00a0                                 face_quadrature,\\n\\u00a0                                 update_values | update_gradients |\\n\\u00a0                                   update_JxW_values | update_normal_vectors)\\n\\u00a0       , fe_subface_values_cell(fe, face_quadrature, update_gradients)\\n\\u00a0     {\\n\\u00a0       const unsigned int n_face_q_points = face_quadrature.size();\\n\\u00a0 \\n\\u00a0       jump_residual.resize(n_face_q_points);\\n\\u00a0       dual_weights.resize(n_face_q_points);\\n\\u00a0       cell_grads.resize(n_face_q_points);\\n\\u00a0       neighbor_grads.resize(n_face_q_points);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     WeightedResidual<dim>::FaceData::FaceData(const FaceData &face_data)\\n\\u00a0       : fe_face_values_cell(face_data.fe_face_values_cell.get_fe(),\\n\\u00a0                             face_data.fe_face_values_cell.get_quadrature(),\\n\\u00a0                             update_values | update_gradients |\\n\\u00a0                               update_JxW_values | update_normal_vectors)\\n\\u00a0       , fe_face_values_neighbor(\\n\\u00a0           face_data.fe_face_values_neighbor.get_fe(),\\n\\u00a0           face_data.fe_face_values_neighbor.get_quadrature(),\\n\\u00a0           update_values | update_gradients | update_JxW_values |\\n\\u00a0             update_normal_vectors)\\n\\u00a0       , fe_subface_values_cell(\\n\\u00a0           face_data.fe_subface_values_cell.get_fe(),\\n\\u00a0           face_data.fe_subface_values_cell.get_quadrature(),\\n\\u00a0           update_gradients)\\n\\u00a0       , jump_residual(face_data.jump_residual)\\n\\u00a0       , dual_weights(face_data.dual_weights)\\n\\u00a0       , cell_grads(face_data.cell_grads)\\n\\u00a0       , neighbor_grads(face_data.neighbor_grads)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     WeightedResidual<dim>::WeightedResidualScratchData::\\n\\u00a0       WeightedResidualScratchData(\\n\\u00a0         const FiniteElement<dim>  &primal_fe,\\n\\u00a0         const Quadrature<dim>     &primal_quadrature,\\n\\u00a0         const Quadrature<dim - 1> &primal_face_quadrature,\\n\\u00a0         const Function<dim>       &rhs_function,\\n\\u00a0         const Vector<double>      &primal_solution,\\n\\u00a0         const Vector<double>      &dual_weights)\\n\\u00a0       : cell_data(primal_fe, primal_quadrature, rhs_function)\\n\\u00a0       , face_data(primal_fe, primal_face_quadrature)\\n\\u00a0       , primal_solution(primal_solution)\\n\\u00a0       , dual_weights(dual_weights)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     WeightedResidual<dim>::WeightedResidualScratchData::\\n\\u00a0       WeightedResidualScratchData(\\n\\u00a0         const WeightedResidualScratchData &scratch_data)\\n\\u00a0       : cell_data(scratch_data.cell_data)\\n\\u00a0       , face_data(scratch_data.face_data)\\n\\u00a0       , primal_solution(scratch_data.primal_solution)\\n\\u00a0       , dual_weights(scratch_data.dual_weights)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     WeightedResidual<dim>::WeightedResidual(\\n\\u00a0       Triangulation<dim>                            &coarse_grid,\\n\\u00a0       const FiniteElement<dim>                      &primal_fe,\\n\\u00a0       const FiniteElement<dim>                      &dual_fe,\\n\\u00a0       const Quadrature<dim>                         &quadrature,\\n\\u00a0       const Quadrature<dim - 1>                     &face_quadrature,\\n\\u00a0       const Function<dim>                           &rhs_function,\\n\\u00a0       const Function<dim>                           &bv,\\n\\u00a0       const DualFunctional::DualFunctionalBase<dim> &dual_functional)\\n\\u00a0       : Base<dim>(coarse_grid)\\n\\u00a0       , PrimalSolver<dim>(coarse_grid,\\n\\u00a0                           primal_fe,\\n\\u00a0                           quadrature,\\n\\u00a0                           face_quadrature,\\n\\u00a0                           rhs_function,\\n\\u00a0                           bv)\\n\\u00a0       , DualSolver<dim>(coarse_grid,\\n\\u00a0                         dual_fe,\\n\\u00a0                         quadrature,\\n\\u00a0                         face_quadrature,\\n\\u00a0                         dual_functional)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\nupdate_hessians@ update_hessiansSecond derivatives of shape functions.Definition fe_update_flags.h:87\\nupdate_normal_vectors@ update_normal_vectorsNormal vectors.Definition fe_update_flags.h:141\\nThe next five functions are boring, as they simply relay their work to the base classes. The first calls the primal and dual solvers in parallel, while postprocessing the solution and retrieving the number of degrees of freedom is done by the primal class.\\n\\u00a0     template <int dim>\\n\\u00a0     void WeightedResidual<dim>::solve_problem()\\n\\u00a0     {\\n\\u00a0       Threads::TaskGroup<void> tasks;\\n\\u00a0       tasks +=\\n\\u00a0         Threads::new_task(&WeightedResidual<dim>::solve_primal_problem, *this);\\n\\u00a0       tasks +=\\n\\u00a0         Threads::new_task(&WeightedResidual<dim>::solve_dual_problem, *this);\\n\\u00a0       tasks.join_all();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void WeightedResidual<dim>::solve_primal_problem()\\n\\u00a0     {\\n\\u00a0       PrimalSolver<dim>::solve_problem();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void WeightedResidual<dim>::solve_dual_problem()\\n\\u00a0     {\\n\\u00a0       DualSolver<dim>::solve_problem();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void WeightedResidual<dim>::postprocess(\\n\\u00a0       const Evaluation::EvaluationBase<dim> &postprocessor) const\\n\\u00a0     {\\n\\u00a0       PrimalSolver<dim>::postprocess(postprocessor);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     unsigned int WeightedResidual<dim>::n_dofs() const\\n\\u00a0     {\\n\\u00a0       return PrimalSolver<dim>::n_dofs();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nThreads::TaskGroupDefinition thread_management.h:1373\\nNow, it is becoming more interesting: the refine_grid() function asks the error estimator to compute the cell-wise error indicators, then uses their absolute values for mesh refinement.\\n\\u00a0     template <int dim>\\n\\u00a0     void WeightedResidual<dim>::refine_grid()\\n\\u00a0     {\\nFirst call the function that computes the cell-wise and global error:\\n\\u00a0       Vector<float> error_indicators(this->triangulation->n_active_cells());\\n\\u00a0       estimate_error(error_indicators);\\n\\u00a0 \\nThen note that marking cells for refinement or coarsening only works if all indicators are positive, to allow their comparison. Thus, drop the signs on all these indicators:\\n\\u00a0       for (float &error_indicator : error_indicators)\\n\\u00a0         error_indicator = std::fabs(error_indicator);\\n\\u00a0 \\nFinally, we can select between different strategies for refinement. The default here is to refine those cells with the largest error indicators that make up for a total of 80 per cent of the error, while we coarsen those with the smallest indicators that make up for the bottom 2 per cent of the error.\\n\\u00a0       GridRefinement::refine_and_coarsen_fixed_fraction(*this->triangulation,\\n\\u00a0                                                         error_indicators,\\n\\u00a0                                                         0.8,\\n\\u00a0                                                         0.02);\\n\\u00a0       this->triangulation->execute_coarsening_and_refinement();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\nGridRefinement::refine_and_coarsen_fixed_fractionvoid refine_and_coarsen_fixed_fraction(Triangulation< dim, spacedim > &tria, const Vector< Number > &criteria, const double top_fraction, const double bottom_fraction, const unsigned int max_n_cells=std::numeric_limits< unsigned int >::max(), const VectorTools::NormType norm_type=VectorTools::L1_norm)Definition grid_refinement.cc:386\\nSince we want to output both the primal and the dual solution, we overload the output_solution function. The only interesting feature of this function is that the primal and dual solutions are defined on different finite element spaces, which is not the format the DataOut class expects. Thus, we have to transfer them to a common finite element space. Since we want the solutions only to see them qualitatively, we contend ourselves with interpolating the dual solution to the (smaller) primal space. For the interpolation, there is a library function, that takes a AffineConstraints object including the hanging node constraints. The rest is standard.\\n\\u00a0     template <int dim>\\n\\u00a0     void WeightedResidual<dim>::output_solution() const\\n\\u00a0     {\\n\\u00a0       AffineConstraints<double> primal_hanging_node_constraints;\\n\\u00a0       DoFTools::make_hanging_node_constraints(PrimalSolver<dim>::dof_handler,\\n\\u00a0                                               primal_hanging_node_constraints);\\n\\u00a0       primal_hanging_node_constraints.close();\\n\\u00a0       Vector<double> dual_solution(PrimalSolver<dim>::dof_handler.n_dofs());\\n\\u00a0       FETools::interpolate(DualSolver<dim>::dof_handler,\\n\\u00a0                            DualSolver<dim>::solution,\\n\\u00a0                            PrimalSolver<dim>::dof_handler,\\n\\u00a0                            primal_hanging_node_constraints,\\n\\u00a0                            dual_solution);\\n\\u00a0 \\n\\u00a0       DataOut<dim> data_out;\\n\\u00a0       data_out.attach_dof_handler(PrimalSolver<dim>::dof_handler);\\n\\u00a0 \\nFETools::interpolatevoid interpolate(const DoFHandler< dim, spacedim > &dof1, const InVector &u1, const DoFHandler< dim, spacedim > &dof2, OutVector &u2)\\nAdd the data vectors for which we want output. Add them both, the DataOut functions can handle as many data vectors as you wish to write to output:\\n\\u00a0       data_out.add_data_vector(PrimalSolver<dim>::solution, \\\"primal_solution\\\");\\n\\u00a0       data_out.add_data_vector(dual_solution, \\\"dual_solution\\\");\\n\\u00a0 \\n\\u00a0       data_out.build_patches();\\n\\u00a0 \\n\\u00a0       std::ofstream out(\\\"solution-\\\" + std::to_string(this->refinement_cycle) +\\n\\u00a0                         \\\".vtu\\\");\\n\\u00a0       data_out.write(out, DataOutBase::vtu);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n Estimating errors\\n Error estimation driver functions\\nAs for the actual computation of error estimates, let's start with the function that drives all this, i.e. calls those functions that actually do the work, and finally collects the results.\\n\\u00a0     template <int dim>\\n\\u00a0     void\\n\\u00a0     WeightedResidual<dim>::estimate_error(Vector<float> &error_indicators) const\\n\\u00a0     {\\nThe first task in computing the error is to set up vectors that denote the primal solution, and the weights (z-z_h)=(z-I_hz), both in the finite element space for which we have computed the dual solution. For this, we have to interpolate the primal solution to the dual finite element space, and to subtract the interpolation of the computed dual solution to the primal finite element space. Fortunately, the library provides functions for the interpolation into larger or smaller finite element spaces, so this is mostly obvious.\\nFirst, let's do that for the primal solution: it is cell-wise interpolated into the finite element space in which we have solved the dual problem: But, again as in the WeightedResidual::output_solution function we first need to create an AffineConstraints object including the hanging node constraints, but this time of the dual finite element space.\\n\\u00a0       AffineConstraints<double> dual_hanging_node_constraints;\\n\\u00a0       DoFTools::make_hanging_node_constraints(DualSolver<dim>::dof_handler,\\n\\u00a0                                               dual_hanging_node_constraints);\\n\\u00a0       dual_hanging_node_constraints.close();\\n\\u00a0       Vector<double> primal_solution(DualSolver<dim>::dof_handler.n_dofs());\\n\\u00a0       FETools::interpolate(PrimalSolver<dim>::dof_handler,\\n\\u00a0                            PrimalSolver<dim>::solution,\\n\\u00a0                            DualSolver<dim>::dof_handler,\\n\\u00a0                            dual_hanging_node_constraints,\\n\\u00a0                            primal_solution);\\n\\u00a0 \\nThen for computing the interpolation of the numerically approximated dual solution z into the finite element space of the primal solution and subtracting it from z: use the interpolate_difference function, that gives (z-I_hz) in the element space of the dual solution.\\n\\u00a0       AffineConstraints<double> primal_hanging_node_constraints;\\n\\u00a0       DoFTools::make_hanging_node_constraints(PrimalSolver<dim>::dof_handler,\\n\\u00a0                                               primal_hanging_node_constraints);\\n\\u00a0       primal_hanging_node_constraints.close();\\n\\u00a0       Vector<double> dual_weights(DualSolver<dim>::dof_handler.n_dofs());\\n\\u00a0       FETools::interpolation_difference(DualSolver<dim>::dof_handler,\\n\\u00a0                                         dual_hanging_node_constraints,\\n\\u00a0                                         DualSolver<dim>::solution,\\n\\u00a0                                         PrimalSolver<dim>::dof_handler,\\n\\u00a0                                         primal_hanging_node_constraints,\\n\\u00a0                                         dual_weights);\\n\\u00a0 \\nFETools::interpolation_differencevoid interpolation_difference(const DoFHandler< dim, spacedim > &dof1, const InVector &z1, const FiniteElement< dim, spacedim > &fe2, OutVector &z1_difference)\\nNote that this could probably have been more efficient since those constraints have been used previously when assembling matrix and right hand side for the primal problem and writing out the dual solution. We leave the optimization of the program in this respect as an exercise.\\nHaving computed the dual weights we now proceed with computing the cell and face residuals of the primal solution. First we set up a map between face iterators and their jump term contributions of faces to the error estimator. The reason is that we compute the jump terms only once, from one side of the face, and want to collect them only afterwards when looping over all cells a second time.\\nWe initialize this map already with a value of -1e20 for all faces, since this value will stand out in the results if something should go wrong and we fail to compute the value for a face for some reason. Secondly, this initialization already makes the std::map object allocate all objects it may possibly need. This is important since we will write into this structure from parallel threads, and doing so would not be thread-safe if the map needed to allocate memory and thereby reshape its data structures. In other words, the initial initialization relieves us from the necessity to synchronize the threads through a mutex each time they write to (and modify the structure of) this map.\\n\\u00a0       FaceIntegrals face_integrals;\\n\\u00a0       for (const auto &cell :\\n\\u00a0            DualSolver<dim>::dof_handler.active_cell_iterators())\\n\\u00a0         for (const auto &face : cell->face_iterators())\\n\\u00a0           face_integrals[face] = -1e20;\\n\\u00a0 \\n\\u00a0       auto worker = [this,\\n\\u00a0                      &error_indicators,\\n\\u00a0                      &face_integrals](const active_cell_iterator  &cell,\\n\\u00a0                                       WeightedResidualScratchData &scratch_data,\\n\\u00a0                                       WeightedResidualCopyData    &copy_data) {\\n\\u00a0         this->estimate_on_one_cell(\\n\\u00a0           cell, scratch_data, copy_data, error_indicators, face_integrals);\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0       auto do_nothing_copier =\\n\\u00a0         std::function<void(const WeightedResidualCopyData &)>();\\n\\u00a0 \\nThen hand it all off to WorkStream::run() to compute the estimators for all cells in parallel:\\n\\u00a0       WorkStream::run(\\n\\u00a0         DualSolver<dim>::dof_handler.begin_active(),\\n\\u00a0         DualSolver<dim>::dof_handler.end(),\\n\\u00a0         worker,\\n\\u00a0         do_nothing_copier,\\n\\u00a0         WeightedResidualScratchData(*DualSolver<dim>::fe,\\n\\u00a0                                     *DualSolver<dim>::quadrature,\\n\\u00a0                                     *DualSolver<dim>::face_quadrature,\\n\\u00a0                                     *this->rhs_function,\\n\\u00a0                                     primal_solution,\\n\\u00a0                                     dual_weights),\\n\\u00a0         WeightedResidualCopyData());\\n\\u00a0 \\nOnce the error contributions are computed, sum them up. For this, note that the cell terms are already set, and that only the edge terms need to be collected. Thus, loop over all cells and their faces, make sure that the contributions of each of the faces are there, and add them up. Only take minus one half of the jump term, since the other half will be taken by the neighboring cell.\\n\\u00a0       unsigned int present_cell = 0;\\n\\u00a0       for (const auto &cell :\\n\\u00a0            DualSolver<dim>::dof_handler.active_cell_iterators())\\n\\u00a0         {\\n\\u00a0           for (const auto &face : cell->face_iterators())\\n\\u00a0             {\\n\\u00a0               Assert(face_integrals.find(face) != face_integrals.end(),\\n\\u00a0                      ExcInternalError());\\n\\u00a0               error_indicators(present_cell) -= 0.5 * face_integrals[face];\\n\\u00a0             }\\n\\u00a0           ++present_cell;\\n\\u00a0         }\\n\\u00a0       std::cout << \\\"   Estimated error: \\\"\\n\\u00a0                 << std::accumulate(error_indicators.begin(),\\n\\u00a0                                    error_indicators.end(),\\n\\u00a0                                    0.)\\n\\u00a0                 << std::endl;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n Estimating on a single cell\\nNext we have the function that is called to estimate the error on a single cell. The function may be called multiple times if the library was configured to use multithreading. Here it goes:\\n\\u00a0     template <int dim>\\n\\u00a0     void WeightedResidual<dim>::estimate_on_one_cell(\\n\\u00a0       const active_cell_iterator  &cell,\\n\\u00a0       WeightedResidualScratchData &scratch_data,\\n\\u00a0       WeightedResidualCopyData    &copy_data,\\n\\u00a0       Vector<float>               &error_indicators,\\n\\u00a0       FaceIntegrals               &face_integrals) const\\n\\u00a0     {\\nBecause of WorkStream, estimate_on_one_cell requires a CopyData object even if it is no used. The next line silences a warning about this unused variable.\\n\\u00a0       (void)copy_data;\\n\\u00a0 \\nFirst task on each cell is to compute the cell residual contributions of this cell, and put them into the error_indicators variable:\\n\\u00a0       integrate_over_cell(cell,\\n\\u00a0                           scratch_data.primal_solution,\\n\\u00a0                           scratch_data.dual_weights,\\n\\u00a0                           scratch_data.cell_data,\\n\\u00a0                           error_indicators);\\n\\u00a0 \\nAfter computing the cell terms, turn to the face terms. For this, loop over all faces of the present cell, and see whether something needs to be computed on it:\\n\\u00a0       for (const auto face_no : cell->face_indices())\\n\\u00a0         {\\nFirst, if this face is part of the boundary, then there is nothing to do. However, to make things easier when summing up the contributions of the faces of cells, we enter this face into the list of faces with a zero contribution to the error.\\n\\u00a0           if (cell->face(face_no)->at_boundary())\\n\\u00a0             {\\n\\u00a0               face_integrals[cell->face(face_no)] = 0;\\n\\u00a0               continue;\\n\\u00a0             }\\n\\u00a0 \\nNext, note that since we want to compute the jump terms on each face only once although we access it twice (if it is not at the boundary), we have to define some rules who is responsible for computing on a face:\\nFirst, if the neighboring cell is on the same level as this one, i.e. neither further refined not coarser, then the one with the lower index within this level does the work. In other words: if the other one has a lower index, then skip work on this face:\\n\\u00a0           if ((cell->neighbor(face_no)->has_children() == false) &&\\n\\u00a0               (cell->neighbor(face_no)->level() == cell->level()) &&\\n\\u00a0               (cell->neighbor(face_no)->index() < cell->index()))\\n\\u00a0             continue;\\n\\u00a0 \\nLikewise, we always work from the coarser cell if this and its neighbor differ in refinement. Thus, if the neighboring cell is less refined than the present one, then do nothing since we integrate over the subfaces when we visit the coarse cell.\\n\\u00a0           if (cell->at_boundary(face_no) == false)\\n\\u00a0             if (cell->neighbor(face_no)->level() < cell->level())\\n\\u00a0               continue;\\n\\u00a0 \\n\\u00a0 \\nNow we know that we are in charge here, so actually compute the face jump terms. If the face is a regular one, i.e. the other side's cell is neither coarser not finer than this cell, then call one function, and if the cell on the other side is further refined, then use another function. Note that the case that the cell on the other side is coarser cannot happen since we have decided above that we handle this case when we pass over that other cell.\\n\\u00a0           if (cell->face(face_no)->has_children() == false)\\n\\u00a0             integrate_over_regular_face(cell,\\n\\u00a0                                         face_no,\\n\\u00a0                                         scratch_data.primal_solution,\\n\\u00a0                                         scratch_data.dual_weights,\\n\\u00a0                                         scratch_data.face_data,\\n\\u00a0                                         face_integrals);\\n\\u00a0           else\\n\\u00a0             integrate_over_irregular_face(cell,\\n\\u00a0                                           face_no,\\n\\u00a0                                           scratch_data.primal_solution,\\n\\u00a0                                           scratch_data.dual_weights,\\n\\u00a0                                           scratch_data.face_data,\\n\\u00a0                                           face_integrals);\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n Computing cell term error contributions\\nAs for the actual computation of the error contributions, first turn to the cell terms:\\n\\u00a0     template <int dim>\\n\\u00a0     void WeightedResidual<dim>::integrate_over_cell(\\n\\u00a0       const active_cell_iterator &cell,\\n\\u00a0       const Vector<double>       &primal_solution,\\n\\u00a0       const Vector<double>       &dual_weights,\\n\\u00a0       CellData                   &cell_data,\\n\\u00a0       Vector<float>              &error_indicators) const\\n\\u00a0     {\\nThe tasks to be done are what appears natural from looking at the error estimation formula: first get the right hand side and Laplacian of the numerical solution at the quadrature points for the cell residual,\\n\\u00a0       cell_data.fe_values.reinit(cell);\\n\\u00a0       cell_data.right_hand_side->value_list(\\n\\u00a0         cell_data.fe_values.get_quadrature_points(), cell_data.rhs_values);\\n\\u00a0       cell_data.fe_values.get_function_laplacians(primal_solution,\\n\\u00a0                                                   cell_data.cell_laplacians);\\n\\u00a0 \\n...then get the dual weights...\\n\\u00a0       cell_data.fe_values.get_function_values(dual_weights,\\n\\u00a0                                               cell_data.dual_weights);\\n\\u00a0 \\n...and finally build the sum over all quadrature points and store it with the present cell:\\n\\u00a0       double sum = 0;\\n\\u00a0       for (unsigned int p = 0; p < cell_data.fe_values.n_quadrature_points; ++p)\\n\\u00a0         sum += ((cell_data.rhs_values[p] + cell_data.cell_laplacians[p]) *\\n\\u00a0                 cell_data.dual_weights[p] * cell_data.fe_values.JxW(p));\\n\\u00a0       error_indicators(cell->active_cell_index()) += sum;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n Computing edge term error contributions \\u2013 1\\nOn the other hand, computation of the edge terms for the error estimate is not so simple. First, we have to distinguish between faces with and without hanging nodes. Because it is the simple case, we first consider the case without hanging nodes on a face (let's call this the \\u2018regular\\u2019 case):\\n\\u00a0     template <int dim>\\n\\u00a0     void WeightedResidual<dim>::integrate_over_regular_face(\\n\\u00a0       const active_cell_iterator &cell,\\n\\u00a0       const unsigned int          face_no,\\n\\u00a0       const Vector<double>       &primal_solution,\\n\\u00a0       const Vector<double>       &dual_weights,\\n\\u00a0       FaceData                   &face_data,\\n\\u00a0       FaceIntegrals              &face_integrals) const\\n\\u00a0     {\\n\\u00a0       const unsigned int n_q_points =\\n\\u00a0         face_data.fe_face_values_cell.n_quadrature_points;\\n\\u00a0 \\nThe first step is to get the values of the gradients at the quadrature points of the finite element field on the present cell. For this, initialize the FEFaceValues object corresponding to this side of the face, and extract the gradients using that object.\\n\\u00a0       face_data.fe_face_values_cell.reinit(cell, face_no);\\n\\u00a0       face_data.fe_face_values_cell.get_function_gradients(\\n\\u00a0         primal_solution, face_data.cell_grads);\\n\\u00a0 \\nThe second step is then to extract the gradients of the finite element solution at the quadrature points on the other side of the face, i.e. from the neighboring cell.\\nFor this, do a sanity check before: make sure that the neighbor actually exists (yes, we should not have come here if the neighbor did not exist, but in complicated software there are bugs, so better check this), and if this is not the case throw an error.\\n\\u00a0       Assert(cell->neighbor(face_no).state() == IteratorState::valid,\\n\\u00a0              ExcInternalError());\\nIteratorState::valid@ validIterator points to a valid object.Definition tria_iterator_base.h:37\\nIf we have that, then we need to find out with which face of the neighboring cell we have to work, i.e. the how-many'th the neighbor the present cell is of the cell behind the present face. For this, there is a function, and we put the result into a variable with the name neighbor_neighbor:\\n\\u00a0       const unsigned int neighbor_neighbor =\\n\\u00a0         cell->neighbor_of_neighbor(face_no);\\nThen define an abbreviation for the neighbor cell, initialize the FEFaceValues object on that cell, and extract the gradients on that cell:\\n\\u00a0       const active_cell_iterator neighbor = cell->neighbor(face_no);\\n\\u00a0       face_data.fe_face_values_neighbor.reinit(neighbor, neighbor_neighbor);\\n\\u00a0       face_data.fe_face_values_neighbor.get_function_gradients(\\n\\u00a0         primal_solution, face_data.neighbor_grads);\\n\\u00a0 \\nNow that we have the gradients on this and the neighboring cell, compute the jump residual by multiplying the jump in the gradient with the normal vector:\\n\\u00a0       for (unsigned int p = 0; p < n_q_points; ++p)\\n\\u00a0         face_data.jump_residual[p] =\\n\\u00a0           ((face_data.cell_grads[p] - face_data.neighbor_grads[p]) *\\n\\u00a0            face_data.fe_face_values_cell.normal_vector(p));\\n\\u00a0 \\nNext get the dual weights for this face:\\n\\u00a0       face_data.fe_face_values_cell.get_function_values(dual_weights,\\n\\u00a0                                                         face_data.dual_weights);\\n\\u00a0 \\nFinally, we have to compute the sum over jump residuals, dual weights, and quadrature weights, to get the result for this face:\\n\\u00a0       double face_integral = 0;\\n\\u00a0       for (unsigned int p = 0; p < n_q_points; ++p)\\n\\u00a0         face_integral +=\\n\\u00a0           (face_data.jump_residual[p] * face_data.dual_weights[p] *\\n\\u00a0            face_data.fe_face_values_cell.JxW(p));\\n\\u00a0 \\nDouble check that the element already exists and that it was not already written to...\\n\\u00a0       Assert(face_integrals.find(cell->face(face_no)) != face_integrals.end(),\\n\\u00a0              ExcInternalError());\\n\\u00a0       Assert(face_integrals[cell->face(face_no)] == -1e20, ExcInternalError());\\n\\u00a0 \\n...then store computed value at assigned location. Note that the stored value does not contain the factor 1/2 that appears in the error representation. The reason is that the term actually does not have this factor if we loop over all faces in the triangulation, but only appears if we write it as a sum over all cells and all faces of each cell; we thus visit the same face twice. We take account of this by using this factor -1/2 later, when we sum up the contributions for each cell individually.\\n\\u00a0       face_integrals[cell->face(face_no)] = face_integral;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n Computing edge term error contributions \\u2013 2\\nWe are still missing the case of faces with hanging nodes. This is what is covered in this function:\\n\\u00a0     template <int dim>\\n\\u00a0     void WeightedResidual<dim>::integrate_over_irregular_face(\\n\\u00a0       const active_cell_iterator &cell,\\n\\u00a0       const unsigned int          face_no,\\n\\u00a0       const Vector<double>       &primal_solution,\\n\\u00a0       const Vector<double>       &dual_weights,\\n\\u00a0       FaceData                   &face_data,\\n\\u00a0       FaceIntegrals              &face_integrals) const\\n\\u00a0     {\\nFirst again two abbreviations, and some consistency checks whether the function is called only on faces for which it is supposed to be called:\\n\\u00a0       const unsigned int n_q_points =\\n\\u00a0         face_data.fe_face_values_cell.n_quadrature_points;\\n\\u00a0 \\n\\u00a0       const typename DoFHandler<dim>::face_iterator face = cell->face(face_no);\\n\\u00a0       const typename DoFHandler<dim>::cell_iterator neighbor =\\n\\u00a0         cell->neighbor(face_no);\\n\\u00a0       Assert(neighbor.state() == IteratorState::valid, ExcInternalError());\\n\\u00a0       Assert(neighbor->has_children(), ExcInternalError());\\n\\u00a0       (void)neighbor;\\n\\u00a0 \\nDoFHandler::cell_iteratortypename ActiveSelector::cell_iterator cell_iteratorDefinition dof_handler.h:468\\nDoFHandler::face_iteratortypename ActiveSelector::face_iterator face_iteratorDefinition dof_handler.h:486\\nThen find out which neighbor the present cell is of the adjacent cell. Note that we will operate on the children of this adjacent cell, but that their orientation is the same as that of their mother, i.e. the neighbor direction is the same.\\n\\u00a0       const unsigned int neighbor_neighbor =\\n\\u00a0         cell->neighbor_of_neighbor(face_no);\\n\\u00a0 \\nThen simply do everything we did in the previous function for one face for all the sub-faces now:\\n\\u00a0       for (unsigned int subface_no = 0; subface_no < face->n_children();\\n\\u00a0            ++subface_no)\\n\\u00a0         {\\nStart with some checks again: get an iterator pointing to the cell behind the present subface and check whether its face is a subface of the one we are considering. If that were not the case, then there would be either a bug in the neighbor_neighbor function called above, or \\u2013 worse \\u2013 some function in the library did not keep to some underlying assumptions about cells, their children, and their faces. In any case, even though this assertion should not be triggered, it does not harm to be cautious, and in optimized mode computations the assertion will be removed anyway.\\n\\u00a0           const active_cell_iterator neighbor_child =\\n\\u00a0             cell->neighbor_child_on_subface(face_no, subface_no);\\n\\u00a0           Assert(neighbor_child->face(neighbor_neighbor) ==\\n\\u00a0                    cell->face(face_no)->child(subface_no),\\n\\u00a0                  ExcInternalError());\\n\\u00a0 \\nNow start the work by again getting the gradient of the solution first at this side of the interface,\\n\\u00a0           face_data.fe_subface_values_cell.reinit(cell, face_no, subface_no);\\n\\u00a0           face_data.fe_subface_values_cell.get_function_gradients(\\n\\u00a0             primal_solution, face_data.cell_grads);\\nthen at the other side,\\n\\u00a0           face_data.fe_face_values_neighbor.reinit(neighbor_child,\\n\\u00a0                                                    neighbor_neighbor);\\n\\u00a0           face_data.fe_face_values_neighbor.get_function_gradients(\\n\\u00a0             primal_solution, face_data.neighbor_grads);\\n\\u00a0 \\nand finally building the jump residuals. Since we take the normal vector from the other cell this time, revert the sign of the first term compared to the other function:\\n\\u00a0           for (unsigned int p = 0; p < n_q_points; ++p)\\n\\u00a0             face_data.jump_residual[p] =\\n\\u00a0               ((face_data.neighbor_grads[p] - face_data.cell_grads[p]) *\\n\\u00a0                face_data.fe_face_values_neighbor.normal_vector(p));\\n\\u00a0 \\nThen get dual weights:\\n\\u00a0           face_data.fe_face_values_neighbor.get_function_values(\\n\\u00a0             dual_weights, face_data.dual_weights);\\n\\u00a0 \\nAt last, sum up the contribution of this sub-face, and set it in the global map:\\n\\u00a0           double face_integral = 0;\\n\\u00a0           for (unsigned int p = 0; p < n_q_points; ++p)\\n\\u00a0             face_integral +=\\n\\u00a0               (face_data.jump_residual[p] * face_data.dual_weights[p] *\\n\\u00a0                face_data.fe_face_values_neighbor.JxW(p));\\n\\u00a0           face_integrals[neighbor_child->face(neighbor_neighbor)] =\\n\\u00a0             face_integral;\\n\\u00a0         }\\n\\u00a0 \\nOnce the contributions of all sub-faces are computed, loop over all sub-faces to collect and store them with the mother face for simple use when later collecting the error terms of cells. Again make safety checks that the entries for the sub-faces have been computed and do not carry an invalid value.\\n\\u00a0       double sum = 0;\\n\\u00a0       for (unsigned int subface_no = 0; subface_no < face->n_children();\\n\\u00a0            ++subface_no)\\n\\u00a0         {\\n\\u00a0           Assert(face_integrals.find(face->child(subface_no)) !=\\n\\u00a0                    face_integrals.end(),\\n\\u00a0                  ExcInternalError());\\n\\u00a0           Assert(face_integrals[face->child(subface_no)] != -1e20,\\n\\u00a0                  ExcInternalError());\\n\\u00a0 \\n\\u00a0           sum += face_integrals[face->child(subface_no)];\\n\\u00a0         }\\nFinally store the value with the parent face.\\n\\u00a0       face_integrals[face] = sum;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   } // namespace LaplaceSolver\\n\\u00a0 \\n\\u00a0 \\n A simulation framework\\nIn the previous example program, we have had two functions that were used to drive the process of solving on subsequently finer grids. We extend this here to allow for a number of parameters to be passed to these functions, and put all of that into framework class.\\nYou will have noted that this program is built up of a number of small parts (evaluation functions, solver classes implementing various refinement methods, different dual functionals, different problem and data descriptions), which makes the program relatively simple to extend, but also allows to solve a large number of different problems by replacing one part by another. We reflect this flexibility by declaring a structure in the following framework class that holds a number of parameters that may be set to test various combinations of the parts of this program, and which can be used to test it at various problems and discretizations in a simple way.\\n\\u00a0   template <int dim>\\n\\u00a0   struct Framework\\n\\u00a0   {\\n\\u00a0   public:\\nFirst, we declare two abbreviations for simple use of the respective data types:\\n\\u00a0     using Evaluator     = Evaluation::EvaluationBase<dim>;\\n\\u00a0     using EvaluatorList = std::list<Evaluator *>;\\n\\u00a0 \\n\\u00a0 \\nThen we have the structure which declares all the parameters that may be set. In the default constructor of the structure, these values are all set to default values, for simple use.\\n\\u00a0     struct ProblemDescription\\n\\u00a0     {\\nFirst allow for the degrees of the piecewise polynomials by which the primal and dual problems will be discretized. They default to (bi-, tri-)linear ansatz functions for the primal, and (bi-, tri-)quadratic ones for the dual problem. If a refinement criterion is chosen that does not need the solution of a dual problem, the value of the dual finite element degree is of course ignored.\\n\\u00a0       unsigned int primal_fe_degree;\\n\\u00a0       unsigned int dual_fe_degree;\\n\\u00a0 \\nThen have an object that describes the problem type, i.e. right hand side, domain, boundary values, etc. The pointer needed here defaults to the Null pointer, i.e. you will have to set it in actual instances of this object to make it useful.\\n\\u00a0       std::unique_ptr<const Data::SetUpBase<dim>> data;\\n\\u00a0 \\nSince we allow to use different refinement criteria (global refinement, refinement by the Kelly error indicator, possibly with a weight, and using the dual estimator), define a number of enumeration values, and subsequently a variable of that type. It will default to dual_weighted_error_estimator.\\n\\u00a0       enum RefinementCriterion\\n\\u00a0       {\\n\\u00a0         dual_weighted_error_estimator,\\n\\u00a0         global_refinement,\\n\\u00a0         kelly_indicator,\\n\\u00a0         weighted_kelly_indicator\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0       RefinementCriterion refinement_criterion;\\n\\u00a0 \\nNext, an object that describes the dual functional. It is only needed if the dual weighted residual refinement is chosen, and also defaults to a Null pointer.\\n\\u00a0       std::unique_ptr<const DualFunctional::DualFunctionalBase<dim>>\\n\\u00a0         dual_functional;\\n\\u00a0 \\nThen a list of evaluation objects. Its default value is empty, i.e. no evaluation objects.\\n\\u00a0       EvaluatorList evaluator_list;\\n\\u00a0 \\nNext to last, a function that is used as a weight to the RefinementWeightedKelly class. The default value of this pointer is zero, but you have to set it to some other value if you want to use the weighted_kelly_indicator refinement criterion.\\n\\u00a0       std::unique_ptr<const Function<dim>> kelly_weight;\\n\\u00a0 \\nFinally, we have a variable that denotes the maximum number of degrees of freedom we allow for the (primal) discretization. If it is exceeded, we stop the process of solving and intermittent mesh refinement. Its default value is 20,000.\\n\\u00a0       unsigned int max_degrees_of_freedom;\\n\\u00a0 \\nFinally the default constructor of this class:\\n\\u00a0       ProblemDescription();\\n\\u00a0     };\\n\\u00a0 \\nThe driver framework class only has one method which calls solver and mesh refinement intermittently, and does some other small tasks in between. Since it does not need data besides the parameters given to it, we make it static:\\n\\u00a0     static void run(const ProblemDescription &descriptor);\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\nAs for the implementation, first the constructor of the parameter object, setting all values to their defaults:\\n\\u00a0   template <int dim>\\n\\u00a0   Framework<dim>::ProblemDescription::ProblemDescription()\\n\\u00a0     : primal_fe_degree(1)\\n\\u00a0     , dual_fe_degree(2)\\n\\u00a0     , refinement_criterion(dual_weighted_error_estimator)\\n\\u00a0     , max_degrees_of_freedom(20000)\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nThen the function which drives the whole process:\\n\\u00a0   template <int dim>\\n\\u00a0   void Framework<dim>::run(const ProblemDescription &descriptor)\\n\\u00a0   {\\nFirst create a triangulation from the given data object,\\n\\u00a0     Triangulation<dim> triangulation(\\n\\u00a0       Triangulation<dim>::smoothing_on_refinement);\\n\\u00a0     descriptor.data->create_coarse_grid(triangulation);\\n\\u00a0 \\nthen a set of finite elements and appropriate quadrature formula:\\n\\u00a0     const FE_Q<dim>       primal_fe(descriptor.primal_fe_degree);\\n\\u00a0     const FE_Q<dim>       dual_fe(descriptor.dual_fe_degree);\\n\\u00a0     const QGauss<dim>     quadrature(descriptor.dual_fe_degree + 1);\\n\\u00a0     const QGauss<dim - 1> face_quadrature(descriptor.dual_fe_degree + 1);\\n\\u00a0 \\nFE_QDefinition fe_q.h:554\\nNext, select one of the classes implementing different refinement criteria.\\n\\u00a0     std::unique_ptr<LaplaceSolver::Base<dim>> solver;\\n\\u00a0     switch (descriptor.refinement_criterion)\\n\\u00a0       {\\n\\u00a0         case ProblemDescription::dual_weighted_error_estimator:\\n\\u00a0           {\\n\\u00a0             solver = std::make_unique<LaplaceSolver::WeightedResidual<dim>>(\\n\\u00a0               triangulation,\\n\\u00a0               primal_fe,\\n\\u00a0               dual_fe,\\n\\u00a0               quadrature,\\n\\u00a0               face_quadrature,\\n\\u00a0               descriptor.data->get_right_hand_side(),\\n\\u00a0               descriptor.data->get_boundary_values(),\\n\\u00a0               *descriptor.dual_functional);\\n\\u00a0             break;\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         case ProblemDescription::global_refinement:\\n\\u00a0           {\\n\\u00a0             solver = std::make_unique<LaplaceSolver::RefinementGlobal<dim>>(\\n\\u00a0               triangulation,\\n\\u00a0               primal_fe,\\n\\u00a0               quadrature,\\n\\u00a0               face_quadrature,\\n\\u00a0               descriptor.data->get_right_hand_side(),\\n\\u00a0               descriptor.data->get_boundary_values());\\n\\u00a0             break;\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         case ProblemDescription::kelly_indicator:\\n\\u00a0           {\\n\\u00a0             solver = std::make_unique<LaplaceSolver::RefinementKelly<dim>>(\\n\\u00a0               triangulation,\\n\\u00a0               primal_fe,\\n\\u00a0               quadrature,\\n\\u00a0               face_quadrature,\\n\\u00a0               descriptor.data->get_right_hand_side(),\\n\\u00a0               descriptor.data->get_boundary_values());\\n\\u00a0             break;\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         case ProblemDescription::weighted_kelly_indicator:\\n\\u00a0           {\\n\\u00a0             solver =\\n\\u00a0               std::make_unique<LaplaceSolver::RefinementWeightedKelly<dim>>(\\n\\u00a0                 triangulation,\\n\\u00a0                 primal_fe,\\n\\u00a0                 quadrature,\\n\\u00a0                 face_quadrature,\\n\\u00a0                 descriptor.data->get_right_hand_side(),\\n\\u00a0                 descriptor.data->get_boundary_values(),\\n\\u00a0                 *descriptor.kelly_weight);\\n\\u00a0             break;\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         default:\\n\\u00a0           AssertThrow(false, ExcInternalError());\\n\\u00a0       }\\n\\u00a0 \\nNow that all objects are in place, run the main loop. The stopping criterion is implemented at the bottom of the loop.\\nIn the loop, first set the new cycle number, then solve the problem, output its solution(s), apply the evaluation objects to it, then decide whether we want to refine the mesh further and solve again on this mesh, or jump out of the loop.\\n\\u00a0     for (unsigned int step = 0; true; ++step)\\n\\u00a0       {\\n\\u00a0         std::cout << \\\"Refinement cycle: \\\" << step << std::endl;\\n\\u00a0 \\n\\u00a0         solver->set_refinement_cycle(step);\\n\\u00a0         solver->solve_problem();\\n\\u00a0         solver->output_solution();\\n\\u00a0 \\n\\u00a0         std::cout << \\\"   Number of degrees of freedom: \\\" << solver->n_dofs()\\n\\u00a0                   << std::endl;\\n\\u00a0 \\n\\u00a0         for (const auto &evaluator : descriptor.evaluator_list)\\n\\u00a0           {\\n\\u00a0             evaluator->set_refinement_cycle(step);\\n\\u00a0             solver->postprocess(*evaluator);\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0         if (solver->n_dofs() < descriptor.max_degrees_of_freedom)\\n\\u00a0           solver->refine_grid();\\n\\u00a0         else\\n\\u00a0           break;\\n\\u00a0       }\\n\\u00a0 \\nClean up the screen after the loop has run:\\n\\u00a0     std::cout << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 } // namespace Step14\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n The main function\\nHere finally comes the main function. It drives the whole process by specifying a set of parameters to be used for the simulation (polynomial degrees, evaluation and dual functionals, etc), and passes them packed into a structure to the frame work class above.\\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       using namespace Step14;\\n\\u00a0 \\nDescribe the problem we want to solve here by passing a descriptor object to the function doing the rest of the work:\\n\\u00a0       const unsigned int                 dim = 2;\\n\\u00a0       Framework<dim>::ProblemDescription descriptor;\\n\\u00a0 \\nFirst set the refinement criterion we wish to use:\\n\\u00a0       descriptor.refinement_criterion =\\n\\u00a0         Framework<dim>::ProblemDescription::dual_weighted_error_estimator;\\nHere, we could as well have used global_refinement or weighted_kelly_indicator. Note that the information given about dual finite elements, dual functional, etc is only important for the given choice of refinement criterion, and is ignored otherwise.\\nThen set the polynomial degrees of primal and dual problem. We choose here bi-linear and bi-quadratic ones:\\n\\u00a0       descriptor.primal_fe_degree = 1;\\n\\u00a0       descriptor.dual_fe_degree   = 2;\\n\\u00a0 \\nThen set the description of the test case, i.e. domain, boundary values, and right hand side. These are prepackaged in classes. We take here the description of Exercise_2_3, but you can also use CurvedRidges<dim>:\\n\\u00a0       descriptor.data =\\n\\u00a0         std::make_unique<Data::SetUp<Data::Exercise_2_3<dim>, dim>>();\\n\\u00a0 \\nNext set first a dual functional, then a list of evaluation objects. We choose as default the evaluation of the value at an evaluation point, represented by the classes PointValueEvaluation in the namespaces of evaluation and dual functional classes. You can also set the PointXDerivativeEvaluation classes for the x-derivative instead of the value at the evaluation point.\\nNote that dual functional and evaluation objects should match. However, you can give as many evaluation functionals as you want, so you can have both point value and derivative evaluated after each step. One such additional evaluation is to output the grid in each step.\\n\\u00a0       const Point<dim> evaluation_point(0.75, 0.75);\\n\\u00a0       descriptor.dual_functional =\\n\\u00a0         std::make_unique<DualFunctional::PointValueEvaluation<dim>>(\\n\\u00a0           evaluation_point);\\n\\u00a0 \\n\\u00a0       Evaluation::PointValueEvaluation<dim> postprocessor1(evaluation_point);\\n\\u00a0       Evaluation::GridOutput<dim>           postprocessor2(\\\"grid\\\");\\n\\u00a0 \\n\\u00a0       descriptor.evaluator_list.push_back(&postprocessor1);\\n\\u00a0       descriptor.evaluator_list.push_back(&postprocessor2);\\n\\u00a0 \\nSet the maximal number of degrees of freedom after which we want the program to stop refining the mesh further:\\n\\u00a0       descriptor.max_degrees_of_freedom = 20000;\\n\\u00a0 \\nFinally pass the descriptor object to a function that runs the entire solution with it:\\n\\u00a0       Framework<dim>::run(descriptor);\\n\\u00a0     }\\n\\u00a0 \\nCatch exceptions to give information about things that failed:\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nPoint values\\nThis program offers a lot of possibilities to play around. We can thus only show a small part of all possible results that can be obtained with the help of this program. However, you are encouraged to just try it out, by changing the settings in the main program. Here, we start by simply letting it run, unmodified: Refinement cycle: 0\\n   Number of degrees of freedom: 72\\n Point value: 0.03243\\n   Estimated error: 0.000702385\\nRefinement cycle: 1\\n   Number of degrees of freedom: 67\\n Point value: 0.0324827\\n   Estimated error: 0.000888953\\nRefinement cycle: 2\\n   Number of degrees of freedom: 130\\n Point value: 0.0329619\\n   Estimated error: 0.000454606\\nRefinement cycle: 3\\n   Number of degrees of freedom: 307\\n Point value: 0.0331934\\n   Estimated error: 0.000241254\\nRefinement cycle: 4\\n   Number of degrees of freedom: 718\\n Point value: 0.0333675\\n   Estimated error: 7.4912e-05\\nRefinement cycle: 5\\n   Number of degrees of freedom: 1665\\n Point value: 0.0334083\\n   Estimated error: 3.69111e-05\\nRefinement cycle: 6\\n   Number of degrees of freedom: 3975\\n Point value: 0.033431\\n   Estimated error: 1.54218e-05\\nRefinement cycle: 7\\n   Number of degrees of freedom: 8934\\n Point value: 0.0334406\\n   Estimated error: 6.28359e-06\\nRefinement cycle: 8\\n   Number of degrees of freedom: 21799\\n Point value: 0.0334444\\nFirst let's look what the program actually computed. On the seventh grid, primal and dual numerical solutions look like this (using a color scheme intended to evoke the snow-capped mountains of Colorado that the original author of this program now calls home): \\n\\n  \\n\\nApparently, the region at the bottom left is so unimportant for the point value evaluation at the top right that the grid is left entirely unrefined there, even though the solution has singularities at the inner corner of that cell! Due to the symmetry in right hand side and domain, the solution should actually look like at the top right in all four corners, but the mesh refinement criterion involving the dual solution chose to refine them differently \\u2013 because we said that we really only care about a single function value somewhere at the top right.\\nHere are some of the meshes that are produced in refinement cycles 0, 2, 4 (top row), and 5, 7, and 8 (bottom row):\\n\\n\\n   \\n\\n   \\n\\nNote the subtle interplay between resolving the corner singularities, and resolving around the point of evaluation. It will be rather difficult to generate such a mesh by hand, as this would involve to judge quantitatively how much which of the four corner singularities should be resolved, and to set the weight compared to the vicinity of the evaluation point.\\nThe program prints the point value and the estimated error in this quantity. From extrapolating it, we can guess that the exact value is somewhere close to 0.0334473, plus or minus 0.0000001 (note that we get almost 6 valid digits from only 22,000 (primal) degrees of freedom. This number cannot be obtained from the value of the functional alone, but I have used the assumption that the error estimator is mostly exact, and extrapolated the computed value plus the estimated error, to get an approximation of the true value. Computing with more degrees of freedom shows that this assumption is indeed valid.\\nFrom the computed results, we can generate two graphs: one that shows the convergence of the error \\\\(J(u)-J(u_h)\\\\) (taking the extrapolated value as correct) in the point value, and the value that we get by adding up computed value \\\\(J(u_h)\\\\) and estimated error eta (if the error estimator \\\\(eta\\\\) were exact, then the value \\\\(J(u_h)+\\\\eta\\\\) would equal the exact point value, and the error in this quantity would always be zero; however, since the error estimator is only a - good - approximation to the true error, we can by this only reduce the size of the error). In this graph, we also indicate the complexity \\\\({\\\\cal O}(1/N)\\\\) to show that mesh refinement acts optimal in this case. The second chart compares true and estimated error, and shows that the two are actually very close to each other, even for such a complicated quantity as the point value:\\n\\n\\n  \\n\\nComparing refinement criteria\\nSince we have accepted quite some effort when using the mesh refinement driven by the dual weighted error estimator (for solving the dual problem, and for evaluating the error representation), it is worth while asking whether that effort was successful. To this end, we first compare the achieved error levels for different mesh refinement criteria. To generate this data, simply change the value of the mesh refinement criterion variable in the main program. The results are thus (for the weight in the Kelly indicator, we have chosen the function \\\\(1/(r^2+0.1^2)\\\\), where \\\\(r\\\\) is the distance to the evaluation point; it can be shown that this is the optimal weight if we neglect the effects of boundaries):\\n\\nChecking these numbers, we see that for global refinement, the error is proportional to \\\\(O(1/(sqrt(N) log(N)))\\\\), and for the dual estimator \\\\(O(1/N)\\\\). Generally speaking, we see that the dual weighted error estimator is better than the other refinement indicators, at least when compared with those that have a similarly regular behavior. The Kelly indicator produces smaller errors, but jumps about the picture rather irregularly, with the error also changing signs sometimes. Therefore, its behavior does not allow to extrapolate the results to larger values of N. Furthermore, if we trust the error estimates of the dual weighted error estimator, the results can be improved by adding the estimated error to the computed values. In terms of reliability, the weighted estimator is thus better than the Kelly indicator, although the latter sometimes produces smaller errors.\\nEvaluation of point stresses\\nBesides evaluating the values of the solution at a certain point, the program also offers the possibility to evaluate the x-derivatives at a certain point, and also to tailor mesh refinement for this. To let the program compute these quantities, simply replace the two occurrences of PointValueEvaluation in the main function by PointXDerivativeEvaluation, and let the program run: Refinement cycle: 0\\n   Number of degrees of freedom: 72\\n Point x-derivative: -0.0719397\\n   Estimated error: -0.0126173\\nRefinement cycle: 1\\n   Number of degrees of freedom: 61\\n Point x-derivative: -0.0707956\\n   Estimated error: -0.00774316\\nRefinement cycle: 2\\n   Number of degrees of freedom: 131\\n Point x-derivative: -0.0568671\\n   Estimated error: -0.00313426\\nRefinement cycle: 3\\n   Number of degrees of freedom: 247\\n Point x-derivative: -0.053033\\n   Estimated error: -0.00136114\\nRefinement cycle: 4\\n   Number of degrees of freedom: 532\\n Point x-derivative: -0.0526429\\n   Estimated error: -0.000558868\\nRefinement cycle: 5\\n   Number of degrees of freedom: 1267\\n Point x-derivative: -0.0526955\\n   Estimated error: -0.000220116\\nRefinement cycle: 6\\n   Number of degrees of freedom: 2864\\n Point x-derivative: -0.0527495\\n   Estimated error: -9.46731e-05\\nRefinement cycle: 7\\n   Number of degrees of freedom: 6409\\n Point x-derivative: -0.052785\\n   Estimated error: -4.21543e-05\\nRefinement cycle: 8\\n   Number of degrees of freedom: 14183\\n Point x-derivative: -0.0528028\\n   Estimated error: -2.04241e-05\\nRefinement cycle: 9\\n   Number of degrees of freedom: 29902\\n Point x-derivative: -0.052814\\nThe solution looks roughly the same as before (the exact solution of course is the same, only the grid changed a little), but the dual solution is now different. A close-up around the point of evaluation shows this: \\n\\n  \\n\\nThis time, the grids in refinement cycles 0, 5, 6, 7, 8, and 9 look like this:\\n\\n\\n   \\n\\n   \\n\\nNote the asymmetry of the grids compared with those we obtained for the point evaluation. This is due to the fact that the domain and the primal solution may be symmetric about the diagonal, but the \\\\(x\\\\)-derivative is not, and the latter enters the refinement criterion.\\nThen, it is interesting to compare actually computed values of the quantity of interest (i.e. the x-derivative of the solution at one point) with a reference value of -0.0528223... plus or minus 0.0000005. We get this reference value by computing on finer grid after some more mesh refinements, with approximately 130,000 cells. Recall that if the error is \\\\(O(1/N)\\\\) in the optimal case, then taking a mesh with ten times more cells gives us one additional digit in the result.\\nIn the left part of the following chart, you again see the convergence of the error towards this extrapolated value, while on the right you see a comparison of true and estimated error:\\n\\n\\n  \\n\\nAfter an initial phase where the true error changes its sign, the estimated error matches it quite well, again. Also note the dramatic improvement in the error when using the estimated error to correct the computed value of \\\\(J(u_h)\\\\).\\nstep-13 revisited\\nIf instead of the Exercise_2_3 data set, we choose CurvedRidges in the main function, and choose \\\\((0.5,0.5)\\\\) as the evaluation point, then we can redo the computations of the previous example program, to compare whether the results obtained with the help of the dual weighted error estimator are better than those we had previously.\\nFirst, the meshes after 9 adaptive refinement cycles obtained with the point evaluation and derivative evaluation refinement criteria, respectively, look like this:\\n\\n\\n  \\n\\nThe features of the solution can still be seen in the mesh, but since the solution is smooth, the singularities of the dual solution entirely dominate the mesh refinement criterion, and lead to strongly concentrated meshes. The solution after the seventh refinement step looks like the following:\\n\\n\\n \\n\\nObviously, the solution is worse at some places, but the mesh refinement process should have taken care that these places are not important for computing the point value.\\nThe next point is to compare the new (duality based) mesh refinement criterion with the old ones. These are the results:\\n\\nThe results are, well, somewhat mixed. First, the Kelly indicator disqualifies itself by its unsteady behavior, changing the sign of the error several times, and with increasing errors under mesh refinement. The dual weighted error estimator has a monotone decrease in the error, and is better than the weighted Kelly and global refinement, but the margin is not as large as expected. This is, here, due to the fact the global refinement can exploit the regular structure of the meshes around the point of evaluation, which leads to a better order of convergence for the point error. However, if we had a mesh that is not locally rectangular, for example because we had to approximate curved boundaries, or if the coefficients were not constant, then this advantage of globally refinement meshes would vanish, while the good performance of the duality based estimator would remain.\\nConclusions and outlook\\nThe results here are not too clearly indicating the superiority of the dual weighted error estimation approach for mesh refinement over other mesh refinement criteria, such as the Kelly indicator. This is due to the relative simplicity of the shown applications. If you are not convinced yet that this approach is indeed superior, you are invited to browse through the literature indicated in the introduction, where plenty of examples are provided where the dual weighted approach can reduce the necessary numerical work by orders of magnitude, making this the only way to compute certain quantities to reasonable accuracies at all.\\nBesides the objections you may raise against its use as a mesh refinement criterion, consider that accurate knowledge of the error in the quantity one might want to compute is of great use, since we can stop computations when we are satisfied with the accuracy. Using more traditional approaches, it is very difficult to get accurate estimates for arbitrary quantities, except for, maybe, the error in the energy norm, and we will then have no guarantee that the result we computed satisfies any requirements on its accuracy. Also, as was shown for the evaluation of point values and derivatives, the error estimate can be used to extrapolate the results, yielding much higher accuracy in the quantity we want to know.\\nLeaving these mathematical considerations, we tried to write the program in a modular way, such that implementing another test case, or another evaluation and dual functional is simple. You are encouraged to take the program as a basis for your own experiments, and to play a little.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2002 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Author: Wolfgang Bangerth, ETH Zurich, 2002\\n */\\n \\n \\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/function.h>\\n#include <deal.II/base/thread_management.h>\\n#include <deal.II/base/work_stream.h>\\n#include <deal.II/lac/vector.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/precondition.h>\\n#include <deal.II/lac/affine_constraints.h>\\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_tools.h>\\n#include <deal.II/grid/grid_out.h>\\n#include <deal.II/grid/grid_refinement.h>\\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_tools.h>\\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_values.h>\\n#include <deal.II/fe/fe_tools.h>\\n#include <deal.II/numerics/vector_tools.h>\\n#include <deal.II/numerics/matrix_tools.h>\\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/error_estimator.h>\\n \\n#include <algorithm>\\n#include <fstream>\\n#include <iostream>\\n#include <list>\\n#include <memory>\\n#include <numeric>\\n \\nnamespace Step14\\n{\\n using namespace dealii;\\n \\n \\n namespace Evaluation\\n  {\\n template <int dim>\\n class EvaluationBase\\n    {\\n public:\\n virtual ~EvaluationBase() = default;\\n \\n void set_refinement_cycle(const unsigned int refinement_cycle);\\n \\n virtual void operator()(const DoFHandler<dim> &dof_handler,\\n const Vector<double>  &solution) const = 0;\\n \\n protected:\\n unsigned int refinement_cycle;\\n    };\\n \\n \\n \\n template <int dim>\\n void EvaluationBase<dim>::set_refinement_cycle(const unsigned int step)\\n    {\\n      refinement_cycle = step;\\n    }\\n \\n \\n template <int dim>\\n class PointValueEvaluation : public EvaluationBase<dim>\\n    {\\n public:\\n      PointValueEvaluation(const Point<dim> &evaluation_point);\\n \\n virtual void operator()(const DoFHandler<dim> &dof_handler,\\n const Vector<double>  &solution) const override;\\n \\n DeclException1(\\n        ExcEvaluationPointNotFound,\\n Point<dim>,\\n        << \\\"The evaluation point \\\" << arg1\\n        << \\\" was not found among the vertices of the present grid.\\\");\\n \\n private:\\n const Point<dim> evaluation_point;\\n    };\\n \\n \\n template <int dim>\\n    PointValueEvaluation<dim>::PointValueEvaluation(\\n const Point<dim> &evaluation_point)\\n      : evaluation_point(evaluation_point)\\n    {}\\n \\n \\n \\n template <int dim>\\n void\\n    PointValueEvaluation<dim>::operator()(const DoFHandler<dim> &dof_handler,\\n const Vector<double>  &solution) const\\n {\\n double point_value = 1e20;\\n \\n bool evaluation_point_found = false;\\n for (const auto &cell : dof_handler.active_cell_iterators())\\n        if (!evaluation_point_found)\\n          for (const auto vertex : cell->vertex_indices())\\n            if (cell->vertex(vertex).distance(evaluation_point) <\\n                cell->diameter() * 1e-8)\\n              {\\n point_value = solution(cell->vertex_dof_index(vertex, 0));\\n \\n                evaluation_point_found = true;\\n break;\\n              }\\n \\n AssertThrow(evaluation_point_found,\\n                  ExcEvaluationPointNotFound(evaluation_point));\\n \\n      std::cout << \\\"   Point value: \\\" << point_value << std::endl;\\n    }\\n \\n \\n \\n template <int dim>\\n class PointXDerivativeEvaluation : public EvaluationBase<dim>\\n    {\\n public:\\n      PointXDerivativeEvaluation(const Point<dim> &evaluation_point);\\n \\n virtual void operator()(const DoFHandler<dim> &dof_handler,\\n const Vector<double>  &solution) const;\\n \\n DeclException1(\\n        ExcEvaluationPointNotFound,\\n Point<dim>,\\n        << \\\"The evaluation point \\\" << arg1\\n        << \\\" was not found among the vertices of the present grid.\\\");\\n \\n private:\\n const Point<dim> evaluation_point;\\n    };\\n \\n \\n template <int dim>\\n    PointXDerivativeEvaluation<dim>::PointXDerivativeEvaluation(\\n const Point<dim> &evaluation_point)\\n      : evaluation_point(evaluation_point)\\n    {}\\n \\n \\n template <int dim>\\n void PointXDerivativeEvaluation<dim>::operator()(\\n const DoFHandler<dim> &dof_handler,\\n const Vector<double>  &solution) const\\n {\\n double point_derivative = 0;\\n \\n const QTrapezoid<dim>       vertex_quadrature;\\n FEValues<dim>               fe_values(dof_handler.get_fe(),\\n                              vertex_quadrature,\\n update_gradients | update_quadrature_points);\\n      std::vector<Tensor<1, dim>> solution_gradients(vertex_quadrature.size());\\n \\n unsigned int evaluation_point_hits = 0;\\n for (const auto &cell : dof_handler.active_cell_iterators())\\n        for (const auto vertex : cell->vertex_indices())\\n          if (cell->vertex(vertex) == evaluation_point)\\n            {\\n              fe_values.reinit(cell);\\n              fe_values.get_function_gradients(solution, solution_gradients);\\n \\n unsigned int q_point = 0;\\n for (; q_point < solution_gradients.size(); ++q_point)\\n if (fe_values.quadrature_point(q_point) == evaluation_point)\\n break;\\n \\n Assert(q_point < solution_gradients.size(), ExcInternalError());\\n              point_derivative += solution_gradients[q_point][0];\\n              ++evaluation_point_hits;\\n \\n break;\\n            }\\n \\n AssertThrow(evaluation_point_hits > 0,\\n                  ExcEvaluationPointNotFound(evaluation_point));\\n \\n      point_derivative /= evaluation_point_hits;\\n      std::cout << \\\"   Point x-derivative=\\\" << point_derivative << std::endl;\\n    }\\n \\n \\n \\n \\n template <int dim>\\n class GridOutput : public EvaluationBase<dim>\\n    {\\n public:\\n      GridOutput(const std::string &output_name_base);\\n \\n virtual void operator()(const DoFHandler<dim> &dof_handler,\\n const Vector<double>  &solution) const override;\\n \\n private:\\n const std::string output_name_base;\\n    };\\n \\n \\n template <int dim>\\n    GridOutput<dim>::GridOutput(const std::string &output_name_base)\\n      : output_name_base(output_name_base)\\n    {}\\n \\n \\n template <int dim>\\n void GridOutput<dim>::operator()(const DoFHandler<dim> &dof_handler,\\n const Vector<double> & /*solution*/) const\\n {\\n      std::ofstream out(output_name_base + \\\"-\\\" +\\n                        std::to_string(this->refinement_cycle) + \\\".svg\\\");\\n GridOut().write_svg(dof_handler.get_triangulation(), out);\\n    }\\n  } // namespace Evaluation\\n \\n \\n \\n namespace LaplaceSolver\\n  {\\n \\n template <int dim>\\n class Base\\n    {\\n public:\\n      Base(Triangulation<dim> &coarse_grid);\\n virtual ~Base() = default;\\n \\n virtual void solve_problem() = 0;\\n virtual void postprocess(\\n const Evaluation::EvaluationBase<dim> &postprocessor) const = 0;\\n virtual void         refine_grid()                            = 0;\\n virtual unsigned int n_dofs() const                           = 0;\\n \\n virtual void set_refinement_cycle(const unsigned int cycle);\\n \\n virtual void output_solution() const = 0;\\n \\n protected:\\n const SmartPointer<Triangulation<dim>> triangulation;\\n \\n unsigned int refinement_cycle;\\n    };\\n \\n \\n template <int dim>\\n    Base<dim>::Base(Triangulation<dim> &coarse_grid)\\n      : triangulation(&coarse_grid)\\n      , refinement_cycle(numbers::invalid_unsigned_int)\\n    {}\\n \\n \\n \\n template <int dim>\\n void Base<dim>::set_refinement_cycle(const unsigned int cycle)\\n    {\\n      refinement_cycle = cycle;\\n    }\\n \\n \\n \\n template <int dim>\\n class Solver : public virtual Base<dim>\\n    {\\n public:\\n      Solver(Triangulation<dim>        &triangulation,\\n const FiniteElement<dim>  &fe,\\n const Quadrature<dim>     &quadrature,\\n const Quadrature<dim - 1> &face_quadrature,\\n const Function<dim>       &boundary_values);\\n virtual ~Solver() override;\\n \\n virtual void solve_problem() override;\\n \\n virtual void postprocess(\\n const Evaluation::EvaluationBase<dim> &postprocessor) const override;\\n \\n virtual unsigned int n_dofs() const override;\\n \\n protected:\\n const SmartPointer<const FiniteElement<dim>>  fe;\\n const SmartPointer<const Quadrature<dim>>     quadrature;\\n const SmartPointer<const Quadrature<dim - 1>> face_quadrature;\\n DoFHandler<dim>                               dof_handler;\\n Vector<double>                                solution;\\n const SmartPointer<const Function<dim>>       boundary_values;\\n \\n virtual void assemble_rhs(Vector<double> &rhs) const = 0;\\n \\n private:\\n struct LinearSystem\\n      {\\n        LinearSystem(const DoFHandler<dim> &dof_handler);\\n \\n void solve(Vector<double> &solution) const;\\n \\n AffineConstraints<double> hanging_node_constraints;\\n SparsityPattern           sparsity_pattern;\\n SparseMatrix<double> matrix;\\n Vector<double>            rhs;\\n      };\\n \\n \\n struct AssemblyScratchData\\n      {\\n        AssemblyScratchData(const FiniteElement<dim> &fe,\\n const Quadrature<dim>    &quadrature);\\n        AssemblyScratchData(const AssemblyScratchData &scratch_data);\\n \\n FEValues<dim> fe_values;\\n      };\\n \\n struct AssemblyCopyData\\n      {\\n FullMatrix<double> cell_matrix;\\n        std::vector<types::global_dof_index> local_dof_indices;\\n      };\\n \\n \\n void assemble_linear_system(LinearSystem &linear_system);\\n \\n void local_assemble_matrix(\\n const typename DoFHandler<dim>::active_cell_iterator &cell,\\n        AssemblyScratchData                                  &scratch_data,\\n        AssemblyCopyData                                     &copy_data) const;\\n \\n \\n void copy_local_to_global(const AssemblyCopyData &copy_data,\\n                                LinearSystem           &linear_system) const;\\n    };\\n \\n \\n \\n template <int dim>\\n    Solver<dim>::Solver(Triangulation<dim>        &triangulation,\\n const FiniteElement<dim>  &fe,\\n const Quadrature<dim>     &quadrature,\\n const Quadrature<dim - 1> &face_quadrature,\\n const Function<dim>       &boundary_values)\\n      : Base<dim>(triangulation)\\n      , fe(&fe)\\n      , quadrature(&quadrature)\\n      , face_quadrature(&face_quadrature)\\n      , dof_handler(triangulation)\\n      , boundary_values(&boundary_values)\\n    {}\\n \\n \\n template <int dim>\\n    Solver<dim>::~Solver()\\n    {\\n      dof_handler.clear();\\n    }\\n \\n \\n template <int dim>\\n void Solver<dim>::solve_problem()\\n    {\\n      dof_handler.distribute_dofs(*fe);\\n      solution.reinit(dof_handler.n_dofs());\\n \\n      LinearSystem linear_system(dof_handler);\\n      assemble_linear_system(linear_system);\\n      linear_system.solve(solution);\\n    }\\n \\n \\n template <int dim>\\n void Solver<dim>::postprocess(\\n const Evaluation::EvaluationBase<dim> &postprocessor) const\\n {\\n      postprocessor(dof_handler, solution);\\n    }\\n \\n \\n template <int dim>\\n unsigned int Solver<dim>::n_dofs() const\\n {\\n return dof_handler.n_dofs();\\n    }\\n \\n \\n template <int dim>\\n void Solver<dim>::assemble_linear_system(LinearSystem &linear_system)\\n    {\\n Threads::Task<void> rhs_task =\\n Threads::new_task(&Solver<dim>::assemble_rhs, *this, linear_system.rhs);\\n \\n auto worker =\\n        [this](const typename DoFHandler<dim>::active_cell_iterator &cell,\\n               AssemblyScratchData &scratch_data,\\n               AssemblyCopyData    &copy_data) {\\n          this->local_assemble_matrix(cell, scratch_data, copy_data);\\n        };\\n \\n auto copier = [this, &linear_system](const AssemblyCopyData &copy_data) {\\n        this->copy_local_to_global(copy_data, linear_system);\\n      };\\n \\n WorkStream::run(dof_handler.begin_active(),\\n                      dof_handler.end(),\\n                      worker,\\n                      copier,\\n                      AssemblyScratchData(*fe, *quadrature),\\n                      AssemblyCopyData());\\n      linear_system.hanging_node_constraints.condense(linear_system.matrix);\\n \\n      std::map<types::global_dof_index, double> boundary_value_map;\\n VectorTools::interpolate_boundary_values(dof_handler,\\n                                               0,\\n                                               *boundary_values,\\n                                               boundary_value_map);\\n \\n      rhs_task.join();\\n      linear_system.hanging_node_constraints.condense(linear_system.rhs);\\n \\n MatrixTools::apply_boundary_values(boundary_value_map,\\n                                         linear_system.matrix,\\n                                         solution,\\n                                         linear_system.rhs);\\n    }\\n \\n \\n template <int dim>\\n    Solver<dim>::AssemblyScratchData::AssemblyScratchData(\\n const FiniteElement<dim> &fe,\\n const Quadrature<dim>    &quadrature)\\n      : fe_values(fe, quadrature, update_gradients | update_JxW_values)\\n    {}\\n \\n \\n template <int dim>\\n    Solver<dim>::AssemblyScratchData::AssemblyScratchData(\\n const AssemblyScratchData &scratch_data)\\n      : fe_values(scratch_data.fe_values.get_fe(),\\n                  scratch_data.fe_values.get_quadrature(),\\n update_gradients | update_JxW_values)\\n    {}\\n \\n \\n template <int dim>\\n void Solver<dim>::local_assemble_matrix(\\n const typename DoFHandler<dim>::active_cell_iterator &cell,\\n      AssemblyScratchData                                  &scratch_data,\\n      AssemblyCopyData                                     &copy_data) const\\n {\\n const unsigned int dofs_per_cell = fe->n_dofs_per_cell();\\n const unsigned int n_q_points    = quadrature->size();\\n \\n      copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);\\n \\n      copy_data.local_dof_indices.resize(dofs_per_cell);\\n \\n      scratch_data.fe_values.reinit(cell);\\n \\n for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n            copy_data.cell_matrix(i, j) +=\\n              (scratch_data.fe_values.shape_grad(i, q_point) *\\n               scratch_data.fe_values.shape_grad(j, q_point) *\\n               scratch_data.fe_values.JxW(q_point));\\n \\n      cell->get_dof_indices(copy_data.local_dof_indices);\\n    }\\n \\n \\n \\n template <int dim>\\n void Solver<dim>::copy_local_to_global(const AssemblyCopyData &copy_data,\\n                                           LinearSystem &linear_system) const\\n {\\n for (unsigned int i = 0; i < copy_data.local_dof_indices.size(); ++i)\\n for (unsigned int j = 0; j < copy_data.local_dof_indices.size(); ++j)\\n          linear_system.matrix.add(copy_data.local_dof_indices[i],\\n                                   copy_data.local_dof_indices[j],\\n                                   copy_data.cell_matrix(i, j));\\n    }\\n \\n \\n template <int dim>\\n    Solver<dim>::LinearSystem::LinearSystem(const DoFHandler<dim> &dof_handler)\\n    {\\n      hanging_node_constraints.clear();\\n \\n      void (*mhnc_p)(const DoFHandler<dim> &, AffineConstraints<double> &) =\\n        &DoFTools::make_hanging_node_constraints;\\n \\n Threads::Task<void> side_task =\\n Threads::new_task(mhnc_p, dof_handler, hanging_node_constraints);\\n \\n DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());\\n DoFTools::make_sparsity_pattern(dof_handler, dsp);\\n \\n \\n \\n      side_task.join();\\n \\n      hanging_node_constraints.close();\\n      hanging_node_constraints.condense(dsp);\\n      sparsity_pattern.copy_from(dsp);\\n \\n matrix.reinit(sparsity_pattern);\\n      rhs.reinit(dof_handler.n_dofs());\\n    }\\n \\n \\n \\n template <int dim>\\n void Solver<dim>::LinearSystem::solve(Vector<double> &solution) const\\n {\\n SolverControl            solver_control(5000, 1e-12);\\n SolverCG<Vector<double>> cg(solver_control);\\n \\n PreconditionSSOR<SparseMatrix<double>> preconditioner;\\n      preconditioner.initialize(matrix, 1.2);\\n \\n      cg.solve(matrix, solution, rhs, preconditioner);\\n \\n      hanging_node_constraints.distribute(solution);\\n    }\\n \\n \\n \\n \\n template <int dim>\\n class PrimalSolver : public Solver<dim>\\n    {\\n public:\\n      PrimalSolver(Triangulation<dim>        &triangulation,\\n const FiniteElement<dim>  &fe,\\n const Quadrature<dim>     &quadrature,\\n const Quadrature<dim - 1> &face_quadrature,\\n const Function<dim>       &rhs_function,\\n const Function<dim>       &boundary_values);\\n \\n virtual void output_solution() const override;\\n \\n protected:\\n const SmartPointer<const Function<dim>> rhs_function;\\n virtual void assemble_rhs(Vector<double> &rhs) const override;\\n    };\\n \\n \\n template <int dim>\\n    PrimalSolver<dim>::PrimalSolver(Triangulation<dim>        &triangulation,\\n const FiniteElement<dim>  &fe,\\n const Quadrature<dim>     &quadrature,\\n const Quadrature<dim - 1> &face_quadrature,\\n const Function<dim>       &rhs_function,\\n const Function<dim>       &boundary_values)\\n      : Base<dim>(triangulation)\\n      , Solver<dim>(triangulation,\\n                    fe,\\n                    quadrature,\\n                    face_quadrature,\\n                    boundary_values)\\n      , rhs_function(&rhs_function)\\n    {}\\n \\n \\n \\n template <int dim>\\n void PrimalSolver<dim>::output_solution() const\\n {\\n DataOut<dim> data_out;\\n      data_out.attach_dof_handler(this->dof_handler);\\n      data_out.add_data_vector(this->solution, \\\"solution\\\");\\n      data_out.build_patches();\\n \\n      std::ofstream out(\\\"solution-\\\" + std::to_string(this->refinement_cycle) +\\n \\\".vtu\\\");\\n      data_out.write(out, DataOutBase::vtu);\\n    }\\n \\n \\n \\n template <int dim>\\n void PrimalSolver<dim>::assemble_rhs(Vector<double> &rhs) const\\n {\\n FEValues<dim> fe_values(*this->fe,\\n                              *this->quadrature,\\n update_values | update_quadrature_points |\\n update_JxW_values);\\n \\n const unsigned int dofs_per_cell = this->fe->n_dofs_per_cell();\\n const unsigned int n_q_points    = this->quadrature->size();\\n \\n Vector<double>                       cell_rhs(dofs_per_cell);\\n      std::vector<double>                  rhs_values(n_q_points);\\n      std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n for (const auto &cell : this->dof_handler.active_cell_iterators())\\n        {\\n          cell_rhs = 0;\\n \\n          fe_values.reinit(cell);\\n \\n          rhs_function->value_list(fe_values.get_quadrature_points(),\\n                                   rhs_values);\\n \\n for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n              cell_rhs(i) += (fe_values.shape_value(i, q_point) * // phi_i(x_q)\\n                              rhs_values[q_point] *               // f((x_q)\\n                              fe_values.JxW(q_point));            // dx\\n \\n          cell->get_dof_indices(local_dof_indices);\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n            rhs(local_dof_indices[i]) += cell_rhs(i);\\n        }\\n    }\\n \\n \\n \\n template <int dim>\\n class RefinementGlobal : public PrimalSolver<dim>\\n    {\\n public:\\n      RefinementGlobal(Triangulation<dim>        &coarse_grid,\\n const FiniteElement<dim>  &fe,\\n const Quadrature<dim>     &quadrature,\\n const Quadrature<dim - 1> &face_quadrature,\\n const Function<dim>       &rhs_function,\\n const Function<dim>       &boundary_values);\\n \\n virtual void refine_grid() override;\\n    };\\n \\n \\n \\n template <int dim>\\n    RefinementGlobal<dim>::RefinementGlobal(\\n Triangulation<dim>        &coarse_grid,\\n const FiniteElement<dim>  &fe,\\n const Quadrature<dim>     &quadrature,\\n const Quadrature<dim - 1> &face_quadrature,\\n const Function<dim>       &rhs_function,\\n const Function<dim>       &boundary_values)\\n      : Base<dim>(coarse_grid)\\n      , PrimalSolver<dim>(coarse_grid,\\n                          fe,\\n                          quadrature,\\n                          face_quadrature,\\n                          rhs_function,\\n                          boundary_values)\\n    {}\\n \\n \\n \\n template <int dim>\\n void RefinementGlobal<dim>::refine_grid()\\n    {\\n      this->triangulation->refine_global(1);\\n    }\\n \\n \\n \\n template <int dim>\\n class RefinementKelly : public PrimalSolver<dim>\\n    {\\n public:\\n      RefinementKelly(Triangulation<dim>        &coarse_grid,\\n const FiniteElement<dim>  &fe,\\n const Quadrature<dim>     &quadrature,\\n const Quadrature<dim - 1> &face_quadrature,\\n const Function<dim>       &rhs_function,\\n const Function<dim>       &boundary_values);\\n \\n virtual void refine_grid() override;\\n    };\\n \\n \\n \\n template <int dim>\\n    RefinementKelly<dim>::RefinementKelly(\\n Triangulation<dim>        &coarse_grid,\\n const FiniteElement<dim>  &fe,\\n const Quadrature<dim>     &quadrature,\\n const Quadrature<dim - 1> &face_quadrature,\\n const Function<dim>       &rhs_function,\\n const Function<dim>       &boundary_values)\\n      : Base<dim>(coarse_grid)\\n      , PrimalSolver<dim>(coarse_grid,\\n                          fe,\\n                          quadrature,\\n                          face_quadrature,\\n                          rhs_function,\\n                          boundary_values)\\n    {}\\n \\n \\n \\n template <int dim>\\n void RefinementKelly<dim>::refine_grid()\\n    {\\n Vector<float> estimated_error_per_cell(\\n        this->triangulation->n_active_cells());\\n KellyErrorEstimator<dim>::estimate(\\n        this->dof_handler,\\n QGauss<dim - 1>(this->fe->degree + 1),\\n        std::map<types::boundary_id, const Function<dim> *>(),\\n        this->solution,\\n        estimated_error_per_cell);\\n GridRefinement::refine_and_coarsen_fixed_number(*this->triangulation,\\n                                                      estimated_error_per_cell,\\n                                                      0.3,\\n                                                      0.03);\\n      this->triangulation->execute_coarsening_and_refinement();\\n    }\\n \\n \\n \\n \\n template <int dim>\\n class RefinementWeightedKelly : public PrimalSolver<dim>\\n    {\\n public:\\n      RefinementWeightedKelly(Triangulation<dim>        &coarse_grid,\\n const FiniteElement<dim>  &fe,\\n const Quadrature<dim>     &quadrature,\\n const Quadrature<dim - 1> &face_quadrature,\\n const Function<dim>       &rhs_function,\\n const Function<dim>       &boundary_values,\\n const Function<dim>       &weighting_function);\\n \\n virtual void refine_grid() override;\\n \\n private:\\n const SmartPointer<const Function<dim>> weighting_function;\\n    };\\n \\n \\n \\n template <int dim>\\n    RefinementWeightedKelly<dim>::RefinementWeightedKelly(\\n Triangulation<dim>        &coarse_grid,\\n const FiniteElement<dim>  &fe,\\n const Quadrature<dim>     &quadrature,\\n const Quadrature<dim - 1> &face_quadrature,\\n const Function<dim>       &rhs_function,\\n const Function<dim>       &boundary_values,\\n const Function<dim>       &weighting_function)\\n      : Base<dim>(coarse_grid)\\n      , PrimalSolver<dim>(coarse_grid,\\n                          fe,\\n                          quadrature,\\n                          face_quadrature,\\n                          rhs_function,\\n                          boundary_values)\\n      , weighting_function(&weighting_function)\\n    {}\\n \\n \\n \\n template <int dim>\\n void RefinementWeightedKelly<dim>::refine_grid()\\n    {\\n Vector<float> estimated_error_per_cell(\\n        this->triangulation->n_active_cells());\\n      std::map<types::boundary_id, const Function<dim> *> dummy_function_map;\\n KellyErrorEstimator<dim>::estimate(this->dof_handler,\\n                                         *this->face_quadrature,\\n                                         dummy_function_map,\\n                                         this->solution,\\n                                         estimated_error_per_cell);\\n \\n for (const auto &cell : this->dof_handler.active_cell_iterators())\\n        estimated_error_per_cell(cell->active_cell_index()) *=\\n          weighting_function->value(cell->center());\\n \\n GridRefinement::refine_and_coarsen_fixed_number(*this->triangulation,\\n                                                      estimated_error_per_cell,\\n                                                      0.3,\\n                                                      0.03);\\n      this->triangulation->execute_coarsening_and_refinement();\\n    }\\n \\n  } // namespace LaplaceSolver\\n \\n \\n namespace Data\\n  {\\n \\n template <int dim>\\n struct SetUpBase : public Subscriptor\\n    {\\n virtual const Function<dim> &get_boundary_values() const = 0;\\n \\n virtual const Function<dim> &get_right_hand_side() const = 0;\\n \\n virtual void\\n      create_coarse_grid(Triangulation<dim> &coarse_grid) const = 0;\\n    };\\n \\n \\n template <class Traits, int dim>\\n struct SetUp : public SetUpBase<dim>\\n    {\\n virtual const Function<dim> &get_boundary_values() const override;\\n \\n virtual const Function<dim> &get_right_hand_side() const override;\\n \\n \\n virtual void\\n      create_coarse_grid(Triangulation<dim> &coarse_grid) const override;\\n \\n private:\\n static const typename Traits::BoundaryValues boundary_values;\\n static const typename Traits::RightHandSide  right_hand_side;\\n    };\\n \\n template <class Traits, int dim>\\n const typename Traits::BoundaryValues SetUp<Traits, dim>::boundary_values;\\n template <class Traits, int dim>\\n const typename Traits::RightHandSide SetUp<Traits, dim>::right_hand_side;\\n \\n template <class Traits, int dim>\\n const Function<dim> &SetUp<Traits, dim>::get_boundary_values() const\\n {\\n return boundary_values;\\n    }\\n \\n \\n template <class Traits, int dim>\\n const Function<dim> &SetUp<Traits, dim>::get_right_hand_side() const\\n {\\n return right_hand_side;\\n    }\\n \\n \\n template <class Traits, int dim>\\n void SetUp<Traits, dim>::create_coarse_grid(\\n Triangulation<dim> &coarse_grid) const\\n {\\n      Traits::create_coarse_grid(coarse_grid);\\n    }\\n \\n \\n \\n template <int dim>\\n struct CurvedRidges\\n    {\\n class BoundaryValues : public Function<dim>\\n      {\\n public:\\n virtual double value(const Point<dim>  &p,\\n const unsigned int component) const;\\n      };\\n \\n \\n class RightHandSide : public Function<dim>\\n      {\\n public:\\n virtual double value(const Point<dim>  &p,\\n const unsigned int component) const;\\n      };\\n \\n static void create_coarse_grid(Triangulation<dim> &coarse_grid);\\n    };\\n \\n \\n template <int dim>\\n double CurvedRidges<dim>::BoundaryValues::value(\\n const Point<dim> &p,\\n const unsigned int /*component*/) const\\n {\\n double q = p(0);\\n for (unsigned int i = 1; i < dim; ++i)\\n        q += std::sin(10 * p(i) + 5 * p(0) * p(0));\\n const double exponential = std::exp(q);\\n return exponential;\\n    }\\n \\n \\n \\n template <int dim>\\n double CurvedRidges<dim>::RightHandSide::value(\\n const Point<dim> &p,\\n const unsigned int /*component*/) const\\n {\\n double q = p(0);\\n for (unsigned int i = 1; i < dim; ++i)\\n        q += std::sin(10 * p(i) + 5 * p(0) * p(0));\\n const double u  = std::exp(q);\\n double       t1 = 1, t2 = 0, t3 = 0;\\n for (unsigned int i = 1; i < dim; ++i)\\n        {\\n          t1 += std::cos(10 * p(i) + 5 * p(0) * p(0)) * 10 * p(0);\\n          t2 += 10 * std::cos(10 * p(i) + 5 * p(0) * p(0)) -\\n                100 * std::sin(10 * p(i) + 5 * p(0) * p(0)) * p(0) * p(0);\\n          t3 += 100 * std::cos(10 * p(i) + 5 * p(0) * p(0)) *\\n std::cos(10 * p(i) + 5 * p(0) * p(0)) -\\n                100 * std::sin(10 * p(i) + 5 * p(0) * p(0));\\n        }\\n      t1 = t1 * t1;\\n \\n return -u * (t1 + t2 + t3);\\n    }\\n \\n \\n template <int dim>\\n void CurvedRidges<dim>::create_coarse_grid(Triangulation<dim> &coarse_grid)\\n    {\\n GridGenerator::hyper_cube(coarse_grid, -1, 1);\\n      coarse_grid.refine_global(2);\\n    }\\n \\n \\n \\n template <int dim>\\n struct Exercise_2_3\\n    {\\n using BoundaryValues = Functions::ZeroFunction<dim>;\\n \\n class RightHandSide : public Functions::ConstantFunction<dim>\\n      {\\n public:\\n        RightHandSide()\\n          : Functions::ConstantFunction<dim>(1.)\\n        {}\\n      };\\n \\n static void create_coarse_grid(Triangulation<dim> &coarse_grid);\\n    };\\n \\n \\n template <>\\n void Exercise_2_3<2>::create_coarse_grid(Triangulation<2> &coarse_grid)\\n    {\\n const unsigned int dim = 2;\\n \\n const std::vector<Point<2>> vertices = {\\n        {-1.0, -1.0}, {-0.5, -1.0}, {+0.0, -1.0}, {+0.5, -1.0}, {+1.0, -1.0}, \\n        {-1.0, -0.5}, {-0.5, -0.5}, {+0.0, -0.5}, {+0.5, -0.5}, {+1.0, -0.5}, \\n        {-1.0, +0.0}, {-0.5, +0.0}, {+0.5, +0.0}, {+1.0, +0.0},               \\n        {-1.0, +0.5}, {-0.5, +0.5}, {+0.0, +0.5}, {+0.5, +0.5}, {+1.0, +0.5}, \\n        {-1.0, +1.0}, {-0.5, +1.0}, {+0.0, +1.0}, {+0.5, +1.0}, {+1.0, +1.0}};\\n \\n const std::vector<std::array<int, GeometryInfo<dim>::vertices_per_cell>>\\n        cell_vertices = {{{0, 1, 5, 6}},\\n                         {{1, 2, 6, 7}},\\n                         {{2, 3, 7, 8}},\\n                         {{3, 4, 8, 9}},\\n                         {{5, 6, 10, 11}},\\n                         {{8, 9, 12, 13}},\\n                         {{10, 11, 14, 15}},\\n                         {{12, 13, 17, 18}},\\n                         {{14, 15, 19, 20}},\\n                         {{15, 16, 20, 21}},\\n                         {{16, 17, 21, 22}},\\n                         {{17, 18, 22, 23}}};\\n \\n const unsigned int n_cells = cell_vertices.size();\\n \\n      std::vector<CellData<dim>> cells(n_cells, CellData<dim>());\\n for (unsigned int i = 0; i < n_cells; ++i)\\n        {\\n for (unsigned int j = 0; j < cell_vertices[i].size(); ++j)\\n            cells[i].vertices[j] = cell_vertices[i][j];\\n          cells[i].material_id = 0;\\n        }\\n \\n GridTools::consistently_order_cells(cells);\\n      coarse_grid.create_triangulation(vertices, cells, SubCellData());\\n \\n      coarse_grid.refine_global(1);\\n    }\\n  } // namespace Data\\n \\n \\n \\n \\n namespace DualFunctional\\n  {\\n \\n template <int dim>\\n class DualFunctionalBase : public Subscriptor\\n    {\\n public:\\n virtual void assemble_rhs(const DoFHandler<dim> &dof_handler,\\n Vector<double>        &rhs) const = 0;\\n    };\\n \\n \\n \\n template <int dim>\\n class PointValueEvaluation : public DualFunctionalBase<dim>\\n    {\\n public:\\n      PointValueEvaluation(const Point<dim> &evaluation_point);\\n \\n virtual void assemble_rhs(const DoFHandler<dim> &dof_handler,\\n Vector<double>        &rhs) const override;\\n \\n DeclException1(\\n        ExcEvaluationPointNotFound,\\n Point<dim>,\\n        << \\\"The evaluation point \\\" << arg1\\n        << \\\" was not found among the vertices of the present grid.\\\");\\n \\n protected:\\n const Point<dim> evaluation_point;\\n    };\\n \\n \\n template <int dim>\\n    PointValueEvaluation<dim>::PointValueEvaluation(\\n const Point<dim> &evaluation_point)\\n      : evaluation_point(evaluation_point)\\n    {}\\n \\n \\n template <int dim>\\n void\\n    PointValueEvaluation<dim>::assemble_rhs(const DoFHandler<dim> &dof_handler,\\n Vector<double>        &rhs) const\\n {\\n      rhs.reinit(dof_handler.n_dofs());\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n        for (const auto vertex : cell->vertex_indices())\\n          if (cell->vertex(vertex).distance(evaluation_point) <\\n              cell->diameter() * 1e-8)\\n            {\\n              rhs(cell->vertex_dof_index(vertex, 0)) = 1;\\n return;\\n            }\\n \\n AssertThrow(false, ExcEvaluationPointNotFound(evaluation_point));\\n    }\\n \\n \\n \\n template <int dim>\\n class PointXDerivativeEvaluation : public DualFunctionalBase<dim>\\n    {\\n public:\\n      PointXDerivativeEvaluation(const Point<dim> &evaluation_point);\\n \\n virtual void assemble_rhs(const DoFHandler<dim> &dof_handler,\\n Vector<double>        &rhs) const;\\n \\n DeclException1(\\n        ExcEvaluationPointNotFound,\\n Point<dim>,\\n        << \\\"The evaluation point \\\" << arg1\\n        << \\\" was not found among the vertices of the present grid.\\\");\\n \\n protected:\\n const Point<dim> evaluation_point;\\n    };\\n \\n \\n template <int dim>\\n    PointXDerivativeEvaluation<dim>::PointXDerivativeEvaluation(\\n const Point<dim> &evaluation_point)\\n      : evaluation_point(evaluation_point)\\n    {}\\n \\n \\n template <int dim>\\n void PointXDerivativeEvaluation<dim>::assemble_rhs(\\n const DoFHandler<dim> &dof_handler,\\n Vector<double>        &rhs) const\\n {\\n      rhs.reinit(dof_handler.n_dofs());\\n \\n const QGauss<dim>  quadrature(dof_handler.get_fe().degree + 1);\\n FEValues<dim>      fe_values(dof_handler.get_fe(),\\n                              quadrature,\\n update_gradients | update_quadrature_points |\\n update_JxW_values);\\n const unsigned int n_q_points    = fe_values.n_quadrature_points;\\n const unsigned int dofs_per_cell = dof_handler.get_fe().dofs_per_cell;\\n \\n Vector<double>            cell_rhs(dofs_per_cell);\\n      std::vector<unsigned int> local_dof_indices(dofs_per_cell);\\n \\n double total_volume = 0;\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n        if (cell->center().distance(evaluation_point) <= cell->diameter())\\n          {\\n            fe_values.reinit(cell);\\n            cell_rhs = 0;\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n              {\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n                  cell_rhs(i) +=\\n                    fe_values.shape_grad(i, q)[0] // (d/dx phi_i(x_q))\\n                    * fe_values.JxW(q);           // * dx\\n                total_volume += fe_values.JxW(q);\\n              }\\n \\n            cell->get_dof_indices(local_dof_indices);\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n              rhs(local_dof_indices[i]) += cell_rhs(i);\\n          }\\n \\n AssertThrow(total_volume > 0,\\n                  ExcEvaluationPointNotFound(evaluation_point));\\n \\n      rhs /= total_volume;\\n    }\\n \\n \\n  } // namespace DualFunctional\\n \\n \\n namespace LaplaceSolver\\n  {\\n \\n template <int dim>\\n class DualSolver : public Solver<dim>\\n    {\\n public:\\n      DualSolver(\\n Triangulation<dim>                            &triangulation,\\n const FiniteElement<dim>                      &fe,\\n const Quadrature<dim>                         &quadrature,\\n const Quadrature<dim - 1>                     &face_quadrature,\\n const DualFunctional::DualFunctionalBase<dim> &dual_functional);\\n \\n protected:\\n const SmartPointer<const DualFunctional::DualFunctionalBase<dim>>\\n                   dual_functional;\\n virtual void assemble_rhs(Vector<double> &rhs) const override;\\n \\n static const Functions::ZeroFunction<dim> boundary_values;\\n    };\\n \\n template <int dim>\\n const Functions::ZeroFunction<dim> DualSolver<dim>::boundary_values;\\n \\n template <int dim>\\n    DualSolver<dim>::DualSolver(\\n Triangulation<dim>                            &triangulation,\\n const FiniteElement<dim>                      &fe,\\n const Quadrature<dim>                         &quadrature,\\n const Quadrature<dim - 1>                     &face_quadrature,\\n const DualFunctional::DualFunctionalBase<dim> &dual_functional)\\n      : Base<dim>(triangulation)\\n      , Solver<dim>(triangulation,\\n                    fe,\\n                    quadrature,\\n                    face_quadrature,\\n                    boundary_values)\\n      , dual_functional(&dual_functional)\\n    {}\\n \\n \\n \\n template <int dim>\\n void DualSolver<dim>::assemble_rhs(Vector<double> &rhs) const\\n {\\n      dual_functional->assemble_rhs(this->dof_handler, rhs);\\n    }\\n \\n \\n \\n template <int dim>\\n class WeightedResidual : public PrimalSolver<dim>, public DualSolver<dim>\\n    {\\n public:\\n      WeightedResidual(\\n Triangulation<dim>                            &coarse_grid,\\n const FiniteElement<dim>                      &primal_fe,\\n const FiniteElement<dim>                      &dual_fe,\\n const Quadrature<dim>                         &quadrature,\\n const Quadrature<dim - 1>                     &face_quadrature,\\n const Function<dim>                           &rhs_function,\\n const Function<dim>                           &boundary_values,\\n const DualFunctional::DualFunctionalBase<dim> &dual_functional);\\n \\n virtual void solve_problem() override;\\n \\n virtual void postprocess(\\n const Evaluation::EvaluationBase<dim> &postprocessor) const override;\\n \\n virtual unsigned int n_dofs() const override;\\n \\n virtual void refine_grid() override;\\n \\n virtual void output_solution() const override;\\n \\n private:\\n void solve_primal_problem();\\n void solve_dual_problem();\\n \\n using active_cell_iterator =\\n typename DoFHandler<dim>::active_cell_iterator;\\n \\n using FaceIntegrals =\\n typename std::map<typename DoFHandler<dim>::face_iterator, double>;\\n \\n struct CellData\\n      {\\n FEValues<dim>                           fe_values;\\n const SmartPointer<const Function<dim>> right_hand_side;\\n \\n        std::vector<double> cell_residual;\\n        std::vector<double> rhs_values;\\n        std::vector<double> dual_weights;\\n        std::vector<double> cell_laplacians;\\n CellData(const FiniteElement<dim> &fe,\\n const Quadrature<dim>    &quadrature,\\n const Function<dim>      &right_hand_side);\\n CellData(const CellData &cell_data);\\n      };\\n \\n struct FaceData\\n      {\\n FEFaceValues<dim>    fe_face_values_cell;\\n FEFaceValues<dim>    fe_face_values_neighbor;\\n FESubfaceValues<dim> fe_subface_values_cell;\\n \\n        std::vector<double>                  jump_residual;\\n        std::vector<double>                  dual_weights;\\n typename std::vector<Tensor<1, dim>> cell_grads;\\n typename std::vector<Tensor<1, dim>> neighbor_grads;\\n        FaceData(const FiniteElement<dim>  &fe,\\n const Quadrature<dim - 1> &face_quadrature);\\n        FaceData(const FaceData &face_data);\\n      };\\n \\n struct WeightedResidualScratchData\\n      {\\n        WeightedResidualScratchData(\\n const FiniteElement<dim>  &primal_fe,\\n const Quadrature<dim>     &primal_quadrature,\\n const Quadrature<dim - 1> &primal_face_quadrature,\\n const Function<dim>       &rhs_function,\\n const Vector<double>      &primal_solution,\\n const Vector<double>      &dual_weights);\\n \\n        WeightedResidualScratchData(\\n const WeightedResidualScratchData &scratch_data);\\n \\n CellData       cell_data;\\n        FaceData       face_data;\\n Vector<double> primal_solution;\\n Vector<double> dual_weights;\\n      };\\n \\n \\n struct WeightedResidualCopyData\\n      {};\\n \\n \\n \\n void estimate_error(Vector<float> &error_indicators) const;\\n \\n void estimate_on_one_cell(const active_cell_iterator  &cell,\\n                                WeightedResidualScratchData &scratch_data,\\n                                WeightedResidualCopyData    &copy_data,\\n Vector<float>               &error_indicators,\\n                                FaceIntegrals &face_integrals) const;\\n \\n void integrate_over_cell(const active_cell_iterator &cell,\\n const Vector<double>       &primal_solution,\\n const Vector<double>       &dual_weights,\\n CellData                   &cell_data,\\n Vector<float> &error_indicators) const;\\n \\n void integrate_over_regular_face(const active_cell_iterator &cell,\\n const unsigned int          face_no,\\n const Vector<double> &primal_solution,\\n const Vector<double> &dual_weights,\\n                                       FaceData             &face_data,\\n                                       FaceIntegrals &face_integrals) const;\\n void integrate_over_irregular_face(const active_cell_iterator &cell,\\n const unsigned int          face_no,\\n const Vector<double> &primal_solution,\\n const Vector<double> &dual_weights,\\n                                         FaceData             &face_data,\\n                                         FaceIntegrals &face_integrals) const;\\n    };\\n \\n \\n \\n template <int dim>\\n    WeightedResidual<dim>::CellData::CellData(\\n const FiniteElement<dim> &fe,\\n const Quadrature<dim>    &quadrature,\\n const Function<dim>      &right_hand_side)\\n      : fe_values(fe,\\n                  quadrature,\\n update_values | update_hessians | update_quadrature_points |\\n update_JxW_values)\\n      , right_hand_side(&right_hand_side)\\n      , cell_residual(quadrature.size())\\n      , rhs_values(quadrature.size())\\n      , dual_weights(quadrature.size())\\n      , cell_laplacians(quadrature.size())\\n    {}\\n \\n \\n \\n template <int dim>\\n    WeightedResidual<dim>::CellData::CellData(const CellData &cell_data)\\n      : fe_values(cell_data.fe_values.get_fe(),\\n                  cell_data.fe_values.get_quadrature(),\\n update_values | update_hessians | update_quadrature_points |\\n update_JxW_values)\\n      , right_hand_side(cell_data.right_hand_side)\\n      , cell_residual(cell_data.cell_residual)\\n      , rhs_values(cell_data.rhs_values)\\n      , dual_weights(cell_data.dual_weights)\\n      , cell_laplacians(cell_data.cell_laplacians)\\n    {}\\n \\n \\n \\n template <int dim>\\n    WeightedResidual<dim>::FaceData::FaceData(\\n const FiniteElement<dim>  &fe,\\n const Quadrature<dim - 1> &face_quadrature)\\n      : fe_face_values_cell(fe,\\n                            face_quadrature,\\n update_values | update_gradients |\\n update_JxW_values | update_normal_vectors)\\n      , fe_face_values_neighbor(fe,\\n                                face_quadrature,\\n update_values | update_gradients |\\n update_JxW_values | update_normal_vectors)\\n      , fe_subface_values_cell(fe, face_quadrature, update_gradients)\\n    {\\n const unsigned int n_face_q_points = face_quadrature.size();\\n \\n      jump_residual.resize(n_face_q_points);\\n      dual_weights.resize(n_face_q_points);\\n      cell_grads.resize(n_face_q_points);\\n      neighbor_grads.resize(n_face_q_points);\\n    }\\n \\n \\n \\n template <int dim>\\n    WeightedResidual<dim>::FaceData::FaceData(const FaceData &face_data)\\n      : fe_face_values_cell(face_data.fe_face_values_cell.get_fe(),\\n                            face_data.fe_face_values_cell.get_quadrature(),\\n update_values | update_gradients |\\n update_JxW_values | update_normal_vectors)\\n      , fe_face_values_neighbor(\\n          face_data.fe_face_values_neighbor.get_fe(),\\n          face_data.fe_face_values_neighbor.get_quadrature(),\\n update_values | update_gradients | update_JxW_values |\\n update_normal_vectors)\\n      , fe_subface_values_cell(\\n          face_data.fe_subface_values_cell.get_fe(),\\n          face_data.fe_subface_values_cell.get_quadrature(),\\n update_gradients)\\n      , jump_residual(face_data.jump_residual)\\n      , dual_weights(face_data.dual_weights)\\n      , cell_grads(face_data.cell_grads)\\n      , neighbor_grads(face_data.neighbor_grads)\\n    {}\\n \\n \\n \\n template <int dim>\\n    WeightedResidual<dim>::WeightedResidualScratchData::\\n      WeightedResidualScratchData(\\n const FiniteElement<dim>  &primal_fe,\\n const Quadrature<dim>     &primal_quadrature,\\n const Quadrature<dim - 1> &primal_face_quadrature,\\n const Function<dim>       &rhs_function,\\n const Vector<double>      &primal_solution,\\n const Vector<double>      &dual_weights)\\n      : cell_data(primal_fe, primal_quadrature, rhs_function)\\n      , face_data(primal_fe, primal_face_quadrature)\\n      , primal_solution(primal_solution)\\n      , dual_weights(dual_weights)\\n    {}\\n \\n template <int dim>\\n    WeightedResidual<dim>::WeightedResidualScratchData::\\n      WeightedResidualScratchData(\\n const WeightedResidualScratchData &scratch_data)\\n      : cell_data(scratch_data.cell_data)\\n      , face_data(scratch_data.face_data)\\n      , primal_solution(scratch_data.primal_solution)\\n      , dual_weights(scratch_data.dual_weights)\\n    {}\\n \\n \\n \\n template <int dim>\\n    WeightedResidual<dim>::WeightedResidual(\\n Triangulation<dim>                            &coarse_grid,\\n const FiniteElement<dim>                      &primal_fe,\\n const FiniteElement<dim>                      &dual_fe,\\n const Quadrature<dim>                         &quadrature,\\n const Quadrature<dim - 1>                     &face_quadrature,\\n const Function<dim>                           &rhs_function,\\n const Function<dim>                           &bv,\\n const DualFunctional::DualFunctionalBase<dim> &dual_functional)\\n      : Base<dim>(coarse_grid)\\n      , PrimalSolver<dim>(coarse_grid,\\n                          primal_fe,\\n                          quadrature,\\n                          face_quadrature,\\n                          rhs_function,\\n                          bv)\\n      , DualSolver<dim>(coarse_grid,\\n                        dual_fe,\\n                        quadrature,\\n                        face_quadrature,\\n                        dual_functional)\\n    {}\\n \\n \\n template <int dim>\\n void WeightedResidual<dim>::solve_problem()\\n    {\\n Threads::TaskGroup<void> tasks;\\n      tasks +=\\n Threads::new_task(&WeightedResidual<dim>::solve_primal_problem, *this);\\n      tasks +=\\n Threads::new_task(&WeightedResidual<dim>::solve_dual_problem, *this);\\n      tasks.join_all();\\n    }\\n \\n \\n template <int dim>\\n void WeightedResidual<dim>::solve_primal_problem()\\n    {\\n      PrimalSolver<dim>::solve_problem();\\n    }\\n \\n template <int dim>\\n void WeightedResidual<dim>::solve_dual_problem()\\n    {\\n      DualSolver<dim>::solve_problem();\\n    }\\n \\n \\n template <int dim>\\n void WeightedResidual<dim>::postprocess(\\n const Evaluation::EvaluationBase<dim> &postprocessor) const\\n {\\n      PrimalSolver<dim>::postprocess(postprocessor);\\n    }\\n \\n \\n template <int dim>\\n unsigned int WeightedResidual<dim>::n_dofs() const\\n {\\n return PrimalSolver<dim>::n_dofs();\\n    }\\n \\n \\n \\n template <int dim>\\n void WeightedResidual<dim>::refine_grid()\\n    {\\n Vector<float> error_indicators(this->triangulation->n_active_cells());\\n      estimate_error(error_indicators);\\n \\n for (float &error_indicator : error_indicators)\\n        error_indicator = std::fabs(error_indicator);\\n \\n GridRefinement::refine_and_coarsen_fixed_fraction(*this->triangulation,\\n                                                        error_indicators,\\n                                                        0.8,\\n                                                        0.02);\\n      this->triangulation->execute_coarsening_and_refinement();\\n    }\\n \\n \\n template <int dim>\\n void WeightedResidual<dim>::output_solution() const\\n {\\n AffineConstraints<double> primal_hanging_node_constraints;\\n DoFTools::make_hanging_node_constraints(PrimalSolver<dim>::dof_handler,\\n                                              primal_hanging_node_constraints);\\n      primal_hanging_node_constraints.close();\\n Vector<double> dual_solution(PrimalSolver<dim>::dof_handler.n_dofs());\\n FETools::interpolate(DualSolver<dim>::dof_handler,\\n                           DualSolver<dim>::solution,\\n                           PrimalSolver<dim>::dof_handler,\\n                           primal_hanging_node_constraints,\\n                           dual_solution);\\n \\n DataOut<dim> data_out;\\n      data_out.attach_dof_handler(PrimalSolver<dim>::dof_handler);\\n \\n      data_out.add_data_vector(PrimalSolver<dim>::solution, \\\"primal_solution\\\");\\n      data_out.add_data_vector(dual_solution, \\\"dual_solution\\\");\\n \\n      data_out.build_patches();\\n \\n      std::ofstream out(\\\"solution-\\\" + std::to_string(this->refinement_cycle) +\\n \\\".vtu\\\");\\n      data_out.write(out, DataOutBase::vtu);\\n    }\\n \\n \\n \\n template <int dim>\\n void\\n    WeightedResidual<dim>::estimate_error(Vector<float> &error_indicators) const\\n {\\n AffineConstraints<double> dual_hanging_node_constraints;\\n DoFTools::make_hanging_node_constraints(DualSolver<dim>::dof_handler,\\n                                              dual_hanging_node_constraints);\\n      dual_hanging_node_constraints.close();\\n Vector<double> primal_solution(DualSolver<dim>::dof_handler.n_dofs());\\n FETools::interpolate(PrimalSolver<dim>::dof_handler,\\n                           PrimalSolver<dim>::solution,\\n                           DualSolver<dim>::dof_handler,\\n                           dual_hanging_node_constraints,\\n                           primal_solution);\\n \\n AffineConstraints<double> primal_hanging_node_constraints;\\n DoFTools::make_hanging_node_constraints(PrimalSolver<dim>::dof_handler,\\n                                              primal_hanging_node_constraints);\\n      primal_hanging_node_constraints.close();\\n Vector<double> dual_weights(DualSolver<dim>::dof_handler.n_dofs());\\n FETools::interpolation_difference(DualSolver<dim>::dof_handler,\\n                                        dual_hanging_node_constraints,\\n                                        DualSolver<dim>::solution,\\n                                        PrimalSolver<dim>::dof_handler,\\n                                        primal_hanging_node_constraints,\\n                                        dual_weights);\\n \\n \\n      FaceIntegrals face_integrals;\\n for (const auto &cell :\\n           DualSolver<dim>::dof_handler.active_cell_iterators())\\n        for (const auto &face : cell->face_iterators())\\n          face_integrals[face] = -1e20;\\n \\n auto worker = [this,\\n                     &error_indicators,\\n                     &face_integrals](const active_cell_iterator  &cell,\\n                                      WeightedResidualScratchData &scratch_data,\\n                                      WeightedResidualCopyData    &copy_data) {\\n        this->estimate_on_one_cell(\\n          cell, scratch_data, copy_data, error_indicators, face_integrals);\\n      };\\n \\n auto do_nothing_copier =\\n        std::function<void(const WeightedResidualCopyData &)>();\\n \\n WorkStream::run(\\n        DualSolver<dim>::dof_handler.begin_active(),\\n        DualSolver<dim>::dof_handler.end(),\\n        worker,\\n        do_nothing_copier,\\n        WeightedResidualScratchData(*DualSolver<dim>::fe,\\n                                    *DualSolver<dim>::quadrature,\\n                                    *DualSolver<dim>::face_quadrature,\\n                                    *this->rhs_function,\\n                                    primal_solution,\\n                                    dual_weights),\\n        WeightedResidualCopyData());\\n \\n unsigned int present_cell = 0;\\n for (const auto &cell :\\n           DualSolver<dim>::dof_handler.active_cell_iterators())\\n        {\\n for (const auto &face : cell->face_iterators())\\n            {\\n Assert(face_integrals.find(face) != face_integrals.end(),\\n                     ExcInternalError());\\n              error_indicators(present_cell) -= 0.5 * face_integrals[face];\\n            }\\n          ++present_cell;\\n        }\\n      std::cout << \\\"   Estimated error: \\\"\\n                << std::accumulate(error_indicators.begin(),\\n                                   error_indicators.end(),\\n                                   0.)\\n                << std::endl;\\n    }\\n \\n \\n \\n template <int dim>\\n void WeightedResidual<dim>::estimate_on_one_cell(\\n const active_cell_iterator  &cell,\\n      WeightedResidualScratchData &scratch_data,\\n      WeightedResidualCopyData    &copy_data,\\n Vector<float>               &error_indicators,\\n      FaceIntegrals               &face_integrals) const\\n {\\n      (void)copy_data;\\n \\n      integrate_over_cell(cell,\\n                          scratch_data.primal_solution,\\n                          scratch_data.dual_weights,\\n                          scratch_data.cell_data,\\n                          error_indicators);\\n \\n for (const auto face_no : cell->face_indices())\\n        {\\n if (cell->face(face_no)->at_boundary())\\n            {\\n              face_integrals[cell->face(face_no)] = 0;\\n continue;\\n            }\\n \\n if ((cell->neighbor(face_no)->has_children() == false) &&\\n              (cell->neighbor(face_no)->level() == cell->level()) &&\\n              (cell->neighbor(face_no)->index() < cell->index()))\\n continue;\\n \\n if (cell->at_boundary(face_no) == false)\\n if (cell->neighbor(face_no)->level() < cell->level())\\n continue;\\n \\n \\n if (cell->face(face_no)->has_children() == false)\\n            integrate_over_regular_face(cell,\\n                                        face_no,\\n                                        scratch_data.primal_solution,\\n                                        scratch_data.dual_weights,\\n                                        scratch_data.face_data,\\n                                        face_integrals);\\n else\\n            integrate_over_irregular_face(cell,\\n                                          face_no,\\n                                          scratch_data.primal_solution,\\n                                          scratch_data.dual_weights,\\n                                          scratch_data.face_data,\\n                                          face_integrals);\\n        }\\n    }\\n \\n \\n \\n template <int dim>\\n void WeightedResidual<dim>::integrate_over_cell(\\n const active_cell_iterator &cell,\\n const Vector<double>       &primal_solution,\\n const Vector<double>       &dual_weights,\\n CellData                   &cell_data,\\n Vector<float>              &error_indicators) const\\n {\\n      cell_data.fe_values.reinit(cell);\\n      cell_data.right_hand_side->value_list(\\n        cell_data.fe_values.get_quadrature_points(), cell_data.rhs_values);\\n      cell_data.fe_values.get_function_laplacians(primal_solution,\\n                                                  cell_data.cell_laplacians);\\n \\n      cell_data.fe_values.get_function_values(dual_weights,\\n                                              cell_data.dual_weights);\\n \\n double sum = 0;\\n for (unsigned int p = 0; p < cell_data.fe_values.n_quadrature_points; ++p)\\n        sum += ((cell_data.rhs_values[p] + cell_data.cell_laplacians[p]) *\\n                cell_data.dual_weights[p] * cell_data.fe_values.JxW(p));\\n      error_indicators(cell->active_cell_index()) += sum;\\n    }\\n \\n \\n \\n template <int dim>\\n void WeightedResidual<dim>::integrate_over_regular_face(\\n const active_cell_iterator &cell,\\n const unsigned int          face_no,\\n const Vector<double>       &primal_solution,\\n const Vector<double>       &dual_weights,\\n      FaceData                   &face_data,\\n      FaceIntegrals              &face_integrals) const\\n {\\n const unsigned int n_q_points =\\n        face_data.fe_face_values_cell.n_quadrature_points;\\n \\n      face_data.fe_face_values_cell.reinit(cell, face_no);\\n      face_data.fe_face_values_cell.get_function_gradients(\\n        primal_solution, face_data.cell_grads);\\n \\n Assert(cell->neighbor(face_no).state() == IteratorState::valid,\\n             ExcInternalError());\\n const unsigned int neighbor_neighbor =\\n        cell->neighbor_of_neighbor(face_no);\\n const active_cell_iterator neighbor = cell->neighbor(face_no);\\n      face_data.fe_face_values_neighbor.reinit(neighbor, neighbor_neighbor);\\n      face_data.fe_face_values_neighbor.get_function_gradients(\\n        primal_solution, face_data.neighbor_grads);\\n \\n for (unsigned int p = 0; p < n_q_points; ++p)\\n        face_data.jump_residual[p] =\\n          ((face_data.cell_grads[p] - face_data.neighbor_grads[p]) *\\n           face_data.fe_face_values_cell.normal_vector(p));\\n \\n      face_data.fe_face_values_cell.get_function_values(dual_weights,\\n                                                        face_data.dual_weights);\\n \\n double face_integral = 0;\\n for (unsigned int p = 0; p < n_q_points; ++p)\\n        face_integral +=\\n          (face_data.jump_residual[p] * face_data.dual_weights[p] *\\n           face_data.fe_face_values_cell.JxW(p));\\n \\n Assert(face_integrals.find(cell->face(face_no)) != face_integrals.end(),\\n             ExcInternalError());\\n Assert(face_integrals[cell->face(face_no)] == -1e20, ExcInternalError());\\n \\n      face_integrals[cell->face(face_no)] = face_integral;\\n    }\\n \\n \\n \\n template <int dim>\\n void WeightedResidual<dim>::integrate_over_irregular_face(\\n const active_cell_iterator &cell,\\n const unsigned int          face_no,\\n const Vector<double>       &primal_solution,\\n const Vector<double>       &dual_weights,\\n      FaceData                   &face_data,\\n      FaceIntegrals              &face_integrals) const\\n {\\n const unsigned int n_q_points =\\n        face_data.fe_face_values_cell.n_quadrature_points;\\n \\n const typename DoFHandler<dim>::face_iterator face = cell->face(face_no);\\n const typename DoFHandler<dim>::cell_iterator neighbor =\\n        cell->neighbor(face_no);\\n Assert(neighbor.state() == IteratorState::valid, ExcInternalError());\\n Assert(neighbor->has_children(), ExcInternalError());\\n      (void)neighbor;\\n \\n const unsigned int neighbor_neighbor =\\n        cell->neighbor_of_neighbor(face_no);\\n \\n for (unsigned int subface_no = 0; subface_no < face->n_children();\\n           ++subface_no)\\n        {\\n const active_cell_iterator neighbor_child =\\n            cell->neighbor_child_on_subface(face_no, subface_no);\\n Assert(neighbor_child->face(neighbor_neighbor) ==\\n                   cell->face(face_no)->child(subface_no),\\n                 ExcInternalError());\\n \\n          face_data.fe_subface_values_cell.reinit(cell, face_no, subface_no);\\n          face_data.fe_subface_values_cell.get_function_gradients(\\n            primal_solution, face_data.cell_grads);\\n          face_data.fe_face_values_neighbor.reinit(neighbor_child,\\n                                                   neighbor_neighbor);\\n          face_data.fe_face_values_neighbor.get_function_gradients(\\n            primal_solution, face_data.neighbor_grads);\\n \\n for (unsigned int p = 0; p < n_q_points; ++p)\\n            face_data.jump_residual[p] =\\n              ((face_data.neighbor_grads[p] - face_data.cell_grads[p]) *\\n               face_data.fe_face_values_neighbor.normal_vector(p));\\n \\n          face_data.fe_face_values_neighbor.get_function_values(\\n            dual_weights, face_data.dual_weights);\\n \\n double face_integral = 0;\\n for (unsigned int p = 0; p < n_q_points; ++p)\\n            face_integral +=\\n              (face_data.jump_residual[p] * face_data.dual_weights[p] *\\n               face_data.fe_face_values_neighbor.JxW(p));\\n          face_integrals[neighbor_child->face(neighbor_neighbor)] =\\n            face_integral;\\n        }\\n \\n double sum = 0;\\n for (unsigned int subface_no = 0; subface_no < face->n_children();\\n           ++subface_no)\\n        {\\n Assert(face_integrals.find(face->child(subface_no)) !=\\n                   face_integrals.end(),\\n                 ExcInternalError());\\n Assert(face_integrals[face->child(subface_no)] != -1e20,\\n                 ExcInternalError());\\n \\n sum += face_integrals[face->child(subface_no)];\\n        }\\n      face_integrals[face] = sum;\\n    }\\n \\n  } // namespace LaplaceSolver\\n \\n \\n \\n template <int dim>\\n struct Framework\\n  {\\n public:\\n using Evaluator     = Evaluation::EvaluationBase<dim>;\\n using EvaluatorList = std::list<Evaluator *>;\\n \\n \\n struct ProblemDescription\\n    {\\n unsigned int primal_fe_degree;\\n unsigned int dual_fe_degree;\\n \\n      std::unique_ptr<const Data::SetUpBase<dim>> data;\\n \\n enum RefinementCriterion\\n      {\\n        dual_weighted_error_estimator,\\n        global_refinement,\\n        kelly_indicator,\\n        weighted_kelly_indicator\\n      };\\n \\n      RefinementCriterion refinement_criterion;\\n \\n      std::unique_ptr<const DualFunctional::DualFunctionalBase<dim>>\\n        dual_functional;\\n \\n      EvaluatorList evaluator_list;\\n \\n      std::unique_ptr<const Function<dim>> kelly_weight;\\n \\n unsigned int max_degrees_of_freedom;\\n \\n      ProblemDescription();\\n    };\\n \\n static void run(const ProblemDescription &descriptor);\\n  };\\n \\n \\n template <int dim>\\n  Framework<dim>::ProblemDescription::ProblemDescription()\\n    : primal_fe_degree(1)\\n    , dual_fe_degree(2)\\n    , refinement_criterion(dual_weighted_error_estimator)\\n    , max_degrees_of_freedom(20000)\\n  {}\\n \\n \\n \\n template <int dim>\\n void Framework<dim>::run(const ProblemDescription &descriptor)\\n  {\\n Triangulation<dim> triangulation(\\n Triangulation<dim>::smoothing_on_refinement);\\n    descriptor.data->create_coarse_grid(triangulation);\\n \\n const FE_Q<dim>       primal_fe(descriptor.primal_fe_degree);\\n const FE_Q<dim>       dual_fe(descriptor.dual_fe_degree);\\n const QGauss<dim>     quadrature(descriptor.dual_fe_degree + 1);\\n const QGauss<dim - 1> face_quadrature(descriptor.dual_fe_degree + 1);\\n \\n    std::unique_ptr<LaplaceSolver::Base<dim>> solver;\\n switch (descriptor.refinement_criterion)\\n      {\\n case ProblemDescription::dual_weighted_error_estimator:\\n          {\\n            solver = std::make_unique<LaplaceSolver::WeightedResidual<dim>>(\\n triangulation,\\n              primal_fe,\\n              dual_fe,\\n              quadrature,\\n              face_quadrature,\\n              descriptor.data->get_right_hand_side(),\\n              descriptor.data->get_boundary_values(),\\n              *descriptor.dual_functional);\\n break;\\n          }\\n \\n case ProblemDescription::global_refinement:\\n          {\\n            solver = std::make_unique<LaplaceSolver::RefinementGlobal<dim>>(\\n triangulation,\\n              primal_fe,\\n              quadrature,\\n              face_quadrature,\\n              descriptor.data->get_right_hand_side(),\\n              descriptor.data->get_boundary_values());\\n break;\\n          }\\n \\n case ProblemDescription::kelly_indicator:\\n          {\\n            solver = std::make_unique<LaplaceSolver::RefinementKelly<dim>>(\\n triangulation,\\n              primal_fe,\\n              quadrature,\\n              face_quadrature,\\n              descriptor.data->get_right_hand_side(),\\n              descriptor.data->get_boundary_values());\\n break;\\n          }\\n \\n case ProblemDescription::weighted_kelly_indicator:\\n          {\\n            solver =\\n              std::make_unique<LaplaceSolver::RefinementWeightedKelly<dim>>(\\n triangulation,\\n                primal_fe,\\n                quadrature,\\n                face_quadrature,\\n                descriptor.data->get_right_hand_side(),\\n                descriptor.data->get_boundary_values(),\\n                *descriptor.kelly_weight);\\n break;\\n          }\\n \\n default:\\n AssertThrow(false, ExcInternalError());\\n      }\\n \\n for (unsigned int step = 0; true; ++step)\\n      {\\n        std::cout << \\\"Refinement cycle: \\\" << step << std::endl;\\n \\n        solver->set_refinement_cycle(step);\\n        solver->solve_problem();\\n        solver->output_solution();\\n \\n        std::cout << \\\"   Number of degrees of freedom: \\\" << solver->n_dofs()\\n                  << std::endl;\\n \\n for (const auto &evaluator : descriptor.evaluator_list)\\n          {\\n            evaluator->set_refinement_cycle(step);\\n            solver->postprocess(*evaluator);\\n          }\\n \\n \\n if (solver->n_dofs() < descriptor.max_degrees_of_freedom)\\n          solver->refine_grid();\\n else\\n break;\\n      }\\n \\n    std::cout << std::endl;\\n  }\\n \\n} // namespace Step14\\n \\n \\n \\n \\nint main()\\n{\\n try\\n    {\\n using namespace Step14;\\n \\n const unsigned int                 dim = 2;\\n      Framework<dim>::ProblemDescription descriptor;\\n \\n      descriptor.refinement_criterion =\\n        Framework<dim>::ProblemDescription::dual_weighted_error_estimator;\\n \\n      descriptor.primal_fe_degree = 1;\\n      descriptor.dual_fe_degree   = 2;\\n \\n      descriptor.data =\\n        std::make_unique<Data::SetUp<Data::Exercise_2_3<dim>, dim>>();\\n \\n const Point<dim> evaluation_point(0.75, 0.75);\\n      descriptor.dual_functional =\\n        std::make_unique<DualFunctional::PointValueEvaluation<dim>>(\\n          evaluation_point);\\n \\n      Evaluation::PointValueEvaluation<dim> postprocessor1(evaluation_point);\\n      Evaluation::GridOutput<dim>           postprocessor2(\\\"grid\\\");\\n \\n      descriptor.evaluator_list.push_back(&postprocessor1);\\n      descriptor.evaluator_list.push_back(&postprocessor2);\\n \\n      descriptor.max_degrees_of_freedom = 20000;\\n \\n      Framework<dim>::run(descriptor);\\n    }\\n \\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n \\n return 0;\\n}\\naffine_constraints.h\\nAffineConstraints::closevoid close()\\nDataOutInterface::writevoid write(std::ostream &out, const DataOutBase::OutputFormat output_format=DataOutBase::default_format) constDefinition data_out_base.cc:8787\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nDoFHandler::endcell_iterator end() const\\nDoFHandler::get_feconst FiniteElement< dim, spacedim > & get_fe(const types::fe_index index=0) const\\nDoFHandler::distribute_dofsvoid distribute_dofs(const FiniteElement< dim, spacedim > &fe)\\nDoFHandler::get_triangulationconst Triangulation< dim, spacedim > & get_triangulation() const\\nDoFHandler::begin_activeactive_cell_iterator begin_active(const unsigned int level=0) const\\nDoFHandler::clearvoid clear()\\nFiniteElementData::degreeconst unsigned int degreeDefinition fe_data.h:452\\nFiniteElementData::dofs_per_cellconst unsigned int dofs_per_cellDefinition fe_data.h:436\\nQuadrature::sizeunsigned int size() const\\nThreads::TaskGroup::join_allvoid join_all() constDefinition thread_management.h:1431\\nThreads::Task::joinvoid join() constDefinition thread_management.h:738\\nVector::enditerator end()\\nVector::reinitvirtual void reinit(const size_type N, const bool omit_zeroing_entries=false)\\nVector::beginiterator begin()\\nparallel::distributed::Triangulation::execute_coarsening_and_refinementvirtual void execute_coarsening_and_refinement() overrideDefinition tria.cc:3320\\ndof_handler.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nerror_estimator.h\\nfe_values.h\\nfe_q.h\\nfe_tools.h\\nfull_matrix.h\\nfunction.h\\ngrid_refinement.h\\ntria.h\\ngrid_generator.h\\ngrid_out.h\\ngrid_tools.h\\nmatrix_tools.h\\nDifferentiation::SD::fabsExpression fabs(const Expression &x)Definition symengine_math.cc:269\\nGridTools::diameterdouble diameter(const Triangulation< dim, spacedim > &tria)Definition grid_tools_geometry.cc:43\\nLAPACKSupport::matrix@ matrixContents is actually a matrix.Definition lapack_support.h:57\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\nLocalIntegrators::Advection::cell_residualvoid cell_residual(Vector< double > &result, const FEValuesBase< dim > &fe, const std::vector< Tensor< 1, dim > > &input, const ArrayView< const std::vector< double > > &velocity, double factor=1.)Definition advection.h:130\\nPhysics::Elasticity::Kinematics::eSymmetricTensor< 2, dim, Number > e(const Tensor< 2, dim, Number > &F)\\nTrilinosWrappers::internal::endVectorType::value_type * end(VectorType &V)Definition trilinos_sparse_matrix.cc:64\\nUtilities::MPI::sumT sum(const T &t, const MPI_Comm mpi_communicator)\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\ninternal::EvaluatorQuantity::value@ value\\ndata_out.h\\nprecondition.h\\nquadrature_lib.h\\nsolver_cg.h\\nsparse_matrix.h\\nthread_management.h\\nvector.h\\nvector_tools.h\\nwork_stream.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"