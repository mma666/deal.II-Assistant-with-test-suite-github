"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_71.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-71 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-71 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-71 tutorial program\\n\\n\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nA motivation: Why would I use these tools?\\nTheory for magneto-mechanical materials\\n\\nThermodynamic principles\\nConstitutive laws\\n\\nMagnetoelastic constitutive law\\nMagneto-viscoelastic constitutive law\\n\\n\\nRheological experiment\\nSuggested literature\\n\\n The commented program\\n\\nAn introductory example: The fundamentals of automatic and symbolic differentiation\\n\\nAn analytical function\\nComputing derivatives using automatic differentiation\\nHand-calculated derivatives of the analytical solution\\nComputing derivatives using symbolic differentiation\\nThe SimpleExample::run() function\\n\\nA more complex example: Using automatic and symbolic differentiation to compute derivatives at continuum points\\n\\nConstitutive parameters\\nConstitutive laws: Base class\\nMagnetoelastic constitutive law (using automatic differentiation)\\nMagneto-viscoelastic constitutive law (using symbolic algebra and differentiation)\\n\\nA more complex example (continued): Parameters and hand-derived material classes\\n\\nMagnetoelastic constitutive law (hand-derived)\\nMagneto-viscoelastic constitutive law (hand-derived)\\nRheological experiment parameters\\nRheological experiment: Parallel plate rotational rheometer\\nThe CoupledConstitutiveLaws::run() function\\n\\nThe main() function\\n\\n\\n Results\\n\\nIntroductory example\\nConstitutive modelling\\n\\n The plain program\\n   \\n\\n\\nThis program was contributed by Jean-Paul Pelteret. \\nIntroduction\\nThe aim of this tutorial is, quite simply, to introduce the fundamentals of both automatic and symbolic differentiation (respectively abbreviated as AD and SD): Ways in which one can, in source code, describe a function \\\\(\\\\mathbf f(\\\\mathbf x)\\\\) and automatically also obtain a representation of derivatives \\\\(\\\\nabla \\\\mathbf f(\\\\mathbf x)\\\\) (the \\\"Jacobian\\\"), \\\\(\\\\nabla^2 \\\\mathbf f(\\\\mathbf x)\\\\) (the \\\"Hessian\\\"), etc., without having to write additional lines of code. Doing this is quite helpful in solving nonlinear or optimization problems where one would like to only describe the nonlinear equation or the objective function in the code, without having to also provide their derivatives (which are necessary for a Newton method for solving a nonlinear problem, or for finding a minimizer).\\nSince AD and SD tools are somewhat independent of finite elements and boundary value problems, this tutorial is going to be different to the others that you may have read beforehand. It will focus specifically on how these frameworks work and the principles and thinking behind them, and will forgo looking at them in the direct context of a finite element simulation.\\nWe will, in fact, look at two different sets of problems that have greatly different levels of complexity, but when framed properly hold sufficient similarity that the same AD and SD frameworks can be leveraged. With these examples the aim is to build up an understanding of the steps that are required to use the AD and SD tools, the differences between them, and hopefully identify where they could be immediately be used in order to improve or simplify existing code.\\nIt's plausible that you're wondering what AD and SD are, in the first place. Well, that question is easy to answer but without context is not very insightful. So we're not going to cover that in this introduction, but will rather defer this until the first introductory example where we lay out the key points as this example unfolds. To complement this, we should mention that the core theory for both frameworks is extensively discussed in the Automatic and symbolic differentiation topic, so it bears little repeating here.\\nSince we have to pick some sufficiently interesting topic to investigate and identify where AD and SD can be used effectively, the main problem that's implemented in the second half of the tutorial is one of modeling a coupled constitutive law, specifically a magneto-active material (with hysteretic effects). As a means of an introduction to that, later in the introduction some grounding theory for that class of materials will be presented. Naturally, this is not a field (or even a class of materials) that is of interest to a wide audience. Therefore, the author wishes to express up front that this theory and any subsequent derivations mustn't be considered the focus of this tutorial. Instead, keep in mind the complexity of the problem that arises from the relatively innocuous description of the constitutive law, and what we might (in the context of a boundary value problem) need to derive from that. We will perform some computations with these constitutive laws at the level of a representative continuum point (so, remaining in the realm of continuum mechanics), and will produce some benchmark results around which we can frame a final discussion on the topic of computational performance.\\nOnce we have the foundation upon which we can build further concepts, we will see how AD in particular can be exploited at a finite element (rather than continuum) level: this is a topic that is covered in step-72, as well as step-33. But before then, let's take a moment to think about why we might want to consider using these sorts of tools, and what benefits they can potentially offer you.\\nA motivation: Why would I use these tools?\\nThe primary driver for using AD or SD is typically that there is some situation that requires differentiation to be performed, and that doing so is sufficiently challenging to make the prospect of using an external tool to perform that specific task appealing. A broad categorization for the circumstances under which AD or SD can be rendered most useful include (but are probably not limited to) the following:\\nRapid prototyping: For a new class of problems where you're trying to implement a solution quickly, and want to remove some of the intricate details (in terms of both the mathematics as well as the organizational structure of the code itself). You might be willing to justify any additional computational cost, which would be offset by an increased agility in restructuring your code or modifying the part of the problem that is introducing some complex nonlinearity with minimal effort.\\nComplex problems: It could very well be that some problems just happen to have a nonlinearity that is incredibly challenging to linearize or formulate by hand. Having this challenge taken care of for you by a tool that is, for the most part, robust, reliable, and accurate may alleviate some of the pains in implementing certain problems. Examples of this include step-15, where the derivative of the nonlinear PDE we solve is not incredibly difficult to derive, but sufficiently cumbersome that one has to pay attention in doing so by hand, and where implementing the corresponding finite element formulation of the Newton step takes more than just the few lines that it generally takes to implement the bilinear form; step-33 (where we actually use AD) is an even more extreme example.\\nVerification: For materials and simulations that exhibit nonlinear response, an accurate rather than only approximate material tangent (the term mechanical engineers use for the derivative of a material law) can be the difference between convergent and divergent behavior, especially at high external (or coupling) loads. As the complexity of the problem increases, so do the opportunities to introduce subtle (or, perhaps, not-so-subtle) errors that produce predictably negative results. Additionally, there is a lot to be gained by verifying that the implementation is completely correct. For example, certain categories of problems are known to exhibit instabilities, and therefore when you start to lose quadratic convergence in a nonlinear solver (e.g., Newton's method) then this may not be a huge surprise to the investigator. However, it is hard (if not impossible) to distinguish between convergence behavior that is produced as you near an unstable solution and when you simply have an error in the material or finite element linearization, and start to drift off the optimal convergence path due to that. Having a method of verifying the correctness of the implementation of a constitutive law linearization, for example, is perhaps the only meaningful way that you can use to catch such errors, assuming that you've got nobody else to scrutinize your code. Thankfully, with some tactical programming it is quite straight-forward to structure a code for reuse, such that you can use the same classes in production code and directly verify them in, for instance, a unit-test framework.\\n\\nThis tutorial program will have two parts: One where we just introduce the basic ideas of automatic and symbolic differentiation support in deal.II using a simple set of examples; and one where we apply this to a realistic but much more complicated case. For that second half, the next section will provide some background on magneto-mechanical materials \\u2013 you can skip this section if all you want to learn about is what AD and SD actually are, but you probably want to read over this section if you are interested in how to apply AD and SD for concrete situations.\\nTheory for magneto-mechanical materials\\nThermodynamic principles\\nAs a prelude to introducing the coupled magneto-mechanical material law that we'll use to model a magneto-active polymer, we'll start with a very concise summary of the salient thermodynamics to which these constitutive laws must subscribe. The basis for the theory, as summarized here, is described in copious detail by Truesdell and Toupin [201] and Coleman and Noll [64], and follows the logic laid out by Holzapfel [120].\\nStarting from the first law of thermodynamics, and following a few technical assumptions, it can be shown the balance between the kinetic plus internal energy rates and the power supplied to the system from external sources is given by the following relationship that equates the rate of change of the energy in an (arbitrary) volume \\\\(V\\\\) on the left, and the sum of forces acting on that volume on the right:             \\n\\\\[\\n  D_{t} \\\\int\\\\limits_{V} \\\\left[\\n    \\\\frac{1}{2} \\\\rho_{0} \\\\mathbf{v} \\\\cdot \\\\mathbf{v}\\n    + U^{*}_{0} \\\\right] dV\\n= \\\\int\\\\limits_{V} \\\\left[\\n  \\\\rho_{0} \\\\mathbf{v} \\\\cdot \\\\mathbf{a}\\n  + \\\\mathbf{P}^{\\\\text{tot}} : \\\\dot{\\\\mathbf{F}}\\n  + \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\dot{\\\\boldsymbol{\\\\mathbb{B}}}\\n  + \\\\mathbb{E} \\\\cdot \\\\dot{\\\\mathbb{D}}\\n  - D_{t} M^{*}_{0}\\n  - \\\\nabla_{0} \\\\cdot \\\\mathbf{Q}\\n  + R_{0} \\\\right] dV .\\n\\\\]\\n\\n Here \\\\(D_{t}\\\\) represents the total time derivative, \\\\(\\\\rho_{0}\\\\) is the material density as measured in the Lagrangian reference frame, \\\\(\\\\mathbf{v}\\\\) is the material velocity and \\\\(\\\\mathbf{a}\\\\) its acceleration, \\\\(U^{*}_{0}\\\\) is the internal energy per unit reference volume, \\\\(\\\\mathbf{P}^{\\\\text{tot}}\\\\) is the total Piola stress tensor and \\\\(\\\\dot{\\\\mathbf{F}}\\\\) is the time rate of the deformation gradient tensor, \\\\(\\\\boldsymbol{\\\\mathbb{H}}\\\\) and \\\\(\\\\boldsymbol{\\\\mathbb{B}}\\\\) are, respectively, the magnetic field vector and the magnetic induction (or magnetic flux density) vector, \\\\(\\\\mathbb{E}\\\\) and \\\\(\\\\mathbb{D}\\\\) are the electric field vector and electric displacement vector, and \\\\(\\\\mathbf{Q}\\\\) and \\\\(R_{0}\\\\) represent the referential thermal flux vector and thermal source. The material differential operator \\\\(\\\\nabla_{0} (\\\\bullet) \\\\dealcoloneq \\\\frac{d(\\\\bullet)}{d\\\\mathbf{X}}\\\\) where \\\\(\\\\mathbf{X}\\\\) is the material position vector. With some rearrangement of terms, invoking the arbitrariness of the integration volume \\\\(V\\\\), the total internal energy density rate \\\\(\\\\dot{E}_{0}\\\\) can be identified as        \\n\\\\[\\n  \\\\dot{E}_{0}\\n= \\\\mathbf{P}^{\\\\text{tot}} : \\\\dot{\\\\mathbf{F}}\\n  + \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\dot{\\\\boldsymbol{\\\\mathbb{B}}}\\n  + \\\\mathbb{E} \\\\cdot \\\\dot{\\\\mathbb{D}}\\n  - \\\\nabla_{0} \\\\cdot \\\\mathbf{Q}\\n  + R_{0} .\\n\\\\]\\n\\n The total internal energy includes contributions that arise not only due to mechanical deformation (the first term), and thermal fluxes and sources (the fourth and fifth terms), but also due to the intrinsic energy stored in the magnetic and electric fields themselves (the second and third terms, respectively).\\nThe second law of thermodynamics, known also as the entropy inequality principle, informs us that certain thermodynamic processes are irreversible. After accounting for the total entropy and rate of entropy input, the Clausius-Duhem inequality can be derived. In local form (and in the material configuration), this reads       \\n\\\\[\\n  \\\\theta \\\\dot{\\\\eta}_{0}\\n  - R_{0}\\n  + \\\\nabla_{0} \\\\cdot \\\\mathbf{Q}\\n  - \\\\frac{1}{\\\\theta} \\\\nabla_{0} \\\\theta \\\\cdot \\\\mathbf{Q}\\n  \\\\geq 0 .\\n\\\\]\\n\\n The quantity \\\\(\\\\theta\\\\) is the absolute temperature, and \\\\(\\\\eta_{0}\\\\) represents the entropy per unit reference volume.\\nUsing this to replace \\\\(R_{0} - \\\\nabla_{0} \\\\cdot \\\\mathbf{Q}\\\\) in the result stemming from the first law of thermodynamics, we now have the relation         \\n\\\\[\\n  \\\\mathbf{P}^{\\\\text{tot}} : \\\\dot{\\\\mathbf{F}}\\n  + \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\dot{\\\\boldsymbol{\\\\mathbb{B}}}\\n  + \\\\mathbb{E} \\\\cdot \\\\dot{\\\\mathbb{D}}\\n  + \\\\theta \\\\dot{\\\\eta}_{0}\\n  - \\\\dot{E}_{0}\\n  - \\\\frac{1}{\\\\theta} \\\\nabla_{0} \\\\theta \\\\cdot \\\\mathbf{Q}\\n  \\\\geq 0 .\\n\\\\]\\n\\n On the basis of Fourier's law, which informs us that heat flows from regions of high temperature to low temperature, the last term is always positive and can be ignored. This renders the local dissipation inequality       \\n\\\\[\\n  \\\\mathbf{P}^{\\\\text{tot}} : \\\\dot{\\\\mathbf{F}}\\n  + \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\dot{\\\\boldsymbol{\\\\mathbb{B}}}\\n  + \\\\mathbb{E} \\\\cdot \\\\dot{\\\\mathbb{D}}\\n  - \\\\left[ \\\\dot{E}_{0} - \\\\theta \\\\dot{\\\\eta}_{0}  \\\\right]\\n  \\\\geq 0 .\\n\\\\]\\n\\n It is postulated [120] that the Legendre transformation     \\n\\\\[\\n  \\\\psi^{*}_{0}\\n= \\\\psi^{*}_{0} \\\\left( \\\\mathbf{F}, \\\\boldsymbol{\\\\mathbb{B}}, \\\\mathbb{D}, \\\\theta \\\\right)\\n= E_{0} - \\\\theta \\\\eta_{0} ,\\n\\\\]\\n\\n from which we may define the free energy density function \\\\(\\\\psi^{*}_{0}\\\\) with the stated parameterization, exists and is valid. Taking the material rate of this equation and substituting it into the local dissipation inequality results in the generic expression         \\n\\\\[\\n  \\\\mathcal{D}_{\\\\text{int}}\\n  = \\\\mathbf{P}^{\\\\text{tot}} : \\\\dot{\\\\mathbf{F}}\\n  + \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\dot{\\\\boldsymbol{\\\\mathbb{B}}}\\n  + \\\\mathbb{E} \\\\cdot \\\\dot{\\\\mathbb{D}}\\n  - \\\\dot{\\\\theta} \\\\eta_{0}\\n  - \\\\dot{\\\\psi}^{*}_{0} \\\\left( \\\\mathbf{F}, \\\\boldsymbol{\\\\mathbb{B}}, \\\\mathbb{D}, \\\\theta \\\\right)\\n  \\\\geq 0 .\\n\\\\]\\n\\n Under the assumption of isothermal conditions, and that the electric field does not excite the material in a manner that is considered non-negligible, then this dissipation inequality reduces to       \\n\\\\[\\n  \\\\mathcal{D}_{\\\\text{int}}\\n  = \\\\mathbf{P}^{\\\\text{tot}} : \\\\dot{\\\\mathbf{F}}\\n  + \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\dot{\\\\boldsymbol{\\\\mathbb{B}}}\\n  - \\\\dot{\\\\psi}^{*}_{0} \\\\left( \\\\mathbf{F}, \\\\boldsymbol{\\\\mathbb{B}} \\\\right)\\n  \\\\geq 0 .\\n\\\\]\\n\\nConstitutive laws\\nWhen considering materials that exhibit mechanically dissipative behavior, it can be shown that this can be captured within the dissipation inequality through the augmentation of the material free energy density function with additional parameters that represent internal variables [119]. Consequently, we write it as       \\n\\\\[\\n  \\\\mathcal{D}_{\\\\text{int}}\\n  = \\\\mathbf{P}^{\\\\text{tot}} : \\\\dot{\\\\mathbf{F}}\\n  + \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\dot{\\\\boldsymbol{\\\\mathbb{B}}}\\n  - \\\\dot{\\\\psi}^{*}_{0} \\\\left( \\\\mathbf{F}, \\\\mathbf{F}_{v}^{i}, \\\\boldsymbol{\\\\mathbb{B}} \\\\right)\\n  \\\\geq 0 .\\n\\\\]\\n\\n where \\\\(\\\\mathbf{F}_{v}^{i} = \\\\mathbf{F}_{v}^{i} \\\\left( t \\\\right)\\\\) represents the internal variable (which acts like a measure of the deformation gradient) associated with the ith mechanical dissipative (viscous) mechanism. As can be inferred from its parameterization, each of these internal parameters is considered to evolve in time. Currently the free energy density function \\\\(\\\\psi^{*}_{0}\\\\) is parameterized in terms of the magnetic induction \\\\(\\\\boldsymbol{\\\\mathbb{B}}\\\\). This is the natural parameterization that comes as a consequence of the considered balance laws. Should such a class of materials to be incorporated within a finite-element model, it would be ascertained that a certain formulation of the magnetic problem, known as the magnetic vector potential formulation, would need to be adopted. This has its own set of challenges, so where possible the more simple magnetic scalar potential formulation may be preferred. In that case, the magnetic problem needs to be parameterized in terms of the magnetic field \\\\(\\\\boldsymbol{\\\\mathbb{H}}\\\\). To make this re-parameterization, we execute a final Legendre transformation     \\n\\\\[\\n  \\\\tilde{\\\\psi}_{0} \\\\left( \\\\mathbf{F}, \\\\mathbf{F}_{v}^{i}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n  = \\\\psi^{*}_{0} \\\\left( \\\\mathbf{F}, \\\\mathbf{F}_{v}^{i}, \\\\boldsymbol{\\\\mathbb{B}} \\\\right)\\n  - \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\boldsymbol{\\\\mathbb{B}} .\\n\\\\]\\n\\n At the same time, we may take advantage of the principle of material frame indifference in order to express the energy density function in terms of symmetric deformation measures:    \\n\\\\[\\n  \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v}^{i}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n  = \\\\tilde{\\\\psi}_{0} \\\\left( \\\\mathbf{F}, \\\\mathbf{F}_{v}^{i}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right) .\\n\\\\]\\n\\n The upshot of these two transformations (leaving out considerable explicit and hidden details) renders the final expression for the reduced dissipation inequality as       \\n\\\\[\\n  \\\\mathcal{D}_{\\\\text{int}}\\n  = \\\\mathbf{S}^{\\\\text{tot}} : \\\\frac{1}{2} \\\\dot{\\\\mathbf{C}}\\n  - \\\\boldsymbol{\\\\mathbb{B}} \\\\cdot \\\\dot{\\\\boldsymbol{\\\\mathbb{H}}}\\n  - \\\\dot{\\\\psi}_{0} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v}^{i}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n  \\\\geq 0 .\\n\\\\]\\n\\n (Notice the sign change on the second term on the right hand side, and the transfer of the time derivative to the magnetic induction vector.) The stress quantity \\\\(\\\\mathbf{S}^{\\\\text{tot}}\\\\) is known as the total Piola-Kirchhoff stress tensor and its energy conjugate \\\\(\\\\mathbf{C} = \\\\mathbf{F}^{T} \\\\cdot \\\\mathbf{F}\\\\) is the right Cauchy-Green deformation tensor, and \\\\(\\\\mathbf{C}_{v}^{i} = \\\\mathbf{C}_{v}^{i} \\\\left( t \\\\right)\\\\) is the re-parameterized internal variable associated with the ith mechanical dissipative (viscous) mechanism.\\nExpansion of the material rate of the energy density function, and rearrangement of the various terms, results in the expression       \\n\\\\[\\n  \\\\mathcal{D}_{\\\\text{int}}\\n  = \\\\left[ \\\\mathbf{S}^{\\\\text{tot}} - 2 \\\\frac{\\\\partial \\\\psi_{0}}{\\\\partial \\\\mathbf{C}} \\\\right] : \\\\frac{1}{2} \\\\dot{\\\\mathbf{C}}\\n  - \\\\sum\\\\limits_{i}\\\\left[ 2 \\\\frac{\\\\partial \\\\psi_{0}}{\\\\partial \\\\mathbf{C}_{v}^{i}} \\\\right] : \\\\frac{1}{2} \\\\dot{\\\\mathbf{C}}_{v}^{i}\\n  + \\\\left[ - \\\\boldsymbol{\\\\mathbb{B}} - \\\\frac{\\\\partial \\\\psi_{0}}{\\\\partial \\\\boldsymbol{\\\\mathbb{H}}} \\\\right] \\\\cdot \\\\dot{\\\\boldsymbol{\\\\mathbb{H}}}\\n  \\\\geq 0 .\\n\\\\]\\n\\n At this point, its worth noting the use of the partial derivatives \\\\(\\\\partial \\\\left( \\\\bullet \\\\right)\\\\). This is an important detail that will be fundamental to a certain design choice made within the tutorial. As brief reminder of what this signifies, the partial derivative of a multi-variate function returns the derivative of that function with respect to one of those variables while holding the others constant:    \\n\\\\[\\n  \\\\frac{\\\\partial f\\\\left(x, y\\\\right)}{\\\\partial x}\\n  = \\\\frac{d f\\\\left(x, y\\\\right)}{d x} \\\\Big\\\\vert_{y} .\\n\\\\]\\n\\n More specific to what's encoded in the dissipation inequality (with the very general free energy density function \\\\(\\\\psi_{0}\\\\) with its parameterization yet to be formalized), if one of the input variables is a function of another, it is also held constant and the chain rule does not propagate any further, while the computing total derivative would imply judicious use of the chain rule. This can be better understood by comparing the following two statements:       \\n\\\\begin{align*}\\n  \\\\frac{\\\\partial f\\\\left(x, y\\\\left(x\\\\right)\\\\right)}{\\\\partial x}\\n  &= \\\\frac{d f\\\\left(x, y\\\\left(x\\\\right)\\\\right)}{d x} \\\\Big\\\\vert_{y} \\\\\\\\\\n  \\\\frac{d f\\\\left(x, y\\\\left(x\\\\right)\\\\right)}{d x}\\n  &= \\\\frac{d f\\\\left(x, y\\\\left(x\\\\right)\\\\right)}{d x} \\\\Big\\\\vert_{y}\\n   + \\\\frac{d f\\\\left(x, y\\\\left(x\\\\right)\\\\right)}{d y} \\\\Big\\\\vert_{x} \\\\frac{d y\\\\left(x\\\\right)}{x} .\\n\\\\end{align*}\\n\\nReturning to the thermodynamics of the problem, we next exploit the arbitrariness of the quantities \\\\(\\\\dot{\\\\mathbf{C}}\\\\) and \\\\(\\\\dot{\\\\boldsymbol{\\\\mathbb{H}}}\\\\), by application of the Coleman-Noll procedure [64], [63]. This leads to the identification of the kinetic conjugate quantities        \\n\\\\[\\n  \\\\mathbf{S}^{\\\\text{tot}}\\n  = \\\\mathbf{S}^{\\\\text{tot}} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v}^{i}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n  \\\\dealcoloneq 2 \\\\frac{\\\\partial \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v}^{i}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{\\\\partial \\\\mathbf{C}} , \\\\\\\\\\n  \\\\boldsymbol{\\\\mathbb{B}}\\n  = \\\\boldsymbol{\\\\mathbb{B}} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v}^{i}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n  \\\\dealcoloneq - \\\\frac{\\\\partial \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v}^{i}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{\\\\partial \\\\boldsymbol{\\\\mathbb{H}}} .\\n\\\\]\\n\\n (Again, note the use of the partial derivatives to define the stress and magnetic induction in this generalized setting.) From what terms remain in the dissipative power (namely those related to the mechanical dissipative mechanisms), if they are assumed to be independent of one another then, for each mechanism i,    \\n\\\\[\\n  \\\\frac{\\\\partial \\\\psi_{0}}{\\\\partial \\\\mathbf{C}_{v}^{i}} : \\\\dot{\\\\mathbf{C}}_{v}^{i}\\n  \\\\leq 0 .\\n\\\\]\\n\\n This constraint must be satisfied through the appropriate choice of free energy function, as well as a carefully considered evolution law for the internal variables.\\nIn the case that there are no dissipative mechanisms to be captured within the constitutive model (e.g., if the material to be modelled is magneto-hyperelastic) then the free energy density function \\\\(\\\\psi_{0} = \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\\\) reduces to a stored energy density function, and the total stress and magnetic induction can be simplified        \\n\\\\begin{align*}\\n  \\\\mathbf{S}^{\\\\text{tot}}\\n  = \\\\mathbf{S}^{\\\\text{tot}} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n  &\\\\dealcoloneq 2 \\\\frac{d \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{d \\\\mathbf{C}} , \\\\\\\\\\n  \\\\boldsymbol{\\\\mathbb{B}}\\n  = \\\\boldsymbol{\\\\mathbb{B}} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n  &\\\\dealcoloneq - \\\\frac{d \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{d \\\\boldsymbol{\\\\mathbb{H}}} ,\\n\\\\end{align*}\\n\\n where the operator \\\\(d\\\\) denotes the total derivative operation.\\nFor completeness, the linearization of the stress tensor and magnetic induction are captured within the fourth-order total referential elastic tangent tensor \\\\(\\\\mathcal{H}^{\\\\text{tot}} \\\\), the second-order magnetostatic tangent tensor \\\\(\\\\mathbb{D}\\\\) and the third-order total referential magnetoelastic coupling tensor \\\\(\\\\mathfrak{P}^{\\\\text{tot}}\\\\). Irrespective of the parameterization of \\\\(\\\\mathbf{S}^{\\\\text{tot}}\\\\) and \\\\(\\\\boldsymbol{\\\\mathbb{B}}\\\\), these quantities may be computed by          \\n\\\\begin{align*}\\n  \\\\mathcal{H}^{\\\\text{tot}}\\n  &= 2 \\\\frac{d \\\\mathbf{S}^{\\\\text{tot}}}{d \\\\mathbf{C}} , \\\\\\\\\\n  \\\\mathbb{D}\\n  &= \\\\frac{d \\\\boldsymbol{\\\\mathbb{B}}}{d \\\\boldsymbol{\\\\mathbb{H}}} , \\\\\\\\\\n  \\\\mathfrak{P}^{\\\\text{tot}}\\n  &= - \\\\frac{d \\\\mathbf{S}^{\\\\text{tot}}}{d \\\\boldsymbol{\\\\mathbb{H}}} , \\\\\\\\\\n  \\\\left[ \\\\mathfrak{P}^{\\\\text{tot}} \\\\right]^{T}\\n  &= 2 \\\\frac{d \\\\boldsymbol{\\\\mathbb{B}}}{d \\\\mathbf{C}} .\\n\\\\end{align*}\\n\\n For the case of rate-dependent materials, this expands to          \\n\\\\begin{align*}\\n  \\\\mathcal{H}^{\\\\text{tot}} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v}^{i}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n  &= 4 \\\\frac{d^{2} \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v}^{i}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{\\\\partial \\\\mathbf{C} \\\\otimes d \\\\mathbf{C}} , \\\\\\\\\\n  \\\\mathbb{D} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v}^{i}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n  &= -\\\\frac{d^{2} \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v}^{i}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{\\\\partial \\\\boldsymbol{\\\\mathbb{H}} \\\\otimes d \\\\boldsymbol{\\\\mathbb{H}}} , \\\\\\\\\\n  \\\\mathfrak{P}^{\\\\text{tot}} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v}^{i}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n  &= - 2 \\\\frac{d^{2} \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v}^{i}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{\\\\partial \\\\boldsymbol{\\\\mathbb{H}} \\\\otimes d \\\\mathbf{C}} , \\\\\\\\\\n  \\\\left[ \\\\mathfrak{P}^{\\\\text{tot}} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v}^{i}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)  \\\\right]^{T}\\n  &= - 2 \\\\frac{d^{2} \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v}^{i}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{\\\\partial \\\\mathbf{C} \\\\otimes d \\\\boldsymbol{\\\\mathbb{H}}} ,\\n\\\\end{align*}\\n\\n while for rate-independent materials the linearizations are          \\n\\\\begin{align*}\\n  \\\\mathcal{H}^{\\\\text{tot}} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n  &= 4 \\\\frac{d^{2} \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{d \\\\mathbf{C} \\\\otimes d \\\\mathbf{C}} , \\\\\\\\\\n  \\\\mathbb{D} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n  &= -\\\\frac{d^{2} \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{d \\\\boldsymbol{\\\\mathbb{H}} \\\\otimes d \\\\boldsymbol{\\\\mathbb{H}}} , \\\\\\\\\\n  \\\\mathfrak{P}^{\\\\text{tot}} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n  &= - 2 \\\\frac{d^{2} \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{d \\\\boldsymbol{\\\\mathbb{H}} \\\\otimes d \\\\mathbf{C}} , \\\\\\\\\\n  \\\\left[ \\\\mathfrak{P}^{\\\\text{tot}} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)  \\\\right]^{T}\\n  &= - 2 \\\\frac{d^{2} \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{d \\\\mathbf{C} \\\\otimes d \\\\boldsymbol{\\\\mathbb{H}}} .\\n\\\\end{align*}\\n\\n The subtle difference between them is the application of a partial derivative during the calculation of the first derivatives. We'll see later how this affects the choice of AD versus SD for this specific application. For now, we'll simply introduce the two specific materials that are implemented within this tutorial.\\nMagnetoelastic constitutive law\\nThe first material that we'll consider is one that is governed by a magneto-hyperelastic constitutive law. This material responds to both deformation as well as immersion in a magnetic field, but exhibits no time- or history-dependent behavior (such as dissipation through viscous damping or magnetic hysteresis, etc.). The stored energy density function for such a material is only parameterized in terms of the (current) field variables, but not their time derivatives or past values.\\nWe'll choose the energy density function, which captures both the energy stored in the material due to deformation and magnetization, as well as the energy stored in the magnetic field itself, to be          \\n\\\\[\\n  \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n= \\\\frac{1}{2} \\\\mu_{e} f_{\\\\mu_{e}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n    \\\\left[ \\\\text{tr}(\\\\mathbf{C}) - d - 2 \\\\ln (\\\\text{det}(\\\\mathbf{F}))\\n    \\\\right]\\n+ \\\\lambda_{e} \\\\ln^{2} \\\\left(\\\\text{det}(\\\\mathbf{F}) \\\\right)\\n- \\\\frac{1}{2} \\\\mu_{0} \\\\mu_{r} \\\\text{det}(\\\\mathbf{F})\\n    \\\\left[ \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1} \\\\cdot\\n    \\\\boldsymbol{\\\\mathbb{H}} \\\\right]\\n\\\\]\\n\\n with       \\n\\\\[\\n  f_{\\\\mu_{e}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n= 1 + \\\\left[ \\\\frac{\\\\mu_{e}^{\\\\infty}}{\\\\mu_{e}} - 1 \\\\right]\\n    \\\\tanh \\\\left( 2 \\\\frac{\\\\boldsymbol{\\\\mathbb{H}} \\\\cdot\\n    \\\\boldsymbol{\\\\mathbb{H}}}\\n      {\\\\left(h_{e}^{\\\\text{sat}}\\\\right)^{2}} \\\\right)\\n\\\\]\\n\\n and for which the variable \\\\(d = \\\\text{tr}(\\\\mathbf{I})\\\\) ( \\\\(\\\\mathbf{I}\\\\) being the rank-2 identity tensor) represents the spatial dimension and \\\\(\\\\mathbf{F}\\\\) is the deformation gradient tensor. To give some brief background to the various components of \\\\(\\\\psi_{0}\\\\), the first two terms bear a great resemblance to the stored energy density function for a (hyperelastic) Neohookean material. The only difference between what's used here and the Neohookean material is the scaling of the elastic shear modulus by the magnetic field-sensitive saturation function  \\\\(f_{\\\\mu_{e}}\\n\\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\\\) (see [173], equation 29). This function will, in effect, cause the material to stiffen in the presence of a strong magnetic field. As it is governed by a sigmoid-type function, the shear modulus will asymptotically converge on the specified saturation shear modulus. It can also be shown that the last term in \\\\(\\\\psi_{0}\\\\) is the stored energy density function for magnetic field (as derived from first principles), scaled by the relative permeability constant. This definition collectively implies that the material is linearly magnetized, i.e., the magnetization vector and magnetic field vector are aligned. (This is certainly not obvious with the magnetic energy stated in its current form, but when the magnetic induction and magnetization are derived from \\\\(\\\\psi_{0}\\\\) and all magnetic fields are expressed in the current configuration then this correlation becomes clear.) As for the specifics of what the magnetic induction, stress tensor, and the various material tangents look like, we'll defer presenting these to the tutorial body where the full, unassisted implementation of the constitutive law is defined.\\nMagneto-viscoelastic constitutive law\\nThe second material that we'll formulate is one for a magneto-viscoelastic material with a single dissipative mechanism i. The free energy density function that we'll be considering is defined as                        \\n\\\\begin{align*}\\n  \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v}, \\\\boldsymbol{\\\\mathbb{H}}\\n  \\\\right)\\n&= \\\\psi_{0}^{ME} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n+ \\\\psi_{0}^{MVE} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n\\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n\\\\\\\\ \\\\psi_{0}^{ME} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n&= \\\\frac{1}{2} \\\\mu_{e} f_{\\\\mu_{e}^{ME}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}}\\n\\\\right)\\n    \\\\left[ \\\\text{tr}(\\\\mathbf{C}) - d - 2 \\\\ln (\\\\text{det}(\\\\mathbf{F}))\\n    \\\\right]\\n+ \\\\lambda_{e} \\\\ln^{2} \\\\left(\\\\text{det}(\\\\mathbf{F}) \\\\right)\\n- \\\\frac{1}{2} \\\\mu_{0} \\\\mu_{r} \\\\text{det}(\\\\mathbf{F})\\n    \\\\left[ \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1} \\\\cdot\\n    \\\\boldsymbol{\\\\mathbb{H}} \\\\right]\\n\\\\\\\\ \\\\psi_{0}^{MVE} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n\\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n&= \\\\frac{1}{2} \\\\mu_{v} f_{\\\\mu_{v}^{MVE}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}}\\n\\\\right)\\n    \\\\left[ \\\\mathbf{C}_{v} : \\\\left[\\n      \\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{-\\\\frac{2}{d}}\\n      \\\\mathbf{C} \\\\right] - d - \\\\ln\\\\left(\\n      \\\\text{det}\\\\left(\\\\mathbf{C}_{v}\\\\right) \\\\right)  \\\\right]\\n\\\\end{align*}\\n\\n with       \\n\\\\[\\n  f_{\\\\mu_{e}}^{ME} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n= 1 + \\\\left[ \\\\frac{\\\\mu_{e}^{\\\\infty}}{\\\\mu_{e}} - 1 \\\\right]\\n    \\\\tanh \\\\left( 2 \\\\frac{\\\\boldsymbol{\\\\mathbb{H}} \\\\cdot\\n    \\\\boldsymbol{\\\\mathbb{H}}}\\n      {\\\\left(h_{e}^{\\\\text{sat}}\\\\right)^{2}} \\\\right)\\n\\\\]\\n\\n\\n\\\\[\\n  f_{\\\\mu_{v}}^{MVE} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n= 1 + \\\\left[ \\\\frac{\\\\mu_{v}^{\\\\infty}}{\\\\mu_{v}} - 1 \\\\right]\\n    \\\\tanh \\\\left( 2 \\\\frac{\\\\boldsymbol{\\\\mathbb{H}} \\\\cdot\\n    \\\\boldsymbol{\\\\mathbb{H}}}\\n      {\\\\left(h_{v}^{\\\\text{sat}}\\\\right)^{2}} \\\\right)\\n\\\\]\\n\\n and the evolution law       \\n\\\\[\\n  \\\\dot{\\\\mathbf{C}}_{v} \\\\left( \\\\mathbf{C} \\\\right)\\n= \\\\frac{1}{\\\\tau} \\\\left[\\n      \\\\left[\\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{-\\\\frac{2}{d}}\\n        \\\\mathbf{C}\\\\right]^{-1}\\n    - \\\\mathbf{C}_{v} \\\\right]\\n\\\\]\\n\\n for the internal viscous variable. We've chosen the magnetoelastic part of the energy \\\\(\\\\psi_{0}^{ME} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\\\) to match that of the first material model that we explored, so this part needs no further explanation. As for the viscous part \\\\(\\\\psi_{0}^{MVE}\\\\), this component of the free energy (in conjunction with the evolution law for the viscous deformation tensor) is taken from [144] (with the additional scaling by the viscous saturation function described in [173]). It is derived in a thermodynamically consistent framework that, at its core, models the movement of polymer chains on a micro-scale level.\\nTo proceed beyond this point, we'll also need to consider the time discretization of the evolution law. Choosing the implicit first-order backwards difference scheme, then        \\n\\\\[\\n  \\\\dot{\\\\mathbf{C}}_{v}\\n\\\\approx \\\\frac{\\\\mathbf{C}_{v}^{(t)} - \\\\mathbf{C}_{v}^{(t-1)}}{\\\\Delta t}\\n= \\\\frac{1}{\\\\tau} \\\\left[\\n      \\\\left[\\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{-\\\\frac{2}{d}}\\n        \\\\mathbf{C}\\\\right]^{-1}\\n    - \\\\mathbf{C}_{v}^{(t)} \\\\right]\\n\\\\]\\n\\n where the superscript \\\\((t)\\\\) denotes that the quantity is taken at the current timestep, and \\\\((t-1)\\\\) denotes quantities taken at the previous timestep (i.e., a history variable). The timestep size \\\\(\\\\Delta t\\\\) is the difference between the current time and that of the previous timestep. Rearranging the terms so that all internal variable quantities at the current time are on the left hand side of the equation, we get         \\n\\\\[\\n\\\\mathbf{C}_{v}^{(t)}\\n= \\\\frac{1}{1 + \\\\frac{\\\\Delta t}{\\\\tau_{v}}} \\\\left[\\n    \\\\mathbf{C}_{v}^{(t-1)}\\n  + \\\\frac{\\\\Delta t}{\\\\tau_{v}}\\n    \\\\left[\\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{-\\\\frac{2}{d}}\\n    \\\\mathbf{C} \\\\right]^{-1}\\n  \\\\right]\\n\\\\]\\n\\n that matches [144] equation 54.\\nRheological experiment\\nNow that we have shown all of these formulas for the thermodynamics and theory governing magneto-mechanics and constitutive models, let us outline what the program will do with all of this. We wish to do something meaningful with the materials laws that we've formulated, and so it makes sense to subject them to some mechanical and magnetic loading conditions that are, in some way, representative of some conditions that might be found either in an application or in a laboratory setting. One way to achieve that aim would be to embed these constitutive laws in a finite element model to simulate a device. In this instance, though, we'll keep things simple (we are focusing on the automatic and symbolic differentiation concepts, after all) and will find a concise way to faithfully replicate an industry-standard rheological experiment using an analytical expression for the loading conditions.\\nThe rheological experiment that we'll reproduce, which idealizes a laboratory experiment that was used to characterize magneto-active polymers, is detailed in [173] (as well as [172], in which it is documented along with the real-world experiments). The images below provide a visual description of the problem set up.\\n\\n\\n \\nThe basic functional geometry of the parallel-plate rotational rheometer. The smooth rotor (blue) applies a torque to an experimental sample (red) of radius \\\\(r\\\\) and height \\\\(H\\\\) while an axially aligned magnetic field generated by a a magneto-rheological device. Although the time-dependent deformation profile of the may be varied, one common experiment would be to subject the material to a harmonic torsional deformation of constant amplitude and frequency \\\\(\\\\omega\\\\). \\n\\n \\nSchematic of the kinematics of the problem, assuming no preloading or compression of the sample. A point \\\\(\\\\mathbf{P}\\\\) located at azimuth \\\\(\\\\Theta\\\\) is displaced to location \\\\(\\\\mathbf{p}\\\\) at azimuth \\\\(\\\\theta = \\\\Theta + \\\\alpha\\\\). \\n\\n\\n\\nUnder the assumptions that an incompressible medium is being tested, and that the deformation profile through the sample thickness is linear, then the displacement at some measurement point \\\\(\\\\mathbf{X}\\\\) within the sample, expressed in radial coordinates, is         \\n\\\\begin{align*}\\n  r(\\\\mathbf{X})\\n  &= \\\\frac{R(X_{1}, X_{2})}{\\\\sqrt{\\\\lambda_{3}}} , \\\\\\\\\\n  \\\\theta(\\\\mathbf{X})\\n  & = \\\\Theta(X_{1}, X_{2}) + \\\\underbrace{\\\\tau(t)\\n       \\\\lambda_{3} X_{3}}_{\\\\alpha(X_{3}, t)} , \\\\\\\\\\n  z(\\\\mathbf{X})\\n  &= \\\\lambda_{3} X_{3}\\n\\\\end{align*}\\n\\n where \\\\(R(X_{1}, X_{2})\\\\) and \\\\(\\\\Theta(X_{1}, X_{2})\\\\) are the radius at \\u2013 and angle of \\u2013 the sampling point, \\\\(\\\\lambda_{3}\\\\) is the (constant) axial deformation, \\\\(\\\\tau(t) = \\\\frac{A}{RH} \\\\sin\\\\left(\\\\omega t\\\\right)\\\\) is the time-dependent torsion angle per unit length that will be prescribed using a sinusoidally repeating oscillation of fixed amplitude \\\\(A\\\\). The magnetic field is aligned axially, i.e., in the \\\\(X_{3}\\\\) direction.\\nThis summarizes everything that we need to fully characterize the idealized loading at any point within the rheological sample. We'll set up the problem in such a way that we \\\"pick\\\" a representative point with this sample, and subject it to a harmonic shear deformation at a constant axial deformation (by default, a compressive load) and a constant, axially applied magnetic field. We will record the stress and magnetic induction at this point, and will output that data to file for post-processing. Although its not necessary for this particular problem, we will also be computing the tangents as well. Even though they are not directly used in this particular piece of work, these second derivatives are needed to embed the constitutive law within a finite element model (one possible extension to this work). We'll therefore take the opportunity to check our hand calculations for correctness using the assisted differentiation frameworks.\\nSuggested literature\\nIn addition to the already mentioned Automatic and symbolic differentiation topic, the following are a few references that discuss in more detail\\nmagneto-mechanics, and some aspects of automated differentiation frameworks: [170], [172], and\\nthe automation of finite element frameworks using AD and/or SD: [146], [133].\\n\\n\\n\\n The commented program\\nWe start by including all the necessary deal.II header files and some C++ related ones. This first header will give us access to a data structure that will allow us to store arbitrary data within it.\\n\\u00a0 #include <deal.II/algorithms/general_data_storage.h>\\n\\u00a0 \\nNext come some core classes, including one that provides an implementation for time-stepping.\\n\\u00a0 #include <deal.II/base/discrete_time.h>\\n\\u00a0 #include <deal.II/base/numbers.h>\\n\\u00a0 #include <deal.II/base/parameter_acceptor.h>\\n\\u00a0 #include <deal.II/base/symmetric_tensor.h>\\n\\u00a0 #include <deal.II/base/tensor.h>\\n\\u00a0 #include <deal.II/base/timer.h>\\n\\u00a0 #include <deal.II/base/utilities.h>\\n\\u00a0 \\nnumbersDefinition numbers.h:230\\nThen some headers that define some useful coordinate transformations and kinematic relationships that are often found in nonlinear elasticity.\\n\\u00a0 #include <deal.II/physics/transformations.h>\\n\\u00a0 #include <deal.II/physics/elasticity/kinematics.h>\\n\\u00a0 #include <deal.II/physics/elasticity/standard_tensors.h>\\n\\u00a0 \\nThe following two headers provide all of the functionality that we need to perform automatic differentiation, and use the symbolic computer algebra system that deal.II can utilize. The headers of all automatic differentiation and symbolic differentiation wrapper classes, and any ancillary data structures that are required, are all collected inside these unifying headers.\\n\\u00a0 #include <deal.II/differentiation/ad.h>\\n\\u00a0 #include <deal.II/differentiation/sd.h>\\n\\u00a0 \\nIncluding this header allows us the capability to write output to a file stream.\\n\\u00a0 #include <fstream>\\n\\u00a0 \\n\\u00a0 \\nAs per usual, the entire tutorial program is defined within its own unique namespace.\\n\\u00a0 namespace Step71\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n An introductory example: The fundamentals of automatic and symbolic differentiation\\nAutomatic and symbolic differentiation have some magical and mystical qualities. Although their use in a project can be beneficial for a multitude of reasons, the barrier to understanding how to use these frameworks or how they can be leveraged may exceed the patience of the developer that is trying to (reliably) integrate them into their work.\\nAlthough it is the wish of the author to successfully illustrate how these tools can be integrated into workflows for finite element modelling, it might be best to first take a step back and start right from the basics. So to start off with, we'll first have a look at differentiating a \\\"simple\\\" mathematical function using both frameworks, so that the fundamental operations (both their sequence and function) can be firmly established and understood with minimal complication. In the second part of this tutorial we will put these fundamentals into practice and build on them further.\\nAccompanying the description of the algorithmic steps to use the frameworks will be a simplified view as to what they might be doing in the background. This description will be very much one designed to aid understanding, and the reader is encouraged to view the Automatic and symbolic differentiation documentation topic for a far more formal description into how these tools actually work.\\n An analytical function\\n\\u00a0   namespace SimpleExample\\n\\u00a0   {\\nIn order to convince the reader that these tools are indeed useful in practice, let us choose a function for which it is not too difficult to compute the analytical derivatives by hand. It's just sufficiently complicated to make you think about whether or not you truly want to go through with this exercise, and might also make you question whether you are completely sure that your calculations and implementation for its derivatives are correct. The point, of course, is that differentiation of functions is in a sense relatively formulaic and should be something computers are good at \\u2013 if we could build on existing software that understands the rules, we wouldn't have to bother with doing it ourselves.\\nWe choose the two variable trigonometric function \\\\(f(x,y) = \\\\cos\\\\left(\\\\frac{y}{x}\\\\right)\\\\) for this purpose. Notice that this function is templated on the number type. This is done because we can often (but not always) use special auto-differentiable and symbolic types as drop-in replacements for real or complex valued types, and these will then perform some elementary calculations, such as evaluate a function value along with its derivatives. We will exploit that property and make sure that we need only define our function once, and then it can be re-used in whichever context we wish to perform differential operations on it.\\n\\u00a0     template <typename NumberType>\\n\\u00a0     NumberType f(const NumberType &x, const NumberType &y)\\n\\u00a0     {\\n\\u00a0       return std::cos(y / x);\\n\\u00a0     }\\n\\u00a0 \\nstd::cos::VectorizedArray< Number, width > cos(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6609\\nRather than revealing this function's derivatives immediately, we'll forward declare functions that return them and defer their definition to later. As implied by the function names, they respectively return the derivatives \\\\(\\\\frac{df(x,y)}{dx}\\\\):\\n\\u00a0     double df_dx(const double x, const double y);\\n\\u00a0 \\n\\\\(\\\\frac{df(x,y)}{dy}\\\\):\\n\\u00a0     double df_dy(const double x, const double y);\\n\\u00a0 \\n\\\\(\\\\frac{d^{2}f(x,y)}{dx^{2}}\\\\):\\n\\u00a0     double d2f_dx_dx(const double x, const double y);\\n\\u00a0 \\n\\\\(\\\\frac{d^{2}f(x,y)}{dx dy}\\\\):\\n\\u00a0     double d2f_dx_dy(const double x, const double y);\\n\\u00a0 \\n\\\\(\\\\frac{d^{2}f(x,y)}{dy dx}\\\\):\\n\\u00a0     double d2f_dy_dx(const double x, const double y);\\n\\u00a0 \\nand, lastly, \\\\(\\\\frac{d^{2}f(x,y)}{dy^{2}}\\\\):\\n\\u00a0     double d2f_dy_dy(const double x, const double y);\\n\\u00a0 \\n\\u00a0 \\n Computing derivatives using automatic differentiation\\nTo begin, we'll use AD as the tool to automatically compute derivatives for us. We will evaluate the function with the arguments x and y, and expect the resulting value and all of the derivatives to match to within the given tolerance.\\n\\u00a0     void\\n\\u00a0     run_and_verify_ad(const double x, const double y, const double tol = 1e-12)\\n\\u00a0     {\\nOur function \\\\(f(x,y)\\\\) is a scalar-valued function, with arguments that represent the typical input variables that one comes across in algebraic calculations or tensor calculus. For this reason, the Differentiation::AD::ScalarFunction class is the appropriate wrapper class to use to do the computations that we require. (As a point of comparison, if the function arguments represented finite element cell degrees-of-freedom, we'd want to treat them differently.) The spatial dimension of the problem is irrelevant since we have no vector- or tensor-valued arguments to accommodate, so the dim template argument is arbitrarily assigned a value of 1. The second template argument stipulates which AD framework will be used (deal.II has support for several external AD frameworks), and what the underlying number type provided by this framework is to be used. This number type influences the maximum order of the differential operation, and the underlying algorithms that are used to compute them. Given its template nature, this choice is a compile-time decision because many (but not all) of the AD libraries exploit compile-time meta-programming to implement these special number types in an efficient manner. The third template parameter states what the result type is; in our case, we're working with doubles.\\n\\u00a0       constexpr unsigned int                     dim = 1;\\n\\u00a0       constexpr Differentiation::AD::NumberTypes ADTypeCode =\\n\\u00a0         Differentiation::AD::NumberTypes::sacado_dfad_dfad;\\n\\u00a0       using ADHelper =\\n\\u00a0         Differentiation::AD::ScalarFunction<dim, ADTypeCode, double>;\\n\\u00a0 \\nDifferentiation::AD::ScalarFunctionDefinition ad_helpers.h:3118\\nDifferentiation::AD::NumberTypesNumberTypesDefinition ad_number_types.h:34\\nDifferentiation::AD::NumberTypes::sacado_dfad_dfad@ sacado_dfad_dfad\\nIt is necessary that we pre-register with our ADHelper class how many arguments (what we will call \\\"independent variables\\\") the function \\\\(f(x,y)\\\\) has. Those arguments are x and y, so obviously there are two of them.\\n\\u00a0       constexpr unsigned int n_independent_variables = 2;\\n\\u00a0 \\nWe now have sufficient information to create and initialize an instance of the helper class. We can also get the concrete number type that will be used in all subsequent calculations. This is useful, because we can write everything from here on by referencing this type, and if we ever want to change the framework used, or number type (e.g., if we need more differential operations) then we need only adjust the ADTypeCode template parameter.\\n\\u00a0       ADHelper ad_helper(n_independent_variables);\\n\\u00a0       using ADNumberType = typename ADHelper::ad_type;\\n\\u00a0 \\nThe next step is to register the numerical values of the independent variables with the helper class. This is done because the function and its derivatives will be evaluated for exactly these arguments. Since we register them in the order {x,y}, the variable x will be assigned component number 0, and y will be component 1 \\u2013 a detail that will be used in the next few lines.\\n\\u00a0       ad_helper.register_independent_variables({x, y});\\n\\u00a0 \\nWe now ask for the helper class to give to us the independent variables with their auto-differentiable representation. These are termed \\\"sensitive variables\\\", because from this point on any operations that we do with the components independent_variables_ad are tracked and recorded by the AD framework, and will be considered when we ask for the derivatives of something that they're used to compute. What the helper returns is a vector of auto-differentiable numbers, but we can be sure that the zeroth element represents x and the first element y. Just to make completely sure that there's no ambiguity of what number type these variables are, we suffix all of the auto-differentiable variables with ad.\\n\\u00a0       const std::vector<ADNumberType> independent_variables_ad =\\n\\u00a0         ad_helper.get_sensitive_variables();\\n\\u00a0       const ADNumberType &x_ad = independent_variables_ad[0];\\n\\u00a0       const ADNumberType &y_ad = independent_variables_ad[1];\\n\\u00a0 \\nWe can immediately pass in our sensitive representation of the independent variables to our templated function that computes \\\\(f(x,y)\\\\). This also returns an auto-differentiable number.\\n\\u00a0       const ADNumberType f_ad = f(x_ad, y_ad);\\n\\u00a0 \\nSo now the natural question to ask is what we have actually just computed by passing these special x_ad and y_ad variables to the function f, instead of the original double variables x and y? In other words, how is all of this related to the computation of the derivatives that we were wanting to determine? Or, more concisely: What is so special about this returned ADNumberType object that gives it the ability to magically return derivatives?\\nIn essence, how this could be done is the following: This special number can be viewed as a data structure that stores the function value, and the prescribed number of derivatives. For a once-differentiable number expecting two arguments, it might look like this:\\n struct ADNumberType\\n{\\n double value;          // The value of the object\\n double derivatives[2]; // Array of derivatives of the object with\\n // respect to x and y\\n};\\n For our independent variable x_ad, the starting value of x_ad.value would simply be its assigned value (i.e., the real value of that this variable represents). The derivative x_ad.derivatives[0] would be initialized to 1, since x is the zeroth independent variable and \\\\(\\\\frac{d(x)}{dx} = 1\\\\). The derivative x.derivatives[1] would be initialized to zero, since the first independent variable is y and \\\\(\\\\frac{d(x)}{dy} = 0\\\\).\\nFor the function derivatives to be meaningful, we must assume that not only is this function differentiable in an analytical sense, but that it is also differentiable at the evaluation point x,y. We can exploit both of these assumptions: when we use this number type in mathematical operations, the AD framework could overload the operations (e.g., operator+(), operator*() as well as sin(), exp(), etc.) such that the returned result has the expected value. At the same time, it would then compute the derivatives through the knowledge of exactly what function is being overloaded and rigorous application of the chain-rule. So, the sin() function (with its argument a itself being a function of the independent variables x and y) might be defined as follows:\\n ADNumberType sin(const ADNumberType &a)\\n{\\n  ADNumberType output;\\n \\n \\n // For the input argument \\\"a\\\", \\\"a.value\\\" is simply its value.\\n  output.value = sin(a.value);\\n \\n \\n // We know that the derivative of sin(a) is cos(a), but we need\\n // to also consider the chain rule and that the input argument\\n // `a` is also differentiable with respect to the original\\n // independent variables `x` and `y`. So `a.derivatives[0]`\\n // and `a.derivatives[1]` respectively represent the partial\\n // derivatives of `a` with respect to its inputs `x` and `y`.\\n  output.derivatives[0] = cos(a.value)*a.derivatives[0];\\n  output.derivatives[1] = cos(a.value)*a.derivatives[1];\\n \\n \\n return output;\\n}\\n All of that could of course also be done for second and even higher order derivatives.\\nSo it is now clear that with the above representation the ADNumberType is carrying around some extra data that represents the various derivatives of differentiable functions with respect to the original (sensitive) independent variables. It should therefore be noted that there is computational overhead associated with using them (as we compute extra functions when doing derivative computations) as well as memory overhead in storing these results. So the prescribed number of levels of differential operations should ideally be kept to a minimum to limit computational cost. We could, for instance, have computed the first derivatives ourself and then have used the Differentiation::AD::VectorFunction helper class to determine the gradient of the collection of dependent functions, which would be the second derivatives of the original scalar function.\\nIt is also worth noting that because the chain rule is indiscriminately applied and we only see the beginning and end-points of the calculation {x,y} \\\\(\\\\rightarrow\\\\) f(x,y), we will only ever be able to query the total derivatives of f; the partial derivatives (a.derivatives[0] and a.derivatives[1] in the above example) are intermediate values and are hidden from us.\\nOkay, since we now at least have some idea as to exactly what f_ad represents and what is encoded within it, let's put all of that to some actual use. To gain access to those hidden derivative results, we register the final result with the helper class. After this point, we can no longer change the value of f_ad and have those changes reflected in the results returned by the helper class.\\n\\u00a0       ad_helper.register_dependent_variable(f_ad);\\n\\u00a0 \\nThe next step is to extract the derivatives (specifically, the function gradient and Hessian). To do so we first create some temporary data structures (with the result type double) to store the derivatives (noting that all derivatives are returned at once, and not individually)...\\n\\u00a0       Vector<double>     Df(ad_helper.n_dependent_variables());\\n\\u00a0       FullMatrix<double> D2f(ad_helper.n_dependent_variables(),\\n\\u00a0                              ad_helper.n_independent_variables());\\n\\u00a0 \\nFullMatrixDefinition full_matrix.h:79\\nVectorDefinition vector.h:120\\n... and we then request that the helper class compute these derivatives, and the function value itself. And that's it. We have everything that we were aiming to get.\\n\\u00a0       const double computed_f = ad_helper.compute_value();\\n\\u00a0       ad_helper.compute_gradient(Df);\\n\\u00a0       ad_helper.compute_hessian(D2f);\\n\\u00a0 \\nWe can convince ourselves that the AD framework is correct by comparing it to the analytical solution. (Or, if you're like the author, you'll be doing the opposite and will rather verify that your implementation of the analytical solution is correct!)\\n\\u00a0       AssertThrow(std::abs(f(x, y) - computed_f) < tol,\\n\\u00a0                   ExcMessage(std::string(\\\"Incorrect value computed for f. \\\") +\\n\\u00a0                              std::string(\\\"Hand-calculated value: \\\") +\\n\\u00a0                              Utilities::to_string(f(x, y)) +\\n\\u00a0                              std::string(\\\" ; \\\") +\\n\\u00a0                              std::string(\\\"Value computed by AD: \\\") +\\n\\u00a0                              Utilities::to_string(computed_f)));\\n\\u00a0 \\nAssertThrow#define AssertThrow(cond, exc)Definition exceptions.h:1739\\nUtilities::to_stringstd::string to_string(const number value, const unsigned int digits=numbers::invalid_unsigned_int)Definition utilities.cc:479\\nstd::abs::VectorizedArray< Number, width > abs(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6927\\nBecause we know the ordering of the independent variables, we know which component of the gradient relates to which derivative...\\n\\u00a0       const double computed_df_dx = Df[0];\\n\\u00a0       const double computed_df_dy = Df[1];\\n\\u00a0 \\n\\u00a0       AssertThrow(std::abs(df_dx(x, y) - computed_df_dx) < tol,\\n\\u00a0                   ExcMessage(\\n\\u00a0                     std::string(\\\"Incorrect value computed for df/dx. \\\") +\\n\\u00a0                     std::string(\\\"Hand-calculated value: \\\") +\\n\\u00a0                     Utilities::to_string(df_dx(x, y)) + std::string(\\\" ; \\\") +\\n\\u00a0                     std::string(\\\"Value computed by AD: \\\") +\\n\\u00a0                     Utilities::to_string(computed_df_dx)));\\n\\u00a0       AssertThrow(std::abs(df_dy(x, y) - computed_df_dy) < tol,\\n\\u00a0                   ExcMessage(\\n\\u00a0                     std::string(\\\"Incorrect value computed for df/dy. \\\") +\\n\\u00a0                     std::string(\\\"Hand-calculated value: \\\") +\\n\\u00a0                     Utilities::to_string(df_dy(x, y)) + std::string(\\\" ; \\\") +\\n\\u00a0                     std::string(\\\"Value computed by AD: \\\") +\\n\\u00a0                     Utilities::to_string(computed_df_dy)));\\n\\u00a0 \\n... and similar for the Hessian.\\n\\u00a0       const double computed_d2f_dx_dx = D2f[0][0];\\n\\u00a0       const double computed_d2f_dx_dy = D2f[0][1];\\n\\u00a0       const double computed_d2f_dy_dx = D2f[1][0];\\n\\u00a0       const double computed_d2f_dy_dy = D2f[1][1];\\n\\u00a0 \\n\\u00a0       AssertThrow(std::abs(d2f_dx_dx(x, y) - computed_d2f_dx_dx) < tol,\\n\\u00a0                   ExcMessage(\\n\\u00a0                     std::string(\\\"Incorrect value computed for d2f/dx_dx. \\\") +\\n\\u00a0                     std::string(\\\"Hand-calculated value: \\\") +\\n\\u00a0                     Utilities::to_string(d2f_dx_dx(x, y)) + std::string(\\\" ; \\\") +\\n\\u00a0                     std::string(\\\"Value computed by AD: \\\") +\\n\\u00a0                     Utilities::to_string(computed_d2f_dx_dx)));\\n\\u00a0       AssertThrow(std::abs(d2f_dx_dy(x, y) - computed_d2f_dx_dy) < tol,\\n\\u00a0                   ExcMessage(\\n\\u00a0                     std::string(\\\"Incorrect value computed for d2f/dx_dy. \\\") +\\n\\u00a0                     std::string(\\\"Hand-calculated value: \\\") +\\n\\u00a0                     Utilities::to_string(d2f_dx_dy(x, y)) + std::string(\\\" ; \\\") +\\n\\u00a0                     std::string(\\\"Value computed by AD: \\\") +\\n\\u00a0                     Utilities::to_string(computed_d2f_dx_dy)));\\n\\u00a0       AssertThrow(std::abs(d2f_dy_dx(x, y) - computed_d2f_dy_dx) < tol,\\n\\u00a0                   ExcMessage(\\n\\u00a0                     std::string(\\\"Incorrect value computed for d2f/dy_dx. \\\") +\\n\\u00a0                     std::string(\\\"Hand-calculated value: \\\") +\\n\\u00a0                     Utilities::to_string(d2f_dy_dx(x, y)) + std::string(\\\" ; \\\") +\\n\\u00a0                     std::string(\\\"Value computed by AD: \\\") +\\n\\u00a0                     Utilities::to_string(computed_d2f_dy_dx)));\\n\\u00a0       AssertThrow(std::abs(d2f_dy_dy(x, y) - computed_d2f_dy_dy) < tol,\\n\\u00a0                   ExcMessage(\\n\\u00a0                     std::string(\\\"Incorrect value computed for d2f/dy_dy. \\\") +\\n\\u00a0                     std::string(\\\"Hand-calculated value: \\\") +\\n\\u00a0                     Utilities::to_string(d2f_dy_dy(x, y)) + std::string(\\\" ; \\\") +\\n\\u00a0                     std::string(\\\"Value computed by AD: \\\") +\\n\\u00a0                     Utilities::to_string(computed_d2f_dy_dy)));\\n\\u00a0     }\\n\\u00a0 \\nThat's pretty great. There wasn't too much work involved in computing second-order derivatives of this trigonometric function.\\n Hand-calculated derivatives of the analytical solution\\nSince we now know how much \\\"implementation effort\\\" it takes to have the AD framework compute those derivatives for us, let's compare that to the same computed by hand and implemented in several stand-alone functions.\\nHere are the two first derivatives of  \\\\(f(x,y) =\\n   \\\\cos\\\\left(\\\\frac{y}{x}\\\\right)\\\\):\\n\\\\(\\\\frac{df(x,y)}{dx} = \\\\frac{y}{x^2} \\\\sin\\\\left(\\\\frac{y}{x}\\\\right)\\\\)\\n\\u00a0     double df_dx(const double x, const double y)\\n\\u00a0     {\\n\\u00a0       Assert(x != 0.0, ExcDivideByZero());\\n\\u00a0       return y * std::sin(y / x) / (x * x);\\n\\u00a0     }\\n\\u00a0 \\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\nstd::sin::VectorizedArray< Number, width > sin(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6589\\n\\\\(\\\\frac{df(x,y)}{dx} = -\\\\frac{1}{x} \\\\sin\\\\left(\\\\frac{y}{x}\\\\right)\\\\)\\n\\u00a0     double df_dy(const double x, const double y)\\n\\u00a0     {\\n\\u00a0       return -std::sin(y / x) / x;\\n\\u00a0     }\\n\\u00a0 \\nAnd here are the four second derivatives of \\\\(f(x,y)\\\\):\\n\\\\(\\\\frac{d^{2}f(x,y)}{dx^{2}} = -\\\\frac{y}{x^4} (2x\\n   \\\\sin\\\\left(\\\\frac{y}{x}\\\\right) + y \\\\cos\\\\left(\\\\frac{y}{x}\\\\right))\\\\)\\n\\u00a0     double d2f_dx_dx(const double x, const double y)\\n\\u00a0     {\\n\\u00a0       return -y * (2 * x * std::sin(y / x) + y * std::cos(y / x)) /\\n\\u00a0              (x * x * x * x);\\n\\u00a0     }\\n\\u00a0 \\n\\\\(\\\\frac{d^{2}f(x,y)}{dx dy} = \\\\frac{1}{x^3} (x\\n   \\\\sin\\\\left(\\\\frac{y}{x}\\\\right) + y \\\\cos\\\\left(\\\\frac{y}{x}\\\\right))\\\\)\\n\\u00a0     double d2f_dx_dy(const double x, const double y)\\n\\u00a0     {\\n\\u00a0       return (x * std::sin(y / x) + y * std::cos(y / x)) / (x * x * x);\\n\\u00a0     }\\n\\u00a0 \\n\\\\(\\\\frac{d^{2}f(x,y)}{dy dx} = \\\\frac{1}{x^3} (x\\n   \\\\sin\\\\left(\\\\frac{y}{x}\\\\right) + y \\\\cos\\\\left(\\\\frac{y}{x}\\\\right))\\\\) (as expected, on the basis of Schwarz's theorem)\\n\\u00a0     double d2f_dy_dx(const double x, const double y)\\n\\u00a0     {\\n\\u00a0       return (x * std::sin(y / x) + y * std::cos(y / x)) / (x * x * x);\\n\\u00a0     }\\n\\u00a0 \\n\\\\(\\\\frac{d^{2}f(x,y)}{dy^{2}} = -\\\\frac{1}{x^2}\\n   \\\\cos\\\\left(\\\\frac{y}{x}\\\\right)\\\\)\\n\\u00a0     double d2f_dy_dy(const double x, const double y)\\n\\u00a0     {\\n\\u00a0       return -(std::cos(y / x)) / (x * x);\\n\\u00a0     }\\n\\u00a0 \\nHmm... there's a lot of places in the above where we could have introduced an error in the above, especially when it comes to applying the chain rule. Although they're no silver bullet, at the very least these AD frameworks can serve as a verification tool to make sure that we haven't made any errors (either by calculation or by implementation) that would negatively affect our results.\\nThe point of this example of course is that we might have chosen a relatively simple function \\\\(f(x,y)\\\\) for which we can hand-verify that the derivatives the AD framework computed is correct. But the AD framework didn't care that the function was simple: It could have been a much much more convoluted expression, or could have depended on more than two variables, and it would still have been able to compute the derivatives \\u2013 the only difference would have been that we wouldn't have been able to come up with the derivatives any more to verify correctness of the AD framework.\\n Computing derivatives using symbolic differentiation\\nWe'll now repeat the same exercise using symbolic differentiation. The term \\\"symbolic differentiation\\\" is a little bit misleading because differentiation is just one tool that the Computer Algebra System (CAS) (i.e., the symbolic framework) provides. Nevertheless, in the context of finite element modeling and applications it is the most common use of a CAS and will therefore be the one that we'll focus on. Once more, we'll supply the argument values x and y with which to evaluate our function \\\\(f(x,y) = \\\\cos\\\\left(\\\\frac{y}{x}\\\\right)\\\\) and its derivatives, and a tolerance with which to test the correctness of the returned results.\\n\\u00a0     void\\n\\u00a0     run_and_verify_sd(const double x, const double y, const double tol = 1e-12)\\n\\u00a0     {\\nThe first step that we need to take is to form the symbolic variables that represent the function arguments that we wish to differentiate with respect to. Again, these will be the independent variables for our problem and as such are, in some sense, primitive variables that have no dependencies on any other variable. We create these types of (independent) variables by initializing a symbolic type Differentiation::SD::Expression, which is a wrapper to a set of classes used by the symbolic framework, with a unique identifier. On this occasion it makes sense that this identifier, a std::string, be simply \\\"x\\\" for the \\\\(x\\\\) argument, and likewise \\\"y\\\" for the \\\\(y\\\\) argument to the dependent function. Like before, we'll suffix symbolic variable names with sd so that we can clearly see which variables are symbolic (as opposed to numeric) in nature.\\n\\u00a0       const Differentiation::SD::Expression x_sd(\\\"x\\\");\\n\\u00a0       const Differentiation::SD::Expression y_sd(\\\"y\\\");\\n\\u00a0 \\nDifferentiation::SD::ExpressionDefinition symengine_number_types.h:177\\nUsing the templated function that computes \\\\(f(x,y)\\\\), we can pass these independent variables as arguments to the function. The returned result will be another symbolic type that represents the sequence of operations used to compute \\\\(\\\\cos\\\\left(\\\\frac{y}{x}\\\\right)\\\\).\\n\\u00a0       const Differentiation::SD::Expression f_sd = f(x_sd, y_sd);\\n\\u00a0 \\nAt this point it is legitimate to print out the expression f_sd, and if we did so  std::cout << \\\"f(x,y) = \\\" << f_sd << std::endl;\\n  we would see f(x,y) = cos(y/x) printed to the console.\\nYou might notice that we've constructed our symbolic function f_sd with no context as to how we might want to use it: In contrast to the AD approach shown above, what we were returned from calling f(x_sd, y_sd) is not the evaluation of the function f at some specific point, but is in fact a symbolic representation of the evaluation at a generic, as yet undetermined, point. This is one of the key points that makes symbolic frameworks (the CAS) different from automatic differentiation frameworks. Each of the variables x_sd and y_sd, and even the composite dependent function f_sd, are in some sense respectively \\\"placeholders\\\" for numerical values and a composition of operations. In fact, the individual components that are used to compose the function are also placeholders. The sequence of operations are encoded into in a tree-like data structure (conceptually similar to an abstract syntax tree).\\nOnce we form these data structures we can defer any operations that we might want to do with them until some later time. Each of these placeholders represents something, but we have the opportunity to define or redefine what they represent at any convenient point in time. So for this particular problem it makes sense that we somehow want to associate \\\"x\\\" and \\\"y\\\" with some numerical value (with type yet to be determined), but we could conceptually (and if it made sense) assign the ratio \\\"y/x\\\" a value instead of the variables \\\"x\\\" and \\\"y\\\" individually. We could also associate with \\\"x\\\" or \\\"y\\\" some other symbolic function g(a,b). Any of these operations involves manipulating the recorded tree of operations, and substituting the salient nodes on the tree (and that nodes' subtree) with something else. The key word here is \\\"substitution\\\", and indeed there are many functions in the Differentiation::SD namespace that have this word in their names.\\nThis capability makes the framework entirely generic. In the context of finite element simulations, the types of operations that we would typically perform with our symbolic types are function composition, differentiation, substitution (partial or complete), and evaluation (i.e., conversion of the symbolic type to its numerical counterpart). But should you need it, a CAS is often capable of more than just this: It could be forming anti-derivatives (integrals) of functions, perform simplifications on the expressions that form a function (e.g., replace \\\\((\\\\sin a)^2 + (\\\\cos a)^2\\\\) by \\\\(1\\\\); or, more simply: if the function did an operation like 1+2, a CAS could replace it by 3), and so forth: The expression that a variable represents is obtained from how the function \\\\(f\\\\) is implemented, but a CAS can do with it whatever its functionality happens to be.\\nSpecifically, to compute the symbolic representation of the first derivatives of the dependent function with respect to its individual independent variables, we use the Differentiation::SD::Expression::differentiate() function with the independent variable given as its argument. Each call will cause the CAS to go through the tree of operations that compose f_sd and differentiate each node of the expression tree with respect to the given symbolic argument.\\n\\u00a0       const Differentiation::SD::Expression df_dx_sd = f_sd.differentiate(x_sd);\\n\\u00a0       const Differentiation::SD::Expression df_dy_sd = f_sd.differentiate(y_sd);\\n\\u00a0 \\nDifferentiation::SD::Expression::differentiateExpression differentiate(const Expression &symbol) constDefinition symengine_number_types.cc:261\\nTo compute the symbolic representation of the second derivatives, we simply differentiate the first derivatives with respect to the independent variables. So to compute a higher order derivative, we first need to compute the lower order derivative. (As the return type of the call to differentiate() is an expression, we could in principal execute double differentiation directly from the scalar by chaining two calls together. But this is unnecessary in this particular case, since we have the intermediate results at hand.)\\n\\u00a0       const Differentiation::SD::Expression d2f_dx_dx_sd =\\n\\u00a0         df_dx_sd.differentiate(x_sd);\\n\\u00a0       const Differentiation::SD::Expression d2f_dx_dy_sd =\\n\\u00a0         df_dx_sd.differentiate(y_sd);\\n\\u00a0       const Differentiation::SD::Expression d2f_dy_dx_sd =\\n\\u00a0         df_dy_sd.differentiate(x_sd);\\n\\u00a0       const Differentiation::SD::Expression d2f_dy_dy_sd =\\n\\u00a0         df_dy_sd.differentiate(y_sd);\\nPrinting the expressions for the first and second derivatives, as computed by the CAS, using the statements  std::cout << \\\"df_dx_sd: \\\" << df_dx_sd << std::endl;\\nstd::cout << \\\"df_dy_sd: \\\" << df_dy_sd << std::endl;\\nstd::cout << \\\"d2f_dx_dx_sd: \\\" << d2f_dx_dx_sd << std::endl;\\nstd::cout << \\\"d2f_dx_dy_sd: \\\" << d2f_dx_dy_sd << std::endl;\\nstd::cout << \\\"d2f_dy_dx_sd: \\\" << d2f_dy_dx_sd << std::endl;\\nstd::cout << \\\"d2f_dy_dy_sd: \\\" << d2f_dy_dy_sd << std::endl;\\n  renders the following output:  df_dx_sd: y*sin(y/x)/x**2\\ndf_dy_sd: -sin(y/x)/x\\nd2f_dx_dx_sd: -y**2*cos(y/x)/x**4 - 2*y*sin(y/x)/x**3\\nd2f_dx_dy_sd: sin(y/x)/x**2 + y*cos(y/x)/x**3\\nd2f_dy_dx_sd: sin(y/x)/x**2 + y*cos(y/x)/x**3\\nd2f_dy_dy_sd: -cos(y/x)/x**2\\n  This compares favorably to the analytical expressions for these derivatives that were presented earlier.\\nNow that we have formed the symbolic expressions for the function and its derivatives, we want to evaluate them for the numeric values for the main function arguments x and y. To accomplish this, we construct a substitution map, which maps the symbolic values to their numerical counterparts.\\n\\u00a0       const Differentiation::SD::types::substitution_map substitution_map =\\n\\u00a0         Differentiation::SD::make_substitution_map(\\n\\u00a0           std::pair<Differentiation::SD::Expression, double>{x_sd, x},\\n\\u00a0           std::pair<Differentiation::SD::Expression, double>{y_sd, y});\\n\\u00a0 \\nDifferentiation::SD::types::substitution_mapstd::map< SD::Expression, SD::Expression, internal::ExpressionKeyLess > substitution_mapDefinition symengine_types.h:59\\nDifferentiation::SD::make_substitution_maptypes::substitution_map make_substitution_map(const Expression &symbol, const Expression &value)Definition symengine_scalar_operations.cc:173\\nThe last step in the process is to convert all symbolic variables and operations into numerical values, and produce the numerical result of this operation. To do this we combine the substitution map with the symbolic variable in the step we have already mentioned above: \\\"substitution\\\".\\nOnce we pass this substitution map to the CAS, it will substitute each instance of the symbolic variable (or, more generally, sub-expression) with its numerical counterpart and then propagate these results up the operation tree, simplifying each node on the tree if possible. If the tree is reduced to a single value (i.e., we have substituted all of the independent variables with their numerical counterpart) then the evaluation is complete.\\nDue to the strongly-typed nature of C++, we need to instruct the CAS to convert its representation of the result into an intrinsic data type (in this case a double). This is the \\\"evaluation\\\" step, and through the template type we define the return type of this process. Conveniently, these two steps can be done at once if we are certain that we've performed a full substitution.\\n\\u00a0       const double computed_f =\\n\\u00a0         f_sd.substitute_and_evaluate<double>(substitution_map);\\n\\u00a0 \\n\\u00a0       AssertThrow(std::abs(f(x, y) - computed_f) < tol,\\n\\u00a0                   ExcMessage(std::string(\\\"Incorrect value computed for f. \\\") +\\n\\u00a0                              std::string(\\\"Hand-calculated value: \\\") +\\n\\u00a0                              Utilities::to_string(f(x, y)) +\\n\\u00a0                              std::string(\\\" ; \\\") +\\n\\u00a0                              std::string(\\\"Value computed by AD: \\\") +\\n\\u00a0                              Utilities::to_string(computed_f)));\\n\\u00a0 \\nWe can do the same for the first derivatives...\\n\\u00a0       const double computed_df_dx =\\n\\u00a0         df_dx_sd.substitute_and_evaluate<double>(substitution_map);\\n\\u00a0       const double computed_df_dy =\\n\\u00a0         df_dy_sd.substitute_and_evaluate<double>(substitution_map);\\n\\u00a0 \\n\\u00a0       AssertThrow(std::abs(df_dx(x, y) - computed_df_dx) < tol,\\n\\u00a0                   ExcMessage(\\n\\u00a0                     std::string(\\\"Incorrect value computed for df/dx. \\\") +\\n\\u00a0                     std::string(\\\"Hand-calculated value: \\\") +\\n\\u00a0                     Utilities::to_string(df_dx(x, y)) + std::string(\\\" ; \\\") +\\n\\u00a0                     std::string(\\\"Value computed by AD: \\\") +\\n\\u00a0                     Utilities::to_string(computed_df_dx)));\\n\\u00a0       AssertThrow(std::abs(df_dy(x, y) - computed_df_dy) < tol,\\n\\u00a0                   ExcMessage(\\n\\u00a0                     std::string(\\\"Incorrect value computed for df/dy. \\\") +\\n\\u00a0                     std::string(\\\"Hand-calculated value: \\\") +\\n\\u00a0                     Utilities::to_string(df_dy(x, y)) + std::string(\\\" ; \\\") +\\n\\u00a0                     std::string(\\\"Value computed by AD: \\\") +\\n\\u00a0                     Utilities::to_string(computed_df_dy)));\\n\\u00a0 \\n... and the second derivatives. Notice that we can reuse the same substitution map for each of these operations because we wish to evaluate all of these functions for the same values of x and y. Modifying the values in the substitution map renders the result of same symbolic expression evaluated with different values being assigned to the independent variables. We could also happily have each variable represent a real value in one pass, and a complex value in the next.\\n\\u00a0       const double computed_d2f_dx_dx =\\n\\u00a0         d2f_dx_dx_sd.substitute_and_evaluate<double>(substitution_map);\\n\\u00a0       const double computed_d2f_dx_dy =\\n\\u00a0         d2f_dx_dy_sd.substitute_and_evaluate<double>(substitution_map);\\n\\u00a0       const double computed_d2f_dy_dx =\\n\\u00a0         d2f_dy_dx_sd.substitute_and_evaluate<double>(substitution_map);\\n\\u00a0       const double computed_d2f_dy_dy =\\n\\u00a0         d2f_dy_dy_sd.substitute_and_evaluate<double>(substitution_map);\\n\\u00a0 \\n\\u00a0       AssertThrow(std::abs(d2f_dx_dx(x, y) - computed_d2f_dx_dx) < tol,\\n\\u00a0                   ExcMessage(\\n\\u00a0                     std::string(\\\"Incorrect value computed for d2f/dx_dx. \\\") +\\n\\u00a0                     std::string(\\\"Hand-calculated value: \\\") +\\n\\u00a0                     Utilities::to_string(d2f_dx_dx(x, y)) + std::string(\\\" ; \\\") +\\n\\u00a0                     std::string(\\\"Value computed by SD: \\\") +\\n\\u00a0                     Utilities::to_string(computed_d2f_dx_dx)));\\n\\u00a0       AssertThrow(std::abs(d2f_dx_dy(x, y) - computed_d2f_dx_dy) < tol,\\n\\u00a0                   ExcMessage(\\n\\u00a0                     std::string(\\\"Incorrect value computed for d2f/dx_dy. \\\") +\\n\\u00a0                     std::string(\\\"Hand-calculated value: \\\") +\\n\\u00a0                     Utilities::to_string(d2f_dx_dy(x, y)) + std::string(\\\" ; \\\") +\\n\\u00a0                     std::string(\\\"Value computed by SD: \\\") +\\n\\u00a0                     Utilities::to_string(computed_d2f_dx_dy)));\\n\\u00a0       AssertThrow(std::abs(d2f_dy_dx(x, y) - computed_d2f_dy_dx) < tol,\\n\\u00a0                   ExcMessage(\\n\\u00a0                     std::string(\\\"Incorrect value computed for d2f/dy_dx. \\\") +\\n\\u00a0                     std::string(\\\"Hand-calculated value: \\\") +\\n\\u00a0                     Utilities::to_string(d2f_dy_dx(x, y)) + std::string(\\\" ; \\\") +\\n\\u00a0                     std::string(\\\"Value computed by SD: \\\") +\\n\\u00a0                     Utilities::to_string(computed_d2f_dy_dx)));\\n\\u00a0       AssertThrow(std::abs(d2f_dy_dy(x, y) - computed_d2f_dy_dy) < tol,\\n\\u00a0                   ExcMessage(\\n\\u00a0                     std::string(\\\"Incorrect value computed for d2f/dy_dy. \\\") +\\n\\u00a0                     std::string(\\\"Hand-calculated value: \\\") +\\n\\u00a0                     Utilities::to_string(d2f_dy_dy(x, y)) + std::string(\\\" ; \\\") +\\n\\u00a0                     std::string(\\\"Value computed by SD: \\\") +\\n\\u00a0                     Utilities::to_string(computed_d2f_dy_dy)));\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n The SimpleExample::run() function\\nThe function used to drive these initial examples is straightforward. We'll arbitrarily choose some values at which to evaluate the function (although knowing that x = 0 is not permissible), and then pass these values to the functions that use the AD and SD frameworks.\\n\\u00a0     void run()\\n\\u00a0     {\\n\\u00a0       const double x = 1.23;\\n\\u00a0       const double y = 0.91;\\n\\u00a0 \\n\\u00a0       std::cout << \\\"Simple example using automatic differentiation...\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       run_and_verify_ad(x, y);\\n\\u00a0       std::cout << \\\"... all calculations are correct!\\\" << std::endl;\\n\\u00a0 \\n\\u00a0       std::cout << \\\"Simple example using symbolic differentiation.\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       run_and_verify_sd(x, y);\\n\\u00a0       std::cout << \\\"... all calculations are correct!\\\" << std::endl;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   } // namespace SimpleExample\\n\\u00a0 \\n\\u00a0 \\n A more complex example: Using automatic and symbolic differentiation to compute derivatives at continuum points\\nNow that we've introduced the principles behind automatic and symbolic differentiation, we'll put them into action by formulating two coupled magneto-mechanical constitutive laws: one that is rate-independent, and another that exhibits rate-dependent behavior.\\nAs you will recall from the introduction, the material constitutive laws we will consider are far more complicated than the simple example above. This is not just because of the form of the function \\\\(\\\\psi_{0}\\\\) that we will consider, but in particular because \\\\(\\\\psi_{0}\\\\) doesn't just depend on two scalar variables, but instead on a whole bunch of tensors, each with several components. In some cases, these are symmetric tensors, for which only a subset of components is in fact independent, and one has to think about what it actually means to compute a derivative such as \\\\(\\\\frac{\\\\partial\\\\psi_{0}}{\\\\partial \\\\mathbf{C}}\\\\) where  \\\\(\\\\mathbf\\n   C\\\\) is a symmetric tensor. How all of this will work will, hopefully, become clear below. It will also become clear that doing this by hand is going to be, at the very best, exceedingly tedious and, at worst, riddled with hard-to-find bugs.\\n\\u00a0   namespace CoupledConstitutiveLaws\\n\\u00a0   {\\n Constitutive parameters\\nWe start with a description of the various material parameters that appear in the description of the energy function \\\\(\\\\psi_{0}\\\\).\\nThe ConstitutiveParameters class is used to hold these values. Values for all parameters (both constitutive and rheological) are taken from [173], and are given values that produce a constitutive response that is broadly representative of a real, laboratory-made magneto-active polymer, though the specific values used here are of no consequence to the purpose of this program of course.\\nThe first four constitutive parameters respectively represent\\nthe elastic shear modulus \\\\(\\\\mu_{e}\\\\),\\nthe elastic shear modulus at magnetic saturation \\\\(\\\\mu_{e}^{\\\\infty}\\\\),\\nthe saturation magnetic field strength for the elastic shear modulus \\\\(h_{e}^{\\\\text{sat}}\\\\), and\\nthe Poisson ratio \\\\(\\\\nu\\\\).\\n\\n\\u00a0     class ConstitutiveParameters : public ParameterAcceptor\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       ConstitutiveParameters();\\n\\u00a0 \\n\\u00a0       double mu_e       = 30.0e3;\\n\\u00a0       double mu_e_inf   = 250.0e3;\\n\\u00a0       double mu_e_h_sat = 212.2e3;\\n\\u00a0       double nu_e       = 0.49;\\n\\u00a0 \\nParameterAcceptorDefinition parameter_acceptor.h:359\\nThe next four, which only pertain to the rate-dependent material, are parameters for\\nthe viscoelastic shear modulus \\\\(\\\\mu_{v}\\\\),\\nthe viscoelastic shear modulus at magnetic saturation \\\\(\\\\mu_{v}^{\\\\infty}\\\\),\\nthe saturation magnetic field strength for the viscoelastic shear modulus \\\\(h_{v}^{\\\\text{sat}}\\\\), and\\nthe characteristic relaxation time \\\\(\\\\tau\\\\).\\n\\n\\u00a0       double mu_v       = 20.0e3;\\n\\u00a0       double mu_v_inf   = 35.0e3;\\n\\u00a0       double mu_v_h_sat = 92.84e3;\\n\\u00a0       double tau_v      = 0.6;\\n\\u00a0 \\nThe last parameter is the relative magnetic permeability \\\\(\\\\mu_{r}\\\\).\\n\\u00a0       double mu_r = 6.0;\\n\\u00a0 \\n\\u00a0       bool initialized = false;\\n\\u00a0     };\\n\\u00a0 \\nThe parameters are initialized through the ParameterAcceptor framework, which is discussed in detail in step-60.\\n\\u00a0     ConstitutiveParameters::ConstitutiveParameters()\\n\\u00a0       : ParameterAcceptor(\\\"/Coupled Constitutive Laws/Constitutive Parameters/\\\")\\n\\u00a0     {\\n\\u00a0       add_parameter(\\\"Elastic shear modulus\\\", mu_e);\\n\\u00a0       add_parameter(\\\"Elastic shear modulus at magnetic saturation\\\", mu_e_inf);\\n\\u00a0       add_parameter(\\n\\u00a0         \\\"Saturation magnetic field strength for elastic shear modulus\\\",\\n\\u00a0         mu_e_h_sat);\\n\\u00a0       add_parameter(\\\"Poisson ratio\\\", nu_e);\\n\\u00a0 \\n\\u00a0       add_parameter(\\\"Viscoelastic shear modulus\\\", mu_v);\\n\\u00a0       add_parameter(\\\"Viscoelastic shear modulus at magnetic saturation\\\",\\n\\u00a0                     mu_v_inf);\\n\\u00a0       add_parameter(\\n\\u00a0         \\\"Saturation magnetic field strength for viscoelastic shear modulus\\\",\\n\\u00a0         mu_v_h_sat);\\n\\u00a0       add_parameter(\\\"Characteristic relaxation time\\\", tau_v);\\n\\u00a0 \\n\\u00a0       add_parameter(\\\"Relative magnetic permeability\\\", mu_r);\\n\\u00a0 \\n\\u00a0       parse_parameters_call_back.connect([&]() { initialized = true; });\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n Constitutive laws: Base class\\nSince we'll be formulating two constitutive laws for the same class of materials, it makes sense to define a base class that ensures a unified interface to them.\\nThe class declaration starts with the constructor that will accept the set of constitutive parameters that, in conjunction with the material law itself, dictate the material response.\\n\\u00a0     template <int dim>\\n\\u00a0     class Coupled_Magnetomechanical_Constitutive_Law_Base\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       Coupled_Magnetomechanical_Constitutive_Law_Base(\\n\\u00a0         const ConstitutiveParameters &constitutive_parameters);\\n\\u00a0 \\nInstead of computing and returning the kinetic variables or their linearization at will, we'll calculate and store these values within a single method. These cached results will then be returned upon request. We'll defer the precise explanation as to why we'd want to do this to a later stage. What is important for now is to see that this function accepts all of the field variables, namely the magnetic field vector \\\\(\\\\boldsymbol{\\\\mathbb{H}}\\\\) and right Cauchy-Green deformation tensor \\\\(\\\\mathbf{C}\\\\), as well as the time discretizer. These, in addition to the constitutive_parameters, are all the fundamental quantities that are required to compute the material response.\\n\\u00a0       virtual void update_internal_data(const SymmetricTensor<2, dim> &C,\\n\\u00a0                                         const Tensor<1, dim>          &H,\\n\\u00a0                                         const DiscreteTime &time) = 0;\\n\\u00a0 \\nDiscreteTimeDefinition discrete_time.h:233\\nSymmetricTensorDefinition symmetric_tensor.h:719\\nTensorDefinition tensor.h:471\\nThe next few functions provide the interface to probe the material response due subject to the applied deformation and magnetic loading.\\nSince the class of materials can be expressed in terms of a free energy \\\\(\\\\psi_{0}\\\\), we can compute that...\\n\\u00a0       virtual double get_psi() const = 0;\\n\\u00a0 \\n... as well as the two kinetic quantities:\\nthe magnetic induction vector \\\\(\\\\boldsymbol{\\\\mathbb{B}}\\\\), and\\nthe total Piola-Kirchhoff stress tensor \\\\(\\\\mathbf{S}^{\\\\text{tot}}\\\\)\\n\\n\\u00a0       virtual Tensor<1, dim> get_B() const = 0;\\n\\u00a0 \\n\\u00a0       virtual SymmetricTensor<2, dim> get_S() const = 0;\\n\\u00a0 \\n... and the linearization of the kinetic quantities, which are:\\nthe magnetostatic tangent tensor \\\\(\\\\mathbb{D}\\\\),\\nthe total referential magnetoelastic coupling tensor \\\\(\\\\mathfrak{P}^{\\\\text{tot}}\\\\), and\\nthe total referential elastic tangent tensor \\\\(\\\\mathcal{H}^{\\\\text{tot}}\\\\).\\n\\n\\u00a0       virtual SymmetricTensor<2, dim> get_DD() const = 0;\\n\\u00a0 \\n\\u00a0       virtual Tensor<3, dim> get_PP() const = 0;\\n\\u00a0 \\n\\u00a0       virtual SymmetricTensor<4, dim> get_HH() const = 0;\\n\\u00a0 \\nWe'll also define a method that provides a mechanism for this class instance to do any additional tasks before moving on to the next timestep. Again, the reason for doing this will become clear a little later.\\n\\u00a0       virtual void update_end_of_timestep()\\n\\u00a0       {}\\n\\u00a0 \\nIn the protected part of the class, we store a reference to an instance of the constitutive parameters that govern the material response. For convenience, we also define some functions that return various constitutive parameters (both explicitly defined, as well as calculated).\\nThe parameters related to the elastic response of the material are, in order:\\nthe elastic shear modulus,\\nthe elastic shear modulus at saturation magnetic field,\\nthe saturation magnetic field strength for the elastic shear modulus,\\nthe Poisson ratio,\\nthe Lam\\u00e9 parameter, and\\nthe bulk modulus.\\n\\n\\u00a0     protected:\\n\\u00a0       const ConstitutiveParameters &constitutive_parameters;\\n\\u00a0 \\n\\u00a0       double get_mu_e() const;\\n\\u00a0 \\n\\u00a0       double get_mu_e_inf() const;\\n\\u00a0 \\n\\u00a0       double get_mu_e_h_sat() const;\\n\\u00a0 \\n\\u00a0       double get_nu_e() const;\\n\\u00a0 \\n\\u00a0       double get_lambda_e() const;\\n\\u00a0 \\n\\u00a0       double get_kappa_e() const;\\n\\u00a0 \\nThe parameters related to the elastic response of the material are, in order:\\nthe viscoelastic shear modulus,\\nthe viscoelastic shear modulus at magnetic saturation,\\nthe saturation magnetic field strength for the viscoelastic shear modulus, and\\nthe characteristic relaxation time.\\n\\n\\u00a0       double get_mu_v() const;\\n\\u00a0 \\n\\u00a0       double get_mu_v_inf() const;\\n\\u00a0 \\n\\u00a0       double get_mu_v_h_sat() const;\\n\\u00a0 \\n\\u00a0       double get_tau_v() const;\\n\\u00a0 \\nThe parameters related to the magnetic response of the material are, in order:\\nthe relative magnetic permeability, and\\nthe magnetic permeability constant \\\\(\\\\mu_{0}\\\\) (not really a material constant, but rather a universal constant that we'll group here for simplicity).\\n\\nWe'll also implement a function that returns the timestep size from the time discretizion.\\n\\u00a0       double get_mu_r() const;\\n\\u00a0 \\n\\u00a0       constexpr double get_mu_0() const;\\n\\u00a0       double           get_delta_t(const DiscreteTime &time) const;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nIn the following, let us start by implementing the several relatively trivial member functions of the class just defined:\\n\\u00a0     template <int dim>\\n\\u00a0     Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::\\n\\u00a0       Coupled_Magnetomechanical_Constitutive_Law_Base(\\n\\u00a0         const ConstitutiveParameters &constitutive_parameters)\\n\\u00a0       : constitutive_parameters(constitutive_parameters)\\n\\u00a0     {\\n\\u00a0       Assert(get_kappa_e() > 0, ExcInternalError());\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double\\n\\u00a0     Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_e() const\\n\\u00a0     {\\n\\u00a0       return constitutive_parameters.mu_e;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double\\n\\u00a0     Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_e_inf() const\\n\\u00a0     {\\n\\u00a0       return constitutive_parameters.mu_e_inf;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double\\n\\u00a0     Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_e_h_sat() const\\n\\u00a0     {\\n\\u00a0       return constitutive_parameters.mu_e_h_sat;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double\\n\\u00a0     Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_nu_e() const\\n\\u00a0     {\\n\\u00a0       return constitutive_parameters.nu_e;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double\\n\\u00a0     Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_lambda_e() const\\n\\u00a0     {\\n\\u00a0       return 2.0 * get_mu_e() * get_nu_e() / (1.0 - 2.0 * get_nu_e());\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double\\n\\u00a0     Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_kappa_e() const\\n\\u00a0     {\\n\\u00a0       return (2.0 * get_mu_e() * (1.0 + get_nu_e())) /\\n\\u00a0              (3.0 * (1.0 - 2.0 * get_nu_e()));\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double\\n\\u00a0     Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_v() const\\n\\u00a0     {\\n\\u00a0       return constitutive_parameters.mu_v;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double\\n\\u00a0     Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_v_inf() const\\n\\u00a0     {\\n\\u00a0       return constitutive_parameters.mu_v_inf;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double\\n\\u00a0     Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_v_h_sat() const\\n\\u00a0     {\\n\\u00a0       return constitutive_parameters.mu_v_h_sat;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double\\n\\u00a0     Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_tau_v() const\\n\\u00a0     {\\n\\u00a0       return constitutive_parameters.tau_v;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double\\n\\u00a0     Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_r() const\\n\\u00a0     {\\n\\u00a0       return constitutive_parameters.mu_r;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     constexpr double\\n\\u00a0     Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_0() const\\n\\u00a0     {\\n\\u00a0       return 4.0 * numbers::PI * 1e-7;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_delta_t(\\n\\u00a0       const DiscreteTime &time) const\\n\\u00a0     {\\n\\u00a0       return time.get_previous_step_size();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\nPhysics::Elasticity::Kinematics::eSymmetricTensor< 2, dim, Number > e(const Tensor< 2, dim, Number > &F)\\nnumbers::PIstatic constexpr double PIDefinition numbers.h:259\\n Magnetoelastic constitutive law (using automatic differentiation)\\nWe'll begin by considering a non-dissipative material, namely one that is governed by a magneto-hyperelastic constitutive law that exhibits stiffening when immersed in a magnetic field. As described in the introduction, the stored energy density function for such a material might be given by          \\n\\\\[\\n   \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   = \\\\frac{1}{2} \\\\mu_{e} f_{\\\\mu_{e}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   \\\\left[ \\\\text{tr}(\\\\mathbf{C}) - d - 2 \\\\ln (\\\\text{det}(\\\\mathbf{F}))\\n   \\\\right]\\n   + \\\\lambda_{e} \\\\ln^{2} \\\\left(\\\\text{det}(\\\\mathbf{F}) \\\\right)\\n   - \\\\frac{1}{2} \\\\mu_{0} \\\\mu_{r} \\\\text{det}(\\\\mathbf{F})\\n   \\\\left[ \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right]\\n   \\\\]\\n\\n with       \\n\\\\[\\n   f_{\\\\mu_{e}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   = 1 + \\\\left[ \\\\frac{\\\\mu_{e}^{\\\\infty}}{\\\\mu_{e}} - 1 \\\\right]\\n   \\\\tanh \\\\left( 2 \\\\frac{\\\\boldsymbol{\\\\mathbb{H}} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}}}\\n   {\\\\left(h_{e}^{\\\\text{sat}}\\\\right)^{2}} \\\\right) .\\n   \\\\]\\n\\nNow on to the class that implements this behavior. Since we expect that this class fully describes a single material, we'll mark it as \\\"final\\\" so that the inheritance tree terminated here. At the top of the class, we define the helper type that we will use in the AD computations for our scalar energy density function. Note that we expect it to return values of type double. We also have to specify the number of spatial dimensions, dim, so that the link between vector, tensor and symmetric tensor fields and the number of components that they contain may be established. The concrete ADTypeCode used for the ADHelper class will be provided as a template argument at the point where this class is actually used.\\n\\u00a0     template <int dim, Differentiation::AD::NumberTypes ADTypeCode>\\n\\u00a0     class Magnetoelastic_Constitutive_Law_AD final\\n\\u00a0       : public Coupled_Magnetomechanical_Constitutive_Law_Base<dim>\\n\\u00a0     {\\n\\u00a0       using ADHelper =\\n\\u00a0         Differentiation::AD::ScalarFunction<dim, ADTypeCode, double>;\\n\\u00a0       using ADNumberType = typename ADHelper::ad_type;\\n\\u00a0 \\n\\u00a0     public:\\n\\u00a0       Magnetoelastic_Constitutive_Law_AD(\\n\\u00a0         const ConstitutiveParameters &constitutive_parameters);\\n\\u00a0 \\nSince the public interface to the base class is pure-virtual, here we'll declare that this class will override all of these base class methods.\\n\\u00a0       virtual void update_internal_data(const SymmetricTensor<2, dim> &C,\\n\\u00a0                                         const Tensor<1, dim>          &H,\\n\\u00a0                                         const DiscreteTime &) override;\\n\\u00a0 \\n\\u00a0       virtual double get_psi() const override;\\n\\u00a0 \\n\\u00a0       virtual Tensor<1, dim> get_B() const override;\\n\\u00a0 \\n\\u00a0       virtual SymmetricTensor<2, dim> get_S() const override;\\n\\u00a0 \\n\\u00a0       virtual SymmetricTensor<2, dim> get_DD() const override;\\n\\u00a0 \\n\\u00a0       virtual Tensor<3, dim> get_PP() const override;\\n\\u00a0 \\n\\u00a0       virtual SymmetricTensor<4, dim> get_HH() const override;\\n\\u00a0 \\nIn the private part of the class, we need to define some extractors that will help us set independent variables and later get the computed values related to the dependent variables. If this class were to be used in the context of a finite element problem, then each of these extractors is (most likely) related to the gradient of a component of the solution field (in this case, displacement and magnetic scalar potential). As you can probably infer by now, here \\\"C\\\" denotes the right Cauchy-Green tensor and \\\"H\\\" denotes the magnetic field vector.\\n\\u00a0     private:\\n\\u00a0       const FEValuesExtractors::Vector             H_components;\\n\\u00a0       const FEValuesExtractors::SymmetricTensor<2> C_components;\\n\\u00a0 \\nFEValuesExtractors::SymmetricTensorDefinition fe_values_extractors.h:197\\nFEValuesExtractors::VectorDefinition fe_values_extractors.h:150\\nThis is an instance of the automatic differentiation helper that we'll set up to do all of the differential calculations related to the constitutive law...\\n\\u00a0       ADHelper ad_helper;\\n\\u00a0 \\n... and the following three member variables will store the output from the ad_helper. The ad_helper returns the derivatives with respect to all field variables at once, so we'll retain the full gradient vector and Hessian matrix. From that, we'll extract the individual entries that we're actually interested in.\\n\\u00a0       double             psi;\\n\\u00a0       Vector<double>     Dpsi;\\n\\u00a0       FullMatrix<double> D2psi;\\n\\u00a0     };\\n\\u00a0 \\nWhen setting up the field component extractors, it is completely arbitrary as to how they are ordered. But it is important that the extractors do not have overlapping indices. The total number of components of these extractors defines the number of independent variables that the ad_helper needs to track, and with respect to which we'll be taking derivatives. The resulting data structures Dpsi and D2psi must also be sized accordingly. Once the ad_helper is configured (its input argument being the total number of components of \\\\(\\\\mathbf{C}\\\\) and \\\\(\\\\boldsymbol{\\\\mathbb{H}}\\\\)), we can directly interrogate it as to how many independent variables it uses.\\n\\u00a0     template <int dim, Differentiation::AD::NumberTypes ADTypeCode>\\n\\u00a0     Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::\\n\\u00a0       Magnetoelastic_Constitutive_Law_AD(\\n\\u00a0         const ConstitutiveParameters &constitutive_parameters)\\n\\u00a0       : Coupled_Magnetomechanical_Constitutive_Law_Base<dim>(\\n\\u00a0           constitutive_parameters)\\n\\u00a0       , H_components(0)\\n\\u00a0       , C_components(Tensor<1, dim>::n_independent_components)\\n\\u00a0       , ad_helper(Tensor<1, dim>::n_independent_components +\\n\\u00a0                   SymmetricTensor<2, dim>::n_independent_components)\\n\\u00a0       , psi(0.0)\\n\\u00a0       , Dpsi(ad_helper.n_independent_variables())\\n\\u00a0       , D2psi(ad_helper.n_independent_variables(),\\n\\u00a0               ad_helper.n_independent_variables())\\n\\u00a0     {}\\n\\u00a0 \\nAs stated before, due to the way that the automatic differentiation libraries work, the ad_helper will always returns the derivatives of the energy density function with respect to all field variables simultaneously. For this reason, it does not make sense to compute the derivatives in the functions get_B(), get_S(), etc. because we'd be doing a lot of extra computations that are then simply discarded. So, the best way to deal with that is to have a single function call that does all of the calculations up-front, and then we extract the stored data as its needed. That's what we'll do in the update_internal_data() method. As the material is rate-independent, we can ignore the DiscreteTime argument.\\n\\u00a0     template <int dim, Differentiation::AD::NumberTypes ADTypeCode>\\n\\u00a0     void\\n\\u00a0     Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::update_internal_data(\\n\\u00a0       const SymmetricTensor<2, dim> &C,\\n\\u00a0       const Tensor<1, dim>          &H,\\n\\u00a0       const DiscreteTime &)\\n\\u00a0     {\\n\\u00a0       Assert(determinant(C) > 0, ExcInternalError());\\n\\u00a0 \\ndeterminantDEAL_II_HOST constexpr Number determinant(const SymmetricTensor< 2, dim, Number > &)Definition symmetric_tensor.h:2724\\nSince we reuse the ad_helper data structure at each time step, we need to clear it of all stale information before use.\\n\\u00a0       ad_helper.reset();\\n\\u00a0 \\nThe next step is to set the values for all field components. These define the \\\"point\\\" around which we'll be computing the function gradients and their linearization. The extractors that we created before provide the association between the fields and the registry within the ad_helper \\u2013 they'll be used repeatedly to ensure that we have the correct interpretation of which variable corresponds to which component of H or C.\\n\\u00a0       ad_helper.register_independent_variable(H, H_components);\\n\\u00a0       ad_helper.register_independent_variable(C, C_components);\\n\\u00a0 \\nNow that we've done the initial setup, we can retrieve the AD counterparts of our fields. These are truly the independent variables for the energy function, and are \\\"sensitive\\\" to the calculations that are performed with them. Notice that the AD number are treated as a special number type, and can be used in many templated classes (in this example, as the scalar type for the Tensor and SymmetricTensor class).\\n\\u00a0       const Tensor<1, dim, ADNumberType> H_ad =\\n\\u00a0         ad_helper.get_sensitive_variables(H_components);\\n\\u00a0       const SymmetricTensor<2, dim, ADNumberType> C_ad =\\n\\u00a0         ad_helper.get_sensitive_variables(C_components);\\n\\u00a0 \\nWe can also use them in many functions that are templated on the scalar type. So, for these intermediate values that we require, we can perform tensor operations and some mathematical functions. The resulting type will also be an automatically differentiable number, which encodes the operations performed in these functions.\\n\\u00a0       const ADNumberType det_F_ad = std::sqrt(determinant(C_ad));\\n\\u00a0       const SymmetricTensor<2, dim, ADNumberType> C_inv_ad = invert(C_ad);\\n\\u00a0       AssertThrow(det_F_ad > ADNumberType(0.0),\\n\\u00a0                   ExcMessage(\\\"Volumetric Jacobian must be positive.\\\"));\\n\\u00a0 \\nstd::sqrt::VectorizedArray< Number, width > sqrt(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6869\\ninvertDEAL_II_HOST constexpr SymmetricTensor< 2, dim, Number > invert(const SymmetricTensor< 2, dim, Number > &)Definition symmetric_tensor.h:3250\\nNext we'll compute the scaling function that will cause the shear modulus to change (increase) under the influence of a magnetic field...\\n\\u00a0       const ADNumberType f_mu_e_ad =\\n\\u00a0         1.0 + (this->get_mu_e_inf() / this->get_mu_e() - 1.0) *\\n\\u00a0                 std::tanh((2.0 * H_ad * H_ad) /\\n\\u00a0                           (this->get_mu_e_h_sat() * this->get_mu_e_h_sat()));\\n\\u00a0 \\nstd::tanhinline ::VectorizedArray< Number, width > tanh(const ::VectorizedArray< Number, width > &x)Definition vectorization.h:6749\\n... and then we can define the material stored energy density function. We'll see later that this example is sufficiently complex to warrant the use of AD to, at the very least, verify an unassisted implementation.\\n\\u00a0       const ADNumberType psi_ad =\\n\\u00a0         0.5 * this->get_mu_e() * f_mu_e_ad *\\n\\u00a0           (trace(C_ad) - dim - 2.0 * std::log(det_F_ad))                 \\n\\u00a0         + this->get_lambda_e() * std::log(det_F_ad) * std::log(det_F_ad) \\n\\u00a0         - 0.5 * this->get_mu_0() * this->get_mu_r() * det_F_ad *\\n\\u00a0             (H_ad * C_inv_ad * H_ad); \\n\\u00a0 \\nstd::log::VectorizedArray< Number, width > log(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6849\\ntraceDEAL_II_HOST constexpr Number trace(const SymmetricTensor< 2, dim2, Number > &)\\nThe stored energy density function is, in fact, the dependent variable for this problem, so as a final step in the \\\"configuration\\\" phase, we register its definition with the ad_helper.\\n\\u00a0       ad_helper.register_dependent_variable(psi_ad);\\n\\u00a0 \\nFinally, we can retrieve the resulting value of the stored energy density function, as well as its gradient and Hessian with respect to the input fields, and cache them.\\n\\u00a0       psi = ad_helper.compute_value();\\n\\u00a0       ad_helper.compute_gradient(Dpsi);\\n\\u00a0       ad_helper.compute_hessian(D2psi);\\n\\u00a0     }\\n\\u00a0 \\nThe following few functions then allow for querying the so-stored value of \\\\(\\\\psi_{0}\\\\), and to extract the desired components of the gradient vector and Hessian matrix. We again make use of the extractors to express which parts of the total gradient vector and Hessian matrix we wish to retrieve. They only return the derivatives of the energy function, so for our definitions of the kinetic variables and their linearization a few more manipulations are required to form the desired result.\\n\\u00a0     template <int dim, Differentiation::AD::NumberTypes ADTypeCode>\\n\\u00a0     double Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_psi() const\\n\\u00a0     {\\n\\u00a0       return psi;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim, Differentiation::AD::NumberTypes ADTypeCode>\\n\\u00a0     Tensor<1, dim>\\n\\u00a0     Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_B() const\\n\\u00a0     {\\n\\u00a0       const Tensor<1, dim> dpsi_dH =\\n\\u00a0         ad_helper.extract_gradient_component(Dpsi, H_components);\\n\\u00a0       return -dpsi_dH;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim, Differentiation::AD::NumberTypes ADTypeCode>\\n\\u00a0     SymmetricTensor<2, dim>\\n\\u00a0     Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_S() const\\n\\u00a0     {\\n\\u00a0       const SymmetricTensor<2, dim> dpsi_dC =\\n\\u00a0         ad_helper.extract_gradient_component(Dpsi, C_components);\\n\\u00a0       return 2.0 * dpsi_dC;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim, Differentiation::AD::NumberTypes ADTypeCode>\\n\\u00a0     SymmetricTensor<2, dim>\\n\\u00a0     Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_DD() const\\n\\u00a0     {\\n\\u00a0       const Tensor<2, dim> dpsi_dH_dH =\\n\\u00a0         ad_helper.extract_hessian_component(D2psi, H_components, H_components);\\n\\u00a0       return -symmetrize(dpsi_dH_dH);\\n\\u00a0     }\\n\\u00a0 \\nsymmetrizeDEAL_II_HOST constexpr SymmetricTensor< 2, dim, Number > symmetrize(const Tensor< 2, dim, Number > &t)Definition symmetric_tensor.h:3534\\nNote that for coupled terms the order of the extractor arguments is especially important, as it dictates the order in which the directional derivatives are taken. So, if we'd reversed the order of the extractors in the call to extract_hessian_component() then we'd actually have been retrieving part of  \\\\(\\\\left[ \\\\mathfrak{P}^{\\\\text{tot}}\\n   \\\\right]^{T}\\\\).\\n\\u00a0     template <int dim, Differentiation::AD::NumberTypes ADTypeCode>\\n\\u00a0     Tensor<3, dim>\\n\\u00a0     Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_PP() const\\n\\u00a0     {\\n\\u00a0       const Tensor<3, dim> dpsi_dC_dH =\\n\\u00a0         ad_helper.extract_hessian_component(D2psi, C_components, H_components);\\n\\u00a0       return -2.0 * dpsi_dC_dH;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim, Differentiation::AD::NumberTypes ADTypeCode>\\n\\u00a0     SymmetricTensor<4, dim>\\n\\u00a0     Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_HH() const\\n\\u00a0     {\\n\\u00a0       const SymmetricTensor<4, dim> dpsi_dC_dC =\\n\\u00a0         ad_helper.extract_hessian_component(D2psi, C_components, C_components);\\n\\u00a0       return 4.0 * dpsi_dC_dC;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n Magneto-viscoelastic constitutive law (using symbolic algebra and differentiation)\\nThe second material law that we'll consider will be one that represents a magneto-viscoelastic material with a single dissipative mechanism. We'll consider the free energy density function for such a material to be defined as                        \\n\\\\begin{align*}\\n   \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v}, \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)\\n   &= \\\\psi_{0}^{ME} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   + \\\\psi_{0}^{MVE} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   \\\\\\\\ \\\\psi_{0}^{ME} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   &= \\\\frac{1}{2} \\\\mu_{e} f_{\\\\mu_{e}^{ME}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)\\n   \\\\left[ \\\\text{tr}(\\\\mathbf{C}) - d - 2 \\\\ln (\\\\text{det}(\\\\mathbf{F}))\\n   \\\\right]\\n   + \\\\lambda_{e} \\\\ln^{2} \\\\left(\\\\text{det}(\\\\mathbf{F}) \\\\right)\\n   - \\\\frac{1}{2} \\\\mu_{0} \\\\mu_{r} \\\\text{det}(\\\\mathbf{F})\\n   \\\\left[ \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right]\\n   \\\\\\\\ \\\\psi_{0}^{MVE} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   &= \\\\frac{1}{2} \\\\mu_{v} f_{\\\\mu_{v}^{MVE}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)\\n   \\\\left[ \\\\mathbf{C}_{v} : \\\\left[\\n   \\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{-\\\\frac{2}{d}}\\n   \\\\mathbf{C} \\\\right] - d - \\\\ln\\\\left(\\n   \\\\text{det}\\\\left(\\\\mathbf{C}_{v}\\\\right) \\\\right)  \\\\right]\\n   \\\\end{align*}\\n\\n with       \\n\\\\[\\n   f_{\\\\mu_{e}}^{ME} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   = 1 + \\\\left[ \\\\frac{\\\\mu_{e}^{\\\\infty}}{\\\\mu_{e}} - 1 \\\\right]\\n   \\\\tanh \\\\left( 2 \\\\frac{\\\\boldsymbol{\\\\mathbb{H}} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}}}\\n   {\\\\left(h_{e}^{\\\\text{sat}}\\\\right)^{2}} \\\\right)\\n   \\\\]\\n\\n\\n\\\\[\\n   f_{\\\\mu_{v}}^{MVE} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   = 1 + \\\\left[ \\\\frac{\\\\mu_{v}^{\\\\infty}}{\\\\mu_{v}} - 1 \\\\right]\\n   \\\\tanh \\\\left( 2 \\\\frac{\\\\boldsymbol{\\\\mathbb{H}} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}}}\\n   {\\\\left(h_{v}^{\\\\text{sat}}\\\\right)^{2}} \\\\right),\\n   \\\\]\\n\\n in conjunction with the evolution law for the internal viscous variable         \\n\\\\[\\n   \\\\mathbf{C}_{v}^{(t)}\\n   = \\\\frac{1}{1 + \\\\frac{\\\\Delta t}{\\\\tau_{v}}} \\\\left[\\n   \\\\mathbf{C}_{v}^{(t-1)}\\n   + \\\\frac{\\\\Delta t}{\\\\tau_{v}}\\n   \\\\left[\\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{-\\\\frac{2}{d}}\\n   \\\\mathbf{C} \\\\right]^{-1}\\n   \\\\right]\\n   \\\\]\\n\\n that was discretized using a first-order backward difference approximation.\\nAgain, let us see how this is implemented in a concrete class. Instead of the AD framework used in the previous class, we will now utilize the SD approach. To support this, the class constructor accepts not only the constitutive_parameters, but also two additional variables that will be used to initialize a Differentiation::SD::BatchOptimizer. We'll give more context to this later.\\n\\u00a0     template <int dim>\\n\\u00a0     class Magnetoviscoelastic_Constitutive_Law_SD final\\n\\u00a0       : public Coupled_Magnetomechanical_Constitutive_Law_Base<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       Magnetoviscoelastic_Constitutive_Law_SD(\\n\\u00a0         const ConstitutiveParameters                &constitutive_parameters,\\n\\u00a0         const Differentiation::SD::OptimizerType     optimizer_type,\\n\\u00a0         const Differentiation::SD::OptimizationFlags optimization_flags);\\n\\u00a0 \\nDifferentiation::SD::OptimizerTypeOptimizerTypeDefinition symengine_optimizer.h:96\\nDifferentiation::SD::OptimizationFlagsOptimizationFlagsDefinition symengine_optimizer.h:142\\nLike for the automatic differentiation helper, the Differentiation::SD::BatchOptimizer will return a collection of results all at once. So, in order to do that just once, we'll utilize a similar approach to before and do all of the expensive calculations within the update_internal_data() function, and cache the results for layer extraction.\\n\\u00a0       virtual void update_internal_data(const SymmetricTensor<2, dim> &C,\\n\\u00a0                                         const Tensor<1, dim>          &H,\\n\\u00a0                                         const DiscreteTime &time) override;\\n\\u00a0 \\n\\u00a0       virtual double get_psi() const override;\\n\\u00a0 \\n\\u00a0       virtual Tensor<1, dim> get_B() const override;\\n\\u00a0 \\n\\u00a0       virtual SymmetricTensor<2, dim> get_S() const override;\\n\\u00a0 \\n\\u00a0       virtual SymmetricTensor<2, dim> get_DD() const override;\\n\\u00a0 \\n\\u00a0       virtual Tensor<3, dim> get_PP() const override;\\n\\u00a0 \\n\\u00a0       virtual SymmetricTensor<4, dim> get_HH() const override;\\n\\u00a0 \\nSince we're dealing with a rate dependent material, we'll have to update the history variable at the appropriate time. That will be the purpose of this function.\\n\\u00a0       virtual void update_end_of_timestep() override;\\n\\u00a0 \\nIn the private part of the class, we will want to keep track of the internal viscous deformation, so the following two (real-valued, non-symbolic) member variables respectively hold\\nthe value of internal variable time step (and, if embedded within a nonlinear solver framework, Newton step), and\\nthe value of internal variable at the previous timestep.\\n\\n(We've labeled these variables \\\"Q\\\" so that they're easy to identify; in a sea of calculations it is not necessarily easy to distinguish Cv or C_v from C.)\\n\\u00a0     private:\\n\\u00a0       SymmetricTensor<2, dim> Q_t;\\n\\u00a0       SymmetricTensor<2, dim> Q_t1;\\n\\u00a0 \\nAs we'll be using symbolic types, we'll need to define some symbolic variables to use with the framework. (They are all suffixed with \\\"SD\\\" to make it easy to distinguish the symbolic types or expressions from real-valued types or scalars.) This can be done once up front (potentially even as static variables) to minimize the overhead associated with creating these variables. For the ultimate in generic programming, we can even describe the constitutive parameters symbolically, potentially allowing a single class instance to be reused with different inputs for these values too.\\nThese are the symbolic scalars that represent the elastic, viscous, and magnetic material parameters (defined mostly in the same order as they appear in the ConstitutiveParameters class). We also store a symbolic expression, delta_t_sd, that represents the time step size):\\n\\u00a0       const Differentiation::SD::Expression mu_e_sd;\\n\\u00a0       const Differentiation::SD::Expression mu_e_inf_sd;\\n\\u00a0       const Differentiation::SD::Expression mu_e_h_sat_sd;\\n\\u00a0       const Differentiation::SD::Expression lambda_e_sd;\\n\\u00a0       const Differentiation::SD::Expression mu_v_sd;\\n\\u00a0       const Differentiation::SD::Expression mu_v_inf_sd;\\n\\u00a0       const Differentiation::SD::Expression mu_v_h_sat_sd;\\n\\u00a0       const Differentiation::SD::Expression tau_v_sd;\\n\\u00a0       const Differentiation::SD::Expression delta_t_sd;\\n\\u00a0       const Differentiation::SD::Expression mu_r_sd;\\n\\u00a0 \\nNext we define some tensorial symbolic variables that represent the independent field variables, upon which the energy density function is parameterized:\\n\\u00a0       const Tensor<1, dim, Differentiation::SD::Expression>          H_sd;\\n\\u00a0       const SymmetricTensor<2, dim, Differentiation::SD::Expression> C_sd;\\n\\u00a0 \\nAnd similarly we have the symbolic representation of the internal viscous variables (both its current value and its value at the previous timestep):\\n\\u00a0       const SymmetricTensor<2, dim, Differentiation::SD::Expression> Q_t_sd;\\n\\u00a0       const SymmetricTensor<2, dim, Differentiation::SD::Expression> Q_t1_sd;\\n\\u00a0 \\nWe should also store the definitions of the dependent expressions: Although we'll only compute them once, we require them to retrieve data from the optimizer that is declared below. Furthermore, when serializing a material class like this one (not done as a part of this tutorial) we'd either need to serialize these expressions as well or we'd need to reconstruct them upon reloading.\\n\\u00a0       Differentiation::SD::Expression                          psi_sd;\\n\\u00a0       Tensor<1, dim, Differentiation::SD::Expression>          B_sd;\\n\\u00a0       SymmetricTensor<2, dim, Differentiation::SD::Expression> S_sd;\\n\\u00a0       SymmetricTensor<2, dim, Differentiation::SD::Expression> BB_sd;\\n\\u00a0       Tensor<3, dim, Differentiation::SD::Expression>          PP_sd;\\n\\u00a0       SymmetricTensor<4, dim, Differentiation::SD::Expression> HH_sd;\\n\\u00a0 \\nThe next variable is then the optimizer that is used to evaluate the dependent functions. More specifically, it provides the possibility to accelerate the evaluation of the symbolic dependent expressions. This is a vital tool, because the native evaluation of lengthy expressions (using no method of acceleration, but rather direct evaluation directly of the symbolic expressions) can be very slow. The Differentiation::SD::BatchOptimizer class provides a mechanism by which to transform the symbolic expression tree into another code path that, for example, shares intermediate results between the various dependent expressions (meaning that these intermediate values only get calculated once per evaluation) and/or compiling the code using a just-in-time compiler (thereby retrieving near-native performance for the evaluation step).\\nPerforming this code transformation is very computationally expensive, so we store the optimizer so that it is done just once per class instance. This also further motivates the decision to make the constitutive parameters themselves symbolic. We could then reuse a single instance of this optimizer across several materials (with the same energy function, of course) and potentially multiple continuum points (if embedded within a finite element simulation).\\nAs specified by the template parameter, the numerical result will be of type double.\\n\\u00a0       Differentiation::SD::BatchOptimizer<double> optimizer;\\n\\u00a0 \\nDifferentiation::SD::BatchOptimizerDefinition symengine_optimizer.h:1434\\nDuring the evaluation phase, we must map the symbolic variables to their real-valued counterparts. The next method will provide this functionality.\\nThe final method of this class will configure the optimizer.\\n\\u00a0       Differentiation::SD::types::substitution_map\\n\\u00a0       make_substitution_map(const SymmetricTensor<2, dim> &C,\\n\\u00a0                             const Tensor<1, dim>          &H,\\n\\u00a0                             const double                   delta_t) const;\\n\\u00a0 \\n\\u00a0       void initialize_optimizer();\\n\\u00a0     };\\n\\u00a0 \\nAs the resting deformation state is one at which the material is considered to be completely relaxed, the internal viscous variables are initialized with the identity tensor, i.e. \\\\(\\\\mathbf{C}_{v} = \\\\mathbf{I}\\\\). The various symbolic variables representing the constitutive parameters, time step size, and field and internal variables all get a unique identifier. The optimizer is passed the two parameters that declare which optimization (acceleration) technique should be applied, as well as which additional steps should be taken by the CAS to help improve performance during evaluation.\\n\\u00a0     template <int dim>\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law_SD<dim>::\\n\\u00a0       Magnetoviscoelastic_Constitutive_Law_SD(\\n\\u00a0         const ConstitutiveParameters                &constitutive_parameters,\\n\\u00a0         const Differentiation::SD::OptimizerType     optimizer_type,\\n\\u00a0         const Differentiation::SD::OptimizationFlags optimization_flags)\\n\\u00a0       : Coupled_Magnetomechanical_Constitutive_Law_Base<dim>(\\n\\u00a0           constitutive_parameters)\\n\\u00a0       , Q_t(Physics::Elasticity::StandardTensors<dim>::I)\\n\\u00a0       , Q_t1(Physics::Elasticity::StandardTensors<dim>::I)\\n\\u00a0       , mu_e_sd(\\\"mu_e\\\")\\n\\u00a0       , mu_e_inf_sd(\\\"mu_e_inf\\\")\\n\\u00a0       , mu_e_h_sat_sd(\\\"mu_e_h_sat\\\")\\n\\u00a0       , lambda_e_sd(\\\"lambda_e\\\")\\n\\u00a0       , mu_v_sd(\\\"mu_v\\\")\\n\\u00a0       , mu_v_inf_sd(\\\"mu_v_inf\\\")\\n\\u00a0       , mu_v_h_sat_sd(\\\"mu_v_h_sat\\\")\\n\\u00a0       , tau_v_sd(\\\"tau_v\\\")\\n\\u00a0       , delta_t_sd(\\\"delta_t\\\")\\n\\u00a0       , mu_r_sd(\\\"mu_r\\\")\\n\\u00a0       , H_sd(Differentiation::SD::make_vector_of_symbols<dim>(\\\"H\\\"))\\n\\u00a0       , C_sd(Differentiation::SD::make_symmetric_tensor_of_symbols<2, dim>(\\\"C\\\"))\\n\\u00a0       , Q_t_sd(\\n\\u00a0           Differentiation::SD::make_symmetric_tensor_of_symbols<2, dim>(\\\"Q_t\\\"))\\n\\u00a0       , Q_t1_sd(\\n\\u00a0           Differentiation::SD::make_symmetric_tensor_of_symbols<2, dim>(\\\"Q_t1\\\"))\\n\\u00a0       , optimizer(optimizer_type, optimization_flags)\\n\\u00a0     {\\n\\u00a0       initialize_optimizer();\\n\\u00a0     }\\n\\u00a0 \\nDifferentiationDefinition numbers.h:645\\nPhysicsDefinition physics.h:28\\nThe substitution map simply pairs all of the following data together:\\nthe constitutive parameters (with values retrieved from the base class),\\nthe time step size (with its value retrieved from the time discretizer),\\nthe field values (with their values being prescribed by an external function that is calling into this Magnetoviscoelastic_Constitutive_Law_SD instance), and\\nthe current and previous internal viscous deformation (with their values stored within this class instance).\\n\\n\\u00a0     template <int dim>\\n\\u00a0     Differentiation::SD::types::substitution_map\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law_SD<dim>::make_substitution_map(\\n\\u00a0       const SymmetricTensor<2, dim> &C,\\n\\u00a0       const Tensor<1, dim>          &H,\\n\\u00a0       const double                   delta_t) const\\n\\u00a0     {\\n\\u00a0       return Differentiation::SD::make_substitution_map(\\n\\u00a0         std::make_pair(mu_e_sd, this->get_mu_e()),\\n\\u00a0         std::make_pair(mu_e_inf_sd, this->get_mu_e_inf()),\\n\\u00a0         std::make_pair(mu_e_h_sat_sd, this->get_mu_e_h_sat()),\\n\\u00a0         std::make_pair(lambda_e_sd, this->get_lambda_e()),\\n\\u00a0         std::make_pair(mu_v_sd, this->get_mu_v()),\\n\\u00a0         std::make_pair(mu_v_inf_sd, this->get_mu_v_inf()),\\n\\u00a0         std::make_pair(mu_v_h_sat_sd, this->get_mu_v_h_sat()),\\n\\u00a0         std::make_pair(tau_v_sd, this->get_tau_v()),\\n\\u00a0         std::make_pair(delta_t_sd, delta_t),\\n\\u00a0         std::make_pair(mu_r_sd, this->get_mu_r()),\\n\\u00a0         std::make_pair(H_sd, H),\\n\\u00a0         std::make_pair(C_sd, C),\\n\\u00a0         std::make_pair(Q_t_sd, Q_t),\\n\\u00a0         std::make_pair(Q_t1_sd, Q_t1));\\n\\u00a0     }\\n\\u00a0 \\nDue to the \\\"natural\\\" use of the symbolic expressions, much of the procedure to configure the optimizer looks very similar to that which is used to construct the automatic differentiation helper. Nevertheless, we'll detail these steps again to highlight the differences that underlie the two frameworks.\\nThe function starts with expressions that symbolically encode the determinant of the deformation gradient (as expressed in terms of the right Cauchy-Green deformation tensor, our primary field variable), as well as the inverse of \\\\(\\\\mathbf{C}\\\\) itself:\\n\\u00a0     template <int dim>\\n\\u00a0     void Magnetoviscoelastic_Constitutive_Law_SD<dim>::initialize_optimizer()\\n\\u00a0     {\\n\\u00a0       const Differentiation::SD::Expression det_F_sd =\\n\\u00a0         std::sqrt(determinant(C_sd));\\n\\u00a0       const SymmetricTensor<2, dim, Differentiation::SD::Expression> C_inv_sd =\\n\\u00a0         invert(C_sd);\\n\\u00a0 \\nNext is the symbolic representation of the saturation function for the elastic part of the free energy density function, followed by the magnetoelastic contribution to the free energy density function. This all has the same structure as we'd seen previously.\\n\\u00a0       const Differentiation::SD::Expression f_mu_e_sd =\\n\\u00a0         1.0 +\\n\\u00a0         (mu_e_inf_sd / mu_e_sd - 1.0) *\\n\\u00a0           std::tanh((2.0 * H_sd * H_sd) / (mu_e_h_sat_sd * mu_e_h_sat_sd));\\n\\u00a0 \\n\\u00a0       const Differentiation::SD::Expression psi_ME_sd =\\n\\u00a0         0.5 * mu_e_sd * f_mu_e_sd *\\n\\u00a0           (trace(C_sd) - dim - 2.0 * std::log(det_F_sd)) +\\n\\u00a0         lambda_e_sd * std::log(det_F_sd) * std::log(det_F_sd) -\\n\\u00a0         0.5 * this->get_mu_0() * mu_r_sd * det_F_sd * (H_sd * C_inv_sd * H_sd);\\n\\u00a0 \\nIn addition, we define the magneto-viscoelastic contribution to the free energy density function. The first component required to implement this is a scaling function that will cause the viscous shear modulus to change (increase) under the influence of a magnetic field (see [173], equation 29). Thereafter we can compute the dissipative component of the energy density function; its expression is stated in [173] (equation 28), which is a straight-forward extension of an energy density function formulated in [144] (equation 46).\\n\\u00a0       const Differentiation::SD::Expression f_mu_v_sd =\\n\\u00a0         1.0 +\\n\\u00a0         (mu_v_inf_sd / mu_v_sd - 1.0) *\\n\\u00a0           std::tanh((2.0 * H_sd * H_sd) / (mu_v_h_sat_sd * mu_v_h_sat_sd));\\n\\u00a0 \\n\\u00a0       const Differentiation::SD::Expression psi_MVE_sd =\\n\\u00a0         0.5 * mu_v_sd * f_mu_v_sd *\\n\\u00a0         (Q_t_sd * (std::pow(det_F_sd, -2.0 / dim) * C_sd) - dim -\\n\\u00a0          std::log(determinant(Q_t_sd)));\\n\\u00a0 \\nstd::pow::VectorizedArray< Number, width > pow(const ::VectorizedArray< Number, width > &, const Number p)Definition vectorization.h:6885\\nFrom these building blocks, we can then define the material's total free energy density function:\\n\\u00a0       psi_sd = psi_ME_sd + psi_MVE_sd;\\n\\u00a0 \\nAs it stands, to the CAS the variable Q_t_sd appears to be independent of C_sd. Our tensorial symbolic expression Q_t_sd just has an identifier associated with it, and there is nothing that links it to the other tensorial symbolic expression C_sd. So any derivatives taken with respect to C_sd will ignore this inherent dependence which, as we can see from the evolution law, is in fact \\\\(\\\\mathbf{C}_{v} = \\\\mathbf{C}_{v} \\\\left( \\\\mathbf{C}, t \\\\right)\\\\). This means that deriving any function \\\\(f = f(\\\\mathbf{C}, \\\\mathbf{Q})\\\\) with respect to \\\\(\\\\mathbf{C}\\\\) will return partial derivatives  \\\\(\\\\frac{\\\\partial f(\\\\mathbf{C}, \\\\mathbf{Q})}{\\\\partial \\\\mathbf{C}}\\n   \\\\Big\\\\vert_{\\\\mathbf{Q}}\\\\) as opposed to the total derivative      \\\\(\\\\frac{d f(\\\\mathbf{C}, \\\\mathbf{Q}(\\\\mathbf{C}))}{d \\\\mathbf{C}} =\\n   \\\\frac{\\\\partial f(\\\\mathbf{C}, \\\\mathbf{Q}(\\\\mathbf{C}))}{\\\\partial\\n   \\\\mathbf{C}} \\\\Big\\\\vert_{\\\\mathbf{Q}} + \\\\frac{\\\\partial f(\\\\mathbf{C},\\n   \\\\mathbf{Q}(\\\\mathbf{C}))}{\\\\partial \\\\mathbf{Q}}\\n   \\\\Big\\\\vert_{\\\\mathbf{C}} : \\\\frac{d \\\\mathbf{Q}(\\\\mathbf{C}))}{d\\n   \\\\mathbf{C}}\\\\).\\nBy contrast, with the current AD libraries the total derivative would always be returned. This implies that the computed kinetic variables would be incorrect for this class of material model, making AD the incorrect tool from which to derive (at the continuum point level) the constitutive law for this dissipative material from an energy density function.\\nIt is this specific level of control that characterizes a defining difference difference between the SD and AD frameworks. In a few lines we'll be manipulating the expression for the internal variable Q_t_sd such that it produces the correct linearization.\\nBut, first, we'll compute the symbolic expressions for the kinetic variables, i.e., the magnetic induction vector and the Piola-Kirchhoff stress tensor. The code that performs the differentiation quite closely mimics the definition stated in the theory.\\n\\u00a0       B_sd = -Differentiation::SD::differentiate(psi_sd, H_sd);\\n\\u00a0       S_sd = 2.0 * Differentiation::SD::differentiate(psi_sd, C_sd);\\n\\u00a0 \\nDifferentiation::SD::differentiateExpression differentiate(const Expression &f, const Expression &x)Definition symengine_scalar_operations.cc:69\\nSince the next step is to linearize the above, it is the appropriate time to inform the CAS of the explicit dependency of Q_t_sd on C_sd, i.e., state that  \\\\(\\\\mathbf{C}_{v} = \\\\mathbf{C}_{v} \\\\left( \\\\mathbf{C}, t\\n   \\\\right)\\\\). This means that all future differential operations made with respect to C_sd will take into account this dependence (i.e., compute total derivatives). In other words, we will transform some expression such that their intrinsic parameterization changes from \\\\(f(\\\\mathbf{C}, \\\\mathbf{Q})\\\\) to \\\\(f(\\\\mathbf{C}, \\\\mathbf{Q}(\\\\mathbf{C}))\\\\).\\nTo do this, we consider the time-discrete evolution law. From that, we have the explicit expression for the internal variable in terms of its history as well as the primary field variable. That is what it described in this expression:\\n\\u00a0       const SymmetricTensor<2, dim, Differentiation::SD::Expression>\\n\\u00a0         Q_t_sd_explicit =\\n\\u00a0           (1.0 / (1.0 + delta_t_sd / tau_v_sd)) *\\n\\u00a0           (Q_t1_sd +\\n\\u00a0            (delta_t_sd / tau_v_sd * std::pow(det_F_sd, 2.0 / dim) * C_inv_sd));\\n\\u00a0 \\nNext we produce an intermediate substitution map, which will take every instance of Q_t_sd (our identifier) found in an expression and replace it with the full expression held in Q_t_sd_explicit.\\n\\u00a0       const Differentiation::SD::types::substitution_map\\n\\u00a0         substitution_map_explicit = Differentiation::SD::make_substitution_map(\\n\\u00a0           std::make_pair(Q_t_sd, Q_t_sd_explicit));\\n\\u00a0 \\nWe can the perform this substitution on the two kinetic variables and immediately differentiate the result that appears after that substitution with the field variables. (If you'd like, this could be split up into two steps with the intermediate results stored in a temporary variable.) Again, if you overlook the \\\"complexity\\\" generated by the substitution, these calls that linearize the kinetic variables and produce the three tangent tensors quite closely resembles what's stated in the theory.\\n\\u00a0       BB_sd = symmetrize(Differentiation::SD::differentiate(\\n\\u00a0         Differentiation::SD::substitute(B_sd, substitution_map_explicit),\\n\\u00a0         H_sd));\\n\\u00a0       PP_sd = -Differentiation::SD::differentiate(\\n\\u00a0         Differentiation::SD::substitute(S_sd, substitution_map_explicit), H_sd);\\n\\u00a0       HH_sd =\\n\\u00a0         2.0 *\\n\\u00a0         Differentiation::SD::differentiate(\\n\\u00a0           Differentiation::SD::substitute(S_sd, substitution_map_explicit),\\n\\u00a0           C_sd);\\n\\u00a0 \\nDifferentiation::SD::substituteExpression substitute(const Expression &expression, const types::substitution_map &substitution_map)\\nNow we need to tell the optimizer what entries we need to provide numerical values for in order for it to successfully perform its calculations. These essentially act as the input arguments to all dependent functions that the optimizer must evaluate. They are, collectively, the independent variables for the problem, the history variables, the time step size and the constitutive parameters (since we've not hard encoded them in the energy density function).\\nSo what we really want is to provide it a collection of symbols, which one could accomplish in this way:  optimizer.register_symbols(Differentiation::SD::make_symbol_map(\\n  mu_e_sd, mu_e_inf_sd, mu_e_h_sat_sd, lambda_e_sd,\\n  mu_v_sd, mu_v_inf_sd, mu_v_h_sat_sd, tau_v_sd,\\n  delta_t_sd, mu_r_sd,\\n  H_sd, C_sd,\\n  Q_t_sd, Q_t1_sd));\\nDifferentiation::SD::make_symbol_maptypes::substitution_map make_symbol_map(const SymbolicType &symbol)\\n  But this is all actually already encoded as the keys of the substitution map. Doing the above would also mean that we need to manage the symbols in two places (here and when constructing the substitution map), which is annoying and a potential source of error if this material class is modified or extended. Since we're not interested in the values at this point, it is alright if the substitution map is filled with invalid data for the values associated with each key entry. So we'll simply create a fake substitution map, and extract the symbols from that. Note that any substitution map passed to the optimizer will have to, at the very least, contain entries for these symbols.\\n\\u00a0       optimizer.register_symbols(\\n\\u00a0         Differentiation::SD::Utilities::extract_symbols(\\n\\u00a0           make_substitution_map({}, {}, 0)));\\n\\u00a0 \\nDifferentiation::SD::Utilities::extract_symbolsSD::types::symbol_vector extract_symbols(const SD::types::substitution_map &substitution_values)\\nWe then inform the optimizer of what values we want calculated, which in our situation encompasses all of the dependent variables (namely the energy density function and its various derivatives).\\n\\u00a0       optimizer.register_functions(psi_sd, B_sd, S_sd, BB_sd, PP_sd, HH_sd);\\n\\u00a0 \\nThe last step is to finalize the optimizer. With this call it will determine an equivalent code path that will evaluate all of the dependent functions at once, but with less computational cost than when evaluating the symbolic expression directly. Note: This is an expensive call, so we want execute it as few times as possible. We've done it in the constructor of our class, which achieves the goal of being called only once per class instance.\\n\\u00a0       optimizer.optimize();\\n\\u00a0     }\\n\\u00a0 \\nSince the configuration of the optimizer was done up front, there's very little to do each time we want to compute kinetic variables or their linearization (derivatives).\\n\\u00a0     template <int dim>\\n\\u00a0     void Magnetoviscoelastic_Constitutive_Law_SD<dim>::update_internal_data(\\n\\u00a0       const SymmetricTensor<2, dim> &C,\\n\\u00a0       const Tensor<1, dim>          &H,\\n\\u00a0       const DiscreteTime            &time)\\n\\u00a0     {\\nTo update the internal history variable, we first need to compute a few fundamental quantities, which we've seen before. We can also ask the time discretizer for the time step size that was used to iterate from the previous time step to the current one.\\n\\u00a0       const double delta_t = this->get_delta_t(time);\\n\\u00a0 \\n\\u00a0       const double                  det_F = std::sqrt(determinant(C));\\n\\u00a0       const SymmetricTensor<2, dim> C_inv = invert(C);\\n\\u00a0       AssertThrow(det_F > 0.0,\\n\\u00a0                   ExcMessage(\\\"Volumetric Jacobian must be positive.\\\"));\\n\\u00a0 \\nNow we can update the (real valued) internal viscous deformation tensor, as per the definition given by the evolution law in conjunction with the chosen time discretization scheme.\\n\\u00a0       Q_t = (1.0 / (1.0 + delta_t / this->get_tau_v())) *\\n\\u00a0             (Q_t1 + (delta_t / this->get_tau_v()) * std::pow(det_F, 2.0 / dim) *\\n\\u00a0                       C_inv);\\n\\u00a0 \\nNext we pass the optimizer the numeric values that we wish the independent variables, time step size and (implicit to this call), the constitutive parameters to represent.\\n\\u00a0       const auto substitution_map = make_substitution_map(C, H, delta_t);\\n\\u00a0 \\nWhen making this next call, the call path used to (numerically) evaluate the dependent functions is quicker than dictionary substitution.\\n\\u00a0       optimizer.substitute(substitution_map);\\n\\u00a0     }\\n\\u00a0 \\nHaving called update_internal_data(), it is then valid to extract data from the optimizer. When doing the evaluation, we need the exact symbolic expressions of the data to extracted from the optimizer. The implication of this is that we needed to store the symbolic expressions of all dependent variables for the lifetime of the optimizer (naturally, the same is implied for the input variables).\\n\\u00a0     template <int dim>\\n\\u00a0     double Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_psi() const\\n\\u00a0     {\\n\\u00a0       return optimizer.evaluate(psi_sd);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     Tensor<1, dim> Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_B() const\\n\\u00a0     {\\n\\u00a0       return optimizer.evaluate(B_sd);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     SymmetricTensor<2, dim>\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_S() const\\n\\u00a0     {\\n\\u00a0       return optimizer.evaluate(S_sd);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     SymmetricTensor<2, dim>\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_DD() const\\n\\u00a0     {\\n\\u00a0       return optimizer.evaluate(BB_sd);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     Tensor<3, dim> Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_PP() const\\n\\u00a0     {\\n\\u00a0       return optimizer.evaluate(PP_sd);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     SymmetricTensor<4, dim>\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_HH() const\\n\\u00a0     {\\n\\u00a0       return optimizer.evaluate(HH_sd);\\n\\u00a0     }\\n\\u00a0 \\nWhen moving forward in time, the \\\"current\\\" state of the internal variable instantaneously defines the state at the \\\"previous\\\" timestep. As such, we record value of history variable for use as the \\\"past value\\\" at the next time step.\\n\\u00a0     template <int dim>\\n\\u00a0     void Magnetoviscoelastic_Constitutive_Law_SD<dim>::update_end_of_timestep()\\n\\u00a0     {\\n\\u00a0       Q_t1 = Q_t;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n A more complex example (continued): Parameters and hand-derived material classes\\nNow that we've seen how the AD and SD frameworks can make light(er) work of defining these constitutive laws, we'll implement the equivalent classes by hand for the purpose of verification and to do some preliminary benchmarking of the frameworks versus a native implementation.\\nAt the expense of the author's sanity, what is documented below (hopefully accurately) are the full definitions for the kinetic variables and their tangents, as well as some intermediate computations. Since the structure and design of the constitutive law classes has been outlined earlier, we'll gloss over it and simply delineate between the various stages of calculations in the update_internal_data() method definition. It should be easy enough to link the derivative calculations (with their moderately expressive variable names) to their documented definitions that appear in the class descriptions. We will, however, take the opportunity to present two different paradigms for implementing constitutive law classes. The second will provide more flexibility than the first (thereby making it more easily extensible, in the author's opinion) at the expense of some performance.\\n Magnetoelastic constitutive law (hand-derived)\\nFrom the stored energy that, as mentioned earlier, is defined as          \\n\\\\[\\n   \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   = \\\\frac{1}{2} \\\\mu_{e} f_{\\\\mu_{e}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   \\\\left[ \\\\text{tr}(\\\\mathbf{C}) - d - 2 \\\\ln (\\\\text{det}(\\\\mathbf{F}))\\n   \\\\right]\\n   + \\\\lambda_{e} \\\\ln^{2} \\\\left(\\\\text{det}(\\\\mathbf{F}) \\\\right)\\n   - \\\\frac{1}{2} \\\\mu_{0} \\\\mu_{r} \\\\text{det}(\\\\mathbf{F})\\n   \\\\left[ \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right]\\n   \\\\]\\n\\n with        \\n\\\\[\\n   f_{\\\\mu_{e}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   = 1 + \\\\left[ \\\\frac{\\\\mu_{e}^{\\\\infty}}{\\\\mu_{e}} - 1 \\\\right]\\n   \\\\tanh \\\\left( 2 \\\\frac{\\\\boldsymbol{\\\\mathbb{H}} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}}}\\n   {\\\\left(h_{e}^{\\\\text{sat}}\\\\right)^{2}} \\\\right) ,\\n   \\\\\\\\ \\\\text{det}(\\\\mathbf{F}) = \\\\sqrt{\\\\text{det}(\\\\mathbf{C})}\\n   \\\\]\\n\\n for this magnetoelastic material, the first derivatives that correspond to the magnetic induction vector and total Piola-Kirchhoff stress tensor are            \\n\\\\[\\n   \\\\boldsymbol{\\\\mathbb{B}} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)\\n   \\\\dealcoloneq - \\\\frac{d \\\\psi_{0}}{d \\\\boldsymbol{\\\\mathbb{H}}}\\n   = - \\\\frac{1}{2} \\\\mu_{e} \\\\left[ \\\\text{tr}(\\\\mathbf{C}) - d - 2 \\\\ln\\n   (\\\\text{det}(\\\\mathbf{F}))\\n   \\\\right] \\\\frac{d f_{\\\\mu_{e}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)}{d \\\\boldsymbol{\\\\mathbb{H}}}\\n   + \\\\mu_{0} \\\\mu_{r} \\\\text{det}(\\\\mathbf{F}) \\\\left[ \\\\mathbf{C}^{-1} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right]\\n   \\\\]\\n\\n\\n\\\\begin{align}\\n   \\\\mathbf{S}^{\\\\text{tot}} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)\\n   \\\\dealcoloneq 2 \\\\frac{d \\\\psi_{0} \\\\left( \\\\mathbf{C},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{d \\\\mathbf{C}}\\n   &= \\\\mu_{e} f_{\\\\mu_{e}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   \\\\left[ \\\\frac{d\\\\,\\\\text{tr}(\\\\mathbf{C})}{d \\\\mathbf{C}}\\n   - 2 \\\\frac{1}{\\\\text{det}(\\\\mathbf{F})}\\n   \\\\frac{d\\\\,\\\\text{det}(\\\\mathbf{F})}{d \\\\mathbf{C}} \\\\right]\\n   + 4 \\\\lambda_{e} \\\\ln \\\\left(\\\\text{det}(\\\\mathbf{F}) \\\\right)\\n   \\\\frac{1}{\\\\text{det}(\\\\mathbf{F})} \\\\frac{d\\\\,\\\\text{det}(\\\\mathbf{F})}{d\\n   \\\\mathbf{C}}\\n   - \\\\mu_{0} \\\\mu_{r} \\\\left[\\n   \\\\left[ \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right] \\\\frac{d\\\\,\\\\text{det}(\\\\mathbf{F})}{d\\n   \\\\mathbf{C}} + \\\\text{det}(\\\\mathbf{F}) \\\\frac{d \\\\left[\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right]}{d \\\\mathbf{C}} \\\\right]\\n   \\\\\\\\ &= \\\\mu_{e} f_{\\\\mu_{e}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   \\\\left[ \\\\mathbf{I} - \\\\mathbf{C}^{-1} \\\\right]\\n   + 2 \\\\lambda_{e} \\\\ln \\\\left(\\\\text{det}(\\\\mathbf{F}) \\\\right) \\\\mathbf{C}^{-1}\\n   - \\\\mu_{0} \\\\mu_{r} \\\\left[\\n   \\\\frac{1}{2}  \\\\left[ \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1}\\n   \\\\cdot \\\\boldsymbol{\\\\mathbb{H}} \\\\right] \\\\text{det}(\\\\mathbf{F})\\n   \\\\mathbf{C}^{-1}\\n   - \\\\text{det}(\\\\mathbf{F})\\n   \\\\left[ \\\\mathbf{C}^{-1} \\\\cdot \\\\boldsymbol{\\\\mathbb{H}} \\\\right] \\\\otimes\\n   \\\\left[ \\\\mathbf{C}^{-1} \\\\cdot \\\\boldsymbol{\\\\mathbb{H}} \\\\right]\\n   \\\\right]\\n   \\\\end{align}\\n\\n with          \\n\\\\[\\n   \\\\frac{d f_{\\\\mu_{e}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{d\\n   \\\\boldsymbol{\\\\mathbb{H}}}\\n   = \\\\left[ \\\\frac{\\\\mu_{e}^{\\\\infty}}{\\\\mu_{e}} - 1 \\\\right]\\n   \\\\text{sech}^{2} \\\\left( 2 \\\\frac{\\\\boldsymbol{\\\\mathbb{H}} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}}}\\n   {\\\\left(h_{e}^{\\\\text{sat}}\\\\right)^{2}} \\\\right)\\n   \\\\left[ \\\\frac{4} {\\\\left(h_{e}^{\\\\text{sat}}\\\\right)^{2}}\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right]\\n   \\\\]\\n\\n\\n\\\\[\\n   \\\\frac{d\\\\,\\\\text{tr}(\\\\mathbf{C})}{d \\\\mathbf{C}}\\n   = \\\\mathbf{I}\\n   \\\\quad \\\\text{(the second-order identity tensor)}\\n   \\\\]\\n\\n\\n\\\\[\\n   \\\\frac{d\\\\,\\\\text{det}(\\\\mathbf{F})}{d \\\\mathbf{C}}\\n   = \\\\frac{1}{2} \\\\text{det}(\\\\mathbf{F}) \\\\mathbf{C}^{-1}\\n   \\\\]\\n\\n\\n\\\\[\\n   \\\\frac{d C^{-1}_{ab}}{d C_{cd}}\\n   = - \\\\text{sym} \\\\left( C^{-1}_{ac} C^{-1}_{bd} \\\\right)\\n   = -\\\\frac{1}{2} \\\\left[ C^{-1}_{ac} C^{-1}_{bd} + C^{-1}_{ad} C^{-1}_{bc}\\n   \\\\right]\\n   \\\\]\\n\\n\\n\\\\[\\n   \\\\frac{d \\\\left[ \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right]}{d \\\\mathbf{C}}\\n   = - \\\\left[ \\\\mathbf{C}^{-1} \\\\cdot \\\\boldsymbol{\\\\mathbb{H}} \\\\right] \\\\otimes\\n   \\\\left[ \\\\mathbf{C}^{-1} \\\\cdot \\\\boldsymbol{\\\\mathbb{H}} \\\\right]\\n   \\\\]\\n\\n The use of the symmetry operator \\\\(\\\\text{sym} \\\\left( \\\\bullet \\\\right)\\\\) in the one derivation above helps to ensure that the resulting rank-4 tensor, which holds minor symmetries due to the symmetry of \\\\(\\\\mathbf{C}\\\\), still maps rank-2 symmetric tensors to rank-2 symmetric tensors. See the SymmetricTensor class documentation and the introduction to step-44 and for further explanation as to what symmetry means in the context of fourth-order tensors.\\nThe linearization of each of the kinematic variables with respect to their arguments are         \\n\\\\[\\n   \\\\mathbb{D} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   = \\\\frac{d \\\\boldsymbol{\\\\mathbb{B}}}{d \\\\boldsymbol{\\\\mathbb{H}}}\\n   = - \\\\frac{1}{2} \\\\mu_{e} \\\\left[ \\\\text{tr}(\\\\mathbf{C}) - d - 2 \\\\ln\\n   (\\\\text{det}(\\\\mathbf{F}))\\n   \\\\right] \\\\frac{d^{2} f_{\\\\mu_{e}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)}{d \\\\boldsymbol{\\\\mathbb{H}} \\\\otimes d \\\\boldsymbol{\\\\mathbb{H}}}\\n   + \\\\mu_{0} \\\\mu_{r} \\\\text{det}(\\\\mathbf{F}) \\\\mathbf{C}^{-1}\\n   \\\\]\\n\\n\\n\\\\begin{align}\\n   \\\\mathfrak{P}^{\\\\text{tot}} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right) = - \\\\frac{d \\\\mathbf{S}^{\\\\text{tot}}}{d \\\\boldsymbol{\\\\mathbb{H}}}\\n   &= - \\\\mu_{e}\\n   \\\\left[ \\\\frac{d\\\\,\\\\text{tr}(\\\\mathbf{C})}{d \\\\mathbf{C}}\\n   - 2 \\\\frac{1}{\\\\text{det}(\\\\mathbf{F})}\\n   \\\\frac{d\\\\,\\\\text{det}(\\\\mathbf{F})}{d \\\\mathbf{C}} \\\\right]\\n   \\\\otimes \\\\frac{d f_{\\\\mu_{e} \\\\left( \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)}}{d \\\\boldsymbol{\\\\mathbb{H}}}\\n   + \\\\mu_{0} \\\\mu_{r} \\\\left[\\n   \\\\frac{d\\\\,\\\\text{det}(\\\\mathbf{F})}{d \\\\mathbf{C}} \\\\otimes\\n   \\\\frac{d \\\\left[ \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right]}{d \\\\boldsymbol{\\\\mathbb{H}}} \\\\right]\\n   + \\\\text{det}(\\\\mathbf{F})\\n   \\\\frac{d^{2} \\\\left[ \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1}\\n   \\\\cdot \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right]}{d \\\\mathbf{C} \\\\otimes d \\\\boldsymbol{\\\\mathbb{H}}}\\n   \\\\\\\\ &= - \\\\mu_{e}\\n   \\\\left[ \\\\mathbf{I} - \\\\mathbf{C}^{-1} \\\\right] \\\\otimes\\n   \\\\frac{d f_{\\\\mu_{e} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}}{d\\n   \\\\boldsymbol{\\\\mathbb{H}}}\\n   + \\\\mu_{0} \\\\mu_{r} \\\\left[\\n   \\\\text{det}(\\\\mathbf{F}) \\\\mathbf{C}^{-1} \\\\otimes\\n   \\\\left[ \\\\mathbf{C}^{-1} \\\\cdot \\\\boldsymbol{\\\\mathbb{H}} \\\\right]\\n   \\\\right]\\n   + \\\\text{det}(\\\\mathbf{F})\\n   \\\\frac{d^{2} \\\\left[ \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1}\\n   \\\\cdot \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right]}{d \\\\mathbf{C} \\\\otimes \\\\mathbf{C} \\\\boldsymbol{\\\\mathbb{H}}}\\n   \\\\end{align}\\n\\n\\n\\\\begin{align}\\n   \\\\mathcal{H}^{\\\\text{tot}} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right) = 2 \\\\frac{d \\\\mathbf{S}^{\\\\text{tot}}}{d \\\\mathbf{C}}\\n   &= 2 \\\\mu_{e} f_{\\\\mu_{e}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   \\\\left[ - \\\\frac{d \\\\mathbf{C}^{-1}}{d \\\\mathbf{C}} \\\\right]\\n   + 4 \\\\lambda_{e} \\\\left[ \\\\mathbf{C}^{-1} \\\\otimes \\\\left[\\n   \\\\frac{1}{\\\\text{det}(\\\\mathbf{F})} \\\\frac{d \\\\, \\\\text{det}(\\\\mathbf{F})}{d\\n   \\\\mathbf{C}} \\\\right] + \\\\ln \\\\left(\\\\text{det}(\\\\mathbf{F}) \\\\right) \\\\frac{d\\n   \\\\mathbf{C}^{-1}}{d \\\\mathbf{C}} \\\\right]\\n   \\\\\\\\ &- \\\\mu_{0} \\\\mu_{r}  \\\\left[\\n   \\\\text{det}(\\\\mathbf{F}) \\\\mathbf{C}^{-1} \\\\otimes \\\\frac{d \\\\left[\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right]}{d \\\\mathbf{C}}\\n   + \\\\left[ \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right] \\\\mathbf{C}^{-1} \\\\otimes \\\\frac{d \\\\,\\n   \\\\text{det}(\\\\mathbf{F})}{d \\\\mathbf{C}}\\n   + \\\\left[ \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right] \\\\text{det}(\\\\mathbf{F}) \\\\frac{d\\n   \\\\mathbf{C}^{-1}}{d \\\\mathbf{C}}\\n   \\\\right]\\n   \\\\\\\\ &+ 2 \\\\mu_{0} \\\\mu_{r} \\\\left[ \\\\left[\\n   \\\\left[ \\\\mathbf{C}^{-1} \\\\cdot \\\\boldsymbol{\\\\mathbb{H}} \\\\right] \\\\otimes\\n   \\\\left[ \\\\mathbf{C}^{-1} \\\\cdot \\\\boldsymbol{\\\\mathbb{H}} \\\\right]\\n   \\\\right] \\\\otimes \\\\frac{d \\\\, \\\\text{det}(\\\\mathbf{F})}{d \\\\mathbf{C}}\\n   - \\\\text{det}(\\\\mathbf{F})\\n   \\\\frac{d^{2} \\\\left[ \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1}\\n   \\\\cdot \\\\boldsymbol{\\\\mathbb{H}}\\\\right]}{d \\\\mathbf{C} \\\\otimes d\\n   \\\\mathbf{C}}\\n   \\\\right]\\n   \\\\\\\\ &= 2 \\\\mu_{e} f_{\\\\mu_{e}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   \\\\left[ - \\\\frac{d \\\\mathbf{C}^{-1}}{d \\\\mathbf{C}} \\\\right]\\n   + 4 \\\\lambda_{e} \\\\left[ \\\\frac{1}{2} \\\\mathbf{C}^{-1} \\\\otimes\\n   \\\\mathbf{C}^{-1} + \\\\ln \\\\left(\\\\text{det}(\\\\mathbf{F}) \\\\right) \\\\frac{d\\n   \\\\mathbf{C}^{-1}}{d \\\\mathbf{C}} \\\\right]\\n   \\\\\\\\ &- \\\\mu_{0} \\\\mu_{r}  \\\\left[\\n   - \\\\text{det}(\\\\mathbf{F}) \\\\mathbf{C}^{-1} \\\\otimes \\\\left[ \\\\left[\\n   \\\\mathbf{C}^{-1} \\\\cdot \\\\boldsymbol{\\\\mathbb{H}} \\\\right] \\\\otimes\\n   \\\\left[ \\\\mathbf{C}^{-1} \\\\cdot \\\\boldsymbol{\\\\mathbb{H}} \\\\right] \\\\right]\\n   + \\\\frac{1}{2} \\\\left[ \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right] \\\\text{det}(\\\\mathbf{F})  \\\\mathbf{C}^{-1}\\n   \\\\otimes \\\\mathbf{C}^{-1}\\n   + \\\\left[ \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right] \\\\text{det}(\\\\mathbf{F}) \\\\frac{d\\n   \\\\mathbf{C}^{-1}}{d \\\\mathbf{C}}\\n   \\\\right]\\n   \\\\\\\\ &+ 2 \\\\mu_{0} \\\\mu_{r} \\\\left[ \\\\frac{1}{2} \\\\text{det}(\\\\mathbf{F}) \\\\left[\\n   \\\\left[ \\\\mathbf{C}^{-1} \\\\cdot \\\\boldsymbol{\\\\mathbb{H}} \\\\right] \\\\otimes\\n   \\\\left[ \\\\mathbf{C}^{-1} \\\\cdot \\\\boldsymbol{\\\\mathbb{H}} \\\\right]\\n   \\\\right] \\\\otimes \\\\mathbf{C}^{-1}\\n   - \\\\text{det}(\\\\mathbf{F})\\n   \\\\frac{d^{2} \\\\left[ \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1}\\n   \\\\cdot \\\\boldsymbol{\\\\mathbb{H}}\\\\right]}{d \\\\mathbf{C} \\\\otimes d\\n   \\\\mathbf{C}}\\n   \\\\right]\\n   \\\\end{align}\\n\\n with             \\n\\\\[\\n   \\\\frac{d^{2} f_{\\\\mu_{e}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{d\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\otimes d \\\\boldsymbol{\\\\mathbb{H}}}\\n   = -2 \\\\left[ \\\\frac{\\\\mu_{e}^{\\\\infty}}{\\\\mu_{e}} - 1 \\\\right]\\n   \\\\tanh \\\\left( 2 \\\\frac{\\\\boldsymbol{\\\\mathbb{H}} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}}}\\n   {\\\\left(h_{e}^{\\\\text{sat}}\\\\right)^{2}} \\\\right)\\n   \\\\text{sech}^{2} \\\\left( 2 \\\\frac{\\\\boldsymbol{\\\\mathbb{H}} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}}}\\n   {\\\\left(h_{e}^{\\\\text{sat}}\\\\right)^{2}} \\\\right)\\n   \\\\left[ \\\\frac{4} {\\\\left(h_{e}^{\\\\text{sat}}\\\\right)^{2}} \\\\mathbf{I}\\n   \\\\right]\\n   \\\\]\\n\\n\\n\\\\[\\n   \\\\frac{d \\\\left[ \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right]}{d \\\\boldsymbol{\\\\mathbb{H}}}\\n   = 2 \\\\mathbf{C}^{-1} \\\\cdot \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\]\\n\\n\\n\\\\[\\n   \\\\frac{d^{2} \\\\left[ \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}}\\\\right]}{d \\\\mathbf{C} \\\\otimes d\\n   \\\\boldsymbol{\\\\mathbb{H}}} \\\\Rightarrow \\\\frac{d^{2} \\\\left[ \\\\mathbb{H}_{e}\\n   C^{-1}_{ef} \\\\mathbb{H}_{f}\\n   \\\\right]}{d C_{ab} d \\\\mathbb{H}_{c}}\\n   = - C^{-1}_{ac} C^{-1}_{be} \\\\mathbb{H}_{e} - C^{-1}_{ae} \\\\mathbb{H}_{e}\\n   C^{-1}_{bc}\\n   \\\\]\\n\\n\\n\\\\begin{align}\\n   \\\\frac{d^{2} \\\\left[ \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}}\\\\right]}{d \\\\mathbf{C} \\\\otimes d \\\\mathbf{C}}\\n   &= -\\\\frac{d \\\\left[\\\\left[ \\\\mathbf{C}^{-1} \\\\cdot \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right] \\\\otimes\\n   \\\\left[ \\\\mathbf{C}^{-1} \\\\cdot \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right]\\\\right]}{d \\\\mathbf{C}}\\n   \\\\\\\\ \\\\Rightarrow\\n   \\\\frac{d^{2} \\\\left[ \\\\mathbb{H}_{e} C^{-1}_{ef} \\\\mathbb{H}_{f}\\n   \\\\right]}{d C_{ab} d C_{cd}}\\n   &= \\\\text{sym} \\\\left( C^{-1}_{ae} \\\\mathbb{H}_{e} C^{-1}_{cf}\\n   \\\\mathbb{H}_{f} C^{-1}_{bd}\\n   + C^{-1}_{ce} \\\\mathbb{H}_{e} C^{-1}_{bf} \\\\mathbb{H}_{f}\\n   C^{-1}_{ad} \\\\right)\\n   \\\\\\\\ &= \\\\frac{1}{2} \\\\left[\\n   C^{-1}_{ae} \\\\mathbb{H}_{e} C^{-1}_{cf} \\\\mathbb{H}_{f} C^{-1}_{bd}\\n   + C^{-1}_{ae} \\\\mathbb{H}_{e} C^{-1}_{df} \\\\mathbb{H}_{f} C^{-1}_{bc}\\n   + C^{-1}_{ce} \\\\mathbb{H}_{e} C^{-1}_{bf} \\\\mathbb{H}_{f} C^{-1}_{ad}\\n   + C^{-1}_{be} \\\\mathbb{H}_{e} C^{-1}_{df} \\\\mathbb{H}_{f} C^{-1}_{ac}\\n   \\\\right]\\n   \\\\end{align}\\n\\nWell, that escalated quickly \\u2013 although the definition of \\\\(\\\\psi_{0}\\\\) and \\\\(f_{\\\\mu_e}\\\\) might have given some hints that the calculating the kinetic fields and their linearization would take some effort, it is likely that there's a little more complexity to the final definitions that perhaps initially thought. Knowing what we now do, it's probably fair to say that we really do not want to compute first and second derivatives of these functions with respect to their arguments \\u2013 regardless of well we did in calculus classes, or how good a programmer we may be.\\nIn the class method definition where these are ultimately implemented, we've composed these calculations slightly differently. Some intermediate steps are also retained to give another perspective of how to systematically compute the derivatives. Additionally, some calculations are decomposed less or further to reuse some of the intermediate values and, hopefully, aid the reader to follow the derivative operations.\\n\\u00a0     template <int dim>\\n\\u00a0     class Magnetoelastic_Constitutive_Law final\\n\\u00a0       : public Coupled_Magnetomechanical_Constitutive_Law_Base<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       Magnetoelastic_Constitutive_Law(\\n\\u00a0         const ConstitutiveParameters &constitutive_parameters);\\n\\u00a0 \\n\\u00a0       virtual void update_internal_data(const SymmetricTensor<2, dim> &C,\\n\\u00a0                                         const Tensor<1, dim>          &H,\\n\\u00a0                                         const DiscreteTime &) override;\\n\\u00a0 \\n\\u00a0       virtual double get_psi() const override;\\n\\u00a0 \\n\\u00a0       virtual Tensor<1, dim> get_B() const override;\\n\\u00a0 \\n\\u00a0       virtual SymmetricTensor<2, dim> get_S() const override;\\n\\u00a0 \\n\\u00a0       virtual SymmetricTensor<2, dim> get_DD() const override;\\n\\u00a0 \\n\\u00a0       virtual Tensor<3, dim> get_PP() const override;\\n\\u00a0 \\n\\u00a0       virtual SymmetricTensor<4, dim> get_HH() const override;\\n\\u00a0 \\n\\u00a0     private:\\n\\u00a0       double                  psi;\\n\\u00a0       Tensor<1, dim>          B;\\n\\u00a0       SymmetricTensor<2, dim> S;\\n\\u00a0       SymmetricTensor<2, dim> BB;\\n\\u00a0       Tensor<3, dim>          PP;\\n\\u00a0       SymmetricTensor<4, dim> HH;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     Magnetoelastic_Constitutive_Law<dim>::Magnetoelastic_Constitutive_Law(\\n\\u00a0       const ConstitutiveParameters &constitutive_parameters)\\n\\u00a0       : Coupled_Magnetomechanical_Constitutive_Law_Base<dim>(\\n\\u00a0           constitutive_parameters)\\n\\u00a0       , psi(0.0)\\n\\u00a0     {}\\n\\u00a0 \\nFor this class's update method, we'll simply precompute a collection of intermediate values (for function evaluations, derivative calculations, and the like) and \\\"manually\\\" arrange them in the order that's required to maximize their reuse. This means that we have to manage this ourselves, and decide what values must be compute before others, all while keeping some semblance of order or structure in the code itself. It's effective, but perhaps a little tedious. It also doesn't do too much to help future extension of the class, because all of these values remain local to this single method.\\nInterestingly, this basic technique of precomputing intermediate expressions that are used in more than one place has a name: common subexpression elimination (CSE). It is a strategy used by Computer Algebra Systems to reduce the computational expense when they are tasked with evaluating similar expressions.\\n\\u00a0     template <int dim>\\n\\u00a0     void Magnetoelastic_Constitutive_Law<dim>::update_internal_data(\\n\\u00a0       const SymmetricTensor<2, dim> &C,\\n\\u00a0       const Tensor<1, dim>          &H,\\n\\u00a0       const DiscreteTime &)\\n\\u00a0     {\\n\\u00a0       const double                  det_F = std::sqrt(determinant(C));\\n\\u00a0       const SymmetricTensor<2, dim> C_inv = invert(C);\\n\\u00a0       AssertThrow(det_F > 0.0,\\n\\u00a0                   ExcMessage(\\\"Volumetric Jacobian must be positive.\\\"));\\n\\u00a0 \\nThe saturation function for the magneto-elastic energy.\\n\\u00a0       const double two_h_dot_h_div_h_sat_squ =\\n\\u00a0         (2.0 * H * H) / (this->get_mu_e_h_sat() * this->get_mu_e_h_sat());\\n\\u00a0       const double tanh_two_h_dot_h_div_h_sat_squ =\\n\\u00a0         std::tanh(two_h_dot_h_div_h_sat_squ);\\n\\u00a0 \\n\\u00a0       const double f_mu_e =\\n\\u00a0         1.0 + (this->get_mu_e_inf() / this->get_mu_e() - 1.0) *\\n\\u00a0                 tanh_two_h_dot_h_div_h_sat_squ;\\n\\u00a0 \\nThe first derivative of the saturation function, noting that \\\\(\\\\frac{d \\\\tanh(x)}{dx} = \\\\text{sech}^{2}(x)\\\\).\\n\\u00a0       const double dtanh_two_h_dot_h_div_h_sat_squ =\\n\\u00a0         Utilities::fixed_power<2>(1.0 / std::cosh(two_h_dot_h_div_h_sat_squ));\\n\\u00a0       const Tensor<1, dim> dtwo_h_dot_h_div_h_sat_squ_dH =\\n\\u00a0         2.0 * 2.0 / (this->get_mu_e_h_sat() * this->get_mu_e_h_sat()) * H;\\n\\u00a0 \\n\\u00a0       const Tensor<1, dim> df_mu_e_dH =\\n\\u00a0         (this->get_mu_e_inf() / this->get_mu_e() - 1.0) *\\n\\u00a0         (dtanh_two_h_dot_h_div_h_sat_squ * dtwo_h_dot_h_div_h_sat_squ_dH);\\n\\u00a0 \\nUtilities::fixed_powerconstexpr T fixed_power(const T t)Definition utilities.h:942\\nstd::coshinline ::VectorizedArray< Number, width > cosh(const ::VectorizedArray< Number, width > &x)Definition vectorization.h:6709\\nThe second derivative of saturation function, noting that \\\\(\\\\frac{d \\\\text{sech}^{2}(x)}{dx} = -2 \\\\tanh(x) \\\\text{sech}^{2}(x)\\\\).\\n\\u00a0       const double d2tanh_two_h_dot_h_div_h_sat_squ =\\n\\u00a0         -2.0 * tanh_two_h_dot_h_div_h_sat_squ * dtanh_two_h_dot_h_div_h_sat_squ;\\n\\u00a0       const SymmetricTensor<2, dim> d2two_h_dot_h_div_h_sat_squ_dH_dH =\\n\\u00a0         2.0 * 2.0 / (this->get_mu_e_h_sat() * this->get_mu_e_h_sat()) *\\n\\u00a0         Physics::Elasticity::StandardTensors<dim>::I;\\n\\u00a0 \\n\\u00a0       const SymmetricTensor<2, dim> d2f_mu_e_dH_dH =\\n\\u00a0         (this->get_mu_e_inf() / this->get_mu_e() - 1.0) *\\n\\u00a0         (d2tanh_two_h_dot_h_div_h_sat_squ *\\n\\u00a0            symmetrize(outer_product(dtwo_h_dot_h_div_h_sat_squ_dH,\\n\\u00a0                                     dtwo_h_dot_h_div_h_sat_squ_dH)) +\\n\\u00a0          dtanh_two_h_dot_h_div_h_sat_squ * d2two_h_dot_h_div_h_sat_squ_dH_dH);\\n\\u00a0 \\nPhysics::Elasticity::StandardTensorsDefinition standard_tensors.h:45\\nouter_productDEAL_II_HOST constexpr SymmetricTensor< 4, dim, Number > outer_product(const SymmetricTensor< 2, dim, Number > &t1, const SymmetricTensor< 2, dim, Number > &t2)Definition symmetric_tensor.h:3301\\nSome intermediate quantities attained directly from the field / kinematic variables.\\n\\u00a0       const double         log_det_F         = std::log(det_F);\\n\\u00a0       const double         tr_C              = trace(C);\\n\\u00a0       const Tensor<1, dim> C_inv_dot_H       = C_inv * H;\\n\\u00a0       const double         H_dot_C_inv_dot_H = H * C_inv_dot_H;\\n\\u00a0 \\nFirst derivatives of the intermediate quantities.\\n\\u00a0       const SymmetricTensor<2, dim> d_tr_C_dC =\\n\\u00a0         Physics::Elasticity::StandardTensors<dim>::I;\\n\\u00a0       const SymmetricTensor<2, dim> ddet_F_dC     = 0.5 * det_F * C_inv;\\n\\u00a0       const SymmetricTensor<2, dim> dlog_det_F_dC = 0.5 * C_inv;\\n\\u00a0 \\n\\u00a0       const Tensor<1, dim> dH_dot_C_inv_dot_H_dH = 2.0 * C_inv_dot_H;\\n\\u00a0 \\n\\u00a0       SymmetricTensor<4, dim> dC_inv_dC;\\n\\u00a0       for (unsigned int A = 0; A < dim; ++A)\\n\\u00a0         for (unsigned int B = A; B < dim; ++B)\\n\\u00a0           for (unsigned int C = 0; C < dim; ++C)\\n\\u00a0             for (unsigned int D = C; D < dim; ++D)\\n\\u00a0               dC_inv_dC[A][B][C][D] -=               \\n\\u00a0                 0.5 * (C_inv[A][C] * C_inv[B][D]     \\n\\u00a0                        + C_inv[A][D] * C_inv[B][C]); \\n\\u00a0 \\n\\u00a0       const SymmetricTensor<2, dim> dH_dot_C_inv_dot_H_dC =\\n\\u00a0         -symmetrize(outer_product(C_inv_dot_H, C_inv_dot_H));\\n\\u00a0 \\nSecond derivatives of the intermediate quantities.\\n\\u00a0       const SymmetricTensor<4, dim> d2log_det_F_dC_dC = 0.5 * dC_inv_dC;\\n\\u00a0 \\n\\u00a0       const SymmetricTensor<4, dim> d2det_F_dC_dC =\\n\\u00a0         0.5 * (outer_product(C_inv, ddet_F_dC) + det_F * dC_inv_dC);\\n\\u00a0 \\n\\u00a0       const SymmetricTensor<2, dim> d2H_dot_C_inv_dot_H_dH_dH = 2.0 * C_inv;\\n\\u00a0 \\n\\u00a0       Tensor<3, dim> d2H_dot_C_inv_dot_H_dC_dH;\\n\\u00a0       for (unsigned int A = 0; A < dim; ++A)\\n\\u00a0         for (unsigned int B = 0; B < dim; ++B)\\n\\u00a0           for (unsigned int C = 0; C < dim; ++C)\\n\\u00a0             d2H_dot_C_inv_dot_H_dC_dH[A][B][C] -=\\n\\u00a0               C_inv[A][C] * C_inv_dot_H[B] + \\n\\u00a0               C_inv_dot_H[A] * C_inv[B][C];  \\n\\u00a0 \\n\\u00a0       SymmetricTensor<4, dim> d2H_dot_C_inv_dot_H_dC_dC;\\n\\u00a0       for (unsigned int A = 0; A < dim; ++A)\\n\\u00a0         for (unsigned int B = A; B < dim; ++B)\\n\\u00a0           for (unsigned int C = 0; C < dim; ++C)\\n\\u00a0             for (unsigned int D = C; D < dim; ++D)\\n\\u00a0               d2H_dot_C_inv_dot_H_dC_dC[A][B][C][D] +=\\n\\u00a0                 0.5 * (C_inv_dot_H[A] * C_inv_dot_H[C] * C_inv[B][D] +\\n\\u00a0                        C_inv_dot_H[A] * C_inv_dot_H[D] * C_inv[B][C] +\\n\\u00a0                        C_inv_dot_H[B] * C_inv_dot_H[C] * C_inv[A][D] +\\n\\u00a0                        C_inv_dot_H[B] * C_inv_dot_H[D] * C_inv[A][C]);\\n\\u00a0 \\nThe stored energy density function.\\n\\u00a0       psi =\\n\\u00a0         (0.5 * this->get_mu_e() * f_mu_e) *\\n\\u00a0           (tr_C - dim - 2.0 * std::log(det_F)) +\\n\\u00a0         this->get_lambda_e() * (std::log(det_F) * std::log(det_F)) -\\n\\u00a0         (0.5 * this->get_mu_0() * this->get_mu_r()) * det_F * (H * C_inv * H);\\n\\u00a0 \\nThe kinetic quantities.\\n\\u00a0       B = -(0.5 * this->get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) *\\n\\u00a0             df_mu_e_dH \\n\\u00a0           + 0.5 * this->get_mu_0() * this->get_mu_r() * det_F *\\n\\u00a0               dH_dot_C_inv_dot_H_dH; \\n\\u00a0 \\n\\u00a0       S = 2.0 * (0.5 * this->get_mu_e() * f_mu_e) *                        \\n\\u00a0             (d_tr_C_dC - 2.0 * dlog_det_F_dC)                              \\n\\u00a0           + 2.0 * this->get_lambda_e() * (2.0 * log_det_F * dlog_det_F_dC) \\n\\u00a0           - 2.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) *            \\n\\u00a0               (H_dot_C_inv_dot_H * ddet_F_dC                               \\n\\u00a0                + det_F * dH_dot_C_inv_dot_H_dC);                           \\n\\u00a0 \\nThe linearization of the kinetic quantities.\\n\\u00a0       BB = -(0.5 * this->get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * \\n\\u00a0              d2f_mu_e_dH_dH                                             \\n\\u00a0            + 0.5 * this->get_mu_0() * this->get_mu_r() * det_F *\\n\\u00a0                d2H_dot_C_inv_dot_H_dH_dH; \\n\\u00a0 \\n\\u00a0       PP = -2.0 * (0.5 * this->get_mu_e()) *                                  \\n\\u00a0              outer_product(Tensor<2, dim>(d_tr_C_dC - 2.0 * dlog_det_F_dC),   \\n\\u00a0                            df_mu_e_dH)                                        \\n\\u00a0            +                                                                  \\n\\u00a0            2.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) *                \\n\\u00a0              (outer_product(Tensor<2, dim>(ddet_F_dC), dH_dot_C_inv_dot_H_dH) \\n\\u00a0               + det_F * d2H_dot_C_inv_dot_H_dC_dH);                           \\n\\u00a0 \\n\\u00a0       HH =\\n\\u00a0         4.0 * (0.5 * this->get_mu_e() * f_mu_e) * (-2.0 * d2log_det_F_dC_dC) \\n\\u00a0         + 4.0 * this->get_lambda_e() *                                       \\n\\u00a0             (2.0 * outer_product(dlog_det_F_dC, dlog_det_F_dC)               \\n\\u00a0              + 2.0 * log_det_F * d2log_det_F_dC_dC)                          \\n\\u00a0         - 4.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) *                \\n\\u00a0             (H_dot_C_inv_dot_H * d2det_F_dC_dC                               \\n\\u00a0              + outer_product(ddet_F_dC, dH_dot_C_inv_dot_H_dC)               \\n\\u00a0              + outer_product(dH_dot_C_inv_dot_H_dC, ddet_F_dC)               \\n\\u00a0              + det_F * d2H_dot_C_inv_dot_H_dC_dC);                           \\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double Magnetoelastic_Constitutive_Law<dim>::get_psi() const\\n\\u00a0     {\\n\\u00a0       return psi;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     Tensor<1, dim> Magnetoelastic_Constitutive_Law<dim>::get_B() const\\n\\u00a0     {\\n\\u00a0       return B;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     SymmetricTensor<2, dim> Magnetoelastic_Constitutive_Law<dim>::get_S() const\\n\\u00a0     {\\n\\u00a0       return S;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     SymmetricTensor<2, dim> Magnetoelastic_Constitutive_Law<dim>::get_DD() const\\n\\u00a0     {\\n\\u00a0       return BB;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     Tensor<3, dim> Magnetoelastic_Constitutive_Law<dim>::get_PP() const\\n\\u00a0     {\\n\\u00a0       return PP;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     SymmetricTensor<4, dim> Magnetoelastic_Constitutive_Law<dim>::get_HH() const\\n\\u00a0     {\\n\\u00a0       return HH;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n Magneto-viscoelastic constitutive law (hand-derived)\\nAs mentioned before, the free energy density function for the magneto-viscoelastic material with one dissipative mechanism that we'll be considering is defined as       \\n\\\\[\\n   \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v}, \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)\\n   = \\\\psi_{0}^{ME} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   + \\\\psi_{0}^{MVE} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   \\\\]\\n\\n\\n\\\\[\\n   \\\\psi_{0}^{ME} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   = \\\\frac{1}{2} \\\\mu_{e} f_{\\\\mu_{e}^{ME}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)\\n   \\\\left[ \\\\text{tr}(\\\\mathbf{C}) - d - 2 \\\\ln (\\\\text{det}(\\\\mathbf{F}))\\n   \\\\right]\\n   + \\\\lambda_{e} \\\\ln^{2} \\\\left(\\\\text{det}(\\\\mathbf{F}) \\\\right)\\n   - \\\\frac{1}{2} \\\\mu_{0} \\\\mu_{r} \\\\text{det}(\\\\mathbf{F})\\n   \\\\left[ \\\\boldsymbol{\\\\mathbb{H}} \\\\cdot \\\\mathbf{C}^{-1} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right]\\n   \\\\]\\n\\n\\n\\\\[\\n   \\\\psi_{0}^{MVE} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   = \\\\frac{1}{2} \\\\mu_{v} f_{\\\\mu_{v}^{MVE}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)\\n   \\\\left[ \\\\mathbf{C}_{v} : \\\\left[\\n   \\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{-\\\\frac{2}{d}}\\n   \\\\mathbf{C} \\\\right] - d - \\\\ln\\\\left(\\n   \\\\text{det}\\\\left(\\\\mathbf{C}_{v}\\\\right) \\\\right)  \\\\right]\\n   \\\\]\\n\\n with       \\n\\\\[\\n   f_{\\\\mu_{e}}^{ME} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   = 1 + \\\\left[ \\\\frac{\\\\mu_{e}^{\\\\infty}}{\\\\mu_{e}} - 1 \\\\right]\\n   \\\\tanh \\\\left( 2 \\\\frac{\\\\boldsymbol{\\\\mathbb{H}} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}}}\\n   {\\\\left(h_{e}^{\\\\text{sat}}\\\\right)^{2}} \\\\right)\\n   \\\\]\\n\\n\\n\\\\[\\n   f_{\\\\mu_{v}}^{MVE} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   = 1 + \\\\left[ \\\\frac{\\\\mu_{v}^{\\\\infty}}{\\\\mu_{v}} - 1 \\\\right]\\n   \\\\tanh \\\\left( 2 \\\\frac{\\\\boldsymbol{\\\\mathbb{H}} \\\\cdot\\n   \\\\boldsymbol{\\\\mathbb{H}}}\\n   {\\\\left(h_{v}^{\\\\text{sat}}\\\\right)^{2}} \\\\right)\\n   \\\\]\\n\\n and the evolution law       \\n\\\\[\\n   \\\\dot{\\\\mathbf{C}}_{v} \\\\left( \\\\mathbf{C} \\\\right)\\n   = \\\\frac{1}{\\\\tau} \\\\left[\\n   \\\\left[\\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{-\\\\frac{2}{d}}\\n   \\\\mathbf{C}\\\\right]^{-1}\\n   - \\\\mathbf{C}_{v} \\\\right]\\n   \\\\]\\n\\n that itself is parameterized in terms of \\\\(\\\\mathbf{C}\\\\). By design, the magnetoelastic part of the energy \\\\(\\\\psi_{0}^{ME} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\\\) is identical to that of the magnetoelastic material presented earlier. So, for the derivatives of the various contributions stemming from this part of the energy, please refer to the previous section. We'll continue to highlight the specific contributions from those terms by superscripting the salient terms with \\\\(ME\\\\), while contributions from the magneto-viscoelastic component are superscripted with \\\\(MVE\\\\). Furthermore, the magnetic saturation function \\\\(f_{\\\\mu_{v}}^{MVE} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\\\) for the damping term has the identical form as that of the elastic term (i.e., \\\\(f_{\\\\mu_{e}}^{ME} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\\\) ), and so the structure of its derivatives are identical to that seen before; the only change is for the three constitutive parameters that are now associated with the viscous shear modulus \\\\(\\\\mu_{v}\\\\) rather than the elastic shear modulus \\\\(\\\\mu_{e}\\\\).\\nFor this magneto-viscoelastic material, the first derivatives that correspond to the magnetic induction vector and total Piola-Kirchhoff stress tensor are              \\n\\\\[\\n   \\\\boldsymbol{\\\\mathbb{B}} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   \\\\dealcoloneq - \\\\frac{\\\\partial \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{\\\\partial \\\\boldsymbol{\\\\mathbb{H}}}\\n   \\\\Big\\\\vert_{\\\\mathbf{C}, \\\\mathbf{C}_{v}} \\\\equiv\\n   \\\\boldsymbol{\\\\mathbb{B}}^{ME} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)\\n   + \\\\boldsymbol{\\\\mathbb{B}}^{MVE} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right) =  - \\\\frac{d \\\\psi_{0}^{ME} \\\\left(\\n   \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{d \\\\boldsymbol{\\\\mathbb{H}}}\\n   - \\\\frac{\\\\partial \\\\psi_{0}^{MVE} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{\\\\partial \\\\boldsymbol{\\\\mathbb{H}}}\\n   \\\\]\\n\\n\\n\\\\[\\n   \\\\mathbf{S}^{\\\\text{tot}} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   \\\\dealcoloneq 2 \\\\frac{\\\\partial \\\\psi_{0} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{\\\\partial \\\\mathbf{C}}\\n   \\\\Big\\\\vert_{\\\\mathbf{C}_{v}, \\\\boldsymbol{\\\\mathbb{H}}} \\\\equiv\\n   \\\\mathbf{S}^{\\\\text{tot}, ME} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)\\n   + \\\\mathbf{S}^{\\\\text{tot}, MVE} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)\\n   =  2 \\\\frac{d \\\\psi_{0}^{ME} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)}{d \\\\mathbf{C}}\\n   + 2 \\\\frac{\\\\partial \\\\psi_{0}^{MVE} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{\\\\partial \\\\mathbf{C}}\\n   \\\\]\\n\\n with the viscous contributions being             \\n\\\\[\\n   \\\\boldsymbol{\\\\mathbb{B}}^{MVE} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   = - \\\\frac{\\\\partial \\\\psi_{0}^{MVE} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{\\\\partial \\\\boldsymbol{\\\\mathbb{H}}}\\n   \\\\Big\\\\vert_{\\\\mathbf{C}, \\\\mathbf{C}_{v}} = - \\\\frac{1}{2} \\\\mu_{v}\\n   \\\\left[ \\\\mathbf{C}_{v} : \\\\left[\\n   \\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{-\\\\frac{2}{d}}\\n   \\\\mathbf{C} \\\\right] - d - \\\\ln\\\\left(\\n   \\\\text{det}\\\\left(\\\\mathbf{C}_{v}\\\\right) \\\\right)  \\\\right]\\n   \\\\frac{\\\\partial f_{\\\\mu_{v}^{MVE}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)}{\\\\partial \\\\boldsymbol{\\\\mathbb{H}}}\\n   \\\\]\\n\\n\\n\\\\[\\n   \\\\mathbf{S}^{\\\\text{tot}, MVE} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)\\n   = 2 \\\\frac{\\\\partial \\\\psi_{0}^{MVE} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{\\\\partial \\\\mathbf{C}}\\n   \\\\Big\\\\vert_{\\\\mathbf{C}_{v}, \\\\boldsymbol{\\\\mathbb{H}}} = \\\\mu_{v}\\n   f_{\\\\mu_{v}^{MVE}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   \\\\left[  \\\\left[ \\\\mathbf{C}_{v} : \\\\mathbf{C} \\\\right] \\\\left[ -\\n   \\\\frac{1}{d}\\n   \\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{-\\\\frac{2}{d}}\\n   \\\\mathbf{C}^{-1} \\\\right]\\n   + \\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{-\\\\frac{2}{d}}\\n   \\\\mathbf{C}_{v}\\n   \\\\right]\\n   \\\\]\\n\\n and with      \\n\\\\[\\n   \\\\frac{\\\\partial f_{\\\\mu_{v}^{MVE}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)}{\\\\partial \\\\boldsymbol{\\\\mathbb{H}}} \\\\equiv \\\\frac{d\\n   f_{\\\\mu_{v}^{MVE}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{d\\n   \\\\boldsymbol{\\\\mathbb{H}}} .\\n   \\\\]\\n\\n The time-discretized evolution law,         \\n\\\\[\\n   \\\\mathbf{C}_{v}^{(t)} \\\\left( \\\\mathbf{C} \\\\right)\\n   = \\\\frac{1}{1 + \\\\frac{\\\\Delta t}{\\\\tau_{v}}} \\\\left[\\n   \\\\mathbf{C}_{v}^{(t-1)}\\n   + \\\\frac{\\\\Delta t}{\\\\tau_{v}}\\n   \\\\left[\\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{-\\\\frac{2}{d}}\\n   \\\\mathbf{C} \\\\right]^{-1}\\n   \\\\right]\\n   \\\\]\\n\\n will also dictate how the linearization of the internal variable with respect to the field variables is composed.\\nObserve that in order to attain the correct expressions for the magnetic induction vector and total Piola-Kirchhoff stress tensor for this dissipative material, we must adhere strictly to the outcome of applying the Coleman-Noll procedure: we must take partial derivatives of the free energy density function with respect to the field variables. (For our non-dissipative magnetoelastic material, taking either partial or total derivatives would have had the same result, so there was no need to draw your attention to this before.) The crucial part of the operation is to freeze the internal variable \\\\(\\\\mathbf{C}_{v}^{(t)} \\\\left( \\\\mathbf{C} \\\\right)\\\\) while computing the derivatives of   \\\\(\\\\psi_{0}^{MVE} \\\\left( \\\\mathbf{C},\\n   \\\\mathbf{C}_{v} \\\\left( \\\\mathbf{C} \\\\right), \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)\\\\) with respect to \\\\(\\\\mathbf{C}\\\\) \\u2013 the dependence of \\\\(\\\\mathbf{C}_{v}^{(t)}\\\\) on \\\\(\\\\mathbf{C}\\\\) is not to be taken into account. When deciding whether to use AD or SD to perform this task the choice is clear \\u2013 only the symbolic framework provides a mechanism to do this; as was mentioned before, AD can only return total derivatives so it is unsuitable for the task.\\nTo wrap things up, we'll present the material tangents for this rate-dependent coupled material. The linearization of both kinetic variables with respect to their arguments are         \\n\\\\[\\n   \\\\mathbb{D} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v}, \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right) = \\\\frac{d \\\\boldsymbol{\\\\mathbb{B}}}{d \\\\boldsymbol{\\\\mathbb{H}}}\\n   \\\\equiv \\\\mathbb{D}^{ME} \\\\left( \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   + \\\\mathbb{D}^{MVE} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right) = \\\\frac{d \\\\boldsymbol{\\\\mathbb{B}}^{ME}}{d\\n   \\\\boldsymbol{\\\\mathbb{H}}}\\n   + \\\\frac{d \\\\boldsymbol{\\\\mathbb{B}}^{MVE}}{d \\\\boldsymbol{\\\\mathbb{H}}}\\n   \\\\]\\n\\n\\n\\\\[\\n   \\\\mathfrak{P}^{\\\\text{tot}} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right) = - \\\\frac{d \\\\mathbf{S}^{\\\\text{tot}}}{d\\n   \\\\boldsymbol{\\\\mathbb{H}}} \\\\equiv \\\\mathfrak{P}^{\\\\text{tot}, ME} \\\\left(\\n   \\\\mathbf{C}, \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   + \\\\mathfrak{P}^{\\\\text{tot}, MVE} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right) = - \\\\frac{d \\\\mathbf{S}^{\\\\text{tot},\\n   ME}}{d \\\\boldsymbol{\\\\mathbb{H}}}\\n   - \\\\frac{d \\\\mathbf{S}^{\\\\text{tot}, MVE}}{d \\\\boldsymbol{\\\\mathbb{H}}}\\n   \\\\]\\n\\n\\n\\\\[\\n   \\\\mathcal{H}^{\\\\text{tot}} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right) = 2 \\\\frac{d \\\\mathbf{S}^{\\\\text{tot}}}{d\\n   \\\\mathbf{C}} \\\\equiv \\\\mathcal{H}^{\\\\text{tot}, ME} \\\\left( \\\\mathbf{C},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   + \\\\mathcal{H}^{\\\\text{tot}, MVE} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right) = 2 \\\\frac{d \\\\mathbf{S}^{\\\\text{tot},\\n   ME}}{d \\\\mathbf{C}}\\n   + 2 \\\\frac{d \\\\mathbf{S}^{\\\\text{tot}, MVE}}{d \\\\mathbf{C}}\\n   \\\\]\\n\\n where the tangents for the viscous contributions are           \\n\\\\[\\n   \\\\mathbb{D}^{MVE} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right) = - \\\\frac{1}{2} \\\\mu_{v}\\n   \\\\left[ \\\\mathbf{C}_{v} : \\\\left[\\n   \\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{-\\\\frac{2}{d}}\\n   \\\\mathbf{C} \\\\right] - d - \\\\ln\\\\left(\\n   \\\\text{det}\\\\left(\\\\mathbf{C}_{v}\\\\right) \\\\right)  \\\\right]\\n   \\\\frac{\\\\partial^{2} f_{\\\\mu_{v}^{MVE}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)}{\\\\partial \\\\boldsymbol{\\\\mathbb{H}} \\\\otimes\\n   d \\\\boldsymbol{\\\\mathbb{H}}}\\n   \\\\]\\n\\n\\n\\\\[\\n   \\\\mathfrak{P}^{\\\\text{tot}, MVE} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right) = - \\\\mu_{v}\\n   \\\\left[  \\\\left[ \\\\mathbf{C}_{v} : \\\\mathbf{C} \\\\right] \\\\left[ -\\n   \\\\frac{1}{d}\\n   \\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{-\\\\frac{2}{d}}\\n   \\\\mathbf{C}^{-1} \\\\right]\\n   + \\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{-\\\\frac{2}{d}}\\n   \\\\mathbf{C}_{v}\\n   \\\\right] \\\\otimes \\\\frac{d f_{\\\\mu_{v}^{MVE}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)}{d \\\\boldsymbol{\\\\mathbb{H}}}\\n   \\\\]\\n\\n\\n\\\\begin{align}\\n   \\\\mathcal{H}^{\\\\text{tot}, MVE} \\\\left( \\\\mathbf{C}, \\\\mathbf{C}_{v},\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   &= 2 \\\\mu_{v} f_{\\\\mu_{v}^{MVE}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   \\\\left[ - \\\\frac{1}{d}\\n   \\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{-\\\\frac{2}{d}}\\n   \\\\mathbf{C}^{-1} \\\\right] \\\\otimes\\n   \\\\left[ \\\\mathbf{C}_{v} + \\\\mathbf{C} : \\\\frac{d \\\\mathbf{C}_{v}}{d\\n   \\\\mathbf{C}} \\\\right]\\n   \\\\\\\\ &+ 2 \\\\mu_{v} f_{\\\\mu_{v}^{MVE}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   \\\\left[ \\\\mathbf{C}_{v} : \\\\mathbf{C} \\\\right]\\n   \\\\left[\\n   \\\\frac{1}{d^{2}}\\n   \\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{-\\\\frac{2}{d}}\\n   \\\\mathbf{C}^{-1} \\\\otimes \\\\mathbf{C}^{-1}\\n   - \\\\frac{1}{d}\\n   \\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{-\\\\frac{2}{d}} \\\\frac{d\\n   \\\\mathbf{C}^{-1}}{d \\\\mathbf{C}}\\n   \\\\right]\\n   \\\\\\\\ &+ 2 \\\\mu_{v} f_{\\\\mu_{v}^{MVE}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}} \\\\right)\\n   \\\\left[\\n   -\\\\frac{1}{d}\\n   \\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{-\\\\frac{2}{d}}\\n   \\\\mathbf{C}_{v} \\\\otimes \\\\mathbf{C}^{-1}\\n   + \\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{-\\\\frac{2}{d}}\\n   \\\\frac{d \\\\mathbf{C}_{v}}{d \\\\mathbf{C}}\\n   \\\\right]\\n   \\\\end{align}\\n\\n with       \\n\\\\[\\n   \\\\frac{\\\\partial^{2} f_{\\\\mu_{v}^{MVE}} \\\\left( \\\\boldsymbol{\\\\mathbb{H}}\\n   \\\\right)}{\\\\partial \\\\boldsymbol{\\\\mathbb{H}} \\\\otimes\\n   d \\\\boldsymbol{\\\\mathbb{H}}} \\\\equiv \\\\frac{d^{2} f_{\\\\mu_{v}^{MVE}} \\\\left(\\n   \\\\boldsymbol{\\\\mathbb{H}} \\\\right)}{d \\\\boldsymbol{\\\\mathbb{H}} \\\\otimes d\\n   \\\\boldsymbol{\\\\mathbb{H}}}\\n   \\\\]\\n\\n and, from the evolution law,            \\n\\\\[\\n   \\\\frac{d \\\\mathbf{C}_{v}}{d \\\\mathbf{C}}\\n   \\\\equiv \\\\frac{d \\\\mathbf{C}_{v}^{(t)}}{d \\\\mathbf{C}}\\n   = \\\\frac{\\\\frac{\\\\Delta t}{\\\\tau_{v}} }{1 + \\\\frac{\\\\Delta t}{\\\\tau_{v}}}\\n   \\\\left[\\n   \\\\frac{1}{d}\\n   \\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{\\\\frac{2}{d}}\\n   \\\\mathbf{C}^{-1} \\\\otimes \\\\mathbf{C}^{-1}\\n   + \\\\left[\\\\text{det}\\\\left(\\\\mathbf{F}\\\\right)\\\\right]^{\\\\frac{2}{d}} \\\\frac{d\\n   \\\\mathbf{C}^{-1}}{d \\\\mathbf{C}}\\n   \\\\right] .\\n   \\\\]\\n\\n Notice that just the last term of \\\\(\\\\mathcal{H}^{\\\\text{tot}, MVE}\\\\) contains the tangent of the internal variable. The linearization of this particular evolution law is linear. For an example of a nonlinear evolution law, for which this linearization must be solved for in an iterative manner, see [132].\\n\\u00a0     template <int dim>\\n\\u00a0     class Magnetoviscoelastic_Constitutive_Law final\\n\\u00a0       : public Coupled_Magnetomechanical_Constitutive_Law_Base<dim>\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       Magnetoviscoelastic_Constitutive_Law(\\n\\u00a0         const ConstitutiveParameters &constitutive_parameters);\\n\\u00a0 \\n\\u00a0       virtual void update_internal_data(const SymmetricTensor<2, dim> &C,\\n\\u00a0                                         const Tensor<1, dim>          &H,\\n\\u00a0                                         const DiscreteTime &time) override;\\n\\u00a0 \\n\\u00a0       virtual double get_psi() const override;\\n\\u00a0 \\n\\u00a0       virtual Tensor<1, dim> get_B() const override;\\n\\u00a0 \\n\\u00a0       virtual SymmetricTensor<2, dim> get_S() const override;\\n\\u00a0 \\n\\u00a0       virtual SymmetricTensor<2, dim> get_DD() const override;\\n\\u00a0 \\n\\u00a0       virtual Tensor<3, dim> get_PP() const override;\\n\\u00a0 \\n\\u00a0       virtual SymmetricTensor<4, dim> get_HH() const override;\\n\\u00a0 \\n\\u00a0       virtual void update_end_of_timestep() override;\\n\\u00a0 \\n\\u00a0     private:\\n\\u00a0       SymmetricTensor<2, dim> Q_t;\\n\\u00a0       SymmetricTensor<2, dim> Q_t1;\\n\\u00a0 \\n\\u00a0       double                  psi;\\n\\u00a0       Tensor<1, dim>          B;\\n\\u00a0       SymmetricTensor<2, dim> S;\\n\\u00a0       SymmetricTensor<2, dim> BB;\\n\\u00a0       Tensor<3, dim>          PP;\\n\\u00a0       SymmetricTensor<4, dim> HH;\\n\\u00a0 \\nA data structure that is used to store all intermediate calculations. We'll see shortly precisely how this can be leveraged to make the part of the code where we actually perform calculations clean and easy (well, at least easier) to follow and maintain. But for now, we can say that it will allow us to move the parts of the code where we compute the derivatives of intermediate quantities away from where they are used.\\n\\u00a0       mutable GeneralDataStorage cache;\\n\\u00a0 \\nGeneralDataStorageDefinition general_data_storage.h:42\\nThe next two functions are used to update the state of the field and internal variables, and will be called before we perform any detailed calculations.\\n\\u00a0       void set_primary_variables(const SymmetricTensor<2, dim> &C,\\n\\u00a0                                  const Tensor<1, dim>          &H) const;\\n\\u00a0 \\n\\u00a0       void update_internal_variable(const DiscreteTime &time);\\n\\u00a0 \\nThe remainder of the class interface is dedicated to methods that are used to compute the components required to calculate the free energy density function, and all of its derivatives:\\nThe kinematic, or field, variables.\\n\\u00a0       const Tensor<1, dim> &get_H() const;\\n\\u00a0 \\n\\u00a0       const SymmetricTensor<2, dim> &get_C() const;\\n\\u00a0 \\nA generalized formulation for the saturation function, with the required constitutive parameters passed as arguments to each function.\\n\\u00a0       double get_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const;\\n\\u00a0 \\n\\u00a0       double get_tanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const;\\n\\u00a0 \\n\\u00a0       double get_f_mu(const double mu,\\n\\u00a0                       const double mu_inf,\\n\\u00a0                       const double mu_h_sat) const;\\n\\u00a0 \\nA generalized formulation for the first derivative of saturation function, with the required constitutive parameters passed as arguments to each function.\\n\\u00a0       double get_dtanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const;\\n\\u00a0 \\n\\u00a0       Tensor<1, dim>\\n\\u00a0       get_dtwo_h_dot_h_div_h_sat_squ_dH(const double mu_h_sat) const;\\n\\u00a0 \\n\\u00a0       Tensor<1, dim> get_df_mu_dH(const double mu,\\n\\u00a0                                   const double mu_inf,\\n\\u00a0                                   const double mu_h_sat) const;\\n\\u00a0 \\nA generalized formulation for the second derivative of saturation function, with the required constitutive parameters passed as arguments to each function.\\n\\u00a0       double get_d2tanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const;\\n\\u00a0 \\n\\u00a0       SymmetricTensor<2, dim>\\n\\u00a0       get_d2two_h_dot_h_div_h_sat_squ_dH_dH(const double mu_h_sat) const;\\n\\u00a0 \\n\\u00a0       SymmetricTensor<2, dim> get_d2f_mu_dH_dH(const double mu,\\n\\u00a0                                                const double mu_inf,\\n\\u00a0                                                const double mu_h_sat) const;\\n\\u00a0 \\nIntermediate quantities attained directly from the field / kinematic variables.\\n\\u00a0       const double &get_det_F() const;\\n\\u00a0 \\n\\u00a0       const SymmetricTensor<2, dim> &get_C_inv() const;\\n\\u00a0 \\n\\u00a0       const double &get_log_det_F() const;\\n\\u00a0 \\n\\u00a0       const double &get_trace_C() const;\\n\\u00a0 \\n\\u00a0       const Tensor<1, dim> &get_C_inv_dot_H() const;\\n\\u00a0 \\n\\u00a0       const double &get_H_dot_C_inv_dot_H() const;\\n\\u00a0 \\nFirst derivatives of the intermediate quantities.\\n\\u00a0       const SymmetricTensor<4, dim> &get_dC_inv_dC() const;\\n\\u00a0 \\n\\u00a0       const SymmetricTensor<2, dim> &get_d_tr_C_dC() const;\\n\\u00a0 \\n\\u00a0       const SymmetricTensor<2, dim> &get_ddet_F_dC() const;\\n\\u00a0 \\n\\u00a0       const SymmetricTensor<2, dim> &get_dlog_det_F_dC() const;\\n\\u00a0 \\n\\u00a0       const Tensor<1, dim> &get_dH_dot_C_inv_dot_H_dH() const;\\n\\u00a0 \\n\\u00a0       const SymmetricTensor<2, dim> &get_dH_dot_C_inv_dot_H_dC() const;\\n\\u00a0 \\nDerivative of internal variable with respect to field variables. Notice that we only need this one derivative of the internal variable, as this variable is only differentiated as part of the linearization of the kinetic variables.\\n\\u00a0       const SymmetricTensor<4, dim> &\\n\\u00a0       get_dQ_t_dC(const DiscreteTime &time) const;\\n\\u00a0 \\nSecond derivatives of the intermediate quantities.\\n\\u00a0       const SymmetricTensor<4, dim> &get_d2log_det_F_dC_dC() const;\\n\\u00a0 \\n\\u00a0       const SymmetricTensor<4, dim> &get_d2det_F_dC_dC() const;\\n\\u00a0 \\n\\u00a0       const SymmetricTensor<2, dim> &get_d2H_dot_C_inv_dot_H_dH_dH() const;\\n\\u00a0 \\n\\u00a0       const Tensor<3, dim> &get_d2H_dot_C_inv_dot_H_dC_dH() const;\\n\\u00a0 \\n\\u00a0       const SymmetricTensor<4, dim> &get_d2H_dot_C_inv_dot_H_dC_dC() const;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<\\n\\u00a0       dim>::Magnetoviscoelastic_Constitutive_Law(const ConstitutiveParameters\\n\\u00a0                                                    &constitutive_parameters)\\n\\u00a0       : Coupled_Magnetomechanical_Constitutive_Law_Base<dim>(\\n\\u00a0           constitutive_parameters)\\n\\u00a0       , Q_t(Physics::Elasticity::StandardTensors<dim>::I)\\n\\u00a0       , Q_t1(Physics::Elasticity::StandardTensors<dim>::I)\\n\\u00a0       , psi(0.0)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void Magnetoviscoelastic_Constitutive_Law<dim>::update_internal_data(\\n\\u00a0       const SymmetricTensor<2, dim> &C,\\n\\u00a0       const Tensor<1, dim>          &H,\\n\\u00a0       const DiscreteTime            &time)\\n\\u00a0     {\\nint\\nRecord the applied deformation state as well as the magnetic load. Thereafter, update internal (viscous) variable based on new deformation state.\\n\\u00a0       set_primary_variables(C, H);\\n\\u00a0       update_internal_variable(time);\\n\\u00a0 \\nGet the values for the elastic and viscous saturation function based on the current magnetic field...\\n\\u00a0       const double f_mu_e = get_f_mu(this->get_mu_e(),\\n\\u00a0                                      this->get_mu_e_inf(),\\n\\u00a0                                      this->get_mu_e_h_sat());\\n\\u00a0 \\n\\u00a0       const double f_mu_v = get_f_mu(this->get_mu_v(),\\n\\u00a0                                      this->get_mu_v_inf(),\\n\\u00a0                                      this->get_mu_v_h_sat());\\n\\u00a0 \\n... as well as their first derivatives...\\n\\u00a0       const Tensor<1, dim> df_mu_e_dH = get_df_mu_dH(this->get_mu_e(),\\n\\u00a0                                                      this->get_mu_e_inf(),\\n\\u00a0                                                      this->get_mu_e_h_sat());\\n\\u00a0 \\n\\u00a0       const Tensor<1, dim> df_mu_v_dH = get_df_mu_dH(this->get_mu_v(),\\n\\u00a0                                                      this->get_mu_v_inf(),\\n\\u00a0                                                      this->get_mu_v_h_sat());\\n\\u00a0 \\n\\u00a0 \\n... and their second derivatives.\\n\\u00a0       const SymmetricTensor<2, dim> d2f_mu_e_dH_dH =\\n\\u00a0         get_d2f_mu_dH_dH(this->get_mu_e(),\\n\\u00a0                          this->get_mu_e_inf(),\\n\\u00a0                          this->get_mu_e_h_sat());\\n\\u00a0 \\n\\u00a0       const SymmetricTensor<2, dim> d2f_mu_v_dH_dH =\\n\\u00a0         get_d2f_mu_dH_dH(this->get_mu_v(),\\n\\u00a0                          this->get_mu_v_inf(),\\n\\u00a0                          this->get_mu_v_h_sat());\\n\\u00a0 \\nIntermediate quantities. Note that, since we're fetching these values from a cache that has a lifetime that outlasts this function call, we can alias the result rather than copying the value from the cache.\\n\\u00a0       const double                  &det_F = get_det_F();\\n\\u00a0       const SymmetricTensor<2, dim> &C_inv = get_C_inv();\\n\\u00a0 \\n\\u00a0       const double &log_det_F         = get_log_det_F();\\n\\u00a0       const double &tr_C              = get_trace_C();\\n\\u00a0       const double &H_dot_C_inv_dot_H = get_H_dot_C_inv_dot_H();\\n\\u00a0 \\nFirst derivatives of intermediate values, as well as the that of the internal variable with respect to the right Cauchy-Green deformation tensor.\\n\\u00a0       const SymmetricTensor<2, dim> &d_tr_C_dC     = get_d_tr_C_dC();\\n\\u00a0       const SymmetricTensor<2, dim> &ddet_F_dC     = get_ddet_F_dC();\\n\\u00a0       const SymmetricTensor<2, dim> &dlog_det_F_dC = get_dlog_det_F_dC();\\n\\u00a0 \\n\\u00a0       const SymmetricTensor<4, dim> &dQ_t_dC = get_dQ_t_dC(time);\\n\\u00a0 \\n\\u00a0       const Tensor<1, dim> &dH_dot_C_inv_dot_H_dH = get_dH_dot_C_inv_dot_H_dH();\\n\\u00a0 \\n\\u00a0       const SymmetricTensor<2, dim> &dH_dot_C_inv_dot_H_dC =\\n\\u00a0         get_dH_dot_C_inv_dot_H_dC();\\n\\u00a0 \\nSecond derivatives of intermediate values.\\n\\u00a0       const SymmetricTensor<4, dim> &d2log_det_F_dC_dC =\\n\\u00a0         get_d2log_det_F_dC_dC();\\n\\u00a0 \\n\\u00a0       const SymmetricTensor<4, dim> &d2det_F_dC_dC = get_d2det_F_dC_dC();\\n\\u00a0 \\n\\u00a0       const SymmetricTensor<2, dim> &d2H_dot_C_inv_dot_H_dH_dH =\\n\\u00a0         get_d2H_dot_C_inv_dot_H_dH_dH();\\n\\u00a0 \\n\\u00a0       const Tensor<3, dim> &d2H_dot_C_inv_dot_H_dC_dH =\\n\\u00a0         get_d2H_dot_C_inv_dot_H_dC_dH();\\n\\u00a0 \\n\\u00a0       const SymmetricTensor<4, dim> &d2H_dot_C_inv_dot_H_dC_dC =\\n\\u00a0         get_d2H_dot_C_inv_dot_H_dC_dC();\\n\\u00a0 \\nSince the definitions of the linearizations become particularly lengthy, we'll decompose the free energy density function into three additive components:\\nthe \\\"Neo-Hookean\\\"-like term,\\nthe rate-dependent term, and\\nthe term that resembles that of the energy stored in the magnetic field.\\n\\nTo remain consistent, each of these contributions will be individually added to the variables that we want to compute in that same order.\\nSo, first of all this is the energy density function itself:\\n\\u00a0       psi = (0.5 * this->get_mu_e() * f_mu_e) *\\n\\u00a0               (tr_C - dim - 2.0 * std::log(det_F)) +\\n\\u00a0             this->get_lambda_e() * (std::log(det_F) * std::log(det_F));\\n\\u00a0       psi += (0.5 * this->get_mu_v() * f_mu_v) *\\n\\u00a0              (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -\\n\\u00a0               std::log(determinant(Q_t)));\\n\\u00a0       psi -=\\n\\u00a0         (0.5 * this->get_mu_0() * this->get_mu_r()) * det_F * (H * C_inv * H);\\n\\u00a0 \\n... followed by the magnetic induction vector and Piola-Kirchhoff stress:\\n\\u00a0       B =\\n\\u00a0         -(0.5 * this->get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * df_mu_e_dH;\\n\\u00a0       B -= (0.5 * this->get_mu_v()) *\\n\\u00a0            (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -\\n\\u00a0             std::log(determinant(Q_t))) *\\n\\u00a0            df_mu_v_dH;\\n\\u00a0       B += 0.5 * this->get_mu_0() * this->get_mu_r() * det_F *\\n\\u00a0            dH_dot_C_inv_dot_H_dH;\\n\\u00a0 \\n\\u00a0       S = 2.0 * (0.5 * this->get_mu_e() * f_mu_e) *                         \\n\\u00a0             (d_tr_C_dC - 2.0 * dlog_det_F_dC)                               \\n\\u00a0           + 2.0 * this->get_lambda_e() * (2.0 * log_det_F * dlog_det_F_dC); \\n\\u00a0       S += 2.0 * (0.5 * this->get_mu_v() * f_mu_v) *\\n\\u00a0            ((Q_t * C) *\\n\\u00a0               ((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) * ddet_F_dC) +\\n\\u00a0             std::pow(det_F, -2.0 / dim) * Q_t);                // dC/dC = II\\n\\u00a0       S -= 2.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) * \\n\\u00a0            (H_dot_C_inv_dot_H * ddet_F_dC                      \\n\\u00a0             + det_F * dH_dot_C_inv_dot_H_dC);                  \\n\\u00a0 \\n... and lastly the tangents due to the linearization of the kinetic variables.\\n\\u00a0       BB = -(0.5 * this->get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) *\\n\\u00a0            d2f_mu_e_dH_dH;\\n\\u00a0       BB -= (0.5 * this->get_mu_v()) *\\n\\u00a0             (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -\\n\\u00a0              std::log(determinant(Q_t))) *\\n\\u00a0             d2f_mu_v_dH_dH;\\n\\u00a0       BB += 0.5 * this->get_mu_0() * this->get_mu_r() * det_F *\\n\\u00a0             d2H_dot_C_inv_dot_H_dH_dH;\\n\\u00a0 \\n\\u00a0       PP = -2.0 * (0.5 * this->get_mu_e()) *\\n\\u00a0            outer_product(Tensor<2, dim>(d_tr_C_dC - 2.0 * dlog_det_F_dC),\\n\\u00a0                          df_mu_e_dH);\\n\\u00a0       PP -= 2.0 * (0.5 * this->get_mu_v()) *\\n\\u00a0             outer_product(Tensor<2, dim>((Q_t * C) *\\n\\u00a0                                            ((-2.0 / dim) *\\n\\u00a0                                             std::pow(det_F, -2.0 / dim - 1.0) *\\n\\u00a0                                             ddet_F_dC) +\\n\\u00a0                                          std::pow(det_F, -2.0 / dim) * Q_t),\\n\\u00a0                           df_mu_v_dH);\\n\\u00a0       PP += 2.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) *\\n\\u00a0             (outer_product(Tensor<2, dim>(ddet_F_dC), dH_dot_C_inv_dot_H_dH) +\\n\\u00a0              det_F * d2H_dot_C_inv_dot_H_dC_dH);\\n\\u00a0 \\n\\u00a0       HH =\\n\\u00a0         4.0 * (0.5 * this->get_mu_e() * f_mu_e) * (-2.0 * d2log_det_F_dC_dC) \\n\\u00a0         + 4.0 * this->get_lambda_e() *                                       \\n\\u00a0             (2.0 * outer_product(dlog_det_F_dC, dlog_det_F_dC)               \\n\\u00a0              + 2.0 * log_det_F * d2log_det_F_dC_dC);                         \\n\\u00a0       HH += 4.0 * (0.5 * this->get_mu_v() * f_mu_v) *\\n\\u00a0             (outer_product((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *\\n\\u00a0                              ddet_F_dC,\\n\\u00a0                            C * dQ_t_dC + Q_t) +\\n\\u00a0              (Q_t * C) *\\n\\u00a0                (outer_product(ddet_F_dC,\\n\\u00a0                               (-2.0 / dim) * (-2.0 / dim - 1.0) *\\n\\u00a0                                 std::pow(det_F, -2.0 / dim - 2.0) * ddet_F_dC) +\\n\\u00a0                 ((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *\\n\\u00a0                  d2det_F_dC_dC)) +\\n\\u00a0              outer_product(Q_t,\\n\\u00a0                            (-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *\\n\\u00a0                              ddet_F_dC) +\\n\\u00a0              std::pow(det_F, -2.0 / dim) * dQ_t_dC);\\n\\u00a0       HH -= 4.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) * \\n\\u00a0             (H_dot_C_inv_dot_H * d2det_F_dC_dC                  \\n\\u00a0              + outer_product(ddet_F_dC, dH_dot_C_inv_dot_H_dC)  \\n\\u00a0              + outer_product(dH_dot_C_inv_dot_H_dC, ddet_F_dC)  \\n\\u00a0              + det_F * d2H_dot_C_inv_dot_H_dC_dC);              \\n\\u00a0 \\n\\u00a0 \\nNow that we're done using all of those temporary variables stored in our cache, we can clear it out to free up some memory.\\n\\u00a0       cache.reset();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double Magnetoviscoelastic_Constitutive_Law<dim>::get_psi() const\\n\\u00a0     {\\n\\u00a0       return psi;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     Tensor<1, dim> Magnetoviscoelastic_Constitutive_Law<dim>::get_B() const\\n\\u00a0     {\\n\\u00a0       return B;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     SymmetricTensor<2, dim>\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_S() const\\n\\u00a0     {\\n\\u00a0       return S;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     SymmetricTensor<2, dim>\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_DD() const\\n\\u00a0     {\\n\\u00a0       return BB;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     Tensor<3, dim> Magnetoviscoelastic_Constitutive_Law<dim>::get_PP() const\\n\\u00a0     {\\n\\u00a0       return PP;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     SymmetricTensor<4, dim>\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_HH() const\\n\\u00a0     {\\n\\u00a0       return HH;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void Magnetoviscoelastic_Constitutive_Law<dim>::update_end_of_timestep()\\n\\u00a0     {\\n\\u00a0       Q_t1 = Q_t;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     void Magnetoviscoelastic_Constitutive_Law<dim>::update_internal_variable(\\n\\u00a0       const DiscreteTime &time)\\n\\u00a0     {\\n\\u00a0       const double delta_t = this->get_delta_t(time);\\n\\u00a0 \\n\\u00a0       Q_t = (1.0 / (1.0 + delta_t / this->get_tau_v())) *\\n\\u00a0             (Q_t1 + (delta_t / this->get_tau_v()) *\\n\\u00a0                       std::pow(get_det_F(), 2.0 / dim) * get_C_inv());\\n\\u00a0     }\\n\\u00a0 \\nThe next few functions implement the generalized formulation for the saturation function, as well as its various derivatives.\\n\\u00a0     template <int dim>\\n\\u00a0     double\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_two_h_dot_h_div_h_sat_squ(\\n\\u00a0       const double mu_h_sat) const\\n\\u00a0     {\\n\\u00a0       const Tensor<1, dim> &H = get_H();\\n\\u00a0       return (2.0 * H * H) / (mu_h_sat * mu_h_sat);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double Magnetoviscoelastic_Constitutive_Law<\\n\\u00a0       dim>::get_tanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const\\n\\u00a0     {\\n\\u00a0       return std::tanh(get_two_h_dot_h_div_h_sat_squ(mu_h_sat));\\n\\u00a0     }\\n\\u00a0 \\nA scaling function that will cause the shear modulus to change (increase) under the influence of a magnetic field.\\n\\u00a0     template <int dim>\\n\\u00a0     double Magnetoviscoelastic_Constitutive_Law<dim>::get_f_mu(\\n\\u00a0       const double mu,\\n\\u00a0       const double mu_inf,\\n\\u00a0       const double mu_h_sat) const\\n\\u00a0     {\\n\\u00a0       return 1.0 +\\n\\u00a0              (mu_inf / mu - 1.0) * get_tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat);\\n\\u00a0     }\\n\\u00a0 \\nFirst derivative of scaling function\\n\\u00a0     template <int dim>\\n\\u00a0     double Magnetoviscoelastic_Constitutive_Law<\\n\\u00a0       dim>::get_dtanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const\\n\\u00a0     {\\n\\u00a0       return std::pow(1.0 / std::cosh(get_two_h_dot_h_div_h_sat_squ(mu_h_sat)),\\n\\u00a0                       2.0);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     Tensor<1, dim> Magnetoviscoelastic_Constitutive_Law<\\n\\u00a0       dim>::get_dtwo_h_dot_h_div_h_sat_squ_dH(const double mu_h_sat) const\\n\\u00a0     {\\n\\u00a0       return 2.0 * 2.0 / (mu_h_sat * mu_h_sat) * get_H();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     Tensor<1, dim> Magnetoviscoelastic_Constitutive_Law<dim>::get_df_mu_dH(\\n\\u00a0       const double mu,\\n\\u00a0       const double mu_inf,\\n\\u00a0       const double mu_h_sat) const\\n\\u00a0     {\\n\\u00a0       return (mu_inf / mu - 1.0) *\\n\\u00a0              (get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *\\n\\u00a0               get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat));\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     double Magnetoviscoelastic_Constitutive_Law<\\n\\u00a0       dim>::get_d2tanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const\\n\\u00a0     {\\n\\u00a0       return -2.0 * get_tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *\\n\\u00a0              get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     SymmetricTensor<2, dim> Magnetoviscoelastic_Constitutive_Law<\\n\\u00a0       dim>::get_d2two_h_dot_h_div_h_sat_squ_dH_dH(const double mu_h_sat) const\\n\\u00a0     {\\n\\u00a0       return 2.0 * 2.0 / (mu_h_sat * mu_h_sat) *\\n\\u00a0              Physics::Elasticity::StandardTensors<dim>::I;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     SymmetricTensor<2, dim>\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_d2f_mu_dH_dH(\\n\\u00a0       const double mu,\\n\\u00a0       const double mu_inf,\\n\\u00a0       const double mu_h_sat) const\\n\\u00a0     {\\n\\u00a0       return (mu_inf / mu - 1.0) *\\n\\u00a0              (get_d2tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *\\n\\u00a0                 symmetrize(\\n\\u00a0                   outer_product(get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat),\\n\\u00a0                                 get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat))) +\\n\\u00a0               get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *\\n\\u00a0                 get_d2two_h_dot_h_div_h_sat_squ_dH_dH(mu_h_sat));\\n\\u00a0     }\\n\\u00a0 \\nFor the cached calculation approach that we've adopted for this material class, the root of all calculations are the field variables, and the immutable ancillary data such as the constitutive parameters and time step size. As such, we need to enter them into the cache in a different manner to the other variables, since they are inputs that are prescribed from outside the class itself. This function simply adds them to the cache directly from the input arguments, checking that there is no equivalent data there in the first place (we expect to call the update_internal_data() method only once per time step, or Newton iteration).\\n\\u00a0     template <int dim>\\n\\u00a0     void Magnetoviscoelastic_Constitutive_Law<dim>::set_primary_variables(\\n\\u00a0       const SymmetricTensor<2, dim> &C,\\n\\u00a0       const Tensor<1, dim>          &H) const\\n\\u00a0     {\\nSet value for \\\\(\\\\boldsymbol{\\\\mathbb{H}}\\\\).\\n\\u00a0       const std::string name_H(\\\"H\\\");\\n\\u00a0       Assert(!cache.stores_object_with_name(name_H),\\n\\u00a0              ExcMessage(\\n\\u00a0                \\\"The primary variable has already been added to the cache.\\\"));\\n\\u00a0       cache.add_unique_copy(name_H, H);\\n\\u00a0 \\nSet value for \\\\(\\\\mathbf{C}\\\\).\\n\\u00a0       const std::string name_C(\\\"C\\\");\\n\\u00a0       Assert(!cache.stores_object_with_name(name_C),\\n\\u00a0              ExcMessage(\\n\\u00a0                \\\"The primary variable has already been added to the cache.\\\"));\\n\\u00a0       cache.add_unique_copy(name_C, C);\\n\\u00a0     }\\n\\u00a0 \\nAfter that, we can fetch them from the cache at any point in time.\\n\\u00a0     template <int dim>\\n\\u00a0     const Tensor<1, dim> &\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_H() const\\n\\u00a0     {\\n\\u00a0       const std::string name(\\\"H\\\");\\n\\u00a0       Assert(cache.stores_object_with_name(name),\\n\\u00a0              ExcMessage(\\\"Primary variables must be added to the cache.\\\"));\\n\\u00a0       return cache.template get_object_with_name<Tensor<1, dim>>(name);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     const SymmetricTensor<2, dim> &\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_C() const\\n\\u00a0     {\\n\\u00a0       const std::string name(\\\"C\\\");\\n\\u00a0       Assert(cache.stores_object_with_name(name),\\n\\u00a0              ExcMessage(\\\"Primary variables must be added to the cache.\\\"));\\n\\u00a0       return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);\\n\\u00a0     }\\n\\u00a0 \\nWith the primary variables guaranteed to be in the cache when we need them, we can not compute all intermediate values (either directly, or indirectly) from them.\\nIf the cache does not already store the value that we're looking for, then we quickly calculate it, store it in the cache and return the value just stored in the cache. That way we can return it as a reference and avoid copying the object. The same goes for any values that a compound function might depend on. Said another way, if there is a dependency chain of calculations that come before the one that we're currently interested in doing, then we're guaranteed to resolve the dependencies before we proceed with using any of those values. Although there is a cost to fetching data from the cache, the \\\"resolved dependency\\\" concept might be sufficiently convenient to make it worth looking past the extra cost. If these material laws are embedded within a finite element framework, then the added cost might not even be noticeable.\\n\\u00a0     template <int dim>\\n\\u00a0     const double &Magnetoviscoelastic_Constitutive_Law<dim>::get_det_F() const\\n\\u00a0     {\\n\\u00a0       const std::string name(\\\"det_F\\\");\\n\\u00a0       if (cache.stores_object_with_name(name) == false)\\n\\u00a0         {\\n\\u00a0           const double det_F = std::sqrt(determinant(get_C()));\\n\\u00a0           AssertThrow(det_F > 0.0,\\n\\u00a0                       ExcMessage(\\\"Volumetric Jacobian must be positive.\\\"));\\n\\u00a0           cache.add_unique_copy(name, det_F);\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0       return cache.template get_object_with_name<double>(name);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     const SymmetricTensor<2, dim> &\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_C_inv() const\\n\\u00a0     {\\n\\u00a0       const std::string name(\\\"C_inv\\\");\\n\\u00a0       if (cache.stores_object_with_name(name) == false)\\n\\u00a0         {\\n\\u00a0           cache.add_unique_copy(name, invert(get_C()));\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0       return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     const double &\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_log_det_F() const\\n\\u00a0     {\\n\\u00a0       const std::string name(\\\"log(det_F)\\\");\\n\\u00a0       if (cache.stores_object_with_name(name) == false)\\n\\u00a0         cache.add_unique_copy(name, std::log(get_det_F()));\\n\\u00a0 \\n\\u00a0       return cache.template get_object_with_name<double>(name);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     const double &Magnetoviscoelastic_Constitutive_Law<dim>::get_trace_C() const\\n\\u00a0     {\\n\\u00a0       const std::string name(\\\"trace(C)\\\");\\n\\u00a0       if (cache.stores_object_with_name(name) == false)\\n\\u00a0         cache.add_unique_copy(name, trace(get_C()));\\n\\u00a0 \\n\\u00a0       return cache.template get_object_with_name<double>(name);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     const Tensor<1, dim> &\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_C_inv_dot_H() const\\n\\u00a0     {\\n\\u00a0       const std::string name(\\\"C_inv_dot_H\\\");\\n\\u00a0       if (cache.stores_object_with_name(name) == false)\\n\\u00a0         cache.add_unique_copy(name, get_C_inv() * get_H());\\n\\u00a0 \\n\\u00a0       return cache.template get_object_with_name<Tensor<1, dim>>(name);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     const double &\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_H_dot_C_inv_dot_H() const\\n\\u00a0     {\\n\\u00a0       const std::string name(\\\"H_dot_C_inv_dot_H\\\");\\n\\u00a0       if (cache.stores_object_with_name(name) == false)\\n\\u00a0         cache.add_unique_copy(name, get_H() * get_C_inv_dot_H());\\n\\u00a0 \\n\\u00a0       return cache.template get_object_with_name<double>(name);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     const SymmetricTensor<4, dim> &\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_dQ_t_dC(\\n\\u00a0       const DiscreteTime &time) const\\n\\u00a0     {\\n\\u00a0       const std::string name(\\\"dQ_t_dC\\\");\\n\\u00a0       if (cache.stores_object_with_name(name) == false)\\n\\u00a0         {\\n\\u00a0           const double  delta_t = this->get_delta_t(time);\\n\\u00a0           const double &det_F   = get_det_F();\\n\\u00a0 \\n\\u00a0           const SymmetricTensor<4, dim> dQ_t_dC =\\n\\u00a0             (1.0 / (1.0 + delta_t / this->get_tau_v())) *\\n\\u00a0             (delta_t / this->get_tau_v()) *\\n\\u00a0             ((2.0 / dim) * std::pow(det_F, 2.0 / dim - 1.0) *\\n\\u00a0                outer_product(get_C_inv(), get_ddet_F_dC()) +\\n\\u00a0              std::pow(det_F, 2.0 / dim) * get_dC_inv_dC());\\n\\u00a0 \\n\\u00a0           cache.add_unique_copy(name, dQ_t_dC);\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0       return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     const SymmetricTensor<4, dim> &\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_dC_inv_dC() const\\n\\u00a0     {\\n\\u00a0       const std::string name(\\\"dC_inv_dC\\\");\\n\\u00a0       if (cache.stores_object_with_name(name) == false)\\n\\u00a0         {\\n\\u00a0           const SymmetricTensor<2, dim> &C_inv = get_C_inv();\\n\\u00a0           SymmetricTensor<4, dim>        dC_inv_dC;\\n\\u00a0 \\n\\u00a0           for (unsigned int A = 0; A < dim; ++A)\\n\\u00a0             for (unsigned int B = A; B < dim; ++B)\\n\\u00a0               for (unsigned int C = 0; C < dim; ++C)\\n\\u00a0                 for (unsigned int D = C; D < dim; ++D)\\n\\u00a0                   dC_inv_dC[A][B][C][D] -=               \\n\\u00a0                     0.5 * (C_inv[A][C] * C_inv[B][D]     \\n\\u00a0                            + C_inv[A][D] * C_inv[B][C]); \\n\\u00a0 \\n\\u00a0           cache.add_unique_copy(name, dC_inv_dC);\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0       return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     const SymmetricTensor<2, dim> &\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_d_tr_C_dC() const\\n\\u00a0     {\\n\\u00a0       const std::string name(\\\"d_tr_C_dC\\\");\\n\\u00a0       if (cache.stores_object_with_name(name) == false)\\n\\u00a0         cache.add_unique_copy(name,\\n\\u00a0                               Physics::Elasticity::StandardTensors<dim>::I);\\n\\u00a0 \\n\\u00a0       return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     const SymmetricTensor<2, dim> &\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_ddet_F_dC() const\\n\\u00a0     {\\n\\u00a0       const std::string name(\\\"ddet_F_dC\\\");\\n\\u00a0       if (cache.stores_object_with_name(name) == false)\\n\\u00a0         cache.add_unique_copy(name, 0.5 * get_det_F() * get_C_inv());\\n\\u00a0 \\n\\u00a0       return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     const SymmetricTensor<2, dim> &\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_dlog_det_F_dC() const\\n\\u00a0     {\\n\\u00a0       const std::string name(\\\"dlog_det_F_dC\\\");\\n\\u00a0       if (cache.stores_object_with_name(name) == false)\\n\\u00a0         cache.add_unique_copy(name, 0.5 * get_C_inv());\\n\\u00a0 \\n\\u00a0       return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     const Tensor<1, dim> &\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_dH_dot_C_inv_dot_H_dH() const\\n\\u00a0     {\\n\\u00a0       const std::string name(\\\"dH_dot_C_inv_dot_H_dH\\\");\\n\\u00a0       if (cache.stores_object_with_name(name) == false)\\n\\u00a0         cache.add_unique_copy(name, 2.0 * get_C_inv_dot_H());\\n\\u00a0 \\n\\u00a0       return cache.template get_object_with_name<Tensor<1, dim>>(name);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     const SymmetricTensor<2, dim> &\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_dH_dot_C_inv_dot_H_dC() const\\n\\u00a0     {\\n\\u00a0       const std::string name(\\\"dH_dot_C_inv_dot_H_dC\\\");\\n\\u00a0       if (cache.stores_object_with_name(name) == false)\\n\\u00a0         {\\n\\u00a0           const Tensor<1, dim> C_inv_dot_H = get_C_inv_dot_H();\\n\\u00a0           cache.add_unique_copy(\\n\\u00a0             name, -symmetrize(outer_product(C_inv_dot_H, C_inv_dot_H)));\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0       return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     const SymmetricTensor<4, dim> &\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_d2log_det_F_dC_dC() const\\n\\u00a0     {\\n\\u00a0       const std::string name(\\\"d2log_det_F_dC_dC\\\");\\n\\u00a0       if (cache.stores_object_with_name(name) == false)\\n\\u00a0         cache.add_unique_copy(name, 0.5 * get_dC_inv_dC());\\n\\u00a0 \\n\\u00a0       return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     const SymmetricTensor<4, dim> &\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_d2det_F_dC_dC() const\\n\\u00a0     {\\n\\u00a0       const std::string name(\\\"d2det_F_dC_dC\\\");\\n\\u00a0       if (cache.stores_object_with_name(name) == false)\\n\\u00a0         cache.add_unique_copy(name,\\n\\u00a0                               0.5 *\\n\\u00a0                                 (outer_product(get_C_inv(), get_ddet_F_dC()) +\\n\\u00a0                                  get_det_F() * get_dC_inv_dC()));\\n\\u00a0 \\n\\u00a0       return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     const SymmetricTensor<2, dim> &\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_d2H_dot_C_inv_dot_H_dH_dH()\\n\\u00a0       const\\n\\u00a0     {\\n\\u00a0       const std::string name(\\\"d2H_dot_C_inv_dot_H_dH_dH\\\");\\n\\u00a0       if (cache.stores_object_with_name(name) == false)\\n\\u00a0         cache.add_unique_copy(name, 2.0 * get_C_inv());\\n\\u00a0 \\n\\u00a0       return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     const Tensor<3, dim> &\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_d2H_dot_C_inv_dot_H_dC_dH()\\n\\u00a0       const\\n\\u00a0     {\\n\\u00a0       const std::string name(\\\"d2H_dot_C_inv_dot_H_dC_dH\\\");\\n\\u00a0       if (cache.stores_object_with_name(name) == false)\\n\\u00a0         {\\n\\u00a0           const Tensor<1, dim>          &C_inv_dot_H = get_C_inv_dot_H();\\n\\u00a0           const SymmetricTensor<2, dim> &C_inv       = get_C_inv();\\n\\u00a0 \\n\\u00a0           Tensor<3, dim> d2H_dot_C_inv_dot_H_dC_dH;\\n\\u00a0           for (unsigned int A = 0; A < dim; ++A)\\n\\u00a0             for (unsigned int B = 0; B < dim; ++B)\\n\\u00a0               for (unsigned int C = 0; C < dim; ++C)\\n\\u00a0                 d2H_dot_C_inv_dot_H_dC_dH[A][B][C] -=\\n\\u00a0                   C_inv[A][C] * C_inv_dot_H[B] + \\n\\u00a0                   C_inv_dot_H[A] * C_inv[B][C];  \\n\\u00a0 \\n\\u00a0           cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dH);\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0       return cache.template get_object_with_name<Tensor<3, dim>>(name);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     template <int dim>\\n\\u00a0     const SymmetricTensor<4, dim> &\\n\\u00a0     Magnetoviscoelastic_Constitutive_Law<dim>::get_d2H_dot_C_inv_dot_H_dC_dC()\\n\\u00a0       const\\n\\u00a0     {\\n\\u00a0       const std::string name(\\\"d2H_dot_C_inv_dot_H_dC_dC\\\");\\n\\u00a0       if (cache.stores_object_with_name(name) == false)\\n\\u00a0         {\\n\\u00a0           const Tensor<1, dim>          &C_inv_dot_H = get_C_inv_dot_H();\\n\\u00a0           const SymmetricTensor<2, dim> &C_inv       = get_C_inv();\\n\\u00a0 \\n\\u00a0           SymmetricTensor<4, dim> d2H_dot_C_inv_dot_H_dC_dC;\\n\\u00a0           for (unsigned int A = 0; A < dim; ++A)\\n\\u00a0             for (unsigned int B = A; B < dim; ++B)\\n\\u00a0               for (unsigned int C = 0; C < dim; ++C)\\n\\u00a0                 for (unsigned int D = C; D < dim; ++D)\\n\\u00a0                   d2H_dot_C_inv_dot_H_dC_dC[A][B][C][D] +=\\n\\u00a0                     0.5 * (C_inv_dot_H[A] * C_inv_dot_H[C] * C_inv[B][D] +\\n\\u00a0                            C_inv_dot_H[A] * C_inv_dot_H[D] * C_inv[B][C] +\\n\\u00a0                            C_inv_dot_H[B] * C_inv_dot_H[C] * C_inv[A][D] +\\n\\u00a0                            C_inv_dot_H[B] * C_inv_dot_H[D] * C_inv[A][C]);\\n\\u00a0 \\n\\u00a0           cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dC);\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0       return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name);\\n\\u00a0     }\\n\\u00a0 \\nPhysics::Elasticity::Kinematics::CSymmetricTensor< 2, dim, Number > C(const Tensor< 2, dim, Number > &F)\\n Rheological experiment parameters\\nThe RheologicalExperimentParameters class is used to drive the numerical experiments that are to be conducted on the coupled materials that we've implemented constitutive laws for.\\n\\u00a0     class RheologicalExperimentParameters : public ParameterAcceptor\\n\\u00a0     {\\n\\u00a0     public:\\n\\u00a0       RheologicalExperimentParameters();\\n\\u00a0 \\nThese are dimensions of the rheological specimen that is to be simulated. They, effectively, define the measurement point for our virtual experiment.\\n\\u00a0       double sample_radius = 0.01;\\n\\u00a0       double sample_height = 0.001;\\n\\u00a0 \\nThe three steady-state loading parameters are respectively\\nthe axial stretch,\\nthe shear strain amplitude, and\\nthe axial magnetic field strength.\\n\\n\\u00a0       double lambda_2 = 0.95;\\n\\u00a0       double gamma_12 = 0.05;\\n\\u00a0       double H_2      = 60.0e3;\\n\\u00a0 \\nMoreover, the parameters for the time-dependent rheological loading conditions are\\nthe loading cycle frequency,\\nthe number of load cycles, and\\nthe number of discrete timesteps per cycle.\\n\\n\\u00a0       double       frequency         = 1.0 / (2.0 * numbers::PI);\\n\\u00a0       unsigned int n_cycles          = 5;\\n\\u00a0       unsigned int n_steps_per_cycle = 2500;\\n\\u00a0 \\nWe also declare some self-explanatory parameters related to output data generated for the experiments conducted with rate-dependent and rate-independent materials.\\n\\u00a0       bool        output_data_to_file = true;\\n\\u00a0       std::string output_filename_rd =\\n\\u00a0         \\\"experimental_results-rate_dependent.csv\\\";\\n\\u00a0       std::string output_filename_ri =\\n\\u00a0         \\\"experimental_results-rate_independent.csv\\\";\\n\\u00a0 \\nThe next few functions compute time-related parameters for the experiment...\\n\\u00a0       double start_time() const;\\n\\u00a0 \\n\\u00a0       double end_time() const;\\n\\u00a0 \\n\\u00a0       double delta_t() const;\\n\\u00a0 \\n... while the following two prescribe the mechanical and magnetic loading at any given time...\\n\\u00a0       Tensor<1, 3> get_H(const double time) const;\\n\\u00a0 \\n\\u00a0       Tensor<2, 3> get_F(const double time) const;\\n\\u00a0 \\n... and this last one outputs the status of the experiment to the console.\\n\\u00a0       bool print_status(const int step_number) const;\\n\\u00a0 \\n\\u00a0       bool initialized = false;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     RheologicalExperimentParameters::RheologicalExperimentParameters()\\n\\u00a0       : ParameterAcceptor(\\\"/Coupled Constitutive Laws/Rheological Experiment/\\\")\\n\\u00a0     {\\n\\u00a0       add_parameter(\\\"Experimental sample radius\\\", sample_radius);\\n\\u00a0       add_parameter(\\\"Experimental sample radius\\\", sample_height);\\n\\u00a0 \\n\\u00a0       add_parameter(\\\"Axial stretch\\\", lambda_2);\\n\\u00a0       add_parameter(\\\"Shear strain amplitude\\\", gamma_12);\\n\\u00a0       add_parameter(\\\"Axial magnetic field strength\\\", H_2);\\n\\u00a0 \\n\\u00a0       add_parameter(\\\"Frequency\\\", frequency);\\n\\u00a0       add_parameter(\\\"Number of loading cycles\\\", n_cycles);\\n\\u00a0       add_parameter(\\\"Discretisation for each cycle\\\", n_steps_per_cycle);\\n\\u00a0 \\n\\u00a0       add_parameter(\\\"Output experimental results to file\\\", output_data_to_file);\\n\\u00a0       add_parameter(\\\"Output file name (rate dependent constitutive law)\\\",\\n\\u00a0                     output_filename_rd);\\n\\u00a0       add_parameter(\\\"Output file name (rate independent constitutive law)\\\",\\n\\u00a0                     output_filename_ri);\\n\\u00a0 \\n\\u00a0       parse_parameters_call_back.connect([&]() -> void { initialized = true; });\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     double RheologicalExperimentParameters::start_time() const\\n\\u00a0     {\\n\\u00a0       return 0.0;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     double RheologicalExperimentParameters::end_time() const\\n\\u00a0     {\\n\\u00a0       return n_cycles / frequency;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     double RheologicalExperimentParameters::delta_t() const\\n\\u00a0     {\\n\\u00a0       return (end_time() - start_time()) / (n_steps_per_cycle * n_cycles);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     bool\\n\\u00a0     RheologicalExperimentParameters::print_status(const int step_number) const\\n\\u00a0     {\\n\\u00a0       return (step_number % (n_cycles * n_steps_per_cycle / 100)) == 0;\\n\\u00a0     }\\n\\u00a0 \\nThe applied magnetic field is always aligned with the axis of rotation of the rheometer's rotor.\\n\\u00a0     Tensor<1, 3> RheologicalExperimentParameters::get_H(const double) const\\n\\u00a0     {\\n\\u00a0       return Tensor<1, 3>({0.0, 0.0, H_2});\\n\\u00a0     }\\n\\u00a0 \\nThe applied deformation (gradient) is computed based on the geometry of the rheometer and the sample, the sampling point, and the experimental parameters. From the displacement profile documented in the introduction, the deformation gradient may be expressed in Cartesian coordinates as           \\n\\\\[\\n   \\\\mathbf{F} = \\\\begin{bmatrix}\\n   \\\\frac{\\\\cos\\\\left(\\\\alpha\\\\right)}{\\\\sqrt{\\\\lambda_{3}}}\\n   & -\\\\frac{\\\\sin\\\\left(\\\\alpha\\\\right)}{\\\\sqrt{\\\\lambda_{3}}}\\n   & -\\\\tau R \\\\sqrt{\\\\lambda_{3}} \\\\sin\\\\left(\\\\Theta + \\\\alpha\\\\right)\\n   \\\\\\\\  \\\\frac{\\\\sin\\\\left(\\\\alpha\\\\right)}{\\\\sqrt{\\\\lambda_{3}}}\\n   & \\\\frac{\\\\cos\\\\left(\\\\alpha\\\\right)}{\\\\sqrt{\\\\lambda_{3}}}\\n   & -\\\\tau R \\\\sqrt{\\\\lambda_{3}} \\\\cos\\\\left(\\\\Theta + \\\\alpha\\\\right)\\n   \\\\\\\\  0 & 0 & \\\\lambda_{3}\\n   \\\\end{bmatrix}\\n   \\\\]\\n\\n\\u00a0     Tensor<2, 3> RheologicalExperimentParameters::get_F(const double time) const\\n\\u00a0     {\\n\\u00a0       AssertThrow((sample_radius > 0.0 && sample_height > 0.0),\\n\\u00a0                   ExcMessage(\\\"Non-physical sample dimensions\\\"));\\n\\u00a0       AssertThrow(lambda_2 > 0.0,\\n\\u00a0                   ExcMessage(\\\"Non-physical applied axial stretch\\\"));\\n\\u00a0 \\n\\u00a0       const double sqrt_lambda_2     = std::sqrt(lambda_2);\\n\\u00a0       const double inv_sqrt_lambda_2 = 1.0 / sqrt_lambda_2;\\n\\u00a0 \\n\\u00a0       const double alpha_max =\\n\\u00a0         std::atan(std::tan(gamma_12) * sample_height /\\n\\u00a0                   sample_radius); // Small strain approximation\\n\\u00a0       const double A       = sample_radius * alpha_max;\\n\\u00a0       const double w       = 2.0 * numbers::PI * frequency; // in rad /s\\n\\u00a0       const double gamma_t = A * std::sin(w * time);\\n\\u00a0       const double tau_t =\\n\\u00a0         gamma_t /\\n\\u00a0         (sample_radius * sample_height); // Torsion angle per unit length\\n\\u00a0       const double alpha_t = tau_t * lambda_2 * sample_height;\\n\\u00a0 \\n\\u00a0       Tensor<2, 3> F;\\n\\u00a0       F[0][0] = inv_sqrt_lambda_2 * std::cos(alpha_t);\\n\\u00a0       F[0][1] = -inv_sqrt_lambda_2 * std::sin(alpha_t);\\n\\u00a0       F[0][2] = -tau_t * sample_radius * sqrt_lambda_2 * std::sin(alpha_t);\\n\\u00a0       F[1][0] = inv_sqrt_lambda_2 * std::sin(alpha_t);\\n\\u00a0       F[1][1] = inv_sqrt_lambda_2 * std::cos(alpha_t);\\n\\u00a0       F[1][2] = tau_t * sample_radius * sqrt_lambda_2 * std::cos(alpha_t);\\n\\u00a0       F[2][0] = 0.0;\\n\\u00a0       F[2][1] = 0.0;\\n\\u00a0       F[2][2] = lambda_2;\\n\\u00a0 \\n\\u00a0       AssertThrow((F[0][0] > 0) && (F[1][1] > 0) && (F[2][2] > 0),\\n\\u00a0                   ExcMessage(\\\"Non-physical deformation gradient component.\\\"));\\n\\u00a0       AssertThrow(std::abs(determinant(F) - 1.0) < 1e-6,\\n\\u00a0                   ExcMessage(\\\"Volumetric Jacobian is not equal to unity.\\\"));\\n\\u00a0 \\n\\u00a0       return F;\\n\\u00a0     }\\n\\u00a0 \\nstd::tan::VectorizedArray< Number, width > tan(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6629\\nstd::ataninline ::VectorizedArray< Number, width > atan(const ::VectorizedArray< Number, width > &x)Definition vectorization.h:6689\\n Rheological experiment: Parallel plate rotational rheometer\\nThis is the function that will drive the numerical experiments.\\n\\u00a0     template <int dim>\\n\\u00a0     void run_rheological_experiment(\\n\\u00a0       const RheologicalExperimentParameters &experimental_parameters,\\n\\u00a0       Coupled_Magnetomechanical_Constitutive_Law_Base<dim>\\n\\u00a0         &material_hand_calculated,\\n\\u00a0       Coupled_Magnetomechanical_Constitutive_Law_Base<dim>\\n\\u00a0                         &material_assisted_computation,\\n\\u00a0       TimerOutput       &timer,\\n\\u00a0       const std::string &filename)\\n\\u00a0     {\\nTimerOutputDefinition timer.h:549\\nWe can take the hand-implemented constitutive law and compare the results that we attain with it to those that we get using AD or SD. In this way, we can verify that they produce identical results (which indicates that either both implementations have a high probability of being correct, or that they're incorrect with identical flaws being present in both). Either way, it is a decent sanity check for the fully self-implemented variants and can certainly be used as a debugging strategy when differences between the results are detected).\\n\\u00a0       const auto check_material_class_results =\\n\\u00a0         [](\\n\\u00a0           const Coupled_Magnetomechanical_Constitutive_Law_Base<dim> &to_verify,\\n\\u00a0           const Coupled_Magnetomechanical_Constitutive_Law_Base<dim> &blessed,\\n\\u00a0           const double tol = 1e-6) {\\n\\u00a0           (void)to_verify;\\n\\u00a0           (void)blessed;\\n\\u00a0           (void)tol;\\n\\u00a0 \\n\\u00a0           Assert(std::abs(blessed.get_psi() - to_verify.get_psi()) < tol,\\n\\u00a0                  ExcMessage(\\\"No match for psi. Error: \\\" +\\n\\u00a0                             Utilities::to_string(std::abs(\\n\\u00a0                               blessed.get_psi() - to_verify.get_psi()))));\\n\\u00a0 \\n\\u00a0           Assert((blessed.get_B() - to_verify.get_B()).norm() < tol,\\n\\u00a0                  ExcMessage(\\\"No match for B. Error: \\\" +\\n\\u00a0                             Utilities::to_string(\\n\\u00a0                               (blessed.get_B() - to_verify.get_B()).norm())));\\n\\u00a0           Assert((blessed.get_S() - to_verify.get_S()).norm() < tol,\\n\\u00a0                  ExcMessage(\\\"No match for S. Error: \\\" +\\n\\u00a0                             Utilities::to_string(\\n\\u00a0                               (blessed.get_S() - to_verify.get_S()).norm())));\\n\\u00a0 \\n\\u00a0           Assert((blessed.get_DD() - to_verify.get_DD()).norm() < tol,\\n\\u00a0                  ExcMessage(\\\"No match for BB. Error: \\\" +\\n\\u00a0                             Utilities::to_string(\\n\\u00a0                               (blessed.get_DD() - to_verify.get_DD()).norm())));\\n\\u00a0           Assert((blessed.get_PP() - to_verify.get_PP()).norm() < tol,\\n\\u00a0                  ExcMessage(\\\"No match for PP. Error: \\\" +\\n\\u00a0                             Utilities::to_string(\\n\\u00a0                               (blessed.get_PP() - to_verify.get_PP()).norm())));\\n\\u00a0           Assert((blessed.get_HH() - to_verify.get_HH()).norm() < tol,\\n\\u00a0                  ExcMessage(\\\"No match for HH. Error: \\\" +\\n\\u00a0                             Utilities::to_string(\\n\\u00a0                               (blessed.get_HH() - to_verify.get_HH()).norm())));\\n\\u00a0         };\\n\\u00a0 \\nWe'll be outputting the constitutive response of the material to file for post-processing, so here we declare a stream that will act as a buffer for this output. We'll use a simple CSV format for the outputted results.\\n\\u00a0       std::ostringstream stream;\\n\\u00a0       stream\\n\\u00a0         << \\\"Time;Axial magnetic field strength [A/m];Axial magnetic induction [T];Shear strain [%];Shear stress [Pa]\\\\n\\\";\\n\\u00a0 \\nUsing the DiscreteTime class, we iterate through each timestep using a fixed time step size.\\n\\u00a0       for (DiscreteTime time(experimental_parameters.start_time(),\\n\\u00a0                              experimental_parameters.end_time() +\\n\\u00a0                                experimental_parameters.delta_t(),\\n\\u00a0                              experimental_parameters.delta_t());\\n\\u00a0            time.is_at_end() == false;\\n\\u00a0            time.advance_time())\\n\\u00a0         {\\n\\u00a0           if (experimental_parameters.print_status(time.get_step_number()))\\n\\u00a0             std::cout << \\\"Timestep = \\\" << time.get_step_number()\\n\\u00a0                       << \\\" @ time = \\\" << time.get_current_time() << \\\"s.\\\"\\n\\u00a0                       << std::endl;\\n\\u00a0 \\nWe fetch and compute the loading to be applied to the material at this time step...\\n\\u00a0           const Tensor<1, dim> H =\\n\\u00a0             experimental_parameters.get_H(time.get_current_time());\\n\\u00a0           const Tensor<2, dim> F =\\n\\u00a0             experimental_parameters.get_F(time.get_current_time());\\n\\u00a0           const SymmetricTensor<2, dim> C =\\n\\u00a0             Physics::Elasticity::Kinematics::C(F);\\n\\u00a0 \\n... then we update the state of the materials...\\n\\u00a0           {\\n\\u00a0             TimerOutput::Scope timer_section(timer, \\\"Hand calculated\\\");\\n\\u00a0             material_hand_calculated.update_internal_data(C, H, time);\\n\\u00a0             material_hand_calculated.update_end_of_timestep();\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0           {\\n\\u00a0             TimerOutput::Scope timer_section(timer, \\\"Assisted computation\\\");\\n\\u00a0             material_assisted_computation.update_internal_data(C, H, time);\\n\\u00a0             material_assisted_computation.update_end_of_timestep();\\n\\u00a0           }\\n\\u00a0 \\nTimerOutput::ScopeDefinition timer.h:557\\n... and test for discrepancies between the two.\\n\\u00a0           check_material_class_results(material_hand_calculated,\\n\\u00a0                                        material_assisted_computation);\\n\\u00a0 \\n\\u00a0           if (experimental_parameters.output_data_to_file)\\n\\u00a0             {\\nThe next thing that we will do is collect some results to post-process. All quantities are in the \\\"current configuration\\\" (rather than the \\\"reference configuration\\\", in which all quantities computed by the constitutive laws are framed).\\n\\u00a0               const Tensor<1, dim> h =\\n\\u00a0                 Physics::Transformations::Covariant::push_forward(H, F);\\n\\u00a0               const Tensor<1, dim> b =\\n\\u00a0                 Physics::Transformations::Piola::push_forward(\\n\\u00a0                   material_hand_calculated.get_B(), F);\\n\\u00a0               const SymmetricTensor<2, dim> sigma =\\n\\u00a0                 Physics::Transformations::Piola::push_forward(\\n\\u00a0                   material_hand_calculated.get_S(), F);\\n\\u00a0               stream << time.get_current_time() << ';' << h[2] << ';' << b[2]\\n\\u00a0                      << ';' << F[1][2] * 100.0 << ';' << sigma[1][2] << '\\\\n';\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0 \\nPhysics::Transformations::Covariant::push_forwardTensor< 1, dim, Number > push_forward(const Tensor< 1, dim, Number > &V, const Tensor< 2, dim, Number > &F)\\nPhysics::Transformations::Piola::push_forwardTensor< 1, dim, Number > push_forward(const Tensor< 1, dim, Number > &V, const Tensor< 2, dim, Number > &F)\\nFinally, we output the strain-stress and magnetic loading history to file.\\n\\u00a0       if (experimental_parameters.output_data_to_file)\\n\\u00a0         {\\n\\u00a0           std::ofstream output(filename);\\n\\u00a0           output << stream.str();\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0 \\n The CoupledConstitutiveLaws::run() function\\nThe purpose of this driver function is to read in all of the parameters from file and, based off of that, create a representative instance of each constitutive law and invoke the function that conducts a rheological experiment with it.\\n\\u00a0     void run(int argc, char *argv[])\\n\\u00a0     {\\n\\u00a0       using namespace dealii;\\n\\u00a0 \\n\\u00a0       constexpr unsigned int dim = 3;\\n\\u00a0 \\n\\u00a0       const ConstitutiveParameters          constitutive_parameters;\\n\\u00a0       const RheologicalExperimentParameters experimental_parameters;\\n\\u00a0 \\n\\u00a0       std::string parameter_file;\\n\\u00a0       if (argc > 1)\\n\\u00a0         parameter_file = argv[1];\\n\\u00a0       else\\n\\u00a0         parameter_file = \\\"parameters.prm\\\";\\n\\u00a0       ParameterAcceptor::initialize(parameter_file, \\\"used_parameters.prm\\\");\\n\\u00a0 \\nParameterAcceptor::initializestatic void initialize(const std::string &filename=\\\"\\\", const std::string &output_filename=\\\"\\\", const ParameterHandler::OutputStyle output_style_for_output_filename=ParameterHandler::Short, ParameterHandler &prm=ParameterAcceptor::prm, const ParameterHandler::OutputStyle output_style_for_filename=ParameterHandler::DefaultStyle)Definition parameter_acceptor.cc:80\\nWe start the actual work by configuring and running the experiment using our rate-independent constitutive law. The automatically differentiable number type is hard-coded here, but with some clever templating it is possible to select which framework to use at run time (e.g., as selected through the parameter file). We'll simultaneously perform the experiments with the counterpart material law that was fully implemented by hand, and check what it computes against our assisted implementation.\\n\\u00a0       {\\n\\u00a0         TimerOutput timer(std::cout,\\n\\u00a0                           TimerOutput::summary,\\n\\u00a0                           TimerOutput::wall_times);\\n\\u00a0         std::cout\\n\\u00a0           << \\\"Coupled magnetoelastic constitutive law using automatic differentiation.\\\"\\n\\u00a0           << std::endl;\\n\\u00a0 \\n\\u00a0         constexpr Differentiation::AD::NumberTypes ADTypeCode =\\n\\u00a0           Differentiation::AD::NumberTypes::sacado_dfad_dfad;\\n\\u00a0 \\n\\u00a0         Magnetoelastic_Constitutive_Law<dim> material(constitutive_parameters);\\n\\u00a0         Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode> material_ad(\\n\\u00a0           constitutive_parameters);\\n\\u00a0 \\n\\u00a0         run_rheological_experiment(experimental_parameters,\\n\\u00a0                                    material,\\n\\u00a0                                    material_ad,\\n\\u00a0                                    timer,\\n\\u00a0                                    experimental_parameters.output_filename_ri);\\n\\u00a0 \\n\\u00a0         std::cout << \\\"... all calculations are correct!\\\" << std::endl;\\n\\u00a0       }\\n\\u00a0 \\nTimerOutput::wall_times@ wall_timesDefinition timer.h:651\\nTimerOutput::summary@ summaryDefinition timer.h:607\\nNext we do the same for the rate-dependent constitutive law. The highest performance option is selected as default if SymEngine is set up to use the LLVM just-in-time compiler which (in conjunction with some aggressive compilation flags) produces the fastest code evaluation path of all of the available option. As a fall-back, the so called \\\"lambda\\\" optimizer (which only requires a C++11 compliant compiler) will be selected. At the same time, we'll ask the CAS to perform common subexpression elimination to minimize the number of intermediate calculations used during evaluation. We'll record how long it takes to execute the \\\"initialization\\\" step inside the constructor for the SD implementation, as this is where the abovementioned transformations occur.\\n\\u00a0       {\\n\\u00a0         TimerOutput timer(std::cout,\\n\\u00a0                           TimerOutput::summary,\\n\\u00a0                           TimerOutput::wall_times);\\n\\u00a0         std::cout\\n\\u00a0           << \\\"Coupled magneto-viscoelastic constitutive law using symbolic differentiation.\\\"\\n\\u00a0           << std::endl;\\n\\u00a0 \\n\\u00a0 #ifdef DEAL_II_SYMENGINE_WITH_LLVM\\n\\u00a0         std::cout << \\\"Using LLVM optimizer.\\\" << std::endl;\\n\\u00a0         constexpr Differentiation::SD::OptimizerType optimizer_type =\\n\\u00a0           Differentiation::SD::OptimizerType::llvm;\\n\\u00a0         constexpr Differentiation::SD::OptimizationFlags optimization_flags =\\n\\u00a0           Differentiation::SD::OptimizationFlags::optimize_all;\\n\\u00a0 #else\\n\\u00a0         std::cout << \\\"Using lambda optimizer.\\\" << std::endl;\\n\\u00a0         constexpr Differentiation::SD::OptimizerType optimizer_type =\\n\\u00a0           Differentiation::SD::OptimizerType::lambda;\\n\\u00a0         constexpr Differentiation::SD::OptimizationFlags optimization_flags =\\n\\u00a0           Differentiation::SD::OptimizationFlags::optimize_cse;\\n\\u00a0 #endif\\n\\u00a0 \\n\\u00a0         Magnetoviscoelastic_Constitutive_Law<dim> material(\\n\\u00a0           constitutive_parameters);\\n\\u00a0 \\n\\u00a0         timer.enter_subsection(\\\"Initialize symbolic CL\\\");\\n\\u00a0         Magnetoviscoelastic_Constitutive_Law_SD<dim> material_sd(\\n\\u00a0           constitutive_parameters, optimizer_type, optimization_flags);\\n\\u00a0         timer.leave_subsection();\\n\\u00a0 \\n\\u00a0         run_rheological_experiment(experimental_parameters,\\n\\u00a0                                    material,\\n\\u00a0                                    material_sd,\\n\\u00a0                                    timer,\\n\\u00a0                                    experimental_parameters.output_filename_rd);\\n\\u00a0 \\n\\u00a0         std::cout << \\\"... all calculations are correct!\\\" << std::endl;\\n\\u00a0       }\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   } // namespace CoupledConstitutiveLaws\\n\\u00a0 \\n\\u00a0 } // namespace Step71\\n\\u00a0 \\n\\u00a0 \\nDEAL_II_SYMENGINE_WITH_LLVM#define DEAL_II_SYMENGINE_WITH_LLVMDefinition config.h:285\\nDifferentiation::SD::OptimizerType::llvm@ llvm\\nDifferentiation::SD::OptimizerType::lambda@ lambda\\nDifferentiation::SD::OptimizationFlags::optimize_all@ optimize_all\\nDifferentiation::SD::OptimizationFlags::optimize_cse@ optimize_cse\\n The main() function\\nThe main function only calls the driver functions for the two sets of examples that are to be executed.\\n\\u00a0 int main(int argc, char *argv[])\\n\\u00a0 {\\n\\u00a0   Step71::SimpleExample::run();\\n\\u00a0   Step71::CoupledConstitutiveLaws::run(argc, argv);\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nIntroductory example\\nThe first exploratory example produces the following output. It is verified that all three implementations produce identical results. > ./step-71\\nSimple example using automatic differentiation...\\n... all calculations are correct!\\nSimple example using symbolic differentiation.\\n... all calculations are correct!\\nConstitutive modelling\\nTo help summarize the results from the virtual experiment itself, below are some graphs showing the shear stress, plotted against the shear strain, at a select location within the material sample. The plots show the stress-strain curves under three different magnetic loads, and for the last cycle of the (mechanical) loading profile, when the rate-dependent material reaches a repeatable (\\\"steady-state\\\") response. These types of graphs are often referred to as Lissajous plots. The area of the ellipse that the curve takes for viscoelastic materials provides some measure of how much energy is dissipated by the material, and its ellipticity indicates the phase shift of the viscous response with respect to the elastic response.\\n\\n\\n \\nLissajous plot for the magneto-elastic material. \\n\\n \\nLissajous plot for the magneto-viscoelastic material. \\n\\n\\n\\nIt is not surprising to see that the magneto-elastic material response has an unloading curve that matches the loading curve \\u2013 the material is non-dissipative after all. But here it's clearly noticeable how the gradient of the curve increases as the applied magnetic field increases. The tangent at any point along this curve is related to the instantaneous shear modulus and, due to the way that the energy density function was defined, we expect that the shear modulus increases as the magnetic field strength increases. We observe much the same behavior for the magneto-viscoelastic material. The major axis of the ellipse traced by the loading-unloading curve has a slope that increases as a greater magnetic load is applied. At the same time, the more energy is dissipated by the material.\\nAs for the code output, this is what is printed to the console for the part pertaining to the rheological experiment conducted with the magnetoelastic material: Coupled magnetoelastic constitutive law using automatic differentiation.\\nTimestep = 0 @ time = 0s.\\nTimestep = 125 @ time = 0.314159s.\\nTimestep = 250 @ time = 0.628318s.\\nTimestep = 375 @ time = 0.942477s.\\n...\\nTimestep = 12250 @ time = 30.7876s.\\nTimestep = 12375 @ time = 31.1018s.\\nTimestep = 12500 @ time = 31.4159s.\\n... all calculations are correct!\\nAnd this portion of the output pertains to the experiment performed with the magneto-viscoelastic material: Coupled magneto-viscoelastic constitutive law using symbolic differentiation.\\nUsing LLVM optimizer.\\nTimestep = 0 @ time = 0s.\\nTimestep = 125 @ time = 0.314159s.\\nTimestep = 250 @ time = 0.628318s.\\nTimestep = 375 @ time = 0.942477s.\\n...\\nTimestep = 12250 @ time = 30.7876s.\\nTimestep = 12375 @ time = 31.1018s.\\nTimestep = 12500 @ time = 31.4159s.\\n... all calculations are correct!\\nThe timer output is also emitted to the console, so we can compare time taken to perform the hand- and assisted- calculations and get some idea of the overhead of using the AD and SD frameworks. Here are the timings taken from the magnetoelastic experiment using the AD framework, based on the Sacado component of the Trilinos library: +---------------------------------------------+------------+------------+\\n| Total wallclock time elapsed since start    |       3.2s |            |\\n|                                             |            |            |\\n| Section                         | no. calls |  wall time | % of total |\\n+---------------------------------+-----------+------------+------------+\\n| Assisted computation            |     12501 |      3.02s |        95% |\\n| Hand calculated                 |     12501 |    0.0464s |       1.5% |\\n+---------------------------------+-----------+------------+------------+\\n With respect to the computations performed using automatic differentiation (as a reminder, this is with two levels of differentiation using the Sacado library in conjunction with dynamic forward auto-differentiable types), we observe that the assisted computations takes about \\\\(65 \\\\times\\\\) longer to compute the desired quantities. This does seem like quite a lot of overhead but, as mentioned in the introduction, it's entirely subjective and circumstance-dependent as to whether or not this is acceptable or not: Do you value computer time more than human time for doing the necessary hand-computations of derivatives, verify their correctness, implement them, and verify the correctness of the implementation? If you develop a research code that will only be run for a relatively small number of experiments, you might value your own time more. If you develop a production code that will be run over and over on 10,000-core clusters for hours, your considerations might be different. In any case, the one nice feature of the AD approach is the \\\"drop in\\\" capability when functions and classes are templated on the scalar type. This means that minimal effort is required to start working with it.\\nIn contrast, the timings for magneto-viscoelastic material as implemented using just-in-time (JIT) compiled symbolic algebra indicate that, at some non-negligible cost during initialization, the calculations themselves are a lot more efficiently executed: +---------------------------------------------+------------+------------+\\n| Total wallclock time elapsed since start    |      1.34s |            |\\n|                                             |            |            |\\n| Section                         | no. calls |  wall time | % of total |\\n+---------------------------------+-----------+------------+------------+\\n| Assisted computation            |     12501 |     0.376s |        28% |\\n| Hand calculated                 |     12501 |     0.368s |        27% |\\n| Initialize symbolic CL          |         1 |     0.466s |        35% |\\n+---------------------------------+-----------+------------+------------+\\n Since the initialization phase need, most likely, only be executed once per thread, this initial expensive phase can be offset by the repeated use of a single Differentiation::SD::BatchOptimizer instance. Even though the magneto-viscoelastic constitutive law has more terms to calculate when compared to its magnetoelastic counterpart, it still is a whole order of magnitude faster to execute the computations of the kinetic variables and tangents. And when compared to the hand computed variant that uses the caching scheme, the calculation time is nearly equal. So although using the symbolic framework requires a paradigm shift in terms of how one implements and manipulates the symbolic expressions, it can offer good performance and flexibility that the AD frameworks lack.\\nOn the point of data caching, the added cost of value caching for the magneto-viscoelastic material implementation is, in fact, about a \\\\(6\\\\times\\\\) increase in the time spent in update_internal_data() when compared to the implementation using intermediate values for the numerical experiments conducted with this material. Here's a sample output of the timing comparison extracted for the \\\"hand calculated\\\" variant when the caching data structure is removed: +---------------------------------------------+------------+------------+\\n| Total wallclock time elapsed since start    |      1.01s |            |\\n|                                             |            |            |\\n| Section                         | no. calls |  wall time | % of total |\\n+---------------------------------+-----------+------------+------------+\\n| Assisted computation            |     12501 |     0.361s |        36% |\\n| Hand calculated                 |     12501 |    0.0562s |       5.6% |\\n| Initialize symbolic CL          |         1 |     0.469s |        47% |\\n+---------------------------------+-----------+------------+------------+\\nWith some minor adjustment we can quite easily test the different optimization schemes for the batch optimizer. So let's compare the computational expense associated with the LLVM batch optimizer setting versus the alternatives. Below are the timings reported for the lambda optimization method (retaining the use of CSE): +---------------------------------------------+------------+------------+\\n| Total wallclock time elapsed since start    |      3.87s |            |\\n|                                             |            |            |\\n| Section                         | no. calls |  wall time | % of total |\\n+---------------------------------+-----------+------------+------------+\\n| Assisted computation            |     12501 |      3.12s |        81% |\\n| Hand calculated                 |     12501 |     0.394s |        10% |\\n| Initialize symbolic CL          |         1 |     0.209s |       5.4% |\\n+---------------------------------+-----------+------------+------------+\\n The primary observation here is that an order of magnitude greater time is spent in the \\\"Assisted computation\\\" section when compared to the LLVM approach.\\nLast of all we'll test how dictionary substitution, in conjunction with CSE, performs. Dictionary substitution simply does all of the evaluation within the native CAS framework itself, with no transformation of the underlying data structures taking place. Only the use of CSE, which caches intermediate results, will provide any \\\"acceleration\\\" in this instance. With that in mind, here are the results from this selection: +---------------------------------------------+------------+------------+\\n| Total wallclock time elapsed since start    |  1.54e+03s |            |\\n|                                             |            |            |\\n| Section                         | no. calls |  wall time | % of total |\\n+---------------------------------+-----------+------------+------------+\\n| Assisted computation            |     12501 |  1.54e+03s |     1e+02% |\\n| Hand calculated                 |     12501 |     0.563s |         0% |\\n| Initialize symbolic CL          |         1 |     0.184s |         0% |\\n+---------------------------------+-----------+------------+------------+\\n Needless to say, compared to the other two methods, these results took quite some time to produce... The dictionary substitution method is perhaps only really viable for simple expressions or when the number of calls is sufficiently small.\\nSo, which framework should I use?\\nPerhaps you've been convinced that these tools have some merit, and can be of immediate help or use to you. The obvious question now is which one to use. Focusing specifically at a continuum point level, where you would be using these frameworks to compute derivatives of a constitutive law in particular, we can say the following:\\nAutomatic differentiation probably provides the simplest entry point into the world of assisted differentiation.\\nGiven a sufficiently generic implementation of a constitutive framework, AD can often be used as a drop-in replacement for the intrinsic scalar types and the helper classes can then be leveraged to compute first (and possibly higher order) derivatives with minimal effort.\\nAs a qualification to the above point, being a \\\"drop-in replacement\\\" does not mean that you must not be contentious of what the algorithms that these numbers are being passed through are doing. It is possible to inadvertently perform an operation that would, upon differentiating, return an incorrect result. So this is definitely something that one should be aware of. A concrete example: When computing the eigenvalues of a tensor, if the tensor is diagonal then a short-cut to the result is simply to return the diagonal entries directly (as extracted from the input tensor). This is completely correct in terms of computing the eigenvalues themselves, but not going through the algorithm that would otherwise compute the eigenvalues for a non-diagonal tensor has had an unintended side-effect, namely that the eigenvalues appear (to the AD framework) to be completely decoupled from one another and their cross-sensitivities are not encoded in the returned result. Upon differentiating, many entries of the derivative tensor will be missing. To fix this issue, one has to ensure that the standard eigenvalue solving algorithm is used so that the sensitivities of the returned eigenvalues with respect to one another are encoded in the result.\\nComputations involving AD number types may be expensive. The expense increases (sometimes quite considerably) as the order of the differential operations increases. This may be mitigated by computational complexity of surrounding operations (such as a linear solve, for example), but is ultimately problem specific.\\nAD is restricted to the case where only total derivatives are required. If a differential operation requires a partial derivative with respect to an independent variable then it is not appropriate to use it.\\nEach AD library has its own quirks (sad to say but, in the author's experience, true), so it may take some trial and error to find the appropriate library and choice of AD number to suit your purposes. The reason for these \\\"quirks\\\" often boils down to the overall philosophy behind the library (data structures, the use of template meta-programming, etc.) as well as the mathematical implementation of the derivative computations (for example, manipulations of results using logarithmic functions to change basis might restrict the domain for the input values \\u2013 details all hidden from the user, of course). Furthermore, one library might be able to compute the desired results quicker than another, so some initial exploration might be beneficial in that regard.\\nSymbolic differentiation (well, the use of a CAS in general) provides the most flexible framework with which to perform assisted computations.\\nThe SD framework can do everything that the AD frameworks can, with the additional benefit of having low-level control over when certain manipulations and operations are performed.\\nAcceleration of expression evaluation is possible, potentially leading to near-native performance of the SD framework compared to some hand implementations (this comparison being dependent on the overall program design, of course) at the expense of the initial optimization call.\\nClever use of the Differentiation::SD::BatchOptimizer could minimize the expense of the costly call that optimizes the dependent expressions. The possibility to serialize the Differentiation::SD::BatchOptimizer that often (but not always) this expensive call can be done once and then reused in a later simulation.\\nIf two or more material laws differ by only their material parameters, for instance, then a single batch optimizer can be shared between them as long as those material parameters are considered to be symbolic. The implication of this is that you can \\\"differentiate once, evaluate in many contexts\\\".\\nThe SD framework may partially be used as a \\\"drop-in replacement\\\" for scalar types, but one (at the very least) has to add some more framework around it to perform the value substitution step, converting symbolic types to their numerical counterparts.\\nIt may not be possible to use SD numbers within some specialized algorithms. For example, if an algorithm has an exit point or code branch based off of some concrete, numerical value that the (symbolic) input argument should take, then obviously this isn't going to work. One either has to reimplement the algorithm specifically for SD number types (somewhat inconvenient, but frequently possible as conditionals are supported by the Differentiation::SD::Expression class), or one must use a creative means around this specific issue (e.g., introduce a symbolic expression that represents the result returned by this algorithm, perhaps declaring it to be a symbolic function if that makes sense within the context in which it is to be used. This can later be substituted by its numerical values, and if declared a symbolic function then its deferred derivatives may also be incorporated into the calculations as substituted results.).\\nThe biggest drawback to using SD is that using it requires a paradigm shift, and that one has to frame most problems differently in order to take the most advantage of it. (Careful consideration of how the data structures are used and reused is also essential to get it to work effectively.) This may mean that one needs to play around with it a bit and build up an understanding of what the sequence of typical operations is and what specifically each step does in terms of manipulating the underlying data. If one has the time and inclination to do so, then the benefits of using this tool may be substantial.\\n\\nPossibilities for extension\\nThere are a few logical ways in which this program could be extended:\\nPerhaps the most obvious extension would be to implement and test other constitutive models. This could still be within the realm of coupled magneto-mechanical problems, perhaps considering alternatives to the \\\"Neo-Hookean\\\"-type elastic part of the energy functions, changing the constitutive law for the dissipative energy (and its associated evolution law), or including magnetic hysteretic effects or damage models for the composite polymer that these material seek to model.\\nOf course, the implemented models could be modified or completely replaced with models that are focused on other aspects of physics, such as electro-active polymers, biomechanical materials, elastoplastic media, etc.\\nImplement a different time-discretization scheme for the viscoelastic evolution law.\\nInstead of deriving everything directly from an energy density function, use the Differentiation::AD::VectorFunction to directly linearize the kinetic quantities. This would mean that only a once-differentiable auto-differentiable number type would be required, and would certainly improve the performance greatly. Such an approach would also offer the opportunity for dissipative materials, such as the magneto-viscoelastic one consider here, to be implemented in conjunction with AD. This is because the linearization invokes the total derivative of the dependent variables with respect to the field variables, which is exactly what the AD frameworks can provide.\\nInvestigate using other auto-differentiable number types and frameworks (such as ADOL-C). Since each AD library has its own implementation, the choice of which to use could result in performance increases and, in the most unfortunate cases, more stable computations. It can at least be said that for the AD libraries that deal.II supports, the accuracy of results should be largely unaffected by this decision.\\nEmbed one of these constitutive laws within a finite element simulation.\\n\\nWith less effort, one could think about re-writing nonlinear problem solvers such as the one implemented in step-15 using AD or SD approaches to compute the Newton matrix. Indeed, this is done in step-72.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2021 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Author: Jean-Paul Pelteret, 2021\\n */\\n \\n \\n#include <deal.II/algorithms/general_data_storage.h>\\n \\n#include <deal.II/base/discrete_time.h>\\n#include <deal.II/base/numbers.h>\\n#include <deal.II/base/parameter_acceptor.h>\\n#include <deal.II/base/symmetric_tensor.h>\\n#include <deal.II/base/tensor.h>\\n#include <deal.II/base/timer.h>\\n#include <deal.II/base/utilities.h>\\n \\n#include <deal.II/physics/transformations.h>\\n#include <deal.II/physics/elasticity/kinematics.h>\\n#include <deal.II/physics/elasticity/standard_tensors.h>\\n \\n#include <deal.II/differentiation/ad.h>\\n#include <deal.II/differentiation/sd.h>\\n \\n#include <fstream>\\n \\n \\nnamespace Step71\\n{\\n using namespace dealii;\\n \\n \\n namespace SimpleExample\\n  {\\n template <typename NumberType>\\n    NumberType f(const NumberType &x, const NumberType &y)\\n    {\\n return std::cos(y / x);\\n    }\\n \\n double df_dx(const double x, const double y);\\n \\n double df_dy(const double x, const double y);\\n \\n double d2f_dx_dx(const double x, const double y);\\n \\n double d2f_dx_dy(const double x, const double y);\\n \\n double d2f_dy_dx(const double x, const double y);\\n \\n double d2f_dy_dy(const double x, const double y);\\n \\n \\n \\n void\\n    run_and_verify_ad(const double x, const double y, const double tol = 1e-12)\\n    {\\n constexpr unsigned int                     dim = 1;\\n constexpr Differentiation::AD::NumberTypes ADTypeCode =\\n Differentiation::AD::NumberTypes::sacado_dfad_dfad;\\n using ADHelper =\\n Differentiation::AD::ScalarFunction<dim, ADTypeCode, double>;\\n \\n constexpr unsigned int n_independent_variables = 2;\\n \\n      ADHelper ad_helper(n_independent_variables);\\n using ADNumberType = typename ADHelper::ad_type;\\n \\n      ad_helper.register_independent_variables({x, y});\\n \\n const std::vector<ADNumberType> independent_variables_ad =\\n        ad_helper.get_sensitive_variables();\\n const ADNumberType &x_ad = independent_variables_ad[0];\\n const ADNumberType &y_ad = independent_variables_ad[1];\\n \\n const ADNumberType f_ad = f(x_ad, y_ad);\\n \\n \\n      ad_helper.register_dependent_variable(f_ad);\\n \\n Vector<double>     Df(ad_helper.n_dependent_variables());\\n FullMatrix<double> D2f(ad_helper.n_dependent_variables(),\\n                             ad_helper.n_independent_variables());\\n \\n const double computed_f = ad_helper.compute_value();\\n      ad_helper.compute_gradient(Df);\\n      ad_helper.compute_hessian(D2f);\\n \\n AssertThrow(std::abs(f(x, y) - computed_f) < tol,\\n                  ExcMessage(std::string(\\\"Incorrect value computed for f. \\\") +\\n                             std::string(\\\"Hand-calculated value: \\\") +\\n Utilities::to_string(f(x, y)) +\\n                             std::string(\\\" ; \\\") +\\n                             std::string(\\\"Value computed by AD: \\\") +\\n Utilities::to_string(computed_f)));\\n \\n const double computed_df_dx = Df[0];\\n const double computed_df_dy = Df[1];\\n \\n AssertThrow(std::abs(df_dx(x, y) - computed_df_dx) < tol,\\n                  ExcMessage(\\n                    std::string(\\\"Incorrect value computed for df/dx. \\\") +\\n                    std::string(\\\"Hand-calculated value: \\\") +\\n Utilities::to_string(df_dx(x, y)) + std::string(\\\" ; \\\") +\\n                    std::string(\\\"Value computed by AD: \\\") +\\n Utilities::to_string(computed_df_dx)));\\n AssertThrow(std::abs(df_dy(x, y) - computed_df_dy) < tol,\\n                  ExcMessage(\\n                    std::string(\\\"Incorrect value computed for df/dy. \\\") +\\n                    std::string(\\\"Hand-calculated value: \\\") +\\n Utilities::to_string(df_dy(x, y)) + std::string(\\\" ; \\\") +\\n                    std::string(\\\"Value computed by AD: \\\") +\\n Utilities::to_string(computed_df_dy)));\\n \\n const double computed_d2f_dx_dx = D2f[0][0];\\n const double computed_d2f_dx_dy = D2f[0][1];\\n const double computed_d2f_dy_dx = D2f[1][0];\\n const double computed_d2f_dy_dy = D2f[1][1];\\n \\n AssertThrow(std::abs(d2f_dx_dx(x, y) - computed_d2f_dx_dx) < tol,\\n                  ExcMessage(\\n                    std::string(\\\"Incorrect value computed for d2f/dx_dx. \\\") +\\n                    std::string(\\\"Hand-calculated value: \\\") +\\n Utilities::to_string(d2f_dx_dx(x, y)) + std::string(\\\" ; \\\") +\\n                    std::string(\\\"Value computed by AD: \\\") +\\n Utilities::to_string(computed_d2f_dx_dx)));\\n AssertThrow(std::abs(d2f_dx_dy(x, y) - computed_d2f_dx_dy) < tol,\\n                  ExcMessage(\\n                    std::string(\\\"Incorrect value computed for d2f/dx_dy. \\\") +\\n                    std::string(\\\"Hand-calculated value: \\\") +\\n Utilities::to_string(d2f_dx_dy(x, y)) + std::string(\\\" ; \\\") +\\n                    std::string(\\\"Value computed by AD: \\\") +\\n Utilities::to_string(computed_d2f_dx_dy)));\\n AssertThrow(std::abs(d2f_dy_dx(x, y) - computed_d2f_dy_dx) < tol,\\n                  ExcMessage(\\n                    std::string(\\\"Incorrect value computed for d2f/dy_dx. \\\") +\\n                    std::string(\\\"Hand-calculated value: \\\") +\\n Utilities::to_string(d2f_dy_dx(x, y)) + std::string(\\\" ; \\\") +\\n                    std::string(\\\"Value computed by AD: \\\") +\\n Utilities::to_string(computed_d2f_dy_dx)));\\n AssertThrow(std::abs(d2f_dy_dy(x, y) - computed_d2f_dy_dy) < tol,\\n                  ExcMessage(\\n                    std::string(\\\"Incorrect value computed for d2f/dy_dy. \\\") +\\n                    std::string(\\\"Hand-calculated value: \\\") +\\n Utilities::to_string(d2f_dy_dy(x, y)) + std::string(\\\" ; \\\") +\\n                    std::string(\\\"Value computed by AD: \\\") +\\n Utilities::to_string(computed_d2f_dy_dy)));\\n    }\\n \\n \\n \\n \\n double df_dx(const double x, const double y)\\n    {\\n Assert(x != 0.0, ExcDivideByZero());\\n return y * std::sin(y / x) / (x * x);\\n    }\\n \\n double df_dy(const double x, const double y)\\n    {\\n return -std::sin(y / x) / x;\\n    }\\n \\n double d2f_dx_dx(const double x, const double y)\\n    {\\n return -y * (2 * x * std::sin(y / x) + y * std::cos(y / x)) /\\n             (x * x * x * x);\\n    }\\n \\n double d2f_dx_dy(const double x, const double y)\\n    {\\n return (x * std::sin(y / x) + y * std::cos(y / x)) / (x * x * x);\\n    }\\n \\n double d2f_dy_dx(const double x, const double y)\\n    {\\n return (x * std::sin(y / x) + y * std::cos(y / x)) / (x * x * x);\\n    }\\n \\n double d2f_dy_dy(const double x, const double y)\\n    {\\n return -(std::cos(y / x)) / (x * x);\\n    }\\n \\n \\n \\n \\n \\n \\n void\\n    run_and_verify_sd(const double x, const double y, const double tol = 1e-12)\\n    {\\n const Differentiation::SD::Expression x_sd(\\\"x\\\");\\n const Differentiation::SD::Expression y_sd(\\\"y\\\");\\n \\n const Differentiation::SD::Expression f_sd = f(x_sd, y_sd);\\n \\n const Differentiation::SD::Expression df_dx_sd = f_sd.differentiate(x_sd);\\n const Differentiation::SD::Expression df_dy_sd = f_sd.differentiate(y_sd);\\n \\n const Differentiation::SD::Expression d2f_dx_dx_sd =\\n        df_dx_sd.differentiate(x_sd);\\n const Differentiation::SD::Expression d2f_dx_dy_sd =\\n        df_dx_sd.differentiate(y_sd);\\n const Differentiation::SD::Expression d2f_dy_dx_sd =\\n        df_dy_sd.differentiate(x_sd);\\n const Differentiation::SD::Expression d2f_dy_dy_sd =\\n        df_dy_sd.differentiate(y_sd);\\n \\n const Differentiation::SD::types::substitution_map substitution_map =\\n Differentiation::SD::make_substitution_map(\\n          std::pair<Differentiation::SD::Expression, double>{x_sd, x},\\n          std::pair<Differentiation::SD::Expression, double>{y_sd, y});\\n \\n const double computed_f =\\n        f_sd.substitute_and_evaluate<double>(substitution_map);\\n \\n AssertThrow(std::abs(f(x, y) - computed_f) < tol,\\n                  ExcMessage(std::string(\\\"Incorrect value computed for f. \\\") +\\n                             std::string(\\\"Hand-calculated value: \\\") +\\n Utilities::to_string(f(x, y)) +\\n                             std::string(\\\" ; \\\") +\\n                             std::string(\\\"Value computed by AD: \\\") +\\n Utilities::to_string(computed_f)));\\n \\n const double computed_df_dx =\\n        df_dx_sd.substitute_and_evaluate<double>(substitution_map);\\n const double computed_df_dy =\\n        df_dy_sd.substitute_and_evaluate<double>(substitution_map);\\n \\n AssertThrow(std::abs(df_dx(x, y) - computed_df_dx) < tol,\\n                  ExcMessage(\\n                    std::string(\\\"Incorrect value computed for df/dx. \\\") +\\n                    std::string(\\\"Hand-calculated value: \\\") +\\n Utilities::to_string(df_dx(x, y)) + std::string(\\\" ; \\\") +\\n                    std::string(\\\"Value computed by AD: \\\") +\\n Utilities::to_string(computed_df_dx)));\\n AssertThrow(std::abs(df_dy(x, y) - computed_df_dy) < tol,\\n                  ExcMessage(\\n                    std::string(\\\"Incorrect value computed for df/dy. \\\") +\\n                    std::string(\\\"Hand-calculated value: \\\") +\\n Utilities::to_string(df_dy(x, y)) + std::string(\\\" ; \\\") +\\n                    std::string(\\\"Value computed by AD: \\\") +\\n Utilities::to_string(computed_df_dy)));\\n \\n const double computed_d2f_dx_dx =\\n        d2f_dx_dx_sd.substitute_and_evaluate<double>(substitution_map);\\n const double computed_d2f_dx_dy =\\n        d2f_dx_dy_sd.substitute_and_evaluate<double>(substitution_map);\\n const double computed_d2f_dy_dx =\\n        d2f_dy_dx_sd.substitute_and_evaluate<double>(substitution_map);\\n const double computed_d2f_dy_dy =\\n        d2f_dy_dy_sd.substitute_and_evaluate<double>(substitution_map);\\n \\n AssertThrow(std::abs(d2f_dx_dx(x, y) - computed_d2f_dx_dx) < tol,\\n                  ExcMessage(\\n                    std::string(\\\"Incorrect value computed for d2f/dx_dx. \\\") +\\n                    std::string(\\\"Hand-calculated value: \\\") +\\n Utilities::to_string(d2f_dx_dx(x, y)) + std::string(\\\" ; \\\") +\\n                    std::string(\\\"Value computed by SD: \\\") +\\n Utilities::to_string(computed_d2f_dx_dx)));\\n AssertThrow(std::abs(d2f_dx_dy(x, y) - computed_d2f_dx_dy) < tol,\\n                  ExcMessage(\\n                    std::string(\\\"Incorrect value computed for d2f/dx_dy. \\\") +\\n                    std::string(\\\"Hand-calculated value: \\\") +\\n Utilities::to_string(d2f_dx_dy(x, y)) + std::string(\\\" ; \\\") +\\n                    std::string(\\\"Value computed by SD: \\\") +\\n Utilities::to_string(computed_d2f_dx_dy)));\\n AssertThrow(std::abs(d2f_dy_dx(x, y) - computed_d2f_dy_dx) < tol,\\n                  ExcMessage(\\n                    std::string(\\\"Incorrect value computed for d2f/dy_dx. \\\") +\\n                    std::string(\\\"Hand-calculated value: \\\") +\\n Utilities::to_string(d2f_dy_dx(x, y)) + std::string(\\\" ; \\\") +\\n                    std::string(\\\"Value computed by SD: \\\") +\\n Utilities::to_string(computed_d2f_dy_dx)));\\n AssertThrow(std::abs(d2f_dy_dy(x, y) - computed_d2f_dy_dy) < tol,\\n                  ExcMessage(\\n                    std::string(\\\"Incorrect value computed for d2f/dy_dy. \\\") +\\n                    std::string(\\\"Hand-calculated value: \\\") +\\n Utilities::to_string(d2f_dy_dy(x, y)) + std::string(\\\" ; \\\") +\\n                    std::string(\\\"Value computed by SD: \\\") +\\n Utilities::to_string(computed_d2f_dy_dy)));\\n    }\\n \\n \\n \\n void run()\\n    {\\n const double x = 1.23;\\n const double y = 0.91;\\n \\n      std::cout << \\\"Simple example using automatic differentiation...\\\"\\n                << std::endl;\\n      run_and_verify_ad(x, y);\\n      std::cout << \\\"... all calculations are correct!\\\" << std::endl;\\n \\n      std::cout << \\\"Simple example using symbolic differentiation.\\\"\\n                << std::endl;\\n      run_and_verify_sd(x, y);\\n      std::cout << \\\"... all calculations are correct!\\\" << std::endl;\\n    }\\n \\n  } // namespace SimpleExample\\n \\n \\n \\n namespace CoupledConstitutiveLaws\\n  {\\n \\n class ConstitutiveParameters : public ParameterAcceptor\\n    {\\n public:\\n      ConstitutiveParameters();\\n \\n double mu_e       = 30.0e3;\\n double mu_e_inf   = 250.0e3;\\n double mu_e_h_sat = 212.2e3;\\n double nu_e       = 0.49;\\n \\n double mu_v       = 20.0e3;\\n double mu_v_inf   = 35.0e3;\\n double mu_v_h_sat = 92.84e3;\\n double tau_v      = 0.6;\\n \\n double mu_r = 6.0;\\n \\n bool initialized = false;\\n    };\\n \\n    ConstitutiveParameters::ConstitutiveParameters()\\n      : ParameterAcceptor(\\\"/Coupled Constitutive Laws/Constitutive Parameters/\\\")\\n    {\\n      add_parameter(\\\"Elastic shear modulus\\\", mu_e);\\n      add_parameter(\\\"Elastic shear modulus at magnetic saturation\\\", mu_e_inf);\\n      add_parameter(\\n \\\"Saturation magnetic field strength for elastic shear modulus\\\",\\n        mu_e_h_sat);\\n      add_parameter(\\\"Poisson ratio\\\", nu_e);\\n \\n      add_parameter(\\\"Viscoelastic shear modulus\\\", mu_v);\\n      add_parameter(\\\"Viscoelastic shear modulus at magnetic saturation\\\",\\n                    mu_v_inf);\\n      add_parameter(\\n \\\"Saturation magnetic field strength for viscoelastic shear modulus\\\",\\n        mu_v_h_sat);\\n      add_parameter(\\\"Characteristic relaxation time\\\", tau_v);\\n \\n      add_parameter(\\\"Relative magnetic permeability\\\", mu_r);\\n \\n      parse_parameters_call_back.connect([&]() { initialized = true; });\\n    }\\n \\n \\n \\n template <int dim>\\n class Coupled_Magnetomechanical_Constitutive_Law_Base\\n    {\\n public:\\n      Coupled_Magnetomechanical_Constitutive_Law_Base(\\n const ConstitutiveParameters &constitutive_parameters);\\n \\n virtual void update_internal_data(const SymmetricTensor<2, dim> &C,\\n const Tensor<1, dim>          &H,\\n const DiscreteTime &time) = 0;\\n \\n virtual double get_psi() const = 0;\\n \\n virtual Tensor<1, dim> get_B() const = 0;\\n \\n virtual SymmetricTensor<2, dim> get_S() const = 0;\\n \\n virtual SymmetricTensor<2, dim> get_DD() const = 0;\\n \\n virtual Tensor<3, dim> get_PP() const = 0;\\n \\n virtual SymmetricTensor<4, dim> get_HH() const = 0;\\n \\n virtual void update_end_of_timestep()\\n      {}\\n \\n protected:\\n const ConstitutiveParameters &constitutive_parameters;\\n \\n double get_mu_e() const;\\n \\n double get_mu_e_inf() const;\\n \\n double get_mu_e_h_sat() const;\\n \\n double get_nu_e() const;\\n \\n double get_lambda_e() const;\\n \\n double get_kappa_e() const;\\n \\n double get_mu_v() const;\\n \\n double get_mu_v_inf() const;\\n \\n double get_mu_v_h_sat() const;\\n \\n double get_tau_v() const;\\n \\n double get_mu_r() const;\\n \\n constexpr double get_mu_0() const;\\n double           get_delta_t(const DiscreteTime &time) const;\\n    };\\n \\n \\n \\n template <int dim>\\n    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::\\n      Coupled_Magnetomechanical_Constitutive_Law_Base(\\n const ConstitutiveParameters &constitutive_parameters)\\n      : constitutive_parameters(constitutive_parameters)\\n    {\\n Assert(get_kappa_e() > 0, ExcInternalError());\\n    }\\n \\n \\n template <int dim>\\n double\\n    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_e() const\\n {\\n return constitutive_parameters.mu_e;\\n    }\\n \\n \\n template <int dim>\\n double\\n    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_e_inf() const\\n {\\n return constitutive_parameters.mu_e_inf;\\n    }\\n \\n \\n template <int dim>\\n double\\n    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_e_h_sat() const\\n {\\n return constitutive_parameters.mu_e_h_sat;\\n    }\\n \\n \\n template <int dim>\\n double\\n    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_nu_e() const\\n {\\n return constitutive_parameters.nu_e;\\n    }\\n \\n \\n template <int dim>\\n double\\n    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_lambda_e() const\\n {\\n return 2.0 * get_mu_e() * get_nu_e() / (1.0 - 2.0 * get_nu_e());\\n    }\\n \\n \\n template <int dim>\\n double\\n    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_kappa_e() const\\n {\\n return (2.0 * get_mu_e() * (1.0 + get_nu_e())) /\\n             (3.0 * (1.0 - 2.0 * get_nu_e()));\\n    }\\n \\n \\n template <int dim>\\n double\\n    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_v() const\\n {\\n return constitutive_parameters.mu_v;\\n    }\\n \\n \\n template <int dim>\\n double\\n    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_v_inf() const\\n {\\n return constitutive_parameters.mu_v_inf;\\n    }\\n \\n \\n template <int dim>\\n double\\n    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_v_h_sat() const\\n {\\n return constitutive_parameters.mu_v_h_sat;\\n    }\\n \\n \\n template <int dim>\\n double\\n    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_tau_v() const\\n {\\n return constitutive_parameters.tau_v;\\n    }\\n \\n \\n template <int dim>\\n double\\n    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_r() const\\n {\\n return constitutive_parameters.mu_r;\\n    }\\n \\n \\n template <int dim>\\n constexpr double\\n    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_0() const\\n {\\n return 4.0 * numbers::PI * 1e-7;\\n    }\\n \\n \\n template <int dim>\\n double Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_delta_t(\\n const DiscreteTime &time) const\\n {\\n return time.get_previous_step_size();\\n    }\\n \\n \\n \\n template <int dim, Differentiation::AD::NumberTypes ADTypeCode>\\n class Magnetoelastic_Constitutive_Law_AD final\\n      : public Coupled_Magnetomechanical_Constitutive_Law_Base<dim>\\n    {\\n using ADHelper =\\n Differentiation::AD::ScalarFunction<dim, ADTypeCode, double>;\\n using ADNumberType = typename ADHelper::ad_type;\\n \\n public:\\n      Magnetoelastic_Constitutive_Law_AD(\\n const ConstitutiveParameters &constitutive_parameters);\\n \\n virtual void update_internal_data(const SymmetricTensor<2, dim> &C,\\n const Tensor<1, dim>          &H,\\n const DiscreteTime &) override;\\n \\n virtual double get_psi() const override;\\n \\n virtual Tensor<1, dim> get_B() const override;\\n \\n virtual SymmetricTensor<2, dim> get_S() const override;\\n \\n virtual SymmetricTensor<2, dim> get_DD() const override;\\n \\n virtual Tensor<3, dim> get_PP() const override;\\n \\n virtual SymmetricTensor<4, dim> get_HH() const override;\\n \\n private:\\n const FEValuesExtractors::Vector             H_components;\\n const FEValuesExtractors::SymmetricTensor<2> C_components;\\n \\n      ADHelper ad_helper;\\n \\n double             psi;\\n Vector<double>     Dpsi;\\n FullMatrix<double> D2psi;\\n    };\\n \\n template <int dim, Differentiation::AD::NumberTypes ADTypeCode>\\n    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::\\n      Magnetoelastic_Constitutive_Law_AD(\\n const ConstitutiveParameters &constitutive_parameters)\\n      : Coupled_Magnetomechanical_Constitutive_Law_Base<dim>(\\n          constitutive_parameters)\\n      , H_components(0)\\n      , C_components(Tensor<1, dim>::n_independent_components)\\n      , ad_helper(Tensor<1, dim>::n_independent_components +\\n SymmetricTensor<2, dim>::n_independent_components)\\n      , psi(0.0)\\n      , Dpsi(ad_helper.n_independent_variables())\\n      , D2psi(ad_helper.n_independent_variables(),\\n              ad_helper.n_independent_variables())\\n    {}\\n \\n template <int dim, Differentiation::AD::NumberTypes ADTypeCode>\\n void\\n    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::update_internal_data(\\n const SymmetricTensor<2, dim> &C,\\n const Tensor<1, dim>          &H,\\n const DiscreteTime &)\\n    {\\n Assert(determinant(C) > 0, ExcInternalError());\\n \\n      ad_helper.reset();\\n \\n      ad_helper.register_independent_variable(H, H_components);\\n      ad_helper.register_independent_variable(C, C_components);\\n \\n const Tensor<1, dim, ADNumberType> H_ad =\\n        ad_helper.get_sensitive_variables(H_components);\\n const SymmetricTensor<2, dim, ADNumberType> C_ad =\\n        ad_helper.get_sensitive_variables(C_components);\\n \\n const ADNumberType det_F_ad = std::sqrt(determinant(C_ad));\\n const SymmetricTensor<2, dim, ADNumberType> C_inv_ad = invert(C_ad);\\n AssertThrow(det_F_ad > ADNumberType(0.0),\\n                  ExcMessage(\\\"Volumetric Jacobian must be positive.\\\"));\\n \\n const ADNumberType f_mu_e_ad =\\n        1.0 + (this->get_mu_e_inf() / this->get_mu_e() - 1.0) *\\n std::tanh((2.0 * H_ad * H_ad) /\\n                          (this->get_mu_e_h_sat() * this->get_mu_e_h_sat()));\\n \\n const ADNumberType psi_ad =\\n        0.5 * this->get_mu_e() * f_mu_e_ad *\\n          (trace(C_ad) - dim - 2.0 * std::log(det_F_ad))                 \\n        + this->get_lambda_e() * std::log(det_F_ad) * std::log(det_F_ad) \\n        - 0.5 * this->get_mu_0() * this->get_mu_r() * det_F_ad *\\n            (H_ad * C_inv_ad * H_ad); \\n \\n      ad_helper.register_dependent_variable(psi_ad);\\n \\n      psi = ad_helper.compute_value();\\n      ad_helper.compute_gradient(Dpsi);\\n      ad_helper.compute_hessian(D2psi);\\n    }\\n \\n template <int dim, Differentiation::AD::NumberTypes ADTypeCode>\\n double Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_psi() const\\n {\\n return psi;\\n    }\\n \\n \\n template <int dim, Differentiation::AD::NumberTypes ADTypeCode>\\n Tensor<1, dim>\\n    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_B() const\\n {\\n const Tensor<1, dim> dpsi_dH =\\n        ad_helper.extract_gradient_component(Dpsi, H_components);\\n return -dpsi_dH;\\n    }\\n \\n \\n template <int dim, Differentiation::AD::NumberTypes ADTypeCode>\\n SymmetricTensor<2, dim>\\n    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_S() const\\n {\\n const SymmetricTensor<2, dim> dpsi_dC =\\n        ad_helper.extract_gradient_component(Dpsi, C_components);\\n return 2.0 * dpsi_dC;\\n    }\\n \\n \\n template <int dim, Differentiation::AD::NumberTypes ADTypeCode>\\n SymmetricTensor<2, dim>\\n    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_DD() const\\n {\\n const Tensor<2, dim> dpsi_dH_dH =\\n        ad_helper.extract_hessian_component(D2psi, H_components, H_components);\\n return -symmetrize(dpsi_dH_dH);\\n    }\\n \\n template <int dim, Differentiation::AD::NumberTypes ADTypeCode>\\n Tensor<3, dim>\\n    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_PP() const\\n {\\n const Tensor<3, dim> dpsi_dC_dH =\\n        ad_helper.extract_hessian_component(D2psi, C_components, H_components);\\n return -2.0 * dpsi_dC_dH;\\n    }\\n \\n \\n template <int dim, Differentiation::AD::NumberTypes ADTypeCode>\\n SymmetricTensor<4, dim>\\n    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_HH() const\\n {\\n const SymmetricTensor<4, dim> dpsi_dC_dC =\\n        ad_helper.extract_hessian_component(D2psi, C_components, C_components);\\n return 4.0 * dpsi_dC_dC;\\n    }\\n \\n \\n \\n template <int dim>\\n class Magnetoviscoelastic_Constitutive_Law_SD final\\n      : public Coupled_Magnetomechanical_Constitutive_Law_Base<dim>\\n    {\\n public:\\n      Magnetoviscoelastic_Constitutive_Law_SD(\\n const ConstitutiveParameters                &constitutive_parameters,\\n const Differentiation::SD::OptimizerType     optimizer_type,\\n const Differentiation::SD::OptimizationFlags optimization_flags);\\n \\n virtual void update_internal_data(const SymmetricTensor<2, dim> &C,\\n const Tensor<1, dim>          &H,\\n const DiscreteTime &time) override;\\n \\n virtual double get_psi() const override;\\n \\n virtual Tensor<1, dim> get_B() const override;\\n \\n virtual SymmetricTensor<2, dim> get_S() const override;\\n \\n virtual SymmetricTensor<2, dim> get_DD() const override;\\n \\n virtual Tensor<3, dim> get_PP() const override;\\n \\n virtual SymmetricTensor<4, dim> get_HH() const override;\\n \\n virtual void update_end_of_timestep() override;\\n \\n private:\\n SymmetricTensor<2, dim> Q_t;\\n SymmetricTensor<2, dim> Q_t1;\\n \\n const Differentiation::SD::Expression mu_e_sd;\\n const Differentiation::SD::Expression mu_e_inf_sd;\\n const Differentiation::SD::Expression mu_e_h_sat_sd;\\n const Differentiation::SD::Expression lambda_e_sd;\\n const Differentiation::SD::Expression mu_v_sd;\\n const Differentiation::SD::Expression mu_v_inf_sd;\\n const Differentiation::SD::Expression mu_v_h_sat_sd;\\n const Differentiation::SD::Expression tau_v_sd;\\n const Differentiation::SD::Expression delta_t_sd;\\n const Differentiation::SD::Expression mu_r_sd;\\n \\n const Tensor<1, dim, Differentiation::SD::Expression>          H_sd;\\n const SymmetricTensor<2, dim, Differentiation::SD::Expression> C_sd;\\n \\n const SymmetricTensor<2, dim, Differentiation::SD::Expression> Q_t_sd;\\n const SymmetricTensor<2, dim, Differentiation::SD::Expression> Q_t1_sd;\\n \\n Differentiation::SD::Expression                          psi_sd;\\n Tensor<1, dim, Differentiation::SD::Expression>          B_sd;\\n SymmetricTensor<2, dim, Differentiation::SD::Expression> S_sd;\\n SymmetricTensor<2, dim, Differentiation::SD::Expression> BB_sd;\\n Tensor<3, dim, Differentiation::SD::Expression>          PP_sd;\\n SymmetricTensor<4, dim, Differentiation::SD::Expression> HH_sd;\\n \\n Differentiation::SD::BatchOptimizer<double> optimizer;\\n \\n Differentiation::SD::types::substitution_map\\n make_substitution_map(const SymmetricTensor<2, dim> &C,\\n const Tensor<1, dim>          &H,\\n const double                   delta_t) const;\\n \\n void initialize_optimizer();\\n    };\\n \\n template <int dim>\\n    Magnetoviscoelastic_Constitutive_Law_SD<dim>::\\n      Magnetoviscoelastic_Constitutive_Law_SD(\\n const ConstitutiveParameters                &constitutive_parameters,\\n const Differentiation::SD::OptimizerType     optimizer_type,\\n const Differentiation::SD::OptimizationFlags optimization_flags)\\n      : Coupled_Magnetomechanical_Constitutive_Law_Base<dim>(\\n          constitutive_parameters)\\n      , Q_t(Physics::Elasticity::StandardTensors<dim>::I)\\n      , Q_t1(Physics::Elasticity::StandardTensors<dim>::I)\\n      , mu_e_sd(\\\"mu_e\\\")\\n      , mu_e_inf_sd(\\\"mu_e_inf\\\")\\n      , mu_e_h_sat_sd(\\\"mu_e_h_sat\\\")\\n      , lambda_e_sd(\\\"lambda_e\\\")\\n      , mu_v_sd(\\\"mu_v\\\")\\n      , mu_v_inf_sd(\\\"mu_v_inf\\\")\\n      , mu_v_h_sat_sd(\\\"mu_v_h_sat\\\")\\n      , tau_v_sd(\\\"tau_v\\\")\\n      , delta_t_sd(\\\"delta_t\\\")\\n      , mu_r_sd(\\\"mu_r\\\")\\n      , H_sd(Differentiation::SD::make_vector_of_symbols<dim>(\\\"H\\\"))\\n      , C_sd(Differentiation::SD::make_symmetric_tensor_of_symbols<2, dim>(\\\"C\\\"))\\n      , Q_t_sd(\\n Differentiation::SD::make_symmetric_tensor_of_symbols<2, dim>(\\\"Q_t\\\"))\\n      , Q_t1_sd(\\n Differentiation::SD::make_symmetric_tensor_of_symbols<2, dim>(\\\"Q_t1\\\"))\\n      , optimizer(optimizer_type, optimization_flags)\\n    {\\n      initialize_optimizer();\\n    }\\n \\n template <int dim>\\n Differentiation::SD::types::substitution_map\\n    Magnetoviscoelastic_Constitutive_Law_SD<dim>::make_substitution_map(\\n const SymmetricTensor<2, dim> &C,\\n const Tensor<1, dim>          &H,\\n const double                   delta_t) const\\n {\\n return Differentiation::SD::make_substitution_map(\\n        std::make_pair(mu_e_sd, this->get_mu_e()),\\n        std::make_pair(mu_e_inf_sd, this->get_mu_e_inf()),\\n        std::make_pair(mu_e_h_sat_sd, this->get_mu_e_h_sat()),\\n        std::make_pair(lambda_e_sd, this->get_lambda_e()),\\n        std::make_pair(mu_v_sd, this->get_mu_v()),\\n        std::make_pair(mu_v_inf_sd, this->get_mu_v_inf()),\\n        std::make_pair(mu_v_h_sat_sd, this->get_mu_v_h_sat()),\\n        std::make_pair(tau_v_sd, this->get_tau_v()),\\n        std::make_pair(delta_t_sd, delta_t),\\n        std::make_pair(mu_r_sd, this->get_mu_r()),\\n        std::make_pair(H_sd, H),\\n        std::make_pair(C_sd, C),\\n        std::make_pair(Q_t_sd, Q_t),\\n        std::make_pair(Q_t1_sd, Q_t1));\\n    }\\n \\n template <int dim>\\n void Magnetoviscoelastic_Constitutive_Law_SD<dim>::initialize_optimizer()\\n    {\\n const Differentiation::SD::Expression det_F_sd =\\n std::sqrt(determinant(C_sd));\\n const SymmetricTensor<2, dim, Differentiation::SD::Expression> C_inv_sd =\\n invert(C_sd);\\n \\n const Differentiation::SD::Expression f_mu_e_sd =\\n        1.0 +\\n        (mu_e_inf_sd / mu_e_sd - 1.0) *\\n std::tanh((2.0 * H_sd * H_sd) / (mu_e_h_sat_sd * mu_e_h_sat_sd));\\n \\n const Differentiation::SD::Expression psi_ME_sd =\\n        0.5 * mu_e_sd * f_mu_e_sd *\\n          (trace(C_sd) - dim - 2.0 * std::log(det_F_sd)) +\\n        lambda_e_sd * std::log(det_F_sd) * std::log(det_F_sd) -\\n        0.5 * this->get_mu_0() * mu_r_sd * det_F_sd * (H_sd * C_inv_sd * H_sd);\\n \\n const Differentiation::SD::Expression f_mu_v_sd =\\n        1.0 +\\n        (mu_v_inf_sd / mu_v_sd - 1.0) *\\n std::tanh((2.0 * H_sd * H_sd) / (mu_v_h_sat_sd * mu_v_h_sat_sd));\\n \\n const Differentiation::SD::Expression psi_MVE_sd =\\n        0.5 * mu_v_sd * f_mu_v_sd *\\n        (Q_t_sd * (std::pow(det_F_sd, -2.0 / dim) * C_sd) - dim -\\n std::log(determinant(Q_t_sd)));\\n \\n      psi_sd = psi_ME_sd + psi_MVE_sd;\\n \\n \\n      B_sd = -Differentiation::SD::differentiate(psi_sd, H_sd);\\n      S_sd = 2.0 * Differentiation::SD::differentiate(psi_sd, C_sd);\\n \\n const SymmetricTensor<2, dim, Differentiation::SD::Expression>\\n        Q_t_sd_explicit =\\n          (1.0 / (1.0 + delta_t_sd / tau_v_sd)) *\\n          (Q_t1_sd +\\n           (delta_t_sd / tau_v_sd * std::pow(det_F_sd, 2.0 / dim) * C_inv_sd));\\n \\n const Differentiation::SD::types::substitution_map\\n        substitution_map_explicit = Differentiation::SD::make_substitution_map(\\n          std::make_pair(Q_t_sd, Q_t_sd_explicit));\\n \\n      BB_sd = symmetrize(Differentiation::SD::differentiate(\\n Differentiation::SD::substitute(B_sd, substitution_map_explicit),\\n        H_sd));\\n      PP_sd = -Differentiation::SD::differentiate(\\n Differentiation::SD::substitute(S_sd, substitution_map_explicit), H_sd);\\n      HH_sd =\\n        2.0 *\\n Differentiation::SD::differentiate(\\n Differentiation::SD::substitute(S_sd, substitution_map_explicit),\\n          C_sd);\\n \\n      optimizer.register_symbols(\\n Differentiation::SD::Utilities::extract_symbols(\\n make_substitution_map({}, {}, 0)));\\n \\n      optimizer.register_functions(psi_sd, B_sd, S_sd, BB_sd, PP_sd, HH_sd);\\n \\n      optimizer.optimize();\\n    }\\n \\n template <int dim>\\n void Magnetoviscoelastic_Constitutive_Law_SD<dim>::update_internal_data(\\n const SymmetricTensor<2, dim> &C,\\n const Tensor<1, dim>          &H,\\n const DiscreteTime            &time)\\n    {\\n const double delta_t = this->get_delta_t(time);\\n \\n const double                  det_F = std::sqrt(determinant(C));\\n const SymmetricTensor<2, dim> C_inv = invert(C);\\n AssertThrow(det_F > 0.0,\\n                  ExcMessage(\\\"Volumetric Jacobian must be positive.\\\"));\\n \\n      Q_t = (1.0 / (1.0 + delta_t / this->get_tau_v())) *\\n            (Q_t1 + (delta_t / this->get_tau_v()) * std::pow(det_F, 2.0 / dim) *\\n                      C_inv);\\n \\n const auto substitution_map = make_substitution_map(C, H, delta_t);\\n \\n      optimizer.substitute(substitution_map);\\n    }\\n \\n template <int dim>\\n double Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_psi() const\\n {\\n return optimizer.evaluate(psi_sd);\\n    }\\n \\n \\n template <int dim>\\n Tensor<1, dim> Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_B() const\\n {\\n return optimizer.evaluate(B_sd);\\n    }\\n \\n \\n template <int dim>\\n SymmetricTensor<2, dim>\\n    Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_S() const\\n {\\n return optimizer.evaluate(S_sd);\\n    }\\n \\n \\n template <int dim>\\n SymmetricTensor<2, dim>\\n    Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_DD() const\\n {\\n return optimizer.evaluate(BB_sd);\\n    }\\n \\n \\n template <int dim>\\n Tensor<3, dim> Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_PP() const\\n {\\n return optimizer.evaluate(PP_sd);\\n    }\\n \\n \\n template <int dim>\\n SymmetricTensor<4, dim>\\n    Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_HH() const\\n {\\n return optimizer.evaluate(HH_sd);\\n    }\\n \\n template <int dim>\\n void Magnetoviscoelastic_Constitutive_Law_SD<dim>::update_end_of_timestep()\\n    {\\n      Q_t1 = Q_t;\\n    }\\n \\n \\n \\n \\n \\n template <int dim>\\n class Magnetoelastic_Constitutive_Law final\\n      : public Coupled_Magnetomechanical_Constitutive_Law_Base<dim>\\n    {\\n public:\\n      Magnetoelastic_Constitutive_Law(\\n const ConstitutiveParameters &constitutive_parameters);\\n \\n virtual void update_internal_data(const SymmetricTensor<2, dim> &C,\\n const Tensor<1, dim>          &H,\\n const DiscreteTime &) override;\\n \\n virtual double get_psi() const override;\\n \\n virtual Tensor<1, dim> get_B() const override;\\n \\n virtual SymmetricTensor<2, dim> get_S() const override;\\n \\n virtual SymmetricTensor<2, dim> get_DD() const override;\\n \\n virtual Tensor<3, dim> get_PP() const override;\\n \\n virtual SymmetricTensor<4, dim> get_HH() const override;\\n \\n private:\\n double                  psi;\\n Tensor<1, dim>          B;\\n SymmetricTensor<2, dim> S;\\n SymmetricTensor<2, dim> BB;\\n Tensor<3, dim>          PP;\\n SymmetricTensor<4, dim> HH;\\n    };\\n \\n \\n template <int dim>\\n    Magnetoelastic_Constitutive_Law<dim>::Magnetoelastic_Constitutive_Law(\\n const ConstitutiveParameters &constitutive_parameters)\\n      : Coupled_Magnetomechanical_Constitutive_Law_Base<dim>(\\n          constitutive_parameters)\\n      , psi(0.0)\\n    {}\\n \\n template <int dim>\\n void Magnetoelastic_Constitutive_Law<dim>::update_internal_data(\\n const SymmetricTensor<2, dim> &C,\\n const Tensor<1, dim>          &H,\\n const DiscreteTime &)\\n    {\\n const double                  det_F = std::sqrt(determinant(C));\\n const SymmetricTensor<2, dim> C_inv = invert(C);\\n AssertThrow(det_F > 0.0,\\n                  ExcMessage(\\\"Volumetric Jacobian must be positive.\\\"));\\n \\n const double two_h_dot_h_div_h_sat_squ =\\n        (2.0 * H * H) / (this->get_mu_e_h_sat() * this->get_mu_e_h_sat());\\n const double tanh_two_h_dot_h_div_h_sat_squ =\\n std::tanh(two_h_dot_h_div_h_sat_squ);\\n \\n const double f_mu_e =\\n        1.0 + (this->get_mu_e_inf() / this->get_mu_e() - 1.0) *\\n                tanh_two_h_dot_h_div_h_sat_squ;\\n \\n const double dtanh_two_h_dot_h_div_h_sat_squ =\\n Utilities::fixed_power<2>(1.0 / std::cosh(two_h_dot_h_div_h_sat_squ));\\n const Tensor<1, dim> dtwo_h_dot_h_div_h_sat_squ_dH =\\n        2.0 * 2.0 / (this->get_mu_e_h_sat() * this->get_mu_e_h_sat()) * H;\\n \\n const Tensor<1, dim> df_mu_e_dH =\\n        (this->get_mu_e_inf() / this->get_mu_e() - 1.0) *\\n        (dtanh_two_h_dot_h_div_h_sat_squ * dtwo_h_dot_h_div_h_sat_squ_dH);\\n \\n const double d2tanh_two_h_dot_h_div_h_sat_squ =\\n        -2.0 * tanh_two_h_dot_h_div_h_sat_squ * dtanh_two_h_dot_h_div_h_sat_squ;\\n const SymmetricTensor<2, dim> d2two_h_dot_h_div_h_sat_squ_dH_dH =\\n        2.0 * 2.0 / (this->get_mu_e_h_sat() * this->get_mu_e_h_sat()) *\\n Physics::Elasticity::StandardTensors<dim>::I;\\n \\n const SymmetricTensor<2, dim> d2f_mu_e_dH_dH =\\n        (this->get_mu_e_inf() / this->get_mu_e() - 1.0) *\\n        (d2tanh_two_h_dot_h_div_h_sat_squ *\\n symmetrize(outer_product(dtwo_h_dot_h_div_h_sat_squ_dH,\\n                                    dtwo_h_dot_h_div_h_sat_squ_dH)) +\\n         dtanh_two_h_dot_h_div_h_sat_squ * d2two_h_dot_h_div_h_sat_squ_dH_dH);\\n \\n const double         log_det_F         = std::log(det_F);\\n const double         tr_C              = trace(C);\\n const Tensor<1, dim> C_inv_dot_H       = C_inv * H;\\n const double         H_dot_C_inv_dot_H = H * C_inv_dot_H;\\n \\n const SymmetricTensor<2, dim> d_tr_C_dC =\\n Physics::Elasticity::StandardTensors<dim>::I;\\n const SymmetricTensor<2, dim> ddet_F_dC     = 0.5 * det_F * C_inv;\\n const SymmetricTensor<2, dim> dlog_det_F_dC = 0.5 * C_inv;\\n \\n const Tensor<1, dim> dH_dot_C_inv_dot_H_dH = 2.0 * C_inv_dot_H;\\n \\n SymmetricTensor<4, dim> dC_inv_dC;\\n for (unsigned int A = 0; A < dim; ++A)\\n for (unsigned int B = A; B < dim; ++B)\\n for (unsigned int C = 0; C < dim; ++C)\\n for (unsigned int D = C; D < dim; ++D)\\n              dC_inv_dC[A][B][C][D] -=               \\n                0.5 * (C_inv[A][C] * C_inv[B][D]     \\n                       + C_inv[A][D] * C_inv[B][C]); \\n \\n const SymmetricTensor<2, dim> dH_dot_C_inv_dot_H_dC =\\n        -symmetrize(outer_product(C_inv_dot_H, C_inv_dot_H));\\n \\n const SymmetricTensor<4, dim> d2log_det_F_dC_dC = 0.5 * dC_inv_dC;\\n \\n const SymmetricTensor<4, dim> d2det_F_dC_dC =\\n        0.5 * (outer_product(C_inv, ddet_F_dC) + det_F * dC_inv_dC);\\n \\n const SymmetricTensor<2, dim> d2H_dot_C_inv_dot_H_dH_dH = 2.0 * C_inv;\\n \\n Tensor<3, dim> d2H_dot_C_inv_dot_H_dC_dH;\\n for (unsigned int A = 0; A < dim; ++A)\\n for (unsigned int B = 0; B < dim; ++B)\\n for (unsigned int C = 0; C < dim; ++C)\\n            d2H_dot_C_inv_dot_H_dC_dH[A][B][C] -=\\n              C_inv[A][C] * C_inv_dot_H[B] + \\n              C_inv_dot_H[A] * C_inv[B][C];  \\n \\n SymmetricTensor<4, dim> d2H_dot_C_inv_dot_H_dC_dC;\\n for (unsigned int A = 0; A < dim; ++A)\\n for (unsigned int B = A; B < dim; ++B)\\n for (unsigned int C = 0; C < dim; ++C)\\n for (unsigned int D = C; D < dim; ++D)\\n              d2H_dot_C_inv_dot_H_dC_dC[A][B][C][D] +=\\n                0.5 * (C_inv_dot_H[A] * C_inv_dot_H[C] * C_inv[B][D] +\\n                       C_inv_dot_H[A] * C_inv_dot_H[D] * C_inv[B][C] +\\n                       C_inv_dot_H[B] * C_inv_dot_H[C] * C_inv[A][D] +\\n                       C_inv_dot_H[B] * C_inv_dot_H[D] * C_inv[A][C]);\\n \\n      psi =\\n        (0.5 * this->get_mu_e() * f_mu_e) *\\n          (tr_C - dim - 2.0 * std::log(det_F)) +\\n        this->get_lambda_e() * (std::log(det_F) * std::log(det_F)) -\\n        (0.5 * this->get_mu_0() * this->get_mu_r()) * det_F * (H * C_inv * H);\\n \\n      B = -(0.5 * this->get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) *\\n            df_mu_e_dH \\n          + 0.5 * this->get_mu_0() * this->get_mu_r() * det_F *\\n              dH_dot_C_inv_dot_H_dH; \\n \\n      S = 2.0 * (0.5 * this->get_mu_e() * f_mu_e) *                        \\n            (d_tr_C_dC - 2.0 * dlog_det_F_dC)                              \\n          + 2.0 * this->get_lambda_e() * (2.0 * log_det_F * dlog_det_F_dC) \\n          - 2.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) *            \\n              (H_dot_C_inv_dot_H * ddet_F_dC                               \\n               + det_F * dH_dot_C_inv_dot_H_dC);                           \\n \\n      BB = -(0.5 * this->get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * \\n             d2f_mu_e_dH_dH                                             \\n           + 0.5 * this->get_mu_0() * this->get_mu_r() * det_F *\\n               d2H_dot_C_inv_dot_H_dH_dH; \\n \\n      PP = -2.0 * (0.5 * this->get_mu_e()) *                                  \\n outer_product(Tensor<2, dim>(d_tr_C_dC - 2.0 * dlog_det_F_dC),   \\n                           df_mu_e_dH)                                        \\n           +                                                                  \\n           2.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) *                \\n             (outer_product(Tensor<2, dim>(ddet_F_dC), dH_dot_C_inv_dot_H_dH) \\n              + det_F * d2H_dot_C_inv_dot_H_dC_dH);                           \\n \\n      HH =\\n        4.0 * (0.5 * this->get_mu_e() * f_mu_e) * (-2.0 * d2log_det_F_dC_dC) \\n        + 4.0 * this->get_lambda_e() *                                       \\n            (2.0 * outer_product(dlog_det_F_dC, dlog_det_F_dC)               \\n             + 2.0 * log_det_F * d2log_det_F_dC_dC)                          \\n        - 4.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) *                \\n            (H_dot_C_inv_dot_H * d2det_F_dC_dC                               \\n             + outer_product(ddet_F_dC, dH_dot_C_inv_dot_H_dC)               \\n             + outer_product(dH_dot_C_inv_dot_H_dC, ddet_F_dC)               \\n             + det_F * d2H_dot_C_inv_dot_H_dC_dC);                           \\n    }\\n \\n template <int dim>\\n double Magnetoelastic_Constitutive_Law<dim>::get_psi() const\\n {\\n return psi;\\n    }\\n \\n template <int dim>\\n Tensor<1, dim> Magnetoelastic_Constitutive_Law<dim>::get_B() const\\n {\\n return B;\\n    }\\n \\n template <int dim>\\n SymmetricTensor<2, dim> Magnetoelastic_Constitutive_Law<dim>::get_S() const\\n {\\n return S;\\n    }\\n \\n template <int dim>\\n SymmetricTensor<2, dim> Magnetoelastic_Constitutive_Law<dim>::get_DD() const\\n {\\n return BB;\\n    }\\n \\n template <int dim>\\n Tensor<3, dim> Magnetoelastic_Constitutive_Law<dim>::get_PP() const\\n {\\n return PP;\\n    }\\n \\n template <int dim>\\n SymmetricTensor<4, dim> Magnetoelastic_Constitutive_Law<dim>::get_HH() const\\n {\\n return HH;\\n    }\\n \\n \\n \\n template <int dim>\\n class Magnetoviscoelastic_Constitutive_Law final\\n      : public Coupled_Magnetomechanical_Constitutive_Law_Base<dim>\\n    {\\n public:\\n      Magnetoviscoelastic_Constitutive_Law(\\n const ConstitutiveParameters &constitutive_parameters);\\n \\n virtual void update_internal_data(const SymmetricTensor<2, dim> &C,\\n const Tensor<1, dim>          &H,\\n const DiscreteTime &time) override;\\n \\n virtual double get_psi() const override;\\n \\n virtual Tensor<1, dim> get_B() const override;\\n \\n virtual SymmetricTensor<2, dim> get_S() const override;\\n \\n virtual SymmetricTensor<2, dim> get_DD() const override;\\n \\n virtual Tensor<3, dim> get_PP() const override;\\n \\n virtual SymmetricTensor<4, dim> get_HH() const override;\\n \\n virtual void update_end_of_timestep() override;\\n \\n private:\\n SymmetricTensor<2, dim> Q_t;\\n SymmetricTensor<2, dim> Q_t1;\\n \\n double                  psi;\\n Tensor<1, dim>          B;\\n SymmetricTensor<2, dim> S;\\n SymmetricTensor<2, dim> BB;\\n Tensor<3, dim>          PP;\\n SymmetricTensor<4, dim> HH;\\n \\n mutable GeneralDataStorage cache;\\n \\n void set_primary_variables(const SymmetricTensor<2, dim> &C,\\n const Tensor<1, dim>          &H) const;\\n \\n void update_internal_variable(const DiscreteTime &time);\\n \\n \\n const Tensor<1, dim> &get_H() const;\\n \\n const SymmetricTensor<2, dim> &get_C() const;\\n \\n double get_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const;\\n \\n double get_tanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const;\\n \\n double get_f_mu(const double mu,\\n const double mu_inf,\\n const double mu_h_sat) const;\\n \\n double get_dtanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const;\\n \\n Tensor<1, dim>\\n      get_dtwo_h_dot_h_div_h_sat_squ_dH(const double mu_h_sat) const;\\n \\n Tensor<1, dim> get_df_mu_dH(const double mu,\\n const double mu_inf,\\n const double mu_h_sat) const;\\n \\n double get_d2tanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const;\\n \\n SymmetricTensor<2, dim>\\n      get_d2two_h_dot_h_div_h_sat_squ_dH_dH(const double mu_h_sat) const;\\n \\n SymmetricTensor<2, dim> get_d2f_mu_dH_dH(const double mu,\\n const double mu_inf,\\n const double mu_h_sat) const;\\n \\n const double &get_det_F() const;\\n \\n const SymmetricTensor<2, dim> &get_C_inv() const;\\n \\n const double &get_log_det_F() const;\\n \\n const double &get_trace_C() const;\\n \\n const Tensor<1, dim> &get_C_inv_dot_H() const;\\n \\n const double &get_H_dot_C_inv_dot_H() const;\\n \\n const SymmetricTensor<4, dim> &get_dC_inv_dC() const;\\n \\n const SymmetricTensor<2, dim> &get_d_tr_C_dC() const;\\n \\n const SymmetricTensor<2, dim> &get_ddet_F_dC() const;\\n \\n const SymmetricTensor<2, dim> &get_dlog_det_F_dC() const;\\n \\n const Tensor<1, dim> &get_dH_dot_C_inv_dot_H_dH() const;\\n \\n const SymmetricTensor<2, dim> &get_dH_dot_C_inv_dot_H_dC() const;\\n \\n const SymmetricTensor<4, dim> &\\n      get_dQ_t_dC(const DiscreteTime &time) const;\\n \\n const SymmetricTensor<4, dim> &get_d2log_det_F_dC_dC() const;\\n \\n const SymmetricTensor<4, dim> &get_d2det_F_dC_dC() const;\\n \\n const SymmetricTensor<2, dim> &get_d2H_dot_C_inv_dot_H_dH_dH() const;\\n \\n const Tensor<3, dim> &get_d2H_dot_C_inv_dot_H_dC_dH() const;\\n \\n const SymmetricTensor<4, dim> &get_d2H_dot_C_inv_dot_H_dC_dC() const;\\n    };\\n \\n \\n template <int dim>\\n    Magnetoviscoelastic_Constitutive_Law<\\n      dim>::Magnetoviscoelastic_Constitutive_Law(const ConstitutiveParameters\\n                                                   &constitutive_parameters)\\n      : Coupled_Magnetomechanical_Constitutive_Law_Base<dim>(\\n          constitutive_parameters)\\n      , Q_t(Physics::Elasticity::StandardTensors<dim>::I)\\n      , Q_t1(Physics::Elasticity::StandardTensors<dim>::I)\\n      , psi(0.0)\\n    {}\\n \\n \\n template <int dim>\\n void Magnetoviscoelastic_Constitutive_Law<dim>::update_internal_data(\\n const SymmetricTensor<2, dim> &C,\\n const Tensor<1, dim>          &H,\\n const DiscreteTime            &time)\\n    {\\n      set_primary_variables(C, H);\\n      update_internal_variable(time);\\n \\n const double f_mu_e = get_f_mu(this->get_mu_e(),\\n                                     this->get_mu_e_inf(),\\n                                     this->get_mu_e_h_sat());\\n \\n const double f_mu_v = get_f_mu(this->get_mu_v(),\\n                                     this->get_mu_v_inf(),\\n                                     this->get_mu_v_h_sat());\\n \\n const Tensor<1, dim> df_mu_e_dH = get_df_mu_dH(this->get_mu_e(),\\n                                                     this->get_mu_e_inf(),\\n                                                     this->get_mu_e_h_sat());\\n \\n const Tensor<1, dim> df_mu_v_dH = get_df_mu_dH(this->get_mu_v(),\\n                                                     this->get_mu_v_inf(),\\n                                                     this->get_mu_v_h_sat());\\n \\n \\n const SymmetricTensor<2, dim> d2f_mu_e_dH_dH =\\n        get_d2f_mu_dH_dH(this->get_mu_e(),\\n                         this->get_mu_e_inf(),\\n                         this->get_mu_e_h_sat());\\n \\n const SymmetricTensor<2, dim> d2f_mu_v_dH_dH =\\n        get_d2f_mu_dH_dH(this->get_mu_v(),\\n                         this->get_mu_v_inf(),\\n                         this->get_mu_v_h_sat());\\n \\n const double                  &det_F = get_det_F();\\n const SymmetricTensor<2, dim> &C_inv = get_C_inv();\\n \\n const double &log_det_F         = get_log_det_F();\\n const double &tr_C              = get_trace_C();\\n const double &H_dot_C_inv_dot_H = get_H_dot_C_inv_dot_H();\\n \\n const SymmetricTensor<2, dim> &d_tr_C_dC     = get_d_tr_C_dC();\\n const SymmetricTensor<2, dim> &ddet_F_dC     = get_ddet_F_dC();\\n const SymmetricTensor<2, dim> &dlog_det_F_dC = get_dlog_det_F_dC();\\n \\n const SymmetricTensor<4, dim> &dQ_t_dC = get_dQ_t_dC(time);\\n \\n const Tensor<1, dim> &dH_dot_C_inv_dot_H_dH = get_dH_dot_C_inv_dot_H_dH();\\n \\n const SymmetricTensor<2, dim> &dH_dot_C_inv_dot_H_dC =\\n        get_dH_dot_C_inv_dot_H_dC();\\n \\n const SymmetricTensor<4, dim> &d2log_det_F_dC_dC =\\n        get_d2log_det_F_dC_dC();\\n \\n const SymmetricTensor<4, dim> &d2det_F_dC_dC = get_d2det_F_dC_dC();\\n \\n const SymmetricTensor<2, dim> &d2H_dot_C_inv_dot_H_dH_dH =\\n        get_d2H_dot_C_inv_dot_H_dH_dH();\\n \\n const Tensor<3, dim> &d2H_dot_C_inv_dot_H_dC_dH =\\n        get_d2H_dot_C_inv_dot_H_dC_dH();\\n \\n const SymmetricTensor<4, dim> &d2H_dot_C_inv_dot_H_dC_dC =\\n        get_d2H_dot_C_inv_dot_H_dC_dC();\\n \\n      psi = (0.5 * this->get_mu_e() * f_mu_e) *\\n              (tr_C - dim - 2.0 * std::log(det_F)) +\\n            this->get_lambda_e() * (std::log(det_F) * std::log(det_F));\\n      psi += (0.5 * this->get_mu_v() * f_mu_v) *\\n             (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -\\n std::log(determinant(Q_t)));\\n      psi -=\\n        (0.5 * this->get_mu_0() * this->get_mu_r()) * det_F * (H * C_inv * H);\\n \\n      B =\\n        -(0.5 * this->get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * df_mu_e_dH;\\n      B -= (0.5 * this->get_mu_v()) *\\n           (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -\\n std::log(determinant(Q_t))) *\\n           df_mu_v_dH;\\n      B += 0.5 * this->get_mu_0() * this->get_mu_r() * det_F *\\n           dH_dot_C_inv_dot_H_dH;\\n \\n      S = 2.0 * (0.5 * this->get_mu_e() * f_mu_e) *                         \\n            (d_tr_C_dC - 2.0 * dlog_det_F_dC)                               \\n          + 2.0 * this->get_lambda_e() * (2.0 * log_det_F * dlog_det_F_dC); \\n      S += 2.0 * (0.5 * this->get_mu_v() * f_mu_v) *\\n           ((Q_t * C) *\\n              ((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) * ddet_F_dC) +\\n std::pow(det_F, -2.0 / dim) * Q_t);                // dC/dC = II\\n      S -= 2.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) * \\n           (H_dot_C_inv_dot_H * ddet_F_dC                      \\n            + det_F * dH_dot_C_inv_dot_H_dC);                  \\n \\n      BB = -(0.5 * this->get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) *\\n           d2f_mu_e_dH_dH;\\n      BB -= (0.5 * this->get_mu_v()) *\\n            (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -\\n std::log(determinant(Q_t))) *\\n            d2f_mu_v_dH_dH;\\n      BB += 0.5 * this->get_mu_0() * this->get_mu_r() * det_F *\\n            d2H_dot_C_inv_dot_H_dH_dH;\\n \\n      PP = -2.0 * (0.5 * this->get_mu_e()) *\\n outer_product(Tensor<2, dim>(d_tr_C_dC - 2.0 * dlog_det_F_dC),\\n                         df_mu_e_dH);\\n      PP -= 2.0 * (0.5 * this->get_mu_v()) *\\n outer_product(Tensor<2, dim>((Q_t * C) *\\n                                           ((-2.0 / dim) *\\n std::pow(det_F, -2.0 / dim - 1.0) *\\n                                            ddet_F_dC) +\\n std::pow(det_F, -2.0 / dim) * Q_t),\\n                          df_mu_v_dH);\\n      PP += 2.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) *\\n            (outer_product(Tensor<2, dim>(ddet_F_dC), dH_dot_C_inv_dot_H_dH) +\\n             det_F * d2H_dot_C_inv_dot_H_dC_dH);\\n \\n      HH =\\n        4.0 * (0.5 * this->get_mu_e() * f_mu_e) * (-2.0 * d2log_det_F_dC_dC) \\n        + 4.0 * this->get_lambda_e() *                                       \\n            (2.0 * outer_product(dlog_det_F_dC, dlog_det_F_dC)               \\n             + 2.0 * log_det_F * d2log_det_F_dC_dC);                         \\n      HH += 4.0 * (0.5 * this->get_mu_v() * f_mu_v) *\\n            (outer_product((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *\\n                             ddet_F_dC,\\n                           C * dQ_t_dC + Q_t) +\\n             (Q_t * C) *\\n               (outer_product(ddet_F_dC,\\n                              (-2.0 / dim) * (-2.0 / dim - 1.0) *\\n std::pow(det_F, -2.0 / dim - 2.0) * ddet_F_dC) +\\n                ((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *\\n                 d2det_F_dC_dC)) +\\n outer_product(Q_t,\\n                           (-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *\\n                             ddet_F_dC) +\\n std::pow(det_F, -2.0 / dim) * dQ_t_dC);\\n      HH -= 4.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) * \\n            (H_dot_C_inv_dot_H * d2det_F_dC_dC                  \\n             + outer_product(ddet_F_dC, dH_dot_C_inv_dot_H_dC)  \\n             + outer_product(dH_dot_C_inv_dot_H_dC, ddet_F_dC)  \\n             + det_F * d2H_dot_C_inv_dot_H_dC_dC);              \\n \\n \\n      cache.reset();\\n    }\\n \\n template <int dim>\\n double Magnetoviscoelastic_Constitutive_Law<dim>::get_psi() const\\n {\\n return psi;\\n    }\\n \\n \\n template <int dim>\\n Tensor<1, dim> Magnetoviscoelastic_Constitutive_Law<dim>::get_B() const\\n {\\n return B;\\n    }\\n \\n \\n template <int dim>\\n SymmetricTensor<2, dim>\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_S() const\\n {\\n return S;\\n    }\\n \\n \\n template <int dim>\\n SymmetricTensor<2, dim>\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_DD() const\\n {\\n return BB;\\n    }\\n \\n \\n template <int dim>\\n Tensor<3, dim> Magnetoviscoelastic_Constitutive_Law<dim>::get_PP() const\\n {\\n return PP;\\n    }\\n \\n \\n template <int dim>\\n SymmetricTensor<4, dim>\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_HH() const\\n {\\n return HH;\\n    }\\n \\n \\n template <int dim>\\n void Magnetoviscoelastic_Constitutive_Law<dim>::update_end_of_timestep()\\n    {\\n      Q_t1 = Q_t;\\n    }\\n \\n \\n template <int dim>\\n void Magnetoviscoelastic_Constitutive_Law<dim>::update_internal_variable(\\n const DiscreteTime &time)\\n    {\\n const double delta_t = this->get_delta_t(time);\\n \\n      Q_t = (1.0 / (1.0 + delta_t / this->get_tau_v())) *\\n            (Q_t1 + (delta_t / this->get_tau_v()) *\\n std::pow(get_det_F(), 2.0 / dim) * get_C_inv());\\n    }\\n \\n template <int dim>\\n double\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_two_h_dot_h_div_h_sat_squ(\\n const double mu_h_sat) const\\n {\\n const Tensor<1, dim> &H = get_H();\\n return (2.0 * H * H) / (mu_h_sat * mu_h_sat);\\n    }\\n \\n \\n template <int dim>\\n double Magnetoviscoelastic_Constitutive_Law<\\n      dim>::get_tanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const\\n {\\n return std::tanh(get_two_h_dot_h_div_h_sat_squ(mu_h_sat));\\n    }\\n \\n template <int dim>\\n double Magnetoviscoelastic_Constitutive_Law<dim>::get_f_mu(\\n const double mu,\\n const double mu_inf,\\n const double mu_h_sat) const\\n {\\n return 1.0 +\\n             (mu_inf / mu - 1.0) * get_tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat);\\n    }\\n \\n template <int dim>\\n double Magnetoviscoelastic_Constitutive_Law<\\n      dim>::get_dtanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const\\n {\\n return std::pow(1.0 / std::cosh(get_two_h_dot_h_div_h_sat_squ(mu_h_sat)),\\n                      2.0);\\n    }\\n \\n \\n template <int dim>\\n Tensor<1, dim> Magnetoviscoelastic_Constitutive_Law<\\n      dim>::get_dtwo_h_dot_h_div_h_sat_squ_dH(const double mu_h_sat) const\\n {\\n return 2.0 * 2.0 / (mu_h_sat * mu_h_sat) * get_H();\\n    }\\n \\n \\n template <int dim>\\n Tensor<1, dim> Magnetoviscoelastic_Constitutive_Law<dim>::get_df_mu_dH(\\n const double mu,\\n const double mu_inf,\\n const double mu_h_sat) const\\n {\\n return (mu_inf / mu - 1.0) *\\n             (get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *\\n              get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat));\\n    }\\n \\n \\n template <int dim>\\n double Magnetoviscoelastic_Constitutive_Law<\\n      dim>::get_d2tanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const\\n {\\n return -2.0 * get_tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *\\n             get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat);\\n    }\\n \\n \\n template <int dim>\\n SymmetricTensor<2, dim> Magnetoviscoelastic_Constitutive_Law<\\n      dim>::get_d2two_h_dot_h_div_h_sat_squ_dH_dH(const double mu_h_sat) const\\n {\\n return 2.0 * 2.0 / (mu_h_sat * mu_h_sat) *\\n Physics::Elasticity::StandardTensors<dim>::I;\\n    }\\n \\n \\n template <int dim>\\n SymmetricTensor<2, dim>\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2f_mu_dH_dH(\\n const double mu,\\n const double mu_inf,\\n const double mu_h_sat) const\\n {\\n return (mu_inf / mu - 1.0) *\\n             (get_d2tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *\\n symmetrize(\\n outer_product(get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat),\\n                                get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat))) +\\n              get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *\\n                get_d2two_h_dot_h_div_h_sat_squ_dH_dH(mu_h_sat));\\n    }\\n \\n template <int dim>\\n void Magnetoviscoelastic_Constitutive_Law<dim>::set_primary_variables(\\n const SymmetricTensor<2, dim> &C,\\n const Tensor<1, dim>          &H) const\\n {\\n const std::string name_H(\\\"H\\\");\\n Assert(!cache.stores_object_with_name(name_H),\\n             ExcMessage(\\n \\\"The primary variable has already been added to the cache.\\\"));\\n      cache.add_unique_copy(name_H, H);\\n \\n const std::string name_C(\\\"C\\\");\\n Assert(!cache.stores_object_with_name(name_C),\\n             ExcMessage(\\n \\\"The primary variable has already been added to the cache.\\\"));\\n      cache.add_unique_copy(name_C, C);\\n    }\\n \\n template <int dim>\\n const Tensor<1, dim> &\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_H() const\\n {\\n const std::string name(\\\"H\\\");\\n Assert(cache.stores_object_with_name(name),\\n             ExcMessage(\\\"Primary variables must be added to the cache.\\\"));\\n return cache.template get_object_with_name<Tensor<1, dim>>(name);\\n    }\\n \\n template <int dim>\\n const SymmetricTensor<2, dim> &\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_C() const\\n {\\n const std::string name(\\\"C\\\");\\n Assert(cache.stores_object_with_name(name),\\n             ExcMessage(\\\"Primary variables must be added to the cache.\\\"));\\n return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);\\n    }\\n \\n template <int dim>\\n const double &Magnetoviscoelastic_Constitutive_Law<dim>::get_det_F() const\\n {\\n const std::string name(\\\"det_F\\\");\\n if (cache.stores_object_with_name(name) == false)\\n        {\\n const double det_F = std::sqrt(determinant(get_C()));\\n AssertThrow(det_F > 0.0,\\n                      ExcMessage(\\\"Volumetric Jacobian must be positive.\\\"));\\n          cache.add_unique_copy(name, det_F);\\n        }\\n \\n return cache.template get_object_with_name<double>(name);\\n    }\\n \\n \\n template <int dim>\\n const SymmetricTensor<2, dim> &\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_C_inv() const\\n {\\n const std::string name(\\\"C_inv\\\");\\n if (cache.stores_object_with_name(name) == false)\\n        {\\n          cache.add_unique_copy(name, invert(get_C()));\\n        }\\n \\n return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);\\n    }\\n \\n \\n template <int dim>\\n const double &\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_log_det_F() const\\n {\\n const std::string name(\\\"log(det_F)\\\");\\n if (cache.stores_object_with_name(name) == false)\\n        cache.add_unique_copy(name, std::log(get_det_F()));\\n \\n return cache.template get_object_with_name<double>(name);\\n    }\\n \\n \\n template <int dim>\\n const double &Magnetoviscoelastic_Constitutive_Law<dim>::get_trace_C() const\\n {\\n const std::string name(\\\"trace(C)\\\");\\n if (cache.stores_object_with_name(name) == false)\\n        cache.add_unique_copy(name, trace(get_C()));\\n \\n return cache.template get_object_with_name<double>(name);\\n    }\\n \\n \\n template <int dim>\\n const Tensor<1, dim> &\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_C_inv_dot_H() const\\n {\\n const std::string name(\\\"C_inv_dot_H\\\");\\n if (cache.stores_object_with_name(name) == false)\\n        cache.add_unique_copy(name, get_C_inv() * get_H());\\n \\n return cache.template get_object_with_name<Tensor<1, dim>>(name);\\n    }\\n \\n \\n template <int dim>\\n const double &\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_H_dot_C_inv_dot_H() const\\n {\\n const std::string name(\\\"H_dot_C_inv_dot_H\\\");\\n if (cache.stores_object_with_name(name) == false)\\n        cache.add_unique_copy(name, get_H() * get_C_inv_dot_H());\\n \\n return cache.template get_object_with_name<double>(name);\\n    }\\n \\n \\n template <int dim>\\n const SymmetricTensor<4, dim> &\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_dQ_t_dC(\\n const DiscreteTime &time) const\\n {\\n const std::string name(\\\"dQ_t_dC\\\");\\n if (cache.stores_object_with_name(name) == false)\\n        {\\n const double  delta_t = this->get_delta_t(time);\\n const double &det_F   = get_det_F();\\n \\n const SymmetricTensor<4, dim> dQ_t_dC =\\n            (1.0 / (1.0 + delta_t / this->get_tau_v())) *\\n            (delta_t / this->get_tau_v()) *\\n            ((2.0 / dim) * std::pow(det_F, 2.0 / dim - 1.0) *\\n outer_product(get_C_inv(), get_ddet_F_dC()) +\\n std::pow(det_F, 2.0 / dim) * get_dC_inv_dC());\\n \\n          cache.add_unique_copy(name, dQ_t_dC);\\n        }\\n \\n return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name);\\n    }\\n \\n \\n template <int dim>\\n const SymmetricTensor<4, dim> &\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_dC_inv_dC() const\\n {\\n const std::string name(\\\"dC_inv_dC\\\");\\n if (cache.stores_object_with_name(name) == false)\\n        {\\n const SymmetricTensor<2, dim> &C_inv = get_C_inv();\\n SymmetricTensor<4, dim>        dC_inv_dC;\\n \\n for (unsigned int A = 0; A < dim; ++A)\\n for (unsigned int B = A; B < dim; ++B)\\n for (unsigned int C = 0; C < dim; ++C)\\n for (unsigned int D = C; D < dim; ++D)\\n                  dC_inv_dC[A][B][C][D] -=               \\n                    0.5 * (C_inv[A][C] * C_inv[B][D]     \\n                           + C_inv[A][D] * C_inv[B][C]); \\n \\n          cache.add_unique_copy(name, dC_inv_dC);\\n        }\\n \\n return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name);\\n    }\\n \\n \\n template <int dim>\\n const SymmetricTensor<2, dim> &\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_d_tr_C_dC() const\\n {\\n const std::string name(\\\"d_tr_C_dC\\\");\\n if (cache.stores_object_with_name(name) == false)\\n        cache.add_unique_copy(name,\\n Physics::Elasticity::StandardTensors<dim>::I);\\n \\n return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);\\n    }\\n \\n \\n template <int dim>\\n const SymmetricTensor<2, dim> &\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_ddet_F_dC() const\\n {\\n const std::string name(\\\"ddet_F_dC\\\");\\n if (cache.stores_object_with_name(name) == false)\\n        cache.add_unique_copy(name, 0.5 * get_det_F() * get_C_inv());\\n \\n return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);\\n    }\\n \\n \\n template <int dim>\\n const SymmetricTensor<2, dim> &\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_dlog_det_F_dC() const\\n {\\n const std::string name(\\\"dlog_det_F_dC\\\");\\n if (cache.stores_object_with_name(name) == false)\\n        cache.add_unique_copy(name, 0.5 * get_C_inv());\\n \\n return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);\\n    }\\n \\n \\n template <int dim>\\n const Tensor<1, dim> &\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_dH_dot_C_inv_dot_H_dH() const\\n {\\n const std::string name(\\\"dH_dot_C_inv_dot_H_dH\\\");\\n if (cache.stores_object_with_name(name) == false)\\n        cache.add_unique_copy(name, 2.0 * get_C_inv_dot_H());\\n \\n return cache.template get_object_with_name<Tensor<1, dim>>(name);\\n    }\\n \\n \\n template <int dim>\\n const SymmetricTensor<2, dim> &\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_dH_dot_C_inv_dot_H_dC() const\\n {\\n const std::string name(\\\"dH_dot_C_inv_dot_H_dC\\\");\\n if (cache.stores_object_with_name(name) == false)\\n        {\\n const Tensor<1, dim> C_inv_dot_H = get_C_inv_dot_H();\\n          cache.add_unique_copy(\\n            name, -symmetrize(outer_product(C_inv_dot_H, C_inv_dot_H)));\\n        }\\n \\n return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);\\n    }\\n \\n \\n template <int dim>\\n const SymmetricTensor<4, dim> &\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2log_det_F_dC_dC() const\\n {\\n const std::string name(\\\"d2log_det_F_dC_dC\\\");\\n if (cache.stores_object_with_name(name) == false)\\n        cache.add_unique_copy(name, 0.5 * get_dC_inv_dC());\\n \\n return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name);\\n    }\\n \\n \\n template <int dim>\\n const SymmetricTensor<4, dim> &\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2det_F_dC_dC() const\\n {\\n const std::string name(\\\"d2det_F_dC_dC\\\");\\n if (cache.stores_object_with_name(name) == false)\\n        cache.add_unique_copy(name,\\n                              0.5 *\\n                                (outer_product(get_C_inv(), get_ddet_F_dC()) +\\n                                 get_det_F() * get_dC_inv_dC()));\\n \\n return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name);\\n    }\\n \\n \\n template <int dim>\\n const SymmetricTensor<2, dim> &\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2H_dot_C_inv_dot_H_dH_dH()\\n      const\\n {\\n const std::string name(\\\"d2H_dot_C_inv_dot_H_dH_dH\\\");\\n if (cache.stores_object_with_name(name) == false)\\n        cache.add_unique_copy(name, 2.0 * get_C_inv());\\n \\n return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);\\n    }\\n \\n \\n template <int dim>\\n const Tensor<3, dim> &\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2H_dot_C_inv_dot_H_dC_dH()\\n      const\\n {\\n const std::string name(\\\"d2H_dot_C_inv_dot_H_dC_dH\\\");\\n if (cache.stores_object_with_name(name) == false)\\n        {\\n const Tensor<1, dim>          &C_inv_dot_H = get_C_inv_dot_H();\\n const SymmetricTensor<2, dim> &C_inv       = get_C_inv();\\n \\n Tensor<3, dim> d2H_dot_C_inv_dot_H_dC_dH;\\n for (unsigned int A = 0; A < dim; ++A)\\n for (unsigned int B = 0; B < dim; ++B)\\n for (unsigned int C = 0; C < dim; ++C)\\n                d2H_dot_C_inv_dot_H_dC_dH[A][B][C] -=\\n                  C_inv[A][C] * C_inv_dot_H[B] + \\n                  C_inv_dot_H[A] * C_inv[B][C];  \\n \\n          cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dH);\\n        }\\n \\n return cache.template get_object_with_name<Tensor<3, dim>>(name);\\n    }\\n \\n \\n template <int dim>\\n const SymmetricTensor<4, dim> &\\n    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2H_dot_C_inv_dot_H_dC_dC()\\n      const\\n {\\n const std::string name(\\\"d2H_dot_C_inv_dot_H_dC_dC\\\");\\n if (cache.stores_object_with_name(name) == false)\\n        {\\n const Tensor<1, dim>          &C_inv_dot_H = get_C_inv_dot_H();\\n const SymmetricTensor<2, dim> &C_inv       = get_C_inv();\\n \\n SymmetricTensor<4, dim> d2H_dot_C_inv_dot_H_dC_dC;\\n for (unsigned int A = 0; A < dim; ++A)\\n for (unsigned int B = A; B < dim; ++B)\\n for (unsigned int C = 0; C < dim; ++C)\\n for (unsigned int D = C; D < dim; ++D)\\n                  d2H_dot_C_inv_dot_H_dC_dC[A][B][C][D] +=\\n                    0.5 * (C_inv_dot_H[A] * C_inv_dot_H[C] * C_inv[B][D] +\\n                           C_inv_dot_H[A] * C_inv_dot_H[D] * C_inv[B][C] +\\n                           C_inv_dot_H[B] * C_inv_dot_H[C] * C_inv[A][D] +\\n                           C_inv_dot_H[B] * C_inv_dot_H[D] * C_inv[A][C]);\\n \\n          cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dC);\\n        }\\n \\n return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name);\\n    }\\n \\n \\n class RheologicalExperimentParameters : public ParameterAcceptor\\n    {\\n public:\\n      RheologicalExperimentParameters();\\n \\n double sample_radius = 0.01;\\n double sample_height = 0.001;\\n \\n double lambda_2 = 0.95;\\n double gamma_12 = 0.05;\\n double H_2      = 60.0e3;\\n \\n double       frequency         = 1.0 / (2.0 * numbers::PI);\\n unsigned int n_cycles          = 5;\\n unsigned int n_steps_per_cycle = 2500;\\n \\n bool        output_data_to_file = true;\\n      std::string output_filename_rd =\\n \\\"experimental_results-rate_dependent.csv\\\";\\n      std::string output_filename_ri =\\n \\\"experimental_results-rate_independent.csv\\\";\\n \\n double start_time() const;\\n \\n double end_time() const;\\n \\n double delta_t() const;\\n \\n Tensor<1, 3> get_H(const double time) const;\\n \\n Tensor<2, 3> get_F(const double time) const;\\n \\n bool print_status(const int step_number) const;\\n \\n bool initialized = false;\\n    };\\n \\n \\n \\n    RheologicalExperimentParameters::RheologicalExperimentParameters()\\n      : ParameterAcceptor(\\\"/Coupled Constitutive Laws/Rheological Experiment/\\\")\\n    {\\n      add_parameter(\\\"Experimental sample radius\\\", sample_radius);\\n      add_parameter(\\\"Experimental sample radius\\\", sample_height);\\n \\n      add_parameter(\\\"Axial stretch\\\", lambda_2);\\n      add_parameter(\\\"Shear strain amplitude\\\", gamma_12);\\n      add_parameter(\\\"Axial magnetic field strength\\\", H_2);\\n \\n      add_parameter(\\\"Frequency\\\", frequency);\\n      add_parameter(\\\"Number of loading cycles\\\", n_cycles);\\n      add_parameter(\\\"Discretisation for each cycle\\\", n_steps_per_cycle);\\n \\n      add_parameter(\\\"Output experimental results to file\\\", output_data_to_file);\\n      add_parameter(\\\"Output file name (rate dependent constitutive law)\\\",\\n                    output_filename_rd);\\n      add_parameter(\\\"Output file name (rate independent constitutive law)\\\",\\n                    output_filename_ri);\\n \\n      parse_parameters_call_back.connect([&]() -> void { initialized = true; });\\n    }\\n \\n \\n double RheologicalExperimentParameters::start_time() const\\n {\\n return 0.0;\\n    }\\n \\n \\n double RheologicalExperimentParameters::end_time() const\\n {\\n return n_cycles / frequency;\\n    }\\n \\n \\n double RheologicalExperimentParameters::delta_t() const\\n {\\n return (end_time() - start_time()) / (n_steps_per_cycle * n_cycles);\\n    }\\n \\n \\n bool\\n    RheologicalExperimentParameters::print_status(const int step_number) const\\n {\\n return (step_number % (n_cycles * n_steps_per_cycle / 100)) == 0;\\n    }\\n \\n Tensor<1, 3> RheologicalExperimentParameters::get_H(const double) const\\n {\\n return Tensor<1, 3>({0.0, 0.0, H_2});\\n    }\\n \\n Tensor<2, 3> RheologicalExperimentParameters::get_F(const double time) const\\n {\\n AssertThrow((sample_radius > 0.0 && sample_height > 0.0),\\n                  ExcMessage(\\\"Non-physical sample dimensions\\\"));\\n AssertThrow(lambda_2 > 0.0,\\n                  ExcMessage(\\\"Non-physical applied axial stretch\\\"));\\n \\n const double sqrt_lambda_2     = std::sqrt(lambda_2);\\n const double inv_sqrt_lambda_2 = 1.0 / sqrt_lambda_2;\\n \\n const double alpha_max =\\n std::atan(std::tan(gamma_12) * sample_height /\\n                  sample_radius); // Small strain approximation\\n const double A       = sample_radius * alpha_max;\\n const double w       = 2.0 * numbers::PI * frequency; // in rad /s\\n const double gamma_t = A * std::sin(w * time);\\n const double tau_t =\\n        gamma_t /\\n        (sample_radius * sample_height); // Torsion angle per unit length\\n const double alpha_t = tau_t * lambda_2 * sample_height;\\n \\n Tensor<2, 3> F;\\n F[0][0] = inv_sqrt_lambda_2 * std::cos(alpha_t);\\n F[0][1] = -inv_sqrt_lambda_2 * std::sin(alpha_t);\\n F[0][2] = -tau_t * sample_radius * sqrt_lambda_2 * std::sin(alpha_t);\\n F[1][0] = inv_sqrt_lambda_2 * std::sin(alpha_t);\\n F[1][1] = inv_sqrt_lambda_2 * std::cos(alpha_t);\\n F[1][2] = tau_t * sample_radius * sqrt_lambda_2 * std::cos(alpha_t);\\n F[2][0] = 0.0;\\n F[2][1] = 0.0;\\n F[2][2] = lambda_2;\\n \\n AssertThrow((F[0][0] > 0) && (F[1][1] > 0) && (F[2][2] > 0),\\n                  ExcMessage(\\\"Non-physical deformation gradient component.\\\"));\\n AssertThrow(std::abs(determinant(F) - 1.0) < 1e-6,\\n                  ExcMessage(\\\"Volumetric Jacobian is not equal to unity.\\\"));\\n \\n return F;\\n    }\\n \\n \\n template <int dim>\\n void run_rheological_experiment(\\n const RheologicalExperimentParameters &experimental_parameters,\\n      Coupled_Magnetomechanical_Constitutive_Law_Base<dim>\\n        &material_hand_calculated,\\n      Coupled_Magnetomechanical_Constitutive_Law_Base<dim>\\n                        &material_assisted_computation,\\n TimerOutput       &timer,\\n const std::string &filename)\\n    {\\n const auto check_material_class_results =\\n        [](\\n const Coupled_Magnetomechanical_Constitutive_Law_Base<dim> &to_verify,\\n const Coupled_Magnetomechanical_Constitutive_Law_Base<dim> &blessed,\\n const double tol = 1e-6) {\\n          (void)to_verify;\\n          (void)blessed;\\n          (void)tol;\\n \\n Assert(std::abs(blessed.get_psi() - to_verify.get_psi()) < tol,\\n                 ExcMessage(\\\"No match for psi. Error: \\\" +\\n Utilities::to_string(std::abs(\\n                              blessed.get_psi() - to_verify.get_psi()))));\\n \\n Assert((blessed.get_B() - to_verify.get_B()).norm() < tol,\\n                 ExcMessage(\\\"No match for B. Error: \\\" +\\n Utilities::to_string(\\n                              (blessed.get_B() - to_verify.get_B()).norm())));\\n Assert((blessed.get_S() - to_verify.get_S()).norm() < tol,\\n                 ExcMessage(\\\"No match for S. Error: \\\" +\\n Utilities::to_string(\\n                              (blessed.get_S() - to_verify.get_S()).norm())));\\n \\n Assert((blessed.get_DD() - to_verify.get_DD()).norm() < tol,\\n                 ExcMessage(\\\"No match for BB. Error: \\\" +\\n Utilities::to_string(\\n                              (blessed.get_DD() - to_verify.get_DD()).norm())));\\n Assert((blessed.get_PP() - to_verify.get_PP()).norm() < tol,\\n                 ExcMessage(\\\"No match for PP. Error: \\\" +\\n Utilities::to_string(\\n                              (blessed.get_PP() - to_verify.get_PP()).norm())));\\n Assert((blessed.get_HH() - to_verify.get_HH()).norm() < tol,\\n                 ExcMessage(\\\"No match for HH. Error: \\\" +\\n Utilities::to_string(\\n                              (blessed.get_HH() - to_verify.get_HH()).norm())));\\n        };\\n \\n      std::ostringstream stream;\\n      stream\\n        << \\\"Time;Axial magnetic field strength [A/m];Axial magnetic induction [T];Shear strain [%];Shear stress [Pa]\\\\n\\\";\\n \\n for (DiscreteTime time(experimental_parameters.start_time(),\\n                             experimental_parameters.end_time() +\\n                               experimental_parameters.delta_t(),\\n                             experimental_parameters.delta_t());\\n           time.is_at_end() == false;\\n           time.advance_time())\\n        {\\n if (experimental_parameters.print_status(time.get_step_number()))\\n            std::cout << \\\"Timestep = \\\" << time.get_step_number()\\n                      << \\\" @ time = \\\" << time.get_current_time() << \\\"s.\\\"\\n                      << std::endl;\\n \\n const Tensor<1, dim> H =\\n            experimental_parameters.get_H(time.get_current_time());\\n const Tensor<2, dim> F =\\n            experimental_parameters.get_F(time.get_current_time());\\n const SymmetricTensor<2, dim> C =\\n Physics::Elasticity::Kinematics::C(F);\\n \\n          {\\n TimerOutput::Scope timer_section(timer, \\\"Hand calculated\\\");\\n            material_hand_calculated.update_internal_data(C, H, time);\\n            material_hand_calculated.update_end_of_timestep();\\n          }\\n \\n          {\\n TimerOutput::Scope timer_section(timer, \\\"Assisted computation\\\");\\n            material_assisted_computation.update_internal_data(C, H, time);\\n            material_assisted_computation.update_end_of_timestep();\\n          }\\n \\n          check_material_class_results(material_hand_calculated,\\n                                       material_assisted_computation);\\n \\n if (experimental_parameters.output_data_to_file)\\n            {\\n const Tensor<1, dim> h =\\n Physics::Transformations::Covariant::push_forward(H, F);\\n const Tensor<1, dim> b =\\n Physics::Transformations::Piola::push_forward(\\n                  material_hand_calculated.get_B(), F);\\n const SymmetricTensor<2, dim> sigma =\\n Physics::Transformations::Piola::push_forward(\\n                  material_hand_calculated.get_S(), F);\\n              stream << time.get_current_time() << ';' << h[2] << ';' << b[2]\\n                     << ';' << F[1][2] * 100.0 << ';' << sigma[1][2] << '\\\\n';\\n            }\\n        }\\n \\n if (experimental_parameters.output_data_to_file)\\n        {\\n          std::ofstream output(filename);\\n          output << stream.str();\\n        }\\n    }\\n \\n \\n void run(int argc, char *argv[])\\n    {\\n using namespace dealii;\\n \\n constexpr unsigned int dim = 3;\\n \\n const ConstitutiveParameters          constitutive_parameters;\\n const RheologicalExperimentParameters experimental_parameters;\\n \\n      std::string parameter_file;\\n if (argc > 1)\\n        parameter_file = argv[1];\\n else\\n        parameter_file = \\\"parameters.prm\\\";\\n ParameterAcceptor::initialize(parameter_file, \\\"used_parameters.prm\\\");\\n \\n      {\\n TimerOutput timer(std::cout,\\n TimerOutput::summary,\\n TimerOutput::wall_times);\\n        std::cout\\n          << \\\"Coupled magnetoelastic constitutive law using automatic differentiation.\\\"\\n          << std::endl;\\n \\n constexpr Differentiation::AD::NumberTypes ADTypeCode =\\n Differentiation::AD::NumberTypes::sacado_dfad_dfad;\\n \\n        Magnetoelastic_Constitutive_Law<dim> material(constitutive_parameters);\\n        Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode> material_ad(\\n          constitutive_parameters);\\n \\n        run_rheological_experiment(experimental_parameters,\\n                                   material,\\n                                   material_ad,\\n                                   timer,\\n                                   experimental_parameters.output_filename_ri);\\n \\n        std::cout << \\\"... all calculations are correct!\\\" << std::endl;\\n      }\\n \\n      {\\n TimerOutput timer(std::cout,\\n TimerOutput::summary,\\n TimerOutput::wall_times);\\n        std::cout\\n          << \\\"Coupled magneto-viscoelastic constitutive law using symbolic differentiation.\\\"\\n          << std::endl;\\n \\n#ifdef DEAL_II_SYMENGINE_WITH_LLVM\\n        std::cout << \\\"Using LLVM optimizer.\\\" << std::endl;\\n constexpr Differentiation::SD::OptimizerType optimizer_type =\\n Differentiation::SD::OptimizerType::llvm;\\n constexpr Differentiation::SD::OptimizationFlags optimization_flags =\\n Differentiation::SD::OptimizationFlags::optimize_all;\\n#else\\n        std::cout << \\\"Using lambda optimizer.\\\" << std::endl;\\n constexpr Differentiation::SD::OptimizerType optimizer_type =\\n Differentiation::SD::OptimizerType::lambda;\\n constexpr Differentiation::SD::OptimizationFlags optimization_flags =\\n Differentiation::SD::OptimizationFlags::optimize_cse;\\n#endif\\n \\n        Magnetoviscoelastic_Constitutive_Law<dim> material(\\n          constitutive_parameters);\\n \\n        timer.enter_subsection(\\\"Initialize symbolic CL\\\");\\n        Magnetoviscoelastic_Constitutive_Law_SD<dim> material_sd(\\n          constitutive_parameters, optimizer_type, optimization_flags);\\n        timer.leave_subsection();\\n \\n        run_rheological_experiment(experimental_parameters,\\n                                   material,\\n                                   material_sd,\\n                                   timer,\\n                                   experimental_parameters.output_filename_rd);\\n \\n        std::cout << \\\"... all calculations are correct!\\\" << std::endl;\\n      }\\n    }\\n \\n  } // namespace CoupledConstitutiveLaws\\n \\n} // namespace Step71\\n \\n \\n \\nint main(int argc, char *argv[])\\n{\\n  Step71::SimpleExample::run();\\n  Step71::CoupledConstitutiveLaws::run(argc, argv);\\n \\n return 0;\\n}\\nad.h\\nDifferentiation::SD::Expression::substitute_and_evaluateReturnType substitute_and_evaluate(const types::substitution_map &substitution_values) const\\nDiscreteTime::get_previous_step_sizedouble get_previous_step_size() constDefinition discrete_time.h:507\\nTimerOutput::leave_subsectionvoid leave_subsection(const std::string &section_name=\\\"\\\")Definition timer.cc:443\\nTimerOutput::enter_subsectionvoid enter_subsection(const std::string &section_name)Definition timer.cc:401\\ndiscrete_time.h\\ngeneral_data_storage.h\\nutilities.h\\nkinematics.h\\nDifferentiation::SD::make_symmetric_tensor_of_symbolsSymmetricTensor< rank, dim, Expression > make_symmetric_tensor_of_symbols(const std::string &symbol)Definition symengine_tensor_operations.cc:263\\nDifferentiation::SD::make_vector_of_symbolsTensor< 1, dim, Expression > make_vector_of_symbols(const std::string &symbol)Definition symengine_tensor_operations.cc:236\\nPhysics::Elasticity::Kinematics::wTensor< 2, dim, Number > w(const Tensor< 2, dim, Number > &F, const Tensor< 2, dim, Number > &dF_dt)\\nPhysics::Elasticity::Kinematics::bSymmetricTensor< 2, dim, Number > b(const Tensor< 2, dim, Number > &F)\\nPhysics::Elasticity::Kinematics::FTensor< 2, dim, Number > F(const Tensor< 2, dim, Number > &Grad_u)\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\nnumbers.h\\nparameter_acceptor.h\\nsd.h\\nstandard_tensors.h\\nsymmetric_tensor.h\\ntensor.h\\ntimer.h\\ntransformations.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"