"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_62.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-62 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-62 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-62 tutorial program\\n\\n\\nThis tutorial depends on step-8, step-40.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nElastic equations\\nSimulation parameters\\n\\n The commented program\\n\\nInclude files\\nAuxiliary classes and functions\\n\\nThe `RightHandSide` class\\nThe `PML` class\\nThe `Rho` class\\nThe `Parameters` class\\nThe `QuadratureCache` class\\nThe `get_stiffness_tensor()` function\\n\\nThe `ElasticWave` class\\nImplementation of the auxiliary classes\\n\\nThe `RightHandSide` class implementation\\nThe `PML` class implementation\\nThe `Rho` class implementation\\nThe `Parameters` class implementation\\nThe `QuadratureCache` class implementation\\n\\nImplementation of the `ElasticWave` class\\n\\nConstructor\\nElasticWave::setup_system\\nElasticWave::assemble_system\\nElasticWave::solve\\nElasticWave::initialize_position_vector\\nElasticWave::store_frequency_step_data\\nElasticWave::output_results\\nElasticWave::setup_quadrature_cache\\nElasticWave::frequency_sweep\\nElasticWave::run\\nThe main function\\n\\n\\n\\n Results\\n\\nResonance frequency and bandgap\\nMode profile\\nExperimental applications\\nPossibilities for extensions\\n\\n The plain program\\n   \\n\\n\\nThis program was contributed by Daniel Garcia-Sanchez. \\n\\nNoteAs a prerequisite of this program, you need to have HDF5, complex PETSc, and the p4est libraries installed. The installation of deal.II together with these additional libraries is described in the README file.\\nIntroduction\\nA phononic crystal is a periodic nanostructure that modifies the motion of mechanical vibrations or phonons. Phononic structures can be used to disperse, route and confine mechanical vibrations. These structures have potential applications in quantum information and have been used to study macroscopic quantum phenomena. Phononic crystals are usually fabricated in cleanrooms.\\nIn this tutorial we show how to a design a phononic superlattice cavity which is a particular type of phononic crystal that can be used to confine mechanical vibrations. A phononic superlattice cavity is formed by two Distributed Bragg Reflector, mirrors and a \\\\(\\\\lambda/2\\\\) cavity where \\\\(\\\\lambda\\\\) is the acoustic wavelength. Acoustic DBRs are periodic structures where a set of bilayer stacks with contrasting physical properties (sound velocity index) is repeated \\\\(N\\\\) times. Superlattice cavities are usually grown on a Gallium Arsenide wafer by Molecular Beam Epitaxy. The bilayers correspond to GaAs/AlAs mirror pairs. As shown below, the thickness of the mirror layers (brown and green) is \\\\(\\\\lambda/4\\\\) and the thickness of the cavity (blue) is \\\\(\\\\lambda/2\\\\).\\n\\nIn this tutorial we calculate the band gap and the mechanical resonance of a phononic superlattice cavity but the code presented here can be easily used to design and calculate other types of phononic crystals.\\nThe device is a waveguide in which the wave goes from left to right. The simulations of this tutorial are done in 2D, but the code is dimension independent and can be easily used with 3D simulations. The waveguide width is equal to the \\\\(y\\\\) dimension of the domain and the waveguide length is equal to the \\\\(x\\\\) dimension of the domain. There are two regimes that depend on the waveguide width:\\nSingle mode: In this case the width of the structure is much smaller than the wavelength. This case can be solved either with FEM (the approach that we take here) or with a simple semi-analytical 1D transfer matrix formalism.\\nMultimode: In this case the width of the structure is larger than the wavelength. This case can be solved using FEM or with a scattering matrix formalism. Although we do not study this case in this tutorial, it is very easy to reach the multimode regime by increasing the parameter waveguide width (dimension_y in the jupyter notebook).\\n\\nThe simulations of this tutorial are performed in the frequency domain. To calculate the transmission spectrum, we use a procedure that is commonly used in time domain FDTD simulations. A pulse at a certain frequency is generated on the left side of the structure and the transmitted energy is measured on the right side of the structure. The simulation is run twice. First, we run the simulation with the phononic structure and measure the transmitted energy:\\n\\nThen, we run the simulation without the phononic structure and measure the transmitted energy. We use the simulation without the structure for the calibration:\\n\\nThe transmission coefficient corresponds to the energy of the first simulation divided by the calibration energy. We repeat this procedure for each frequency step.\\nElastic equations\\nWhat we want to simulate here is the transmission of elastic waves. Consequently, the right description of the problem uses the elastic equations, which in the time domain are given by    \\n\\\\[\\n\\\\rho\\\\partial_{tt} u_i - \\\\partial_j (c_{ijkl} \\\\varepsilon_{kl}) = f_i,\\n\\\\qquad i=0,1,2\\n\\\\]\\n\\n where the stiffness tensor \\\\(c_{ijkl}\\\\) depends on the spatial coordinates and the strain is the symmetrized gradient of the displacement, given by   \\n\\\\[\\n\\\\varepsilon_{kl} =\\\\frac{1}{2}(\\\\partial_k u_l + \\\\partial_l u_k)\\n\\\\]\\n\\nA perfectly matched layer (PML) can be used to truncate the solution at the boundaries. A PML is a transformation that results in a complex coordinate stretching.\\nInstead of a time domain approach, this tutorial program converts the equations above into the frequency domain by performing a Fourier transform with regard to the time variable. The elastic equations in the frequency domain then read as follows        \\n\\\\begin{eqnarray*}\\n\\\\nabla\\\\cdot(\\\\boldsymbol{\\\\bar\\\\sigma} \\\\xi \\\\boldsymbol{\\\\Lambda})&=&-\\\\omega^2\\\\rho\\\\xi\\\\mathbf{\\\\bar u}\\\\\\\\\\n\\\\boldsymbol{\\\\bar \\\\sigma} &=&\\\\mathbf{C}\\\\boldsymbol{\\\\bar\\\\varepsilon}\\\\\\\\\\n\\\\boldsymbol{\\\\bar\\\\varepsilon}&=&\\\\frac{1}{2}[(\\\\nabla\\\\mathbf{\\\\bar{u}}\\\\boldsymbol{\\\\Lambda}+\\\\boldsymbol{\\\\Lambda}^\\\\mathrm{T}(\\\\nabla\\\\mathbf{\\\\bar{u}})^\\\\mathrm{T})]\\\\\\\\\\n\\\\xi &=&\\\\prod_i^\\\\textrm{dim}s_i\\\\\\\\\\n\\\\boldsymbol{\\\\Lambda} &=& \\\\operatorname{diag}(1/s_0,1/s_1,1/s_2)\\\\qquad\\\\textrm{for 3D}\\\\\\\\\\n\\\\boldsymbol{\\\\Lambda} &=& \\\\operatorname{diag}(1/s_0,1/s_1)\\\\qquad\\\\textrm{for 2D}\\n\\\\end{eqnarray*}\\n\\n where the coefficients \\\\(s_i = 1+is_i'(x,y,z)\\\\) account for the absorption. There are 3 \\\\(s_i\\\\) coefficients in 3D and 2 in 2D. The imaginary par of \\\\(s_i\\\\) is equal to zero outside the PML. The PMLs are reflectionless only for the exact wave equations. When the set of equations is discretized the PML is no longer reflectionless. The reflections can be made arbitrarily small as long as the medium is slowly varying, see the adiabatic theorem. In the code a quadratic turn-on of the PML has been used. A linear and cubic turn-on is also known to work. These equations can be expanded into    \\n\\\\[\\n-\\\\omega^2\\\\rho \\\\xi  u_m - \\\\partial_n \\\\left(\\\\frac{\\\\xi}{s_n}c_{mnkl}\\n\\\\varepsilon_{kl}\\\\right) = f_m\\n\\\\]\\n\\n\\n\\\\[\\n\\\\varepsilon_{kl} =\\\\frac{1}{2}\\\\left(\\\\frac{1}{s_k}\\\\partial_k u_l\\n+ \\\\frac{1}{s_l}\\\\partial_l u_k\\\\right)\\n\\\\]\\n\\n where summation over repeated indices (here \\\\(n\\\\), as well as \\\\(k\\\\) and \\\\(l\\\\)) is as always implied. Note that the strain is no longer symmetric after applying the complex coordinate stretching of the PML. This set of equations can be written as    \\n\\\\[\\n-\\\\omega^2\\\\rho \\\\xi  u_m - \\\\partial_n \\\\left(\\\\frac{\\\\xi c_{mnkl}}{2s_n s_k} \\\\partial_k u_l\\n+ \\\\frac{\\\\xi c_{mnkl}}{2s_n s_l} \\\\partial_l u_k\\\\right) = f_m\\n\\\\]\\n\\nThe same as the strain, the stress tensor is not symmetric inside the PML ( \\\\(s_j\\\\neq 0\\\\)). Indeed the fields inside the PML are not physical. It is useful to introduce the tensors \\\\(\\\\alpha_{mnkl}\\\\) and \\\\(\\\\beta_{mnkl}\\\\).    \\n\\\\[\\n-\\\\omega^2\\\\rho \\\\xi  u_m - \\\\partial_n \\\\left(\\\\alpha_{mnkl}\\\\partial_k u_l\\n+  \\\\beta_{mnkl}\\\\partial_l u_k\\\\right) = f_m\\n\\\\]\\n\\nWe can multiply by \\\\(\\\\varphi_m\\\\) and integrate over the domain \\\\(\\\\Omega\\\\) and integrate by parts.    \\n\\\\begin{eqnarray*}\\n-\\\\omega^2\\\\int_\\\\Omega\\\\rho\\\\xi\\\\varphi_m u_m + \\\\int_\\\\Omega\\\\partial_n\\\\varphi_m \\\\left(\\\\frac{\\\\xi c_{mnkl}}{2s_n s_k} \\\\partial_k u_l\\n+ \\\\frac{\\\\xi c_{mnkl}}{2s_n s_l} \\\\partial_l u_k\\\\right) = \\\\int_\\\\Omega\\\\varphi_m f_m\\n\\\\end{eqnarray*}\\n\\n It is this set of equations we want to solve for a set of frequencies \\\\(\\\\omega\\\\) in order to compute the transmission coefficient as function of frequency. The linear system becomes      \\n\\\\begin{eqnarray*}\\nAU&=&F\\\\\\\\\\nA_{ij} &=& -\\\\omega^2\\\\int_\\\\Omega\\\\rho \\\\xi\\\\varphi_m^i \\\\varphi_m^j + \\\\int_\\\\Omega\\\\partial_n\\\\varphi_m^i \\\\left(\\\\frac{\\\\xi c_{mnkl}}{2s_n s_k} \\\\partial_k \\\\varphi_l^j\\n+ \\\\frac{\\\\xi c_{mnkl}}{2s_n s_l} \\\\partial_l \\\\varphi_k^j\\\\right)\\\\\\\\\\nF_i &=& \\\\int_\\\\Omega\\\\varphi_m^i f_m\\n\\\\end{eqnarray*}\\n\\nSimulation parameters\\nIn this tutorial we use a python jupyter notebook to set up the parameters and run the simulation. First we create a HDF5 file where we store the parameters and the results of the simulation.\\nEach of the simulations (displacement and calibration) is stored in a separate HDF5 group: import numpy as np\\nimport h5py\\nimport matplotlib.pyplot as plt\\nimport subprocess\\nimport scipy.constants as constants\\nimport scipy.optimize\\n \\n# This considerably reduces the size of the svg data\\nplt.rcParams['svg.fonttype'] = 'none'\\n \\nh5_file = h5py.File('results.h5', 'w')\\ndata = h5_file.create_group('data')\\ndisplacement = data.create_group('displacement')\\ncalibration = data.create_group('calibration')\\n \\n# Set the parameters\\nfor group in [displacement, calibration]:\\n # Dimensions of the domain\\n # The waveguide length is equal to dimension_x\\n    group.attrs['dimension_x'] = 2e-5\\n # The waveguide width is equal to dimension_y\\n    group.attrs['dimension_y'] = 2e-8\\n \\n # Position of the probe that we use to measure the flux\\n    group.attrs['probe_pos_x']   = 8e-6\\n    group.attrs['probe_pos_y']   = 0\\n    group.attrs['probe_width_y'] = 2e-08\\n \\n # Number of points in the probe\\n    group.attrs['nb_probe_points'] = 5\\n \\n # Global refinement\\n    group.attrs['grid_level'] = 1\\n \\n # Cavity\\n    group.attrs['cavity_resonance_frequency'] = 20e9\\n    group.attrs['nb_mirror_pairs']            = 15\\n \\n # Material\\n    group.attrs['poissons_ratio'] = 0.27\\n    group.attrs['youngs_modulus'] = 270000000000.0\\n    group.attrs['material_a_rho'] = 3200\\n if group == displacement:\\n        group.attrs['material_b_rho'] = 2000\\n else:\\n        group.attrs['material_b_rho'] = 3200\\n    group.attrs['lambda'] = (group.attrs['youngs_modulus'] * group.attrs['poissons_ratio'] /\\n                           ((1 + group.attrs['poissons_ratio']) *\\n                           (1 - 2 * group.attrs['poissons_ratio'])))\\n    group.attrs['mu']= (group.attrs['youngs_modulus'] / (2 * (1 + group.attrs['poissons_ratio'])))\\n \\n # Force\\n    group.attrs['max_force_amplitude'] = 1e26\\n    group.attrs['force_sigma_x']       = 1e-7\\n    group.attrs['force_sigma_y']       = 1\\n    group.attrs['max_force_width_x']   = 3e-7\\n    group.attrs['max_force_width_y']   = 2e-8\\n    group.attrs['force_x_pos']         = -8e-6\\n    group.attrs['force_y_pos']         = 0\\n \\n # PML\\n    group.attrs['pml_x']            = True\\n    group.attrs['pml_y']            = False\\n    group.attrs['pml_width_x']      = 1.8e-6\\n    group.attrs['pml_width_y']      = 5e-7\\n    group.attrs['pml_coeff']        = 1.6\\n    group.attrs['pml_coeff_degree'] = 2\\n \\n # Frequency sweep\\n    group.attrs['center_frequency']    = 20e9\\n    group.attrs['frequency_range']     = 0.5e9\\n    group.attrs['start_frequency']     = group.attrs['center_frequency'] - group.attrs['frequency_range'] / 2\\n    group.attrs['stop_frequency']      = group.attrs['center_frequency'] + group.attrs['frequency_range'] / 2\\n    group.attrs['nb_frequency_points'] = 400\\n \\n # Other parameters\\n if group == displacement:\\n        group.attrs['simulation_name'] = 'phononic_cavity_displacement'\\n else:\\n        group.attrs['simulation_name'] = 'phononic_cavity_calibration'\\n    group.attrs['save_vtu_files'] = False\\n \\nh5_file.close()\\n The commented program\\n Include files\\nMost of the include files we need for this program have already been discussed in previous programs, in particular in step-40.\\n\\u00a0 #include <deal.II/base/conditional_ostream.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/base/index_set.h>\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/timer.h>\\n\\u00a0 #include <deal.II/base/utilities.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_system.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_refinement.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/generic_linear_algebra.h>\\n\\u00a0 #include <deal.II/lac/petsc_solver.h>\\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/error_estimator.h>\\n\\u00a0 \\n\\u00a0 #include <fstream>\\n\\u00a0 #include <iostream>\\n\\u00a0 \\nThe following header provides the Tensor class that we use to represent the material properties.\\n\\u00a0 #include <deal.II/base/tensor.h>\\n\\u00a0 \\n\\u00a0 \\nThe following header is necessary for the HDF5 interface of deal.II.\\n\\u00a0 #include <deal.II/base/hdf5.h>\\n\\u00a0 \\nThis header is required for the function VectorTools::point_value that we use to evaluate the result of the simulation.\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 \\nWe need these headers for the function GridTools::find_active_cell_around_point that we use in the function ElasticWave::store_frequency_step_data()\\n\\u00a0 #include <deal.II/grid/grid_tools.h>\\n\\u00a0 #include <deal.II/grid/grid_tools_cache.h>\\n\\u00a0 \\n\\u00a0 namespace step62\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n Auxiliary classes and functions\\nThe following classes are used to store the parameters of the simulation.\\n The RightHandSide class\\nThis class is used to define the force pulse on the left side of the structure:\\n\\u00a0   template <int dim>\\n\\u00a0   class RightHandSide : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     RightHandSide(HDF5::Group &data);\\n\\u00a0 \\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component) const override;\\n\\u00a0 \\n\\u00a0   private:\\nFunctionDefinition function.h:152\\nFunction::valuevirtual RangeNumberType value(const Point< dim > &p, const unsigned int component=0) const\\nHDF5::GroupDefinition hdf5.h:977\\nPointDefinition point.h:111\\nThe variable data is the HDF5::Group in which all the simulation results will be stored. Note that the variables RightHandSide::data, PML::data, Rho::data and Parameters::data point to the same group of the HDF5 file. When a HDF5::Group is copied, it will point to the same group of the HDF5 file.\\n\\u00a0     HDF5::Group data;\\n\\u00a0 \\nThe simulation parameters are stored in data as HDF5 attributes. The following attributes are defined in the jupyter notebook, stored in data as HDF5 attributes and then read by the constructor.\\n\\u00a0     const double     max_force_amplitude;\\n\\u00a0     const double     force_sigma_x;\\n\\u00a0     const double     force_sigma_y;\\n\\u00a0     const double     max_force_width_x;\\n\\u00a0     const double     max_force_width_y;\\n\\u00a0     const Point<dim> force_center;\\n\\u00a0 \\n\\u00a0   public:\\nIn this particular simulation the force has only a \\\\(x\\\\) component, \\\\(F_y=0\\\\).\\n\\u00a0     const unsigned int force_component = 0;\\n\\u00a0   };\\n\\u00a0 \\n The PML class\\nThis class is used to define the shape of the Perfectly Matches Layer (PML) to absorb waves traveling towards the boundary:\\n\\u00a0   template <int dim>\\n\\u00a0   class PML : public Function<dim, std::complex<double>>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     PML(HDF5::Group &data);\\n\\u00a0 \\n\\u00a0     virtual std::complex<double>\\n\\u00a0     value(const Point<dim> &p, const unsigned int component) const override;\\n\\u00a0 \\n\\u00a0   private:\\nHDF5::Group in which all the simulation results will be stored.\\n\\u00a0     HDF5::Group data;\\n\\u00a0 \\nThe same as before, the following attributes are defined in the jupyter notebook, stored in data as HDF5 attributes and then read by the constructor.\\n\\u00a0     const double pml_coeff;\\n\\u00a0     const int    pml_coeff_degree;\\n\\u00a0     const double dimension_x;\\n\\u00a0     const double dimension_y;\\n\\u00a0     const bool   pml_x;\\n\\u00a0     const bool   pml_y;\\n\\u00a0     const double pml_width_x;\\n\\u00a0     const double pml_width_y;\\n\\u00a0     const double a_coeff_x;\\n\\u00a0     const double a_coeff_y;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n The Rho class\\nThis class is used to define the mass density.\\n\\u00a0   template <int dim>\\n\\u00a0   class Rho : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     Rho(HDF5::Group &data);\\n\\u00a0 \\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component = 0) const override;\\n\\u00a0 \\n\\u00a0   private:\\nHDF5::Group in which all the simulation results will be stored.\\n\\u00a0     HDF5::Group data;\\n\\u00a0 \\nThe same as before, the following attributes are defined in the jupyter notebook, stored in data as HDF5 attributes and then read by the constructor.\\n\\u00a0     const double       lambda;\\n\\u00a0     const double       mu;\\n\\u00a0     const double       material_a_rho;\\n\\u00a0     const double       material_b_rho;\\n\\u00a0     const double       cavity_resonance_frequency;\\n\\u00a0     const unsigned int nb_mirror_pairs;\\n\\u00a0     const double       dimension_y;\\n\\u00a0     const unsigned int grid_level;\\n\\u00a0     double             average_rho_width;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n The Parameters class\\nThis class contains all the parameters that will be used in the simulation.\\n\\u00a0   template <int dim>\\n\\u00a0   class Parameters\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     Parameters(HDF5::Group &data);\\n\\u00a0 \\nHDF5::Group in which all the simulation results will be stored.\\n\\u00a0     HDF5::Group data;\\n\\u00a0 \\nThe same as before, the following attributes are defined in the jupyter notebook, stored in data as HDF5 attributes and then read by the constructor.\\n\\u00a0     const std::string        simulation_name;\\n\\u00a0     const bool               save_vtu_files;\\n\\u00a0     const double             start_frequency;\\n\\u00a0     const double             stop_frequency;\\n\\u00a0     const unsigned int       nb_frequency_points;\\n\\u00a0     const double             lambda;\\n\\u00a0     const double             mu;\\n\\u00a0     const double             dimension_x;\\n\\u00a0     const double             dimension_y;\\n\\u00a0     const unsigned int       nb_probe_points;\\n\\u00a0     const unsigned int       grid_level;\\n\\u00a0     const Point<dim>         probe_start_point;\\n\\u00a0     const Point<dim>         probe_stop_point;\\n\\u00a0     const RightHandSide<dim> right_hand_side;\\n\\u00a0     const PML<dim>           pml;\\n\\u00a0     const Rho<dim>           rho;\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     const double comparison_float_constant = 1e-12;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n The QuadratureCache class\\nThe calculation of the mass and stiffness matrices is very expensive. These matrices are the same for all the frequency steps. The right hand side vector is also the same for all the frequency steps. We use this class to store these objects and re-use them at each frequency step. Note that here we don't store the assembled mass and stiffness matrices and right hand sides, but instead the data for a single cell. QuadratureCache class is very similar to the PointHistory class that has been used in step-18.\\n\\u00a0   template <int dim>\\n\\u00a0   class QuadratureCache\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     QuadratureCache(const unsigned int dofs_per_cell);\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     unsigned int dofs_per_cell;\\n\\u00a0 \\n\\u00a0   public:\\nWe store the mass and stiffness matrices in the variables mass_coefficient and stiffness_coefficient. We store as well the right_hand_side and JxW values which are going to be the same for all the frequency steps.\\n\\u00a0     FullMatrix<std::complex<double>>  mass_coefficient;\\n\\u00a0     FullMatrix<std::complex<double>>  stiffness_coefficient;\\n\\u00a0     std::vector<std::complex<double>> right_hand_side;\\n\\u00a0     double                            JxW;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFullMatrixDefinition full_matrix.h:79\\n The get_stiffness_tensor() function\\nThis function returns the stiffness tensor of the material. For the sake of simplicity we consider the stiffness to be isotropic and homogeneous; only the density \\\\(\\\\rho\\\\) depends on the position. As we have previously shown in step-8, if the stiffness is isotropic and homogeneous, the stiffness coefficients \\\\(c_{ijkl}\\\\) can be expressed as a function of the two coefficients \\\\(\\\\lambda\\\\) and \\\\(\\\\mu\\\\). The coefficient tensor reduces to      \\n\\\\[\\n   c_{ijkl}\\n   =\\n   \\\\lambda \\\\delta_{ij} \\\\delta_{kl} +\\n   \\\\mu (\\\\delta_{ik} \\\\delta_{jl} + \\\\delta_{il} \\\\delta_{jk}).\\n   \\\\]\\n\\n\\u00a0   template <int dim>\\n\\u00a0   SymmetricTensor<4, dim> get_stiffness_tensor(const double lambda,\\n\\u00a0                                                const double mu)\\n\\u00a0   {\\n\\u00a0     SymmetricTensor<4, dim> stiffness_tensor;\\n\\u00a0     for (unsigned int i = 0; i < dim; ++i)\\n\\u00a0       for (unsigned int j = 0; j < dim; ++j)\\n\\u00a0         for (unsigned int k = 0; k < dim; ++k)\\n\\u00a0           for (unsigned int l = 0; l < dim; ++l)\\n\\u00a0             stiffness_tensor[i][j][k][l] =\\n\\u00a0               (((i == k) && (j == l) ? mu : 0.0) +\\n\\u00a0                ((i == l) && (j == k) ? mu : 0.0) +\\n\\u00a0                ((i == j) && (k == l) ? lambda : 0.0));\\n\\u00a0     return stiffness_tensor;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nSymmetricTensorDefinition symmetric_tensor.h:719\\n The ElasticWave class\\nNext let's declare the main class of this program. Its structure is very similar to the step-40 tutorial program. The main differences are:\\nThe sweep over the frequency values.\\nWe save the stiffness and mass matrices in quadrature_cache and use them for each frequency step.\\nWe store the measured energy by the probe for each frequency step in the HDF5 file.\\n\\n\\u00a0   template <int dim>\\n\\u00a0   class ElasticWave\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     ElasticWave(const Parameters<dim> &parameters);\\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void setup_system();\\n\\u00a0     void assemble_system(const double omega,\\n\\u00a0                          const bool   calculate_quadrature_data);\\n\\u00a0     void solve();\\n\\u00a0     void initialize_probe_positions_vector();\\n\\u00a0     void store_frequency_step_data(const unsigned int frequency_idx);\\n\\u00a0     void output_results();\\n\\u00a0 \\nThis is called before every frequency step to set up a pristine state for the cache variables.\\n\\u00a0     void setup_quadrature_cache();\\n\\u00a0 \\nThis function loops over the frequency vector and runs the simulation for each frequency step.\\n\\u00a0     void frequency_sweep();\\n\\u00a0 \\nThe parameters are stored in this variable.\\n\\u00a0     Parameters<dim> parameters;\\n\\u00a0 \\n\\u00a0     MPI_Comm mpi_communicator;\\n\\u00a0 \\n\\u00a0     parallel::distributed::Triangulation<dim> triangulation;\\n\\u00a0 \\n\\u00a0     const QGauss<dim> quadrature_formula;\\n\\u00a0 \\nMPI_Comm\\nQGaussDefinition quadrature_lib.h:40\\nparallel::distributed::TriangulationDefinition tria.h:268\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\nWe store the mass and stiffness matrices for each cell this vector.\\n\\u00a0     std::vector<QuadratureCache<dim>> quadrature_cache;\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     const FESystem<dim> fe;\\n\\u00a0     DoFHandler<dim>     dof_handler;\\n\\u00a0 \\n\\u00a0     IndexSet locally_owned_dofs;\\n\\u00a0     IndexSet locally_relevant_dofs;\\n\\u00a0 \\n\\u00a0     AffineConstraints<std::complex<double>> constraints;\\n\\u00a0 \\n\\u00a0     LinearAlgebraPETSc::MPI::SparseMatrix system_matrix;\\n\\u00a0     LinearAlgebraPETSc::MPI::Vector       locally_relevant_solution;\\n\\u00a0     LinearAlgebraPETSc::MPI::Vector       system_rhs;\\n\\u00a0 \\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nDoFHandlerDefinition dof_handler.h:317\\nFESystemDefinition fe_system.h:208\\nIndexSetDefinition index_set.h:70\\nPETScWrappers::MPI::SparseMatrixDefinition petsc_sparse_matrix.h:367\\nPETScWrappers::MPI::VectorDefinition petsc_vector.h:158\\nThis vector contains the range of frequencies that we are going to simulate.\\n\\u00a0     std::vector<double> frequency;\\n\\u00a0 \\nThis vector contains the coordinates \\\\((x,y)\\\\) of the points of the measurement probe.\\n\\u00a0     FullMatrix<double> probe_positions;\\n\\u00a0 \\nHDF5 datasets to store the frequency and probe_positions vectors.\\n\\u00a0     HDF5::DataSet frequency_dataset;\\n\\u00a0     HDF5::DataSet probe_positions_dataset;\\n\\u00a0 \\nHDF5::DataSetDefinition hdf5.h:426\\nHDF5 dataset that stores the values of the energy measured by the probe.\\n\\u00a0     HDF5::DataSet displacement;\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     ConditionalOStream pcout;\\n\\u00a0     TimerOutput        computing_timer;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nConditionalOStreamDefinition conditional_ostream.h:80\\nTimerOutputDefinition timer.h:549\\n Implementation of the auxiliary classes\\n The RightHandSide class implementation\\nThe constructor reads all the parameters from the HDF5::Group data using the HDF5::Group::get_attribute() function.\\n\\u00a0   template <int dim>\\n\\u00a0   RightHandSide<dim>::RightHandSide(HDF5::Group &data)\\n\\u00a0     : Function<dim>(dim)\\n\\u00a0     , data(data)\\n\\u00a0     , max_force_amplitude(data.get_attribute<double>(\\\"max_force_amplitude\\\"))\\n\\u00a0     , force_sigma_x(data.get_attribute<double>(\\\"force_sigma_x\\\"))\\n\\u00a0     , force_sigma_y(data.get_attribute<double>(\\\"force_sigma_y\\\"))\\n\\u00a0     , max_force_width_x(data.get_attribute<double>(\\\"max_force_width_x\\\"))\\n\\u00a0     , max_force_width_y(data.get_attribute<double>(\\\"max_force_width_y\\\"))\\n\\u00a0     , force_center(Point<dim>(data.get_attribute<double>(\\\"force_x_pos\\\"),\\n\\u00a0                               data.get_attribute<double>(\\\"force_y_pos\\\")))\\n\\u00a0   {}\\n\\u00a0 \\nThis function defines the spatial shape of the force vector pulse which takes the form of a Gaussian function           \\n\\\\begin{align*}\\n   F_x &=\\n   \\\\left\\\\{\\n   \\\\begin{array}{ll}\\n   a \\\\exp(- (\\\\frac{(x-b_x)^2 }{ 2 \\\\sigma_x^2}+\\\\frac{(y-b_y)^2 }{ 2\\n   \\\\sigma_y^2}))\\n   & \\\\text{if}\\\\, x_\\\\textrm{min} <x<x_\\\\textrm{max}\\\\, \\\\text{and}\\\\,\\n   y_\\\\textrm{min} <y<y_\\\\textrm{max}  \\\\\\\\ 0 & \\\\text{otherwise},\\n   \\\\end{array}\\n   \\\\right.\\\\\\\\ F_y &= 0\\n   \\\\end{align*}\\n\\n where \\\\(a\\\\) is the maximum amplitude that takes the force and \\\\(\\\\sigma_x\\\\) and \\\\(\\\\sigma_y\\\\) are the standard deviations for the \\\\(x\\\\) and \\\\(y\\\\) components. Note that the pulse has been cropped to \\\\(x_\\\\textrm{min}<x<x_\\\\textrm{max}\\\\) and \\\\(y_\\\\textrm{min} <y<y_\\\\textrm{max}\\\\).\\n\\u00a0   template <int dim>\\n\\u00a0   double RightHandSide<dim>::value(const Point<dim>  &p,\\n\\u00a0                                    const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     if (component == force_component)\\n\\u00a0       {\\n\\u00a0         if (std::abs(p[0] - force_center[0]) < max_force_width_x / 2 &&\\n\\u00a0             std::abs(p[1] - force_center[1]) < max_force_width_y / 2)\\n\\u00a0           {\\n\\u00a0             return max_force_amplitude *\\n\\u00a0                    std::exp(\\n\\u00a0                      -(Utilities::fixed_power<2>(p[0] - force_center[0]) /\\n\\u00a0                          (2 * Utilities::fixed_power<2>(force_sigma_x)) +\\n\\u00a0                        Utilities::fixed_power<2>(p[1] - force_center[1]) /\\n\\u00a0                          (2 * Utilities::fixed_power<2>(force_sigma_y))));\\n\\u00a0           }\\n\\u00a0         else\\n\\u00a0           {\\n\\u00a0             return 0;\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       {\\n\\u00a0         return 0;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nUtilities::fixed_powerconstexpr T fixed_power(const T t)Definition utilities.h:942\\nstd::exp::VectorizedArray< Number, width > exp(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6829\\nstd::abs::VectorizedArray< Number, width > abs(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6927\\n The PML class implementation\\nAs before, the constructor reads all the parameters from the HDF5::Group data using the HDF5::Group::get_attribute() function. As we have discussed, a quadratic turn-on of the PML has been defined in the jupyter notebook. It is possible to use a linear, cubic or another power degree by changing the parameter pml_coeff_degree. The parameters pml_x and pml_y can be used to turn on and off the x and y PMLs.\\n\\u00a0   template <int dim>\\n\\u00a0   PML<dim>::PML(HDF5::Group &data)\\n\\u00a0     : Function<dim, std::complex<double>>(dim)\\n\\u00a0     , data(data)\\n\\u00a0     , pml_coeff(data.get_attribute<double>(\\\"pml_coeff\\\"))\\n\\u00a0     , pml_coeff_degree(data.get_attribute<int>(\\\"pml_coeff_degree\\\"))\\n\\u00a0     , dimension_x(data.get_attribute<double>(\\\"dimension_x\\\"))\\n\\u00a0     , dimension_y(data.get_attribute<double>(\\\"dimension_y\\\"))\\n\\u00a0     , pml_x(data.get_attribute<bool>(\\\"pml_x\\\"))\\n\\u00a0     , pml_y(data.get_attribute<bool>(\\\"pml_y\\\"))\\n\\u00a0     , pml_width_x(data.get_attribute<double>(\\\"pml_width_x\\\"))\\n\\u00a0     , pml_width_y(data.get_attribute<double>(\\\"pml_width_y\\\"))\\n\\u00a0     , a_coeff_x(pml_coeff / std::pow(pml_width_x, pml_coeff_degree))\\n\\u00a0     , a_coeff_y(pml_coeff / std::pow(pml_width_y, pml_coeff_degree))\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nbool\\nint\\nstdSTL namespace.\\nThe PML coefficient for the x component takes the form \\\\(s'_x = a_x x^{\\\\textrm{degree}}\\\\)\\n\\u00a0   template <int dim>\\n\\u00a0   std::complex<double> PML<dim>::value(const Point<dim>  &p,\\n\\u00a0                                        const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     double calculated_pml_x_coeff = 0;\\n\\u00a0     double calculated_pml_y_coeff = 0;\\n\\u00a0 \\n\\u00a0     if ((component == 0) && pml_x)\\n\\u00a0       {\\n\\u00a0         const double pml_x_start_position = dimension_x / 2 - pml_width_x;\\n\\u00a0         if (std::abs(p[0]) > pml_x_start_position)\\n\\u00a0           {\\n\\u00a0             const double x_prime = std::abs(p[0]) - pml_x_start_position;\\n\\u00a0             calculated_pml_x_coeff =\\n\\u00a0               a_coeff_x * std::pow(x_prime, pml_coeff_degree);\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     if ((component == 1) && pml_y)\\n\\u00a0       {\\n\\u00a0         const double pml_y_start_position = dimension_y / 2 - pml_width_y;\\n\\u00a0         if (std::abs(p[1]) > pml_y_start_position)\\n\\u00a0           {\\n\\u00a0             const double y_prime = std::abs(p[1]) - pml_y_start_position;\\n\\u00a0             calculated_pml_y_coeff =\\n\\u00a0               a_coeff_y * std::pow(y_prime, pml_coeff_degree);\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     return 1. + std::max(calculated_pml_x_coeff, calculated_pml_y_coeff) *\\n\\u00a0                   std::complex<double>(0., 1.);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nstd::max::VectorizedArray< Number, width > max(const ::VectorizedArray< Number, width > &, const ::VectorizedArray< Number, width > &)Definition vectorization.h:6943\\nstd::pow::VectorizedArray< Number, width > pow(const ::VectorizedArray< Number, width > &, const Number p)Definition vectorization.h:6885\\n The Rho class implementation\\nThis class is used to define the mass density. As we have explained before, a phononic superlattice cavity is formed by two Distributed Reflector, mirrors and a \\\\(\\\\lambda/2\\\\) cavity where \\\\(\\\\lambda\\\\) is the acoustic wavelength. Acoustic DBRs are periodic structures where a set of bilayer stacks with contrasting physical properties (sound velocity index) is repeated \\\\(N\\\\) times. The change of in the wave velocity is generated by alternating layers with different density.\\n\\u00a0   template <int dim>\\n\\u00a0   Rho<dim>::Rho(HDF5::Group &data)\\n\\u00a0     : Function<dim>(1)\\n\\u00a0     , data(data)\\n\\u00a0     , lambda(data.get_attribute<double>(\\\"lambda\\\"))\\n\\u00a0     , mu(data.get_attribute<double>(\\\"mu\\\"))\\n\\u00a0     , material_a_rho(data.get_attribute<double>(\\\"material_a_rho\\\"))\\n\\u00a0     , material_b_rho(data.get_attribute<double>(\\\"material_b_rho\\\"))\\n\\u00a0     , cavity_resonance_frequency(\\n\\u00a0         data.get_attribute<double>(\\\"cavity_resonance_frequency\\\"))\\n\\u00a0     , nb_mirror_pairs(data.get_attribute<int>(\\\"nb_mirror_pairs\\\"))\\n\\u00a0     , dimension_y(data.get_attribute<double>(\\\"dimension_y\\\"))\\n\\u00a0     , grid_level(data.get_attribute<int>(\\\"grid_level\\\"))\\n\\u00a0   {\\nIn order to increase the precision we use subpixel smoothing.\\n\\u00a0     average_rho_width = dimension_y / (std::pow(2.0, grid_level));\\n\\u00a0     data.set_attribute(\\\"average_rho_width\\\", average_rho_width);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double Rho<dim>::value(const Point<dim> &p,\\n\\u00a0                          const unsigned int /*component*/) const\\n\\u00a0   {\\nHDF5::HDF5Object::set_attributevoid set_attribute(const std::string &attr_name, const T value)Definition hdf5.h:1674\\nThe speed of sound is defined by   \\n\\\\[\\n   c = \\\\frac{K_e}{\\\\rho}\\n   \\\\]\\n\\n where \\\\(K_e\\\\) is the effective elastic constant and \\\\(\\\\rho\\\\) the density. Here we consider the case in which the waveguide width is much smaller than the wavelength. In this case it can be shown that for the two dimensional case   \\n\\\\[\\n   K_e = 4\\\\mu\\\\frac{\\\\lambda +\\\\mu}{\\\\lambda+2\\\\mu}\\n   \\\\]\\n\\n and for the three dimensional case \\\\(K_e\\\\) is equal to the Young's modulus.   \\n\\\\[\\n   K_e = \\\\mu\\\\frac{3\\\\lambda +2\\\\mu}{\\\\lambda+\\\\mu}\\n   \\\\]\\n\\n\\u00a0     double elastic_constant;\\n\\u00a0     if (dim == 2)\\n\\u00a0       {\\n\\u00a0         elastic_constant = 4 * mu * (lambda + mu) / (lambda + 2 * mu);\\n\\u00a0       }\\n\\u00a0     else if (dim == 3)\\n\\u00a0       {\\n\\u00a0         elastic_constant = mu * (3 * lambda + 2 * mu) / (lambda + mu);\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       DEAL_II_NOT_IMPLEMENTED();\\n\\u00a0 \\n\\u00a0     const double material_a_speed_of_sound =\\n\\u00a0       std::sqrt(elastic_constant / material_a_rho);\\n\\u00a0     const double material_a_wavelength =\\n\\u00a0       material_a_speed_of_sound / cavity_resonance_frequency;\\n\\u00a0     const double material_b_speed_of_sound =\\n\\u00a0       std::sqrt(elastic_constant / material_b_rho);\\n\\u00a0     const double material_b_wavelength =\\n\\u00a0       material_b_speed_of_sound / cavity_resonance_frequency;\\n\\u00a0 \\nDEAL_II_NOT_IMPLEMENTED#define DEAL_II_NOT_IMPLEMENTED()Definition exceptions.h:1814\\nstd::sqrt::VectorizedArray< Number, width > sqrt(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6869\\nThe density \\\\(\\\\rho\\\\) takes the following form  where the brown color represents material_a and the green color represents material_b.\\n\\u00a0     for (unsigned int idx = 0; idx < nb_mirror_pairs; ++idx)\\n\\u00a0       {\\n\\u00a0         const double layer_transition_center =\\n\\u00a0           material_a_wavelength / 2 +\\n\\u00a0           idx * (material_b_wavelength / 4 + material_a_wavelength / 4);\\n\\u00a0         if (std::abs(p[0]) >=\\n\\u00a0               (layer_transition_center - average_rho_width / 2) &&\\n\\u00a0             std::abs(p[0]) <= (layer_transition_center + average_rho_width / 2))\\n\\u00a0           {\\n\\u00a0             const double coefficient =\\n\\u00a0               (std::abs(p[0]) -\\n\\u00a0                (layer_transition_center - average_rho_width / 2)) /\\n\\u00a0               average_rho_width;\\n\\u00a0             return (1 - coefficient) * material_a_rho +\\n\\u00a0                    coefficient * material_b_rho;\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\nHere we define the subpixel smoothing which improves the precision of the simulation.\\n\\u00a0     for (unsigned int idx = 0; idx < nb_mirror_pairs; ++idx)\\n\\u00a0       {\\n\\u00a0         const double layer_transition_center =\\n\\u00a0           material_a_wavelength / 2 +\\n\\u00a0           idx * (material_b_wavelength / 4 + material_a_wavelength / 4) +\\n\\u00a0           material_b_wavelength / 4;\\n\\u00a0         if (std::abs(p[0]) >=\\n\\u00a0               (layer_transition_center - average_rho_width / 2) &&\\n\\u00a0             std::abs(p[0]) <= (layer_transition_center + average_rho_width / 2))\\n\\u00a0           {\\n\\u00a0             const double coefficient =\\n\\u00a0               (std::abs(p[0]) -\\n\\u00a0                (layer_transition_center - average_rho_width / 2)) /\\n\\u00a0               average_rho_width;\\n\\u00a0             return (1 - coefficient) * material_b_rho +\\n\\u00a0                    coefficient * material_a_rho;\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\nthen the cavity\\n\\u00a0     if (std::abs(p[0]) <= material_a_wavelength / 2)\\n\\u00a0       {\\n\\u00a0         return material_a_rho;\\n\\u00a0       }\\n\\u00a0 \\nthe material_a layers\\n\\u00a0     for (unsigned int idx = 0; idx < nb_mirror_pairs; ++idx)\\n\\u00a0       {\\n\\u00a0         const double layer_center =\\n\\u00a0           material_a_wavelength / 2 +\\n\\u00a0           idx * (material_b_wavelength / 4 + material_a_wavelength / 4) +\\n\\u00a0           material_b_wavelength / 4 + material_a_wavelength / 8;\\n\\u00a0         const double layer_width = material_a_wavelength / 4;\\n\\u00a0         if (std::abs(p[0]) >= (layer_center - layer_width / 2) &&\\n\\u00a0             std::abs(p[0]) <= (layer_center + layer_width / 2))\\n\\u00a0           {\\n\\u00a0             return material_a_rho;\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\nthe material_b layers\\n\\u00a0     for (unsigned int idx = 0; idx < nb_mirror_pairs; ++idx)\\n\\u00a0       {\\n\\u00a0         const double layer_center =\\n\\u00a0           material_a_wavelength / 2 +\\n\\u00a0           idx * (material_b_wavelength / 4 + material_a_wavelength / 4) +\\n\\u00a0           material_b_wavelength / 8;\\n\\u00a0         const double layer_width = material_b_wavelength / 4;\\n\\u00a0         if (std::abs(p[0]) >= (layer_center - layer_width / 2) &&\\n\\u00a0             std::abs(p[0]) <= (layer_center + layer_width / 2))\\n\\u00a0           {\\n\\u00a0             return material_b_rho;\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\nand finally the default is material_a.\\n\\u00a0     return material_a_rho;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n The Parameters class implementation\\nThe constructor reads all the parameters from the HDF5::Group data using the HDF5::Group::get_attribute() function.\\n\\u00a0   template <int dim>\\n\\u00a0   Parameters<dim>::Parameters(HDF5::Group &data)\\n\\u00a0     : data(data)\\n\\u00a0     , simulation_name(data.get_attribute<std::string>(\\\"simulation_name\\\"))\\n\\u00a0     , save_vtu_files(data.get_attribute<bool>(\\\"save_vtu_files\\\"))\\n\\u00a0     , start_frequency(data.get_attribute<double>(\\\"start_frequency\\\"))\\n\\u00a0     , stop_frequency(data.get_attribute<double>(\\\"stop_frequency\\\"))\\n\\u00a0     , nb_frequency_points(data.get_attribute<int>(\\\"nb_frequency_points\\\"))\\n\\u00a0     , lambda(data.get_attribute<double>(\\\"lambda\\\"))\\n\\u00a0     , mu(data.get_attribute<double>(\\\"mu\\\"))\\n\\u00a0     , dimension_x(data.get_attribute<double>(\\\"dimension_x\\\"))\\n\\u00a0     , dimension_y(data.get_attribute<double>(\\\"dimension_y\\\"))\\n\\u00a0     , nb_probe_points(data.get_attribute<int>(\\\"nb_probe_points\\\"))\\n\\u00a0     , grid_level(data.get_attribute<int>(\\\"grid_level\\\"))\\n\\u00a0     , probe_start_point(data.get_attribute<double>(\\\"probe_pos_x\\\"),\\n\\u00a0                         data.get_attribute<double>(\\\"probe_pos_y\\\") -\\n\\u00a0                           data.get_attribute<double>(\\\"probe_width_y\\\") / 2)\\n\\u00a0     , probe_stop_point(data.get_attribute<double>(\\\"probe_pos_x\\\"),\\n\\u00a0                        data.get_attribute<double>(\\\"probe_pos_y\\\") +\\n\\u00a0                          data.get_attribute<double>(\\\"probe_width_y\\\") / 2)\\n\\u00a0     , right_hand_side(data)\\n\\u00a0     , pml(data)\\n\\u00a0     , rho(data)\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n The QuadratureCache class implementation\\nWe need to reserve enough space for the mass and stiffness matrices and the right hand side vector.\\n\\u00a0   template <int dim>\\n\\u00a0   QuadratureCache<dim>::QuadratureCache(const unsigned int dofs_per_cell)\\n\\u00a0     : dofs_per_cell(dofs_per_cell)\\n\\u00a0     , mass_coefficient(dofs_per_cell, dofs_per_cell)\\n\\u00a0     , stiffness_coefficient(dofs_per_cell, dofs_per_cell)\\n\\u00a0     , right_hand_side(dofs_per_cell)\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n Implementation of the ElasticWave class\\n Constructor\\nThis is very similar to the constructor of step-40. In addition we create the HDF5 datasets frequency_dataset, position_dataset and displacement. Note the use of the template keyword for the creation of the HDF5 datasets. It is a C++ requirement to use the template keyword in order to treat create_dataset as a dependent template name.\\n\\u00a0   template <int dim>\\n\\u00a0   ElasticWave<dim>::ElasticWave(const Parameters<dim> &parameters)\\n\\u00a0     : parameters(parameters)\\n\\u00a0     , mpi_communicator(MPI_COMM_WORLD)\\n\\u00a0     , triangulation(mpi_communicator,\\n\\u00a0                     typename Triangulation<dim>::MeshSmoothing(\\n\\u00a0                       Triangulation<dim>::smoothing_on_refinement |\\n\\u00a0                       Triangulation<dim>::smoothing_on_coarsening))\\n\\u00a0     , quadrature_formula(2)\\n\\u00a0     , fe(FE_Q<dim>(1) ^ dim)\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0     , frequency(parameters.nb_frequency_points)\\n\\u00a0     , probe_positions(parameters.nb_probe_points, dim)\\n\\u00a0     , frequency_dataset(parameters.data.template create_dataset<double>(\\n\\u00a0         \\\"frequency\\\",\\n\\u00a0         std::vector<hsize_t>{parameters.nb_frequency_points}))\\n\\u00a0     , probe_positions_dataset(parameters.data.template create_dataset<double>(\\n\\u00a0         \\\"position\\\",\\n\\u00a0         std::vector<hsize_t>{parameters.nb_probe_points, dim}))\\n\\u00a0     , displacement(\\n\\u00a0         parameters.data.template create_dataset<std::complex<double>>(\\n\\u00a0           \\\"displacement\\\",\\n\\u00a0           std::vector<hsize_t>{parameters.nb_probe_points,\\n\\u00a0                                parameters.nb_frequency_points}))\\n\\u00a0     , pcout(std::cout,\\n\\u00a0             (Utilities::MPI::this_mpi_process(mpi_communicator) == 0))\\n\\u00a0     , computing_timer(mpi_communicator,\\n\\u00a0                       pcout,\\n\\u00a0                       TimerOutput::never,\\n\\u00a0                       TimerOutput::wall_times)\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFE_QDefinition fe_q.h:554\\nTriangulationDefinition tria.h:1323\\nInitializeLibrary::MPI@ MPI\\nUtilitiesDefinition communication_pattern_base.h:30\\n ElasticWave::setup_system\\nThere is nothing new in this function, the only difference with step-40 is that we don't have to apply boundary conditions because we use the PMLs to truncate the domain.\\n\\u00a0   template <int dim>\\n\\u00a0   void ElasticWave<dim>::setup_system()\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope t(computing_timer, \\\"setup\\\");\\n\\u00a0 \\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0 \\n\\u00a0     locally_owned_dofs = dof_handler.locally_owned_dofs();\\n\\u00a0     locally_relevant_dofs =\\n\\u00a0       DoFTools::extract_locally_relevant_dofs(dof_handler);\\n\\u00a0 \\n\\u00a0     locally_relevant_solution.reinit(locally_owned_dofs,\\n\\u00a0                                      locally_relevant_dofs,\\n\\u00a0                                      mpi_communicator);\\n\\u00a0 \\n\\u00a0     system_rhs.reinit(locally_owned_dofs, mpi_communicator);\\n\\u00a0 \\n\\u00a0     constraints.clear();\\n\\u00a0     constraints.reinit(locally_relevant_dofs);\\n\\u00a0     DoFTools::make_hanging_node_constraints(dof_handler, constraints);\\n\\u00a0 \\n\\u00a0     constraints.close();\\n\\u00a0 \\n\\u00a0     DynamicSparsityPattern dsp(locally_relevant_dofs);\\n\\u00a0 \\n\\u00a0     DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false);\\n\\u00a0     SparsityTools::distribute_sparsity_pattern(dsp,\\n\\u00a0                                                locally_owned_dofs,\\n\\u00a0                                                mpi_communicator,\\n\\u00a0                                                locally_relevant_dofs);\\n\\u00a0 \\n\\u00a0     system_matrix.reinit(locally_owned_dofs,\\n\\u00a0                          locally_owned_dofs,\\n\\u00a0                          dsp,\\n\\u00a0                          mpi_communicator);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nTimerOutput::ScopeDefinition timer.h:557\\nDoFTools::make_hanging_node_constraintsvoid make_hanging_node_constraints(const DoFHandler< dim, spacedim > &dof_handler, AffineConstraints< number > &constraints)Definition dof_tools_constraints.cc:3073\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nDoFTools::extract_locally_relevant_dofsIndexSet extract_locally_relevant_dofs(const DoFHandler< dim, spacedim > &dof_handler)Definition dof_tools.cc:1164\\nSparsityTools::distribute_sparsity_patternvoid distribute_sparsity_pattern(DynamicSparsityPattern &dsp, const IndexSet &locally_owned_rows, const MPI_Comm mpi_comm, const IndexSet &locally_relevant_rows)Definition sparsity_tools.cc:1020\\n ElasticWave::assemble_system\\nThis function is also very similar to step-40, though there are notable differences. We assemble the system for each frequency/omega step. In the first step we set calculate_quadrature_data = True and we calculate the mass and stiffness matrices and the right hand side vector. In the subsequent steps we will use that data to accelerate the calculation.\\n\\u00a0   template <int dim>\\n\\u00a0   void ElasticWave<dim>::assemble_system(const double omega,\\n\\u00a0                                          const bool   calculate_quadrature_data)\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope t(computing_timer, \\\"assembly\\\");\\n\\u00a0 \\n\\u00a0     FEValues<dim>      fe_values(fe,\\n\\u00a0                             quadrature_formula,\\n\\u00a0                             update_values | update_gradients |\\n\\u00a0                               update_quadrature_points | update_JxW_values);\\n\\u00a0     const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n\\u00a0     const unsigned int n_q_points    = quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     FullMatrix<std::complex<double>> cell_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0     Vector<std::complex<double>>     cell_rhs(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\nFEValuesDefinition fe_values.h:63\\nVectorDefinition vector.h:120\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nHere we store the value of the right hand side, rho and the PML.\\n\\u00a0     std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim));\\n\\u00a0     std::vector<double>         rho_values(n_q_points);\\n\\u00a0     std::vector<Vector<std::complex<double>>> pml_values(\\n\\u00a0       n_q_points, Vector<std::complex<double>>(dim));\\n\\u00a0 \\nWe calculate the stiffness tensor for the \\\\(\\\\lambda\\\\) and \\\\(\\\\mu\\\\) that have been defined in the jupyter notebook. Note that contrary to \\\\(\\\\rho\\\\) the stiffness is constant among for the whole domain.\\n\\u00a0     const SymmetricTensor<4, dim> stiffness_tensor =\\n\\u00a0       get_stiffness_tensor<dim>(parameters.lambda, parameters.mu);\\n\\u00a0 \\nWe use the same method of step-20 for vector-valued problems.\\n\\u00a0     const FEValuesExtractors::Vector displacement(0);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       if (cell->is_locally_owned())\\n\\u00a0         {\\n\\u00a0           cell_matrix = 0;\\n\\u00a0           cell_rhs    = 0;\\n\\u00a0 \\nFEValuesExtractors::VectorDefinition fe_values_extractors.h:150\\nWe have to calculate the values of the right hand side, rho and the PML only if we are going to calculate the mass and the stiffness matrices. Otherwise we can skip this calculation which considerably reduces the total calculation time.\\n\\u00a0           if (calculate_quadrature_data)\\n\\u00a0             {\\n\\u00a0               fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0               parameters.right_hand_side.vector_value_list(\\n\\u00a0                 fe_values.get_quadrature_points(), rhs_values);\\n\\u00a0               parameters.rho.value_list(fe_values.get_quadrature_points(),\\n\\u00a0                                         rho_values);\\n\\u00a0               parameters.pml.vector_value_list(\\n\\u00a0                 fe_values.get_quadrature_points(), pml_values);\\n\\u00a0             }\\n\\u00a0 \\nWe have done this in step-18. Get a pointer to the quadrature cache data local to the present cell, and, as a defensive measure, make sure that this pointer is within the bounds of the global array:\\n\\u00a0           QuadratureCache<dim> *local_quadrature_points_data =\\n\\u00a0             reinterpret_cast<QuadratureCache<dim> *>(cell->user_pointer());\\n\\u00a0           Assert(local_quadrature_points_data >= &quadrature_cache.front(),\\n\\u00a0                  ExcInternalError());\\n\\u00a0           Assert(local_quadrature_points_data <= &quadrature_cache.back(),\\n\\u00a0                  ExcInternalError());\\n\\u00a0           for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0             {\\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\nThe quadrature_data variable is used to store the mass and stiffness matrices, the right hand side vector and the value of JxW.\\n\\u00a0               QuadratureCache<dim> &quadrature_data =\\n\\u00a0                 local_quadrature_points_data[q];\\n\\u00a0 \\nBelow we declare the force vector and the parameters of the PML \\\\(s\\\\) and \\\\(\\\\xi\\\\).\\n\\u00a0               Tensor<1, dim>                       force;\\n\\u00a0               Tensor<1, dim, std::complex<double>> s;\\n\\u00a0               std::complex<double>                 xi(1, 0);\\n\\u00a0 \\nTensorDefinition tensor.h:471\\nThe following block is calculated only in the first frequency step.\\n\\u00a0               if (calculate_quadrature_data)\\n\\u00a0                 {\\nStore the value of JxW.\\n\\u00a0                   quadrature_data.JxW = fe_values.JxW(q);\\n\\u00a0 \\n\\u00a0                   for (unsigned int component = 0; component < dim; ++component)\\n\\u00a0                     {\\nConvert vectors to tensors and calculate xi\\n\\u00a0                       force[component] = rhs_values[q][component];\\n\\u00a0                       s[component]     = pml_values[q][component];\\n\\u00a0                       xi *= s[component];\\n\\u00a0                     }\\n\\u00a0 \\nHere we calculate the \\\\(\\\\alpha_{mnkl}\\\\) and \\\\(\\\\beta_{mnkl}\\\\) tensors.\\n\\u00a0                   Tensor<4, dim, std::complex<double>> alpha;\\n\\u00a0                   Tensor<4, dim, std::complex<double>> beta;\\n\\u00a0                   for (unsigned int m = 0; m < dim; ++m)\\n\\u00a0                     for (unsigned int n = 0; n < dim; ++n)\\n\\u00a0                       for (unsigned int k = 0; k < dim; ++k)\\n\\u00a0                         for (unsigned int l = 0; l < dim; ++l)\\n\\u00a0                           {\\n\\u00a0                             alpha[m][n][k][l] = xi *\\n\\u00a0                                                 stiffness_tensor[m][n][k][l] /\\n\\u00a0                                                 (2.0 * s[n] * s[k]);\\n\\u00a0                             beta[m][n][k][l] = xi *\\n\\u00a0                                                stiffness_tensor[m][n][k][l] /\\n\\u00a0                                                (2.0 * s[n] * s[l]);\\n\\u00a0                           }\\n\\u00a0 \\n\\u00a0                   for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0                     {\\n\\u00a0                       const Tensor<1, dim> phi_i =\\n\\u00a0                         fe_values[displacement].value(i, q);\\n\\u00a0                       const Tensor<2, dim> grad_phi_i =\\n\\u00a0                         fe_values[displacement].gradient(i, q);\\n\\u00a0 \\n\\u00a0                       for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0                         {\\n\\u00a0                           const Tensor<1, dim> phi_j =\\n\\u00a0                             fe_values[displacement].value(j, q);\\n\\u00a0                           const Tensor<2, dim> grad_phi_j =\\n\\u00a0                             fe_values[displacement].gradient(j, q);\\n\\u00a0 \\ncalculate the values of the mass matrix.\\n\\u00a0                           quadrature_data.mass_coefficient[i][j] =\\n\\u00a0                             rho_values[q] * xi * phi_i * phi_j;\\n\\u00a0 \\nLoop over the \\\\(mnkl\\\\) indices of the stiffness tensor.\\n\\u00a0                           std::complex<double> stiffness_coefficient = 0;\\n\\u00a0                           for (unsigned int m = 0; m < dim; ++m)\\n\\u00a0                             for (unsigned int n = 0; n < dim; ++n)\\n\\u00a0                               for (unsigned int k = 0; k < dim; ++k)\\n\\u00a0                                 for (unsigned int l = 0; l < dim; ++l)\\n\\u00a0                                   {\\nHere we calculate the stiffness matrix. Note that the stiffness matrix is not symmetric because of the PMLs. We use the gradient function (see the documentation) which is a Tensor<2,dim>. The matrix \\\\(G_{ij}\\\\) consists of entries     \\n\\\\[\\n   G_{ij}=\\n   \\\\frac{\\\\partial\\\\phi_i}{\\\\partial x_j}\\n   =\\\\partial_j \\\\phi_i\\n   \\\\]\\n\\n Note the position of the indices \\\\(i\\\\) and \\\\(j\\\\) and the notation that we use in this tutorial: \\\\(\\\\partial_j\\\\phi_i\\\\). As the stiffness tensor is not symmetric, it is very easy to make a mistake.\\n\\u00a0                                     stiffness_coefficient +=\\n\\u00a0                                       grad_phi_i[m][n] *\\n\\u00a0                                       (alpha[m][n][k][l] * grad_phi_j[l][k] +\\n\\u00a0                                        beta[m][n][k][l] * grad_phi_j[k][l]);\\n\\u00a0                                   }\\n\\u00a0 \\nWe save the value of the stiffness matrix in quadrature_data\\n\\u00a0                           quadrature_data.stiffness_coefficient[i][j] =\\n\\u00a0                             stiffness_coefficient;\\n\\u00a0                         }\\n\\u00a0 \\nand the value of the right hand side in quadrature_data.\\n\\u00a0                       quadrature_data.right_hand_side[i] =\\n\\u00a0                         phi_i * force * fe_values.JxW(q);\\n\\u00a0                     }\\n\\u00a0                 }\\n\\u00a0 \\nWe loop again over the degrees of freedom of the cells to calculate the system matrix. These loops are really quick because we have already calculated the stiffness and mass matrices, only the value of \\\\(\\\\omega\\\\) changes.\\n\\u00a0               for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0                 {\\n\\u00a0                   for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0                     {\\n\\u00a0                       std::complex<double> matrix_sum = 0;\\n\\u00a0                       matrix_sum += -Utilities::fixed_power<2>(omega) *\\n\\u00a0                                     quadrature_data.mass_coefficient[i][j];\\n\\u00a0                       matrix_sum += quadrature_data.stiffness_coefficient[i][j];\\n\\u00a0                       cell_matrix(i, j) += matrix_sum * quadrature_data.JxW;\\n\\u00a0                     }\\n\\u00a0                   cell_rhs(i) += quadrature_data.right_hand_side[i];\\n\\u00a0                 }\\n\\u00a0             }\\n\\u00a0           cell->get_dof_indices(local_dof_indices);\\n\\u00a0           constraints.distribute_local_to_global(cell_matrix,\\n\\u00a0                                                  cell_rhs,\\n\\u00a0                                                  local_dof_indices,\\n\\u00a0                                                  system_matrix,\\n\\u00a0                                                  system_rhs);\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0     system_matrix.compress(VectorOperation::add);\\n\\u00a0     system_rhs.compress(VectorOperation::add);\\n\\u00a0   }\\n\\u00a0 \\nVectorOperation::add@ addDefinition vector_operation.h:53\\n ElasticWave::solve\\nThis is even more simple than in step-40. We use the parallel direct solver MUMPS which requires less options than an iterative solver. The drawback is that it does not scale very well. It is not straightforward to solve the Helmholtz equation with an iterative solver. The shifted Laplacian multigrid method is a well known approach to precondition this system, but this is beyond the scope of this tutorial.\\n\\u00a0   template <int dim>\\n\\u00a0   void ElasticWave<dim>::solve()\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope              t(computing_timer, \\\"solve\\\");\\n\\u00a0     LinearAlgebraPETSc::MPI::Vector completely_distributed_solution(\\n\\u00a0       locally_owned_dofs, mpi_communicator);\\n\\u00a0 \\n\\u00a0     SolverControl                    solver_control;\\n\\u00a0     PETScWrappers::SparseDirectMUMPS solver(solver_control, mpi_communicator);\\n\\u00a0     solver.solve(system_matrix, completely_distributed_solution, system_rhs);\\n\\u00a0 \\n\\u00a0     pcout << \\\"   Solved in \\\" << solver_control.last_step() << \\\" iterations.\\\"\\n\\u00a0           << std::endl;\\n\\u00a0     constraints.distribute(completely_distributed_solution);\\n\\u00a0     locally_relevant_solution = completely_distributed_solution;\\n\\u00a0   }\\n\\u00a0 \\nPETScWrappers::SparseDirectMUMPSDefinition petsc_solver.h:904\\nSolverControlDefinition solver_control.h:67\\n ElasticWave::initialize_position_vector\\nWe use this function to calculate the values of the position vector.\\n\\u00a0   template <int dim>\\n\\u00a0   void ElasticWave<dim>::initialize_probe_positions_vector()\\n\\u00a0   {\\n\\u00a0     for (unsigned int position_idx = 0;\\n\\u00a0          position_idx < parameters.nb_probe_points;\\n\\u00a0          ++position_idx)\\n\\u00a0       {\\nBecause of the way the operator + and - are overloaded to subtract two points, the following has to be done: Point_b<dim> + (-Point_a<dim>)\\n\\u00a0         const Point<dim> p =\\n\\u00a0           (position_idx / ((double)(parameters.nb_probe_points - 1))) *\\n\\u00a0             (parameters.probe_stop_point + (-parameters.probe_start_point)) +\\n\\u00a0           parameters.probe_start_point;\\n\\u00a0         probe_positions[position_idx][0] = p[0];\\n\\u00a0         probe_positions[position_idx][1] = p[1];\\n\\u00a0         if (dim == 3)\\n\\u00a0           {\\n\\u00a0             probe_positions[position_idx][2] = p[2];\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n ElasticWave::store_frequency_step_data\\nThis function stores in the HDF5 file the measured energy by the probe.\\n\\u00a0   template <int dim>\\n\\u00a0   void\\n\\u00a0   ElasticWave<dim>::store_frequency_step_data(const unsigned int frequency_idx)\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope t(computing_timer, \\\"store_frequency_step_data\\\");\\n\\u00a0 \\nWe store the displacement in the \\\\(x\\\\) direction; the displacement in the \\\\(y\\\\) direction is negligible.\\n\\u00a0     const unsigned int probe_displacement_component = 0;\\n\\u00a0 \\nThe vector coordinates contains the coordinates in the HDF5 file of the points of the probe that are located in locally owned cells. The vector displacement_data contains the value of the displacement at these points.\\n\\u00a0     std::vector<hsize_t>              coordinates;\\n\\u00a0     std::vector<std::complex<double>> displacement_data;\\n\\u00a0 \\n\\u00a0     const auto &mapping = get_default_linear_mapping(triangulation);\\n\\u00a0     GridTools::Cache<dim, dim> cache(triangulation, mapping);\\n\\u00a0     typename Triangulation<dim, dim>::active_cell_iterator cell_hint{};\\n\\u00a0     std::vector<bool>                                      marked_vertices = {};\\n\\u00a0     const double                                           tolerance = 1.e-10;\\n\\u00a0 \\n\\u00a0     for (unsigned int position_idx = 0;\\n\\u00a0          position_idx < parameters.nb_probe_points;\\n\\u00a0          ++position_idx)\\n\\u00a0       {\\n\\u00a0         Point<dim> point;\\n\\u00a0         for (unsigned int dim_idx = 0; dim_idx < dim; ++dim_idx)\\n\\u00a0           {\\n\\u00a0             point[dim_idx] = probe_positions[position_idx][dim_idx];\\n\\u00a0           }\\n\\u00a0         bool point_in_locally_owned_cell = false;\\n\\u00a0         {\\n\\u00a0           auto cell_and_ref_point = GridTools::find_active_cell_around_point(\\n\\u00a0             cache, point, cell_hint, marked_vertices, tolerance);\\n\\u00a0           if (cell_and_ref_point.first.state() == IteratorState::valid)\\n\\u00a0             {\\n\\u00a0               cell_hint = cell_and_ref_point.first;\\n\\u00a0               point_in_locally_owned_cell =\\n\\u00a0                 cell_and_ref_point.first->is_locally_owned();\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0         if (point_in_locally_owned_cell)\\n\\u00a0           {\\nGridTools::CacheDefinition grid_tools_cache.h:67\\nTriaActiveIteratorDefinition tria_iterator.h:755\\nget_default_linear_mappingconst Mapping< dim, spacedim > & get_default_linear_mapping(const Triangulation< dim, spacedim > &triangulation)Definition mapping.cc:294\\nGridTools::find_active_cell_around_pointstd::pair< typename MeshType< dim, spacedim >::active_cell_iterator, Point< dim > > find_active_cell_around_point(const Mapping< dim, spacedim > &mapping, const MeshType< dim, spacedim > &mesh, const Point< spacedim > &p, const std::vector< bool > &marked_vertices={}, const double tolerance=1.e-10)Definition grid_tools_dof_handlers.cc:442\\nIteratorState::valid@ validIterator points to a valid object.Definition tria_iterator_base.h:37\\nOpenCASCADE::pointPoint< spacedim > point(const gp_Pnt &p, const double tolerance=1e-10)Definition utilities.cc:191\\nThen we can store the values of the displacement in the points of the probe in displacement_data.\\n\\u00a0             Vector<std::complex<double>> tmp_vector(dim);\\n\\u00a0             VectorTools::point_value(dof_handler,\\n\\u00a0                                      locally_relevant_solution,\\n\\u00a0                                      point,\\n\\u00a0                                      tmp_vector);\\n\\u00a0             coordinates.emplace_back(position_idx);\\n\\u00a0             coordinates.emplace_back(frequency_idx);\\n\\u00a0             displacement_data.emplace_back(\\n\\u00a0               tmp_vector(probe_displacement_component));\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\nVectorTools::point_valuevoid point_value(const DoFHandler< dim, spacedim > &dof, const VectorType &fe_function, const Point< spacedim, double > &point, Vector< typename VectorType::value_type > &value)\\nWe write the displacement data in the HDF5 file. The call HDF5::DataSet::write_selection() is MPI collective which means that all the processes have to participate.\\n\\u00a0     if (coordinates.size() > 0)\\n\\u00a0       {\\n\\u00a0         displacement.write_selection(displacement_data, coordinates);\\n\\u00a0       }\\nTherefore even if the process has no data to write it has to participate in the collective call. For this we can use HDF5::DataSet::write_none(). Note that we have to specify the data type, in this case std::complex<double>.\\n\\u00a0     else\\n\\u00a0       {\\n\\u00a0         displacement.write_none<std::complex<double>>();\\n\\u00a0       }\\n\\u00a0 \\nIf the variable save_vtu_files in the input file equals True then all the data will be saved as vtu. The procedure to write vtu files has been described in step-40.\\n\\u00a0     if (parameters.save_vtu_files)\\n\\u00a0       {\\n\\u00a0         std::vector<std::string> solution_names(dim, \\\"displacement\\\");\\n\\u00a0         std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n\\u00a0           interpretation(\\n\\u00a0             dim, DataComponentInterpretation::component_is_part_of_vector);\\n\\u00a0 \\n\\u00a0         DataOut<dim> data_out;\\n\\u00a0         data_out.add_data_vector(dof_handler,\\n\\u00a0                                  locally_relevant_solution,\\n\\u00a0                                  solution_names,\\n\\u00a0                                  interpretation);\\n\\u00a0         Vector<float> subdomain(triangulation.n_active_cells());\\n\\u00a0         for (unsigned int i = 0; i < subdomain.size(); ++i)\\n\\u00a0           subdomain(i) = triangulation.locally_owned_subdomain();\\n\\u00a0         data_out.add_data_vector(subdomain, \\\"subdomain\\\");\\n\\u00a0 \\n\\u00a0         std::vector<Vector<double>> force(\\n\\u00a0           dim, Vector<double>(triangulation.n_active_cells()));\\n\\u00a0         std::vector<Vector<double>> pml(\\n\\u00a0           dim, Vector<double>(triangulation.n_active_cells()));\\n\\u00a0         Vector<double> rho(triangulation.n_active_cells());\\n\\u00a0 \\n\\u00a0         for (auto &cell : triangulation.active_cell_iterators())\\n\\u00a0           {\\n\\u00a0             if (cell->is_locally_owned())\\n\\u00a0               {\\n\\u00a0                 for (unsigned int dim_idx = 0; dim_idx < dim; ++dim_idx)\\n\\u00a0                   {\\n\\u00a0                     force[dim_idx](cell->active_cell_index()) =\\n\\u00a0                       parameters.right_hand_side.value(cell->center(), dim_idx);\\n\\u00a0                     pml[dim_idx](cell->active_cell_index()) =\\n\\u00a0                       parameters.pml.value(cell->center(), dim_idx).imag();\\n\\u00a0                   }\\n\\u00a0                 rho(cell->active_cell_index()) =\\n\\u00a0                   parameters.rho.value(cell->center());\\n\\u00a0               }\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOutDefinition data_out.h:147\\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nparallel::TriangulationBase::locally_owned_subdomaintypes::subdomain_id locally_owned_subdomain() const overrideDefinition tria_base.cc:345\\nDataComponentInterpretation::component_is_part_of_vector@ component_is_part_of_vectorDefinition data_component_interpretation.h:58\\nAnd on the cells that we are not interested in, set the respective value to a bogus value in order to make sure that if we were somehow wrong about our assumption we would find out by looking at the graphical output:\\n\\u00a0             else\\n\\u00a0               {\\n\\u00a0                 for (unsigned int dim_idx = 0; dim_idx < dim; ++dim_idx)\\n\\u00a0                   {\\n\\u00a0                     force[dim_idx](cell->active_cell_index()) = -1e+20;\\n\\u00a0                     pml[dim_idx](cell->active_cell_index())   = -1e+20;\\n\\u00a0                   }\\n\\u00a0                 rho(cell->active_cell_index()) = -1e+20;\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         for (unsigned int dim_idx = 0; dim_idx < dim; ++dim_idx)\\n\\u00a0           {\\n\\u00a0             data_out.add_data_vector(force[dim_idx],\\n\\u00a0                                      \\\"force_\\\" + std::to_string(dim_idx));\\n\\u00a0             data_out.add_data_vector(pml[dim_idx],\\n\\u00a0                                      \\\"pml_\\\" + std::to_string(dim_idx));\\n\\u00a0           }\\n\\u00a0         data_out.add_data_vector(rho, \\\"rho\\\");\\n\\u00a0 \\n\\u00a0         data_out.build_patches();\\n\\u00a0 \\n\\u00a0         std::stringstream  frequency_idx_stream;\\n\\u00a0         const unsigned int nb_number_positions =\\n\\u00a0           ((unsigned int)std::log10(parameters.nb_frequency_points)) + 1;\\n\\u00a0         frequency_idx_stream << std::setw(nb_number_positions)\\n\\u00a0                              << std::setfill('0') << frequency_idx;\\n\\u00a0         const std::string filename = (parameters.simulation_name + \\\"_\\\" +\\n\\u00a0                                       frequency_idx_stream.str() + \\\".vtu\\\");\\n\\u00a0         data_out.write_vtu_in_parallel(filename, mpi_communicator);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n ElasticWave::output_results\\nThis function writes the datasets that have not already been written.\\n\\u00a0   template <int dim>\\n\\u00a0   void ElasticWave<dim>::output_results()\\n\\u00a0   {\\nThe vectors frequency and position are the same for all the processes. Therefore any of the processes can write the corresponding datasets. Because the call HDF5::DataSet::write is MPI collective, the rest of the processes will have to call HDF5::DataSet::write_none.\\n\\u00a0     if (Utilities::MPI::this_mpi_process(mpi_communicator) == 0)\\n\\u00a0       {\\n\\u00a0         frequency_dataset.write(frequency);\\n\\u00a0         probe_positions_dataset.write(probe_positions);\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       {\\n\\u00a0         frequency_dataset.write_none<double>();\\n\\u00a0         probe_positions_dataset.write_none<double>();\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nUtilities::MPI::this_mpi_processunsigned int this_mpi_process(const MPI_Comm mpi_communicator)Definition mpi.cc:107\\n ElasticWave::setup_quadrature_cache\\nWe use this function at the beginning of our computations to set up initial values of the cache variables. This function has been described in step-18. There are no differences with the function of step-18.\\n\\u00a0   template <int dim>\\n\\u00a0   void ElasticWave<dim>::setup_quadrature_cache()\\n\\u00a0   {\\n\\u00a0     triangulation.clear_user_data();\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       std::vector<QuadratureCache<dim>> tmp;\\n\\u00a0       quadrature_cache.swap(tmp);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     quadrature_cache.resize(triangulation.n_locally_owned_active_cells() *\\n\\u00a0                               quadrature_formula.size(),\\n\\u00a0                             QuadratureCache<dim>(fe.n_dofs_per_cell()));\\n\\u00a0     unsigned int cache_index = 0;\\n\\u00a0     for (const auto &cell : triangulation.active_cell_iterators())\\n\\u00a0       if (cell->is_locally_owned())\\n\\u00a0         {\\n\\u00a0           cell->set_user_pointer(&quadrature_cache[cache_index]);\\n\\u00a0           cache_index += quadrature_formula.size();\\n\\u00a0         }\\n\\u00a0     Assert(cache_index == quadrature_cache.size(), ExcInternalError());\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nTriangulation::clear_user_datavoid clear_user_data()\\nparallel::TriangulationBase::n_locally_owned_active_cellsunsigned int n_locally_owned_active_cells() constDefinition tria_base.cc:131\\n ElasticWave::frequency_sweep\\nFor clarity we divide the function run of step-40 into the functions run and frequency_sweep. In the function frequency_sweep we place the iteration over the frequency vector.\\n\\u00a0   template <int dim>\\n\\u00a0   void ElasticWave<dim>::frequency_sweep()\\n\\u00a0   {\\n\\u00a0     for (unsigned int frequency_idx = 0;\\n\\u00a0          frequency_idx < parameters.nb_frequency_points;\\n\\u00a0          ++frequency_idx)\\n\\u00a0       {\\n\\u00a0         pcout << parameters.simulation_name + \\\" frequency idx: \\\"\\n\\u00a0               << frequency_idx << '/' << parameters.nb_frequency_points - 1\\n\\u00a0               << std::endl;\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0         setup_system();\\n\\u00a0         if (frequency_idx == 0)\\n\\u00a0           {\\n\\u00a0             pcout << \\\"   Number of active cells :       \\\"\\n\\u00a0                   << triangulation.n_active_cells() << std::endl;\\n\\u00a0             pcout << \\\"   Number of degrees of freedom : \\\"\\n\\u00a0                   << dof_handler.n_dofs() << std::endl;\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         if (frequency_idx == 0)\\n\\u00a0           {\\nWrite the simulation parameters only once\\n\\u00a0             parameters.data.set_attribute(\\\"active_cells\\\",\\n\\u00a0                                           triangulation.n_active_cells());\\n\\u00a0             parameters.data.set_attribute(\\\"degrees_of_freedom\\\",\\n\\u00a0                                           dof_handler.n_dofs());\\n\\u00a0           }\\n\\u00a0 \\nWe calculate the frequency and omega values for this particular step.\\n\\u00a0         const double current_loop_frequency =\\n\\u00a0           (parameters.start_frequency +\\n\\u00a0            frequency_idx *\\n\\u00a0              (parameters.stop_frequency - parameters.start_frequency) /\\n\\u00a0              (parameters.nb_frequency_points - 1));\\n\\u00a0         const double current_loop_omega =\\n\\u00a0           2 * numbers::PI * current_loop_frequency;\\n\\u00a0 \\nnumbers::PIstatic constexpr double PIDefinition numbers.h:259\\nIn the first frequency step we calculate the mass and stiffness matrices and the right hand side. In the subsequent frequency steps we will use those values. This improves considerably the calculation time.\\n\\u00a0         assemble_system(current_loop_omega,\\n\\u00a0                         (frequency_idx == 0) ? true : false);\\n\\u00a0         solve();\\n\\u00a0 \\n\\u00a0         frequency[frequency_idx] = current_loop_frequency;\\n\\u00a0         store_frequency_step_data(frequency_idx);\\n\\u00a0 \\n\\u00a0         computing_timer.print_summary();\\n\\u00a0         computing_timer.reset();\\n\\u00a0         pcout << std::endl;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n ElasticWave::run\\nThis function is very similar to the one in step-40.\\n\\u00a0   template <int dim>\\n\\u00a0   void ElasticWave<dim>::run()\\n\\u00a0   {\\n\\u00a0 #ifdef DEBUG\\n\\u00a0     pcout << \\\"Debug mode\\\" << std::endl;\\n\\u00a0 #else\\n\\u00a0     pcout << \\\"Release mode\\\" << std::endl;\\n\\u00a0 #endif\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       Point<dim> p1;\\n\\u00a0       p1(0) = -parameters.dimension_x / 2;\\n\\u00a0       p1(1) = -parameters.dimension_y / 2;\\n\\u00a0       if (dim == 3)\\n\\u00a0         {\\n\\u00a0           p1(2) = -parameters.dimension_y / 2;\\n\\u00a0         }\\n\\u00a0       Point<dim> p2;\\n\\u00a0       p2(0) = parameters.dimension_x / 2;\\n\\u00a0       p2(1) = parameters.dimension_y / 2;\\n\\u00a0       if (dim == 3)\\n\\u00a0         {\\n\\u00a0           p2(2) = parameters.dimension_y / 2;\\n\\u00a0         }\\n\\u00a0       std::vector<unsigned int> divisions(dim);\\n\\u00a0       divisions[0] = int(parameters.dimension_x / parameters.dimension_y);\\n\\u00a0       divisions[1] = 1;\\n\\u00a0       if (dim == 3)\\n\\u00a0         {\\n\\u00a0           divisions[2] = 1;\\n\\u00a0         }\\n\\u00a0       GridGenerator::subdivided_hyper_rectangle(triangulation,\\n\\u00a0                                                 divisions,\\n\\u00a0                                                 p1,\\n\\u00a0                                                 p2);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     triangulation.refine_global(parameters.grid_level);\\n\\u00a0 \\n\\u00a0     setup_quadrature_cache();\\n\\u00a0 \\n\\u00a0     initialize_probe_positions_vector();\\n\\u00a0 \\n\\u00a0     frequency_sweep();\\n\\u00a0 \\n\\u00a0     output_results();\\n\\u00a0   }\\n\\u00a0 } // namespace step62\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nGridGenerator::subdivided_hyper_rectanglevoid subdivided_hyper_rectangle(Triangulation< dim, spacedim > &tria, const std::vector< unsigned int > &repetitions, const Point< dim > &p1, const Point< dim > &p2, const bool colorize=false)\\n The main function\\nThe main function is very similar to the one in step-40.\\n\\u00a0 int main(int argc, char *argv[])\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       using namespace dealii;\\n\\u00a0       const unsigned int dim = 2;\\n\\u00a0 \\n\\u00a0       Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);\\n\\u00a0 \\n\\u00a0       HDF5::File data_file(\\\"results.h5\\\",\\n\\u00a0                            HDF5::File::FileAccessMode::create,\\n\\u00a0                            MPI_COMM_WORLD);\\n\\u00a0       auto       data = data_file.create_group(\\\"data\\\");\\n\\u00a0 \\nHDF5::FileDefinition hdf5.h:1074\\nHDF5::File::FileAccessMode::create@ create\\nHDF5::Group::create_groupGroup create_group(const std::string &name) constDefinition hdf5.cc:380\\nUtilities::MPI::MPI_InitFinalizeDefinition mpi.h:1081\\nEach of the simulations (displacement and calibration) is stored in a separate HDF5 group:\\n\\u00a0       const std::array<std::string, 2> group_names{\\n\\u00a0         {\\\"displacement\\\", \\\"calibration\\\"}};\\n\\u00a0       for (const std::string &group_name : group_names)\\n\\u00a0         {\\nFor each of these two group names, we now create the group and put attributes into these groups. Specifically, these are:\\nThe dimensions of the waveguide (in \\\\(x\\\\) and \\\\(y\\\\) directions)\\nThe position of the probe (in \\\\(x\\\\) and \\\\(y\\\\) directions)\\nThe number of points in the probe\\nThe global refinement level\\nThe cavity resonance frequency\\nThe number of mirror pairs\\nThe material properties\\nThe force parameters\\nThe PML parameters\\nThe frequency parameters\\n\\n\\u00a0           auto group = data.create_group(group_name);\\n\\u00a0 \\n\\u00a0           group.set_attribute<double>(\\\"dimension_x\\\", 2e-5);\\n\\u00a0           group.set_attribute<double>(\\\"dimension_y\\\", 2e-8);\\n\\u00a0           group.set_attribute<double>(\\\"probe_pos_x\\\", 8e-6);\\n\\u00a0           group.set_attribute<double>(\\\"probe_pos_y\\\", 0);\\n\\u00a0           group.set_attribute<double>(\\\"probe_width_y\\\", 2e-08);\\n\\u00a0           group.set_attribute<unsigned int>(\\\"nb_probe_points\\\", 5);\\n\\u00a0           group.set_attribute<unsigned int>(\\\"grid_level\\\", 1);\\n\\u00a0           group.set_attribute<double>(\\\"cavity_resonance_frequency\\\", 20e9);\\n\\u00a0           group.set_attribute<unsigned int>(\\\"nb_mirror_pairs\\\", 15);\\n\\u00a0 \\n\\u00a0           group.set_attribute<double>(\\\"poissons_ratio\\\", 0.27);\\n\\u00a0           group.set_attribute<double>(\\\"youngs_modulus\\\", 270000000000.0);\\n\\u00a0           group.set_attribute<double>(\\\"material_a_rho\\\", 3200);\\n\\u00a0 \\n\\u00a0           if (group_name == \\\"displacement\\\")\\n\\u00a0             group.set_attribute<double>(\\\"material_b_rho\\\", 2000);\\n\\u00a0           else\\n\\u00a0             group.set_attribute<double>(\\\"material_b_rho\\\", 3200);\\n\\u00a0 \\n\\u00a0           group.set_attribute(\\n\\u00a0             \\\"lambda\\\",\\n\\u00a0             group.get_attribute<double>(\\\"youngs_modulus\\\") *\\n\\u00a0               group.get_attribute<double>(\\\"poissons_ratio\\\") /\\n\\u00a0               ((1 + group.get_attribute<double>(\\\"poissons_ratio\\\")) *\\n\\u00a0                (1 - 2 * group.get_attribute<double>(\\\"poissons_ratio\\\"))));\\n\\u00a0           group.set_attribute(\\\"mu\\\",\\n\\u00a0                               group.get_attribute<double>(\\\"youngs_modulus\\\") /\\n\\u00a0                                 (2 * (1 + group.get_attribute<double>(\\n\\u00a0                                             \\\"poissons_ratio\\\"))));\\n\\u00a0 \\n\\u00a0           group.set_attribute<double>(\\\"max_force_amplitude\\\", 1e26);\\n\\u00a0           group.set_attribute<double>(\\\"force_sigma_x\\\", 1e-7);\\n\\u00a0           group.set_attribute<double>(\\\"force_sigma_y\\\", 1);\\n\\u00a0           group.set_attribute<double>(\\\"max_force_width_x\\\", 3e-7);\\n\\u00a0           group.set_attribute<double>(\\\"max_force_width_y\\\", 2e-8);\\n\\u00a0           group.set_attribute<double>(\\\"force_x_pos\\\", -8e-6);\\n\\u00a0           group.set_attribute<double>(\\\"force_y_pos\\\", 0);\\n\\u00a0 \\n\\u00a0           group.set_attribute<bool>(\\\"pml_x\\\", true);\\n\\u00a0           group.set_attribute<bool>(\\\"pml_y\\\", false);\\n\\u00a0           group.set_attribute<double>(\\\"pml_width_x\\\", 1.8e-6);\\n\\u00a0           group.set_attribute<double>(\\\"pml_width_y\\\", 5e-7);\\n\\u00a0           group.set_attribute<double>(\\\"pml_coeff\\\", 1.6);\\n\\u00a0           group.set_attribute<unsigned int>(\\\"pml_coeff_degree\\\", 2);\\n\\u00a0 \\n\\u00a0           group.set_attribute<double>(\\\"center_frequency\\\", 20e9);\\n\\u00a0           group.set_attribute<double>(\\\"frequency_range\\\", 0.5e9);\\n\\u00a0           group.set_attribute<double>(\\n\\u00a0             \\\"start_frequency\\\",\\n\\u00a0             group.get_attribute<double>(\\\"center_frequency\\\") -\\n\\u00a0               group.get_attribute<double>(\\\"frequency_range\\\") / 2);\\n\\u00a0           group.set_attribute<double>(\\n\\u00a0             \\\"stop_frequency\\\",\\n\\u00a0             group.get_attribute<double>(\\\"center_frequency\\\") +\\n\\u00a0               group.get_attribute<double>(\\\"frequency_range\\\") / 2);\\n\\u00a0           group.set_attribute<unsigned int>(\\\"nb_frequency_points\\\", 400);\\n\\u00a0 \\n\\u00a0           if (group_name == std::string(\\\"displacement\\\"))\\n\\u00a0             group.set_attribute<std::string>(\\n\\u00a0               \\\"simulation_name\\\", std::string(\\\"phononic_cavity_displacement\\\"));\\n\\u00a0           else\\n\\u00a0             group.set_attribute<std::string>(\\n\\u00a0               \\\"simulation_name\\\", std::string(\\\"phononic_cavity_calibration\\\"));\\n\\u00a0 \\n\\u00a0           group.set_attribute<bool>(\\\"save_vtu_files\\\", false);\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0       {\\nDisplacement simulation. The parameters are read from the displacement HDF5 group and the results are saved in the same HDF5 group.\\n\\u00a0         auto                    displacement = data.open_group(\\\"displacement\\\");\\n\\u00a0         step62::Parameters<dim> parameters(displacement);\\n\\u00a0 \\n\\u00a0         step62::ElasticWave<dim> elastic_problem(parameters);\\n\\u00a0         elastic_problem.run();\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0       {\\nCalibration simulation. The parameters are read from the calibration HDF5 group and the results are saved in the same HDF5 group.\\n\\u00a0         auto                    calibration = data.open_group(\\\"calibration\\\");\\n\\u00a0         step62::Parameters<dim> parameters(calibration);\\n\\u00a0 \\n\\u00a0         step62::ElasticWave<dim> elastic_problem(parameters);\\n\\u00a0         elastic_problem.run();\\n\\u00a0       }\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0 \\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nResonance frequency and bandgap\\nThe results are analyzed in the jupyter notebook with the following code h5_file = h5py.File('results.h5', 'r')\\ndata = h5_file['data']\\n \\n# Gaussian function that we use to fit the resonance\\ndef resonance_f(freq, freq_m, quality_factor, max_amplitude):\\n    omega = 2 * constants.pi * freq\\n    omega_m = 2 * constants.pi * freq_m\\n    gamma = omega_m / quality_factor\\n return max_amplitude * omega_m**2 * gamma**2 / (((omega_m**2 - omega**2)**2 + gamma**2 * omega**2))\\n \\nfrequency = data['displacement']['frequency'][...]\\n# Average the probe points\\ndisplacement = np.mean(data['displacement']['displacement'], axis=0)\\ncalibration_displacement = np.mean(data['calibration']['displacement'], axis=0)\\nreflection_coefficient = displacement / calibration_displacement\\nreflectivity = (np.abs(np.mean(data['displacement']['displacement'][...]**2, axis=0))/\\n                np.abs(np.mean(data['calibration']['displacement'][...]**2, axis=0)))\\n \\ntry:\\n    x_data = frequency\\n    y_data = reflectivity\\n    quality_factor_guess = 1e3\\n    freq_guess = x_data[np.argmax(y_data)]\\n    amplitude_guess = np.max(y_data)\\n    fit_result, covariance = scipy.optimize.curve_fit(resonance_f, x_data, y_data,\\n                                                      [freq_guess, quality_factor_guess, amplitude_guess])\\n    freq_m = fit_result[0]\\n    quality_factor = np.abs(fit_result[1])\\n    max_amplitude = fit_result[2]\\n    y_data_fit = resonance_f(x_data, freq_m, quality_factor, max_amplitude)\\n \\n    fig = plt.figure()\\n    plt.plot(frequency / 1e9, reflectivity, frequency / 1e9, y_data_fit)\\n    plt.xlabel('frequency (GHz)')\\n    plt.ylabel('amplitude^2 (a.u.)')\\n    plt.title('Transmission\\\\n' + 'freq = ' + \\\"%.7g\\\" % (freq_guess / 1e9) + 'GHz Q = ' + \\\"%.6g\\\" % quality_factor)\\nexcept:\\n    fig = plt.figure()\\n    plt.plot(frequency / 1e9, reflectivity)\\n    plt.xlabel('frequency (GHz)')\\n    plt.ylabel('amplitude^2 (a.u.)')\\n    plt.title('Transmission')\\n \\nfig = plt.figure()\\nplt.plot(frequency / 1e9, np.angle(reflection_coefficient))\\nplt.xlabel('frequency (GHz)')\\nplt.ylabel('phase (rad)')\\nplt.title('Phase (transmission coefficient)\\\\n')\\n \\nplt.show()\\nh5_file.close()\\nA phononic cavity is characterized by the resonance frequency and the the quality factor. The quality factor is equal to the ratio between the stored energy in the resonator and the energy dissipated energy per cycle, which is approximately equivalent to the ratio between the resonance frequency and the full width at half maximum (FWHM). The FWHM is equal to the bandwidth over which the power of vibration is greater than half the power at the resonant frequency.    \\n\\\\[\\nQ = \\\\frac{f_r}{\\\\Delta f} = \\\\frac{\\\\omega_r}{\\\\Delta \\\\omega} =\\n2 \\\\pi \\\\times \\\\frac{\\\\text{energy stored}}{\\\\text{energy dissipated per cycle}}\\n\\\\]\\n\\nThe square of the amplitude of the mechanical resonance \\\\(a^2\\\\) as a function of the frequency has a gaussian shape   \\n\\\\[\\na^2 = a_\\\\textrm{max}^2\\\\frac{\\\\omega^2\\\\Gamma^2}{(\\\\omega_r^2-\\\\omega^2)^2+\\\\Gamma^2\\\\omega^2}\\n\\\\]\\n\\n where \\\\(f_r = \\\\frac{\\\\omega_r}{2\\\\pi}\\\\) is the resonance frequency and \\\\(\\\\Gamma=\\\\frac{\\\\omega_r}{Q}\\\\) is the dissipation rate. We used the previous equation in the jupyter notebook to fit the mechanical resonance.\\nGiven the values we have chosen for the parameters, one could estimate the resonance frequency analytically. Indeed, this is then confirmed by what we get in this program: the phononic superlattice cavity exhibits a mechanical resonance at 20GHz and a quality factor of 5046. The following images show the transmission amplitude and phase as a function of frequency in the vicinity of the resonance frequency:\\n \\nThe images above suggest that the periodic structure has its intended effect: It really only lets waves of a very specific frequency pass through, whereas all other waves are reflected. This is of course precisely what one builds these sorts of devices for. But it is not quite this easy. In practice, there is really only a \\\"band gap\\\", i.e., the device blocks waves other than the desired one at 20GHz only within a certain frequency range. Indeed, to find out how large this \\\"gap\\\" is within which waves are blocked, we can extend the frequency range to 16 GHz through the appropriate parameters in the input file. We then obtain the following image:\\n\\nWhat this image suggests is that in the range of around 18 to around 22 GHz, really only the waves with a frequency of 20 GHz are allowed to pass through, but beyond this range, there are plenty of other frequencies that can pass through the device.\\nMode profile\\nWe can inspect the mode profile with Paraview or VisIt. As we have discussed, at resonance all the mechanical energy is transmitted and the amplitude of motion is amplified inside the cavity. It can be observed that the PMLs are quite effective to truncate the solution. The following image shows the mode profile at resonance:\\n\\nOn the other hand, out of resonance all the mechanical energy is reflected. The following image shows the profile at 19.75 GHz. Note the interference between the force pulse and the reflected wave at the position \\\\(x=-8\\\\mu\\\\textrm{m}\\\\).\\n\\nExperimental applications\\nPhononic superlattice cavities find application in quantum optomechanics. Here we have presented the simulation of a 2D superlattice cavity, but this code can be used as well to simulate \\\"real world\\\" 3D devices such as micropillar superlattice cavities, which are promising candidates to study macroscopic quantum phenomena. The 20GHz mode of a micropillar superlattice cavity is essentially a mechanical harmonic oscillator that is very well isolated from the environment. If the device is cooled down to 20mK in a dilution fridge, the mode would then become a macroscopic quantum harmonic oscillator.\\nPossibilities for extensions\\nInstead of setting the parameters in the C++ file we could set the parameters using a python script and save them in the HDF5 file that we will use for the simulations. Then the deal.II program will read the parameters from the HDF5 file.\\nimport numpy as np\\nimport h5py\\nimport matplotlib.pyplot as plt\\nimport subprocess\\nimport scipy.constants as constants\\nimport scipy.optimize\\n \\n# This considerably reduces the size of the svg data\\nplt.rcParams['svg.fonttype'] = 'none'\\n \\nh5_file = h5py.File('results.h5', 'w')\\ndata = h5_file.create_group('data')\\ndisplacement = data.create_group('displacement')\\ncalibration = data.create_group('calibration')\\n \\n# Set the parameters\\nfor group in [displacement, calibration]:\\n # Dimensions of the domain\\n # The waveguide length is equal to dimension_x\\n    group.attrs['dimension_x'] = 2e-5\\n # The waveguide width is equal to dimension_y\\n    group.attrs['dimension_y'] = 2e-8\\n \\n # Position of the probe that we use to measure the flux\\n    group.attrs['probe_pos_x']   = 8e-6\\n    group.attrs['probe_pos_y']   = 0\\n    group.attrs['probe_width_y'] = 2e-08\\n \\n # Number of points in the probe\\n    group.attrs['nb_probe_points'] = 5\\n \\n # Global refinement\\n    group.attrs['grid_level'] = 1\\n \\n # Cavity\\n    group.attrs['cavity_resonance_frequency'] = 20e9\\n    group.attrs['nb_mirror_pairs']            = 15\\n \\n # Material\\n    group.attrs['poissons_ratio'] = 0.27\\n    group.attrs['youngs_modulus'] = 270000000000.0\\n    group.attrs['material_a_rho'] = 3200\\n if group == displacement:\\n        group.attrs['material_b_rho'] = 2000\\n else:\\n        group.attrs['material_b_rho'] = 3200\\n    group.attrs['lambda'] = (group.attrs['youngs_modulus'] * group.attrs['poissons_ratio'] /\\n                           ((1 + group.attrs['poissons_ratio']) *\\n                           (1 - 2 * group.attrs['poissons_ratio'])))\\n    group.attrs['mu']= (group.attrs['youngs_modulus'] / (2 * (1 + group.attrs['poissons_ratio'])))\\n \\n # Force\\n    group.attrs['max_force_amplitude'] = 1e26\\n    group.attrs['force_sigma_x']       = 1e-7\\n    group.attrs['force_sigma_y']       = 1\\n    group.attrs['max_force_width_x']   = 3e-7\\n    group.attrs['max_force_width_y']   = 2e-8\\n    group.attrs['force_x_pos']         = -8e-6\\n    group.attrs['force_y_pos']         = 0\\n \\n # PML\\n    group.attrs['pml_x']            = True\\n    group.attrs['pml_y']            = False\\n    group.attrs['pml_width_x']      = 1.8e-6\\n    group.attrs['pml_width_y']      = 5e-7\\n    group.attrs['pml_coeff']        = 1.6\\n    group.attrs['pml_coeff_degree'] = 2\\n \\n # Frequency sweep\\n    group.attrs['center_frequency']    = 20e9\\n    group.attrs['frequency_range']     = 0.5e9\\n    group.attrs['start_frequency']     = group.attrs['center_frequency'] - group.attrs['frequency_range'] / 2\\n    group.attrs['stop_frequency']      = group.attrs['center_frequency'] + group.attrs['frequency_range'] / 2\\n    group.attrs['nb_frequency_points'] = 400\\n \\n # Other parameters\\n if group == displacement:\\n        group.attrs['simulation_name'] = 'phononic_cavity_displacement'\\n else:\\n        group.attrs['simulation_name'] = 'phononic_cavity_calibration'\\n    group.attrs['save_vtu_files'] = False\\n \\nh5_file.close()\\nIn order to read the HDF5 parameters we have to use the HDF5::File::FileAccessMode::open flag. HDF5::File data_file(\\\"results.h5\\\",\\n                     HDF5::File::FileAccessMode::open,\\n                     MPI_COMM_WORLD);\\nauto       data = data_file.open_group(\\\"data\\\");\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2019 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Author: Daniel Garcia-Sanchez, CNRS, 2019\\n */\\n \\n \\n#include <deal.II/base/conditional_ostream.h>\\n#include <deal.II/base/function.h>\\n \\n#include <deal.II/base/index_set.h>\\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/timer.h>\\n#include <deal.II/base/utilities.h>\\n \\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_system.h>\\n#include <deal.II/fe/fe_values.h>\\n \\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_refinement.h>\\n \\n#include <deal.II/lac/affine_constraints.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/generic_linear_algebra.h>\\n#include <deal.II/lac/petsc_solver.h>\\n#include <deal.II/lac/vector.h>\\n \\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/error_estimator.h>\\n \\n#include <fstream>\\n#include <iostream>\\n \\n#include <deal.II/base/tensor.h>\\n \\n \\n#include <deal.II/base/hdf5.h>\\n \\n#include <deal.II/numerics/vector_tools.h>\\n \\n#include <deal.II/grid/grid_tools.h>\\n#include <deal.II/grid/grid_tools_cache.h>\\n \\nnamespace step62\\n{\\n using namespace dealii;\\n \\n \\n template <int dim>\\n class RightHandSide : public Function<dim>\\n  {\\n public:\\n    RightHandSide(HDF5::Group &data);\\n \\n virtual double value(const Point<dim>  &p,\\n const unsigned int component) const override;\\n \\n private:\\n HDF5::Group data;\\n \\n const double     max_force_amplitude;\\n const double     force_sigma_x;\\n const double     force_sigma_y;\\n const double     max_force_width_x;\\n const double     max_force_width_y;\\n const Point<dim> force_center;\\n \\n public:\\n const unsigned int force_component = 0;\\n  };\\n \\n template <int dim>\\n class PML : public Function<dim, std::complex<double>>\\n  {\\n public:\\n    PML(HDF5::Group &data);\\n \\n virtual std::complex<double>\\n    value(const Point<dim> &p, const unsigned int component) const override;\\n \\n private:\\n HDF5::Group data;\\n \\n const double pml_coeff;\\n const int    pml_coeff_degree;\\n const double dimension_x;\\n const double dimension_y;\\n const bool   pml_x;\\n const bool   pml_y;\\n const double pml_width_x;\\n const double pml_width_y;\\n const double a_coeff_x;\\n const double a_coeff_y;\\n  };\\n \\n \\n \\n template <int dim>\\n class Rho : public Function<dim>\\n  {\\n public:\\n    Rho(HDF5::Group &data);\\n \\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n \\n private:\\n HDF5::Group data;\\n \\n const double lambda;\\n const double       mu;\\n const double       material_a_rho;\\n const double       material_b_rho;\\n const double       cavity_resonance_frequency;\\n const unsigned int nb_mirror_pairs;\\n const double       dimension_y;\\n const unsigned int grid_level;\\n double             average_rho_width;\\n  };\\n \\n \\n \\n template <int dim>\\n class Parameters\\n  {\\n public:\\n    Parameters(HDF5::Group &data);\\n \\n HDF5::Group data;\\n \\n const std::string        simulation_name;\\n const bool               save_vtu_files;\\n const double             start_frequency;\\n const double             stop_frequency;\\n const unsigned int       nb_frequency_points;\\n const double lambda;\\n const double             mu;\\n const double             dimension_x;\\n const double             dimension_y;\\n const unsigned int       nb_probe_points;\\n const unsigned int       grid_level;\\n const Point<dim>         probe_start_point;\\n const Point<dim>         probe_stop_point;\\n const RightHandSide<dim> right_hand_side;\\n const PML<dim>           pml;\\n const Rho<dim>           rho;\\n \\n private:\\n const double comparison_float_constant = 1e-12;\\n  };\\n \\n \\n \\n template <int dim>\\n class QuadratureCache\\n  {\\n public:\\n    QuadratureCache(const unsigned int dofs_per_cell);\\n \\n private:\\n unsigned int dofs_per_cell;\\n \\n public:\\n FullMatrix<std::complex<double>>  mass_coefficient;\\n FullMatrix<std::complex<double>>  stiffness_coefficient;\\n    std::vector<std::complex<double>> right_hand_side;\\n double                            JxW;\\n  };\\n \\n \\n \\n \\n template <int dim>\\n SymmetricTensor<4, dim> get_stiffness_tensor(const double lambda,\\n const double mu)\\n  {\\n SymmetricTensor<4, dim> stiffness_tensor;\\n for (unsigned int i = 0; i < dim; ++i)\\n for (unsigned int j = 0; j < dim; ++j)\\n for (unsigned int k = 0; k < dim; ++k)\\n for (unsigned int l = 0; l < dim; ++l)\\n            stiffness_tensor[i][j][k][l] =\\n              (((i == k) && (j == l) ? mu : 0.0) +\\n               ((i == l) && (j == k) ? mu : 0.0) +\\n               ((i == j) && (k == l) ? lambda : 0.0));\\n return stiffness_tensor;\\n  }\\n \\n \\n \\n \\n template <int dim>\\n class ElasticWave\\n  {\\n public:\\n    ElasticWave(const Parameters<dim> &parameters);\\n void run();\\n \\n private:\\n void setup_system();\\n void assemble_system(const double omega,\\n const bool   calculate_quadrature_data);\\n void solve();\\n void initialize_probe_positions_vector();\\n void store_frequency_step_data(const unsigned int frequency_idx);\\n void output_results();\\n \\n void setup_quadrature_cache();\\n \\n void frequency_sweep();\\n \\n    Parameters<dim> parameters;\\n \\n MPI_Comm mpi_communicator;\\n \\n parallel::distributed::Triangulation<dim> triangulation;\\n \\n const QGauss<dim> quadrature_formula;\\n \\n    std::vector<QuadratureCache<dim>> quadrature_cache;\\n \\n \\n const FESystem<dim> fe;\\n DoFHandler<dim>     dof_handler;\\n \\n IndexSet locally_owned_dofs;\\n IndexSet locally_relevant_dofs;\\n \\n AffineConstraints<std::complex<double>> constraints;\\n \\n LinearAlgebraPETSc::MPI::SparseMatrix system_matrix;\\n LinearAlgebraPETSc::MPI::Vector       locally_relevant_solution;\\n LinearAlgebraPETSc::MPI::Vector       system_rhs;\\n \\n \\n    std::vector<double> frequency;\\n \\n FullMatrix<double> probe_positions;\\n \\n HDF5::DataSet frequency_dataset;\\n HDF5::DataSet probe_positions_dataset;\\n \\n HDF5::DataSet displacement;\\n \\n \\n ConditionalOStream pcout;\\n TimerOutput        computing_timer;\\n  };\\n \\n \\n \\n \\n \\n template <int dim>\\n  RightHandSide<dim>::RightHandSide(HDF5::Group &data)\\n    : Function<dim>(dim)\\n    , data(data)\\n    , max_force_amplitude(data.get_attribute<double>(\\\"max_force_amplitude\\\"))\\n    , force_sigma_x(data.get_attribute<double>(\\\"force_sigma_x\\\"))\\n    , force_sigma_y(data.get_attribute<double>(\\\"force_sigma_y\\\"))\\n    , max_force_width_x(data.get_attribute<double>(\\\"max_force_width_x\\\"))\\n    , max_force_width_y(data.get_attribute<double>(\\\"max_force_width_y\\\"))\\n    , force_center(Point<dim>(data.get_attribute<double>(\\\"force_x_pos\\\"),\\n                              data.get_attribute<double>(\\\"force_y_pos\\\")))\\n  {}\\n \\n template <int dim>\\n double RightHandSide<dim>::value(const Point<dim>  &p,\\n const unsigned int component) const\\n {\\n if (component == force_component)\\n      {\\n if (std::abs(p[0] - force_center[0]) < max_force_width_x / 2 &&\\n std::abs(p[1] - force_center[1]) < max_force_width_y / 2)\\n          {\\n return max_force_amplitude *\\n std::exp(\\n                     -(Utilities::fixed_power<2>(p[0] - force_center[0]) /\\n                         (2 * Utilities::fixed_power<2>(force_sigma_x)) +\\n Utilities::fixed_power<2>(p[1] - force_center[1]) /\\n                         (2 * Utilities::fixed_power<2>(force_sigma_y))));\\n          }\\n else\\n          {\\n return 0;\\n          }\\n      }\\n else\\n      {\\n return 0;\\n      }\\n  }\\n \\n \\n \\n \\n template <int dim>\\n  PML<dim>::PML(HDF5::Group &data)\\n    : Function<dim, std::complex<double>>(dim)\\n    , data(data)\\n    , pml_coeff(data.get_attribute<double>(\\\"pml_coeff\\\"))\\n    , pml_coeff_degree(data.get_attribute<int>(\\\"pml_coeff_degree\\\"))\\n    , dimension_x(data.get_attribute<double>(\\\"dimension_x\\\"))\\n    , dimension_y(data.get_attribute<double>(\\\"dimension_y\\\"))\\n    , pml_x(data.get_attribute<bool>(\\\"pml_x\\\"))\\n    , pml_y(data.get_attribute<bool>(\\\"pml_y\\\"))\\n    , pml_width_x(data.get_attribute<double>(\\\"pml_width_x\\\"))\\n    , pml_width_y(data.get_attribute<double>(\\\"pml_width_y\\\"))\\n    , a_coeff_x(pml_coeff / std::pow(pml_width_x, pml_coeff_degree))\\n    , a_coeff_y(pml_coeff / std::pow(pml_width_y, pml_coeff_degree))\\n  {}\\n \\n \\n \\n template <int dim>\\n  std::complex<double> PML<dim>::value(const Point<dim>  &p,\\n const unsigned int component) const\\n {\\n double calculated_pml_x_coeff = 0;\\n double calculated_pml_y_coeff = 0;\\n \\n if ((component == 0) && pml_x)\\n      {\\n const double pml_x_start_position = dimension_x / 2 - pml_width_x;\\n if (std::abs(p[0]) > pml_x_start_position)\\n          {\\n const double x_prime = std::abs(p[0]) - pml_x_start_position;\\n            calculated_pml_x_coeff =\\n              a_coeff_x * std::pow(x_prime, pml_coeff_degree);\\n          }\\n      }\\n \\n if ((component == 1) && pml_y)\\n      {\\n const double pml_y_start_position = dimension_y / 2 - pml_width_y;\\n if (std::abs(p[1]) > pml_y_start_position)\\n          {\\n const double y_prime = std::abs(p[1]) - pml_y_start_position;\\n            calculated_pml_y_coeff =\\n              a_coeff_y * std::pow(y_prime, pml_coeff_degree);\\n          }\\n      }\\n \\n return 1. + std::max(calculated_pml_x_coeff, calculated_pml_y_coeff) *\\n                  std::complex<double>(0., 1.);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n  Rho<dim>::Rho(HDF5::Group &data)\\n    : Function<dim>(1)\\n    , data(data)\\n    , lambda(data.get_attribute<double>(\\\"lambda\\\"))\\n    , mu(data.get_attribute<double>(\\\"mu\\\"))\\n    , material_a_rho(data.get_attribute<double>(\\\"material_a_rho\\\"))\\n    , material_b_rho(data.get_attribute<double>(\\\"material_b_rho\\\"))\\n    , cavity_resonance_frequency(\\n        data.get_attribute<double>(\\\"cavity_resonance_frequency\\\"))\\n    , nb_mirror_pairs(data.get_attribute<int>(\\\"nb_mirror_pairs\\\"))\\n    , dimension_y(data.get_attribute<double>(\\\"dimension_y\\\"))\\n    , grid_level(data.get_attribute<int>(\\\"grid_level\\\"))\\n  {\\n    average_rho_width = dimension_y / (std::pow(2.0, grid_level));\\n    data.set_attribute(\\\"average_rho_width\\\", average_rho_width);\\n  }\\n \\n \\n \\n template <int dim>\\n double Rho<dim>::value(const Point<dim> &p,\\n const unsigned int /*component*/) const\\n {\\n double elastic_constant;\\n if (dim == 2)\\n      {\\n        elastic_constant = 4 * mu * (lambda + mu) / (lambda + 2 * mu);\\n      }\\n else if (dim == 3)\\n      {\\n        elastic_constant = mu * (3 * lambda + 2 * mu) / (lambda + mu);\\n      }\\n else\\n DEAL_II_NOT_IMPLEMENTED();\\n \\n const double material_a_speed_of_sound =\\n std::sqrt(elastic_constant / material_a_rho);\\n const double material_a_wavelength =\\n      material_a_speed_of_sound / cavity_resonance_frequency;\\n const double material_b_speed_of_sound =\\n std::sqrt(elastic_constant / material_b_rho);\\n const double material_b_wavelength =\\n      material_b_speed_of_sound / cavity_resonance_frequency;\\n \\n for (unsigned int idx = 0; idx < nb_mirror_pairs; ++idx)\\n      {\\n const double layer_transition_center =\\n          material_a_wavelength / 2 +\\n          idx * (material_b_wavelength / 4 + material_a_wavelength / 4);\\n if (std::abs(p[0]) >=\\n              (layer_transition_center - average_rho_width / 2) &&\\n std::abs(p[0]) <= (layer_transition_center + average_rho_width / 2))\\n          {\\n const double coefficient =\\n              (std::abs(p[0]) -\\n               (layer_transition_center - average_rho_width / 2)) /\\n              average_rho_width;\\n return (1 - coefficient) * material_a_rho +\\n                   coefficient * material_b_rho;\\n          }\\n      }\\n \\n for (unsigned int idx = 0; idx < nb_mirror_pairs; ++idx)\\n      {\\n const double layer_transition_center =\\n          material_a_wavelength / 2 +\\n          idx * (material_b_wavelength / 4 + material_a_wavelength / 4) +\\n          material_b_wavelength / 4;\\n if (std::abs(p[0]) >=\\n              (layer_transition_center - average_rho_width / 2) &&\\n std::abs(p[0]) <= (layer_transition_center + average_rho_width / 2))\\n          {\\n const double coefficient =\\n              (std::abs(p[0]) -\\n               (layer_transition_center - average_rho_width / 2)) /\\n              average_rho_width;\\n return (1 - coefficient) * material_b_rho +\\n                   coefficient * material_a_rho;\\n          }\\n      }\\n \\n if (std::abs(p[0]) <= material_a_wavelength / 2)\\n      {\\n return material_a_rho;\\n      }\\n \\n for (unsigned int idx = 0; idx < nb_mirror_pairs; ++idx)\\n      {\\n const double layer_center =\\n          material_a_wavelength / 2 +\\n          idx * (material_b_wavelength / 4 + material_a_wavelength / 4) +\\n          material_b_wavelength / 4 + material_a_wavelength / 8;\\n const double layer_width = material_a_wavelength / 4;\\n if (std::abs(p[0]) >= (layer_center - layer_width / 2) &&\\n std::abs(p[0]) <= (layer_center + layer_width / 2))\\n          {\\n return material_a_rho;\\n          }\\n      }\\n \\n for (unsigned int idx = 0; idx < nb_mirror_pairs; ++idx)\\n      {\\n const double layer_center =\\n          material_a_wavelength / 2 +\\n          idx * (material_b_wavelength / 4 + material_a_wavelength / 4) +\\n          material_b_wavelength / 8;\\n const double layer_width = material_b_wavelength / 4;\\n if (std::abs(p[0]) >= (layer_center - layer_width / 2) &&\\n std::abs(p[0]) <= (layer_center + layer_width / 2))\\n          {\\n return material_b_rho;\\n          }\\n      }\\n \\n return material_a_rho;\\n  }\\n \\n \\n \\n \\n template <int dim>\\n  Parameters<dim>::Parameters(HDF5::Group &data)\\n    : data(data)\\n    , simulation_name(data.get_attribute<std::string>(\\\"simulation_name\\\"))\\n    , save_vtu_files(data.get_attribute<bool>(\\\"save_vtu_files\\\"))\\n    , start_frequency(data.get_attribute<double>(\\\"start_frequency\\\"))\\n    , stop_frequency(data.get_attribute<double>(\\\"stop_frequency\\\"))\\n    , nb_frequency_points(data.get_attribute<int>(\\\"nb_frequency_points\\\"))\\n    , lambda(data.get_attribute<double>(\\\"lambda\\\"))\\n    , mu(data.get_attribute<double>(\\\"mu\\\"))\\n    , dimension_x(data.get_attribute<double>(\\\"dimension_x\\\"))\\n    , dimension_y(data.get_attribute<double>(\\\"dimension_y\\\"))\\n    , nb_probe_points(data.get_attribute<int>(\\\"nb_probe_points\\\"))\\n    , grid_level(data.get_attribute<int>(\\\"grid_level\\\"))\\n    , probe_start_point(data.get_attribute<double>(\\\"probe_pos_x\\\"),\\n                        data.get_attribute<double>(\\\"probe_pos_y\\\") -\\n                          data.get_attribute<double>(\\\"probe_width_y\\\") / 2)\\n    , probe_stop_point(data.get_attribute<double>(\\\"probe_pos_x\\\"),\\n                       data.get_attribute<double>(\\\"probe_pos_y\\\") +\\n                         data.get_attribute<double>(\\\"probe_width_y\\\") / 2)\\n    , right_hand_side(data)\\n    , pml(data)\\n    , rho(data)\\n  {}\\n \\n \\n \\n \\n template <int dim>\\n  QuadratureCache<dim>::QuadratureCache(const unsigned int dofs_per_cell)\\n    : dofs_per_cell(dofs_per_cell)\\n    , mass_coefficient(dofs_per_cell, dofs_per_cell)\\n    , stiffness_coefficient(dofs_per_cell, dofs_per_cell)\\n    , right_hand_side(dofs_per_cell)\\n  {}\\n \\n \\n \\n \\n \\n template <int dim>\\n  ElasticWave<dim>::ElasticWave(const Parameters<dim> &parameters)\\n    : parameters(parameters)\\n    , mpi_communicator(MPI_COMM_WORLD)\\n    , triangulation(mpi_communicator,\\n                    typename Triangulation<dim>::MeshSmoothing(\\n Triangulation<dim>::smoothing_on_refinement |\\n Triangulation<dim>::smoothing_on_coarsening))\\n    , quadrature_formula(2)\\n    , fe(FE_Q<dim>(1) ^ dim)\\n    , dof_handler(triangulation)\\n    , frequency(parameters.nb_frequency_points)\\n    , probe_positions(parameters.nb_probe_points, dim)\\n    , frequency_dataset(parameters.data.template create_dataset<double>(\\n \\\"frequency\\\",\\n std::vector<hsize_t>{parameters.nb_frequency_points}))\\n    , probe_positions_dataset(parameters.data.template create_dataset<double>(\\n \\\"position\\\",\\n        std::vector<hsize_t>{parameters.nb_probe_points, dim}))\\n    , displacement(\\n        parameters.data.template create_dataset<std::complex<double>>(\\n \\\"displacement\\\",\\n          std::vector<hsize_t>{parameters.nb_probe_points,\\n                               parameters.nb_frequency_points}))\\n    , pcout(std::cout,\\n            (Utilities::MPI::this_mpi_process(mpi_communicator) == 0))\\n    , computing_timer(mpi_communicator,\\n                      pcout,\\n TimerOutput::never,\\n TimerOutput::wall_times)\\n  {}\\n \\n \\n \\n \\n template <int dim>\\n void ElasticWave<dim>::setup_system()\\n  {\\n TimerOutput::Scope t(computing_timer, \\\"setup\\\");\\n \\n    dof_handler.distribute_dofs(fe);\\n \\n    locally_owned_dofs = dof_handler.locally_owned_dofs();\\n    locally_relevant_dofs =\\n DoFTools::extract_locally_relevant_dofs(dof_handler);\\n \\n    locally_relevant_solution.reinit(locally_owned_dofs,\\n                                     locally_relevant_dofs,\\n                                     mpi_communicator);\\n \\n    system_rhs.reinit(locally_owned_dofs, mpi_communicator);\\n \\n    constraints.clear();\\n    constraints.reinit(locally_relevant_dofs);\\n DoFTools::make_hanging_node_constraints(dof_handler, constraints);\\n \\n    constraints.close();\\n \\n DynamicSparsityPattern dsp(locally_relevant_dofs);\\n \\n DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false);\\n SparsityTools::distribute_sparsity_pattern(dsp,\\n                                               locally_owned_dofs,\\n                                               mpi_communicator,\\n                                               locally_relevant_dofs);\\n \\n    system_matrix.reinit(locally_owned_dofs,\\n                         locally_owned_dofs,\\n                         dsp,\\n                         mpi_communicator);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void ElasticWave<dim>::assemble_system(const double omega,\\n const bool   calculate_quadrature_data)\\n  {\\n TimerOutput::Scope t(computing_timer, \\\"assembly\\\");\\n \\n FEValues<dim>      fe_values(fe,\\n                            quadrature_formula,\\n update_values | update_gradients |\\n update_quadrature_points | update_JxW_values);\\n const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n const unsigned int n_q_points    = quadrature_formula.size();\\n \\n FullMatrix<std::complex<double>> cell_matrix(dofs_per_cell, dofs_per_cell);\\n Vector<std::complex<double>>     cell_rhs(dofs_per_cell);\\n \\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim));\\n    std::vector<double>         rho_values(n_q_points);\\n    std::vector<Vector<std::complex<double>>> pml_values(\\n      n_q_points, Vector<std::complex<double>>(dim));\\n \\n const SymmetricTensor<4, dim> stiffness_tensor =\\n      get_stiffness_tensor<dim>(parameters.lambda, parameters.mu);\\n \\n const FEValuesExtractors::Vector displacement(0);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      if (cell->is_locally_owned())\\n        {\\n cell_matrix = 0;\\n          cell_rhs    = 0;\\n \\n if (calculate_quadrature_data)\\n            {\\n              fe_values.reinit(cell);\\n \\n              parameters.right_hand_side.vector_value_list(\\n                fe_values.get_quadrature_points(), rhs_values);\\n              parameters.rho.value_list(fe_values.get_quadrature_points(),\\n                                        rho_values);\\n              parameters.pml.vector_value_list(\\n                fe_values.get_quadrature_points(), pml_values);\\n            }\\n \\n          QuadratureCache<dim> *local_quadrature_points_data =\\n reinterpret_cast<QuadratureCache<dim> *>(cell->user_pointer());\\n Assert(local_quadrature_points_data >= &quadrature_cache.front(),\\n                 ExcInternalError());\\n Assert(local_quadrature_points_data <= &quadrature_cache.back(),\\n                 ExcInternalError());\\n for (unsigned int q = 0; q < n_q_points; ++q)\\n            {\\n              QuadratureCache<dim> &quadrature_data =\\n                local_quadrature_points_data[q];\\n \\n Tensor<1, dim>                       force;\\n Tensor<1, dim, std::complex<double>> s;\\n              std::complex<double>                 xi(1, 0);\\n \\n if (calculate_quadrature_data)\\n                {\\n                  quadrature_data.JxW = fe_values.JxW(q);\\n \\n for (unsigned int component = 0; component < dim; ++component)\\n                    {\\n                      force[component] = rhs_values[q][component];\\n                      s[component]     = pml_values[q][component];\\n                      xi *= s[component];\\n                    }\\n \\n Tensor<4, dim, std::complex<double>> alpha;\\n Tensor<4, dim, std::complex<double>> beta;\\n for (unsigned int m = 0; m < dim; ++m)\\n for (unsigned int n = 0; n < dim; ++n)\\n for (unsigned int k = 0; k < dim; ++k)\\n for (unsigned int l = 0; l < dim; ++l)\\n                          {\\n                            alpha[m][n][k][l] = xi *\\n                                                stiffness_tensor[m][n][k][l] /\\n                                                (2.0 * s[n] * s[k]);\\n                            beta[m][n][k][l] = xi *\\n                                               stiffness_tensor[m][n][k][l] /\\n                                               (2.0 * s[n] * s[l]);\\n                          }\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n                    {\\n const Tensor<1, dim> phi_i =\\n                        fe_values[displacement].value(i, q);\\n const Tensor<2, dim> grad_phi_i =\\n                        fe_values[displacement].gradient(i, q);\\n \\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n                        {\\n const Tensor<1, dim> phi_j =\\n                            fe_values[displacement].value(j, q);\\n const Tensor<2, dim> grad_phi_j =\\n                            fe_values[displacement].gradient(j, q);\\n \\n                          quadrature_data.mass_coefficient[i][j] =\\n                            rho_values[q] * xi * phi_i * phi_j;\\n \\n                          std::complex<double> stiffness_coefficient = 0;\\n for (unsigned int m = 0; m < dim; ++m)\\n for (unsigned int n = 0; n < dim; ++n)\\n for (unsigned int k = 0; k < dim; ++k)\\n for (unsigned int l = 0; l < dim; ++l)\\n                                  {\\n                                    stiffness_coefficient +=\\n                                      grad_phi_i[m][n] *\\n                                      (alpha[m][n][k][l] * grad_phi_j[l][k] +\\n                                       beta[m][n][k][l] * grad_phi_j[k][l]);\\n                                  }\\n \\n                          quadrature_data.stiffness_coefficient[i][j] =\\n                            stiffness_coefficient;\\n                        }\\n \\n                      quadrature_data.right_hand_side[i] =\\n                        phi_i * force * fe_values.JxW(q);\\n                    }\\n                }\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n                {\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n                    {\\n                      std::complex<double> matrix_sum = 0;\\n                      matrix_sum += -Utilities::fixed_power<2>(omega) *\\n                                    quadrature_data.mass_coefficient[i][j];\\n                      matrix_sum += quadrature_data.stiffness_coefficient[i][j];\\n cell_matrix(i, j) += matrix_sum * quadrature_data.JxW;\\n                    }\\n                  cell_rhs(i) += quadrature_data.right_hand_side[i];\\n                }\\n            }\\n          cell->get_dof_indices(local_dof_indices);\\n          constraints.distribute_local_to_global(cell_matrix,\\n                                                 cell_rhs,\\n                                                 local_dof_indices,\\n                                                 system_matrix,\\n                                                 system_rhs);\\n        }\\n \\n    system_matrix.compress(VectorOperation::add);\\n    system_rhs.compress(VectorOperation::add);\\n  }\\n \\n \\n template <int dim>\\n void ElasticWave<dim>::solve()\\n  {\\n TimerOutput::Scope              t(computing_timer, \\\"solve\\\");\\n LinearAlgebraPETSc::MPI::Vector completely_distributed_solution(\\n      locally_owned_dofs, mpi_communicator);\\n \\n SolverControl                    solver_control;\\n PETScWrappers::SparseDirectMUMPS solver(solver_control, mpi_communicator);\\n    solver.solve(system_matrix, completely_distributed_solution, system_rhs);\\n \\n    pcout << \\\"   Solved in \\\" << solver_control.last_step() << \\\" iterations.\\\"\\n          << std::endl;\\n    constraints.distribute(completely_distributed_solution);\\n    locally_relevant_solution = completely_distributed_solution;\\n  }\\n \\n \\n template <int dim>\\n void ElasticWave<dim>::initialize_probe_positions_vector()\\n  {\\n for (unsigned int position_idx = 0;\\n         position_idx < parameters.nb_probe_points;\\n         ++position_idx)\\n      {\\n const Point<dim> p =\\n          (position_idx / ((double)(parameters.nb_probe_points - 1))) *\\n            (parameters.probe_stop_point + (-parameters.probe_start_point)) +\\n          parameters.probe_start_point;\\n        probe_positions[position_idx][0] = p[0];\\n        probe_positions[position_idx][1] = p[1];\\n if (dim == 3)\\n          {\\n            probe_positions[position_idx][2] = p[2];\\n          }\\n      }\\n  }\\n \\n \\n template <int dim>\\n void\\n  ElasticWave<dim>::store_frequency_step_data(const unsigned int frequency_idx)\\n  {\\n TimerOutput::Scope t(computing_timer, \\\"store_frequency_step_data\\\");\\n \\n const unsigned int probe_displacement_component = 0;\\n \\n    std::vector<hsize_t>              coordinates;\\n    std::vector<std::complex<double>> displacement_data;\\n \\n const auto &mapping = get_default_linear_mapping(triangulation);\\n GridTools::Cache<dim, dim> cache(triangulation, mapping);\\n typename Triangulation<dim, dim>::active_cell_iterator cell_hint{};\\n    std::vector<bool>                                      marked_vertices = {};\\n const double                                           tolerance = 1.e-10;\\n \\n for (unsigned int position_idx = 0;\\n         position_idx < parameters.nb_probe_points;\\n         ++position_idx)\\n      {\\n Point<dim> point;\\n for (unsigned int dim_idx = 0; dim_idx < dim; ++dim_idx)\\n          {\\n point[dim_idx] = probe_positions[position_idx][dim_idx];\\n          }\\n bool point_in_locally_owned_cell = false;\\n        {\\n auto cell_and_ref_point = GridTools::find_active_cell_around_point(\\n            cache, point, cell_hint, marked_vertices, tolerance);\\n if (cell_and_ref_point.first.state() == IteratorState::valid)\\n            {\\n              cell_hint = cell_and_ref_point.first;\\n              point_in_locally_owned_cell =\\n                cell_and_ref_point.first->is_locally_owned();\\n            }\\n        }\\n if (point_in_locally_owned_cell)\\n          {\\n Vector<std::complex<double>> tmp_vector(dim);\\n VectorTools::point_value(dof_handler,\\n                                     locally_relevant_solution,\\n                                     point,\\n                                     tmp_vector);\\n            coordinates.emplace_back(position_idx);\\n            coordinates.emplace_back(frequency_idx);\\n            displacement_data.emplace_back(\\n              tmp_vector(probe_displacement_component));\\n          }\\n      }\\n \\n if (coordinates.size() > 0)\\n      {\\n        displacement.write_selection(displacement_data, coordinates);\\n      }\\n else\\n      {\\n        displacement.write_none<std::complex<double>>();\\n      }\\n \\n if (parameters.save_vtu_files)\\n      {\\n        std::vector<std::string> solution_names(dim, \\\"displacement\\\");\\n        std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n          interpretation(\\n            dim, DataComponentInterpretation::component_is_part_of_vector);\\n \\n DataOut<dim> data_out;\\n        data_out.add_data_vector(dof_handler,\\n                                 locally_relevant_solution,\\n                                 solution_names,\\n                                 interpretation);\\n Vector<float> subdomain(triangulation.n_active_cells());\\n for (unsigned int i = 0; i < subdomain.size(); ++i)\\n          subdomain(i) = triangulation.locally_owned_subdomain();\\n        data_out.add_data_vector(subdomain, \\\"subdomain\\\");\\n \\n        std::vector<Vector<double>> force(\\n          dim, Vector<double>(triangulation.n_active_cells()));\\n        std::vector<Vector<double>> pml(\\n          dim, Vector<double>(triangulation.n_active_cells()));\\n Vector<double> rho(triangulation.n_active_cells());\\n \\n for (auto &cell : triangulation.active_cell_iterators())\\n          {\\n if (cell->is_locally_owned())\\n              {\\n for (unsigned int dim_idx = 0; dim_idx < dim; ++dim_idx)\\n                  {\\n                    force[dim_idx](cell->active_cell_index()) =\\n                      parameters.right_hand_side.value(cell->center(), dim_idx);\\n                    pml[dim_idx](cell->active_cell_index()) =\\n                      parameters.pml.value(cell->center(), dim_idx).imag();\\n                  }\\n                rho(cell->active_cell_index()) =\\n                  parameters.rho.value(cell->center());\\n              }\\n else\\n              {\\n for (unsigned int dim_idx = 0; dim_idx < dim; ++dim_idx)\\n                  {\\n                    force[dim_idx](cell->active_cell_index()) = -1e+20;\\n                    pml[dim_idx](cell->active_cell_index())   = -1e+20;\\n                  }\\n                rho(cell->active_cell_index()) = -1e+20;\\n              }\\n          }\\n \\n for (unsigned int dim_idx = 0; dim_idx < dim; ++dim_idx)\\n          {\\n            data_out.add_data_vector(force[dim_idx],\\n \\\"force_\\\" + std::to_string(dim_idx));\\n            data_out.add_data_vector(pml[dim_idx],\\n \\\"pml_\\\" + std::to_string(dim_idx));\\n          }\\n        data_out.add_data_vector(rho, \\\"rho\\\");\\n \\n        data_out.build_patches();\\n \\n        std::stringstream  frequency_idx_stream;\\n const unsigned int nb_number_positions =\\n          ((unsigned int)std::log10(parameters.nb_frequency_points)) + 1;\\n        frequency_idx_stream << std::setw(nb_number_positions)\\n                             << std::setfill('0') << frequency_idx;\\n const std::string filename = (parameters.simulation_name + \\\"_\\\" +\\n                                      frequency_idx_stream.str() + \\\".vtu\\\");\\n        data_out.write_vtu_in_parallel(filename, mpi_communicator);\\n      }\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void ElasticWave<dim>::output_results()\\n  {\\n if (Utilities::MPI::this_mpi_process(mpi_communicator) == 0)\\n      {\\n        frequency_dataset.write(frequency);\\n        probe_positions_dataset.write(probe_positions);\\n      }\\n else\\n      {\\n        frequency_dataset.write_none<double>();\\n        probe_positions_dataset.write_none<double>();\\n      }\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void ElasticWave<dim>::setup_quadrature_cache()\\n  {\\n triangulation.clear_user_data();\\n \\n    {\\n      std::vector<QuadratureCache<dim>> tmp;\\n      quadrature_cache.swap(tmp);\\n    }\\n \\n    quadrature_cache.resize(triangulation.n_locally_owned_active_cells() *\\n                              quadrature_formula.size(),\\n                            QuadratureCache<dim>(fe.n_dofs_per_cell()));\\n unsigned int cache_index = 0;\\n for (const auto &cell : triangulation.active_cell_iterators())\\n      if (cell->is_locally_owned())\\n        {\\n          cell->set_user_pointer(&quadrature_cache[cache_index]);\\n          cache_index += quadrature_formula.size();\\n        }\\n Assert(cache_index == quadrature_cache.size(), ExcInternalError());\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void ElasticWave<dim>::frequency_sweep()\\n  {\\n for (unsigned int frequency_idx = 0;\\n         frequency_idx < parameters.nb_frequency_points;\\n         ++frequency_idx)\\n      {\\n        pcout << parameters.simulation_name + \\\" frequency idx: \\\"\\n              << frequency_idx << '/' << parameters.nb_frequency_points - 1\\n              << std::endl;\\n \\n \\n \\n        setup_system();\\n if (frequency_idx == 0)\\n          {\\n            pcout << \\\"   Number of active cells :       \\\"\\n                  << triangulation.n_active_cells() << std::endl;\\n            pcout << \\\"   Number of degrees of freedom : \\\"\\n                  << dof_handler.n_dofs() << std::endl;\\n          }\\n \\n if (frequency_idx == 0)\\n          {\\n            parameters.data.set_attribute(\\\"active_cells\\\",\\n triangulation.n_active_cells());\\n            parameters.data.set_attribute(\\\"degrees_of_freedom\\\",\\n                                          dof_handler.n_dofs());\\n          }\\n \\n const double current_loop_frequency =\\n          (parameters.start_frequency +\\n           frequency_idx *\\n             (parameters.stop_frequency - parameters.start_frequency) /\\n             (parameters.nb_frequency_points - 1));\\n const double current_loop_omega =\\n          2 * numbers::PI * current_loop_frequency;\\n \\n        assemble_system(current_loop_omega,\\n                        (frequency_idx == 0) ? true : false);\\n        solve();\\n \\n        frequency[frequency_idx] = current_loop_frequency;\\n        store_frequency_step_data(frequency_idx);\\n \\n        computing_timer.print_summary();\\n        computing_timer.reset();\\n        pcout << std::endl;\\n      }\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void ElasticWave<dim>::run()\\n  {\\n#ifdef DEBUG\\n    pcout << \\\"Debug mode\\\" << std::endl;\\n#else\\n    pcout << \\\"Release mode\\\" << std::endl;\\n#endif\\n \\n    {\\n Point<dim> p1;\\n      p1(0) = -parameters.dimension_x / 2;\\n      p1(1) = -parameters.dimension_y / 2;\\n if (dim == 3)\\n        {\\n          p1(2) = -parameters.dimension_y / 2;\\n        }\\n Point<dim> p2;\\n      p2(0) = parameters.dimension_x / 2;\\n      p2(1) = parameters.dimension_y / 2;\\n if (dim == 3)\\n        {\\n          p2(2) = parameters.dimension_y / 2;\\n        }\\n      std::vector<unsigned int> divisions(dim);\\n      divisions[0] = int(parameters.dimension_x / parameters.dimension_y);\\n      divisions[1] = 1;\\n if (dim == 3)\\n        {\\n          divisions[2] = 1;\\n        }\\n GridGenerator::subdivided_hyper_rectangle(triangulation,\\n                                                divisions,\\n                                                p1,\\n                                                p2);\\n    }\\n \\n triangulation.refine_global(parameters.grid_level);\\n \\n    setup_quadrature_cache();\\n \\n    initialize_probe_positions_vector();\\n \\n    frequency_sweep();\\n \\n    output_results();\\n  }\\n} // namespace step62\\n \\n \\n \\n \\nint main(int argc, char *argv[])\\n{\\n try\\n    {\\n using namespace dealii;\\n const unsigned int dim = 2;\\n \\n Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);\\n \\n HDF5::File data_file(\\\"results.h5\\\",\\n HDF5::File::FileAccessMode::create,\\n                           MPI_COMM_WORLD);\\n auto       data = data_file.create_group(\\\"data\\\");\\n \\n const std::array<std::string, 2> group_names{\\n        {\\\"displacement\\\", \\\"calibration\\\"}};\\n for (const std::string &group_name : group_names)\\n        {\\n \\n auto group = data.create_group(group_name);\\n \\n group.set_attribute<double>(\\\"dimension_x\\\", 2e-5);\\n group.set_attribute<double>(\\\"dimension_y\\\", 2e-8);\\n group.set_attribute<double>(\\\"probe_pos_x\\\", 8e-6);\\n group.set_attribute<double>(\\\"probe_pos_y\\\", 0);\\n group.set_attribute<double>(\\\"probe_width_y\\\", 2e-08);\\n group.set_attribute<unsigned int>(\\\"nb_probe_points\\\", 5);\\n group.set_attribute<unsigned int>(\\\"grid_level\\\", 1);\\n group.set_attribute<double>(\\\"cavity_resonance_frequency\\\", 20e9);\\n group.set_attribute<unsigned int>(\\\"nb_mirror_pairs\\\", 15);\\n \\n group.set_attribute<double>(\\\"poissons_ratio\\\", 0.27);\\n group.set_attribute<double>(\\\"youngs_modulus\\\", 270000000000.0);\\n group.set_attribute<double>(\\\"material_a_rho\\\", 3200);\\n \\n if (group_name == \\\"displacement\\\")\\n group.set_attribute<double>(\\\"material_b_rho\\\", 2000);\\n else\\n group.set_attribute<double>(\\\"material_b_rho\\\", 3200);\\n \\n group.set_attribute(\\n \\\"lambda\\\",\\n group.get_attribute<double>(\\\"youngs_modulus\\\") *\\n group.get_attribute<double>(\\\"poissons_ratio\\\") /\\n              ((1 + group.get_attribute<double>(\\\"poissons_ratio\\\")) *\\n               (1 - 2 * group.get_attribute<double>(\\\"poissons_ratio\\\"))));\\n group.set_attribute(\\\"mu\\\",\\n group.get_attribute<double>(\\\"youngs_modulus\\\") /\\n                                (2 * (1 + group.get_attribute<double>(\\n \\\"poissons_ratio\\\"))));\\n \\n group.set_attribute<double>(\\\"max_force_amplitude\\\", 1e26);\\n group.set_attribute<double>(\\\"force_sigma_x\\\", 1e-7);\\n group.set_attribute<double>(\\\"force_sigma_y\\\", 1);\\n group.set_attribute<double>(\\\"max_force_width_x\\\", 3e-7);\\n group.set_attribute<double>(\\\"max_force_width_y\\\", 2e-8);\\n group.set_attribute<double>(\\\"force_x_pos\\\", -8e-6);\\n group.set_attribute<double>(\\\"force_y_pos\\\", 0);\\n \\n group.set_attribute<bool>(\\\"pml_x\\\", true);\\n group.set_attribute<bool>(\\\"pml_y\\\", false);\\n group.set_attribute<double>(\\\"pml_width_x\\\", 1.8e-6);\\n group.set_attribute<double>(\\\"pml_width_y\\\", 5e-7);\\n group.set_attribute<double>(\\\"pml_coeff\\\", 1.6);\\n group.set_attribute<unsigned int>(\\\"pml_coeff_degree\\\", 2);\\n \\n group.set_attribute<double>(\\\"center_frequency\\\", 20e9);\\n group.set_attribute<double>(\\\"frequency_range\\\", 0.5e9);\\n group.set_attribute<double>(\\n \\\"start_frequency\\\",\\n group.get_attribute<double>(\\\"center_frequency\\\") -\\n group.get_attribute<double>(\\\"frequency_range\\\") / 2);\\n group.set_attribute<double>(\\n \\\"stop_frequency\\\",\\n group.get_attribute<double>(\\\"center_frequency\\\") +\\n group.get_attribute<double>(\\\"frequency_range\\\") / 2);\\n group.set_attribute<unsigned int>(\\\"nb_frequency_points\\\", 400);\\n \\n if (group_name == std::string(\\\"displacement\\\"))\\n group.set_attribute<std::string>(\\n \\\"simulation_name\\\", std::string(\\\"phononic_cavity_displacement\\\"));\\n else\\n group.set_attribute<std::string>(\\n \\\"simulation_name\\\", std::string(\\\"phononic_cavity_calibration\\\"));\\n \\n group.set_attribute<bool>(\\\"save_vtu_files\\\", false);\\n        }\\n \\n      {\\n auto                    displacement = data.open_group(\\\"displacement\\\");\\n        step62::Parameters<dim> parameters(displacement);\\n \\n        step62::ElasticWave<dim> elastic_problem(parameters);\\n        elastic_problem.run();\\n      }\\n \\n      {\\n auto                    calibration = data.open_group(\\\"calibration\\\");\\n        step62::Parameters<dim> parameters(calibration);\\n \\n        step62::ElasticWave<dim> elastic_problem(parameters);\\n        elastic_problem.run();\\n      }\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n \\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n \\n return 0;\\n}\\naffine_constraints.h\\nDataOutInterface::write_vtu_in_parallelvoid write_vtu_in_parallel(const std::string &filename, const MPI_Comm comm) constDefinition data_out_base.cc:7715\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nHDF5::Group::open_groupGroup open_group(const std::string &name) constDefinition hdf5.cc:372\\nSolverControl::last_stepunsigned int last_step() constDefinition solver_control.cc:129\\nTimerOutput::wall_times@ wall_timesDefinition timer.h:651\\nTimerOutput::never@ neverDefinition timer.h:615\\nconditional_ostream.h\\ndof_handler.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nerror_estimator.h\\nfe_values.h\\nfe_q.h\\nfe_system.h\\nfull_matrix.h\\nfunction.h\\ngeneric_linear_algebra.h\\ngrid_refinement.h\\ngrid_generator.h\\ngrid_tools.h\\ngrid_tools_cache.h\\nhdf5.h\\nutilities.h\\nindex_set.h\\nDifferentiation::SD::OptimizerType::lambda@ lambda\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\nPhysics::Elasticity::Kinematics::eSymmetricTensor< 2, dim, Number > e(const Tensor< 2, dim, Number > &F)\\nPhysics::Elasticity::Kinematics::lTensor< 2, dim, Number > l(const Tensor< 2, dim, Number > &F, const Tensor< 2, dim, Number > &dF_dt)\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\ninternal::VectorizationTypes::group@ group\\ninternal::EvaluatorQuantity::value@ value\\ndata_out.h\\npetsc_solver.h\\nquadrature_lib.h\\ntensor.h\\ntimer.h\\nvector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"