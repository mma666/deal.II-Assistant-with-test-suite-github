"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_70.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-70 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-70 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-70 tutorial program\\n\\n\\nThis tutorial depends on step-19, step-60.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nMassively parallel non-matching grid simulations of fluid structure interaction problems\\n\\nCo-dimension one case\\nCo-dimension zero case\\nRepresentation of \\u03a9 and \\u0393\\nUsing particles to track \\u0393\\n\\nThe testcase\\n More references\\n\\n The commented program\\n\\nInclude files\\nRun-time parameter handling\\nThe StokesImmersedProblem class declaration\\nThe StokesImmersedProblem class implementation\\n\\nObject construction and mesh initialization functions\\nParticle initialization functions\\nDoF initialization functions\\nAssembly functions\\nSolving the linear system\\nMesh refinement\\nCreating output for visualization\\nThe \\\"run\\\" function\\n\\nThe main() function\\n\\n\\n Results\\n\\n Two dimensional test case \\n Three dimensional test case \\nPossibilities for extensions\\n\\n The plain program\\n   \\n\\n\\nThis program was contributed by Luca Heltai (International School for Advanced Studies, Trieste), Bruno Blais (Polytechnique Montr\\u00e9al), and Rene Gassm\\u00f6ller (University of California Davis) \\nNoteIf you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation:   \\nIntroduction\\nMassively parallel non-matching grid simulations of fluid structure interaction problems\\nIn this tutorial we consider a mixing problem in the laminar flow regime. Such problems occur in a wide range of applications ranging from chemical engineering to power generation (e.g. turbomachinery). Mixing problems are particularly hard to solve numerically, because they often involve a container (with fixed boundaries, and possibly complex geometries such as baffles), represented by the domain \\\\(\\\\Omega\\\\), and one (or more) immersed and rotating impellers (represented by the domain \\\\(\\\\Omega^{\\\\text{imp}}\\\\)). The domain in which we would like to solve the flow equations is the (time dependent) difference between the two domains, namely: \\\\(\\\\Omega\\\\setminus\\\\Omega^{\\\\text{imp}}\\\\).\\nFor rotating impellers, the use of Arbitrary Lagrangian Eulerian formulations (in which the fluid domain \\u2013 along with the mesh! \\u2013 is smoothly deformed to follow the deformations of the immersed solid) is not possible, unless only small times (i.e., small fluid domain deformations) are considered. If one wants to track the evolution of the flow across multiple rotations of the impellers, the resulting deformed grid would simply be too distorted to be useful.\\nIn this case, a viable alternative strategy would be to use non-matching methods (similarly to what we have done in step-60), where a background fixed grid (that may or may not be locally refined in time to better capture the solid motion) is coupled with a rotating, independent, grid.\\nIn order to maintain the same notations used in step-60, we use \\\\(\\\\Omega\\\\) to denote the domain in \\\\({\\\\mathbb R}^{\\\\text{spacedim}}\\\\) representing the container of both the fluid and the impeller, and we use \\\\(\\\\Gamma\\\\) in \\\\({\\\\mathbb R}^{\\\\text{dim}}\\\\) to denote either the full impeller (when its spacedim measure is non-negligible, i.e., when we can represent it as a grid of dimension dim equal to spacedim), a co-dimension one representation of a thin impeller, or just the boundary of the full impeller.\\nThe domain \\\\(\\\\Gamma\\\\) is embedded in \\\\(\\\\Omega\\\\) ( \\\\(\\\\Gamma \\\\subseteq \\\\Omega\\\\)) and it is non-matching: It does not, in general, align with any of the features of the volume mesh. We solve a partial differential equation on \\\\(\\\\Omega\\\\), enforcing some conditions on the solution of the problem on the embedded domain \\\\(\\\\Gamma\\\\) by some penalization techniques. In the current case, the condition is that the velocity of the fluid at points on \\\\(\\\\Gamma\\\\) equal the velocity of the solid impeller at that point.\\nThe technique we describe here is presented in the literature using one of many names: the immersed finite element method and the fictitious boundary method among others. The main principle is that the discretization of the two grids are kept completely independent. In the present tutorial, this approach is used to solve for the motion of a viscous fluid, described by the Stokes equation, that is agitated by a rigid non-deformable impeller.\\nThus, the equations solved in \\\\(\\\\Omega\\\\) are the Stokes equations for a creeping flow (i.e. a flow where \\\\(\\\\text{Re}\\\\rightarrow 0\\\\)) and a no-slip boundary condition is applied on the moving embedded domain \\\\(\\\\Gamma\\\\) associated with the impeller. However, this tutorial could be readily extended to other equations (e.g. the Navier-Stokes equations, linear elasticity equation, etc.). It can be seen as a natural extension of step-60 that enables the solution of large problems using a distributed parallel computing architecture via MPI.\\nHowever, contrary to step-60, the Dirichlet boundary conditions on \\\\(\\\\Gamma\\\\) are imposed weakly instead of through the use of Lagrange multipliers, and we concentrate on dealing with the coupling of two fully distributed triangulations (a combination that was not possible in the implementation of step-60).\\nThere are two interesting scenarios that occur when one wants to enforce conditions on the embedded domain \\\\(\\\\Gamma\\\\):\\n\\nThe geometrical dimension dim of the embedded domain \\\\(\\\\Gamma\\\\) is the same of the domain \\\\(\\\\Omega\\\\) (spacedim), that is, the spacedim-dimensional measure of \\\\(\\\\Gamma\\\\) is not zero. In this case, the imposition of the Dirichlet boundary boundary condition on \\\\(\\\\Gamma\\\\) is done through a volumetric penalization. If the applied penalization only depends on the velocity, this is often referred to as \\\\(\\\\mathcal{L}^2\\\\) penalization whereas if the penalization depends on both the velocity and its gradient, it is an \\\\(\\\\mathcal{H}^1\\\\) penalization. The case of the \\\\(\\\\mathcal{L}^2\\\\) penalization is very similar to a Darcy-type approach. Both \\\\(\\\\mathcal{L}^2\\\\) and \\\\(\\\\mathcal{H}^1\\\\) penalizations have been analyzed extensively (see, for example, [4]).\\nThe embedded domain \\\\(\\\\Gamma\\\\) has an intrinsic dimension dim which is smaller than that of \\\\(\\\\Omega\\\\) (spacedim), thus its spacedim-dimensional measure is zero; for example it is a curve embedded in a two dimensional domain, or a surface embedded in a three-dimensional domain. This is of course physically impossible, but one may consider very thin sheets of metal moving in a fluid as essentially lower-dimensional if the thickness of the sheet is negligible. In this case, the boundary condition is imposed weakly on \\\\(\\\\Gamma\\\\) by applying the Nitsche method (see [90]).\\n\\nBoth approaches have very similar requirements and result in highly similar formulations. Thus, we treat them almost in the same way.\\nIn this tutorial program we are not interested in further details on \\\\(\\\\Gamma\\\\): we assume that the dimension of the embedded domain (dim) is always smaller by one or equal with respect to the dimension of the embedding domain \\\\(\\\\Omega\\\\) (spacedim).\\nWe are going to solve the following differential problem: given a sufficiently regular function \\\\(g\\\\) on \\\\(\\\\Gamma\\\\), find the solution \\\\((\\\\textbf{u},p)\\\\) to\\n\\n\\\\begin{eqnarray*}\\n  -\\\\Delta \\\\mathbf{u} + \\\\nabla p &=& 0,\\\\\\\\\\n  -\\\\nabla \\\\cdot \\\\textbf{u} &=& 0,\\\\\\\\\\n  \\\\textbf{u} &=& \\\\textbf{g}  \\\\text{ in } \\\\Gamma,\\\\\\\\\\n  \\\\textbf{u} &=& 0 \\\\text{ on } \\\\partial\\\\Omega.\\n\\\\end{eqnarray*}\\n\\nThis equation, which we have normalized by scaling the time units in such a way that the viscosity has a numerical value of 1, describes slow, viscous flow such as honey or lava. The main goal of this tutorial is to show how to impose the velocity field condition \\\\(\\\\mathbf{u} = \\\\mathbf{g}\\\\) on a non-matching \\\\(\\\\Gamma\\\\) in a weak way, using a penalization method. A more extensive discussion of the Stokes problem including body forces, different boundary conditions, and solution strategies can be found in step-22.\\nLet us start by considering the Stokes problem alone, in the entire domain \\\\(\\\\Omega\\\\). We look for a velocity field \\\\(\\\\mathbf{u}\\\\) and a pressure field \\\\(p\\\\) that satisfy the Stokes equations with homogeneous boundary conditions on \\\\(\\\\partial\\\\Omega\\\\).\\nThe weak form of the Stokes equations is obtained by first writing it in vector form as             \\n\\\\begin{eqnarray*}\\n  \\\\begin{pmatrix}\\n    {-\\\\Delta \\\\textbf{u} + \\\\nabla p}\\n    \\\\\\\\\\n    {-\\\\textrm{div}\\\\;\\\\textbf{u}}\\n  \\\\end{pmatrix}\\n  =\\n  \\\\begin{pmatrix}\\n  0\\n  \\\\\\\\\\n  0\\n  \\\\end{pmatrix},\\n\\\\end{eqnarray*}\\n\\n forming the dot product from the left with a vector-valued test function \\\\(\\\\phi = \\\\begin{pmatrix}\\\\textbf{v} \\\\\\\\ q\\\\end{pmatrix}\\\\), and integrating over the domain \\\\(\\\\Omega\\\\), yielding the following set of equations:        \\n\\\\begin{eqnarray*}\\n  (\\\\mathrm v,\\n   -\\\\Delta \\\\textbf{u} + \\\\nabla p)_{\\\\Omega}\\n  -\\n  (q,\\\\textrm{div}\\\\; \\\\textbf{u})_{\\\\Omega}\\n  =\\n  0\\n\\\\end{eqnarray*}\\n\\n which has to hold for all test functions  \\\\(\\\\phi = \\\\begin{pmatrix}\\\\textbf{v}\\n\\\\\\\\ q\\\\end{pmatrix}\\\\).\\nIntegrating by parts and exploiting the boundary conditions on \\\\(\\\\partial\\\\Omega\\\\), we obtain the following variational problem:    \\n\\\\begin{eqnarray*}\\n(\\\\nabla \\\\textbf{v}, \\\\nabla \\\\textbf{u})_{\\\\Omega} - (\\\\textrm{div}\\\\; \\\\textbf{v}, p)_{\\\\Omega}\\n - (q, \\\\textrm{div}\\\\; \\\\textbf{u})_{\\\\Omega}&=& 0\\n\\\\end{eqnarray*}\\n\\nwhere \\\\((\\\\cdot, \\\\cdot)_{\\\\Omega}\\\\) represents the \\\\(L^2\\\\) scalar product. This is the same variational form used in step-22.\\nThis variational formulation does not take into account the embedded domain. Contrary to step-60, we do not enforce strongly the constraints of \\\\(\\\\textbf{u}\\\\) on \\\\(\\\\Gamma\\\\), but enforce them weakly via a penalization term.\\nThe analysis of this weak imposition of the boundary condition depends on the spacedim-dimensional measure of \\\\(\\\\Gamma\\\\) as either positive (if dim is equal to spacedim) or zero (if dim is smaller than spacedim). We discuss both scenarios.\\nCo-dimension one case\\nIn this case, we assume that \\\\(\\\\Gamma\\\\) is the boundary of the actual impeller, that is, a closed curve embedded in a two-dimensional domain or a closed surface in a three-dimensional domain. The idea of this method starts by considering a weak imposition of the Dirichlet boundary condition on \\\\(\\\\Gamma\\\\), following the Nitsche method. This is achieved by using the following modified formulation on the fluid domain, where no strong conditions on the test functions on \\\\(\\\\Gamma\\\\) are imposed:\\n\\n\\\\begin{multline*}\\n(\\\\nabla \\\\textbf{v}, \\\\nabla \\\\textbf{u})_{\\\\Omega\\\\setminus\\\\Omega^{\\\\text{imp}}} - (\\\\textrm{div}\\\\;  \\\\textbf{v}, p)_{\\\\Omega\\\\setminus\\\\Omega^{\\\\text{imp}}}\\n  - (q, \\\\textrm{div}\\\\; \\\\textbf{u})_{\\\\Omega\\\\setminus\\\\Omega^{\\\\text{imp}}} \\\\\\\\\\n  - (\\\\textbf{v},\\\\nabla \\\\textbf{u} \\\\cdot \\\\textbf{n})_{\\\\Gamma}\\n  + (\\\\textbf{v}\\\\cdot \\\\textbf{n},p)_{\\\\Gamma} \\\\\\\\\\n -  (\\\\nabla\\\\textbf{v}\\\\cdot \\\\textbf{n},\\\\textbf{u})_{\\\\Gamma}\\n + (q, \\\\textbf{u} \\\\cdot \\\\textbf{n})_{\\\\Gamma}\\n + \\\\beta (\\\\textbf{v},\\\\textbf{u})_{\\\\Gamma} \\\\\\\\\\n=  - (\\\\nabla\\\\textbf{v}\\\\cdot \\\\textbf{n},\\\\textbf{g})_{\\\\Gamma} + (q, \\\\textbf{g} \\\\cdot \\\\textbf{n})_{\\\\Gamma}\\n + \\\\beta (\\\\textbf{v},\\\\textbf{g})_{\\\\Gamma}.\\n\\\\end{multline*}\\n\\nThe integrals over \\\\(\\\\Gamma\\\\) are lower-dimensional integrals. It can be shown (see [90]) that there exists a positive constant \\\\(C_1\\\\) so that if \\\\(\\\\beta > C_1\\\\), the weak imposition of the boundary will be consistent and stable. The first two additional integrals on \\\\(\\\\Gamma\\\\) (the second line in the equation above) appear naturally after integrating by parts, when one does not assume that \\\\(\\\\mathbf{v}\\\\) is zero on \\\\(\\\\Gamma\\\\).\\nThe third line in the equation above contains two terms that are added to ensure consistency of the weak form, and a stabilization term, that is there to enforce the boundary condition with an error which is consistent with the approximation error. The consistency terms and the stabilization term are added to the right hand side with the actual boundary data \\\\(\\\\mathbf{g}\\\\).\\nWhen \\\\(\\\\mathbf{u}\\\\) satisfies the condition \\\\(\\\\mathbf{u}=\\\\mathbf{g}\\\\) on \\\\(\\\\Gamma\\\\), all the consistency and stability integrals on \\\\(\\\\Gamma\\\\) cancel out, and one is left with the usual weak form of Stokes flow, that is, the above formulation is consistent.\\nWe note that an alternative (non-symmetric) formulation can be used :\\n\\n\\\\begin{multline*}\\n(\\\\nabla \\\\textbf{v}, \\\\nabla \\\\textbf{u})_{\\\\Omega\\\\setminus\\\\Omega^{\\\\text{imp}}} -  (\\\\textrm{div}\\\\;  \\\\textbf{v}, p)_{\\\\Omega\\\\setminus\\\\Omega^{\\\\text{imp}}}\\n  - (q, \\\\textrm{div}\\\\; \\\\textbf{u})_{\\\\Omega\\\\setminus\\\\Omega^{\\\\text{imp}}} \\\\\\\\\\n  -(\\\\textbf{v},\\\\nabla \\\\textbf{u} \\\\cdot \\\\textbf{n})_{\\\\Gamma}\\n  + (\\\\textbf{v}\\\\cdot \\\\textbf{n},p)_{\\\\Gamma} \\\\\\\\\\n   +(\\\\nabla\\\\textbf{v}\\\\cdot \\\\textbf{n},\\\\textbf{u})_{\\\\Gamma}\\n - (q, \\\\textbf{u} \\\\cdot \\\\textbf{n})_{\\\\Gamma}\\n + \\\\beta (\\\\textbf{v},\\\\textbf{u})_{\\\\Gamma} \\\\\\\\\\n=   (\\\\nabla\\\\textbf{v}\\\\cdot \\\\textbf{n},\\\\textbf{g})_{\\\\Gamma} - (q, \\\\textbf{g} \\\\cdot \\\\textbf{n})_{\\\\Gamma}\\n + \\\\beta (\\\\textbf{v},\\\\textbf{g})_{\\\\Gamma}.\\n\\\\end{multline*}\\n\\n Note the different sign of the first terms on the third and fourth lines. In this case, the stability and consistency conditions become \\\\(\\\\beta > 0\\\\). In the symmetric case, the value of \\\\(\\\\beta\\\\) is dependent on \\\\(h\\\\), and it is in general chosen such that \\\\(\\\\beta = C h^{-1} \\\\) with \\\\(h\\\\) a measure of size of the face being integrated and \\\\(C\\\\) a constant such that \\\\(1 \\\\leq C \\\\leq 10\\\\). This is as one usually does with the Nitsche penalty method to enforcing Dirichlet boundary conditions.\\nThe non-symmetric approach, on the other hand, is related to how one enforced continuity for the non-symmetric interior penalty method for discontinuous Galerkin methods (the \\\"NIPG\\\" method [185]). Even if the non-symmetric case seems advantageous w.r.t. possible choices of stabilization parameters, we opt for the symmetric discretization, since in this case it can be shown that the dual problem is also consistent, leading to a solution where not only the energy norm of the solution converges with the correct order, but also its \\\\(L^2\\\\) norm. Furthermore, the resulting matrix remains symmetric.\\nThe above formulation works under the assumption that the domain is discretized exactly. However, if the deformation of the impeller is a rigid body motion, it is possible to artificially extend the solution of the Stokes problem inside the propeller itself, since a rigid body motion is also a solution to the Stokes problem. The idea is then to solve the same problem, inside \\\\(\\\\Omega^{\\\\text{imp}}\\\\), imposing the same boundary conditions on \\\\(\\\\Gamma\\\\), using the same penalization technique, and testing with test functions \\\\(\\\\mathbf{v}\\\\) which are globally continuous over \\\\(\\\\Omega\\\\).\\nThis results in the following (intermediate) formulation:           \\n\\\\begin{multline*}\\n(\\\\nabla \\\\textbf{v}, \\\\nabla \\\\textbf{u})_{\\\\Omega} - (\\\\textrm{div}\\\\;  \\\\textbf{v}, p)_{\\\\Omega}\\n  - (q, \\\\textrm{div}\\\\; \\\\textbf{u})_{\\\\Omega} \\\\\\\\\\n  - (\\\\textbf{v},  \\\\lbrack \\\\nabla \\\\textbf{u} \\\\rbrack \\\\cdot \\\\textbf{n})_{\\\\Gamma}\\n  + (\\\\textbf{v}\\\\cdot \\\\textbf{n},\\\\lbrack p \\\\rbrack )_{\\\\Gamma} \\\\\\\\\\n -  (\\\\lbrack \\\\nabla\\\\textbf{v} \\\\rbrack \\\\cdot \\\\textbf{n},\\\\textbf{u})_{\\\\Gamma}\\n + (\\\\lbrack q \\\\rbrack, \\\\textbf{u} \\\\cdot n)_{\\\\Gamma}\\n + 2\\\\beta (\\\\textbf{v},\\\\textbf{u})_{\\\\Gamma} \\\\\\\\\\n=  - (\\\\lbrack \\\\nabla\\\\textbf{v}\\\\rbrack\\\\cdot \\\\textbf{n},\\\\textbf{g})_{\\\\Gamma} + (\\\\lbrack q\\\\rbrack, \\\\textbf{g} \\\\cdot n)_{\\\\Gamma}\\n + 2\\\\beta (\\\\textbf{v},\\\\textbf{g})_{\\\\Gamma},\\n\\\\end{multline*}\\n\\n where the jump terms, denoted with \\\\(\\\\lbrack \\\\cdot \\\\rbrack\\\\), are computed with respect to a fixed orientation of the normal vector \\\\(\\\\textbf{n}\\\\). The factor of 2 appears in front of \\\\(\\\\beta\\\\) since we see every part of \\\\(\\\\Gamma\\\\) twice, once from within the fluid and once from within the obstacle moving around in it. (For all of the other integrals over \\\\(\\\\Gamma\\\\), we visit each part of \\\\(\\\\Gamma\\\\) twice, but with opposite signs, and consequently get the jump terms.)\\nHere we notice that, unlike in discontinuous Galerkin methods, the test and trial functions are continuous across \\\\(\\\\Gamma\\\\). Moreover, if \\\\(\\\\Gamma\\\\) is not aligned with cell boundaries, all the jump terms are also zero, since, in general, finite element function spaces are smooth inside each cell, and if \\\\(\\\\Gamma\\\\) cuts through an element intersecting its boundary only at a finite number of points, all the contributions on \\\\(\\\\Gamma\\\\), with the exception of the stabilization ones, can be neglected from the formulation, resulting in the following final form of the variational formulation:\\n\\n\\\\begin{multline*}\\n(\\\\nabla \\\\textbf{v}, \\\\nabla \\\\textbf{u})_{\\\\Omega} - (\\\\textrm{div}\\\\;  \\\\textbf{v}, p)_{\\\\Omega}\\n  - (q, \\\\textrm{div}\\\\; \\\\textbf{u})_{\\\\Omega}  + 2\\\\beta (\\\\textbf{v},\\\\textbf{u})_{\\\\Gamma} \\\\\\\\\\n=  2\\\\beta (\\\\textbf{v},\\\\textbf{g})_{\\\\Gamma}.\\n\\\\end{multline*}\\n\\nIn step-60, the imposition of the constraint required the addition of new variables in the form of Lagrange multipliers. This is not the case for this tutorial program. The imposition of the boundary condition using Nitsche's method only modifies the system matrix and the right-hand side without adding additional unknowns. However, the velocity vector \\\\(\\\\textbf{u}\\\\) on the embedded domain will not match exactly the prescribed velocity \\\\(\\\\textbf{g}\\\\), but only up to a numerical error which is in the same order as the interpolation error of the finite element method. Furthermore, as in step-60, we still need to integrate over the non-matching embedded grid in order to construct the boundary term necessary to impose the boundary condition over \\\\(\\\\Gamma\\\\).\\nCo-dimension zero case\\nIn this case, \\\\(\\\\Gamma\\\\) has the same dimension, but is embedded into \\\\(\\\\Omega\\\\). We can think of this as a thick object moving around in the fluid. In the case of \\\\(\\\\mathcal{L}^2\\\\) penalization, the additional penalization term can be interpreted as a Darcy term within \\\\(\\\\Gamma\\\\), resulting in:\\n\\n\\\\begin{eqnarray*}\\n(\\\\nabla \\\\textbf{v}, \\\\nabla \\\\textbf{u})_{\\\\Omega} - & (\\\\textrm{div}\\\\;  \\\\textbf{v}, p)_{\\\\Omega}\\n  - (q, \\\\textrm{div}\\\\; \\\\textbf{u})_{\\\\Omega}  + \\\\beta (\\\\textbf{v},\\\\textbf{u})_{\\\\Gamma}\\n=  \\\\beta (\\\\textbf{v},\\\\textbf{g})_{\\\\Gamma}.\\n\\\\end{eqnarray*}\\n\\nHere, integrals over \\\\(\\\\Gamma\\\\) are simply integrals over a part of the volume. The \\\\(\\\\mathcal{L}^2\\\\) penalization thus consists in adding a volumetric term that constrains the velocity of the fluid to adhere to the velocity of the rigid body within \\\\(\\\\Gamma\\\\). Also in this case, \\\\(\\\\beta\\\\) must be chosen sufficiently large in order to ensure that the Dirichlet boundary condition in \\\\(\\\\Gamma\\\\) is sufficiently respected, but not too high in order to maintain the proper conditioning of the system matrix.\\nA \\\\(\\\\mathcal{H}^1\\\\) penalization may be constructed in a similar manner, with the addition of a viscous component to the penalization that dampens the velocity gradient within \\\\(\\\\Gamma\\\\):\\n\\n\\\\begin{eqnarray*}\\n(\\\\nabla \\\\textbf{v}, \\\\nabla \\\\textbf{u})_{\\\\Omega} - & (\\\\textrm{div}\\\\;  \\\\textbf{v}, p)_{\\\\Omega}\\n  - (q, \\\\textrm{div}\\\\; \\\\textbf{u})_{\\\\Omega}\\n  + \\\\beta_1 (\\\\textbf{v},\\\\textbf{u})_{\\\\Gamma}\\n  + \\\\beta_2 (\\\\nabla \\\\textbf{v}, \\\\nabla \\\\textbf{u})_{\\\\Gamma}\\n=  \\\\beta_1 (\\\\textbf{v},\\\\textbf{g})_{\\\\Gamma}\\n+ \\\\beta_2 (\\\\nabla \\\\textbf{v}, \\\\nabla \\\\textbf{g})_{\\\\Gamma}.\\n\\\\end{eqnarray*}\\n\\nNotice that the \\\\(L^2\\\\) penalization (dim equal to spacedim) and the Nitsche penalization (dim equal to spacedim-1) result in the exact same numerical implementation, thanks to the dimension independent capabilities of deal.II.\\nRepresentation of \\u03a9 and \\u0393\\nIn this tutorial, both the embedded grid \\\\(\\\\Gamma\\\\) and the embedding grid are described using a parallel::distributed::Triangulation. These two triangulations can be built from functions in the GridGenerator namespace or by reading a mesh file produced with another application (e.g. GMSH, see the discussion in step-49). This is slightly more general than what was previously done in step-60.\\nThe addition of the immersed boundary method, whether it is in the dim=spacedim or dim<spacedim case, only introduces additional terms in the system matrix and the right-hand side of the system which result from the integration over \\\\(\\\\Gamma\\\\). This does not modify the number of variables for which the problem must be solved. The challenge is thus related to the integrals that must be carried over \\\\(\\\\Gamma\\\\).\\nAs usual in finite elements we split this integral into contributions from all cells of the triangulation used to discretize \\\\(\\\\Gamma\\\\), we transform the integral on \\\\(K\\\\) to an integral on the reference element \\\\(\\\\hat K\\\\), where \\\\(F_{K}\\\\) is the mapping from \\\\(\\\\hat K\\\\) to \\\\(K\\\\), and compute the integral on \\\\(\\\\hat K\\\\) using a quadrature formula. For example:\\n\\n\\\\[\\n\\\\beta (\\\\textbf{v},\\\\textbf{u})_{\\\\Gamma} =  \\\\sum_{K\\\\in \\\\Gamma} \\\\int_{\\\\hat K}\\n\\\\hat{\\\\textbf{u}}(\\\\hat x) (\\\\textbf{v} \\\\circ F_{K}) (\\\\hat x) J_K (\\\\hat x) \\\\mathrm{d} \\\\hat x =\\n\\\\sum_{K\\\\in \\\\Gamma} \\\\sum_{i=1}^{n_q}  \\\\big(\\\\hat{\\\\textbf{u}}(\\\\hat x_i)  (\\\\textbf{v} \\\\circ F_{K}) (\\\\hat x_i) J_K (\\\\hat x_i) w_i \\\\big)\\n\\\\]\\n\\nComputing this sum is non-trivial because we have to evaluate  \\\\((v_j \\\\circ F_{K})\\n(\\\\hat x_i)\\\\). In general, if \\\\(\\\\Gamma\\\\) and \\\\(\\\\Omega\\\\) are not aligned, the point \\\\(y_i = F_{K}(\\\\hat x_i)\\\\) is completely arbitrary with respect to \\\\(\\\\Omega\\\\), and unless we figure out a way to interpolate all basis functions of \\\\(V_h(\\\\Omega)\\\\) on an arbitrary point on \\\\(\\\\Omega\\\\), we cannot compute the integral needed.\\nTo evaluate \\\\((v_j \\\\circ F_{K}) (\\\\hat x_i)\\\\) the following steps needs to be taken (as shown in the picture below):\\n\\nFor a given cell \\\\(K\\\\) in \\\\(\\\\Gamma\\\\) compute the real point  \\\\(y_i \\\\dealcoloneq F_{K} (\\\\hat\\nx_i)\\\\), where \\\\(x_i\\\\) is one of the quadrature points used for the integral on  \\\\(K\\n\\\\subseteq \\\\Gamma\\\\). This is the easy part: FEValues::quadrature_point() gives us the real-space locations of all quadrature points.\\nFind the cell of \\\\(\\\\Omega\\\\) in which \\\\(y_i\\\\) lies. We shall call this element \\\\(T\\\\).\\nFind the reference coordinates within \\\\(T\\\\) of \\\\(y_i\\\\). For this, we need the inverse of the mapping \\\\(G_T\\\\) that transforms the reference element \\\\(\\\\hat T\\\\) into the element \\\\(T\\\\): \\\\(\\\\hat y_i = G^{-1}_{T} (y_i)\\\\).\\nEvaluate the basis function \\\\(v_j\\\\) of the \\\\(\\\\Omega\\\\) mesh at this point \\\\(\\\\hat y_i\\\\). This is, again, relatively simple using FEValues.\\n\\n\\n \\nIn step-60, the second through fourth steps above were computed by calling, in turn,\\n\\nGridTools::find_active_cell_around_point(), followed by\\nMapping::transform_real_to_unit_cell(). We then\\nconstruct a custom Quadrature formula, containing the point in the reference cell and then\\nconstruct an FEValues object, with the given quadrature formula, and initialized with the cell obtained in the first step.\\n\\nAlthough this approach could work for the present case, it does not lend itself readily to parallel simulations using distributed triangulations. Indeed, since the position of the quadrature points on the cells of the embedded domain \\\\(\\\\Gamma\\\\) do not match that of the embedding triangulation and since \\\\(\\\\Gamma\\\\) is constantly moving, this would require that the triangulation representing \\\\(\\\\Gamma\\\\) be stored in its entirety for all of the processors. As the number of processor and the number of cells in \\\\(\\\\Gamma\\\\) increases, this leads to a severe bottleneck in terms of memory. Consequently, an alternative strategy is sought in this step.\\nUsing particles to track \\u0393\\nRemember that for both the penalization approach ( \\\\(\\\\mathcal{L}^2\\\\) or \\\\(\\\\mathcal{H}^1\\\\)) and the Nitsche method, we want to compute integrals that are approximated by the quadrature. That is, we need to compute    \\n\\\\[\\n\\\\beta (\\\\textbf{v},\\\\textbf{u})_{\\\\Gamma} =\\n\\\\sum_{K\\\\in \\\\Gamma} \\\\sum_{i=1}^{n_q}  \\\\big(\\\\hat{\\\\textbf{u}}(\\\\hat x_i)  (\\\\textbf{v} \\\\circ F_{K}) (\\\\hat x_i) J_K (\\\\hat x_i) w_i \\\\big)\\n\\\\]\\n\\n If you followed the discussion above, then you will recall that \\\\(\\\\textbf{u}\\\\) and \\\\(\\\\textbf{v}\\\\) are shape functions defined on the fluid mesh. The only things defined on the solid mesh are: \\\\(F_K(\\\\hat x_i)\\\\), which is the location of a quadrature point on a solid cell that is part of \\\\(\\\\Gamma\\\\), \\\\(J_K\\\\) is the determinant of its Jacobian, and \\\\(w_i\\\\) the corresponding quadrature weight.\\nThe important part to realize is now this: \\\\(w_i\\\\) is a property of the quadrature formula and does not change with time. Furthermore, the Jacobian matrix of \\\\(F_K\\\\) itself changes as the solid obstacle moves around in the fluid, but because the solid is considered non-deforming (it only translates and rotates, but doesn't dilate), the determinant of the Jacobian remains constant. As a consequence, the product \\\\(J_K(\\\\hat x_i) w_i\\\\) (which we typically denote by JxW) remains constant for each quadrature point. So the only thing we need keep track of are the positions \\\\(x_i=F_K(\\\\hat x_i)\\\\) \\u2013 but these move with the velocity of the solid domain.\\nIn other words, we don't actually need to keep the solid mesh at all. All we need is the positions \\\\(x_i(t)\\\\) and corresponding JxW values. Since both of these properties are point-properties (or point-vectors) that are attached to the solid material, they can be idealized as a set of disconnected infinitesimally small \\\"particles\\\", which carry the required JxW information with the movement of the solid. deal.II has the ability to distribute and store such a set of particles in large-scale parallel computations in the form of the ParticleHandler class (for details on the implementation see [93]), and we will make use of this functionality in this tutorial.\\nThus, the approach taken in this step is as follows:\\nCreate a parallel::distributed::Triangulation for the domain \\\\(\\\\Gamma\\\\);\\nCreate Particles::Particle at the positions of the quadrature points on \\\\(\\\\Gamma\\\\);\\nCall the Particles::ParticleHandler::insert_global_particles() function, to distribute the particles across processors, following the solid triangulation;\\nAttach the JxW values as a \\\"property\\\" to each Particles::Particle object.\\n\\nThis structure is relatively expensive to generate, but must only be generated once per simulation. Once the Particles::ParticleHandler is generated and the required information is attached to the particle, the integrals over \\\\(\\\\Gamma\\\\) can be carried out by exploiting the fact that particles are grouped cellwise inside ParticleHandler, allowing us to:\\nLooping over all cells of \\\\(\\\\Omega\\\\) that contain at least one particle\\nLooping over all particles in the given cell\\nCompute the integrals and fill the global matrix.\\n\\nSince the Particles::ParticleHandler can manage the exchange of particles from one processor to the other, the embedded triangulation can be moved or deformed by displacing the particles. The only constraint associated with this displacement is that particles should be displaced by a distance that is no larger than the size of one cell. That's because that is the limit to which Particles::ParticleHandler can track which cell a particle that leaves its current cell now resides in.\\nOnce the entire problem (the Stokes problem and the immersed boundary imposition) is assembled, the final saddle point problem is solved by an iterative solver, applied to the Schur complement \\\\(S\\\\) (whose construction is described, for example, in step-22), and we construct \\\\(S\\\\) using LinearOperator classes.\\nThe testcase\\nThe problem we solve here is a demonstration of the time-reversibility of Stokes flow. This is often illustrated in science education experiments with a Taylor-Couette flow and dye droplets that revert back to their original shape after the fluid has been displaced in a periodic manner.\\n\\n\\n\\nIn the present problem, a very viscous fluid is agitated by the rotation of an impeller, which, in 2D, is modeled by a rectangular grid. The impeller rotates for a given number of revolutions, after which the flow is reversed such that the same number of revolutions is carried out in the opposite direction. We recall that since the Stokes equations are self-adjoint, creeping flows are reversible. Consequently, if the impeller motion is reversed in the opposite direction, the fluid should return to its original position. In the present case, this is illustrated by inserting a circle of passive tracer particles that are advected by the fluid and which return to their original position, thus demonstrating the time-reversibility of the flow.\\nMore references\\nThis tutorial program uses a number of techniques on imposing velocity conditions on non-matching interfaces in the interior of the fluid. For more background material, you may want to look up the following references: [90], [4], [98], [34], [115].\\n The commented program\\n Include files\\nMost of these have been introduced elsewhere, we'll comment only on the new ones. The switches close to the top that allow selecting between PETSc and Trilinos linear algebra capabilities are similar to the ones in step-40 and step-50.\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/timer.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/block_linear_operator.h>\\n\\u00a0 #include <deal.II/lac/generic_linear_algebra.h>\\n\\u00a0 #include <deal.II/lac/linear_operator.h>\\n\\u00a0 #include <deal.II/lac/linear_operator_tools.h>\\n\\u00a0 \\n\\u00a0 #define FORCE_USE_OF_TRILINOS\\n\\u00a0 \\n\\u00a0 namespace LA\\n\\u00a0 {\\n\\u00a0 #if defined(DEAL_II_WITH_PETSC) && !defined(DEAL_II_PETSC_WITH_COMPLEX) && \\\\\\n\\u00a0   !(defined(DEAL_II_WITH_TRILINOS) && defined(FORCE_USE_OF_TRILINOS))\\n\\u00a0   using namespace dealii::LinearAlgebraPETSc;\\n\\u00a0 #  define USE_PETSC_LA\\n\\u00a0 #elif defined(DEAL_II_WITH_TRILINOS)\\n\\u00a0   using namespace dealii::LinearAlgebraTrilinos;\\n\\u00a0 #else\\n\\u00a0 #  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required\\n\\u00a0 #endif\\n\\u00a0 } // namespace LA\\n\\u00a0 \\n\\u00a0 #include <deal.II/base/conditional_ostream.h>\\n\\u00a0 #include <deal.II/base/index_set.h>\\n\\u00a0 #include <deal.II/base/parameter_acceptor.h>\\n\\u00a0 #include <deal.II/base/parsed_function.h>\\n\\u00a0 #include <deal.II/base/utilities.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/distributed/grid_refinement.h>\\n\\u00a0 #include <deal.II/distributed/solution_transfer.h>\\n\\u00a0 #include <deal.II/distributed/tria.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_renumbering.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_nothing.h>\\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_system.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 #include <deal.II/fe/mapping_fe_field.h>\\n\\u00a0 #include <deal.II/fe/mapping_q1.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_in.h>\\n\\u00a0 #include <deal.II/grid/grid_tools.h>\\n\\u00a0 #include <deal.II/grid/manifold_lib.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/petsc_precondition.h>\\n\\u00a0 #include <deal.II/lac/petsc_solver.h>\\n\\u00a0 #include <deal.II/lac/petsc_sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/petsc_vector.h>\\n\\u00a0 #include <deal.II/lac/solver_cg.h>\\n\\u00a0 #include <deal.II/lac/solver_gmres.h>\\n\\u00a0 #include <deal.II/lac/solver_minres.h>\\n\\u00a0 #include <deal.II/lac/sparsity_tools.h>\\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/error_estimator.h>\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 \\nlinear_operatorLinearOperator< Range, Domain, Payload > linear_operator(const OperatorExemplar &, const Matrix &)Definition linear_operator.h:1427\\nThese are the only new include files with regard to step-60. In this tutorial, the non-matching coupling between the solid and the fluid is computed using an intermediate data structure that keeps track of how the locations of quadrature points of the solid evolve within the fluid mesh. This data structure needs to keep track of the position of the quadrature points on each cell describing the solid domain, of the quadrature weights, and possibly of the normal vector to each point, if the solid domain is of co-dimension one.\\nDeal.II offers these facilities in the Particles namespace, through the ParticleHandler class. ParticleHandler is a class that allows you to manage a collection of particles (objects of type Particles::Particle), representing a collection of points with some attached properties (e.g., an id) floating on a parallel::distributed::Triangulation. The methods and classes in the namespace Particles allows one to easily implement Particle-In-Cell methods and particle tracing on distributed triangulations.\\nWe \\\"abuse\\\" this data structure to store information about the location of solid quadrature points embedded in the surrounding fluid grid, including integration weights, and possibly surface normals. The reason why we use this additional data structure is related to the fact that the solid and the fluid grids might be non-overlapping, and if we were using two separate triangulation objects, would be distributed independently among parallel processes.\\nIn order to couple the two problems, we rely on the ParticleHandler class, storing in each particle the position of a solid quadrature point (which is in general not aligned to any of the fluid quadrature points), its weight, and any other information that may be required to couple the two problems. These locations are then propagated along with the (prescribed) velocity of the solid impeller.\\nOwnership of the solid quadrature points is initially inherited from the MPI partitioning on the solid mesh itself. The Particles so generated are later distributed to the fluid mesh using the methods of the ParticleHandler class. This allows transparent exchange of information between MPI processes about the overlapping pattern between fluid cells and solid quadrature points.\\n\\u00a0 #include <deal.II/particles/data_out.h>\\n\\u00a0 #include <deal.II/particles/generators.h>\\n\\u00a0 #include <deal.II/particles/particle_handler.h>\\n\\u00a0 #include <deal.II/particles/utilities.h>\\n\\u00a0 \\nWhen generating the grids, we allow reading it from a file, and if deal.II has been built with OpenCASCADE support, we also allow reading CAD files and use them as manifold descriptors for the grid (see step-54 for a detailed description of the various Manifold descriptors that are available in the OpenCASCADE namespace)\\n\\u00a0 #include <deal.II/opencascade/manifold_lib.h>\\n\\u00a0 #include <deal.II/opencascade/utilities.h>\\n\\u00a0 #ifdef DEAL_II_WITH_OPENCASCADE\\n\\u00a0 #  include <TopoDS.hxx>\\n\\u00a0 #endif\\n\\u00a0 \\n\\u00a0 #include <cmath>\\n\\u00a0 #include <filesystem>\\n\\u00a0 #include <fstream>\\n\\u00a0 #include <iostream>\\n\\u00a0 #include <memory>\\n\\u00a0 \\n\\u00a0 namespace Step70\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n Run-time parameter handling\\nSimilarly to what we have done in step-60, we set up a class that holds all the parameters of our problem and derive it from the ParameterAcceptor class to simplify the management and creation of parameter files.\\nThe ParameterAcceptor paradigm requires all parameters to be writable by the ParameterAcceptor methods. In order to avoid bugs that would be very difficult to track down (such as writing things like time = 0 instead of time == 0), we declare all the parameters in an external class, which is initialized before the actual StokesImmersedProblem class, and pass it to the main class as a const reference.\\nThe constructor of the class is responsible for the connection between the members of this class and the corresponding entries in the ParameterHandler. Thanks to the use of the ParameterHandler::add_parameter() method, this connection is trivial, but requires all members of this class to be writeable.\\n\\u00a0   template <int dim, int spacedim = dim>\\n\\u00a0   class StokesImmersedProblemParameters : public ParameterAcceptor\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     StokesImmersedProblemParameters();\\n\\u00a0 \\nParameterAcceptorDefinition parameter_acceptor.h:359\\nhowever, since this class will be passed as a const reference to the StokesImmersedProblem class, we have to make sure we can still set the time correctly in the objects derived by the Function class defined herein. In order to do so, we declare both the StokesImmersedProblemParameters::rhs and StokesImmersedProblemParameters::angular_velocity members to be mutable, and define the following little helper method that sets their time to the correct value.\\n\\u00a0     void set_time(const double &time) const\\n\\u00a0     {\\n\\u00a0       rhs.set_time(time);\\n\\u00a0       angular_velocity.set_time(time);\\n\\u00a0     }\\n\\u00a0 \\nThe remainder of the class consists largely of member variables that describe the details of the simulation and its discretization. The following parameters are about where output should land, the spatial and temporal discretization (the default is the \\\\(Q_2\\\\times Q_1\\\\) Taylor-Hood discretization which uses a polynomial degree of 2 for the velocity), and how many time steps should elapse before we generate graphical output again:\\n\\u00a0     std::string output_directory = \\\".\\\";\\n\\u00a0 \\n\\u00a0     unsigned int velocity_degree = 2;\\n\\u00a0 \\n\\u00a0     unsigned int number_of_time_steps = 501;\\n\\u00a0     double       final_time           = 1.0;\\n\\u00a0 \\n\\u00a0     unsigned int output_frequency = 1;\\n\\u00a0 \\nWe allow every grid to be refined independently. In this tutorial, no physics is resolved on the solid grid, and its velocity is given as a datum. However it is relatively straightforward to incorporate some elasticity model in this tutorial, and transform it into a fully fledged FSI solver.\\n\\u00a0     unsigned int initial_fluid_refinement      = 5;\\n\\u00a0     unsigned int initial_solid_refinement      = 5;\\n\\u00a0     unsigned int particle_insertion_refinement = 3;\\n\\u00a0 \\nTo provide a rough description of the fluid domain, we use the method extract_rtree_level() applied to the tree of bounding boxes of each locally owned cell of the fluid triangulation. The higher the level of the tree, the larger the number of extracted bounding boxes, and the more accurate is the description of the fluid domain. However, a large number of bounding boxes also implies a large communication cost, since the collection of bounding boxes is gathered by all processes.\\n\\u00a0     unsigned int fluid_rtree_extraction_level = 1;\\n\\u00a0 \\nThe only two numerical parameters used in the equations are the viscosity of the fluid, and the penalty term \\\\(\\\\beta\\\\) used in the Nitsche formulation:\\n\\u00a0     double viscosity    = 1.0;\\n\\u00a0     double penalty_term = 100;\\n\\u00a0 \\nBy default, we create a hyper_cube without colorization, and we use homogeneous Dirichlet boundary conditions. In this set we store the boundary ids to use when setting the boundary conditions:\\n\\u00a0     std::list<types::boundary_id> homogeneous_dirichlet_ids{0};\\n\\u00a0 \\nWe illustrate here another way to create a Triangulation from a parameter file, using the method GridGenerator::generate_from_name_and_arguments(), that takes the name of a function in the GridGenerator namespace, and its arguments as a single string representing the arguments as a tuple.\\nThe mechanism with which the arguments are parsed from and to a string is explained in detail in the Patterns::Tools::Convert class, which is used to translate from strings to most of the basic STL types (vectors, maps, tuples) and basic deal.II types (Point, Tensor, BoundingBox, etc.).\\nIn general objects that can be represented by rank 1 uniform elements (i.e., std::vector<double>, Point<dim>, std::set<int>, etc.) are comma separated. Additional ranks take a semicolon, allowing you to parse strings into objects of type std::vector<std::vector<double>>, or, for example, std::vector<Point<dim>>, as 0.0, 0.1; 0.1, 0.2. This string could be interpreted as a vector of two Point objects, or a vector of vector of doubles.\\nWhen the entries are not uniform, as in the tuple case, we use a colon to separate the various entries. For example, a string like 5: 0.1, 0.2 could be used to parse an object of type std::pair<int, Point<2>> or a std::tuple<int, std::vector<double>>.\\nIn our case most of the arguments are Point objects (representing centers, corners, subdivision elements, etc.), integer values (number of subdivisions), double values (radius, lengths, etc.), or boolean options (such as the colorize option that many GridGenerator functions take).\\nIn the example below, we set reasonable default values, but these can be changed at run time by selecting any other supported function of the GridGenerator namespace. If the GridGenerator function fails, this program will interpret the name of the grid as a vtk grid filename, and the arguments as a map from manifold_id to the CAD files describing the geometry of the domain. Every CAD file will be analyzed and a Manifold of the OpenCASCADE namespace will be generated according to the content of the CAD file itself.\\nTo be as generic as possible, we do this for each of the generated grids: the fluid grid, the solid grid, but also the tracer particles which are also generated using a triangulation.\\n\\u00a0     std::string name_of_fluid_grid       = \\\"hyper_cube\\\";\\n\\u00a0     std::string arguments_for_fluid_grid = \\\"-1: 1: false\\\";\\n\\u00a0     std::string name_of_solid_grid       = \\\"hyper_rectangle\\\";\\n\\u00a0     std::string arguments_for_solid_grid = spacedim == 2 ?\\n\\u00a0                                              \\\"-.5, -.1: .5, .1: false\\\" :\\n\\u00a0                                              \\\"-.5, -.1, -.1: .5, .1, .1: false\\\";\\n\\u00a0     std::string name_of_particle_grid    = \\\"hyper_ball\\\";\\n\\u00a0     std::string arguments_for_particle_grid =\\n\\u00a0       spacedim == 2 ? \\\"0.3, 0.3: 0.1: false\\\" : \\\"0.3, 0.3, 0.3 : 0.1: false\\\";\\n\\u00a0 \\nSimilarly, we allow for different local refinement strategies. In particular, we limit the maximum number of refinement levels, in order to control the minimum size of the fluid grid, and guarantee that it is compatible with the solid grid. The minimum number of refinement levels is also controlled to ensured sufficient accuracy in the bulk of the flow. Additionally, we perform local refinement based on standard error estimators on the fluid velocity field.\\nWe permit the user to choose between the two most common refinement strategies, namely fixed_number or fixed_fraction, that refer to the methods GridRefinement::refine_and_coarsen_fixed_fraction() and GridRefinement::refine_and_coarsen_fixed_number().\\nRefinement may be done every few time steps, instead of continuously, and we control this value by the refinement_frequency parameter:\\n\\u00a0     int          max_level_refinement = 8;\\n\\u00a0     int          min_level_refinement = 5;\\n\\u00a0     std::string  refinement_strategy  = \\\"fixed_fraction\\\";\\n\\u00a0     double       coarsening_fraction  = 0.3;\\n\\u00a0     double       refinement_fraction  = 0.3;\\n\\u00a0     unsigned int max_cells            = 20000;\\n\\u00a0     int          refinement_frequency = 5;\\n\\u00a0 \\nFinally, the following two function objects are used to control the source term of Stokes flow and the angular velocity at which we move the solid body. In a more realistic simulation, the solid velocity or its deformation would come from the solution of an auxiliary problem on the solid domain. In this example step we leave this part aside, and simply impose a fixed rotational velocity field along the z-axis on the immersed solid, governed by a function that can be specified in the parameter file :\\n\\u00a0     mutable ParameterAcceptorProxy<Functions::ParsedFunction<spacedim>> rhs;\\n\\u00a0     mutable ParameterAcceptorProxy<Functions::ParsedFunction<spacedim>>\\n\\u00a0       angular_velocity;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nParameterAcceptorProxyDefinition parameter_acceptor.h:697\\nThere remains the task of declaring what run-time parameters we can accept in input files. We split the parameters in various categories, by putting them in different sections of the ParameterHandler class. We begin by declaring all the global parameters used by StokesImmersedProblem in the global scope:\\n\\u00a0   template <int dim, int spacedim>\\n\\u00a0   StokesImmersedProblemParameters<dim,\\n\\u00a0                                   spacedim>::StokesImmersedProblemParameters()\\n\\u00a0     : ParameterAcceptor(\\\"Stokes Immersed Problem/\\\")\\n\\u00a0     , rhs(\\\"Right hand side\\\", spacedim + 1)\\n\\u00a0     , angular_velocity(\\\"Angular velocity\\\")\\n\\u00a0   {\\n\\u00a0     add_parameter(\\n\\u00a0       \\\"Velocity degree\\\", velocity_degree, \\\"\\\", this->prm, Patterns::Integer(1));\\n\\u00a0 \\n\\u00a0     add_parameter(\\\"Number of time steps\\\", number_of_time_steps);\\n\\u00a0     add_parameter(\\\"Output frequency\\\", output_frequency);\\n\\u00a0 \\n\\u00a0     add_parameter(\\\"Output directory\\\", output_directory);\\n\\u00a0 \\n\\u00a0     add_parameter(\\\"Final time\\\", final_time);\\n\\u00a0 \\n\\u00a0     add_parameter(\\\"Viscosity\\\", viscosity);\\n\\u00a0 \\n\\u00a0     add_parameter(\\\"Nitsche penalty term\\\", penalty_term);\\n\\u00a0 \\n\\u00a0     add_parameter(\\\"Initial fluid refinement\\\",\\n\\u00a0                   initial_fluid_refinement,\\n\\u00a0                   \\\"Initial mesh refinement used for the fluid domain Omega\\\");\\n\\u00a0 \\n\\u00a0     add_parameter(\\\"Initial solid refinement\\\",\\n\\u00a0                   initial_solid_refinement,\\n\\u00a0                   \\\"Initial mesh refinement used for the solid domain Gamma\\\");\\n\\u00a0 \\n\\u00a0     add_parameter(\\\"Fluid bounding boxes extraction level\\\",\\n\\u00a0                   fluid_rtree_extraction_level,\\n\\u00a0                   \\\"Extraction level of the rtree used to construct global \\\"\\n\\u00a0                   \\\"bounding boxes\\\");\\n\\u00a0 \\n\\u00a0     add_parameter(\\n\\u00a0       \\\"Particle insertion refinement\\\",\\n\\u00a0       particle_insertion_refinement,\\n\\u00a0       \\\"Refinement of the volumetric mesh used to insert the particles\\\");\\n\\u00a0 \\n\\u00a0     add_parameter(\\n\\u00a0       \\\"Homogeneous Dirichlet boundary ids\\\",\\n\\u00a0       homogeneous_dirichlet_ids,\\n\\u00a0       \\\"Boundary Ids over which homogeneous Dirichlet boundary conditions are applied\\\");\\n\\u00a0 \\nPatterns::IntegerDefinition patterns.h:188\\nNext section is dedicated to the parameters used to create the various grids. We will need three different triangulations: Fluid grid is used to define the fluid domain, Solid grid defines the solid domain, and Particle grid is used to distribute some tracer particles, that are advected with the velocity and only used as passive tracers.\\n\\u00a0     enter_subsection(\\\"Grid generation\\\");\\n\\u00a0     {\\n\\u00a0       add_parameter(\\\"Fluid grid generator\\\", name_of_fluid_grid);\\n\\u00a0       add_parameter(\\\"Fluid grid generator arguments\\\", arguments_for_fluid_grid);\\n\\u00a0 \\n\\u00a0       add_parameter(\\\"Solid grid generator\\\", name_of_solid_grid);\\n\\u00a0       add_parameter(\\\"Solid grid generator arguments\\\", arguments_for_solid_grid);\\n\\u00a0 \\n\\u00a0       add_parameter(\\\"Particle grid generator\\\", name_of_particle_grid);\\n\\u00a0       add_parameter(\\\"Particle grid generator arguments\\\",\\n\\u00a0                     arguments_for_particle_grid);\\n\\u00a0     }\\n\\u00a0     leave_subsection();\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0     enter_subsection(\\\"Refinement and remeshing\\\");\\n\\u00a0     {\\n\\u00a0       add_parameter(\\\"Refinement step frequency\\\", refinement_frequency);\\n\\u00a0       add_parameter(\\\"Refinement maximal level\\\", max_level_refinement);\\n\\u00a0       add_parameter(\\\"Refinement minimal level\\\", min_level_refinement);\\n\\u00a0       add_parameter(\\\"Refinement strategy\\\",\\n\\u00a0                     refinement_strategy,\\n\\u00a0                     \\\"\\\",\\n\\u00a0                     this->prm,\\n\\u00a0                     Patterns::Selection(\\\"fixed_fraction|fixed_number\\\"));\\n\\u00a0       add_parameter(\\\"Refinement coarsening fraction\\\", coarsening_fraction);\\n\\u00a0       add_parameter(\\\"Refinement fraction\\\", refinement_fraction);\\n\\u00a0       add_parameter(\\\"Maximum number of cells\\\", max_cells);\\n\\u00a0     }\\n\\u00a0     leave_subsection();\\n\\u00a0 \\nPatterns::SelectionDefinition patterns.h:381\\nThe final task is to correct the default dimension for the right hand side function and define a meaningful default angular velocity instead of zero.\\n\\u00a0     rhs.declare_parameters_call_back.connect([&]() {\\n\\u00a0       Functions::ParsedFunction<spacedim>::declare_parameters(this->prm,\\n\\u00a0                                                               spacedim + 1);\\n\\u00a0     });\\n\\u00a0     angular_velocity.declare_parameters_call_back.connect([&]() {\\n\\u00a0       this->prm.set(\\\"Function expression\\\",\\n\\u00a0                     \\\"t < .500001 ? 6.283185 : -6.283185\\\");\\n\\u00a0     });\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nFunctions::ParsedFunction::declare_parametersstatic void declare_parameters(ParameterHandler &prm, const unsigned int n_components=1)Definition parsed_function.cc:34\\nOnce the angular velocity is provided as a Function object, we reconstruct the pointwise solid velocity through the following class which derives from the Function class. It provides the value of the velocity of the solid body at a given position by assuming that the body rotates around the origin (or the \\\\(z\\\\) axis in 3d) with a given angular velocity.\\n\\u00a0   template <int spacedim>\\n\\u00a0   class SolidVelocity : public Function<spacedim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     static_assert(spacedim > 1,\\n\\u00a0                   \\\"Cannot instantiate SolidVelocity for spacedim == 1\\\");\\n\\u00a0 \\n\\u00a0     SolidVelocity(const Functions::ParsedFunction<spacedim> &angular_velocity)\\n\\u00a0       : angular_velocity(angular_velocity)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     virtual double value(const Point<spacedim> &p,\\n\\u00a0                          unsigned int           component = 0) const override\\n\\u00a0     {\\n\\u00a0       Tensor<1, spacedim> velocity;\\n\\u00a0 \\nFunctionDefinition function.h:152\\nFunctions::ParsedFunctionDefinition parsed_function.h:83\\nPointDefinition point.h:111\\nTensorDefinition tensor.h:471\\nint\\nWe assume that the angular velocity is directed along the z-axis, i.e., we model the actual angular velocity as if it was a two-dimensional rotation, irrespective of the actual value of spacedim.\\n\\u00a0       const double omega = angular_velocity.value(p);\\n\\u00a0       velocity[0]        = -omega * p[1];\\n\\u00a0       velocity[1]        = omega * p[0];\\n\\u00a0 \\n\\u00a0       return velocity[component];\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     const Functions::ParsedFunction<spacedim> &angular_velocity;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\nFunctions::ParsedFunction::valuevirtual double value(const Point< dim > &p, const unsigned int component=0) const overrideDefinition parsed_function.cc:175\\nSimilarly, we assume that the solid position can be computed explicitly at each time step, exploiting the knowledge of the angular velocity. We compute the exact position of the solid particle assuming that the solid is rotated by an amount equal to the time step multiplied by the angular velocity computed at the point p:\\n\\u00a0   template <int spacedim>\\n\\u00a0   class SolidPosition : public Function<spacedim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     static_assert(spacedim > 1,\\n\\u00a0                   \\\"Cannot instantiate SolidPosition for spacedim == 1\\\");\\n\\u00a0 \\n\\u00a0     SolidPosition(const Functions::ParsedFunction<spacedim> &angular_velocity,\\n\\u00a0                   const double                               time_step)\\n\\u00a0       : Function<spacedim>(spacedim)\\n\\u00a0       , angular_velocity(angular_velocity)\\n\\u00a0       , time_step(time_step)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     virtual double value(const Point<spacedim> &p,\\n\\u00a0                          unsigned int           component = 0) const override\\n\\u00a0     {\\n\\u00a0       Point<spacedim> new_position = p;\\n\\u00a0 \\n\\u00a0       double dtheta = angular_velocity.value(p) * time_step;\\n\\u00a0 \\n\\u00a0       new_position[0] = std::cos(dtheta) * p[0] - std::sin(dtheta) * p[1];\\n\\u00a0       new_position[1] = std::sin(dtheta) * p[0] + std::cos(dtheta) * p[1];\\n\\u00a0 \\n\\u00a0       return new_position[component];\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     void set_time_step(const double new_time_step)\\n\\u00a0     {\\n\\u00a0       time_step = new_time_step;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     const Functions::ParsedFunction<spacedim> &angular_velocity;\\n\\u00a0     double                                     time_step;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\nstd::cos::VectorizedArray< Number, width > cos(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6609\\nstd::sin::VectorizedArray< Number, width > sin(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6589\\n The StokesImmersedProblem class declaration\\nWe are now ready to introduce the main class of our tutorial program. As usual, other than the constructor, we leave a single public entry point: the run() method. Everything else is left private, and accessed through the run method itself.\\n\\u00a0   template <int dim, int spacedim = dim>\\n\\u00a0   class StokesImmersedProblem\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     StokesImmersedProblem(\\n\\u00a0       const StokesImmersedProblemParameters<dim, spacedim> &par);\\n\\u00a0 \\n\\u00a0     void run();\\n\\u00a0 \\nThe next section contains the private members of the class. The first method is similar to what is present in previous example. However it not only takes care of generating the grid for the fluid, but also the grid for the solid. The second computes the largest time step that guarantees that each particle moves of at most one cell. This is important to ensure that the Particles::ParticleHandler can find which cell a particle ends up in, as it can only look from one cell to its immediate neighbors (because, in a parallel setting, every MPI process only knows about the cells it owns as well as their immediate neighbors).\\n\\u00a0   private:\\n\\u00a0     void make_grid();\\n\\u00a0 \\n\\u00a0     double compute_time_step() const;\\n\\u00a0 \\nThe next two functions initialize the Particles::ParticleHandler objects used in this class. We have two such objects: One represents passive tracers, used to plot the trajectories of fluid particles, while the other represents material particles of the solid, which are placed at quadrature points of the solid grid.\\n\\u00a0     void setup_tracer_particles();\\n\\u00a0     void setup_solid_particles();\\n\\u00a0 \\nThe remainder of the set up is split in two parts: The first of the following two functions creates all objects that are needed once per simulation, whereas the other sets up all objects that need to be reinitialized at every refinement step.\\n\\u00a0     void initial_setup();\\n\\u00a0     void setup_dofs();\\n\\u00a0 \\nThe assembly routine is very similar to other Stokes assembly routines, with the exception of the Nitsche restriction part, which exploits one of the particle handlers to integrate on a non-matching part of the fluid domain, corresponding to the position of the solid. We split these two parts into two separate functions.\\n\\u00a0     void assemble_stokes_system();\\n\\u00a0     void assemble_nitsche_restriction();\\n\\u00a0 \\nThe remaining functions solve the linear system (which looks almost identical to the one in step-60) and then postprocess the solution: The refine_and_transfer() method is called only every refinement_frequency steps to adapt the mesh and also make sure that all the fields that were computed on the time step before refinement are transferred correctly to the new grid. This includes vector fields, as well as particle information. Similarly, we call the two output methods only every output_frequency steps.\\n\\u00a0     void solve();\\n\\u00a0 \\n\\u00a0     void refine_and_transfer();\\n\\u00a0 \\n\\u00a0     void output_results(const unsigned int cycle, const double time) const;\\n\\u00a0     void output_particles(const Particles::ParticleHandler<spacedim> &particles,\\n\\u00a0                           std::string                                 fprefix,\\n\\u00a0                           const unsigned int                          iter,\\n\\u00a0                           const double time) const;\\n\\u00a0 \\nParticles::ParticleHandlerDefinition particle_handler.h:63\\nLet us then move on to the member functions of the class. The first deals with run-time parameters that are read from a parameter file. As noted before, we make sure we cannot modify this object from within this class, by making it a const reference.\\n\\u00a0     const StokesImmersedProblemParameters<dim, spacedim> &par;\\n\\u00a0 \\nThen there is also the MPI communicator object that we will use to let processes send information across the network if the program runs in parallel, along with the pcout object and timer information that has also been employed by step-40, for example:\\n\\u00a0     MPI_Comm mpi_communicator;\\n\\u00a0 \\n\\u00a0     ConditionalOStream pcout;\\n\\u00a0 \\n\\u00a0     mutable TimerOutput computing_timer;\\n\\u00a0 \\nConditionalOStreamDefinition conditional_ostream.h:80\\nMPI_Comm\\nTimerOutputDefinition timer.h:549\\nNext is one of the main novelties with regard to step-60. Here we assume that both the solid and the fluid are fully distributed triangulations. This allows the problem to scale to a very large number of degrees of freedom, at the cost of communicating all the overlapping regions between non matching triangulations. This is especially tricky, since we make no assumptions on the relative position or distribution of the various subdomains of the two triangulations. In particular, we assume that every process owns only a part of the solid_tria, and only a part of the fluid_tria, not necessarily in the same physical region, and not necessarily overlapping.\\nWe could in principle try to create the initial subdivisions in such a way that each process's subdomains overlap between the solid and the fluid regions. However, this overlap would be destroyed during the simulation, and we would have to redistribute the DoFs again and again. The approach we follow in this tutorial is more flexible, and not much more expensive. We make two all-to-all communications at the beginning of the simulation to exchange information about an (approximate) information of the geometrical occupancy of each processor (done through a collection of bounding boxes).\\nThis information is used by the Particles::ParticleHandler class to exchange (using a some-to-some communication pattern) all particles, so that every process knows about the particles that live on the region occupied by the fluid subdomain that it owns.\\nIn order to couple the overlapping regions, we exploit the facilities implemented in the ParticleHandler class.\\n\\u00a0     parallel::distributed::Triangulation<spacedim>      fluid_tria;\\n\\u00a0     parallel::distributed::Triangulation<dim, spacedim> solid_tria;\\n\\u00a0 \\nparallel::distributed::TriangulationDefinition tria.h:268\\nNext come descriptions of the finite elements in use, along with the corresponding DoFHandler objects. For the current implementation, only fluid_fe is really necessary. For completeness, and to allow easy extension, we also keep the solid_fe around, which is however initialized to a FE_Nothing finite element space, i.e., one that has no degrees of freedom.\\nWe declare both finite element spaces as std::unique_ptr objects rather than regular member variables, to allow their generation after StokesImmersedProblemParameters has been initialized. In particular, they will be initialized in the initial_setup() method.\\n\\u00a0     std::unique_ptr<FiniteElement<spacedim>>      fluid_fe;\\n\\u00a0     std::unique_ptr<FiniteElement<dim, spacedim>> solid_fe;\\n\\u00a0 \\n\\u00a0     DoFHandler<spacedim>      fluid_dh;\\n\\u00a0     DoFHandler<dim, spacedim> solid_dh;\\n\\u00a0 \\nDoFHandlerDefinition dof_handler.h:317\\nSimilarly to how things are done in step-22, we use a block system to treat the Stokes part of the problem, and follow very closely what was done there.\\n\\u00a0     std::vector<IndexSet> fluid_owned_dofs;\\n\\u00a0     std::vector<IndexSet> solid_owned_dofs;\\n\\u00a0 \\n\\u00a0     std::vector<IndexSet> fluid_relevant_dofs;\\n\\u00a0     std::vector<IndexSet> solid_relevant_dofs;\\n\\u00a0 \\nUsing this partitioning of degrees of freedom, we can then define all of the objects necessary to describe the linear systems in question:\\n\\u00a0     AffineConstraints<double> constraints;\\n\\u00a0 \\n\\u00a0     LA::MPI::BlockSparseMatrix system_matrix;\\n\\u00a0     LA::MPI::BlockSparseMatrix preconditioner_matrix;\\n\\u00a0 \\n\\u00a0     LA::MPI::BlockVector solution;\\n\\u00a0     LA::MPI::BlockVector locally_relevant_solution;\\n\\u00a0     LA::MPI::BlockVector system_rhs;\\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nLet us move to the particles side of this program. There are two Particles::ParticleHandler objects used to couple the solid with the fluid, and to describe the passive tracers. These, in many ways, play a role similar to the DoFHandler class used in the discretization, i.e., they provide for an enumeration of particles and allow querying information about each particle.\\n\\u00a0     Particles::ParticleHandler<spacedim> tracer_particle_handler;\\n\\u00a0     Particles::ParticleHandler<spacedim> solid_particle_handler;\\n\\u00a0 \\nFor every tracer particle, we need to compute the velocity field in its current position, and update its position using a discrete time stepping scheme. We do this using distributed linear algebra objects that store the coordinates of each particle's location or velocity. That is, these vectors have tracer_particle_handler.n_global_particles() * spacedim entries that we will store in a way so that parts of the vector are partitioned across all processes. (Implicitly, we here make the assumption that the spacedim coordinates of each particle are stored in consecutive entries of the vector.) Thus, we need to determine who the owner of each vector entry is. We set this owner to be equal to the process that generated that particle at time \\\\(t=0\\\\). This information is stored for every process in the locally_owned_tracer_particle_coordinates IndexSet.\\nOnce the particles have been distributed around to match the process that owns the region where the particle lives, we will need read access from that process to the corresponding velocity field. We achieve this by filling a read only velocity vector field that contains the relevant information in ghost entries. This is achieved using the locally_relevant_tracer_particle_coordinates IndexSet, that keeps track of how things change during the simulation, i.e., it keeps track of where particles that the current process owns have ended up being, and who owns the particles that ended up in my subdomain.\\nWhile this is not the most efficient strategy, we keep it this way to illustrate how things would work in a real fluid-structure interaction (FSI) problem. If a particle is linked to a specific solid degree of freedom, we are not free to choose who owns it, and we have to communicate this information around. We illustrate this here, and show that the communication pattern is point-to-point, and negligible in terms of total cost of the algorithm.\\nThe vectors defined based on these subdivisions are then used to store the particles velocities (read-only, with ghost entries) and their displacement (read/write, no ghost entries).\\n\\u00a0     IndexSet locally_owned_tracer_particle_coordinates;\\n\\u00a0     IndexSet locally_relevant_tracer_particle_coordinates;\\n\\u00a0 \\n\\u00a0     LA::MPI::Vector tracer_particle_velocities;\\n\\u00a0     LA::MPI::Vector relevant_tracer_particle_displacements;\\n\\u00a0 \\nIndexSetDefinition index_set.h:70\\nOne of the key points of this tutorial program is the coupling between two independent parallel::distributed::Triangulation objects, one of which may be moving and deforming (with possibly large deformations) with respect to the other. When both the fluid and the solid triangulations are of type parallel::distributed::Triangulation, every process has access only to its fraction of locally owned cells of each of the two triangulations. As mentioned above, in general, the locally owned domains are not overlapping.\\nIn order to allow for the efficient exchange of information between non-overlapping parallel::distributed::Triangulation objects, some algorithms of the library require the user to provide a rough description of the area occupied by the locally owned part of the triangulation, in the form of a collection of axis-aligned bounding boxes for each process, that provide a full covering of the locally owned part of the domain. This kind of information can then be used in situations where one needs to send information to the owner of the cell surrounding a known location, without knowing who that owner may in fact be. But, if one knows a collection of bounding boxes for the geometric area or volume each process owns, then we can determine a subset of all processes that might possibly own the cell in which that location lies: namely, all of those processes whose bounding boxes contain that point. Instead of sending the information associated to that location to all processes, one can then get away with only sending it to a small subset of the processes with point-to-point communication primitives. (You will notice that this also allows for the typical time-vs-memory trade-off: The more data we are willing to store about each process's owned area \\u2013 in the form of more refined bounding box information \\u2013 the less communication we have to perform.)\\nWe construct this information by gathering a vector (of length Utilities::MPI::n_mpi_processes()) of vectors of BoundingBox objects. We fill this vector using the extract_rtree_level() function, and allow the user to select what level of the tree to extract. The \\\"level\\\" corresponds to how coarse/fine the overlap of the area with bounding boxes should be.\\nAs an example, this is what would be extracted by the extract_rtree_level() function applied to a two dimensional hyper ball, distributed over three processes. Each image shows in green the bounding boxes associated to the locally owned cells of the triangulation on each process, and in violet the bounding boxes extracted from the rtree:\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nWe store these boxes in a global member variable, which is updated at every refinement step:\\n\\u00a0     std::vector<std::vector<BoundingBox<spacedim>>> global_fluid_bounding_boxes;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n The StokesImmersedProblem class implementation\\n Object construction and mesh initialization functions\\nIn the constructor, we create the mpi_communicator as well as the triangulations and dof_handler for both the fluid and the solid. Using the mpi_communicator, both the ConditionalOStream and TimerOutput object are constructed.\\nIn the constructor, we also check whether the output directory specified in the input file exists and, if not, create it.\\n\\u00a0   template <int dim, int spacedim>\\n\\u00a0   StokesImmersedProblem<dim, spacedim>::StokesImmersedProblem(\\n\\u00a0     const StokesImmersedProblemParameters<dim, spacedim> &par)\\n\\u00a0     : par(par)\\n\\u00a0     , mpi_communicator(MPI_COMM_WORLD)\\n\\u00a0     , pcout(std::cout,\\n\\u00a0             (Utilities::MPI::this_mpi_process(mpi_communicator) == 0))\\n\\u00a0     , computing_timer(mpi_communicator,\\n\\u00a0                       pcout,\\n\\u00a0                       TimerOutput::summary,\\n\\u00a0                       TimerOutput::wall_times)\\n\\u00a0     , fluid_tria(mpi_communicator,\\n\\u00a0                  typename Triangulation<spacedim>::MeshSmoothing(\\n\\u00a0                    Triangulation<spacedim>::smoothing_on_refinement |\\n\\u00a0                    Triangulation<spacedim>::smoothing_on_coarsening))\\n\\u00a0     , solid_tria(mpi_communicator,\\n\\u00a0                  typename Triangulation<dim, spacedim>::MeshSmoothing(\\n\\u00a0                    Triangulation<dim, spacedim>::smoothing_on_refinement |\\n\\u00a0                    Triangulation<dim, spacedim>::smoothing_on_coarsening))\\n\\u00a0     , fluid_dh(fluid_tria)\\n\\u00a0     , solid_dh(solid_tria)\\n\\u00a0   {\\n\\u00a0     if (std::filesystem::exists(par.output_directory))\\n\\u00a0       {\\n\\u00a0         Assert(std::filesystem::is_directory(par.output_directory),\\n\\u00a0                ExcMessage(\\\"You specified <\\\" + par.output_directory +\\n\\u00a0                           \\\"> as the output directory in the input file, \\\"\\n\\u00a0                           \\\"but this is not in fact a directory.\\\"));\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       std::filesystem::create_directory(par.output_directory);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nTriangulationDefinition tria.h:1323\\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\nInitializeLibrary::MPI@ MPI\\nUtilitiesDefinition communication_pattern_base.h:30\\nstdSTL namespace.\\nIn order to generate the grid, we first try to use the functions in the deal.II GridGenerator namespace, by leveraging the GridGenerator::generate_from_name_and_argument(). If this function fails, then we use the following method, where the name is interpreted as a filename, and the arguments are interpreted as a map from manifold ids to CAD files, and are converted to Manifold descriptors using the OpenCASCADE namespace facilities. At the top, we read the file into a triangulation:\\n\\u00a0   template <int dim, int spacedim>\\n\\u00a0   void read_grid_and_cad_files(const std::string &grid_file_name,\\n\\u00a0                                const std::string &ids_and_cad_file_names,\\n\\u00a0                                Triangulation<dim, spacedim> &tria)\\n\\u00a0   {\\n\\u00a0     GridIn<dim, spacedim> grid_in;\\n\\u00a0     grid_in.attach_triangulation(tria);\\n\\u00a0     grid_in.read(grid_file_name);\\n\\u00a0 \\nGridInDefinition grid_in.h:311\\nGridIn::attach_triangulationvoid attach_triangulation(Triangulation< dim, spacedim > &tria)Definition grid_in.cc:153\\nIf we got to this point, then the Triangulation has been read, and we are ready to attach to it the correct manifold descriptions. We perform the next lines of code only if deal.II has been built with OpenCASCADE support. For each entry in the map, we try to open the corresponding CAD file, we analyze it, and according to its content, opt for either a OpenCASCADE::ArcLengthProjectionLineManifold (if the CAD file contains a single TopoDS_Edge or a single TopoDS_Wire) or a OpenCASCADE::NURBSPatchManifold, if the file contains a single face. Notice that if the CAD files do not contain single wires, edges, or faces, an assertion will be throw in the generation of the Manifold.\\nWe use the Patterns::Tools::Convert class to do the conversion from the string to a map between manifold ids and file names for us:\\n\\u00a0 #ifdef DEAL_II_WITH_OPENCASCADE\\n\\u00a0     using map_type  = std::map<types::manifold_id, std::string>;\\n\\u00a0     using Converter = Patterns::Tools::Convert<map_type>;\\n\\u00a0 \\n\\u00a0     for (const auto &pair : Converter::to_value(ids_and_cad_file_names))\\n\\u00a0       {\\n\\u00a0         const auto &manifold_id   = pair.first;\\n\\u00a0         const auto &cad_file_name = pair.second;\\n\\u00a0 \\n\\u00a0         std::string extension =\\n\\u00a0           cad_file_name.substr(cad_file_name.find_last_of('.') + 1);\\n\\u00a0         std::transform(extension.begin(),\\n\\u00a0                        extension.end(),\\n\\u00a0                        extension.begin(),\\n\\u00a0                        [](const char c) -> char { return std::tolower(c); });\\n\\u00a0 \\n\\u00a0         TopoDS_Shape shape;\\n\\u00a0         if (extension == \\\"iges\\\" || extension == \\\"igs\\\")\\n\\u00a0           shape = OpenCASCADE::read_IGES(cad_file_name);\\n\\u00a0         else if (extension == \\\"step\\\" || extension == \\\"stp\\\")\\n\\u00a0           shape = OpenCASCADE::read_STEP(cad_file_name);\\n\\u00a0         else\\n\\u00a0           AssertThrow(false,\\n\\u00a0                       ExcNotImplemented(\\\"We found an extension that we \\\"\\n\\u00a0                                         \\\"do not recognize as a CAD file \\\"\\n\\u00a0                                         \\\"extension. Bailing out.\\\"));\\n\\u00a0 \\nfirstPoint< 2 > firstDefinition grid_out.cc:4623\\nAssertThrow#define AssertThrow(cond, exc)Definition exceptions.h:1739\\nOpenCASCADE::read_STEPTopoDS_Shape read_STEP(const std::string &filename, const double scale_factor=1e-3)Definition utilities.cc:358\\nOpenCASCADE::read_IGESTopoDS_Shape read_IGES(const std::string &filename, const double scale_factor=1e-3)Definition utilities.cc:241\\nPatterns::Tools::ConvertDefinition patterns.h:1298\\nNow we check how many faces are contained in the Shape. OpenCASCADE is intrinsically 3d, so if this number is zero, we interpret this as a line manifold, otherwise as a OpenCASCADE::NormalToMeshProjectionManifold in spacedim = 3, or OpenCASCADE::NURBSPatchManifold in spacedim = 2.\\n\\u00a0         const auto n_elements = OpenCASCADE::count_elements(shape);\\n\\u00a0         if ((std::get<0>(n_elements) == 0))\\n\\u00a0           tria.set_manifold(\\n\\u00a0             manifold_id,\\n\\u00a0             OpenCASCADE::ArclengthProjectionLineManifold<dim, spacedim>(shape));\\n\\u00a0         else if (spacedim == 3)\\n\\u00a0           {\\nOpenCASCADE::ArclengthProjectionLineManifoldDefinition manifold_lib.h:291\\nOpenCASCADE::count_elementsstd::tuple< unsigned int, unsigned int, unsigned int > count_elements(const TopoDS_Shape &shape)Definition utilities.cc:91\\nWe use this trick, because OpenCASCADE::NormalToMeshProjectionManifold is only implemented for spacedim = 3. The check above makes sure that things actually work correctly.\\n\\u00a0             const auto t = reinterpret_cast<Triangulation<dim, 3> *>(&tria);\\n\\u00a0             t->set_manifold(manifold_id,\\n\\u00a0                             OpenCASCADE::NormalToMeshProjectionManifold<dim, 3>(\\n\\u00a0                               shape));\\n\\u00a0           }\\n\\u00a0         else\\nOpenCASCADE::NormalToMeshProjectionManifoldDefinition manifold_lib.h:230\\nTriangulation::set_manifoldvoid set_manifold(const types::manifold_id number, const Manifold< dim, spacedim > &manifold_object)\\nWe also allow surface descriptions in two dimensional spaces based on single NURBS patches. For this to work, the CAD file must contain a single TopoDS_Face.\\n\\u00a0           tria.set_manifold(manifold_id,\\n\\u00a0                             OpenCASCADE::NURBSPatchManifold<dim, spacedim>(\\n\\u00a0                               TopoDS::Face(shape)));\\n\\u00a0       }\\n\\u00a0 #else\\n\\u00a0     (void)ids_and_cad_file_names;\\n\\u00a0     AssertThrow(false, ExcNotImplemented(\\\"Generation of the grid failed.\\\"));\\n\\u00a0 #endif\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nOpenCASCADE::NURBSPatchManifoldDefinition manifold_lib.h:354\\nNow let's put things together, and make all the necessary grids. As mentioned above, we first try to generate the grid internally, and if we fail (i.e., if we end up in the catch clause), then we proceed with the above function.\\nWe repeat this pattern for both the fluid and the solid mesh.\\n\\u00a0   template <int dim, int spacedim>\\n\\u00a0   void StokesImmersedProblem<dim, spacedim>::make_grid()\\n\\u00a0   {\\n\\u00a0     try\\n\\u00a0       {\\n\\u00a0         GridGenerator::generate_from_name_and_arguments(\\n\\u00a0           fluid_tria, par.name_of_fluid_grid, par.arguments_for_fluid_grid);\\n\\u00a0       }\\n\\u00a0     catch (...)\\n\\u00a0       {\\n\\u00a0         pcout << \\\"Generating from name and argument failed.\\\" << std::endl\\n\\u00a0               << \\\"Trying to read from file name.\\\" << std::endl;\\n\\u00a0         read_grid_and_cad_files(par.name_of_fluid_grid,\\n\\u00a0                                 par.arguments_for_fluid_grid,\\n\\u00a0                                 fluid_tria);\\n\\u00a0       }\\n\\u00a0     fluid_tria.refine_global(par.initial_fluid_refinement);\\n\\u00a0 \\n\\u00a0     try\\n\\u00a0       {\\n\\u00a0         GridGenerator::generate_from_name_and_arguments(\\n\\u00a0           solid_tria, par.name_of_solid_grid, par.arguments_for_solid_grid);\\n\\u00a0       }\\n\\u00a0     catch (...)\\n\\u00a0       {\\n\\u00a0         read_grid_and_cad_files(par.name_of_solid_grid,\\n\\u00a0                                 par.arguments_for_solid_grid,\\n\\u00a0                                 solid_tria);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     solid_tria.refine_global(par.initial_solid_refinement);\\n\\u00a0   }\\n\\u00a0 \\nGridGenerator::generate_from_name_and_argumentsvoid generate_from_name_and_arguments(Triangulation< dim, spacedim > &tria, const std::string &grid_generator_function_name, const std::string &grid_generator_function_arguments)Definition grid_generator_from_name.cc:352\\n Particle initialization functions\\nOnce the solid and fluid grids have been created, we start filling the Particles::ParticleHandler objects. The first one we take care of is the one we use to keep track of passive tracers in the fluid. These are simply transported along, and in some sense their locations are unimportant: We just want to use them to see where flow is being transported. We could use any way we choose to determine where they are initially located. A convenient one is to create the initial locations as the vertices of a mesh in a shape of our choice \\u2013 a choice determined by one of the run-time parameters in the parameter file.\\nIn this implementation, we create tracers using the support points of a FE_Q finite element space defined on a temporary grid, which is then discarded. Of this grid, we only keep around the Particles::Particle objects (stored in a Particles::ParticleHandler class) associated to the support points.\\nThe Particles::ParticleHandler class offers the possibility to insert a set of particles that live physically in the part of the domain owned by the active process. However, in this case this function would not suffice. The particles generated as the locally owned support points of an FE_Q object on an arbitrary grid (non-matching with regard to the fluid grid) have no reasons to lie in the same physical region of the locally owned subdomain of the fluid grid. In fact this will almost never be the case, especially since we want to keep track of what is happening to the particles themselves.\\nIn particle-in-cell methods (PIC), it is often customary to assign ownership of the particles to the process where the particles lie. In this tutorial we illustrate a different approach, which is useful if one wants to keep track of information related to the particles (for example, if a particle is associated to a given degree of freedom, which is owned by a specific process and not necessarily the same process that owns the fluid cell where the particle happens to be at any given time). In the approach used here, ownership of the particles is assigned once at the beginning, and one-to-one communication happens whenever the original owner needs information from the process that owns the cell where the particle lives. We make sure that we set ownership of the particles using the initial particle distribution, and keep the same ownership throughout the execution of the program.\\nWith this overview out of the way, let us see what the function does. At the top, we create a temporary triangulation and DoFHandler object from which we will take the node locations for initial particle locations:\\n\\u00a0   template <int dim, int spacedim>\\n\\u00a0   void StokesImmersedProblem<dim, spacedim>::setup_tracer_particles()\\n\\u00a0   {\\n\\u00a0     parallel::distributed::Triangulation<spacedim> particle_insert_tria(\\n\\u00a0       mpi_communicator);\\n\\u00a0     GridGenerator::generate_from_name_and_arguments(\\n\\u00a0       particle_insert_tria,\\n\\u00a0       par.name_of_particle_grid,\\n\\u00a0       par.arguments_for_particle_grid);\\n\\u00a0     particle_insert_tria.refine_global(par.particle_insertion_refinement);\\n\\u00a0 \\n\\u00a0     const FE_Q<spacedim> particles_fe(1);\\n\\u00a0     DoFHandler<spacedim> particles_dof_handler(particle_insert_tria);\\n\\u00a0     particles_dof_handler.distribute_dofs(particles_fe);\\n\\u00a0 \\nFE_QDefinition fe_q.h:554\\nThis is where things start to get complicated. Since we may run this program in a parallel environment, every parallel process will now have created these temporary triangulations and DoFHandlers. But, in fully distributed triangulations, the active process only knows about the locally owned cells, and has no idea of how other processes have distributed their own cells. This is true for both the temporary triangulation created above as well as the fluid triangulation into which we want to embed the particles below. On the other hand, these locally known portions of the two triangulations will, in general, not overlap. That is, the locations of the particles we will create from the node locations of the temporary mesh are arbitrary, and may fall within a region of the fluid triangulation that the current process doesn't have access to (i.e., a region of the fluid domain where cells are artificial). In order to understand who to send those particles to, we need to have a (rough) idea of how the fluid grid is distributed among processors.\\nWe construct this information by first building an index tree of boxes bounding the locally owned cells, and then extracting one of the first levels of the tree:\\n\\u00a0     std::vector<BoundingBox<spacedim>> all_boxes;\\n\\u00a0     all_boxes.reserve(fluid_tria.n_locally_owned_active_cells());\\n\\u00a0     for (const auto &cell : fluid_tria.active_cell_iterators())\\n\\u00a0       if (cell->is_locally_owned())\\n\\u00a0         all_boxes.emplace_back(cell->bounding_box());\\n\\u00a0 \\n\\u00a0     const auto tree = pack_rtree(all_boxes);\\n\\u00a0     const auto local_boxes =\\n\\u00a0       extract_rtree_level(tree, par.fluid_rtree_extraction_level);\\n\\u00a0 \\nextract_rtree_levelstd::vector< BoundingBox< boost::geometry::dimension< typename Rtree::indexable_type >::value > > extract_rtree_level(const Rtree &tree, const unsigned int level)\\npack_rtreeRTree< typename LeafTypeIterator::value_type, IndexType, IndexableGetter > pack_rtree(const LeafTypeIterator &begin, const LeafTypeIterator &end)\\nEach process now has a collection of bounding boxes that completely enclose all locally owned processes (but that may overlap the bounding boxes of other processes). We then exchange this information between all participating processes so that every process knows the bounding boxes of all other processes.\\nEquipped with this knowledge, we can then initialize the tracer_particle_handler to the fluid mesh and generate the particles from the support points of the (temporary) tracer particles triangulation. This function call uses the global_bounding_boxes object we just constructed to figure out where to send the particles whose locations were derived from the locally owned part of the particles_dof_handler. At the end of this call, every particle will have been distributed to the correct process (i.e., the process that owns the fluid cell where the particle lives). We also output their number to the screen at this point.\\n\\u00a0     global_fluid_bounding_boxes =\\n\\u00a0       Utilities::MPI::all_gather(mpi_communicator, local_boxes);\\n\\u00a0 \\n\\u00a0     tracer_particle_handler.initialize(fluid_tria,\\n\\u00a0                                        StaticMappingQ1<spacedim>::mapping);\\n\\u00a0 \\n\\u00a0     Particles::Generators::dof_support_points(particles_dof_handler,\\n\\u00a0                                               global_fluid_bounding_boxes,\\n\\u00a0                                               tracer_particle_handler);\\n\\u00a0 \\n\\u00a0     pcout << \\\"Tracer particles: \\\"\\n\\u00a0           << tracer_particle_handler.n_global_particles() << std::endl;\\n\\u00a0 \\nParticles::Generators::dof_support_pointsvoid dof_support_points(const DoFHandler< dim, spacedim > &dof_handler, const std::vector< std::vector< BoundingBox< spacedim > > > &global_bounding_boxes, ParticleHandler< dim, spacedim > &particle_handler, const Mapping< dim, spacedim > &mapping=(ReferenceCells::get_hypercube< dim >() .template get_default_linear_mapping< dim, spacedim >()), const ComponentMask &components={}, const std::vector< std::vector< double > > &properties={})Definition generators.cc:439\\nUtilities::MPI::all_gatherstd::vector< T > all_gather(const MPI_Comm comm, const T &object_to_send)\\nStaticMappingQ1Definition mapping_q1.h:92\\nEach particle so created has a unique ID. At some point in the algorithm below, we will need vectors containing position and velocity information for each particle. This vector will have size n_particles * spacedim, and we will have to store the elements of this vector in a way so that each parallel process \\\"owns\\\" those elements that correspond to coordinates of the particles it owns. In other words, we have to partition the index space between zero and n_particles * spacedim among all processes. We can do this by querying the tracer_particle_handler for the IDs of its locally relevant particles, and construct the indices that would be needed to store in a (parallel distributed) vector of the position and velocity of all particles where we implicitly assume that we store the coordinates of each location or velocity in spacedim successive vector elements (this is what the IndexSet::tensor_priduct() function does).\\n\\u00a0     locally_owned_tracer_particle_coordinates =\\n\\u00a0       tracer_particle_handler.locally_owned_particle_ids().tensor_product(\\n\\u00a0         complete_index_set(spacedim));\\n\\u00a0 \\ncomplete_index_setIndexSet complete_index_set(const IndexSet::size_type N)Definition index_set.h:1204\\nAt the beginning of the simulation, all particles are in their original position. When particles move, they may traverse to a part of the domain which is owned by another process. If this happens, the current process keeps formally \\\"ownership\\\" of the particles, but may need read access from the process where the particle has landed. We keep this information in another index set, which stores the indices of all particles that are currently on the current process's subdomain, independently if they have always been here or not.\\nKeeping this index set around allows us to leverage linear algebra classes for all communications regarding positions and velocities of the particles. This mimics what would happen in the case where another problem was solved in the solid domain (as in fluid-structure interaction. In this latter case, additional DOFs on the solid domain would be coupled to what is occurring in the fluid domain.\\n\\u00a0     locally_relevant_tracer_particle_coordinates =\\n\\u00a0       locally_owned_tracer_particle_coordinates;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nSimilarly to what we have done for passive tracers, we next set up the particles that track the quadrature points of the solid mesh. The main difference here is that we also want to attach a weight value (the \\\"JxW\\\" value of the quadrature point) to each of particle, so that we can compute integrals even without direct access to the original solid grid.\\nThis is achieved by leveraging the \\\"properties\\\" concept of the Particles::Particle class. It is possible to store (in a memory efficient way) an arbitrary number of double numbers for each of the Particles::Particle objects inside a Particles::ParticleHandler object. We use this possibility to store the JxW values of the quadrature points of the solid grid.\\nIn our case, we only need to store one property per particle: the JxW value of the integration on the solid grid. This is passed at construction time to the solid_particle_handler object as the last argument\\n\\u00a0   template <int dim, int spacedim>\\n\\u00a0   void StokesImmersedProblem<dim, spacedim>::setup_solid_particles()\\n\\u00a0   {\\n\\u00a0     const QGauss<dim> quadrature(fluid_fe->degree + 1);\\n\\u00a0 \\n\\u00a0     const unsigned int n_properties = 1;\\n\\u00a0     solid_particle_handler.initialize(fluid_tria,\\n\\u00a0                                       StaticMappingQ1<spacedim>::mapping,\\n\\u00a0                                       n_properties);\\n\\u00a0 \\nQGaussDefinition quadrature_lib.h:40\\nThe number of particles that we generate locally is equal to the total number of locally owned cells times the number of quadrature points used in each cell. We store all these points in a vector, and their corresponding properties in a vector of vectors:\\n\\u00a0     std::vector<Point<spacedim>> quadrature_points_vec;\\n\\u00a0     quadrature_points_vec.reserve(quadrature.size() *\\n\\u00a0                                   solid_tria.n_locally_owned_active_cells());\\n\\u00a0 \\n\\u00a0     std::vector<std::vector<double>> properties;\\n\\u00a0     properties.reserve(quadrature.size() *\\n\\u00a0                        solid_tria.n_locally_owned_active_cells());\\n\\u00a0 \\n\\u00a0     FEValues<dim, spacedim> fe_v(*solid_fe,\\n\\u00a0                                  quadrature,\\n\\u00a0                                  update_JxW_values | update_quadrature_points);\\n\\u00a0     for (const auto &cell : solid_dh.active_cell_iterators())\\n\\u00a0       if (cell->is_locally_owned())\\n\\u00a0         {\\n\\u00a0           fe_v.reinit(cell);\\n\\u00a0           const auto &points = fe_v.get_quadrature_points();\\n\\u00a0           const auto &JxW    = fe_v.get_JxW_values();\\n\\u00a0 \\n\\u00a0           for (unsigned int q = 0; q < points.size(); ++q)\\n\\u00a0             {\\n\\u00a0               quadrature_points_vec.emplace_back(points[q]);\\n\\u00a0               properties.emplace_back(\\n\\u00a0                 std::vector<double>(n_properties, JxW[q]));\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0 \\nFEValuesDefinition fe_values.h:63\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nWe proceed in the same way we did with the tracer particles, reusing the computed bounding boxes. However, we first check that the global_fluid_bounding_boxes object has been actually filled. This should certainly be the case here, since this method is called after the one that initializes the tracer particles. However, we want to make sure that if in the future someone decides (for whatever reason) to initialize first the solid particle handler, or to copy just this part of the tutorial, a meaningful exception is thrown when things don't work as expected\\nSince we have already stored the position of the quadrature points, we can use these positions to insert the particles directly using the solid_particle_handler instead of having to go through a Particles::Generators function:\\n\\u00a0     Assert(!global_fluid_bounding_boxes.empty(),\\n\\u00a0            ExcInternalError(\\n\\u00a0              \\\"I was expecting the \\\"\\n\\u00a0              \\\"global_fluid_bounding_boxes to be filled at this stage. \\\"\\n\\u00a0              \\\"Make sure you fill this vector before trying to use it \\\"\\n\\u00a0              \\\"here. Bailing out.\\\"));\\n\\u00a0 \\n\\u00a0     solid_particle_handler.insert_global_particles(quadrature_points_vec,\\n\\u00a0                                                    global_fluid_bounding_boxes,\\n\\u00a0                                                    properties);\\n\\u00a0 \\n\\u00a0     pcout << \\\"Solid particles: \\\" << solid_particle_handler.n_global_particles()\\n\\u00a0           << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n DoF initialization functions\\nWe set up the finite element space and the quadrature formula to be used throughout the step. For the fluid, we use Taylor-Hood elements (e.g. \\\\(Q_k \\\\times Q_{k-1}\\\\)). Since we do not solve any equation on the solid domain, an empty finite element space is generated. A natural extension of this program would be to solve a fluid structure interaction problem, which would require that the solid_fe use more useful FiniteElement class.\\nLike for many other functions, we store the time necessary to carry out the operations we perform here. The current function puts its timing information into a section with label \\\"Initial setup\\\". Numerous other calls to this timer are made in various functions. They allow to monitor the absolute and relative cost of each individual function to identify bottlenecks.\\n\\u00a0   template <int dim, int spacedim>\\n\\u00a0   void StokesImmersedProblem<dim, spacedim>::initial_setup()\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope t(computing_timer, \\\"Initial setup\\\");\\n\\u00a0 \\n\\u00a0     fluid_fe = std::make_unique<FESystem<spacedim>>(\\n\\u00a0       FE_Q<spacedim>(par.velocity_degree) ^ spacedim,\\n\\u00a0       FE_Q<spacedim>(par.velocity_degree - 1));\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     solid_fe = std::make_unique<FE_Nothing<dim, spacedim>>();\\n\\u00a0     solid_dh.distribute_dofs(*solid_fe);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nTimerOutput::ScopeDefinition timer.h:557\\nWe next construct the distributed block matrices and vectors which are used to solve the linear equations that arise from the problem. This function is adapted from step-55 and we refer to this step for a thorough explanation.\\n\\u00a0   template <int dim, int spacedim>\\n\\u00a0   void StokesImmersedProblem<dim, spacedim>::setup_dofs()\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope t(computing_timer, \\\"Setup dofs\\\");\\n\\u00a0 \\n\\u00a0     fluid_dh.distribute_dofs(*fluid_fe);\\n\\u00a0 \\n\\u00a0     std::vector<unsigned int> stokes_sub_blocks(spacedim + 1, 0);\\n\\u00a0     stokes_sub_blocks[spacedim] = 1;\\n\\u00a0     DoFRenumbering::component_wise(fluid_dh, stokes_sub_blocks);\\n\\u00a0 \\n\\u00a0     auto dofs_per_block =\\n\\u00a0       DoFTools::count_dofs_per_fe_block(fluid_dh, stokes_sub_blocks);\\n\\u00a0 \\n\\u00a0     const unsigned int n_u = dofs_per_block[0], n_p = dofs_per_block[1];\\n\\u00a0 \\n\\u00a0     pcout << \\\"   Number of degrees of freedom: \\\" << fluid_dh.n_dofs() << \\\" (\\\"\\n\\u00a0           << n_u << '+' << n_p << \\\" -- \\\"\\n\\u00a0           << solid_particle_handler.n_global_particles() << '+'\\n\\u00a0           << tracer_particle_handler.n_global_particles() << ')' << std::endl;\\n\\u00a0 \\n\\u00a0     fluid_owned_dofs.resize(2);\\n\\u00a0     fluid_owned_dofs[0] = fluid_dh.locally_owned_dofs().get_view(0, n_u);\\n\\u00a0     fluid_owned_dofs[1] =\\n\\u00a0       fluid_dh.locally_owned_dofs().get_view(n_u, n_u + n_p);\\n\\u00a0 \\n\\u00a0     const IndexSet locally_relevant_dofs =\\n\\u00a0       DoFTools::extract_locally_relevant_dofs(fluid_dh);\\n\\u00a0     fluid_relevant_dofs.resize(2);\\n\\u00a0     fluid_relevant_dofs[0] = locally_relevant_dofs.get_view(0, n_u);\\n\\u00a0     fluid_relevant_dofs[1] = locally_relevant_dofs.get_view(n_u, n_u + n_p);\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       constraints.reinit(fluid_dh.locally_owned_dofs(), locally_relevant_dofs);\\n\\u00a0 \\n\\u00a0       const FEValuesExtractors::Vector velocities(0);\\n\\u00a0       DoFTools::make_hanging_node_constraints(fluid_dh, constraints);\\n\\u00a0       VectorTools::interpolate_boundary_values(\\n\\u00a0         fluid_dh,\\n\\u00a0         0,\\n\\u00a0         Functions::ZeroFunction<spacedim>(spacedim + 1),\\n\\u00a0         constraints,\\n\\u00a0         fluid_fe->component_mask(velocities));\\n\\u00a0       constraints.close();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     const auto locally_owned_dofs_per_processor =\\n\\u00a0       Utilities::MPI::all_gather(mpi_communicator,\\n\\u00a0                                  fluid_dh.locally_owned_dofs());\\n\\u00a0     {\\n\\u00a0       system_matrix.clear();\\n\\u00a0 \\n\\u00a0       Table<2, DoFTools::Coupling> coupling(spacedim + 1, spacedim + 1);\\n\\u00a0       for (unsigned int c = 0; c < spacedim + 1; ++c)\\n\\u00a0         for (unsigned int d = 0; d < spacedim + 1; ++d)\\n\\u00a0           if (c == spacedim && d == spacedim)\\n\\u00a0             coupling[c][d] = DoFTools::none;\\n\\u00a0           else if (c == spacedim || d == spacedim || c == d)\\n\\u00a0             coupling[c][d] = DoFTools::always;\\n\\u00a0           else\\n\\u00a0             coupling[c][d] = DoFTools::none;\\n\\u00a0 \\n\\u00a0       BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block);\\n\\u00a0 \\n\\u00a0       DoFTools::make_sparsity_pattern(\\n\\u00a0         fluid_dh, coupling, dsp, constraints, false);\\n\\u00a0 \\n\\u00a0       SparsityTools::distribute_sparsity_pattern(\\n\\u00a0         dsp,\\n\\u00a0         locally_owned_dofs_per_processor,\\n\\u00a0         mpi_communicator,\\n\\u00a0         locally_relevant_dofs);\\n\\u00a0 \\n\\u00a0       system_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       preconditioner_matrix.clear();\\n\\u00a0 \\n\\u00a0       Table<2, DoFTools::Coupling> coupling(spacedim + 1, spacedim + 1);\\n\\u00a0       for (unsigned int c = 0; c < spacedim + 1; ++c)\\n\\u00a0         for (unsigned int d = 0; d < spacedim + 1; ++d)\\n\\u00a0           if (c == spacedim && d == spacedim)\\n\\u00a0             coupling[c][d] = DoFTools::always;\\n\\u00a0           else\\n\\u00a0             coupling[c][d] = DoFTools::none;\\n\\u00a0 \\n\\u00a0       BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block);\\n\\u00a0 \\n\\u00a0       DoFTools::make_sparsity_pattern(\\n\\u00a0         fluid_dh, coupling, dsp, constraints, false);\\n\\u00a0       SparsityTools::distribute_sparsity_pattern(\\n\\u00a0         dsp,\\n\\u00a0         locally_owned_dofs_per_processor,\\n\\u00a0         mpi_communicator,\\n\\u00a0         locally_relevant_dofs);\\n\\u00a0       preconditioner_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     locally_relevant_solution.reinit(fluid_owned_dofs,\\n\\u00a0                                      fluid_relevant_dofs,\\n\\u00a0                                      mpi_communicator);\\n\\u00a0     system_rhs.reinit(fluid_owned_dofs, mpi_communicator);\\n\\u00a0     solution.reinit(fluid_owned_dofs, mpi_communicator);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nBlockDynamicSparsityPatternDefinition block_sparsity_pattern.h:549\\nFunctions::ZeroFunctionDefinition function.h:510\\nTableDefinition array_view.h:39\\nDoFTools::make_hanging_node_constraintsvoid make_hanging_node_constraints(const DoFHandler< dim, spacedim > &dof_handler, AffineConstraints< number > &constraints)Definition dof_tools_constraints.cc:3073\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nDoFRenumbering::component_wisevoid component_wise(DoFHandler< dim, spacedim > &dof_handler, const std::vector< unsigned int > &target_component=std::vector< unsigned int >())Definition dof_renumbering.cc:666\\nDoFTools::extract_locally_relevant_dofsIndexSet extract_locally_relevant_dofs(const DoFHandler< dim, spacedim > &dof_handler)Definition dof_tools.cc:1164\\nDoFTools::count_dofs_per_fe_blockstd::vector< types::global_dof_index > count_dofs_per_fe_block(const DoFHandler< dim, spacedim > &dof, const std::vector< unsigned int > &target_block=std::vector< unsigned int >())Definition dof_tools.cc:2104\\nDoFTools::none@ noneDefinition dof_tools.h:243\\nDoFTools::always@ alwaysDefinition dof_tools.h:247\\nPhysics::Elasticity::Kinematics::dSymmetricTensor< 2, dim, Number > d(const Tensor< 2, dim, Number > &F, const Tensor< 2, dim, Number > &dF_dt)\\nSparsityTools::distribute_sparsity_patternvoid distribute_sparsity_pattern(DynamicSparsityPattern &dsp, const IndexSet &locally_owned_rows, const MPI_Comm mpi_comm, const IndexSet &locally_relevant_rows)Definition sparsity_tools.cc:1020\\nVectorTools::interpolate_boundary_valuesvoid interpolate_boundary_values(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const std::map< types::boundary_id, const Function< spacedim, number > * > &function_map, std::map< types::global_dof_index, number > &boundary_values, const ComponentMask &component_mask={})\\nFEValuesExtractors::VectorDefinition fe_values_extractors.h:150\\n Assembly functions\\nWe assemble the system matrix, the preconditioner matrix, and the right hand side. The code is adapted from step-55, which is essentially what step-27 also has, and is pretty standard if you know what the Stokes equations look like.\\n\\u00a0   template <int dim, int spacedim>\\n\\u00a0   void StokesImmersedProblem<dim, spacedim>::assemble_stokes_system()\\n\\u00a0   {\\n\\u00a0     system_matrix         = 0;\\n\\u00a0     preconditioner_matrix = 0;\\n\\u00a0     system_rhs            = 0;\\n\\u00a0 \\n\\u00a0     TimerOutput::Scope t(computing_timer, \\\"Assemble Stokes terms\\\");\\n\\u00a0 \\n\\u00a0     const QGauss<spacedim> quadrature_formula(fluid_fe->degree + 1);\\n\\u00a0     FEValues<spacedim>     fe_values(*fluid_fe,\\n\\u00a0                                  quadrature_formula,\\n\\u00a0                                  update_values | update_gradients |\\n\\u00a0                                    update_quadrature_points |\\n\\u00a0                                    update_JxW_values);\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell = fluid_fe->n_dofs_per_cell();\\n\\u00a0     const unsigned int n_q_points    = quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0     FullMatrix<double> cell_matrix2(dofs_per_cell, dofs_per_cell);\\n\\u00a0     Vector<double>     cell_rhs(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     std::vector<Vector<double>> rhs_values(n_q_points,\\n\\u00a0                                            Vector<double>(spacedim + 1));\\n\\u00a0 \\n\\u00a0     std::vector<Tensor<2, spacedim>> grad_phi_u(dofs_per_cell);\\n\\u00a0     std::vector<double>              div_phi_u(dofs_per_cell);\\n\\u00a0     std::vector<double>              phi_p(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0     const FEValuesExtractors::Vector     velocities(0);\\n\\u00a0     const FEValuesExtractors::Scalar     pressure(spacedim);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : fluid_dh.active_cell_iterators())\\n\\u00a0       if (cell->is_locally_owned())\\n\\u00a0         {\\n\\u00a0           cell_matrix  = 0;\\n\\u00a0           cell_matrix2 = 0;\\n\\u00a0           cell_rhs     = 0;\\n\\u00a0 \\n\\u00a0           fe_values.reinit(cell);\\n\\u00a0           par.rhs.vector_value_list(fe_values.get_quadrature_points(),\\n\\u00a0                                     rhs_values);\\n\\u00a0           for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0             {\\n\\u00a0               for (unsigned int k = 0; k < dofs_per_cell; ++k)\\n\\u00a0                 {\\n\\u00a0                   grad_phi_u[k] = fe_values[velocities].gradient(k, q);\\n\\u00a0                   div_phi_u[k]  = fe_values[velocities].divergence(k, q);\\n\\u00a0                   phi_p[k]      = fe_values[pressure].value(k, q);\\n\\u00a0                 }\\n\\u00a0 \\n\\u00a0               for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0                 {\\n\\u00a0                   for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0                     {\\n\\u00a0                       cell_matrix(i, j) +=\\n\\u00a0                         (par.viscosity *\\n\\u00a0                            scalar_product(grad_phi_u[i], grad_phi_u[j]) -\\n\\u00a0                          div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *\\n\\u00a0                         fe_values.JxW(q);\\n\\u00a0 \\n\\u00a0                       cell_matrix2(i, j) += 1.0 / par.viscosity * phi_p[i] *\\n\\u00a0                                             phi_p[j] * fe_values.JxW(q);\\n\\u00a0                     }\\n\\u00a0 \\n\\u00a0                   const unsigned int component_i =\\n\\u00a0                     fluid_fe->system_to_component_index(i).first;\\n\\u00a0                   cell_rhs(i) += fe_values.shape_value(i, q) *\\n\\u00a0                                  rhs_values[q](component_i) * fe_values.JxW(q);\\n\\u00a0                 }\\n\\u00a0             }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0           cell->get_dof_indices(local_dof_indices);\\n\\u00a0           constraints.distribute_local_to_global(cell_matrix,\\n\\u00a0                                                  cell_rhs,\\n\\u00a0                                                  local_dof_indices,\\n\\u00a0                                                  system_matrix,\\n\\u00a0                                                  system_rhs);\\n\\u00a0 \\n\\u00a0           constraints.distribute_local_to_global(cell_matrix2,\\n\\u00a0                                                  local_dof_indices,\\n\\u00a0                                                  preconditioner_matrix);\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0     system_matrix.compress(VectorOperation::add);\\n\\u00a0     preconditioner_matrix.compress(VectorOperation::add);\\n\\u00a0     system_rhs.compress(VectorOperation::add);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nFullMatrixDefinition full_matrix.h:79\\nVectorDefinition vector.h:120\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nFEValuesExtractors::ScalarDefinition fe_values_extractors.h:95\\nVectorOperation::add@ addDefinition vector_operation.h:53\\nThe following method is then the one that deals with the penalty terms that result from imposing the velocity on the impeller. It is, in a sense, the heart of the tutorial, but it is relatively straightforward. Here we exploit the solid_particle_handler to compute the Nitsche restriction or the penalization in the embedded domain.\\n\\u00a0   template <int dim, int spacedim>\\n\\u00a0   void StokesImmersedProblem<dim, spacedim>::assemble_nitsche_restriction()\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope t(computing_timer, \\\"Assemble Nitsche terms\\\");\\n\\u00a0 \\n\\u00a0     const FEValuesExtractors::Vector velocities(0);\\n\\u00a0     const FEValuesExtractors::Scalar pressure(spacedim);\\n\\u00a0 \\n\\u00a0     SolidVelocity<spacedim> solid_velocity(par.angular_velocity);\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> fluid_dof_indices(\\n\\u00a0       fluid_fe->n_dofs_per_cell());\\n\\u00a0 \\n\\u00a0     FullMatrix<double> local_matrix(fluid_fe->n_dofs_per_cell(),\\n\\u00a0                                     fluid_fe->n_dofs_per_cell());\\n\\u00a0     Vector<double>     local_rhs(fluid_fe->n_dofs_per_cell());\\n\\u00a0 \\n\\u00a0     const auto penalty_parameter =\\n\\u00a0       1.0 / GridTools::minimal_cell_diameter(fluid_tria);\\n\\u00a0 \\nGridTools::minimal_cell_diameterdouble minimal_cell_diameter(const Triangulation< dim, spacedim > &triangulation, const Mapping< dim, spacedim > &mapping=(ReferenceCells::get_hypercube< dim >() .template get_default_linear_mapping< dim, spacedim >()))Definition grid_tools_geometry.cc:407\\nWe loop over all the local particles. Although this could be achieved directly by looping over all the cells, this would force us to loop over numerous cells which do not contain particles. Consequently, we loop over all the particles, but, we get the reference of the cell in which the particle lies and then loop over all particles within that cell. This enables us to skip the cells which do not contain particles, yet to assemble the local matrix and rhs of each cell to apply the Nitsche restriction. Once we are done with all particles on one cell, we advance the particle iterator to the particle past the end of the ones on the current cell (this is the last line of the while loop's body).\\n\\u00a0     auto particle = solid_particle_handler.begin();\\n\\u00a0     while (particle != solid_particle_handler.end())\\n\\u00a0       {\\n\\u00a0         local_matrix = 0;\\n\\u00a0         local_rhs    = 0;\\n\\u00a0 \\nWe get an iterator to the cell within which the particle lies from the particle itself. We can then assemble the additional terms in the system matrix and the right hand side as we would normally.\\n\\u00a0         const auto &cell = particle->get_surrounding_cell();\\n\\u00a0         const auto &dh_cell =\\n\\u00a0           typename DoFHandler<spacedim>::cell_iterator(*cell, &fluid_dh);\\n\\u00a0         dh_cell->get_dof_indices(fluid_dof_indices);\\n\\u00a0 \\nDoFHandler::cell_iteratortypename ActiveSelector::cell_iterator cell_iteratorDefinition dof_handler.h:468\\nSo then let us get the collection of cells that are located on this cell and iterate over them. From each particle we gather the location and the reference location of the particle as well as the additional information that is attached to the particle. In the present case, this information is the \\\"JxW\\\" of the quadrature points which were used to generate the particles.\\nUsing this information, we can add the contribution of the quadrature point to the local_matrix and local_rhs. We can evaluate the value of the shape function at the position of each particle easily by using its reference location.\\n\\u00a0         const auto pic = solid_particle_handler.particles_in_cell(cell);\\n\\u00a0         Assert(pic.begin() == particle, ExcInternalError());\\n\\u00a0         for (const auto &p : pic)\\n\\u00a0           {\\n\\u00a0             const Point<spacedim> ref_q  = p.get_reference_location();\\n\\u00a0             const Point<spacedim> real_q = p.get_location();\\n\\u00a0             const double          JxW    = p.get_properties()[0];\\n\\u00a0 \\n\\u00a0             for (unsigned int i = 0; i < fluid_fe->n_dofs_per_cell(); ++i)\\n\\u00a0               {\\n\\u00a0                 const auto comp_i =\\n\\u00a0                   fluid_fe->system_to_component_index(i).first;\\n\\u00a0                 if (comp_i < spacedim)\\n\\u00a0                   {\\n\\u00a0                     for (unsigned int j = 0; j < fluid_fe->n_dofs_per_cell();\\n\\u00a0                          ++j)\\n\\u00a0                       {\\n\\u00a0                         const auto comp_j =\\n\\u00a0                           fluid_fe->system_to_component_index(j).first;\\n\\u00a0                         if (comp_i == comp_j)\\n\\u00a0                           local_matrix(i, j) +=\\n\\u00a0                             penalty_parameter * par.penalty_term *\\n\\u00a0                             fluid_fe->shape_value(i, ref_q) *\\n\\u00a0                             fluid_fe->shape_value(j, ref_q) * JxW;\\n\\u00a0                       }\\n\\u00a0                     local_rhs(i) += penalty_parameter * par.penalty_term *\\n\\u00a0                                     solid_velocity.value(real_q, comp_i) *\\n\\u00a0                                     fluid_fe->shape_value(i, ref_q) * JxW;\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         constraints.distribute_local_to_global(local_matrix,\\n\\u00a0                                                local_rhs,\\n\\u00a0                                                fluid_dof_indices,\\n\\u00a0                                                system_matrix,\\n\\u00a0                                                system_rhs);\\n\\u00a0         particle = pic.end();\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     system_matrix.compress(VectorOperation::add);\\n\\u00a0     system_rhs.compress(VectorOperation::add);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n Solving the linear system\\nThis function solves the linear system with FGMRES with a block diagonal preconditioner and an algebraic multigrid (AMG) method for the diagonal blocks. The preconditioner applies a V cycle to the \\\\((0,0)\\\\) (i.e., the velocity-velocity) block and a CG with the mass matrix for the \\\\((1,1)\\\\) block (which is our approximation to the Schur complement: the pressure mass matrix assembled above).\\n\\u00a0   template <int dim, int spacedim>\\n\\u00a0   void StokesImmersedProblem<dim, spacedim>::solve()\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope t(computing_timer, \\\"Solve\\\");\\n\\u00a0 \\n\\u00a0     LA::MPI::PreconditionAMG prec_A;\\n\\u00a0     {\\n\\u00a0       LA::MPI::PreconditionAMG::AdditionalData data;\\n\\u00a0 \\n\\u00a0 #ifdef USE_PETSC_LA\\n\\u00a0       data.symmetric_operator = true;\\n\\u00a0 #endif\\n\\u00a0       prec_A.initialize(system_matrix.block(0, 0), data);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     LA::MPI::PreconditionAMG prec_S;\\n\\u00a0     {\\n\\u00a0       LA::MPI::PreconditionAMG::AdditionalData data;\\n\\u00a0 \\n\\u00a0 #ifdef USE_PETSC_LA\\n\\u00a0       data.symmetric_operator = true;\\n\\u00a0 #endif\\n\\u00a0       prec_S.initialize(preconditioner_matrix.block(1, 1), data);\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     const auto A = linear_operator<LA::MPI::Vector>(system_matrix.block(0, 0));\\n\\u00a0     const auto amgA = linear_operator(A, prec_A);\\n\\u00a0 \\n\\u00a0     const auto S =\\n\\u00a0       linear_operator<LA::MPI::Vector>(preconditioner_matrix.block(1, 1));\\n\\u00a0     const auto amgS = linear_operator(S, prec_S);\\n\\u00a0 \\n\\u00a0     ReductionControl          inner_solver_control(100,\\n\\u00a0                                           1e-8 * system_rhs.l2_norm(),\\n\\u00a0                                           1.e-2);\\n\\u00a0     SolverCG<LA::MPI::Vector> cg(inner_solver_control);\\n\\u00a0 \\n\\u00a0     const auto invS = inverse_operator(S, cg, amgS);\\n\\u00a0 \\n\\u00a0     const auto P = block_diagonal_operator<2, LA::MPI::BlockVector>(\\n\\u00a0       std::array<LinearOperator<typename LA::MPI::BlockVector::BlockType>, 2>{\\n\\u00a0         {amgA, amgS}});\\n\\u00a0 \\n\\u00a0     SolverControl solver_control(system_matrix.m(),\\n\\u00a0                                  1e-10 * system_rhs.l2_norm());\\n\\u00a0 \\n\\u00a0     SolverFGMRES<LA::MPI::BlockVector> solver(solver_control);\\n\\u00a0 \\n\\u00a0     constraints.set_zero(solution);\\n\\u00a0 \\n\\u00a0     solver.solve(system_matrix, solution, system_rhs, P);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     pcout << \\\"   Solved in \\\" << solver_control.last_step() << \\\" iterations.\\\"\\n\\u00a0           << std::endl;\\n\\u00a0 \\n\\u00a0     constraints.distribute(solution);\\n\\u00a0 \\n\\u00a0     locally_relevant_solution = solution;\\n\\u00a0     const double mean_pressure =\\n\\u00a0       VectorTools::compute_mean_value(fluid_dh,\\n\\u00a0                                       QGauss<spacedim>(par.velocity_degree + 2),\\n\\u00a0                                       locally_relevant_solution,\\n\\u00a0                                       spacedim);\\n\\u00a0     solution.block(1).add(-mean_pressure);\\n\\u00a0     locally_relevant_solution.block(1) = solution.block(1);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nLinearOperatorDefinition linear_operator.h:201\\nReductionControlDefinition solver_control.h:424\\nSolverCGDefinition solver_cg.h:179\\nSolverControlDefinition solver_control.h:67\\nSolverFGMRESDefinition solver_gmres.h:648\\nblock_diagonal_operatorBlockLinearOperator< Range, Domain, BlockPayload > block_diagonal_operator(const std::array< LinearOperator< typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType >, m > &)Definition block_linear_operator.h:761\\ninverse_operatorLinearOperator< Domain, Range, Payload > inverse_operator(const LinearOperator< Range, Domain, Payload > &op, Solver &solver, const Preconditioner &preconditioner)Definition linear_operator.h:720\\nVectorTools::compute_mean_valueNumber compute_mean_value(const hp::MappingCollection< dim, spacedim > &mapping_collection, const DoFHandler< dim, spacedim > &dof, const hp::QCollection< dim > &q_collection, const ReadVector< Number > &v, const unsigned int component)\\n Mesh refinement\\nWe deal with mesh refinement in a completely standard way, except we now also transfer the particles of the two particle handlers from the existing to the refined mesh. When performing local refinement or coarsening, particles will land in another cell. We could in principle redistribute all particles after refining, however this would be overly expensive.\\nThe Particles::ParticleHandler class has a way to transfer information from a cell to its children or to its parent upon refinement, without the need to reconstruct the entire data structure. This is done similarly to the SolutionTransfer class by calling two functions, one to prepare for refinement, and one to transfer the information after refinement.\\n\\u00a0   template <int dim, int spacedim>\\n\\u00a0   void StokesImmersedProblem<dim, spacedim>::refine_and_transfer()\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope               t(computing_timer, \\\"Refine\\\");\\n\\u00a0     const FEValuesExtractors::Vector velocity(0);\\n\\u00a0 \\n\\u00a0     Vector<float> error_per_cell(fluid_tria.n_active_cells());\\n\\u00a0     KellyErrorEstimator<spacedim>::estimate(fluid_dh,\\n\\u00a0                                             QGauss<spacedim - 1>(\\n\\u00a0                                               par.velocity_degree + 1),\\n\\u00a0                                             {},\\n\\u00a0                                             locally_relevant_solution,\\n\\u00a0                                             error_per_cell,\\n\\u00a0                                             fluid_fe->component_mask(velocity));\\n\\u00a0 \\n\\u00a0     if (par.refinement_strategy == \\\"fixed_fraction\\\")\\n\\u00a0       {\\n\\u00a0         parallel::distributed::GridRefinement::\\n\\u00a0           refine_and_coarsen_fixed_fraction(fluid_tria,\\n\\u00a0                                             error_per_cell,\\n\\u00a0                                             par.refinement_fraction,\\n\\u00a0                                             par.coarsening_fraction);\\n\\u00a0       }\\n\\u00a0     else if (par.refinement_strategy == \\\"fixed_number\\\")\\n\\u00a0       {\\n\\u00a0         parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number(\\n\\u00a0           fluid_tria,\\n\\u00a0           error_per_cell,\\n\\u00a0           par.refinement_fraction,\\n\\u00a0           par.coarsening_fraction,\\n\\u00a0           par.max_cells);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     for (const auto &cell : fluid_tria.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         if (cell->refine_flag_set() &&\\n\\u00a0             cell->level() == par.max_level_refinement)\\n\\u00a0           cell->clear_refine_flag();\\n\\u00a0         if (cell->coarsen_flag_set() &&\\n\\u00a0             cell->level() == par.min_level_refinement)\\n\\u00a0           cell->clear_coarsen_flag();\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     parallel::distributed::SolutionTransfer<spacedim, LA::MPI::BlockVector>\\n\\u00a0       transfer(fluid_dh);\\n\\u00a0 \\n\\u00a0     fluid_tria.prepare_coarsening_and_refinement();\\n\\u00a0     transfer.prepare_for_coarsening_and_refinement(locally_relevant_solution);\\n\\u00a0     tracer_particle_handler.prepare_for_coarsening_and_refinement();\\n\\u00a0     solid_particle_handler.prepare_for_coarsening_and_refinement();\\n\\u00a0 \\n\\u00a0     fluid_tria.execute_coarsening_and_refinement();\\n\\u00a0 \\n\\u00a0     setup_dofs();\\n\\u00a0 \\n\\u00a0     transfer.interpolate(solution);\\n\\u00a0     tracer_particle_handler.unpack_after_coarsening_and_refinement();\\n\\u00a0     solid_particle_handler.unpack_after_coarsening_and_refinement();\\n\\u00a0 \\n\\u00a0     constraints.distribute(solution);\\n\\u00a0     locally_relevant_solution = solution;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nKellyErrorEstimator::estimatestatic void estimate(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const Quadrature< dim - 1 > &quadrature, const std::map< types::boundary_id, const Function< spacedim, Number > * > &neumann_bc, const ReadVector< Number > &solution, Vector< float > &error, const ComponentMask &component_mask={}, const Function< spacedim > *coefficients=nullptr, const unsigned int n_threads=numbers::invalid_unsigned_int, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id, const types::material_id material_id=numbers::invalid_material_id, const Strategy strategy=cell_diameter_over_24)\\nparallel::distributed::SolutionTransferDefinition solution_transfer.h:224\\nlevelunsigned int levelDefinition grid_out.cc:4626\\nparallel::distributed::GridRefinement::refine_and_coarsen_fixed_numbervoid refine_and_coarsen_fixed_number(::Triangulation< dim, spacedim > &tria, const ::Vector< Number > &criteria, const double top_fraction_of_cells, const double bottom_fraction_of_cells, const types::global_cell_index max_n_cells=std::numeric_limits< types::global_cell_index >::max())Definition grid_refinement.cc:503\\n Creating output for visualization\\nWe output the results (velocity and pressure) on the fluid domain using the standard parallel capabilities of deal.II. A single compressed vtu file is written that agglomerates the information of all processors. An additional .pvd record is written to associate the physical time to the vtu files.\\n\\u00a0   template <int dim, int spacedim>\\n\\u00a0   void\\n\\u00a0   StokesImmersedProblem<dim, spacedim>::output_results(const unsigned int cycle,\\n\\u00a0                                                        double time) const\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope t(computing_timer, \\\"Output fluid\\\");\\n\\u00a0 \\n\\u00a0     std::vector<std::string> solution_names(spacedim, \\\"velocity\\\");\\n\\u00a0     solution_names.emplace_back(\\\"pressure\\\");\\n\\u00a0     std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n\\u00a0       data_component_interpretation(\\n\\u00a0         spacedim, DataComponentInterpretation::component_is_part_of_vector);\\n\\u00a0     data_component_interpretation.push_back(\\n\\u00a0       DataComponentInterpretation::component_is_scalar);\\n\\u00a0 \\n\\u00a0     DataOut<spacedim> data_out;\\n\\u00a0     data_out.attach_dof_handler(fluid_dh);\\n\\u00a0     data_out.add_data_vector(locally_relevant_solution,\\n\\u00a0                              solution_names,\\n\\u00a0                              DataOut<spacedim>::type_dof_data,\\n\\u00a0                              data_component_interpretation);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     Vector<float> subdomain(fluid_tria.n_active_cells());\\n\\u00a0     for (unsigned int i = 0; i < subdomain.size(); ++i)\\n\\u00a0       subdomain(i) = fluid_tria.locally_owned_subdomain();\\n\\u00a0     data_out.add_data_vector(subdomain, \\\"subdomain\\\");\\n\\u00a0 \\n\\u00a0     data_out.build_patches();\\n\\u00a0 \\n\\u00a0     const std::string filename =\\n\\u00a0       \\\"solution-\\\" + Utilities::int_to_string(cycle) + \\\".vtu\\\";\\n\\u00a0     data_out.write_vtu_in_parallel(par.output_directory + \\\"/\\\" + filename,\\n\\u00a0                                    mpi_communicator);\\n\\u00a0 \\n\\u00a0     static std::vector<std::pair<double, std::string>> times_and_names;\\n\\u00a0     times_and_names.emplace_back(time, filename);\\n\\u00a0     std::ofstream ofile(par.output_directory + \\\"/\\\" + \\\"solution.pvd\\\");\\n\\u00a0     DataOutBase::write_pvd_record(ofile, times_and_names);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nDataComponentInterpretation::component_is_scalar@ component_is_scalarDefinition data_component_interpretation.h:52\\nDataComponentInterpretation::component_is_part_of_vector@ component_is_part_of_vectorDefinition data_component_interpretation.h:58\\nDataOutBase::write_pvd_recordvoid write_pvd_record(std::ostream &out, const std::vector< std::pair< double, std::string > > &times_and_names)Definition data_out_base.cc:6256\\nUtilities::int_to_stringstd::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)Definition utilities.cc:470\\nSimilarly, we write the particles (either from the solid or the tracers) as a single compressed vtu file through the Particles::DataOut object. This simple object does not write the additional information attached as \\\"properties\\\" to the particles, but only writes their id \\u2013 but then, we don't care about the \\\"JxW\\\" values of these particle locations anyway, so no information that we may have wanted to visualize is lost.\\n\\u00a0   template <int dim, int spacedim>\\n\\u00a0   void StokesImmersedProblem<dim, spacedim>::output_particles(\\n\\u00a0     const Particles::ParticleHandler<spacedim> &particles,\\n\\u00a0     std::string                                 fprefix,\\n\\u00a0     const unsigned int                          iter,\\n\\u00a0     const double                                time) const\\n\\u00a0   {\\n\\u00a0     Particles::DataOut<spacedim> particles_out;\\n\\u00a0     particles_out.build_patches(particles);\\n\\u00a0     const std::string filename =\\n\\u00a0       (fprefix + \\\"-\\\" + Utilities::int_to_string(iter) + \\\".vtu\\\");\\n\\u00a0     particles_out.write_vtu_in_parallel(par.output_directory + \\\"/\\\" + filename,\\n\\u00a0                                         mpi_communicator);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     static std::map<std::string, std::vector<std::pair<double, std::string>>>\\n\\u00a0       times_and_names;\\n\\u00a0     if (times_and_names.find(fprefix) != times_and_names.end())\\n\\u00a0       times_and_names[fprefix].emplace_back(time, filename);\\n\\u00a0     else\\n\\u00a0       times_and_names[fprefix] = {std::make_pair(time, filename)};\\n\\u00a0     std::ofstream ofile(par.output_directory + \\\"/\\\" + fprefix + \\\".pvd\\\");\\n\\u00a0     DataOutBase::write_pvd_record(ofile, times_and_names[fprefix]);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nParticles::DataOutDefinition data_out.h:44\\nParticles::DataOut::build_patchesvoid build_patches(const Particles::ParticleHandler< dim, spacedim > &particles, const std::vector< std::string > &data_component_names={}, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretations={})Definition data_out.cc:27\\n The \\\"run\\\" function\\nThis function now orchestrates the entire simulation. It is very similar to the other time dependent tutorial programs \\u2013 take step-21 or step-26 as an example. At the beginning, we output some status information and also save all current parameters to a file in the output directory, for reproducibility.\\n\\u00a0   template <int dim, int spacedim>\\n\\u00a0   void StokesImmersedProblem<dim, spacedim>::run()\\n\\u00a0   {\\n\\u00a0 #ifdef USE_PETSC_LA\\n\\u00a0     pcout << \\\"Running StokesImmersedProblem<\\\"\\n\\u00a0           << Utilities::dim_string(dim, spacedim) << \\\"> using PETSc.\\\"\\n\\u00a0           << std::endl;\\n\\u00a0 #else\\n\\u00a0     pcout << \\\"Running StokesImmersedProblem<\\\"\\n\\u00a0           << Utilities::dim_string(dim, spacedim) << \\\"> using Trilinos.\\\"\\n\\u00a0           << std::endl;\\n\\u00a0 #endif\\n\\u00a0     par.prm.print_parameters(par.output_directory + \\\"/\\\" + \\\"used_parameters_\\\" +\\n\\u00a0                                std::to_string(dim) + std::to_string(spacedim) +\\n\\u00a0                                \\\".prm\\\",\\n\\u00a0                              ParameterHandler::Short);\\n\\u00a0 \\nParameterHandler::Short@ ShortDefinition parameter_handler.h:884\\nUtilities::dim_stringstd::string dim_string(const int dim, const int spacedim)Definition utilities.cc:555\\nWe then start the time loop. We initialize all the elements of the simulation in the first cycle\\n\\u00a0     const double time_step    = par.final_time / (par.number_of_time_steps - 1);\\n\\u00a0     double       time         = 0;\\n\\u00a0     unsigned int output_cycle = 0;\\n\\u00a0 \\n\\u00a0     for (unsigned int cycle = 0; cycle < par.number_of_time_steps;\\n\\u00a0          ++cycle, time += time_step)\\n\\u00a0       {\\n\\u00a0         par.set_time(time);\\n\\u00a0         pcout << \\\"Cycle \\\" << cycle << ':' << std::endl\\n\\u00a0               << \\\"Time : \\\" << time << \\\", time step: \\\" << time_step << std::endl;\\n\\u00a0 \\n\\u00a0         if (cycle == 0)\\n\\u00a0           {\\n\\u00a0             make_grid();\\n\\u00a0             initial_setup();\\n\\u00a0             setup_dofs();\\n\\u00a0             setup_tracer_particles();\\n\\u00a0             setup_solid_particles();\\n\\u00a0             tracer_particle_velocities.reinit(\\n\\u00a0               locally_owned_tracer_particle_coordinates, mpi_communicator);\\n\\u00a0             output_results(output_cycle, time);\\n\\u00a0             {\\n\\u00a0               TimerOutput::Scope t(computing_timer, \\\"Output tracer particles\\\");\\n\\u00a0               output_particles(tracer_particle_handler,\\n\\u00a0                                \\\"tracer\\\",\\n\\u00a0                                output_cycle,\\n\\u00a0                                time);\\n\\u00a0             }\\n\\u00a0             {\\n\\u00a0               TimerOutput::Scope t(computing_timer, \\\"Output solid particles\\\");\\n\\u00a0               output_particles(solid_particle_handler,\\n\\u00a0                                \\\"solid\\\",\\n\\u00a0                                output_cycle,\\n\\u00a0                                time);\\n\\u00a0             }\\n\\u00a0           }\\nAfter the first time step, we displace the solid body at the beginning of each time step to take into account the fact that is has moved.\\n\\u00a0         else\\n\\u00a0           {\\n\\u00a0             TimerOutput::Scope t(computing_timer,\\n\\u00a0                                  \\\"Set solid particle position\\\");\\n\\u00a0 \\n\\u00a0             SolidPosition<spacedim> solid_position(par.angular_velocity,\\n\\u00a0                                                    time_step);\\n\\u00a0             solid_particle_handler.set_particle_positions(solid_position,\\n\\u00a0                                                           false);\\n\\u00a0           }\\n\\u00a0 \\nIn order to update the state of the system, we first interpolate the fluid velocity at the position of the tracer particles and, with a naive explicit Euler scheme, advect the massless tracer particles.\\n\\u00a0         {\\n\\u00a0           TimerOutput::Scope t(computing_timer, \\\"Set tracer particle motion\\\");\\n\\u00a0           Particles::Utilities::interpolate_field_on_particles(\\n\\u00a0             fluid_dh,\\n\\u00a0             tracer_particle_handler,\\n\\u00a0             locally_relevant_solution,\\n\\u00a0             tracer_particle_velocities,\\n\\u00a0             fluid_fe->component_mask(FEValuesExtractors::Vector(0)));\\n\\u00a0 \\n\\u00a0           tracer_particle_velocities *= time_step;\\n\\u00a0 \\n\\u00a0           locally_relevant_tracer_particle_coordinates =\\n\\u00a0             tracer_particle_handler.locally_owned_particle_ids().tensor_product(\\n\\u00a0               complete_index_set(spacedim));\\n\\u00a0 \\n\\u00a0           relevant_tracer_particle_displacements.reinit(\\n\\u00a0             locally_owned_tracer_particle_coordinates,\\n\\u00a0             locally_relevant_tracer_particle_coordinates,\\n\\u00a0             mpi_communicator);\\n\\u00a0 \\n\\u00a0           relevant_tracer_particle_displacements = tracer_particle_velocities;\\n\\u00a0 \\n\\u00a0           tracer_particle_handler.set_particle_positions(\\n\\u00a0             relevant_tracer_particle_displacements);\\n\\u00a0         }\\n\\u00a0 \\nParticles::Utilities::interpolate_field_on_particlesvoid interpolate_field_on_particles(const DoFHandler< dim, spacedim > &field_dh, const Particles::ParticleHandler< dim, spacedim > &particle_handler, const InputVectorType &field_vector, OutputVectorType &interpolated_field, const ComponentMask &field_comps={})Definition utilities.h:183\\nUsing these new locations, we can then assemble the Stokes system and solve it.\\n\\u00a0         assemble_stokes_system();\\n\\u00a0         assemble_nitsche_restriction();\\n\\u00a0         solve();\\n\\u00a0 \\nWith the appropriate frequencies, we then write the information of the solid particles, the tracer particles, and the fluid domain into files for visualization, and end the time step by adapting the mesh.\\n\\u00a0         if (cycle % par.output_frequency == 0)\\n\\u00a0           {\\n\\u00a0             output_results(output_cycle, time);\\n\\u00a0             {\\n\\u00a0               TimerOutput::Scope t(computing_timer, \\\"Output tracer particles\\\");\\n\\u00a0               output_particles(tracer_particle_handler,\\n\\u00a0                                \\\"tracer\\\",\\n\\u00a0                                output_cycle,\\n\\u00a0                                time);\\n\\u00a0             }\\n\\u00a0             {\\n\\u00a0               TimerOutput::Scope t(computing_timer, \\\"Output solid particles\\\");\\n\\u00a0               output_particles(solid_particle_handler,\\n\\u00a0                                \\\"solid\\\",\\n\\u00a0                                output_cycle,\\n\\u00a0                                time);\\n\\u00a0             }\\n\\u00a0             ++output_cycle;\\n\\u00a0           }\\n\\u00a0         if (cycle % par.refinement_frequency == 0 &&\\n\\u00a0             cycle != par.number_of_time_steps - 1)\\n\\u00a0           refine_and_transfer();\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 } // namespace Step70\\n\\u00a0 \\n\\u00a0 \\n The main() function\\nThe remainder of the code, the main() function, is standard, with the exception of the handling of input parameter files. We allow the user to specify an optional parameter file as an argument to the program. If nothing is specified, we use the default file \\\"parameters.prm\\\", which is created if non existent. The file name is scanned for the string \\\"23\\\" first, and \\\"3\\\" afterwards. If the filename contains the string \\\"23\\\", the problem classes are instantiated with template arguments 2 and 3 respectively. If only the string \\\"3\\\" is found, then both template arguments are set to 3, otherwise both are set to 2.\\nIf the program is called without any command line arguments (i.e., argc==1), then we just use \\\"parameters.prm\\\" by default.\\n\\u00a0 int main(int argc, char *argv[])\\n\\u00a0 {\\n\\u00a0   using namespace Step70;\\n\\u00a0   using namespace dealii;\\n\\u00a0   deallog.depth_console(1);\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);\\n\\u00a0 \\n\\u00a0       std::string prm_file;\\n\\u00a0       if (argc > 1)\\n\\u00a0         prm_file = argv[1];\\n\\u00a0       else\\n\\u00a0         prm_file = \\\"parameters.prm\\\";\\n\\u00a0 \\n\\u00a0       if (prm_file.find(\\\"23\\\") != std::string::npos)\\n\\u00a0         {\\n\\u00a0           StokesImmersedProblemParameters<2, 3> par;\\n\\u00a0           ParameterAcceptor::initialize(prm_file);\\n\\u00a0 \\n\\u00a0           StokesImmersedProblem<2, 3> problem(par);\\n\\u00a0           problem.run();\\n\\u00a0         }\\n\\u00a0       else if (prm_file.find('3') != std::string::npos)\\n\\u00a0         {\\n\\u00a0           StokesImmersedProblemParameters<3> par;\\n\\u00a0           ParameterAcceptor::initialize(prm_file);\\n\\u00a0 \\n\\u00a0           StokesImmersedProblem<3> problem(par);\\n\\u00a0           problem.run();\\n\\u00a0         }\\n\\u00a0       else\\n\\u00a0         {\\n\\u00a0           StokesImmersedProblemParameters<2> par;\\n\\u00a0           ParameterAcceptor::initialize(prm_file);\\n\\u00a0 \\n\\u00a0           StokesImmersedProblem<2> problem(par);\\n\\u00a0           problem.run();\\n\\u00a0         }\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0 \\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\nLogStream::depth_consoleunsigned int depth_console(const unsigned int n)Definition logstream.cc:349\\nParameterAcceptor::initializestatic void initialize(const std::string &filename=\\\"\\\", const std::string &output_filename=\\\"\\\", const ParameterHandler::OutputStyle output_style_for_output_filename=ParameterHandler::Short, ParameterHandler &prm=ParameterAcceptor::prm, const ParameterHandler::OutputStyle output_style_for_filename=ParameterHandler::DefaultStyle)Definition parameter_acceptor.cc:80\\nUtilities::MPI::MPI_InitFinalizeDefinition mpi.h:1081\\ndeallogLogStream deallogDefinition logstream.cc:36\\n Results\\nThe directory in which this program is run contains a number of sample parameter files that you can use to reproduce the results presented in this section. If you do not specify a parameter file as an argument on the command line, the program will try to read the file \\\"`parameters.prm`\\\" by default, and will execute the two dimensional version of the code. As explained in the discussion of the source code, if your file name contains the string \\\"23\\\", then the program will run a three dimensional problem, with immersed solid of co-dimension one. If it contains the string \\\"3\\\", it will run a three dimensional problem, with immersed solid of co-dimension zero, otherwise it will run a two dimensional problem with immersed solid of co-dimension zero.\\nRegardless of the specific parameter file name, if the specified file does not exist, when you execute the program you will get an exception that no such file can be found:\\n----------------------------------------------------\\nException on processing:\\n \\n--------------------------------------------------------\\nAn error occurred in line <74> of file <../source/base/parameter_acceptor.cc> in function\\n static void ::ParameterAcceptor::initialize(const std::string &, const std::string &, const ParameterHandler::OutputStyle, ::ParameterHandler &)\\nThe violated condition was:\\n false\\nAdditional information:\\n    You specified <parameters.prm> as input parameter file, but it does not exist. We created it for you.\\n--------------------------------------------------------\\n \\nAborting!\\n----------------------------------------------------\\nParameterHandlerDefinition parameter_handler.h:855\\nParameterHandler::OutputStyleOutputStyleDefinition parameter_handler.h:873\\nHowever, as the error message already states, the code that triggers the exception will also generate the specified file (\\\"`parameters.prm`\\\" in this case) that simply contains the default values for all parameters this program cares about (for the correct dimension and co-dimension, according to the whether a string \\\"23\\\" or \\\"3\\\" is contained in the file name). By inspection of the default parameter file, we see the following:\\n# Listing of Parameters\\n# ---------------------\\nsubsection Stokes Immersed Problem\\n  set Final time                            = 1\\n  # Extraction level of the rtree used to construct global bounding boxes\\n  set Fluid bounding boxes extraction level = 1\\n \\n  # Boundary Ids over which homogeneous Dirichlet boundary conditions are\\n  # applied\\n  set Homogeneous Dirichlet boundary ids    = 0\\n \\n  # Initial mesh refinement used for the fluid domain Omega\\n  set Initial fluid refinement              = 5\\n \\n  # Initial mesh refinement used for the solid domain Gamma\\n  set Initial solid refinement              = 5\\n  set Nitsche penalty term                  = 100\\n  set Number of time steps                  = 501\\n  set Output directory                      = .\\n  set Output frequency                      = 1\\n \\n  # Refinement of the volumetric mesh used to insert the particles\\n  set Particle insertion refinement         = 3\\n  set Velocity degree                       = 2\\n  set Viscosity                             = 1\\n \\n \\n  subsection Angular velocity\\n    # Sometimes it is convenient to use symbolic constants in the expression\\n    # that describes the function, rather than having to use its numeric value\\n    # everywhere the constant appears. These values can be defined using this\\n    # parameter, in the form `var1=value1, var2=value2, ...'.\\n    #\\n    # A typical example would be to set this runtime parameter to\\n    # `pi=3.1415926536' and then use `pi' in the expression of the actual\\n    # formula. (That said, for convenience this class actually defines both\\n    # `pi' and `Pi' by default, but you get the idea.)\\n    set Function constants  =\\n \\n    # The formula that denotes the function you want to evaluate for\\n    # particular values of the independent variables. This expression may\\n    # contain any of the usual operations such as addition or multiplication,\\n    # as well as all of the common functions such as `sin' or `cos'. In\\n    # addition, it may contain expressions like `if(x>0, 1, -1)' where the\\n    # expression evaluates to the second argument if the first argument is\\n    # true, and to the third argument otherwise. For a full overview of\\n    # possible expressions accepted see the documentation of the muparser\\n    # library at http://muparser.beltoforion.de/.\\n    #\\n    # If the function you are describing represents a vector-valued function\\n    # with multiple components, then separate the expressions for individual\\n    # components by a semicolon.\\n    set Function expression = t < .500001 ? 6.283185 : -6.283185 # default: 0\\n \\n    # The names of the variables as they will be used in the function,\\n    # separated by commas. By default, the names of variables at which the\\n    # function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in\\n    # 3d) for spatial coordinates and `t' for time. You can then use these\\n    # variable names in your function expression and they will be replaced by\\n    # the values of these variables at which the function is currently\\n    # evaluated. However, you can also choose a different set of names for the\\n    # independent variables at which to evaluate your function expression. For\\n    # example, if you work in spherical coordinates, you may wish to set this\\n    # input parameter to `r,phi,theta,t' and then use these variable names in\\n    # your function expression.\\n    set Variable names      = x,y,t\\n  end\\n \\n  subsection Grid generation\\n    set Fluid grid generator              = hyper_cube\\n    set Fluid grid generator arguments    = -1: 1: false\\n    set Particle grid generator           = hyper_ball\\n    set Particle grid generator arguments = 0.3, 0.3: 0.1: false\\n    set Solid grid generator              = hyper_rectangle\\n    set Solid grid generator arguments    = -.5, -.1: .5, .1: false\\n  end\\n \\n  subsection Refinement and remeshing\\n    set Maximum number of cells        = 20000\\n    set Refinement coarsening fraction = 0.3\\n    set Refinement fraction            = 0.3\\n    set Refinement maximal level       = 8\\n    set Refinement minimal level       = 5\\n    set Refinement step frequency      = 5\\n    set Refinement strategy            = fixed_fraction\\n  end\\n \\n  subsection Right hand side\\n    # Sometimes it is convenient to use symbolic constants in the expression\\n    # that describes the function, rather than having to use its numeric value\\n    # everywhere the constant appears. These values can be defined using this\\n    # parameter, in the form `var1=value1, var2=value2, ...'.\\n    #\\n    # A typical example would be to set this runtime parameter to\\n    # `pi=3.1415926536' and then use `pi' in the expression of the actual\\n    # formula. (That said, for convenience this class actually defines both\\n    # `pi' and `Pi' by default, but you get the idea.)\\n    set Function constants  =\\n \\n    # The formula that denotes the function you want to evaluate for\\n    # particular values of the independent variables. This expression may\\n    # contain any of the usual operations such as addition or multiplication,\\n    # as well as all of the common functions such as `sin' or `cos'. In\\n    # addition, it may contain expressions like `if(x>0, 1, -1)' where the\\n    # expression evaluates to the second argument if the first argument is\\n    # true, and to the third argument otherwise. For a full overview of\\n    # possible expressions accepted see the documentation of the muparser\\n    # library at http://muparser.beltoforion.de/.\\n    #\\n    # If the function you are describing represents a vector-valued function\\n    # with multiple components, then separate the expressions for individual\\n    # components by a semicolon.\\n    set Function expression = 0; 0; 0\\n \\n    # The names of the variables as they will be used in the function,\\n    # separated by commas. By default, the names of variables at which the\\n    # function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in\\n    # 3d) for spatial coordinates and `t' for time. You can then use these\\n    # variable names in your function expression and they will be replaced by\\n    # the values of these variables at which the function is currently\\n    # evaluated. However, you can also choose a different set of names for the\\n    # independent variables at which to evaluate your function expression. For\\n    # example, if you work in spherical coordinates, you may wish to set this\\n    # input parameter to `r,phi,theta,t' and then use these variable names in\\n    # your function expression.\\n    set Variable names      = x,y,t\\n  end\\n \\nend\\nIf you now run the program, you will get a file called parameters_22.prm in the directory specified by the parameter Output directory (which defaults to the current directory) containing a shorter version of the above parameters (without comments and documentation), documenting all parameters that were used to run your program:\\nsubsection Stokes Immersed Problem\\n  set Final time                            = 1\\n  set Fluid bounding boxes extraction level = 1\\n  set Homogeneous Dirichlet boundary ids    = 0\\n  set Initial fluid refinement              = 5\\n  set Initial solid refinement              = 5\\n  set Nitsche penalty term                  = 100\\n  set Number of time steps                  = 501\\n  set Output directory                      = .\\n  set Output frequency                      = 1\\n  set Particle insertion refinement         = 3\\n  set Velocity degree                       = 2\\n  set Viscosity                             = 1\\n  subsection Angular velocity\\n    set Function constants  =\\n    set Function expression = t < .500001 ? 6.283185 : -6.283185\\n    set Variable names      = x,y,t\\n  end\\n  subsection Grid generation\\n    set Fluid grid generator              = hyper_cube\\n    set Fluid grid generator arguments    = -1: 1: false\\n    set Particle grid generator           = hyper_ball\\n    set Particle grid generator arguments = 0.3, 0.3: 0.1: false\\n    set Solid grid generator              = hyper_rectangle\\n    set Solid grid generator arguments    = -.5, -.1: .5, .1: false\\n  end\\n  subsection Refinement and remeshing\\n    set Maximum number of cells        = 20000\\n    set Refinement coarsening fraction = 0.3\\n    set Refinement fraction            = 0.3\\n    set Refinement maximal level       = 8\\n    set Refinement minimal level       = 5\\n    set Refinement step frequency      = 5\\n    set Refinement strategy            = fixed_fraction\\n  end\\n  subsection Right hand side\\n    set Function constants  =\\n    set Function expression = 0; 0; 0\\n    set Variable names      = x,y,t\\n  end\\nend\\nThe rationale behind creating first parameters.prm file (the first time the program is run) and then a output/parameters_22.prm (every time you run the program with an existing input file), is because you may want to leave most parameters to their default values, and only modify a handful of them, while still being able to reproduce the results and inspect what parameters were used for a specific simulation. It is generally good scientific practice to store the parameter file you used for a simulation along with the simulation output so that you can repeat the exact same run at a later time if necessary.\\nAnother reason is because the input file may only contain those parameters that differ from their defaults. For example, you could use the following (perfectly valid) parameter file with this tutorial program: subsection Stokes Immersed Problem\\n  set Final time                         = 1\\n  set Nitsche penalty term               = 10\\n  set Number of time steps               = 101\\n  set Velocity degree                    = 3\\nend\\n and you would run the program with Q3/Q2 Taylor-Hood finite elements, for 101 steps, using a Nitsche penalty of 10, and leaving all the other parameters to their default value. The output directory then contains a record of not just these parameters, but indeed all parameters used in the simulation. You can inspect all the other parameters in the produced file parameters_22.prm.\\nTwo dimensional test case \\nThe default problem generates a co-dimension zero impeller, consisting of a rotating rectangular grid, where the rotation is for half a time unit in one direction, and half a time unit in the opposite direction, with constant angular velocity equal to \\\\(\\\\approx 2\\\\pi \\\\frac{\\\\text{rad}}{\\\\text{time unit}}\\\\). Consequently, the impeller does half a rotation and returns to its original position. The following animation displays the velocity magnitude, the motion of the solid impeller and of the tracer particles.\\n\\n   On one core, the output of the program will look like the following:\\nbash@f$ mpirun -np 1 ./step-70 test.prm\\nRunning StokesImmersedProblem<2> using Trilinos.\\nCycle 0:\\nTime : 0, time step: 0.002\\n   Number of degrees of freedom: 9539 (8450+1089 -- 0+0)\\nTracer particles: 337\\nSolid particles: 9216\\n   Solved in 158 iterations.\\n   Number of degrees of freedom: 9845 (8722+1123 -- 9216+337)\\nCycle 1:\\nTime : 0.002, time step: 0.002\\n   Solved in 142 iterations.\\nCycle 2:\\nTime : 0.004, time step: 0.002\\n   Solved in 121 iterations.\\nCycle 3:\\nTime : 0.006, time step: 0.002\\n   Solved in 121 iterations.\\n \\n...\\n \\nCycle 499:\\nTime : 0.998, time step: 0.002\\n   Solved in 199 iterations.\\nCycle 500:\\nTime : 1, time step: 0.002\\n   Solved in 196 iterations.\\n \\n+---------------------------------------------+------------+------------+\\n| Total wallclock time elapsed since start    |       302s |            |\\n|                                             |            |            |\\n| Section                         | no. calls |  wall time | % of total |\\n+---------------------------------+-----------+------------+------------+\\n| Assemble Nitsche terms          |       501 |      43.3s |        14% |\\n| Assemble Stokes terms           |       501 |      21.5s |       7.1% |\\n| Initial setup                   |         1 |  0.000792s |         0% |\\n| Output fluid                    |       502 |      31.8s |        11% |\\n| Output solid particles          |       502 |      32.2s |        11% |\\n| Output tracer particles         |       502 |      0.61s |       0.2% |\\n| Refine                          |       100 |      4.68s |       1.5% |\\n| Set solid particle position     |       500 |      3.34s |       1.1% |\\n| Set tracer particle motion      |       501 |     0.729s |      0.24% |\\n| Setup dofs                      |       101 |       2.2s |      0.73% |\\n| Solve                           |       501 |       164s |        54% |\\n+---------------------------------+-----------+------------+------------+\\nYou may notice that assembling the coupling system is more expensive than assembling the Stokes part. This depends highly on the number of Gauss points (solid particles) that are used to apply the Nitsche restriction. In the present case, a relatively low number of tracer particles are used. Consequently, tracking their motion is relatively cheap.\\nThe following movie shows the evolution of the solution over time:\\n\\n\\n\\n\\n\\nThe movie shows the rotating obstacle in gray (actually a superposition of the solid particles plotted with large enough dots that they overlap), streamlines of the fluid flow in light colors (including the corner vertices that form at specific times during the simulation), and the tracer particles in bluish tones.\\nThe simulation shows that at the end time, the tracer particles have somewhat returned to their original position, although they have been distorted by the flow field. The following image compares the initial and the final position of the particles after one time unit of flow.\\n\\n   In this case, we see that the tracer particles that were outside of the swept volume of the impeller have returned very close to their initial position, whereas those in the swept volume were slightly more deformed. This deformation is non-physical. It is caused by the numerical error induced by the explicit Euler scheme used to advect the particles, by the loss of accuracy due to the fictitious domain and, finally, by the discretization error on the Stokes equations. The first two errors are the leading cause of this deformation and they could be alleviated by the use of a finer mesh and a lower time step.\\nThree dimensional test case \\nTo play around a little bit, we complicate the fictitious domain (taken from https://grabcad.com/library/lungstors-blower-1), and run a co-dimension one simulation in three space dimensions, using the following \\\"`parameters_23.prm`\\\" file :\\nsubsection Stokes Immersed Problem\\n  set Final time                            = 1\\n  set Homogeneous Dirichlet boundary ids    = 0\\n  set Fluid bounding boxes extraction level = 1\\n  set Initial fluid refinement              = 3\\n  set Initial solid refinement              = 0\\n  set Nitsche penalty term                  = 10\\n  set Number of time steps                  = 101\\n  set Output frequency                      = 1\\n  set Particle insertion refinement         = 3\\n  set Velocity degree                       = 2\\n  set Viscosity                             = 1\\n  subsection Angular velocity\\n    set Function constants  =\\n    set Function expression = t < .500001 ? 5 : -5\\n    set Variable names      = x,y,z,t\\n  end\\n  subsection Grid generation\\n    set Fluid grid generator              = hyper_rectangle\\n    set Fluid grid generator arguments    = -50,-50, -10: 50, 50, 40: false\\n    set Solid grid generator              = impeller.vtk\\n    set Solid grid generator arguments    = 1:impeller.step\\n    set Particle grid generator           = hyper_ball\\n    set Particle grid generator arguments = 30, 30, 20: 10: false\\n  end\\n  subsection Refinement and remeshing\\n    set Maximum number of cells        = 100000\\n    set Refinement coarsening fraction = 0.3\\n    set Refinement fraction            = 0.3\\n    set Refinement maximal level       = 6\\n    set Refinement step frequency      = 5\\n    set Refinement strategy            = fixed_fraction\\n  end\\n  subsection Right hand side\\n    set Function constants  =\\n    set Function expression = 0; 0; 0; 0\\n    set Variable names      = x,y,z,t\\n  end\\nend\\nIn this case, the timing outputs are a bit different:\\n+---------------------------------------------+------------+------------+\\n| Total wallclock time elapsed since start    |  5.54e+03s |            |\\n|                                             |            |            |\\n| Section                         | no. calls |  wall time | % of total |\\n+---------------------------------+-----------+------------+------------+\\n| Assemble Nitsche terms          |       101 |       111s |         2% |\\n| Assemble Stokes terms           |       101 |       208s |       3.8% |\\n| Initial setup                   |         1 |   0.00187s |         0% |\\n| Output fluid                    |       102 |      15.5s |      0.28% |\\n| Output solid particles          |       102 |      2.63s |         0% |\\n| Output tracer particles         |       102 |      2.49s |         0% |\\n| Refine                          |        20 |      18.4s |      0.33% |\\n| Set solid particle position     |       100 |       6.1s |      0.11% |\\n| Set tracer particle motion      |       101 |      10.8s |       0.2% |\\n| Setup dofs                      |        21 |      13.9s |      0.25% |\\n| Solve                           |       101 |  5.16e+03s |        93% |\\n+---------------------------------+-----------+------------+------------+\\nNow, the solver is taking most of the solution time in three dimensions, and the particle motion and Nitsche assembly remain relatively unimportant as far as run time is concerned.\\n\\n\\n\\n\\n\\n Possibilities for extensions\\nThe current tutorial program shows a one-way coupling between the fluid and the solid, where the solid motion is imposed (and not solved for), and read in the solid domain by exploiting the location and the weights of the solid quadrature points.\\nThe structure of the code already allows one to implement a two-way coupling, by exploiting the possibility to read values of the fluid velocity on the quadrature points of the solid grid. For this to be more efficient in terms of MPI communication patterns, one should maintain ownership of the quadrature points on the solid processor that owns the cells where they have been created. In the current code, it is sufficient to define the IndexSet of the vectors used to exchange information of the quadrature points by using the solid partition instead of the initial fluid partition.\\nThis allows the combination of the technique used in this tutorial program with those presented in the tutorial step-60 to solve a fluid structure interaction problem with distributed Lagrange multipliers, on parallel::distributed::Triangulation objects.\\nThe timings above show that the current preconditioning strategy does not work well for Nitsche penalization, and we should come up with a better preconditioner if we want to aim at larger problems. Moreover, a checkpoint restart strategy should be implemented to allow for longer simulations to be interrupted and restored, as it is done for example in the step-69 tutorial.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2020 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Authors: Luca Heltai, Bruno Blais, Rene Gassmoeller, 2020\\n */\\n \\n \\n#include <deal.II/base/function.h>\\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/timer.h>\\n \\n#include <deal.II/lac/block_linear_operator.h>\\n#include <deal.II/lac/generic_linear_algebra.h>\\n#include <deal.II/lac/linear_operator.h>\\n#include <deal.II/lac/linear_operator_tools.h>\\n \\n#define FORCE_USE_OF_TRILINOS\\n \\nnamespace LA\\n{\\n#if defined(DEAL_II_WITH_PETSC) && !defined(DEAL_II_PETSC_WITH_COMPLEX) && \\\\\\n  !(defined(DEAL_II_WITH_TRILINOS) && defined(FORCE_USE_OF_TRILINOS))\\n using namespace dealii::LinearAlgebraPETSc;\\n#  define USE_PETSC_LA\\n#elif defined(DEAL_II_WITH_TRILINOS)\\n using namespace dealii::LinearAlgebraTrilinos;\\n#else\\n#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required\\n#endif\\n} // namespace LA\\n \\n#include <deal.II/base/conditional_ostream.h>\\n#include <deal.II/base/index_set.h>\\n#include <deal.II/base/parameter_acceptor.h>\\n#include <deal.II/base/parsed_function.h>\\n#include <deal.II/base/utilities.h>\\n \\n#include <deal.II/distributed/grid_refinement.h>\\n#include <deal.II/distributed/solution_transfer.h>\\n#include <deal.II/distributed/tria.h>\\n \\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_renumbering.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/fe/fe_nothing.h>\\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_system.h>\\n#include <deal.II/fe/fe_values.h>\\n#include <deal.II/fe/mapping_fe_field.h>\\n#include <deal.II/fe/mapping_q1.h>\\n \\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_in.h>\\n#include <deal.II/grid/grid_tools.h>\\n#include <deal.II/grid/manifold_lib.h>\\n \\n#include <deal.II/lac/affine_constraints.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/petsc_precondition.h>\\n#include <deal.II/lac/petsc_solver.h>\\n#include <deal.II/lac/petsc_sparse_matrix.h>\\n#include <deal.II/lac/petsc_vector.h>\\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/solver_gmres.h>\\n#include <deal.II/lac/solver_minres.h>\\n#include <deal.II/lac/sparsity_tools.h>\\n#include <deal.II/lac/vector.h>\\n \\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/error_estimator.h>\\n#include <deal.II/numerics/vector_tools.h>\\n \\n#include <deal.II/particles/data_out.h>\\n#include <deal.II/particles/generators.h>\\n#include <deal.II/particles/particle_handler.h>\\n#include <deal.II/particles/utilities.h>\\n \\n#include <deal.II/opencascade/manifold_lib.h>\\n#include <deal.II/opencascade/utilities.h>\\n#ifdef DEAL_II_WITH_OPENCASCADE\\n#  include <TopoDS.hxx>\\n#endif\\n \\n#include <cmath>\\n#include <filesystem>\\n#include <fstream>\\n#include <iostream>\\n#include <memory>\\n \\nnamespace Step70\\n{\\n using namespace dealii;\\n \\n \\n template <int dim, int spacedim = dim>\\n class StokesImmersedProblemParameters : public ParameterAcceptor\\n  {\\n public:\\n    StokesImmersedProblemParameters();\\n \\n void set_time(const double &time) const\\n {\\n      rhs.set_time(time);\\n      angular_velocity.set_time(time);\\n    }\\n \\n    std::string output_directory = \\\".\\\";\\n \\n unsigned int velocity_degree = 2;\\n \\n unsigned int number_of_time_steps = 501;\\n double       final_time           = 1.0;\\n \\n unsigned int output_frequency = 1;\\n \\n unsigned int initial_fluid_refinement      = 5;\\n unsigned int initial_solid_refinement      = 5;\\n unsigned int particle_insertion_refinement = 3;\\n \\n unsigned int fluid_rtree_extraction_level = 1;\\n \\n double viscosity    = 1.0;\\n double penalty_term = 100;\\n \\n    std::list<types::boundary_id> homogeneous_dirichlet_ids{0};\\n \\n    std::string name_of_fluid_grid       = \\\"hyper_cube\\\";\\n    std::string arguments_for_fluid_grid = \\\"-1: 1: false\\\";\\n    std::string name_of_solid_grid       = \\\"hyper_rectangle\\\";\\n    std::string arguments_for_solid_grid = spacedim == 2 ?\\n \\\"-.5, -.1: .5, .1: false\\\" :\\n \\\"-.5, -.1, -.1: .5, .1, .1: false\\\";\\n    std::string name_of_particle_grid    = \\\"hyper_ball\\\";\\n    std::string arguments_for_particle_grid =\\n      spacedim == 2 ? \\\"0.3, 0.3: 0.1: false\\\" : \\\"0.3, 0.3, 0.3 : 0.1: false\\\";\\n \\n int          max_level_refinement = 8;\\n int          min_level_refinement = 5;\\n    std::string  refinement_strategy  = \\\"fixed_fraction\\\";\\n double       coarsening_fraction  = 0.3;\\n double       refinement_fraction  = 0.3;\\n unsigned int max_cells            = 20000;\\n int          refinement_frequency = 5;\\n \\n mutable ParameterAcceptorProxy<Functions::ParsedFunction<spacedim>> rhs;\\n mutable ParameterAcceptorProxy<Functions::ParsedFunction<spacedim>>\\n      angular_velocity;\\n  };\\n \\n \\n \\n template <int dim, int spacedim>\\n  StokesImmersedProblemParameters<dim,\\n                                  spacedim>::StokesImmersedProblemParameters()\\n    : ParameterAcceptor(\\\"Stokes Immersed Problem/\\\")\\n    , rhs(\\\"Right hand side\\\", spacedim + 1)\\n    , angular_velocity(\\\"Angular velocity\\\")\\n  {\\n    add_parameter(\\n \\\"Velocity degree\\\", velocity_degree, \\\"\\\", this->prm, Patterns::Integer(1));\\n \\n    add_parameter(\\\"Number of time steps\\\", number_of_time_steps);\\n    add_parameter(\\\"Output frequency\\\", output_frequency);\\n \\n    add_parameter(\\\"Output directory\\\", output_directory);\\n \\n    add_parameter(\\\"Final time\\\", final_time);\\n \\n    add_parameter(\\\"Viscosity\\\", viscosity);\\n \\n    add_parameter(\\\"Nitsche penalty term\\\", penalty_term);\\n \\n    add_parameter(\\\"Initial fluid refinement\\\",\\n                  initial_fluid_refinement,\\n \\\"Initial mesh refinement used for the fluid domain Omega\\\");\\n \\n    add_parameter(\\\"Initial solid refinement\\\",\\n                  initial_solid_refinement,\\n \\\"Initial mesh refinement used for the solid domain Gamma\\\");\\n \\n    add_parameter(\\\"Fluid bounding boxes extraction level\\\",\\n                  fluid_rtree_extraction_level,\\n \\\"Extraction level of the rtree used to construct global \\\"\\n \\\"bounding boxes\\\");\\n \\n    add_parameter(\\n \\\"Particle insertion refinement\\\",\\n      particle_insertion_refinement,\\n \\\"Refinement of the volumetric mesh used to insert the particles\\\");\\n \\n    add_parameter(\\n \\\"Homogeneous Dirichlet boundary ids\\\",\\n      homogeneous_dirichlet_ids,\\n \\\"Boundary Ids over which homogeneous Dirichlet boundary conditions are applied\\\");\\n \\n    enter_subsection(\\\"Grid generation\\\");\\n    {\\n      add_parameter(\\\"Fluid grid generator\\\", name_of_fluid_grid);\\n      add_parameter(\\\"Fluid grid generator arguments\\\", arguments_for_fluid_grid);\\n \\n      add_parameter(\\\"Solid grid generator\\\", name_of_solid_grid);\\n      add_parameter(\\\"Solid grid generator arguments\\\", arguments_for_solid_grid);\\n \\n      add_parameter(\\\"Particle grid generator\\\", name_of_particle_grid);\\n      add_parameter(\\\"Particle grid generator arguments\\\",\\n                    arguments_for_particle_grid);\\n    }\\n    leave_subsection();\\n \\n \\n \\n    enter_subsection(\\\"Refinement and remeshing\\\");\\n    {\\n      add_parameter(\\\"Refinement step frequency\\\", refinement_frequency);\\n      add_parameter(\\\"Refinement maximal level\\\", max_level_refinement);\\n      add_parameter(\\\"Refinement minimal level\\\", min_level_refinement);\\n      add_parameter(\\\"Refinement strategy\\\",\\n                    refinement_strategy,\\n \\\"\\\",\\n                    this->prm,\\n Patterns::Selection(\\\"fixed_fraction|fixed_number\\\"));\\n      add_parameter(\\\"Refinement coarsening fraction\\\", coarsening_fraction);\\n      add_parameter(\\\"Refinement fraction\\\", refinement_fraction);\\n      add_parameter(\\\"Maximum number of cells\\\", max_cells);\\n    }\\n    leave_subsection();\\n \\n    rhs.declare_parameters_call_back.connect([&]() {\\n Functions::ParsedFunction<spacedim>::declare_parameters(this->prm,\\n                                                              spacedim + 1);\\n    });\\n    angular_velocity.declare_parameters_call_back.connect([&]() {\\n      this->prm.set(\\\"Function expression\\\",\\n \\\"t < .500001 ? 6.283185 : -6.283185\\\");\\n    });\\n  }\\n \\n \\n template <int spacedim>\\n class SolidVelocity : public Function<spacedim>\\n  {\\n public:\\n static_assert(spacedim > 1,\\n \\\"Cannot instantiate SolidVelocity for spacedim == 1\\\");\\n \\n    SolidVelocity(const Functions::ParsedFunction<spacedim> &angular_velocity)\\n      : angular_velocity(angular_velocity)\\n    {}\\n \\n virtual double value(const Point<spacedim> &p,\\n unsigned int           component = 0) const override\\n {\\n Tensor<1, spacedim> velocity;\\n \\n const double omega = angular_velocity.value(p);\\n      velocity[0]        = -omega * p[1];\\n      velocity[1]        = omega * p[0];\\n \\n return velocity[component];\\n    }\\n \\n private:\\n const Functions::ParsedFunction<spacedim> &angular_velocity;\\n  };\\n \\n \\n template <int spacedim>\\n class SolidPosition : public Function<spacedim>\\n  {\\n public:\\n static_assert(spacedim > 1,\\n \\\"Cannot instantiate SolidPosition for spacedim == 1\\\");\\n \\n    SolidPosition(const Functions::ParsedFunction<spacedim> &angular_velocity,\\n const double                               time_step)\\n      : Function<spacedim>(spacedim)\\n      , angular_velocity(angular_velocity)\\n      , time_step(time_step)\\n    {}\\n \\n virtual double value(const Point<spacedim> &p,\\n unsigned int           component = 0) const override\\n {\\n Point<spacedim> new_position = p;\\n \\n double dtheta = angular_velocity.value(p) * time_step;\\n \\n      new_position[0] = std::cos(dtheta) * p[0] - std::sin(dtheta) * p[1];\\n      new_position[1] = std::sin(dtheta) * p[0] + std::cos(dtheta) * p[1];\\n \\n return new_position[component];\\n    }\\n \\n void set_time_step(const double new_time_step)\\n    {\\n      time_step = new_time_step;\\n    }\\n \\n private:\\n const Functions::ParsedFunction<spacedim> &angular_velocity;\\n double                                     time_step;\\n  };\\n \\n \\n \\n template <int dim, int spacedim = dim>\\n class StokesImmersedProblem\\n  {\\n public:\\n    StokesImmersedProblem(\\n const StokesImmersedProblemParameters<dim, spacedim> &par);\\n \\n void run();\\n \\n private:\\n void make_grid();\\n \\n double compute_time_step() const;\\n \\n void setup_tracer_particles();\\n void setup_solid_particles();\\n \\n void initial_setup();\\n void setup_dofs();\\n \\n void assemble_stokes_system();\\n void assemble_nitsche_restriction();\\n \\n void solve();\\n \\n void refine_and_transfer();\\n \\n void output_results(const unsigned int cycle, const double time) const;\\n void output_particles(const Particles::ParticleHandler<spacedim> &particles,\\n                          std::string                                 fprefix,\\n const unsigned int                          iter,\\n const double time) const;\\n \\n const StokesImmersedProblemParameters<dim, spacedim> &par;\\n \\n MPI_Comm mpi_communicator;\\n \\n ConditionalOStream pcout;\\n \\n mutable TimerOutput computing_timer;\\n \\n parallel::distributed::Triangulation<spacedim>      fluid_tria;\\n parallel::distributed::Triangulation<dim, spacedim> solid_tria;\\n \\n    std::unique_ptr<FiniteElement<spacedim>>      fluid_fe;\\n    std::unique_ptr<FiniteElement<dim, spacedim>> solid_fe;\\n \\n DoFHandler<spacedim>      fluid_dh;\\n DoFHandler<dim, spacedim> solid_dh;\\n \\n    std::vector<IndexSet> fluid_owned_dofs;\\n    std::vector<IndexSet> solid_owned_dofs;\\n \\n    std::vector<IndexSet> fluid_relevant_dofs;\\n    std::vector<IndexSet> solid_relevant_dofs;\\n \\n AffineConstraints<double> constraints;\\n \\n    LA::MPI::BlockSparseMatrix system_matrix;\\n    LA::MPI::BlockSparseMatrix preconditioner_matrix;\\n \\n    LA::MPI::BlockVector solution;\\n    LA::MPI::BlockVector locally_relevant_solution;\\n    LA::MPI::BlockVector system_rhs;\\n \\n Particles::ParticleHandler<spacedim> tracer_particle_handler;\\n Particles::ParticleHandler<spacedim> solid_particle_handler;\\n \\n IndexSet locally_owned_tracer_particle_coordinates;\\n IndexSet locally_relevant_tracer_particle_coordinates;\\n \\n    LA::MPI::Vector tracer_particle_velocities;\\n    LA::MPI::Vector relevant_tracer_particle_displacements;\\n \\n    std::vector<std::vector<BoundingBox<spacedim>>> global_fluid_bounding_boxes;\\n  };\\n \\n \\n \\n \\n \\n template <int dim, int spacedim>\\n  StokesImmersedProblem<dim, spacedim>::StokesImmersedProblem(\\n const StokesImmersedProblemParameters<dim, spacedim> &par)\\n    : par(par)\\n    , mpi_communicator(MPI_COMM_WORLD)\\n    , pcout(std::cout,\\n            (Utilities::MPI::this_mpi_process(mpi_communicator) == 0))\\n    , computing_timer(mpi_communicator,\\n                      pcout,\\n TimerOutput::summary,\\n TimerOutput::wall_times)\\n    , fluid_tria(mpi_communicator,\\n                 typename Triangulation<spacedim>::MeshSmoothing(\\n Triangulation<spacedim>::smoothing_on_refinement |\\n Triangulation<spacedim>::smoothing_on_coarsening))\\n    , solid_tria(mpi_communicator,\\n                 typename Triangulation<dim, spacedim>::MeshSmoothing(\\n Triangulation<dim, spacedim>::smoothing_on_refinement |\\n Triangulation<dim, spacedim>::smoothing_on_coarsening))\\n    , fluid_dh(fluid_tria)\\n    , solid_dh(solid_tria)\\n  {\\n if (std::filesystem::exists(par.output_directory))\\n      {\\n Assert(std::filesystem::is_directory(par.output_directory),\\n               ExcMessage(\\\"You specified <\\\" + par.output_directory +\\n \\\"> as the output directory in the input file, \\\"\\n \\\"but this is not in fact a directory.\\\"));\\n      }\\n else\\n      std::filesystem::create_directory(par.output_directory);\\n  }\\n \\n \\n template <int dim, int spacedim>\\n void read_grid_and_cad_files(const std::string &grid_file_name,\\n const std::string &ids_and_cad_file_names,\\n Triangulation<dim, spacedim> &tria)\\n  {\\n GridIn<dim, spacedim> grid_in;\\n    grid_in.attach_triangulation(tria);\\n    grid_in.read(grid_file_name);\\n \\n#ifdef DEAL_II_WITH_OPENCASCADE\\n using map_type  = std::map<types::manifold_id, std::string>;\\n using Converter = Patterns::Tools::Convert<map_type>;\\n \\n for (const auto &pair : Converter::to_value(ids_and_cad_file_names))\\n      {\\n const auto &manifold_id   = pair.first;\\n const auto &cad_file_name = pair.second;\\n \\n        std::string extension =\\n          cad_file_name.substr(cad_file_name.find_last_of('.') + 1);\\n        std::transform(extension.begin(),\\n                       extension.end(),\\n                       extension.begin(),\\n                       [](const char c) -> char { return std::tolower(c); });\\n \\n        TopoDS_Shape shape;\\n if (extension == \\\"iges\\\" || extension == \\\"igs\\\")\\n          shape = OpenCASCADE::read_IGES(cad_file_name);\\n else if (extension == \\\"step\\\" || extension == \\\"stp\\\")\\n          shape = OpenCASCADE::read_STEP(cad_file_name);\\n else\\n AssertThrow(false,\\n                      ExcNotImplemented(\\\"We found an extension that we \\\"\\n \\\"do not recognize as a CAD file \\\"\\n \\\"extension. Bailing out.\\\"));\\n \\n const auto n_elements = OpenCASCADE::count_elements(shape);\\n if ((std::get<0>(n_elements) == 0))\\n          tria.set_manifold(\\n            manifold_id,\\n OpenCASCADE::ArclengthProjectionLineManifold<dim, spacedim>(shape));\\n else if (spacedim == 3)\\n          {\\n const auto t = reinterpret_cast<Triangulation<dim, 3> *>(&tria);\\n            t->set_manifold(manifold_id,\\n OpenCASCADE::NormalToMeshProjectionManifold<dim, 3>(\\n                              shape));\\n          }\\n else\\n          tria.set_manifold(manifold_id,\\n OpenCASCADE::NURBSPatchManifold<dim, spacedim>(\\n                              TopoDS::Face(shape)));\\n      }\\n#else\\n    (void)ids_and_cad_file_names;\\n AssertThrow(false, ExcNotImplemented(\\\"Generation of the grid failed.\\\"));\\n#endif\\n  }\\n \\n \\n \\n template <int dim, int spacedim>\\n void StokesImmersedProblem<dim, spacedim>::make_grid()\\n  {\\n try\\n      {\\n GridGenerator::generate_from_name_and_arguments(\\n          fluid_tria, par.name_of_fluid_grid, par.arguments_for_fluid_grid);\\n      }\\n catch (...)\\n      {\\n        pcout << \\\"Generating from name and argument failed.\\\" << std::endl\\n              << \\\"Trying to read from file name.\\\" << std::endl;\\n        read_grid_and_cad_files(par.name_of_fluid_grid,\\n                                par.arguments_for_fluid_grid,\\n                                fluid_tria);\\n      }\\n    fluid_tria.refine_global(par.initial_fluid_refinement);\\n \\n try\\n      {\\n GridGenerator::generate_from_name_and_arguments(\\n          solid_tria, par.name_of_solid_grid, par.arguments_for_solid_grid);\\n      }\\n catch (...)\\n      {\\n        read_grid_and_cad_files(par.name_of_solid_grid,\\n                                par.arguments_for_solid_grid,\\n                                solid_tria);\\n      }\\n \\n    solid_tria.refine_global(par.initial_solid_refinement);\\n  }\\n \\n \\n template <int dim, int spacedim>\\n void StokesImmersedProblem<dim, spacedim>::setup_tracer_particles()\\n  {\\n parallel::distributed::Triangulation<spacedim> particle_insert_tria(\\n      mpi_communicator);\\n GridGenerator::generate_from_name_and_arguments(\\n      particle_insert_tria,\\n      par.name_of_particle_grid,\\n      par.arguments_for_particle_grid);\\n    particle_insert_tria.refine_global(par.particle_insertion_refinement);\\n \\n const FE_Q<spacedim> particles_fe(1);\\n DoFHandler<spacedim> particles_dof_handler(particle_insert_tria);\\n    particles_dof_handler.distribute_dofs(particles_fe);\\n \\n    std::vector<BoundingBox<spacedim>> all_boxes;\\n    all_boxes.reserve(fluid_tria.n_locally_owned_active_cells());\\n for (const auto &cell : fluid_tria.active_cell_iterators())\\n      if (cell->is_locally_owned())\\n        all_boxes.emplace_back(cell->bounding_box());\\n \\n const auto tree = pack_rtree(all_boxes);\\n const auto local_boxes =\\n extract_rtree_level(tree, par.fluid_rtree_extraction_level);\\n \\n    global_fluid_bounding_boxes =\\n Utilities::MPI::all_gather(mpi_communicator, local_boxes);\\n \\n    tracer_particle_handler.initialize(fluid_tria,\\n StaticMappingQ1<spacedim>::mapping);\\n \\n Particles::Generators::dof_support_points(particles_dof_handler,\\n                                              global_fluid_bounding_boxes,\\n                                              tracer_particle_handler);\\n \\n    pcout << \\\"Tracer particles: \\\"\\n          << tracer_particle_handler.n_global_particles() << std::endl;\\n \\n    locally_owned_tracer_particle_coordinates =\\n      tracer_particle_handler.locally_owned_particle_ids().tensor_product(\\n complete_index_set(spacedim));\\n \\n    locally_relevant_tracer_particle_coordinates =\\n      locally_owned_tracer_particle_coordinates;\\n  }\\n \\n \\n template <int dim, int spacedim>\\n void StokesImmersedProblem<dim, spacedim>::setup_solid_particles()\\n  {\\n const QGauss<dim> quadrature(fluid_fe->degree + 1);\\n \\n const unsigned int n_properties = 1;\\n    solid_particle_handler.initialize(fluid_tria,\\n StaticMappingQ1<spacedim>::mapping,\\n                                      n_properties);\\n \\n    std::vector<Point<spacedim>> quadrature_points_vec;\\n    quadrature_points_vec.reserve(quadrature.size() *\\n                                  solid_tria.n_locally_owned_active_cells());\\n \\n    std::vector<std::vector<double>> properties;\\n    properties.reserve(quadrature.size() *\\n                       solid_tria.n_locally_owned_active_cells());\\n \\n FEValues<dim, spacedim> fe_v(*solid_fe,\\n                                 quadrature,\\n update_JxW_values | update_quadrature_points);\\n for (const auto &cell : solid_dh.active_cell_iterators())\\n      if (cell->is_locally_owned())\\n        {\\n          fe_v.reinit(cell);\\n const auto &points = fe_v.get_quadrature_points();\\n const auto &JxW    = fe_v.get_JxW_values();\\n \\n for (unsigned int q = 0; q < points.size(); ++q)\\n            {\\n              quadrature_points_vec.emplace_back(points[q]);\\n              properties.emplace_back(\\n                std::vector<double>(n_properties, JxW[q]));\\n            }\\n        }\\n \\n Assert(!global_fluid_bounding_boxes.empty(),\\n           ExcInternalError(\\n \\\"I was expecting the \\\"\\n \\\"global_fluid_bounding_boxes to be filled at this stage. \\\"\\n \\\"Make sure you fill this vector before trying to use it \\\"\\n \\\"here. Bailing out.\\\"));\\n \\n    solid_particle_handler.insert_global_particles(quadrature_points_vec,\\n                                                   global_fluid_bounding_boxes,\\n                                                   properties);\\n \\n    pcout << \\\"Solid particles: \\\" << solid_particle_handler.n_global_particles()\\n          << std::endl;\\n  }\\n \\n \\n \\n \\n template <int dim, int spacedim>\\n void StokesImmersedProblem<dim, spacedim>::initial_setup()\\n  {\\n TimerOutput::Scope t(computing_timer, \\\"Initial setup\\\");\\n \\n    fluid_fe = std::make_unique<FESystem<spacedim>>(\\n FE_Q<spacedim>(par.velocity_degree) ^ spacedim,\\n FE_Q<spacedim>(par.velocity_degree - 1));\\n \\n \\n    solid_fe = std::make_unique<FE_Nothing<dim, spacedim>>();\\n    solid_dh.distribute_dofs(*solid_fe);\\n  }\\n \\n \\n template <int dim, int spacedim>\\n void StokesImmersedProblem<dim, spacedim>::setup_dofs()\\n  {\\n TimerOutput::Scope t(computing_timer, \\\"Setup dofs\\\");\\n \\n    fluid_dh.distribute_dofs(*fluid_fe);\\n \\n    std::vector<unsigned int> stokes_sub_blocks(spacedim + 1, 0);\\n    stokes_sub_blocks[spacedim] = 1;\\n DoFRenumbering::component_wise(fluid_dh, stokes_sub_blocks);\\n \\n auto dofs_per_block =\\n DoFTools::count_dofs_per_fe_block(fluid_dh, stokes_sub_blocks);\\n \\n const unsigned int n_u = dofs_per_block[0], n_p = dofs_per_block[1];\\n \\n    pcout << \\\"   Number of degrees of freedom: \\\" << fluid_dh.n_dofs() << \\\" (\\\"\\n          << n_u << '+' << n_p << \\\" -- \\\"\\n          << solid_particle_handler.n_global_particles() << '+'\\n          << tracer_particle_handler.n_global_particles() << ')' << std::endl;\\n \\n    fluid_owned_dofs.resize(2);\\n    fluid_owned_dofs[0] = fluid_dh.locally_owned_dofs().get_view(0, n_u);\\n    fluid_owned_dofs[1] =\\n      fluid_dh.locally_owned_dofs().get_view(n_u, n_u + n_p);\\n \\n const IndexSet locally_relevant_dofs =\\n DoFTools::extract_locally_relevant_dofs(fluid_dh);\\n    fluid_relevant_dofs.resize(2);\\n    fluid_relevant_dofs[0] = locally_relevant_dofs.get_view(0, n_u);\\n    fluid_relevant_dofs[1] = locally_relevant_dofs.get_view(n_u, n_u + n_p);\\n \\n    {\\n      constraints.reinit(fluid_dh.locally_owned_dofs(), locally_relevant_dofs);\\n \\n const FEValuesExtractors::Vector velocities(0);\\n DoFTools::make_hanging_node_constraints(fluid_dh, constraints);\\n VectorTools::interpolate_boundary_values(\\n        fluid_dh,\\n        0,\\n Functions::ZeroFunction<spacedim>(spacedim + 1),\\n        constraints,\\n        fluid_fe->component_mask(velocities));\\n      constraints.close();\\n    }\\n \\n const auto locally_owned_dofs_per_processor =\\n Utilities::MPI::all_gather(mpi_communicator,\\n                                 fluid_dh.locally_owned_dofs());\\n    {\\n      system_matrix.clear();\\n \\n Table<2, DoFTools::Coupling> coupling(spacedim + 1, spacedim + 1);\\n for (unsigned int c = 0; c < spacedim + 1; ++c)\\n for (unsigned int d = 0; d < spacedim + 1; ++d)\\n if (c == spacedim && d == spacedim)\\n            coupling[c][d] = DoFTools::none;\\n else if (c == spacedim || d == spacedim || c == d)\\n            coupling[c][d] = DoFTools::always;\\n else\\n            coupling[c][d] = DoFTools::none;\\n \\n BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block);\\n \\n DoFTools::make_sparsity_pattern(\\n        fluid_dh, coupling, dsp, constraints, false);\\n \\n SparsityTools::distribute_sparsity_pattern(\\n        dsp,\\n        locally_owned_dofs_per_processor,\\n        mpi_communicator,\\n        locally_relevant_dofs);\\n \\n      system_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);\\n    }\\n \\n    {\\n      preconditioner_matrix.clear();\\n \\n Table<2, DoFTools::Coupling> coupling(spacedim + 1, spacedim + 1);\\n for (unsigned int c = 0; c < spacedim + 1; ++c)\\n for (unsigned int d = 0; d < spacedim + 1; ++d)\\n if (c == spacedim && d == spacedim)\\n            coupling[c][d] = DoFTools::always;\\n else\\n            coupling[c][d] = DoFTools::none;\\n \\n BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block);\\n \\n DoFTools::make_sparsity_pattern(\\n        fluid_dh, coupling, dsp, constraints, false);\\n SparsityTools::distribute_sparsity_pattern(\\n        dsp,\\n        locally_owned_dofs_per_processor,\\n        mpi_communicator,\\n        locally_relevant_dofs);\\n      preconditioner_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);\\n    }\\n \\n    locally_relevant_solution.reinit(fluid_owned_dofs,\\n                                     fluid_relevant_dofs,\\n                                     mpi_communicator);\\n    system_rhs.reinit(fluid_owned_dofs, mpi_communicator);\\n    solution.reinit(fluid_owned_dofs, mpi_communicator);\\n  }\\n \\n \\n \\n template <int dim, int spacedim>\\n void StokesImmersedProblem<dim, spacedim>::assemble_stokes_system()\\n  {\\n    system_matrix         = 0;\\n    preconditioner_matrix = 0;\\n    system_rhs            = 0;\\n \\n TimerOutput::Scope t(computing_timer, \\\"Assemble Stokes terms\\\");\\n \\n const QGauss<spacedim> quadrature_formula(fluid_fe->degree + 1);\\n FEValues<spacedim>     fe_values(*fluid_fe,\\n                                 quadrature_formula,\\n update_values | update_gradients |\\n update_quadrature_points |\\n update_JxW_values);\\n \\n const unsigned int dofs_per_cell = fluid_fe->n_dofs_per_cell();\\n const unsigned int n_q_points    = quadrature_formula.size();\\n \\n FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n FullMatrix<double> cell_matrix2(dofs_per_cell, dofs_per_cell);\\n Vector<double>     cell_rhs(dofs_per_cell);\\n \\n    std::vector<Vector<double>> rhs_values(n_q_points,\\n Vector<double>(spacedim + 1));\\n \\n    std::vector<Tensor<2, spacedim>> grad_phi_u(dofs_per_cell);\\n    std::vector<double>              div_phi_u(dofs_per_cell);\\n    std::vector<double>              phi_p(dofs_per_cell);\\n \\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n const FEValuesExtractors::Vector     velocities(0);\\n const FEValuesExtractors::Scalar     pressure(spacedim);\\n \\n for (const auto &cell : fluid_dh.active_cell_iterators())\\n      if (cell->is_locally_owned())\\n        {\\n cell_matrix  = 0;\\n          cell_matrix2 = 0;\\n          cell_rhs     = 0;\\n \\n          fe_values.reinit(cell);\\n          par.rhs.vector_value_list(fe_values.get_quadrature_points(),\\n                                    rhs_values);\\n for (unsigned int q = 0; q < n_q_points; ++q)\\n            {\\n for (unsigned int k = 0; k < dofs_per_cell; ++k)\\n                {\\n                  grad_phi_u[k] = fe_values[velocities].gradient(k, q);\\n                  div_phi_u[k]  = fe_values[velocities].divergence(k, q);\\n                  phi_p[k]      = fe_values[pressure].value(k, q);\\n                }\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n                {\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n                    {\\n cell_matrix(i, j) +=\\n                        (par.viscosity *\\n                           scalar_product(grad_phi_u[i], grad_phi_u[j]) -\\n                         div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *\\n                        fe_values.JxW(q);\\n \\n                      cell_matrix2(i, j) += 1.0 / par.viscosity * phi_p[i] *\\n                                            phi_p[j] * fe_values.JxW(q);\\n                    }\\n \\n const unsigned int component_i =\\n                    fluid_fe->system_to_component_index(i).first;\\n                  cell_rhs(i) += fe_values.shape_value(i, q) *\\n                                 rhs_values[q](component_i) * fe_values.JxW(q);\\n                }\\n            }\\n \\n \\n          cell->get_dof_indices(local_dof_indices);\\n          constraints.distribute_local_to_global(cell_matrix,\\n                                                 cell_rhs,\\n                                                 local_dof_indices,\\n                                                 system_matrix,\\n                                                 system_rhs);\\n \\n          constraints.distribute_local_to_global(cell_matrix2,\\n                                                 local_dof_indices,\\n                                                 preconditioner_matrix);\\n        }\\n \\n    system_matrix.compress(VectorOperation::add);\\n    preconditioner_matrix.compress(VectorOperation::add);\\n    system_rhs.compress(VectorOperation::add);\\n  }\\n \\n \\n template <int dim, int spacedim>\\n void StokesImmersedProblem<dim, spacedim>::assemble_nitsche_restriction()\\n  {\\n TimerOutput::Scope t(computing_timer, \\\"Assemble Nitsche terms\\\");\\n \\n const FEValuesExtractors::Vector velocities(0);\\n const FEValuesExtractors::Scalar pressure(spacedim);\\n \\n    SolidVelocity<spacedim> solid_velocity(par.angular_velocity);\\n \\n    std::vector<types::global_dof_index> fluid_dof_indices(\\n      fluid_fe->n_dofs_per_cell());\\n \\n FullMatrix<double> local_matrix(fluid_fe->n_dofs_per_cell(),\\n                                    fluid_fe->n_dofs_per_cell());\\n Vector<double>     local_rhs(fluid_fe->n_dofs_per_cell());\\n \\n const auto penalty_parameter =\\n      1.0 / GridTools::minimal_cell_diameter(fluid_tria);\\n \\n auto particle = solid_particle_handler.begin();\\n while (particle != solid_particle_handler.end())\\n      {\\n        local_matrix = 0;\\n        local_rhs    = 0;\\n \\n const auto &cell = particle->get_surrounding_cell();\\n const auto &dh_cell =\\n typename DoFHandler<spacedim>::cell_iterator(*cell, &fluid_dh);\\n        dh_cell->get_dof_indices(fluid_dof_indices);\\n \\n const auto pic = solid_particle_handler.particles_in_cell(cell);\\n Assert(pic.begin() == particle, ExcInternalError());\\n for (const auto &p : pic)\\n          {\\n const Point<spacedim> ref_q  = p.get_reference_location();\\n const Point<spacedim> real_q = p.get_location();\\n const double          JxW    = p.get_properties()[0];\\n \\n for (unsigned int i = 0; i < fluid_fe->n_dofs_per_cell(); ++i)\\n              {\\n const auto comp_i =\\n                  fluid_fe->system_to_component_index(i).first;\\n if (comp_i < spacedim)\\n                  {\\n for (unsigned int j = 0; j < fluid_fe->n_dofs_per_cell();\\n                         ++j)\\n                      {\\n const auto comp_j =\\n                          fluid_fe->system_to_component_index(j).first;\\n if (comp_i == comp_j)\\n                          local_matrix(i, j) +=\\n                            penalty_parameter * par.penalty_term *\\n                            fluid_fe->shape_value(i, ref_q) *\\n                            fluid_fe->shape_value(j, ref_q) * JxW;\\n                      }\\n                    local_rhs(i) += penalty_parameter * par.penalty_term *\\n                                    solid_velocity.value(real_q, comp_i) *\\n                                    fluid_fe->shape_value(i, ref_q) * JxW;\\n                  }\\n              }\\n          }\\n \\n        constraints.distribute_local_to_global(local_matrix,\\n                                               local_rhs,\\n                                               fluid_dof_indices,\\n                                               system_matrix,\\n                                               system_rhs);\\n        particle = pic.end();\\n      }\\n \\n    system_matrix.compress(VectorOperation::add);\\n    system_rhs.compress(VectorOperation::add);\\n  }\\n \\n \\n \\n template <int dim, int spacedim>\\n void StokesImmersedProblem<dim, spacedim>::solve()\\n  {\\n TimerOutput::Scope t(computing_timer, \\\"Solve\\\");\\n \\n    LA::MPI::PreconditionAMG prec_A;\\n    {\\n      LA::MPI::PreconditionAMG::AdditionalData data;\\n \\n#ifdef USE_PETSC_LA\\n      data.symmetric_operator = true;\\n#endif\\n      prec_A.initialize(system_matrix.block(0, 0), data);\\n    }\\n \\n    LA::MPI::PreconditionAMG prec_S;\\n    {\\n      LA::MPI::PreconditionAMG::AdditionalData data;\\n \\n#ifdef USE_PETSC_LA\\n      data.symmetric_operator = true;\\n#endif\\n      prec_S.initialize(preconditioner_matrix.block(1, 1), data);\\n    }\\n \\n const auto A = linear_operator<LA::MPI::Vector>(system_matrix.block(0, 0));\\n const auto amgA = linear_operator(A, prec_A);\\n \\n const auto S =\\n linear_operator<LA::MPI::Vector>(preconditioner_matrix.block(1, 1));\\n const auto amgS = linear_operator(S, prec_S);\\n \\n ReductionControl          inner_solver_control(100,\\n                                          1e-8 * system_rhs.l2_norm(),\\n                                          1.e-2);\\n SolverCG<LA::MPI::Vector> cg(inner_solver_control);\\n \\n const auto invS = inverse_operator(S, cg, amgS);\\n \\n const auto P = block_diagonal_operator<2, LA::MPI::BlockVector>(\\n      std::array<LinearOperator<typename LA::MPI::BlockVector::BlockType>, 2>{\\n        {amgA, amgS}});\\n \\n SolverControl solver_control(system_matrix.m(),\\n                                 1e-10 * system_rhs.l2_norm());\\n \\n SolverFGMRES<LA::MPI::BlockVector> solver(solver_control);\\n \\n    constraints.set_zero(solution);\\n \\n    solver.solve(system_matrix, solution, system_rhs, P);\\n \\n \\n    pcout << \\\"   Solved in \\\" << solver_control.last_step() << \\\" iterations.\\\"\\n          << std::endl;\\n \\n    constraints.distribute(solution);\\n \\n    locally_relevant_solution = solution;\\n const double mean_pressure =\\n VectorTools::compute_mean_value(fluid_dh,\\n QGauss<spacedim>(par.velocity_degree + 2),\\n                                      locally_relevant_solution,\\n                                      spacedim);\\n    solution.block(1).add(-mean_pressure);\\n    locally_relevant_solution.block(1) = solution.block(1);\\n  }\\n \\n \\n \\n \\n template <int dim, int spacedim>\\n void StokesImmersedProblem<dim, spacedim>::refine_and_transfer()\\n  {\\n TimerOutput::Scope               t(computing_timer, \\\"Refine\\\");\\n const FEValuesExtractors::Vector velocity(0);\\n \\n Vector<float> error_per_cell(fluid_tria.n_active_cells());\\n KellyErrorEstimator<spacedim>::estimate(fluid_dh,\\n QGauss<spacedim - 1>(\\n                                              par.velocity_degree + 1),\\n                                            {},\\n                                            locally_relevant_solution,\\n                                            error_per_cell,\\n                                            fluid_fe->component_mask(velocity));\\n \\n if (par.refinement_strategy == \\\"fixed_fraction\\\")\\n      {\\n parallel::distributed::GridRefinement::\\n          refine_and_coarsen_fixed_fraction(fluid_tria,\\n                                            error_per_cell,\\n                                            par.refinement_fraction,\\n                                            par.coarsening_fraction);\\n      }\\n else if (par.refinement_strategy == \\\"fixed_number\\\")\\n      {\\n parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number(\\n          fluid_tria,\\n          error_per_cell,\\n          par.refinement_fraction,\\n          par.coarsening_fraction,\\n          par.max_cells);\\n      }\\n \\n for (const auto &cell : fluid_tria.active_cell_iterators())\\n      {\\n if (cell->refine_flag_set() &&\\n            cell->level() == par.max_level_refinement)\\n          cell->clear_refine_flag();\\n if (cell->coarsen_flag_set() &&\\n            cell->level() == par.min_level_refinement)\\n          cell->clear_coarsen_flag();\\n      }\\n \\n parallel::distributed::SolutionTransfer<spacedim, LA::MPI::BlockVector>\\n      transfer(fluid_dh);\\n \\n    fluid_tria.prepare_coarsening_and_refinement();\\n    transfer.prepare_for_coarsening_and_refinement(locally_relevant_solution);\\n    tracer_particle_handler.prepare_for_coarsening_and_refinement();\\n    solid_particle_handler.prepare_for_coarsening_and_refinement();\\n \\n    fluid_tria.execute_coarsening_and_refinement();\\n \\n    setup_dofs();\\n \\n    transfer.interpolate(solution);\\n    tracer_particle_handler.unpack_after_coarsening_and_refinement();\\n    solid_particle_handler.unpack_after_coarsening_and_refinement();\\n \\n    constraints.distribute(solution);\\n    locally_relevant_solution = solution;\\n  }\\n \\n \\n \\n template <int dim, int spacedim>\\n void\\n  StokesImmersedProblem<dim, spacedim>::output_results(const unsigned int cycle,\\n double time) const\\n {\\n TimerOutput::Scope t(computing_timer, \\\"Output fluid\\\");\\n \\n    std::vector<std::string> solution_names(spacedim, \\\"velocity\\\");\\n    solution_names.emplace_back(\\\"pressure\\\");\\n    std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n      data_component_interpretation(\\n        spacedim, DataComponentInterpretation::component_is_part_of_vector);\\n    data_component_interpretation.push_back(\\n DataComponentInterpretation::component_is_scalar);\\n \\n DataOut<spacedim> data_out;\\n    data_out.attach_dof_handler(fluid_dh);\\n    data_out.add_data_vector(locally_relevant_solution,\\n                             solution_names,\\n DataOut<spacedim>::type_dof_data,\\n                             data_component_interpretation);\\n \\n \\n Vector<float> subdomain(fluid_tria.n_active_cells());\\n for (unsigned int i = 0; i < subdomain.size(); ++i)\\n      subdomain(i) = fluid_tria.locally_owned_subdomain();\\n    data_out.add_data_vector(subdomain, \\\"subdomain\\\");\\n \\n    data_out.build_patches();\\n \\n const std::string filename =\\n \\\"solution-\\\" + Utilities::int_to_string(cycle) + \\\".vtu\\\";\\n    data_out.write_vtu_in_parallel(par.output_directory + \\\"/\\\" + filename,\\n                                   mpi_communicator);\\n \\n static std::vector<std::pair<double, std::string>> times_and_names;\\n    times_and_names.emplace_back(time, filename);\\n    std::ofstream ofile(par.output_directory + \\\"/\\\" + \\\"solution.pvd\\\");\\n DataOutBase::write_pvd_record(ofile, times_and_names);\\n  }\\n \\n \\n template <int dim, int spacedim>\\n void StokesImmersedProblem<dim, spacedim>::output_particles(\\n const Particles::ParticleHandler<spacedim> &particles,\\n    std::string                                 fprefix,\\n const unsigned int                          iter,\\n const double                                time) const\\n {\\n Particles::DataOut<spacedim> particles_out;\\n    particles_out.build_patches(particles);\\n const std::string filename =\\n      (fprefix + \\\"-\\\" + Utilities::int_to_string(iter) + \\\".vtu\\\");\\n    particles_out.write_vtu_in_parallel(par.output_directory + \\\"/\\\" + filename,\\n                                        mpi_communicator);\\n \\n \\n static std::map<std::string, std::vector<std::pair<double, std::string>>>\\n      times_and_names;\\n if (times_and_names.find(fprefix) != times_and_names.end())\\n      times_and_names[fprefix].emplace_back(time, filename);\\n else\\n      times_and_names[fprefix] = {std::make_pair(time, filename)};\\n    std::ofstream ofile(par.output_directory + \\\"/\\\" + fprefix + \\\".pvd\\\");\\n DataOutBase::write_pvd_record(ofile, times_and_names[fprefix]);\\n  }\\n \\n \\n \\n template <int dim, int spacedim>\\n void StokesImmersedProblem<dim, spacedim>::run()\\n  {\\n#ifdef USE_PETSC_LA\\n    pcout << \\\"Running StokesImmersedProblem<\\\"\\n          << Utilities::dim_string(dim, spacedim) << \\\"> using PETSc.\\\"\\n          << std::endl;\\n#else\\n    pcout << \\\"Running StokesImmersedProblem<\\\"\\n          << Utilities::dim_string(dim, spacedim) << \\\"> using Trilinos.\\\"\\n          << std::endl;\\n#endif\\n    par.prm.print_parameters(par.output_directory + \\\"/\\\" + \\\"used_parameters_\\\" +\\n                               std::to_string(dim) + std::to_string(spacedim) +\\n \\\".prm\\\",\\n ParameterHandler::Short);\\n \\n const double time_step    = par.final_time / (par.number_of_time_steps - 1);\\n double       time         = 0;\\n unsigned int output_cycle = 0;\\n \\n for (unsigned int cycle = 0; cycle < par.number_of_time_steps;\\n         ++cycle, time += time_step)\\n      {\\n        par.set_time(time);\\n        pcout << \\\"Cycle \\\" << cycle << ':' << std::endl\\n              << \\\"Time : \\\" << time << \\\", time step: \\\" << time_step << std::endl;\\n \\n if (cycle == 0)\\n          {\\n            make_grid();\\n            initial_setup();\\n            setup_dofs();\\n            setup_tracer_particles();\\n            setup_solid_particles();\\n            tracer_particle_velocities.reinit(\\n              locally_owned_tracer_particle_coordinates, mpi_communicator);\\n            output_results(output_cycle, time);\\n            {\\n TimerOutput::Scope t(computing_timer, \\\"Output tracer particles\\\");\\n              output_particles(tracer_particle_handler,\\n \\\"tracer\\\",\\n                               output_cycle,\\n                               time);\\n            }\\n            {\\n TimerOutput::Scope t(computing_timer, \\\"Output solid particles\\\");\\n              output_particles(solid_particle_handler,\\n \\\"solid\\\",\\n                               output_cycle,\\n                               time);\\n            }\\n          }\\n else\\n          {\\n TimerOutput::Scope t(computing_timer,\\n \\\"Set solid particle position\\\");\\n \\n            SolidPosition<spacedim> solid_position(par.angular_velocity,\\n                                                   time_step);\\n            solid_particle_handler.set_particle_positions(solid_position,\\n false);\\n          }\\n \\n        {\\n TimerOutput::Scope t(computing_timer, \\\"Set tracer particle motion\\\");\\n Particles::Utilities::interpolate_field_on_particles(\\n            fluid_dh,\\n            tracer_particle_handler,\\n            locally_relevant_solution,\\n            tracer_particle_velocities,\\n            fluid_fe->component_mask(FEValuesExtractors::Vector(0)));\\n \\n          tracer_particle_velocities *= time_step;\\n \\n          locally_relevant_tracer_particle_coordinates =\\n            tracer_particle_handler.locally_owned_particle_ids().tensor_product(\\n complete_index_set(spacedim));\\n \\n          relevant_tracer_particle_displacements.reinit(\\n            locally_owned_tracer_particle_coordinates,\\n            locally_relevant_tracer_particle_coordinates,\\n            mpi_communicator);\\n \\n          relevant_tracer_particle_displacements = tracer_particle_velocities;\\n \\n          tracer_particle_handler.set_particle_positions(\\n            relevant_tracer_particle_displacements);\\n        }\\n \\n        assemble_stokes_system();\\n        assemble_nitsche_restriction();\\n        solve();\\n \\n if (cycle % par.output_frequency == 0)\\n          {\\n            output_results(output_cycle, time);\\n            {\\n TimerOutput::Scope t(computing_timer, \\\"Output tracer particles\\\");\\n              output_particles(tracer_particle_handler,\\n \\\"tracer\\\",\\n                               output_cycle,\\n                               time);\\n            }\\n            {\\n TimerOutput::Scope t(computing_timer, \\\"Output solid particles\\\");\\n              output_particles(solid_particle_handler,\\n \\\"solid\\\",\\n                               output_cycle,\\n                               time);\\n            }\\n            ++output_cycle;\\n          }\\n if (cycle % par.refinement_frequency == 0 &&\\n            cycle != par.number_of_time_steps - 1)\\n          refine_and_transfer();\\n      }\\n  }\\n \\n} // namespace Step70\\n \\n \\n \\nint main(int argc, char *argv[])\\n{\\n using namespace Step70;\\n using namespace dealii;\\n deallog.depth_console(1);\\n try\\n    {\\n Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);\\n \\n      std::string prm_file;\\n if (argc > 1)\\n        prm_file = argv[1];\\n else\\n        prm_file = \\\"parameters.prm\\\";\\n \\n if (prm_file.find(\\\"23\\\") != std::string::npos)\\n        {\\n          StokesImmersedProblemParameters<2, 3> par;\\n ParameterAcceptor::initialize(prm_file);\\n \\n          StokesImmersedProblem<2, 3> problem(par);\\n          problem.run();\\n        }\\n else if (prm_file.find('3') != std::string::npos)\\n        {\\n          StokesImmersedProblemParameters<3> par;\\n ParameterAcceptor::initialize(prm_file);\\n \\n          StokesImmersedProblem<3> problem(par);\\n          problem.run();\\n        }\\n else\\n        {\\n          StokesImmersedProblemParameters<2> par;\\n ParameterAcceptor::initialize(prm_file);\\n \\n          StokesImmersedProblem<2> problem(par);\\n          problem.run();\\n        }\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n \\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n \\n return 0;\\n}\\naffine_constraints.h\\nblock_linear_operator.h\\nDataOutInterface::write_vtu_in_parallelvoid write_vtu_in_parallel(const std::string &filename, const MPI_Comm comm) constDefinition data_out_base.cc:7715\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nFunction::valuevirtual RangeNumberType value(const Point< dim > &p, const unsigned int component=0) const\\nGridIn::readvoid read(std::istream &in, Format format=Default)Definition grid_in.cc:4174\\nIndexSet::get_viewIndexSet get_view(const size_type begin, const size_type end) constDefinition index_set.cc:273\\nconditional_ostream.h\\ngrid_refinement.h\\nsolution_transfer.h\\ntria.h\\ndof_handler.h\\ndof_renumbering.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nerror_estimator.h\\nfe_values.h\\nfe_nothing.h\\nfe_q.h\\nfe_system.h\\nfull_matrix.h\\nfunction.h\\ngenerators.h\\ngeneric_linear_algebra.h\\nmanifold_lib.h\\ngrid_generator.h\\ngrid_in.h\\ngrid_tools.h\\nutilities.h\\nutilities.h\\nutilities.h\\nindex_set.h\\nlinear_operator.h\\nlinear_operator_tools.h\\nmapping_fe_field.h\\nmapping_q1.h\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\nPatterns::Tools::to_valuevoid to_value(const std::string &s, T &t)Definition patterns.h:2398\\nUtilities::MPI::this_mpi_processunsigned int this_mpi_process(const MPI_Comm mpi_communicator)Definition mpi.cc:107\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\nparallel::distributed::GridRefinement::refine_and_coarsen_fixed_fractionvoid refine_and_coarsen_fixed_fraction(::Triangulation< dim, spacedim > &tria, const ::Vector< Number > &criteria, const double top_fraction_of_error, const double bottom_fraction_of_error, const VectorTools::NormType norm_type=VectorTools::L1_norm)Definition grid_refinement.cc:576\\ntypes::manifold_idunsigned int manifold_idDefinition types.h:156\\ndata_out.h\\nmanifold_lib.h\\nparameter_acceptor.h\\nparsed_function.h\\nparticle_handler.h\\ndata_out.h\\npetsc_precondition.h\\npetsc_solver.h\\npetsc_sparse_matrix.h\\npetsc_vector.h\\nquadrature_lib.h\\nsolver_cg.h\\nsolver_gmres.h\\nsolver_minres.h\\nsparsity_tools.h\\ntimer.h\\nvector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"