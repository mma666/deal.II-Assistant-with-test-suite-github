"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_81.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-81 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-81 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-81 tutorial program\\n\\n\\nThis tutorial depends on step-6.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nTime-Harmonic Maxwell's Equations with interface conditions\\n\\nDerivation of time-harmonic Maxwell's equations\\nJump conditions on lower dimensional interfaces\\n Rescaling \\n Variational Statement\\nAbsorbing boundary conditions and the perfectly matched layer\\n\\n Discretization Scheme\\nPerfectly Matched Layer\\n\\n The commented program\\n\\nInclude files\\nClass Template Declarations\\n\\nParameters Class\\nPerfectlyMatchedLayer Class\\nMaxwell Class\\n\\nClass Template Definitions and Implementation\\n\\nThe Constructor\\n\\n\\n\\n Results\\n\\n Absorbing boundary conditions and the PML \\n Surface Plasmon Polariton \\n Notes \\n\\n Real and Complex Matrices \\n Rotations and Scaling \\n Postprocessing \\n\\n Possibilities for Extension \\n\\n The plain program\\n   \\n This program was contributed by Manaswinee Bezbaruah (Texas A&M University), and Matthias Maier (Texas A&M University). \\n\\nIntroduction \\nA surface plasmon-polariton (SPP) is a slowly decaying electromagnetic wave that is confined near a metal-air (or similar) interface. SPP structures on novel \\\"2D\\\" materials such as graphene, a monoatomic layer of carbon atoms arranged in a hexagonal lattice, typically have wavelengths much shorter than the wavelength of the free-space radiation. This scale separation makes SPPs on 2D materials a promising ingredient in the design of novel optical devices.\\nIn the following, we discuss a method for observing SPPs numerically by solving a suitable electromagnetic model based on time-harmonic Maxwell's equations which incorporate jump conditions on lower-dimensional material interfaces: The conducting sheet is modeled as an idealized hypersurface with an effective electric conductivity and the weak discontinuity for the tangential surface appears naturally in the variational form.\\nThis tutorial presents a direct solver for the time-harmonic Maxwell equations for scattering configurations with lower-dimensional interfaces. In particular, we discuss using complex values, simple first-order absorbing boundary conditions, and a more sophisticated perfectly matched layer (PML) boundary condition for electromagnetic waves.\\nTime-Harmonic Maxwell's Equations with interface conditions\\nWe start the discussion with a short derivation of the governing equations and some literature references.\\nDerivation of time-harmonic Maxwell's equations\\nIn two ( \\\\(d=2\\\\)) or three ( \\\\(d=3\\\\)) spatial dimensions, the time evolution of an electromagnetic wave \\\\((\\\\mathbf{E},\\\\mathbf{H})\\\\) that consists of an electric field component \\\\(\\\\mathbf{E}(t,\\\\mathbf{x})\\\\;:\\\\;\\\\mathbb{R}\\\\times\\\\mathbb{R}^d\\\\to\\\\mathbb{R}^d\\\\) and a magnetic field component \\\\(\\\\mathbf{H}(t,\\\\mathbf{x})\\\\;:\\\\;\\\\mathbb{R}\\\\times\\\\mathbb{R}^d\\\\to\\\\mathbb{R}^d\\\\) is described by Maxwell's equations [192], [156] :         \\n\\\\begin{align*}\\n  \\\\frac{\\\\partial}{\\\\partial t} \\\\mathbf{H} + \\\\nabla \\\\times \\\\mathbf{E} &= -\\\\mathbf{M}_a,\\n  \\\\\\\\\\n  \\\\nabla \\\\cdot \\\\mathbf{H} &= \\\\rho_m,\\n  \\\\\\\\\\n  \\\\frac{\\\\partial}{\\\\partial t} (\\\\varepsilon\\\\mathbf{E}) - \\\\nabla\\\\times(\\\\mu^{-1}\\\\mathbf{H}) &= - \\\\mathbf{J}_a,\\n  \\\\\\\\\\n  \\\\nabla\\\\cdot(\\\\varepsilon\\\\mathbf{E}) &= \\\\rho.\\n\\\\end{align*}\\n\\n Here, \\\\(\\\\nabla\\\\times\\\\) is the curl operator, \\\\(\\\\nabla\\\\cdot\\\\) is the divergence operator, \\\\(\\\\varepsilon\\\\) is the electric permittivity, \\\\(\\\\mu\\\\) is the magnetic permeability, \\\\(\\\\rho\\\\) is the electric charge density, and \\\\(\\\\rho_m\\\\) is a corresponding (hypothetical) magnetic monopole density. \\\\(\\\\mathbf{J}_a\\\\) and \\\\(\\\\mathbf{M}_a\\\\) are the electric and magnetic flux densities which are related to their respective charge densities by the conservation equations [192] \\n\\\\[\\n\\\\frac{\\\\partial}{\\\\partial t} \\\\rho + \\\\nabla\\\\cdot\\\\mathbf{J}_a = 0\\n\\\\text{ and }\\n\\\\frac{\\\\partial}{\\\\partial t} \\\\rho_m + \\\\nabla\\\\cdot\\\\mathbf{M}_a = 0.\\n\\\\]\\n\\nWe now make the important assumption that the material parameters \\\\(\\\\varepsilon\\\\) and \\\\(\\\\mu\\\\) are time-independent and that the fields \\\\(\\\\mathbf{E}\\\\) and \\\\(\\\\mathbf{H}\\\\), the fluxes \\\\(\\\\mathbf{M}_a\\\\) and \\\\(\\\\mathbf{J}_a\\\\), as well as the densities \\\\(\\\\rho\\\\) and \\\\(\\\\rho_m\\\\) are all time-harmonic, i.e., their time evolution is completely described by    \\n\\\\[\\n  \\\\mathbf{F}(\\\\mathbf{x},t) = \\\\text{Re}\\\\{e^{-i\\\\omega\\n  t}\\\\tilde{\\\\mathbf{F}}(\\\\mathbf{x})\\\\},\\n\\\\]\\n\\n in which \\\\(\\\\omega\\\\) is the temporal angular frequency and \\\\(\\\\tilde{\\\\mathbf{F}}(\\\\mathbf{x})\\\\) is a corresponding complex-valued vector field (or density). Inserting this ansatz into Maxwell's equations, substituting the charge conservation equations and some minor algebra then yields the so-called time-harmonic Maxwell's equations:             \\n\\\\begin{align*}\\n  -i\\\\omega \\\\tilde{\\\\mathbf{H}} + \\\\nabla \\\\times \\\\tilde{\\\\mathbf{E}} &=\\n  -\\\\tilde{\\\\mathbf{M}}_a,\\n  \\\\\\\\\\n  \\\\nabla \\\\cdot \\\\tilde{\\\\mathbf{H}} &= \\\\frac{1}{i\\\\omega}\\\\nabla \\\\cdot\\n  \\\\tilde{\\\\mathbf{M}}_a,\\n  \\\\\\\\\\n  i\\\\omega\\\\varepsilon\\\\tilde{\\\\mathbf{E}} +\\n  \\\\nabla\\\\times(\\\\mu^{-1}\\\\tilde{\\\\mathbf{H}}) &= \\\\tilde{\\\\mathbf{J}}_a,\\n  \\\\\\\\\\n  \\\\nabla\\\\cdot(\\\\varepsilon\\\\tilde{\\\\mathbf{E}}) &=\\n  \\\\frac{1}{i\\\\omega}\\\\nabla\\\\cdot\\\\tilde{\\\\mathbf{J}}_a.\\n\\\\end{align*}\\n\\nFor the sake of better readability we will now drop the tilde and simply write \\\\(\\\\mathbf{E}(\\\\mathbf{x})\\\\), \\\\(\\\\mathbf{H}(\\\\mathbf{x})\\\\), etc., when referring to the time-harmonic fields.\\nJump conditions on lower dimensional interfaces\\nGraphene is a two-dimensional carbon allotrope with a single atom layer that is arranged in a honeycomb lattice [167]. Due to its atomic thickness it is an example of a so-called 2D material: Compared to the other spatial dimensions (where graphene samples can reach up to several centimeters) the atomistic thickness of graphene typically ranges around 2.5 \\u00e5ngstrom ( \\\\(2.5\\\\times10^{-10}\\\\text{m}\\\\)). We will thus model graphene as a lower-dimensional interface \\\\(\\\\Sigma\\\\) embedded into the computational domain \\\\(\\\\Omega\\\\subset\\\\mathbb{R}^d\\\\). More precisely, \\\\(\\\\Sigma\\\\) is a two-dimensional sheet in three spatial dimensions, or a one-dimensional line in two spatial dimensions. The special electronic structure of graphene gives rise to a current density on the lower-dimensional interface that is modeled with an effective surface conductivity \\\\(\\\\sigma^\\\\Sigma\\\\) obeying Ohm's Law:   \\n\\\\[\\n  \\\\mathbf{J}^\\\\Sigma=\\\\sigma^\\\\Sigma\\\\,\\\\mathbf{E}_T\\n\\\\]\\n\\n in which \\\\(\\\\mathbf{J}^\\\\Sigma\\\\) is the surface current density, \\\\(\\\\mathbf{E}_T\\\\) denotes the tangential part of the electric field \\\\(\\\\mathbf{E}\\\\), and \\\\(\\\\sigma^\\\\Sigma\\\\) is an appropriately chosen surface conductivity that will be discussed in more detail below. The surface current density gives rise to a jump condition on \\\\(\\\\Sigma\\\\) in the tangential component of the magnetic field. This is best seen by visualizing Amp\\u00e8re's law:\\n\\n\\n\\n\\n\\nand then taking the limit of the upper and lower part of the line integral approaching the sheet. In contrast, the tangential part of the electric field is continuous. By fixing a unit normal \\\\(\\\\mathbf{\\\\nu}\\\\) on the hypersurface \\\\(\\\\Sigma\\\\) both jump conditions are      \\n\\\\begin{align*}\\n\\\\mathbf{\\\\nu} \\\\times \\\\left[(\\\\mu^{-1}\\\\mathbf{H})^+ - (\\\\mu^{-1}\\\\mathbf{H})^-\\\\right]|_{\\\\Sigma}\\n&= \\\\sigma^{\\\\Sigma}\\\\left[(\\\\mathbf{\\\\nu}\\\\times \\\\mathbf{E}\\\\times \\\\mathbf{\\\\nu})\\\\right]|_{\\\\Sigma},\\n\\\\\\\\\\n\\\\mathbf{\\\\nu} \\\\times \\\\left[\\\\mathbf{E}^+ - \\\\mathbf{E}^-\\\\right]|_{\\\\Sigma} &= 0.\\n\\\\end{align*}\\n\\n The notation \\\\(\\\\mathbf{F}^\\\\pm\\\\) indicates the limit values of the field when approaching the interface from above or below the interface: \\\\(\\\\mathbf{F}^\\\\pm(\\\\mathbf{x})=\\\\lim_{\\\\delta\\\\to0,\\\\delta>0}\\\\mathbf{F}(\\\\mathbf{x}\\\\pm\\\\delta\\\\mathbf{\\\\nu})\\\\).\\nRescaling \\nWe will be using a rescaled version of the Maxwell's equations described above. The rescaling has the following key differences: \\n\\nEvery length is rescaled by the free-space wavelength  \\\\(2\\\\pi k^{-1}\\n\\\\dealcoloneq 2\\\\pi(\\\\omega\\\\sqrt{\\\\varepsilon_0\\\\mu_0})^{-1}\\\\), in which \\\\(\\\\varepsilon_0\\\\) and \\\\(\\\\mu_0\\\\) denote the vacuum dielectric permittivity and magnetic permeability, respectively. \\n\\n\\\\(\\\\mathbf{E}\\\\), \\\\(\\\\mathbf{H}\\\\), \\\\(\\\\mathbf{J}_a\\\\), \\\\(\\\\mathbf{M}_a\\\\) are all rescaled by typical electric current strength \\\\(J_0\\\\), i.e., the strength of the prescribed dipole source at location \\\\(a\\\\) in the \\\\(e_i\\\\) direction in Cartesian coordinates (here, \\\\(\\\\delta\\\\) is the Dirac delta operator).   \\n\\\\[\\n\\\\mathbf{J}_a = J_0 \\\\mathbf{e}_i\\\\delta(x-a)\\n\\\\]\\n\\n\\n\\nAccordingly, our electric permittivity and magnetic permeability are rescaled by \\\\(\\\\varepsilon_0\\\\) and \\\\(\\\\mu_0\\\\) as     \\n\\\\[\\n\\\\mu_r = \\\\frac{1}{\\\\mu_0}\\\\mu\\n\\\\text{ and }\\n\\\\varepsilon_r = \\\\frac{1}{\\\\varepsilon_0}\\\\varepsilon.\\n\\\\]\\n\\nWe use the free-space wave number \\\\(k_0 = \\\\omega\\\\sqrt{\\\\varepsilon_0\\\\mu_0}\\\\) and the dipole strength, \\\\(J_0\\\\) to arrive at the following rescaling of the vector fields and coordinates:        \\n\\\\begin{align*}\\n\\\\hat{x} = k_0x, &\\\\qquad\\n\\\\hat{\\\\nabla} = \\\\frac{1}{k_0}\\\\nabla,\\\\\\\\\\n\\\\hat{\\\\mathbf{H}} = \\\\frac{k_0}{J_0}\\\\mu^{-1}\\\\mathbf{H},&\\\\qquad\\n\\\\hat{\\\\mathbf{E}} = \\\\frac{k_0^2}{\\\\omega\\\\mu_0 J_0}\\\\mathbf{E},\\\\\\\\\\n\\\\hat{\\\\mathbf{J}}_a = \\\\frac{1}{J_0}\\\\mathbf{J}_a,&\\\\qquad\\n\\\\hat{\\\\mathbf{M}}_a = \\\\frac{k_0}{\\\\omega\\\\mu_0 J_0}\\\\mathbf{M}_a.\\n\\\\end{align*}\\n\\nFinally, the interface conductivity is rescaled as   \\n\\\\[\\n\\\\sigma^{\\\\Sigma}_r = \\\\sqrt{\\\\frac{\\\\mu_0}{\\\\varepsilon_0}}\\\\sigma^{\\\\Sigma}.\\n\\\\]\\n\\nAccordingly, our rescaled equations are             \\n\\\\begin{align*}\\n  -i\\\\mu_r \\\\hat{\\\\mathbf{H}} + \\\\hat{\\\\nabla} \\\\times \\\\hat{\\\\mathbf{E}}\\n  &= -\\\\hat{\\\\mathbf{M}}_a,\\n  \\\\\\\\\\n  \\\\hat{\\\\nabla} \\\\cdot (\\\\mu_r\\\\hat{\\\\mathbf{H}}) &= \\\\frac{1}{i\\\\omega}\\\\hat{\\\\nabla}\\n  \\\\cdot \\\\hat{\\\\mathbf{M}}_a,\\n  \\\\\\\\\\n  i\\\\varepsilon_r\\\\hat{\\\\mathbf{E}} + \\\\nabla\\\\times(\\\\mu^{-1}\\\\mathbf{H})\\n  &= \\\\mathbf{J}_a,\\n  \\\\\\\\\\n  \\\\nabla\\\\cdot(\\\\varepsilon\\\\mathbf{E}) &= \\\\frac{1}{i\\\\omega}\\\\hat{\\\\nabla}\\n  \\\\cdot\\\\hat{\\\\mathbf{J}}_a.\\n\\\\end{align*}\\n\\nWe will omit the hat in further discussion for ease of notation.\\nVariational Statement\\nLet \\\\(\\\\Omega \\\\subset \\\\mathbb{R}^n\\\\), \\\\((n = 2,3)\\\\) be a simply connected and bounded domain with Lipschitz-continuous and piecewise smooth boundary, \\\\(\\\\partial\\\\Omega\\\\). Let \\\\(\\\\Sigma\\\\) be an oriented, Lipschitz-continuous, piecewise smooth hypersurface. Fix a normal field \\\\(\\\\nu\\\\) on \\\\(\\\\Sigma\\\\) and let \\\\(n\\\\) denote the outer normal vector on \\\\(\\\\partial\\\\Omega\\\\).\\nIn order to arrive at the variational form, we will substitute for \\\\(\\\\mathbf{H}\\\\) in the first equation and obtain    \\n\\\\[\\n\\\\nabla \\\\times (\\\\mu_r^{-1}\\\\nabla\\\\times\\\\mathbf{E}) - \\\\varepsilon_r \\\\mathbf{E}\\n= i\\\\mathbf{J}_a - \\\\nabla\\\\times (\\\\mu_r^{-1}\\\\mathbf{M}_a).\\n\\\\]\\n\\nNow, consider a smooth test function \\\\(\\\\varphi\\\\) with complex conjugate \\\\(\\\\bar{\\\\varphi}\\\\). Multiply both sides of the above equation by \\\\(\\\\bar{\\\\varphi}\\\\) and integrate by parts in \\\\(\\\\Omega\\\\backslash\\\\Sigma\\\\).          \\n\\\\[\\n\\\\int_\\\\Omega (\\\\mu_r^{-1}\\\\nabla\\\\times\\\\mathbf{E})\\\\cdot (\\\\nabla\\\\times\\\\bar{\\\\varphi})\\\\;\\\\text{d}x\\n- \\\\int_\\\\Omega \\\\varepsilon_r\\\\mathbf{E} \\\\cdot \\\\bar{\\\\varphi}\\\\;\\\\text{d}x\\n- \\\\int_\\\\Sigma [\\\\nu \\\\times (\\\\mu_r^{-1}\\\\nabla\\\\times\\\\mathbf{E} +\\n\\\\mu^{-1}\\\\mathbf{M}_a)]_{\\\\Sigma}\\\\cdot \\\\bar{\\\\varphi}_T\\\\;\\\\text{d}o_x\\\\\\\\\\n\\\\qquad - \\\\int_{\\\\partial\\\\Omega} (\\\\nu \\\\times (\\\\mu_r^{-1}\\\\nabla\\\\times\\\\mathbf{E} +\\n\\\\mu^{-1}\\\\mathbf{M}_a)) \\\\cdot \\\\bar{\\\\varphi}_T\\\\;\\\\text{d}o_x =\\ni\\\\int_\\\\Omega \\\\mathbf{J}_a \\\\cdot \\\\bar{\\\\varphi}\\\\;\\\\text{d}x\\n- \\\\int_\\\\Omega \\\\mu_r^{-1}\\\\mathbf{M}_a \\\\cdot (\\\\nabla \\\\times \\\\bar{\\\\varphi})\\\\;\\\\text{d}x.\\n\\\\]\\n\\nWe use the subscript \\\\(T\\\\) to denote the tangential part of the given vector and \\\\([\\\\cdot]_{\\\\Sigma}\\\\) to denote a jump over \\\\(\\\\Sigma\\\\), i.e.,     \\n\\\\[\\n  \\\\mathbf{F}_T = (\\\\mathbf{\\\\nu}\\\\times \\\\mathbf{F})\\\\times\\\\mathbf{\\\\nu}\\n  \\\\text{ and }\\n  [\\\\mathbf{F}]_{\\\\Sigma}(\\\\mathbf{x}) = \\\\lim\\\\limits_{s\\\\searrow 0}(\\\\mathbf{F}(\\\\mathbf{x}+s\\\\mathbf{\\\\nu})-\\\\mathbf{F}(\\\\mathbf{x}-s\\\\mathbf{\\\\nu}))\\n\\\\]\\n\\n for \\\\(\\\\mathbf{x}\\\\in \\\\Sigma\\\\).\\nFor the computational domain \\\\(\\\\Omega\\\\), we introduce the absorbing boundary condition at \\\\(\\\\partial\\\\Omega\\\\), which is obtained by using a first-order approximation of the Silver-M\\u00fcller radiation condition, truncated at \\\\(\\\\partial\\\\Omega\\\\) [156].   \\n\\\\[\\n\\\\nu\\\\times\\\\mathbf{H}+\\\\sqrt{\\\\mu_r^{-1}\\\\varepsilon_r}\\\\mathbf{E}=0\\\\qquad x\\\\in\\\\partial\\\\Omega\\n\\\\]\\n\\n We assume that \\\\(\\\\mu_r^{-1}\\\\) and \\\\(\\\\varepsilon\\\\) have well-defined square roots. In our numerical computation, we combine the above absorbing boundary condition with a PML.\\nThe jump condition can be expressed as a weak discontinuity as follows:      \\n\\\\[\\n[\\\\nu \\\\times (\\\\mu_r^{-1}\\\\nabla\\\\times\\\\mathbf{E} + \\\\mu^{-1}\\\\mathbf{M}_a)]_{\\\\Sigma}\\n= i\\\\sigma_r^{\\\\Sigma}\\\\mathbf{E}_T,\\\\qquad \\\\text{on }\\\\Sigma\\\\\\\\\\n\\\\nu \\\\times (\\\\mu_r^{-1}\\\\nabla\\\\times\\\\mathbf{E} + \\\\mu^{-1}\\\\mathbf{M}_a)\\n= -i\\\\sqrt{\\\\mu_r^{-1}\\\\varepsilon_r}\\\\mathbf{E}_T,\\\\qquad \\\\text{on }\\\\partial\\\\Omega.\\n\\\\]\\n\\nCombining, our weak form is as follows:         \\n\\\\[\\n\\\\int_\\\\Omega (\\\\mu_r^{-1}\\\\nabla\\\\times\\\\mathbf{E})\\\\cdot (\\\\nabla\\\\times\\\\bar{\\\\varphi})\\\\;\\\\text{d}x\\n- \\\\int_\\\\Omega \\\\varepsilon_r\\\\mathbf{E} \\\\cdot \\\\bar{\\\\varphi}\\\\;\\\\text{d}x\\n- i\\\\int_\\\\Sigma (\\\\sigma_r^{\\\\Sigma}\\\\mathbf{E}_T) \\\\cdot \\\\bar{\\\\varphi}_T\\\\;\\\\text{d}o_x\\\\\\\\\\n\\\\qquad - i\\\\int_{\\\\partial\\\\Omega} (\\\\sqrt{\\\\mu_r^{-1}\\\\varepsilon}\\\\mathbf{E}_T) \\\\cdot\\n(\\\\nabla\\\\times\\\\bar{\\\\varphi}_T)\\\\;\\\\text{d}o_x.=\\ni\\\\int_\\\\Omega \\\\mathbf{J}_a \\\\cdot \\\\bar{\\\\varphi}\\\\;\\\\text{d}x\\n- \\\\int_\\\\Omega \\\\mu_r^{-1}\\\\mathbf{M}_a \\\\cdot (\\\\nabla \\\\times \\\\bar{\\\\varphi})\\\\;\\\\text{d}x.\\n\\\\]\\n\\nAssume that \\\\(\\\\sigma_r^{\\\\Sigma} \\\\in L^{\\\\infty}(\\\\Sigma)^{2\\\\times 2}\\\\) is matrix-valued and symmetric, and has a semidefinite real and complex part. Let \\\\(\\\\varepsilon_r\\\\) be a smooth scalar function with \\\\(-\\\\text{Im}(\\\\varepsilon_r) = 0\\\\), or \\\\(\\\\text{Im}(\\\\varepsilon_r)\\\\ge c > 0\\\\) in \\\\(\\\\Omega\\\\). \\\\(\\\\mu_r^{-1}\\\\) is a smooth scalar such that \\\\(\\\\sqrt{\\\\mu_r^{-1}\\\\varepsilon_r}\\\\) is real valued and strictly positive in \\\\(\\\\partial\\\\Omega\\\\).\\n\\\\(\\\\mathbf{H}(\\\\text{curl};\\\\Omega)\\\\) is space of vector-valued, measurable and square integrable functions whose weak curl admits a representation by a square integrable function. Define a Hilbert space    \\n\\\\[\\nX(\\\\Omega) = \\\\{\\\\varphi \\\\in \\\\mathbf{H}(\\\\text{curl};\\\\Omega)\\\\;\\\\;:\\\\;\\\\; \\\\varphi_T|_{\\\\Sigma}\\n\\\\in L^2(\\\\Sigma)^2,\\\\;\\\\varphi_T|_{\\\\partial\\\\Omega} \\\\in L^2(\\\\partial\\\\Omega)^2\\\\}\\n\\\\]\\n\\n equipped with the norm     \\n\\\\[\\n  \\\\|\\\\varphi\\\\|^2_X = \\\\|\\\\varphi\\\\|^2_{L^2(\\\\Omega)} +\\n  \\\\|\\\\nabla\\\\times\\\\varphi\\\\|^2_{L^2(\\\\Omega)} + \\\\|\\\\varphi_T\\\\|^2_{L^2(\\\\Sigma)} +\\n  \\\\|\\\\varphi_T\\\\|^2_{L^2(\\\\partial\\\\Omega)}.\\n\\\\]\\n\\nDefine          \\n\\\\[\\nA(\\\\mathbf{E},\\\\varphi) \\\\dealcoloneq \\\\int_\\\\Omega (\\\\mu_r^{-1}\\\\nabla\\\\times\\\\mathbf{E})\\\\cdot\\n(\\\\nabla\\\\times\\\\bar{\\\\varphi})\\\\;\\\\text{d}x\\n- \\\\int_\\\\Omega \\\\varepsilon_r\\\\mathbf{E} \\\\cdot \\\\bar{\\\\varphi}\\\\;\\\\text{d}x\\n- i\\\\int_\\\\Sigma (\\\\sigma_r^{\\\\Sigma}\\\\mathbf{E}_T) \\\\cdot \\\\bar{\\\\varphi}_T\\\\;\\\\text{d}o_x\\n- i\\\\int_{\\\\partial\\\\Omega} (\\\\sqrt{\\\\mu_r^{-1}\\\\varepsilon}\\\\mathbf{E}_T) \\\\cdot\\n(\\\\nabla\\\\times\\\\bar{\\\\varphi}_T)\\\\;\\\\text{d}o_x.\\\\\\\\\\nF(\\\\varphi) \\\\dealcoloneq i\\\\int_\\\\Omega \\\\mathbf{J}_a \\\\cdot \\\\bar{\\\\varphi}\\\\;\\\\text{d}x\\n- \\\\int_\\\\Omega \\\\mu_r^{-1}\\\\mathbf{M}_a \\\\cdot (\\\\nabla \\\\times \\\\bar{\\\\varphi})\\\\;\\\\text{d}x.\\n\\\\]\\n\\nThen, our rescaled weak formulation is:\\n\\n\\\\[\\n  \\\\text{Find a unique } \\\\mathbf{E} \\\\in X(\\\\Omega) \\\\text{ such that, for all } \\\\varphi \\\\in X(\\\\Omega),\\n\\\\]\\n\\n\\n\\\\[\\n  A(\\\\mathbf{E},\\\\varphi) = F(\\\\varphi).\\n\\\\]\\n\\nAbsorbing boundary conditions and the perfectly matched layer\\nMoreover, the above equations are supplemented by the Silver-M\\u00fcller radiation condition, if the ambient (unbounded) medium is isotropic. This amounts to the requirement that \\\\(\\\\mathbf{E}\\\\) and \\\\(\\\\mathbf{H}\\\\) both approach a spherical wave uniformly in the radial direction for points at infinity and away from the conducting sheet, i.e.,\\n\\n\\\\[\\n\\\\lim\\\\limits_{|x|\\\\to\\\\infty} \\\\{\\\\mathbf{H}\\\\times x - c^{-1}|x|\\\\mathbf{E}\\\\} = 0\\n\\\\text{ and }\\n\\\\lim\\\\limits_{|x|\\\\to\\\\infty} \\\\{\\\\mathbf{E}\\\\times x - c^{-1}|x|\\\\mathbf{H}\\\\} = 0\\n\\\\text{ for }\\nx \\\\not\\\\in \\\\Sigma.\\n\\\\]\\n\\nIn our case, we eliminate reflection from infinity by implementing a PML, which is described at length below, and avoid the explicit use of the last condition.\\nDiscretization Scheme\\nThe variational form is discretized on a non-uniform quadrilateral mesh with higher-order, curl-conforming N\\u00e9d\\u00e9lec elements implemented by the FE_NedelecSZ class. This way the interface with a weak discontinuity is optimal, and we get optimal convergence rates.\\nConsider the finite element subspace \\\\(X_h(\\\\Omega) \\\\subset X(\\\\Omega)\\\\). Define the matrices         \\n\\\\[\\nA_{ij} = \\\\int_\\\\Omega (\\\\mu_r^{-1}\\\\nabla \\\\times \\\\varphi_j) \\\\cdot\\n          (\\\\nabla\\\\times\\\\bar{\\\\varphi}_i)\\\\;\\\\text{d}x\\n          - \\\\int_\\\\Omega \\\\varepsilon_r\\\\varphi_j \\\\cdot \\\\bar{\\\\varphi}_i\\\\;\\\\text{d}x\\n          - i\\\\int_\\\\Sigma (\\\\sigma_r^{\\\\Sigma}\\\\varphi_{j_T}) \\\\cdot\\n          \\\\bar{\\\\varphi}_{i_T}\\\\;\\\\text{d}o_x\\n          - i\\\\int_{\\\\partial\\\\Omega} (\\\\sqrt{\\\\mu_r^{-1}\\\\varepsilon}\\\\varphi_{j_T})\\n          \\\\cdot (\\\\nabla\\\\times \\\\bar{\\\\varphi}_{i_T})\\\\;\\\\text{d}o_x,\\n\\\\]\\n\\n\\n\\\\[\\nF_i = i\\\\int_\\\\Omega \\\\mathbf{J}_a \\\\cdot \\\\bar{\\\\varphi_i}\\\\;\\\\text{d}x\\n      - \\\\int_\\\\Omega \\\\mu_r^{-1}\\\\mathbf{M}_a \\\\cdot (\\\\nabla \\\\times \\\\bar{\\\\varphi_i})\\n      \\\\;\\\\text{d}x.\\n\\\\]\\n\\nThen under the assumption of a sufficiently refined initial mesh the discretized variational problem is:\\n\\n\\\\[\\n  \\\\text{Find a unique } \\\\mathbf{E}_h = \\\\sum_j U_j\\\\mathbf{\\\\varphi}_j \\\\in\\n  X_h(\\\\Omega) \\\\text{ such that}\\n\\\\]\\n\\n\\n\\\\[\\n\\\\sum_jA_{ij}U_j = F_i\\\\qquad\\\\text{for all }i.\\n\\\\]\\n\\nPerfectly Matched Layer\\nThe SPP amplitude is negatively affected by the absorbing boundary condition and this causes the solution image to be distorted. In order to reduce the resonance and distortion in our solutions, we are implementing a Perfectly Matched Layer (PML) in the scattering configuration.\\nThe concept of a PML was pioneered by B\\u00e9renger [28] and it is is an indispensable tool for truncating unbounded domains for wave equations and often used in the numerical approximation of scattering problems. It is essentially a thin layer with modified material parameters placed near the boundary such that all outgoing electromagnetic waves decay exponentially with no \\u201cartificial\\u201d reflection due to truncation of the domain.\\nOur PML is a concentric circle with modified material coefficients ( \\\\(\\\\varepsilon_r, \\\\mu_r, \\\\sigma\\\\)). It is located in a small region near the boundary \\\\(\\\\partial\\\\Omega\\\\) and the transformation of the material coordinates is chosen to be a function of the radial distance \\\\(\\\\rho\\\\) from the origin \\\\(e_r\\\\). The normal field \\\\(\\\\nu\\\\) of \\\\(\\\\Sigma\\\\) is orthogonal to the radial direction \\\\(e_r\\\\), which makes \\\\(\\\\mathbf{J}_a \\\\equiv 0\\\\) and \\\\(\\\\mathbf{M}_a \\\\equiv 0\\\\) within the PML.\\n\\n\\n\\n\\n\\nIntroduce a change of coordinates       \\n\\\\[\\nx \\\\to \\\\bar{x} =\\n\\\\begin{cases}\\nx + ie_r\\\\int\\\\limits_\\\\rho^r s(\\\\tau)\\\\text{d}\\\\tau,\\\\;\\\\;\\\\;\\\\;\\\\;\\\\;\\\\; r\\\\ge\\\\rho\\\\\\\\\\nx\\\\;\\\\;\\\\;\\\\;\\\\;\\\\;\\\\;\\\\;\\\\;\\\\text{otherwise}\\n\\\\end{cases}\\n\\\\]\\n\\nin which \\\\(r = e_r \\\\cdot x\\\\) and \\\\(s(\\\\tau)\\\\) is an appropriately chosen, nonnegative scaling function.\\nWe introduce the following \\\\(2\\\\times2\\\\) matrices         \\n\\\\begin{align*}\\n  A &= T_{e_xe_r}^{-1} \\\\text{diag}\\\\left(\\\\frac{1}{\\\\bar{d}^2},\\n       \\\\frac{1}{d\\\\bar{d}}\\\\right)T_{e_xe_r}\\n       \\\\\\\\\\n  B &= T_{e_xe_r}^{-1} \\\\text{diag}\\\\left(d,\\\\bar{d}\\\\right)T_{e_xe_r}\\n       \\\\\\\\\\n  C &= T_{e_xe_r}^{-1} \\\\text{diag}\\\\left(\\\\frac{1}{\\\\bar{d}},\\\\frac{1}{d}\\\\right)\\n       T_{e_xe_r}\\n\\\\end{align*}\\n\\nin which\\n\\n\\\\begin{align*}\\n  d       &= 1 + is(r) \\\\\\\\\\n  \\\\bar{d} &= 1 + i/r \\\\int\\\\limits_{\\\\rho}^{r}s(\\\\tau)\\\\text{d}\\\\tau\\n\\\\end{align*}\\n\\nand \\\\(T_{e_xe_r}\\\\) is the rotation matrix which rotates \\\\(e_r\\\\) onto \\\\(e_x\\\\). Thus, after applying the rescaling, we get the following modified parameters       \\n\\\\begin{align*}\\n  \\\\bar{\\\\mu}_r^{-1}        &= \\\\frac{\\\\mu_r^{-1}}{d},\\n  \\\\\\\\\\n  \\\\bar{\\\\varepsilon}_r     &= A^{-1} \\\\varepsilon_r B^{-1}, \\\\text{ and }\\n  \\\\\\\\\\n  \\\\bar{\\\\sigma}^{\\\\Sigma}_r &= C^{-1} \\\\sigma^{\\\\Sigma}_r B^{-1}.\\n\\\\end{align*}\\n\\nThese PML transformations are implemented in our PerfectlyMatchedLayer class. After the PML is implemented, the electromagnetic wave essentially decays exponentially within the PML region near the boundary, therefore reducing reflection from the boundary of our finite domain. The decay function also depends on the strength of our PML, which can be adjusted to see more or less visible decaying in the PML region.\\n The commented program\\n Include files\\nThe set of include files is quite standard. The most notable include is the fe/fe_nedelec_sz.h file which allows us to use the FE_NedelecSZ elements. This is an implementation of the \\\\(H^{curl}\\\\) conforming N\\u00e9d\\u00e9lec Elements that resolves the sign conflict issues that arise from parametrization (for details we refer to the documentation of the FE_NedelecSZ element).\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/base/parameter_acceptor.h>\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/tensor.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_accessor.h>\\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_renumbering.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_nedelec_sz.h>\\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_system.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_refinement.h>\\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/tria_accessor.h>\\n\\u00a0 #include <deal.II/grid/tria_iterator.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/precondition.h>\\n\\u00a0 #include <deal.II/lac/solver_cg.h>\\n\\u00a0 #include <deal.II/lac/sparse_direct.h>\\n\\u00a0 #include <deal.II/lac/sparse_ilu.h>\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/error_estimator.h>\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 #include <fstream>\\n\\u00a0 #include <iostream>\\n\\u00a0 #include <memory>\\n\\u00a0 \\n\\u00a0 \\n Class Template Declarations\\nWe begin our actual implementation by declaring all classes with their data structures and methods upfront.\\n\\u00a0 namespace Step81\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0   using namespace std::complex_literals;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n Parameters Class\\nThe Parameters class inherits ParameterAcceptor, and instantiates all the coefficients in our variational equations. These coefficients are passed through ParameterAcceptor and are editable through a .prm file. More explanation on the use and inheritance from the ParameterAcceptor can be found in step-60.\\nepsilon is the Electric Permittivity coefficient and it is a rank 2 tensor. Depending on the material, we assign the i^th diagonal element of the tensor to the material epsilon value (one of the private epsilon_1_ or epsilon_2_ variables).\\nmu_inv is the inverse of the Magnetic Permiability coefficient and it is a complex number.\\nsigma is the Surface Conductivity coefficient between material left and material right and it is a rank 2 tensor. It is only changed if we are at the interface between two materials. If we are at an interface, we assign the i^th diagonal element of the tensor to the private sigma_ value.\\nJ_a is the strength and orientation of the dipole. As mentioned in the rescaling,   \\n\\\\[\\n   \\\\mathbf{J}_a = J_0 \\\\mathbf{e}_i\\\\delta(x-a)\\n   \\\\]\\n\\n It is a rank 1 tensor that depends on the private dipole_position, dipole_radius, dipole_strength, dipole_orientation variables.\\n\\u00a0   template <int dim>\\n\\u00a0   class Parameters : public ParameterAcceptor\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     Parameters();\\n\\u00a0 \\n\\u00a0     using rank0_type = std::complex<double>;\\n\\u00a0 \\n\\u00a0     using rank1_type = Tensor<1, dim, std::complex<double>>;\\n\\u00a0 \\n\\u00a0     using rank2_type = Tensor<2, dim, rank0_type>;\\n\\u00a0 \\n\\u00a0     using curl_type = Tensor<1, dim == 2 ? 1 : dim, rank0_type>;\\n\\u00a0 \\n\\u00a0   public:\\n\\u00a0     rank2_type epsilon(const Point<dim> &x, types::material_id material);\\n\\u00a0 \\n\\u00a0     std::complex<double> mu_inv(const Point<dim>  &x,\\n\\u00a0                                 types::material_id material);\\n\\u00a0 \\n\\u00a0     rank2_type sigma(const Point<dim>  &x,\\n\\u00a0                      types::material_id left,\\n\\u00a0                      types::material_id right);\\n\\u00a0 \\n\\u00a0     rank1_type J_a(const Point<dim> &point, types::material_id id);\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     rank2_type           epsilon_1;\\n\\u00a0     rank2_type           epsilon_2;\\n\\u00a0     std::complex<double> mu_inv_1;\\n\\u00a0     std::complex<double> mu_inv_2;\\n\\u00a0     rank2_type           sigma_tensor;\\n\\u00a0 \\n\\u00a0     double         dipole_radius;\\n\\u00a0     Point<dim>     dipole_position;\\n\\u00a0     Tensor<1, dim> dipole_orientation;\\n\\u00a0     rank0_type     dipole_strength;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   Parameters<dim>::Parameters()\\n\\u00a0     : ParameterAcceptor(\\\"Parameters\\\")\\n\\u00a0   {\\n\\u00a0     epsilon_1[0][0] = 1.;\\n\\u00a0     epsilon_1[1][1] = 1.;\\n\\u00a0     add_parameter(\\\"material 1 epsilon\\\",\\n\\u00a0                   epsilon_1,\\n\\u00a0                   \\\"relative permittivity of material 1\\\");\\n\\u00a0 \\n\\u00a0     epsilon_2[0][0] = 1.;\\n\\u00a0     epsilon_2[1][1] = 1.;\\n\\u00a0     add_parameter(\\\"material 2 epsilon\\\",\\n\\u00a0                   epsilon_2,\\n\\u00a0                   \\\"relative permittivity of material 2\\\");\\n\\u00a0 \\n\\u00a0     mu_inv_1 = 1.;\\n\\u00a0     add_parameter(\\\"material 1 mu_inv\\\",\\n\\u00a0                   mu_inv_1,\\n\\u00a0                   \\\"inverse of relative permeability of material 1\\\");\\n\\u00a0 \\n\\u00a0     mu_inv_2 = 1.;\\n\\u00a0     add_parameter(\\\"material 2 mu_inv\\\",\\n\\u00a0                   mu_inv_2,\\n\\u00a0                   \\\"inverse of relative permeability of material 2\\\");\\n\\u00a0 \\n\\u00a0     sigma_tensor[0][0] = std::complex<double>(0.001, 0.2);\\n\\u00a0     sigma_tensor[1][1] = std::complex<double>(0.001, 0.2);\\n\\u00a0     add_parameter(\\\"sigma\\\",\\n\\u00a0                   sigma_tensor,\\n\\u00a0                   \\\"surface conductivity between material 1 and material 2\\\");\\n\\u00a0 \\n\\u00a0     dipole_radius = 0.3;\\n\\u00a0     add_parameter(\\\"dipole radius\\\", dipole_radius, \\\"radius of the dipole\\\");\\n\\u00a0 \\n\\u00a0     dipole_position = Point<dim>(0., 0.8);\\n\\u00a0     add_parameter(\\\"dipole position\\\", dipole_position, \\\"position of the dipole\\\");\\n\\u00a0 \\n\\u00a0     dipole_orientation = Tensor<1, dim>{{0., 1.}};\\n\\u00a0     add_parameter(\\\"dipole orientation\\\",\\n\\u00a0                   dipole_orientation,\\n\\u00a0                   \\\"orientation of the dipole\\\");\\n\\u00a0 \\n\\u00a0     dipole_strength = 1.;\\n\\u00a0     add_parameter(\\\"dipole strength\\\", dipole_strength, \\\"strength of the dipole\\\");\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   typename Parameters<dim>::rank2_type\\n\\u00a0   Parameters<dim>::epsilon(const Point<dim> & /*x*/,\\n\\u00a0                            types::material_id material)\\n\\u00a0   {\\n\\u00a0     return (material == 1 ? epsilon_1 : epsilon_2);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   std::complex<double> Parameters<dim>::mu_inv(const Point<dim> & /*x*/,\\n\\u00a0                                                types::material_id material)\\n\\u00a0   {\\n\\u00a0     return (material == 1 ? mu_inv_1 : mu_inv_2);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   typename Parameters<dim>::rank2_type\\n\\u00a0   Parameters<dim>::sigma(const Point<dim> & /*x*/,\\n\\u00a0                          types::material_id left,\\n\\u00a0                          types::material_id right)\\n\\u00a0   {\\n\\u00a0     return (left == right ? rank2_type() : sigma_tensor);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   typename Parameters<dim>::rank1_type\\n\\u00a0   Parameters<dim>::J_a(const Point<dim> &point, types::material_id /*id*/)\\n\\u00a0   {\\n\\u00a0     rank1_type J_a;\\n\\u00a0     const auto distance = (dipole_position - point).norm() / dipole_radius;\\n\\u00a0     if (distance > 1.)\\n\\u00a0       return J_a;\\n\\u00a0     double scale = std::cos(distance * M_PI / 2.) *\\n\\u00a0                    std::cos(distance * M_PI / 2.) / (M_PI / 2. - 2. / M_PI) /\\n\\u00a0                    dipole_radius / dipole_radius;\\n\\u00a0     J_a = dipole_strength * dipole_orientation * scale;\\n\\u00a0     return J_a;\\n\\u00a0   }\\n\\u00a0 \\nParameterAcceptorDefinition parameter_acceptor.h:359\\nPointDefinition point.h:111\\nTensorDefinition tensor.h:471\\nunsigned int\\nGridTools::scalevoid scale(const double scaling_factor, Triangulation< dim, spacedim > &triangulation)Definition grid_tools.cc:256\\nLocalIntegrators::Divergence::normdouble norm(const FEValuesBase< dim > &fe, const ArrayView< const std::vector< Tensor< 1, dim > > > &Du)Definition divergence.h:471\\nOpenCASCADE::pointPoint< spacedim > point(const gp_Pnt &p, const double tolerance=1e-10)Definition utilities.cc:191\\nstd::cos::VectorizedArray< Number, width > cos(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6609\\n PerfectlyMatchedLayer Class\\nThe PerfectlyMatchedLayer class inherits ParameterAcceptor as well. It implements the transformation matrices used to modify the permittivity and permeability tensors supplied from the Parameters class. The actual transformation of the material tensors will be done in the assembly loop. The radii and the strength of the PML is specified, and the coefficients will be modified using transformation matrices within the PML region. The radii and strength of the PML are editable through a .prm file. The rotation function \\\\(T_{exer}\\\\) is the same as introduced in the perfectly matched layer section of the introduction. Similarly, the matrices A, B and C are defined as follows       \\n\\\\[\\n   A = T_{e_xe_r}^{-1}\\n   \\\\text{diag}\\\\left(\\\\frac{1}{\\\\bar{d}^2},\\\\frac{1}{d\\\\bar{d}}\\\\right)T_{e_xe_r},\\\\qquad\\n   B = T_{e_xe_r}^{-1} \\\\text{diag}\\\\left(d,\\\\bar{d}\\\\right)T_{e_xe_r},\\\\qquad\\n   C = T_{e_xe_r}^{-1} \\\\text{diag}\\\\left(\\\\frac{1}{\\\\bar{d}},\\\\frac{1}{d}\\\\right)\\n   T_{e_xe_r}.\\\\qquad\\n   \\\\]\\n\\n\\u00a0   template <int dim>\\n\\u00a0   class PerfectlyMatchedLayer : public ParameterAcceptor\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     static_assert(dim == 2,\\n\\u00a0                   \\\"The perfectly matched layer is only implemented in 2d.\\\");\\n\\u00a0 \\n\\u00a0     Parameters<dim> parameters;\\n\\u00a0 \\n\\u00a0     using rank1_type = Tensor<1, dim, std::complex<double>>;\\n\\u00a0 \\n\\u00a0     using rank2_type = Tensor<2, dim, std::complex<double>>;\\n\\u00a0 \\n\\u00a0     PerfectlyMatchedLayer();\\n\\u00a0 \\n\\u00a0     std::complex<double> d(const Point<dim> point);\\n\\u00a0 \\n\\u00a0     std::complex<double> d_bar(const Point<dim> point);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     rank2_type rotation(std::complex<double> d_1,\\n\\u00a0                         std::complex<double> d_2,\\n\\u00a0                         Point<dim>           point);\\n\\u00a0 \\n\\u00a0     rank2_type a_matrix(const Point<dim> point);\\n\\u00a0 \\n\\u00a0     rank2_type b_matrix(const Point<dim> point);\\n\\u00a0 \\n\\u00a0     rank2_type c_matrix(const Point<dim> point);\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     double inner_radius;\\n\\u00a0     double outer_radius;\\n\\u00a0     double strength;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   PerfectlyMatchedLayer<dim>::PerfectlyMatchedLayer()\\n\\u00a0     : ParameterAcceptor(\\\"PerfectlyMatchedLayer\\\")\\n\\u00a0   {\\n\\u00a0     inner_radius = 12.;\\n\\u00a0     add_parameter(\\\"inner radius\\\",\\n\\u00a0                   inner_radius,\\n\\u00a0                   \\\"inner radius of the PML shell\\\");\\n\\u00a0     outer_radius = 20.;\\n\\u00a0     add_parameter(\\\"outer radius\\\",\\n\\u00a0                   outer_radius,\\n\\u00a0                   \\\"outer radius of the PML shell\\\");\\n\\u00a0     strength = 8.;\\n\\u00a0     add_parameter(\\\"strength\\\", strength, \\\"strength of the PML\\\");\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   typename std::complex<double>\\n\\u00a0   PerfectlyMatchedLayer<dim>::d(const Point<dim> point)\\n\\u00a0   {\\n\\u00a0     const auto radius = point.norm();\\n\\u00a0     if (radius > inner_radius)\\n\\u00a0       {\\n\\u00a0         const double s =\\n\\u00a0           strength * ((radius - inner_radius) * (radius - inner_radius)) /\\n\\u00a0           ((outer_radius - inner_radius) * (outer_radius - inner_radius));\\n\\u00a0         return {1.0, s};\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       {\\n\\u00a0         return 1.0;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   typename std::complex<double>\\n\\u00a0   PerfectlyMatchedLayer<dim>::d_bar(const Point<dim> point)\\n\\u00a0   {\\n\\u00a0     const auto radius = point.norm();\\n\\u00a0     if (radius > inner_radius)\\n\\u00a0       {\\n\\u00a0         const double s_bar =\\n\\u00a0           strength / 3. *\\n\\u00a0           ((radius - inner_radius) * (radius - inner_radius) *\\n\\u00a0            (radius - inner_radius)) /\\n\\u00a0           (radius * (outer_radius - inner_radius) *\\n\\u00a0            (outer_radius - inner_radius));\\n\\u00a0         return {1.0, s_bar};\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       {\\n\\u00a0         return 1.0;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   typename PerfectlyMatchedLayer<dim>::rank2_type\\n\\u00a0   PerfectlyMatchedLayer<dim>::rotation(std::complex<double> d_1,\\n\\u00a0                                        std::complex<double> d_2,\\n\\u00a0                                        Point<dim>           point)\\n\\u00a0   {\\n\\u00a0     rank2_type result;\\n\\u00a0     result[0][0] = point[0] * point[0] * d_1 + point[1] * point[1] * d_2;\\n\\u00a0     result[0][1] = point[0] * point[1] * (d_1 - d_2);\\n\\u00a0     result[1][0] = point[0] * point[1] * (d_1 - d_2);\\n\\u00a0     result[1][1] = point[1] * point[1] * d_1 + point[0] * point[0] * d_2;\\n\\u00a0     return result;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   typename PerfectlyMatchedLayer<dim>::rank2_type\\n\\u00a0   PerfectlyMatchedLayer<dim>::a_matrix(const Point<dim> point)\\n\\u00a0   {\\n\\u00a0     const auto d     = this->d(point);\\n\\u00a0     const auto d_bar = this->d_bar(point);\\n\\u00a0     return invert(rotation(d * d, d * d_bar, point)) *\\n\\u00a0            rotation(d * d, d * d_bar, point);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   typename PerfectlyMatchedLayer<dim>::rank2_type\\n\\u00a0   PerfectlyMatchedLayer<dim>::b_matrix(const Point<dim> point)\\n\\u00a0   {\\n\\u00a0     const auto d     = this->d(point);\\n\\u00a0     const auto d_bar = this->d_bar(point);\\n\\u00a0     return invert(rotation(d, d_bar, point)) * rotation(d, d_bar, point);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   typename PerfectlyMatchedLayer<dim>::rank2_type\\n\\u00a0   PerfectlyMatchedLayer<dim>::c_matrix(const Point<dim> point)\\n\\u00a0   {\\n\\u00a0     const auto d     = this->d(point);\\n\\u00a0     const auto d_bar = this->d_bar(point);\\n\\u00a0     return invert(rotation(1. / d_bar, 1. / d, point)) *\\n\\u00a0            rotation(1. / d_bar, 1. / d, point);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nTensor::normnumbers::NumberTraits< Number >::real_type norm() const\\nPhysics::Elasticity::Kinematics::dSymmetricTensor< 2, dim, Number > d(const Tensor< 2, dim, Number > &F, const Tensor< 2, dim, Number > &dF_dt)\\ninvertDEAL_II_HOST constexpr SymmetricTensor< 2, dim, Number > invert(const SymmetricTensor< 2, dim, Number > &)Definition symmetric_tensor.h:3250\\n Maxwell Class\\nAt this point we are ready to declare all the major building blocks of the finite element program which consists of the usual setup and assembly routines. Most of the structure has already been introduced in previous tutorial programs. The Maxwell class also holds private instances of the Parameters and PerfectlyMatchedLayers classes introduced above. The default values of these parameters are set to show us a standing wave with absorbing boundary conditions and a PML.\\n\\u00a0   template <int dim>\\n\\u00a0   class Maxwell : public ParameterAcceptor\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     Maxwell();\\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     /* run time parameters */\\n\\u00a0     double       scaling;\\n\\u00a0     unsigned int refinements;\\n\\u00a0     unsigned int fe_order;\\n\\u00a0     unsigned int quadrature_order;\\n\\u00a0     bool         absorbing_boundary;\\n\\u00a0 \\n\\u00a0     void parse_parameters_callback();\\n\\u00a0     void make_grid();\\n\\u00a0     void setup_system();\\n\\u00a0     void assemble_system();\\n\\u00a0     void solve();\\n\\u00a0     void output_results();\\n\\u00a0 \\n\\u00a0     Parameters<dim>            parameters;\\n\\u00a0     PerfectlyMatchedLayer<dim> perfectly_matched_layer;\\n\\u00a0 \\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0     DoFHandler<dim>    dof_handler;\\n\\u00a0 \\n\\u00a0     std::unique_ptr<FiniteElement<dim>> fe;\\n\\u00a0 \\n\\u00a0     AffineConstraints<double> constraints;\\n\\u00a0     SparsityPattern           sparsity_pattern;\\n\\u00a0     SparseMatrix<double>      system_matrix;\\n\\u00a0     Vector<double>            solution;\\n\\u00a0     Vector<double>            system_rhs;\\n\\u00a0   };\\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nDoFHandlerDefinition dof_handler.h:317\\nSparseMatrixDefinition sparse_matrix.h:520\\nSparsityPatternDefinition sparsity_pattern.h:343\\nTriangulationDefinition tria.h:1323\\nVectorDefinition vector.h:120\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\n Class Template Definitions and Implementation\\n The Constructor\\nThe Constructor simply consists of default initialization a number of discretization parameters (such as the domain size, mesh refinement, and the order of finite elements and quadrature) and declaring a corresponding entry via ParameterAcceptor::add_parameter(). All of these can be modified by editing the .prm file. Absorbing boundary conditions can be controlled with the absorbing_boundary boolean. If absorbing boundary conditions are disabled we simply enforce homogeneous Dirichlet conditions on the tangential component of the electric field. In the context of time-harmonic Maxwell's equations these are also known as perfectly conducting boundary conditions.\\n\\u00a0   template <int dim>\\n\\u00a0   Maxwell<dim>::Maxwell()\\n\\u00a0     : ParameterAcceptor(\\\"Maxwell\\\")\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0   {\\n\\u00a0     ParameterAcceptor::parse_parameters_call_back.connect(\\n\\u00a0       [&]() { parse_parameters_callback(); });\\n\\u00a0 \\n\\u00a0     scaling = 20;\\n\\u00a0     add_parameter(\\\"scaling\\\", scaling, \\\"scale of the hypercube geometry\\\");\\n\\u00a0 \\n\\u00a0     refinements = 8;\\n\\u00a0     add_parameter(\\\"refinements\\\",\\n\\u00a0                   refinements,\\n\\u00a0                   \\\"number of refinements of the geometry\\\");\\n\\u00a0 \\n\\u00a0     fe_order = 0;\\n\\u00a0     add_parameter(\\\"fe order\\\", fe_order, \\\"order of the finite element space\\\");\\n\\u00a0 \\n\\u00a0     quadrature_order = 1;\\n\\u00a0     add_parameter(\\\"quadrature order\\\",\\n\\u00a0                   quadrature_order,\\n\\u00a0                   \\\"order of the quadrature\\\");\\n\\u00a0 \\n\\u00a0     absorbing_boundary = true;\\n\\u00a0     add_parameter(\\\"absorbing boundary condition\\\",\\n\\u00a0                   absorbing_boundary,\\n\\u00a0                   \\\"use absorbing boundary conditions?\\\");\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void Maxwell<dim>::parse_parameters_callback()\\n\\u00a0   {\\n\\u00a0     fe = std::make_unique<FESystem<dim>>(FE_NedelecSZ<dim>(fe_order), 2);\\n\\u00a0   }\\n\\u00a0 \\nFE_NedelecSZDefinition fe_nedelec_sz.h:85\\nParameterAcceptor::parse_parameters_call_backboost::signals2::signal< void()> parse_parameters_call_backDefinition parameter_acceptor.h:478\\nThe Maxwell::make_grid() routine creates the mesh for the computational domain which in our case is a scaled square domain. Additionally, a material interface is introduced by setting the material id of the upper half ( \\\\(y>0\\\\)) to 1 and of the lower half ( \\\\(y<0\\\\)) of the computational domain to 2. We are using a block decomposition into real and imaginary matrices for the solution matrices. More details on this are available under the Results section.\\n\\u00a0   template <int dim>\\n\\u00a0   void Maxwell<dim>::make_grid()\\n\\u00a0   {\\n\\u00a0     GridGenerator::hyper_cube(triangulation, -scaling, scaling);\\n\\u00a0     triangulation.refine_global(refinements);\\n\\u00a0 \\n\\u00a0     if (!absorbing_boundary)\\n\\u00a0       {\\n\\u00a0         for (auto &face : triangulation.active_face_iterators())\\n\\u00a0           if (face->at_boundary())\\n\\u00a0             face->set_boundary_id(1);\\n\\u00a0       };\\n\\u00a0 \\n\\u00a0     for (auto &cell : triangulation.active_cell_iterators())\\n\\u00a0       if (cell->center()[1] > 0.)\\n\\u00a0         cell->set_material_id(1);\\n\\u00a0       else\\n\\u00a0         cell->set_material_id(2);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     std::cout << \\\"Number of active cells: \\\" << triangulation.n_active_cells()\\n\\u00a0               << std::endl;\\n\\u00a0   }\\n\\u00a0 \\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\ncenterPoint< 3 > centerDefinition data_out_base.cc:267\\nGridGenerator::hyper_cubevoid hyper_cube(Triangulation< dim, spacedim > &tria, const double left=0., const double right=1., const bool colorize=false)\\nThe Maxwell::setup_system() routine follows the usual routine of enumerating all the degrees of freedom and setting up the matrix and vector objects to hold the system data. Enumerating is done by using DoFHandler::distribute_dofs().\\n\\u00a0   template <int dim>\\n\\u00a0   void Maxwell<dim>::setup_system()\\n\\u00a0   {\\n\\u00a0     dof_handler.distribute_dofs(*fe);\\n\\u00a0     std::cout << \\\"Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n\\u00a0               << std::endl;\\n\\u00a0 \\n\\u00a0     solution.reinit(dof_handler.n_dofs());\\n\\u00a0     system_rhs.reinit(dof_handler.n_dofs());\\n\\u00a0 \\n\\u00a0     constraints.clear();\\n\\u00a0 \\n\\u00a0     DoFTools::make_hanging_node_constraints(dof_handler, constraints);\\n\\u00a0 \\n\\u00a0     VectorTools::project_boundary_values_curl_conforming_l2(\\n\\u00a0       dof_handler,\\n\\u00a0       0, /* real part */\\n\\u00a0       Functions::ZeroFunction<dim>(2 * dim),\\n\\u00a0       0, /* boundary id */\\n\\u00a0       constraints);\\n\\u00a0     VectorTools::project_boundary_values_curl_conforming_l2(\\n\\u00a0       dof_handler,\\n\\u00a0       dim, /* imaginary part */\\n\\u00a0       Functions::ZeroFunction<dim>(2 * dim),\\n\\u00a0       0, /* boundary id */\\n\\u00a0       constraints);\\n\\u00a0 \\n\\u00a0     constraints.close();\\n\\u00a0 \\n\\u00a0     DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());\\n\\u00a0     DoFTools::make_sparsity_pattern(dof_handler,\\n\\u00a0                                     dsp,\\n\\u00a0                                     constraints,\\n\\u00a0                                     /* keep_constrained_dofs = */ true);\\n\\u00a0     sparsity_pattern.copy_from(dsp);\\n\\u00a0     system_matrix.reinit(sparsity_pattern);\\n\\u00a0   }\\n\\u00a0 \\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nFunctions::ZeroFunctionDefinition function.h:510\\nVectorTools::project_boundary_values_curl_conforming_l2void project_boundary_values_curl_conforming_l2(const DoFHandler< dim, dim > &dof_handler, const unsigned int first_vector_component, const Function< dim, number > &boundary_function, const types::boundary_id boundary_component, AffineConstraints< number > &constraints, const Mapping< dim > &mapping)\\nDoFTools::make_hanging_node_constraintsvoid make_hanging_node_constraints(const DoFHandler< dim, spacedim > &dof_handler, AffineConstraints< number > &constraints)Definition dof_tools_constraints.cc:3073\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nThis is a helper function that takes the tangential component of a tensor.\\n\\u00a0   template <int dim>\\n\\u00a0   DEAL_II_ALWAYS_INLINE inline Tensor<1, dim, std::complex<double>>\\n\\u00a0   tangential_part(const Tensor<1, dim, std::complex<double>> &tensor,\\n\\u00a0                   const Tensor<1, dim>                       &normal)\\n\\u00a0   {\\n\\u00a0     auto result = tensor;\\n\\u00a0     result[0]   = normal[1] * (tensor[0] * normal[1] - tensor[1] * normal[0]);\\n\\u00a0     result[1]   = -normal[0] * (tensor[0] * normal[1] - tensor[1] * normal[0]);\\n\\u00a0     return result;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nDEAL_II_ALWAYS_INLINE#define DEAL_II_ALWAYS_INLINEDefinition config.h:109\\nAssemble the stiffness matrix and the right-hand side:        \\n\\\\begin{align*}\\n   A_{ij} = \\\\int_\\\\Omega (\\\\mu_r^{-1}\\\\nabla \\\\times \\\\varphi_j) \\\\cdot\\n   (\\\\nabla\\\\times\\\\bar{\\\\varphi}_i)\\\\text{d}x\\n   - \\\\int_\\\\Omega \\\\varepsilon_r\\\\varphi_j \\\\cdot \\\\bar{\\\\varphi}_i\\\\text{d}x\\n   - i\\\\int_\\\\Sigma (\\\\sigma_r^{\\\\Sigma}(\\\\varphi_j)_T) \\\\cdot\\n   (\\\\bar{\\\\varphi}_i)_T\\\\text{do}x\\n   - i\\\\int_{\\\\partial\\\\Omega} (\\\\sqrt{\\\\mu_r^{-1}\\\\varepsilon}(\\\\varphi_j)_T) \\\\cdot\\n   (\\\\nabla\\\\times(\\\\bar{\\\\varphi}_i)_T)\\\\text{d}x, \\\\end{align*}\\n\\n\\n\\\\begin{align}\\n   F_i = i\\\\int_\\\\Omega J_a \\\\cdot \\\\bar{\\\\varphi_i}\\\\text{d}x - \\\\int_\\\\Omega\\n   \\\\mu_r^{-1} \\\\cdot (\\\\nabla \\\\times \\\\bar{\\\\varphi_i}) \\\\text{d}x.\\n   \\\\end{align}\\n\\n In addition, we will be modifying the coefficients if the position of the cell is within the PML region.\\n\\u00a0   template <int dim>\\n\\u00a0   void Maxwell<dim>::assemble_system()\\n\\u00a0   {\\n\\u00a0     const QGauss<dim>     quadrature_formula(quadrature_order);\\n\\u00a0     const QGauss<dim - 1> face_quadrature_formula(quadrature_order);\\n\\u00a0 \\n\\u00a0     FEValues<dim, dim>     fe_values(*fe,\\n\\u00a0                                  quadrature_formula,\\n\\u00a0                                  update_values | update_gradients |\\n\\u00a0                                    update_quadrature_points |\\n\\u00a0                                    update_JxW_values);\\n\\u00a0     FEFaceValues<dim, dim> fe_face_values(*fe,\\n\\u00a0                                           face_quadrature_formula,\\n\\u00a0                                           update_values | update_gradients |\\n\\u00a0                                             update_quadrature_points |\\n\\u00a0                                             update_normal_vectors |\\n\\u00a0                                             update_JxW_values);\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell = fe->dofs_per_cell;\\n\\u00a0 \\n\\u00a0     const unsigned int n_q_points      = quadrature_formula.size();\\n\\u00a0     const unsigned int n_face_q_points = face_quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0     Vector<double>     cell_rhs(dofs_per_cell);\\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\nFEFaceValuesDefinition fe_values.h:322\\nFEValuesDefinition fe_values.h:63\\nFullMatrixDefinition full_matrix.h:79\\nQGaussDefinition quadrature_lib.h:40\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_normal_vectors@ update_normal_vectorsNormal vectors.Definition fe_update_flags.h:141\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nNext, let us assemble on the interior of the domain on the left hand side. So we are computing      \\n\\\\begin{align*}\\n   \\\\int_\\\\Omega (\\\\mu_r^{-1}\\\\nabla \\\\times \\\\varphi_i) \\\\cdot\\n   (\\\\nabla\\\\times\\\\bar{\\\\varphi}_j)\\\\text{d}x\\n   -\\n   \\\\int_\\\\Omega \\\\varepsilon_r\\\\varphi_i \\\\cdot \\\\bar{\\\\varphi}_j\\\\text{d}x\\n   \\\\end{align*}\\n\\n and     \\n\\\\begin{align}\\n   i\\\\int_\\\\Omega J_a \\\\cdot \\\\bar{\\\\varphi_i}\\\\text{d}x\\n   - \\\\int_\\\\Omega \\\\mu_r^{-1} \\\\cdot (\\\\nabla \\\\times \\\\bar{\\\\varphi_i})\\n   \\\\text{d}x.\\n   \\\\end{align}\\n\\n In doing so, we need test functions \\\\(\\\\varphi_i\\\\) and \\\\(\\\\varphi_j\\\\), and the curl of these test variables. We must be careful with the signs of the imaginary parts of these complex test variables. Moreover, we have a conditional that changes the parameters if the cell is in the PML region.\\n\\u00a0     const FEValuesExtractors::Vector real_part(0);\\n\\u00a0     const FEValuesExtractors::Vector imag_part(dim);\\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0         cell_matrix = 0.;\\n\\u00a0         cell_rhs    = 0.;\\n\\u00a0 \\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0         const auto id = cell->material_id();\\n\\u00a0 \\n\\u00a0         const auto &quadrature_points = fe_values.get_quadrature_points();\\n\\u00a0 \\n\\u00a0         for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n\\u00a0           {\\n\\u00a0             const Point<dim> &position = quadrature_points[q_point];\\n\\u00a0 \\n\\u00a0             auto       mu_inv  = parameters.mu_inv(position, id);\\n\\u00a0             auto       epsilon = parameters.epsilon(position, id);\\n\\u00a0             const auto J_a     = parameters.J_a(position, id);\\n\\u00a0 \\n\\u00a0             const auto A = perfectly_matched_layer.a_matrix(position);\\n\\u00a0             const auto B = perfectly_matched_layer.b_matrix(position);\\n\\u00a0             const auto d = perfectly_matched_layer.d(position);\\n\\u00a0 \\n\\u00a0             mu_inv  = mu_inv / d;\\n\\u00a0             epsilon = invert(A) * epsilon * invert(B);\\n\\u00a0 \\n\\u00a0             for (const auto i : fe_values.dof_indices())\\n\\u00a0               {\\n\\u00a0                 constexpr std::complex<double> imag{0., 1.};\\n\\u00a0 \\n\\u00a0                 const auto phi_i =\\n\\u00a0                   fe_values[real_part].value(i, q_point) -\\n\\u00a0                   imag * fe_values[imag_part].value(i, q_point);\\n\\u00a0                 const auto curl_phi_i =\\n\\u00a0                   fe_values[real_part].curl(i, q_point) -\\n\\u00a0                   imag * fe_values[imag_part].curl(i, q_point);\\n\\u00a0 \\n\\u00a0                 const auto rhs_value =\\n\\u00a0                   (imag * scalar_product(J_a, phi_i)) * fe_values.JxW(q_point);\\n\\u00a0                 cell_rhs(i) += rhs_value.real();\\n\\u00a0 \\n\\u00a0                 for (const auto j : fe_values.dof_indices())\\n\\u00a0                   {\\n\\u00a0                     const auto phi_j =\\n\\u00a0                       fe_values[real_part].value(j, q_point) +\\n\\u00a0                       imag * fe_values[imag_part].value(j, q_point);\\n\\u00a0                     const auto curl_phi_j =\\n\\u00a0                       fe_values[real_part].curl(j, q_point) +\\n\\u00a0                       imag * fe_values[imag_part].curl(j, q_point);\\n\\u00a0 \\n\\u00a0                     const auto temp =\\n\\u00a0                       (scalar_product(mu_inv * curl_phi_j, curl_phi_i) -\\n\\u00a0                        scalar_product(epsilon * phi_j, phi_i)) *\\n\\u00a0                       fe_values.JxW(q_point);\\n\\u00a0                     cell_matrix(i, j) += temp.real();\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0 \\nstdSTL namespace.\\nFEValuesExtractors::VectorDefinition fe_values_extractors.h:150\\nNow we assemble the face and the boundary. The following loops will assemble   \\n\\\\begin{align*}\\n   - i\\\\int_\\\\Sigma (\\\\sigma_r^{\\\\Sigma}(\\\\varphi_i)_T) \\\\cdot\\n   (\\\\bar{\\\\varphi}_j)_T\\\\text{do}x \\\\end{align*}\\n\\n and    \\n\\\\begin{align}\\n   - i\\\\int_{\\\\partial\\\\Omega} (\\\\sqrt{\\\\mu_r^{-1}\\\\varepsilon}(\\\\varphi_i)_T)\\n   \\\\cdot (\\\\nabla\\\\times(\\\\bar{\\\\varphi}_j)_T)\\\\text{d}x,\\n   \\\\end{align}\\n\\n respectively. The test variables and the PML are implemented similarly as the domain.\\n\\u00a0         const FEValuesExtractors::Vector real_part(0);\\n\\u00a0         const FEValuesExtractors::Vector imag_part(dim);\\n\\u00a0         for (const auto &face : cell->face_iterators())\\n\\u00a0           {\\n\\u00a0             if (face->at_boundary())\\n\\u00a0               {\\n\\u00a0                 const auto id = face->boundary_id();\\n\\u00a0                 if (id != 0)\\n\\u00a0                   {\\n\\u00a0                     fe_face_values.reinit(cell, face);\\n\\u00a0 \\n\\u00a0                     for (unsigned int q_point = 0; q_point < n_face_q_points;\\n\\u00a0                          ++q_point)\\n\\u00a0                       {\\n\\u00a0                         const auto &position = quadrature_points[q_point];\\n\\u00a0 \\n\\u00a0                         auto mu_inv  = parameters.mu_inv(position, id);\\n\\u00a0                         auto epsilon = parameters.epsilon(position, id);\\n\\u00a0 \\n\\u00a0                         const auto A =\\n\\u00a0                           perfectly_matched_layer.a_matrix(position);\\n\\u00a0                         const auto B =\\n\\u00a0                           perfectly_matched_layer.b_matrix(position);\\n\\u00a0                         const auto d = perfectly_matched_layer.d(position);\\n\\u00a0 \\n\\u00a0                         mu_inv  = mu_inv / d;\\n\\u00a0                         epsilon = invert(A) * epsilon * invert(B);\\n\\u00a0 \\n\\u00a0                         const auto normal =\\n\\u00a0                           fe_face_values.normal_vector(q_point);\\n\\u00a0 \\n\\u00a0                         for (const auto i : fe_face_values.dof_indices())\\n\\u00a0                           {\\n\\u00a0                             constexpr std::complex<double> imag{0., 1.};\\n\\u00a0 \\n\\u00a0                             const auto phi_i =\\n\\u00a0                               fe_face_values[real_part].value(i, q_point) -\\n\\u00a0                               imag *\\n\\u00a0                                 fe_face_values[imag_part].value(i, q_point);\\n\\u00a0                             const auto phi_i_T = tangential_part(phi_i, normal);\\n\\u00a0 \\n\\u00a0                             for (const auto j : fe_face_values.dof_indices())\\n\\u00a0                               {\\n\\u00a0                                 const auto phi_j =\\n\\u00a0                                   fe_face_values[real_part].value(j, q_point) +\\n\\u00a0                                   imag *\\n\\u00a0                                     fe_face_values[imag_part].value(j, q_point);\\n\\u00a0                                 const auto phi_j_T =\\n\\u00a0                                   tangential_part(phi_j, normal) *\\n\\u00a0                                   fe_face_values.JxW(q_point);\\n\\u00a0 \\n\\u00a0                                 const auto prod      = mu_inv * epsilon;\\n\\u00a0                                 const auto sqrt_prod = prod;\\n\\u00a0 \\n\\u00a0                                 const auto temp =\\n\\u00a0                                   -imag * scalar_product((sqrt_prod * phi_j_T),\\n\\u00a0                                                          phi_i_T);\\n\\u00a0                                 cell_matrix(i, j) += temp.real();\\n\\u00a0                               } /* j */\\n\\u00a0                           }     /* i */\\n\\u00a0                       }         /* q_point */\\n\\u00a0                   }\\n\\u00a0               }\\n\\u00a0             else\\n\\u00a0               {\\nWe are on an interior face:\\n\\u00a0                 const auto face_index = cell->face_iterator_to_index(face);\\n\\u00a0 \\n\\u00a0                 const auto id1 = cell->material_id();\\n\\u00a0                 const auto id2 = cell->neighbor(face_index)->material_id();\\n\\u00a0 \\n\\u00a0                 if (id1 == id2)\\n\\u00a0                   continue; /* skip this face */\\n\\u00a0 \\n\\u00a0                 fe_face_values.reinit(cell, face);\\n\\u00a0 \\n\\u00a0                 for (unsigned int q_point = 0; q_point < n_face_q_points;\\n\\u00a0                      ++q_point)\\n\\u00a0                   {\\n\\u00a0                     const auto &position = quadrature_points[q_point];\\n\\u00a0 \\n\\u00a0                     auto sigma = parameters.sigma(position, id1, id2);\\n\\u00a0 \\n\\u00a0                     const auto B = perfectly_matched_layer.b_matrix(position);\\n\\u00a0                     const auto C = perfectly_matched_layer.c_matrix(position);\\n\\u00a0                     sigma        = invert(C) * sigma * invert(B);\\n\\u00a0 \\n\\u00a0                     const auto normal = fe_face_values.normal_vector(q_point);\\n\\u00a0 \\n\\u00a0                     for (const auto i : fe_face_values.dof_indices())\\n\\u00a0                       {\\n\\u00a0                         constexpr std::complex<double> imag{0., 1.};\\n\\u00a0 \\n\\u00a0                         const auto phi_i =\\n\\u00a0                           fe_face_values[real_part].value(i, q_point) -\\n\\u00a0                           imag * fe_face_values[imag_part].value(i, q_point);\\n\\u00a0                         const auto phi_i_T = tangential_part(phi_i, normal);\\n\\u00a0 \\n\\u00a0                         for (const auto j : fe_face_values.dof_indices())\\n\\u00a0                           {\\n\\u00a0                             const auto phi_j =\\n\\u00a0                               fe_face_values[real_part].value(j, q_point) +\\n\\u00a0                               imag *\\n\\u00a0                                 fe_face_values[imag_part].value(j, q_point);\\n\\u00a0                             const auto phi_j_T = tangential_part(phi_j, normal);\\n\\u00a0 \\n\\u00a0                             const auto temp =\\n\\u00a0                               -imag *\\n\\u00a0                               scalar_product((sigma * phi_j_T), phi_i_T) *\\n\\u00a0                               fe_face_values.JxW(q_point);\\n\\u00a0                             cell_matrix(i, j) += temp.real();\\n\\u00a0                           } /* j */\\n\\u00a0                       }     /* i */\\n\\u00a0                   }         /* q_point */\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         constraints.distribute_local_to_global(\\n\\u00a0           cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\nWe use a direct solver from the SparseDirectUMFPACK to solve the system\\n\\u00a0   template <int dim>\\n\\u00a0   void Maxwell<dim>::solve()\\n\\u00a0   {\\n\\u00a0     SparseDirectUMFPACK A_direct;\\n\\u00a0     A_direct.initialize(system_matrix);\\n\\u00a0     A_direct.vmult(solution, system_rhs);\\n\\u00a0   }\\n\\u00a0 \\nSparseDirectUMFPACKDefinition sparse_direct.h:92\\nSparseDirectUMFPACK::initializevoid initialize(const SparsityPattern &sparsity_pattern)Definition sparse_direct.cc:67\\nThe output is written into a vtk file with 4 components\\n\\u00a0   template <int dim>\\n\\u00a0   void Maxwell<dim>::output_results()\\n\\u00a0   {\\n\\u00a0     DataOut<2> data_out;\\n\\u00a0     data_out.attach_dof_handler(dof_handler);\\n\\u00a0     data_out.add_data_vector(solution,\\n\\u00a0                              {\\\"real_Ex\\\", \\\"real_Ey\\\", \\\"imag_Ex\\\", \\\"imag_Ey\\\"});\\n\\u00a0     data_out.build_patches();\\n\\u00a0     std::ofstream output(\\\"solution.vtk\\\");\\n\\u00a0     data_out.write_vtk(output);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   void Maxwell<dim>::run()\\n\\u00a0   {\\n\\u00a0     make_grid();\\n\\u00a0     setup_system();\\n\\u00a0     assemble_system();\\n\\u00a0     solve();\\n\\u00a0     output_results();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 } // namespace Step81\\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nThe following main function calls the class step-81(), initializes the ParameterAcceptor, and calls the run() function.\\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       using namespace dealii;\\n\\u00a0 \\n\\u00a0       Step81::Maxwell<2> maxwell_2d;\\n\\u00a0       ParameterAcceptor::initialize(\\\"parameters.prm\\\");\\n\\u00a0       maxwell_2d.run();\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   return 0;\\n\\u00a0 }\\nParameterAcceptor::initializestatic void initialize(const std::string &filename=\\\"\\\", const std::string &output_filename=\\\"\\\", const ParameterHandler::OutputStyle output_style_for_output_filename=ParameterHandler::Short, ParameterHandler &prm=ParameterAcceptor::prm, const ParameterHandler::OutputStyle output_style_for_filename=ParameterHandler::DefaultStyle)Definition parameter_acceptor.cc:80\\n Results\\nThe solution is written to a .vtk file with four components. These are the real and imaginary parts of the \\\\(E_x\\\\) and \\\\(E_y\\\\) solution waves. With the current setup, the output should read\\nNumber of active cells: 4096\\nNumber of degrees of freedom: 16640\\nProgram ended with exit code: 0\\nAbsorbing boundary conditions and the PML \\nThe following images are the outputs for the imaginary \\\\(E_x\\\\) without the interface and with the dipole centered at \\\\((0,0)\\\\). In order to remove the interface, the surface conductivity is set to 0. First, we turn off the absorbing boundary conditions and the PML. Second, we want to see the effect of the PML when absorbing boundary conditions apply. So we set absorbing boundary conditions to true and leave the PML strength to 0. Lastly, we increase the strength of the PML to 4. Change the following in the .prm file :\\n# use absorbing boundary conditions?\\n  set absorbing boundary condition = false\\n \\n# position of the dipole\\n  set dipole position    = 0, 0\\n \\n# strength of the PML\\n  set strength     = 0\\n \\n# surface conductivity between material 1 and material 2\\n  set sigma              = 0, 0; 0, 0| 0, 0; 0, 0\\nFollowing are the output images:\\n\\n\\n \\nSolution with no interface, Dirichlet boundary conditions and PML strength 0.\\n\\n \\nSolution with no interface, absorbing boundary conditions and PML strength 0.\\n\\n \\nSolution with no interface, absorbing boundary conditions and PML strength 4.\\n\\n\\n\\nWe observe that with absorbing boundary conditions and in absence of the PML, there is a lot of distortion and resonance (the real parts will not be generated without a PML). This is, as we stipulated, due to reflection from infinity. As we see, a much more coherent image is generated with an appropriate PML.\\nSurface Plasmon Polariton \\nNow, let's generate a standing wave by adding an interface at the center. In order to observe this effect, we offset the center of the dipole to  \\\\((0,\\n0.8)\\\\) and set the surface conductivity back to \\\\((0.001, 0.2)\\\\):\\n# position of the dipole\\n  set dipole position    = 0, 0.8\\n \\n# surface conductivity between material 1 and material 2\\n  set sigma              = 0.001, 0.2; 0, 0| 0, 0; 0.001, 0.2\\nOnce again, we will visualize the output with absorbing boundary conditions and PML strength 0 and with absorbing boundary conditions and PML strength\\nThe following tables are the imaginary part of \\\\(E_x\\\\) and the real part of \\\\(E_x\\\\).\\n\\n\\n\\n \\nSolution with an interface, Dirichlet boundary conditions and PML strength 0.\\n\\n \\nSolution with an interface, absorbing boundary conditions and PML strength 0.\\n\\n \\nSolution with an interface, absorbing boundary conditions and PML strength 4.\\n\\n\\n\\n\\n\\n \\nSolution with an interface, Dirichlet boundary conditions and PML strength 0.\\n\\n \\nSolution with an interface, absorbing boundary conditions and PML strength 0.\\n\\n \\nSolution with an interface, absorbing boundary conditions and PML strength 4.\\n\\n\\n\\nThe SPP is confined near the interface that we created, however without absorbing boundary conditions, we don't observe a dissipation effect. On adding the absorbing boundary conditions, we observe distortion and resonance and we still don't notice any dissipation. As expected, the PML removes the distortion and resonance. The standing wave is also dissipating and getting absorbed within the PML, and as we increase the PML strength, the standing wave will dissipate more within the PML ring.\\nHere are some animations to demonstrate the effect of the PML \\n\\n \\nSolution with an interface, Dirichlet boundary conditions and PML strength 0.\\n\\n \\nSolution with an interface, absorbing boundary conditions and PML strength 0.\\n\\n \\nSolution with an interface, absorbing boundary conditions and PML strength 4.\\n\\n\\n\\n\\n\\n \\nSolution with an interface, Dirichlet boundary conditions and PML strength 0.\\n\\n \\nSolution with an interface, absorbing boundary conditions and PML strength 0.\\n\\n \\nSolution with an interface, absorbing boundary conditions and PML strength 4.\\n\\n\\n\\nNotes \\nReal and Complex Matrices \\nAs is evident from the results, we are splitting our solution matrices into the real and the imaginary components. We started off using the \\\\(H^{curl}\\\\) conforming N\\u00e9d\\u00e9lec Elements, and we made two copies of the Finite Elements in order to represent the real and the imaginary components of our input (FE_NedelecSZ was used instead of FE_Nedelec to avoid the sign conflicts issues present in traditional N\\u00e9d\\u00e9lec elements). In the assembly, we create two vectors of dimension \\\\(dim\\\\) that assist us in extracting the real and the imaginary components of our finite elements.\\nRotations and Scaling \\nAs we see in our assembly, our finite element is rotated and scaled as follows:\\nconst auto phi_i = real_part.value(i, q_point) - 1.0i * imag_part.value(i, q_point);\\nThis \\\\(\\\\phi_i\\\\) variable doesn't need to be scaled in this way, we may choose any arbitrary scaling constants \\\\(a\\\\) and \\\\(b\\\\). If we choose this scaling, the \\\\(\\\\phi_j\\\\) must also be modified with the same scaling, as follows:\\nconst auto phi_i = a*real_part.value(i, q_point) -\\n                                   bi * imag_part.value(i, q_point);\\n \\nconst auto phi_j = a*real_part.value(i, q_point) +\\n                                   bi * imag_part.value(i, q_point);\\nMoreover, the cell_rhs need not be the real part of the rhs_value. Say if we modify to take the imaginary part of the computed rhs_value, we must also modify the cell_matrix accordingly to take the imaginary part of temp. However, making these changes to both sides of the equation will not affect our solution, and we will still be able to generate the surface plasmon polariton.\\ncell_rhs(i) += rhs_value.imag();\\n \\ncell_matrix(i) += temp.imag();\\nPostprocessing \\nWe will create a video demonstrating the wave in motion, which is essentially an implementation of \\\\(e^{-i\\\\omega t}(Re(E) + i*Im(E))\\\\) as we increment time. This is done by slightly changing the output function to generate a series of .vtk files, which will represent out solution wave as we increment time. Introduce an input variable \\\\(t\\\\) in the output_results() class as output_results(unsigned int t). Then change the class itself to the following:\\ntemplate <int dim>\\nvoid Maxwell<dim>::output_results(unsigned int t)\\n{\\n  std::cout << \\\"Running step:\\\" << t << std::endl;\\n DataOut<2> data_out;\\n  data_out.attach_dof_handler(dof_handler);\\n Vector<double> postprocessed;\\n  postprocessed.reinit(solution);\\n for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)\\n    {\\n if (i % 4 == 0)\\n        {\\n          postprocessed[i] = std::cos(2 * M_PI * 0.04 * t) * solution[i] -\\n std::sin(2 * M_PI * 0.04 * t) * solution[i + 1];\\n        }\\n else if (i % 4 == 2)\\n        {\\n          postprocessed[i] = std::cos(2 * M_PI * 0.04 * t) * solution[i] -\\n std::sin(2 * M_PI * 0.04 * t) * solution[i + 1];\\n        }\\n    }\\n  data_out.add_data_vector(postprocessed, {\\\"E_x\\\", \\\"E_y\\\", \\\"null0\\\", \\\"null1\\\"});\\n  data_out.build_patches();\\n const std::string filename =\\n \\\"solution-\\\" + Utilities::int_to_string(t) + \\\".vtk\\\";\\n  std::ofstream output(filename);\\n  data_out.write_vtk(output);\\n  std::cout << \\\"Done running step:\\\" << t << std::endl;\\n}\\nDataOutInterface::write_vtkvoid write_vtk(std::ostream &out) constDefinition data_out_base.cc:7681\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nVector::reinitvirtual void reinit(const size_type N, const bool omit_zeroing_entries=false)\\nUtilities::int_to_stringstd::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)Definition utilities.cc:470\\nstd::sin::VectorizedArray< Number, width > sin(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6589\\nFinally, in the run() function, replace output_results() with for (int t = 0; t <= 100; t++)\\n  {\\n    output_results(t);\\n  }\\nThis would generate 100 solution .vtk files, which can be opened in a group on Paraview and then can be saved as an animation. We used FFMPEG to generate gifs.\\nPossibilities for Extension \\nThe example step could be extended in a number of different directions. \\n\\nThe current program uses a direct solver to solve the linear system. This is efficient for two spatial dimensions where scattering problems up to a few millions degrees of freedom can be solved. In 3D, however, the increased stencil size of the Nedelec element pose a severe limiting factor on the problem size that can be computed. As an alternative, the idea to use iterative solvers can be entertained. This, however requires specialized preconditioners. For example, just using an iterative Krylov space solver (such as SolverGMRES) on above problem will requires many thousands of iterations to converge. Unfortunately, time-harmonic Maxwell's equations lack the usual notion of local smoothing properties, which renders the usual suspects, such as a geometric multigrid (see the Multigrid class), largely useless. A possible extension would be to implement an additive Schwarz preconditioner (based on domain decomposition, see for example [101]), or a sweeping preconditioner (see for example [203]).  \\n\\nAnother possible extension of the current program is to introduce local mesh refinement (either based on a residual estimator, or based on the dual weighted residual method, see step-14). This is in particular of interest to counter the increased computational cost caused by the scale separation between the SPP and the dipole.  \\n\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2022 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Authors: Manaswinee Bezbaruah, Matthias Maier, Texas A&M University, 2021.\\n */\\n \\n \\n \\n#include <deal.II/base/function.h>\\n#include <deal.II/base/parameter_acceptor.h>\\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/tensor.h>\\n \\n#include <deal.II/dofs/dof_accessor.h>\\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_renumbering.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/fe/fe_nedelec_sz.h>\\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_system.h>\\n#include <deal.II/fe/fe_values.h>\\n \\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_refinement.h>\\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/tria_accessor.h>\\n#include <deal.II/grid/tria_iterator.h>\\n \\n#include <deal.II/lac/affine_constraints.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/precondition.h>\\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/sparse_direct.h>\\n#include <deal.II/lac/sparse_ilu.h>\\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/lac/vector.h>\\n \\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/error_estimator.h>\\n#include <deal.II/numerics/vector_tools.h>\\n \\n \\n#include <fstream>\\n#include <iostream>\\n#include <memory>\\n \\n \\n \\nnamespace Step81\\n{\\n using namespace dealii;\\n using namespace std::complex_literals;\\n \\n \\n \\n \\n \\n \\n template <int dim>\\n class Parameters : public ParameterAcceptor\\n  {\\n public:\\n    Parameters();\\n \\n using rank0_type = std::complex<double>;\\n \\n using rank1_type = Tensor<1, dim, std::complex<double>>;\\n \\n using rank2_type = Tensor<2, dim, rank0_type>;\\n \\n using curl_type = Tensor<1, dim == 2 ? 1 : dim, rank0_type>;\\n \\n public:\\n    rank2_type epsilon(const Point<dim> &x, types::material_id material);\\n \\n    std::complex<double> mu_inv(const Point<dim>  &x,\\n types::material_id material);\\n \\n    rank2_type sigma(const Point<dim>  &x,\\n types::material_id left,\\n types::material_id right);\\n \\n    rank1_type J_a(const Point<dim> &point, types::material_id id);\\n \\n private:\\n    rank2_type           epsilon_1;\\n    rank2_type           epsilon_2;\\n    std::complex<double> mu_inv_1;\\n    std::complex<double> mu_inv_2;\\n    rank2_type           sigma_tensor;\\n \\n double         dipole_radius;\\n Point<dim>     dipole_position;\\n Tensor<1, dim> dipole_orientation;\\n    rank0_type     dipole_strength;\\n  };\\n \\n \\n template <int dim>\\n  Parameters<dim>::Parameters()\\n    : ParameterAcceptor(\\\"Parameters\\\")\\n  {\\n    epsilon_1[0][0] = 1.;\\n    epsilon_1[1][1] = 1.;\\n    add_parameter(\\\"material 1 epsilon\\\",\\n                  epsilon_1,\\n \\\"relative permittivity of material 1\\\");\\n \\n    epsilon_2[0][0] = 1.;\\n    epsilon_2[1][1] = 1.;\\n    add_parameter(\\\"material 2 epsilon\\\",\\n                  epsilon_2,\\n \\\"relative permittivity of material 2\\\");\\n \\n    mu_inv_1 = 1.;\\n    add_parameter(\\\"material 1 mu_inv\\\",\\n                  mu_inv_1,\\n \\\"inverse of relative permeability of material 1\\\");\\n \\n    mu_inv_2 = 1.;\\n    add_parameter(\\\"material 2 mu_inv\\\",\\n                  mu_inv_2,\\n \\\"inverse of relative permeability of material 2\\\");\\n \\n    sigma_tensor[0][0] = std::complex<double>(0.001, 0.2);\\n    sigma_tensor[1][1] = std::complex<double>(0.001, 0.2);\\n    add_parameter(\\\"sigma\\\",\\n                  sigma_tensor,\\n \\\"surface conductivity between material 1 and material 2\\\");\\n \\n    dipole_radius = 0.3;\\n    add_parameter(\\\"dipole radius\\\", dipole_radius, \\\"radius of the dipole\\\");\\n \\n    dipole_position = Point<dim>(0., 0.8);\\n    add_parameter(\\\"dipole position\\\", dipole_position, \\\"position of the dipole\\\");\\n \\n    dipole_orientation = Tensor<1, dim>{{0., 1.}};\\n    add_parameter(\\\"dipole orientation\\\",\\n                  dipole_orientation,\\n \\\"orientation of the dipole\\\");\\n \\n    dipole_strength = 1.;\\n    add_parameter(\\\"dipole strength\\\", dipole_strength, \\\"strength of the dipole\\\");\\n  }\\n \\n template <int dim>\\n typename Parameters<dim>::rank2_type\\n  Parameters<dim>::epsilon(const Point<dim> & /*x*/,\\n types::material_id material)\\n  {\\n return (material == 1 ? epsilon_1 : epsilon_2);\\n  }\\n \\n template <int dim>\\n  std::complex<double> Parameters<dim>::mu_inv(const Point<dim> & /*x*/,\\n types::material_id material)\\n  {\\n return (material == 1 ? mu_inv_1 : mu_inv_2);\\n  }\\n \\n template <int dim>\\n typename Parameters<dim>::rank2_type\\n  Parameters<dim>::sigma(const Point<dim> & /*x*/,\\n types::material_id left,\\n types::material_id right)\\n  {\\n return (left == right ? rank2_type() : sigma_tensor);\\n  }\\n \\n template <int dim>\\n typename Parameters<dim>::rank1_type\\n  Parameters<dim>::J_a(const Point<dim> &point, types::material_id /*id*/)\\n  {\\n    rank1_type J_a;\\n const auto distance = (dipole_position - point).norm() / dipole_radius;\\n if (distance > 1.)\\n return J_a;\\n double scale = std::cos(distance * M_PI / 2.) *\\n std::cos(distance * M_PI / 2.) / (M_PI / 2. - 2. / M_PI) /\\n                   dipole_radius / dipole_radius;\\n    J_a = dipole_strength * dipole_orientation * scale;\\n return J_a;\\n  }\\n \\n \\n template <int dim>\\n class PerfectlyMatchedLayer : public ParameterAcceptor\\n  {\\n public:\\n static_assert(dim == 2,\\n \\\"The perfectly matched layer is only implemented in 2d.\\\");\\n \\n    Parameters<dim> parameters;\\n \\n using rank1_type = Tensor<1, dim, std::complex<double>>;\\n \\n using rank2_type = Tensor<2, dim, std::complex<double>>;\\n \\n    PerfectlyMatchedLayer();\\n \\n    std::complex<double> d(const Point<dim> point);\\n \\n    std::complex<double> d_bar(const Point<dim> point);\\n \\n \\n    rank2_type rotation(std::complex<double> d_1,\\n                        std::complex<double> d_2,\\n Point<dim>           point);\\n \\n    rank2_type a_matrix(const Point<dim> point);\\n \\n    rank2_type b_matrix(const Point<dim> point);\\n \\n    rank2_type c_matrix(const Point<dim> point);\\n \\n private:\\n double inner_radius;\\n double outer_radius;\\n double strength;\\n  };\\n \\n \\n template <int dim>\\n  PerfectlyMatchedLayer<dim>::PerfectlyMatchedLayer()\\n    : ParameterAcceptor(\\\"PerfectlyMatchedLayer\\\")\\n  {\\n    inner_radius = 12.;\\n    add_parameter(\\\"inner radius\\\",\\n                  inner_radius,\\n \\\"inner radius of the PML shell\\\");\\n    outer_radius = 20.;\\n    add_parameter(\\\"outer radius\\\",\\n                  outer_radius,\\n \\\"outer radius of the PML shell\\\");\\n    strength = 8.;\\n    add_parameter(\\\"strength\\\", strength, \\\"strength of the PML\\\");\\n  }\\n \\n \\n template <int dim>\\n typename std::complex<double>\\n  PerfectlyMatchedLayer<dim>::d(const Point<dim> point)\\n  {\\n const auto radius = point.norm();\\n if (radius > inner_radius)\\n      {\\n const double s =\\n          strength * ((radius - inner_radius) * (radius - inner_radius)) /\\n          ((outer_radius - inner_radius) * (outer_radius - inner_radius));\\n return {1.0, s};\\n      }\\n else\\n      {\\n return 1.0;\\n      }\\n  }\\n \\n \\n template <int dim>\\n typename std::complex<double>\\n  PerfectlyMatchedLayer<dim>::d_bar(const Point<dim> point)\\n  {\\n const auto radius = point.norm();\\n if (radius > inner_radius)\\n      {\\n const double s_bar =\\n          strength / 3. *\\n          ((radius - inner_radius) * (radius - inner_radius) *\\n           (radius - inner_radius)) /\\n          (radius * (outer_radius - inner_radius) *\\n           (outer_radius - inner_radius));\\n return {1.0, s_bar};\\n      }\\n else\\n      {\\n return 1.0;\\n      }\\n  }\\n \\n \\n template <int dim>\\n typename PerfectlyMatchedLayer<dim>::rank2_type\\n  PerfectlyMatchedLayer<dim>::rotation(std::complex<double> d_1,\\n                                       std::complex<double> d_2,\\n Point<dim>           point)\\n  {\\n    rank2_type result;\\n    result[0][0] = point[0] * point[0] * d_1 + point[1] * point[1] * d_2;\\n    result[0][1] = point[0] * point[1] * (d_1 - d_2);\\n    result[1][0] = point[0] * point[1] * (d_1 - d_2);\\n    result[1][1] = point[1] * point[1] * d_1 + point[0] * point[0] * d_2;\\n return result;\\n  }\\n \\n \\n template <int dim>\\n typename PerfectlyMatchedLayer<dim>::rank2_type\\n  PerfectlyMatchedLayer<dim>::a_matrix(const Point<dim> point)\\n  {\\n const auto d     = this->d(point);\\n const auto d_bar = this->d_bar(point);\\n return invert(rotation(d * d, d * d_bar, point)) *\\n           rotation(d * d, d * d_bar, point);\\n  }\\n \\n \\n template <int dim>\\n typename PerfectlyMatchedLayer<dim>::rank2_type\\n  PerfectlyMatchedLayer<dim>::b_matrix(const Point<dim> point)\\n  {\\n const auto d     = this->d(point);\\n const auto d_bar = this->d_bar(point);\\n return invert(rotation(d, d_bar, point)) * rotation(d, d_bar, point);\\n  }\\n \\n \\n template <int dim>\\n typename PerfectlyMatchedLayer<dim>::rank2_type\\n  PerfectlyMatchedLayer<dim>::c_matrix(const Point<dim> point)\\n  {\\n const auto d     = this->d(point);\\n const auto d_bar = this->d_bar(point);\\n return invert(rotation(1. / d_bar, 1. / d, point)) *\\n           rotation(1. / d_bar, 1. / d, point);\\n  }\\n \\n \\n \\n template <int dim>\\n class Maxwell : public ParameterAcceptor\\n  {\\n public:\\n    Maxwell();\\n void run();\\n \\n private:\\n /* run time parameters */\\n double       scaling;\\n unsigned int refinements;\\n unsigned int fe_order;\\n unsigned int quadrature_order;\\n bool         absorbing_boundary;\\n \\n void parse_parameters_callback();\\n void make_grid();\\n void setup_system();\\n void assemble_system();\\n void solve();\\n void output_results();\\n \\n    Parameters<dim>            parameters;\\n    PerfectlyMatchedLayer<dim> perfectly_matched_layer;\\n \\n Triangulation<dim> triangulation;\\n DoFHandler<dim>    dof_handler;\\n \\n    std::unique_ptr<FiniteElement<dim>> fe;\\n \\n AffineConstraints<double> constraints;\\n SparsityPattern           sparsity_pattern;\\n SparseMatrix<double>      system_matrix;\\n Vector<double>            solution;\\n Vector<double>            system_rhs;\\n  };\\n \\n \\n template <int dim>\\n  Maxwell<dim>::Maxwell()\\n    : ParameterAcceptor(\\\"Maxwell\\\")\\n    , dof_handler(triangulation)\\n  {\\n ParameterAcceptor::parse_parameters_call_back.connect(\\n      [&]() { parse_parameters_callback(); });\\n \\n    scaling = 20;\\n    add_parameter(\\\"scaling\\\", scaling, \\\"scale of the hypercube geometry\\\");\\n \\n    refinements = 8;\\n    add_parameter(\\\"refinements\\\",\\n                  refinements,\\n \\\"number of refinements of the geometry\\\");\\n \\n    fe_order = 0;\\n    add_parameter(\\\"fe order\\\", fe_order, \\\"order of the finite element space\\\");\\n \\n    quadrature_order = 1;\\n    add_parameter(\\\"quadrature order\\\",\\n                  quadrature_order,\\n \\\"order of the quadrature\\\");\\n \\n    absorbing_boundary = true;\\n    add_parameter(\\\"absorbing boundary condition\\\",\\n                  absorbing_boundary,\\n \\\"use absorbing boundary conditions?\\\");\\n  }\\n \\n \\n template <int dim>\\n void Maxwell<dim>::parse_parameters_callback()\\n  {\\n    fe = std::make_unique<FESystem<dim>>(FE_NedelecSZ<dim>(fe_order), 2);\\n  }\\n \\n \\n template <int dim>\\n void Maxwell<dim>::make_grid()\\n  {\\n GridGenerator::hyper_cube(triangulation, -scaling, scaling);\\n triangulation.refine_global(refinements);\\n \\n if (!absorbing_boundary)\\n      {\\n for (auto &face : triangulation.active_face_iterators())\\n          if (face->at_boundary())\\n            face->set_boundary_id(1);\\n      };\\n \\n for (auto &cell : triangulation.active_cell_iterators())\\n      if (cell->center()[1] > 0.)\\n        cell->set_material_id(1);\\n else\\n        cell->set_material_id(2);\\n \\n \\n    std::cout << \\\"Number of active cells: \\\" << triangulation.n_active_cells()\\n              << std::endl;\\n  }\\n \\n \\n template <int dim>\\n void Maxwell<dim>::setup_system()\\n  {\\n    dof_handler.distribute_dofs(*fe);\\n    std::cout << \\\"Number of degrees of freedom: \\\" << dof_handler.n_dofs()\\n              << std::endl;\\n \\n    solution.reinit(dof_handler.n_dofs());\\n    system_rhs.reinit(dof_handler.n_dofs());\\n \\n    constraints.clear();\\n \\n DoFTools::make_hanging_node_constraints(dof_handler, constraints);\\n \\n VectorTools::project_boundary_values_curl_conforming_l2(\\n      dof_handler,\\n      0, /* real part */\\n Functions::ZeroFunction<dim>(2 * dim),\\n      0, /* boundary id */\\n      constraints);\\n VectorTools::project_boundary_values_curl_conforming_l2(\\n      dof_handler,\\n      dim, /* imaginary part */\\n Functions::ZeroFunction<dim>(2 * dim),\\n      0, /* boundary id */\\n      constraints);\\n \\n    constraints.close();\\n \\n DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());\\n DoFTools::make_sparsity_pattern(dof_handler,\\n                                    dsp,\\n                                    constraints,\\n /* keep_constrained_dofs = */ true);\\n    sparsity_pattern.copy_from(dsp);\\n    system_matrix.reinit(sparsity_pattern);\\n  }\\n \\n template <int dim>\\n DEAL_II_ALWAYS_INLINE inline Tensor<1, dim, std::complex<double>>\\n  tangential_part(const Tensor<1, dim, std::complex<double>> &tensor,\\n const Tensor<1, dim>                       &normal)\\n  {\\n auto result = tensor;\\n    result[0]   = normal[1] * (tensor[0] * normal[1] - tensor[1] * normal[0]);\\n    result[1]   = -normal[0] * (tensor[0] * normal[1] - tensor[1] * normal[0]);\\n return result;\\n  }\\n \\n \\n \\n template <int dim>\\n void Maxwell<dim>::assemble_system()\\n  {\\n const QGauss<dim>     quadrature_formula(quadrature_order);\\n const QGauss<dim - 1> face_quadrature_formula(quadrature_order);\\n \\n FEValues<dim, dim>     fe_values(*fe,\\n                                 quadrature_formula,\\n update_values | update_gradients |\\n update_quadrature_points |\\n update_JxW_values);\\n FEFaceValues<dim, dim> fe_face_values(*fe,\\n                                          face_quadrature_formula,\\n update_values | update_gradients |\\n update_quadrature_points |\\n update_normal_vectors |\\n update_JxW_values);\\n \\n const unsigned int dofs_per_cell = fe->dofs_per_cell;\\n \\n const unsigned int n_q_points      = quadrature_formula.size();\\n const unsigned int n_face_q_points = face_quadrature_formula.size();\\n \\n FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n Vector<double>     cell_rhs(dofs_per_cell);\\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n const FEValuesExtractors::Vector real_part(0);\\n const FEValuesExtractors::Vector imag_part(dim);\\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n        fe_values.reinit(cell);\\n \\n cell_matrix = 0.;\\n        cell_rhs    = 0.;\\n \\n        cell->get_dof_indices(local_dof_indices);\\n const auto id = cell->material_id();\\n \\n const auto &quadrature_points = fe_values.get_quadrature_points();\\n \\n for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n          {\\n const Point<dim> &position = quadrature_points[q_point];\\n \\n auto       mu_inv  = parameters.mu_inv(position, id);\\n auto epsilon = parameters.epsilon(position, id);\\n const auto J_a     = parameters.J_a(position, id);\\n \\n const auto A = perfectly_matched_layer.a_matrix(position);\\n const auto B = perfectly_matched_layer.b_matrix(position);\\n const auto d = perfectly_matched_layer.d(position);\\n \\n            mu_inv  = mu_inv / d;\\n epsilon = invert(A) * epsilon * invert(B);\\n \\n for (const auto i : fe_values.dof_indices())\\n              {\\n constexpr std::complex<double> imag{0., 1.};\\n \\n const auto phi_i =\\n                  fe_values[real_part].value(i, q_point) -\\n                  imag * fe_values[imag_part].value(i, q_point);\\n const auto curl_phi_i =\\n                  fe_values[real_part].curl(i, q_point) -\\n                  imag * fe_values[imag_part].curl(i, q_point);\\n \\n const auto rhs_value =\\n                  (imag * scalar_product(J_a, phi_i)) * fe_values.JxW(q_point);\\n                cell_rhs(i) += rhs_value.real();\\n \\n for (const auto j : fe_values.dof_indices())\\n                  {\\n const auto phi_j =\\n                      fe_values[real_part].value(j, q_point) +\\n                      imag * fe_values[imag_part].value(j, q_point);\\n const auto curl_phi_j =\\n                      fe_values[real_part].curl(j, q_point) +\\n                      imag * fe_values[imag_part].curl(j, q_point);\\n \\n const auto temp =\\n                      (scalar_product(mu_inv * curl_phi_j, curl_phi_i) -\\n                       scalar_product(epsilon * phi_j, phi_i)) *\\n                      fe_values.JxW(q_point);\\n cell_matrix(i, j) += temp.real();\\n                  }\\n              }\\n          }\\n \\n const FEValuesExtractors::Vector real_part(0);\\n const FEValuesExtractors::Vector imag_part(dim);\\n for (const auto &face : cell->face_iterators())\\n          {\\n if (face->at_boundary())\\n              {\\n const auto id = face->boundary_id();\\n if (id != 0)\\n                  {\\n                    fe_face_values.reinit(cell, face);\\n \\n for (unsigned int q_point = 0; q_point < n_face_q_points;\\n                         ++q_point)\\n                      {\\n const auto &position = quadrature_points[q_point];\\n \\n auto mu_inv  = parameters.mu_inv(position, id);\\n auto epsilon = parameters.epsilon(position, id);\\n \\n const auto A =\\n                          perfectly_matched_layer.a_matrix(position);\\n const auto B =\\n                          perfectly_matched_layer.b_matrix(position);\\n const auto d = perfectly_matched_layer.d(position);\\n \\n                        mu_inv  = mu_inv / d;\\n epsilon = invert(A) * epsilon * invert(B);\\n \\n const auto normal =\\n                          fe_face_values.normal_vector(q_point);\\n \\n for (const auto i : fe_face_values.dof_indices())\\n                          {\\n constexpr std::complex<double> imag{0., 1.};\\n \\n const auto phi_i =\\n                              fe_face_values[real_part].value(i, q_point) -\\n                              imag *\\n                                fe_face_values[imag_part].value(i, q_point);\\n const auto phi_i_T = tangential_part(phi_i, normal);\\n \\n for (const auto j : fe_face_values.dof_indices())\\n                              {\\n const auto phi_j =\\n                                  fe_face_values[real_part].value(j, q_point) +\\n                                  imag *\\n                                    fe_face_values[imag_part].value(j, q_point);\\n const auto phi_j_T =\\n                                  tangential_part(phi_j, normal) *\\n                                  fe_face_values.JxW(q_point);\\n \\n const auto prod      = mu_inv * epsilon;\\n const auto sqrt_prod = prod;\\n \\n const auto temp =\\n                                  -imag * scalar_product((sqrt_prod * phi_j_T),\\n                                                         phi_i_T);\\n cell_matrix(i, j) += temp.real();\\n                              } /* j */\\n                          }     /* i */\\n                      }         /* q_point */\\n                  }\\n              }\\n else\\n              {\\n const auto face_index = cell->face_iterator_to_index(face);\\n \\n const auto id1 = cell->material_id();\\n const auto id2 = cell->neighbor(face_index)->material_id();\\n \\n if (id1 == id2)\\n continue; /* skip this face */\\n \\n                fe_face_values.reinit(cell, face);\\n \\n for (unsigned int q_point = 0; q_point < n_face_q_points;\\n                     ++q_point)\\n                  {\\n const auto &position = quadrature_points[q_point];\\n \\n auto sigma = parameters.sigma(position, id1, id2);\\n \\n const auto B = perfectly_matched_layer.b_matrix(position);\\n const auto C = perfectly_matched_layer.c_matrix(position);\\n                    sigma        = invert(C) * sigma * invert(B);\\n \\n const auto normal = fe_face_values.normal_vector(q_point);\\n \\n for (const auto i : fe_face_values.dof_indices())\\n                      {\\n constexpr std::complex<double> imag{0., 1.};\\n \\n const auto phi_i =\\n                          fe_face_values[real_part].value(i, q_point) -\\n                          imag * fe_face_values[imag_part].value(i, q_point);\\n const auto phi_i_T = tangential_part(phi_i, normal);\\n \\n for (const auto j : fe_face_values.dof_indices())\\n                          {\\n const auto phi_j =\\n                              fe_face_values[real_part].value(j, q_point) +\\n                              imag *\\n                                fe_face_values[imag_part].value(j, q_point);\\n const auto phi_j_T = tangential_part(phi_j, normal);\\n \\n const auto temp =\\n                              -imag *\\n                              scalar_product((sigma * phi_j_T), phi_i_T) *\\n                              fe_face_values.JxW(q_point);\\n cell_matrix(i, j) += temp.real();\\n                          } /* j */\\n                      }     /* i */\\n                  }         /* q_point */\\n              }\\n          }\\n \\n        constraints.distribute_local_to_global(\\n          cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);\\n      }\\n  }\\n \\n template <int dim>\\n void Maxwell<dim>::solve()\\n  {\\n SparseDirectUMFPACK A_direct;\\n    A_direct.initialize(system_matrix);\\n    A_direct.vmult(solution, system_rhs);\\n  }\\n \\n template <int dim>\\n void Maxwell<dim>::output_results()\\n  {\\n DataOut<2> data_out;\\n    data_out.attach_dof_handler(dof_handler);\\n    data_out.add_data_vector(solution,\\n                             {\\\"real_Ex\\\", \\\"real_Ey\\\", \\\"imag_Ex\\\", \\\"imag_Ey\\\"});\\n    data_out.build_patches();\\n    std::ofstream output(\\\"solution.vtk\\\");\\n    data_out.write_vtk(output);\\n  }\\n \\n \\n template <int dim>\\n void Maxwell<dim>::run()\\n  {\\n    make_grid();\\n    setup_system();\\n    assemble_system();\\n    solve();\\n    output_results();\\n  }\\n \\n} // namespace Step81\\n \\n \\nint main()\\n{\\n try\\n    {\\n using namespace dealii;\\n \\n      Step81::Maxwell<2> maxwell_2d;\\n ParameterAcceptor::initialize(\\\"parameters.prm\\\");\\n      maxwell_2d.run();\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n return 0;\\n}\\naffine_constraints.h\\nSparseDirectUMFPACK::vmultvoid vmult(Vector< double > &dst, const Vector< double > &src) constDefinition sparse_direct.cc:795\\ndof_accessor.h\\ndof_handler.h\\ndof_renumbering.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nerror_estimator.h\\nfe_values.h\\nfe_nedelec_sz.h\\nfe_q.h\\nfe_system.h\\nfull_matrix.h\\nfunction.h\\ngrid_refinement.h\\ntria.h\\ngrid_generator.h\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\nParticles::Generators::quadrature_pointsvoid quadrature_points(const Triangulation< dim, spacedim > &triangulation, const Quadrature< dim > &quadrature, const std::vector< std::vector< BoundingBox< spacedim > > > &global_bounding_boxes, ParticleHandler< dim, spacedim > &particle_handler, const Mapping< dim, spacedim > &mapping=(ReferenceCells::get_hypercube< dim >() .template get_default_linear_mapping< dim, spacedim >()), const std::vector< std::vector< double > > &properties={})Definition generators.cc:473\\nPhysics::Elasticity::Kinematics::CSymmetricTensor< 2, dim, Number > C(const Tensor< 2, dim, Number > &F)\\nPhysics::Elasticity::Kinematics::epsilonSymmetricTensor< 2, dim, Number > epsilon(const Tensor< 2, dim, Number > &Grad_u)\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\ninternal::DataOutImplementation::ComponentExtractor::real_part@ real_part\\ndata_out.h\\nparameter_acceptor.h\\nprecondition.h\\nquadrature_lib.h\\nsolver_cg.h\\nsparse_direct.h\\nsparse_ilu.h\\nsparse_matrix.h\\ntensor.h\\ntria_accessor.h\\ntria_iterator.h\\nvector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"