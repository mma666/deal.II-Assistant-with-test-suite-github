"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_52.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-52 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-52 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-52 tutorial program\\n\\n\\nThis tutorial depends on step-26.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nProblem statement\\nRunge-Kutta methods\\n\\nExplicit Runge-Kutta methods\\nEmbedded Runge-Kutta methods\\nImplicit Runge-Kutta methods\\n\\nSpatially discrete formulation\\nNotes on the testcase\\n\\n The commented program\\n\\nInclude files\\nThe Diffusion class\\n\\nDiffusion::setup_system\\nDiffusion::assemble_system\\nDiffusion::get_source\\nDiffusion::evaluate_diffusion\\nDiffusion::id_minus_tau_J_inverse\\nDiffusion::output_results\\nDiffusion::explicit_method\\nDiffusion::implicit_method\\nDiffusion::embedded_explicit_method\\nDiffusion::run\\n\\nThe main() function\\n\\n\\n Results\\n\\n\\n The plain program\\n   \\n\\n\\nThis program was contributed by Bruno Turcksin and Damien Lebrun-Grandie.\\nNoteIn order to run this program, deal.II must be configured to use the UMFPACK sparse direct solver. Refer to the ReadMe for instructions how to do this.\\n Introduction\\nThis program shows how to use Runge-Kutta methods to solve a time-dependent problem. It solves a small variation of the heat equation discussed first in step-26 but, since the purpose of this program is only to demonstrate using more advanced ways to interface with deal.II's time stepping algorithms, only solves a simple problem on a uniformly refined mesh.\\nNoteAt the end of the day, time stepping is a problem that is only solved efficiently if you use adaptive time step selection and error control. This is implemented in many external libraries, but not in deal.II itself. You may want to consider looking at step-86 for a worked out example. In the meantime, this program is deprecated and will be removed after the deal.II 9.6 release.\\nProblem statement\\nIn this example, we solve the one-group time-dependent diffusion approximation of the neutron transport equation (see step-28 for the time-independent multigroup diffusion). This is a model for how neutrons move around highly scattering media, and consequently it is a variant of the time-dependent diffusion equation \\u2013 which is just a different name for the heat equation discussed in step-26, plus some extra terms. We assume that the medium is not fissible and therefore, the neutron flux satisfies the following equation:    \\n\\\\begin{eqnarray*}\\n\\\\frac{1}{v}\\\\frac{\\\\partial \\\\phi(x,t)}{\\\\partial t} = \\\\nabla \\\\cdot D(x) \\\\nabla \\\\phi(x,t)\\n- \\\\Sigma_a(x) \\\\phi(x,t) + S(x,t)\\n\\\\end{eqnarray*}\\n\\n augmented by appropriate boundary conditions. Here, \\\\(v\\\\) is the velocity of neutrons (for simplicity we assume it is equal to 1 which can be achieved by simply scaling the time variable), \\\\(D\\\\) is the diffusion coefficient, \\\\(\\\\Sigma_a\\\\) is the absorption cross section, and \\\\(S\\\\) is a source. Because we are only interested in the time dependence, we assume that \\\\(D\\\\) and \\\\(\\\\Sigma_a\\\\) are constant.\\nSince this program only intends to demonstrate how to use advanced time stepping algorithms, we will only look for the solutions of relatively simple problems. Specifically, we are looking for a solution on a square domain \\\\([0,b]\\\\times[0,b]\\\\) of the form   \\n\\\\begin{eqnarray*}\\n\\\\phi(x,t) = A\\\\sin(\\\\omega t)(bx-x^2).\\n\\\\end{eqnarray*}\\n\\n By using quadratic finite elements, we can represent this function exactly at any particular time, and all the error will be due to the time discretization. We do this because it is then easy to observe the order of convergence of the various time stepping schemes we will consider, without having to separate spatial and temporal errors.\\nWe impose the following boundary conditions: homogeneous Dirichlet for \\\\(x=0\\\\) and \\\\(x=b\\\\) and homogeneous Neumann conditions for \\\\(y=0\\\\) and \\\\(y=b\\\\). We choose the source term so that the corresponding solution is in fact of the form stated above:    \\n\\\\begin{eqnarray*}\\nS=A\\\\left(\\\\frac{1}{v}\\\\omega \\\\cos(\\\\omega t)(bx -x^2) + \\\\sin(\\\\omega t)\\n\\\\left(\\\\Sigma_a (bx-x^2)+2D\\\\right) \\\\right).\\n\\\\end{eqnarray*}\\n\\n Because the solution is a sine in time, we know that the exact solution satisfies \\\\(\\\\phi\\\\left(x,\\\\frac{\\\\pi}{\\\\omega}\\\\right) = 0\\\\). Therefore, the error at time \\\\(t=\\\\frac{\\\\pi}{\\\\omega}\\\\) is simply the norm of the numerical solution, i.e., \\\\(\\\\|e(\\\\cdot,t=\\\\frac{\\\\pi}{\\\\omega})\\\\|_{L_2} = \\\\|\\\\phi_h(\\\\cdot,t=\\\\frac{\\\\pi}{\\\\omega})\\\\|_{L_2}\\\\), and is particularly easily evaluated. In the code, we evaluate the \\\\(l_2\\\\) norm of the vector of nodal values of \\\\(\\\\phi_h\\\\) instead of the \\\\(L_2\\\\) norm of the associated spatial function, since the former is simpler to compute; however, on uniform meshes, the two are just related by a constant and we can consequently observe the temporal convergence order with either.\\nRunge-Kutta methods\\nThe Runge-Kutta methods implemented in deal.II assume that the equation to be solved can be written as:   \\n\\\\begin{eqnarray*}\\n\\\\frac{dy}{dt} = g(t,y).\\n\\\\end{eqnarray*}\\n\\n On the other hand, when using finite elements, discretized time derivatives always result in the presence of a mass matrix on the left hand side. This can easily be seen by considering that if the solution vector \\\\(y(t)\\\\) in the equation above is in fact the vector of nodal coefficients \\\\(U(t)\\\\) for a variable of the form   \\n\\\\begin{eqnarray*}\\n  u_h(x,t) = \\\\sum_j U_j(t) \\\\varphi_j(x)\\n\\\\end{eqnarray*}\\n\\n with spatial shape functions \\\\(\\\\varphi_j(x)\\\\), then multiplying an equation of the form   \\n\\\\begin{eqnarray*}\\n  \\\\frac{\\\\partial u(x,t)}{\\\\partial t} = q(t,u(x,t))\\n\\\\end{eqnarray*}\\n\\n by test functions, integrating over \\\\(\\\\Omega\\\\), substituting \\\\(u\\\\rightarrow u_h\\\\) and restricting the test functions to the \\\\(\\\\varphi_i(x)\\\\) from above, then this spatially discretized equation has the form   \\n\\\\begin{eqnarray*}\\nM\\\\frac{dU}{dt} = f(t,U),\\n\\\\end{eqnarray*}\\n\\n where \\\\(M\\\\) is the mass matrix and \\\\(f(t,U)\\\\) is the spatially discretized version of \\\\(q(t,u(x,t))\\\\) (where \\\\(q\\\\) is typically the place where spatial derivatives appear, but this is not of much concern for the moment given that we only consider time derivatives). In other words, this form fits the general scheme above if we write   \\n\\\\begin{eqnarray*}\\n\\\\frac{dy}{dt} = g(t,y) = M^{-1}f(t,y).\\n\\\\end{eqnarray*}\\n\\nRunke-Kutta methods are time stepping schemes that approximate  \\\\(y(t_n)\\\\approx\\ny_{n}\\\\) through a particular one-step approach. They are typically written in the form   \\n\\\\begin{eqnarray*}\\ny_{n+1} = y_n + \\\\sum_{i=1}^s b_i k_i\\n\\\\end{eqnarray*}\\n\\n where for the form of the right hand side above   \\n\\\\begin{eqnarray*}\\nk_i = \\\\Delta t \\\\, M^{-1} f\\\\left(t_n+c_ih,y_n+\\\\sum_{j=1}^sa_{ij}k_j\\\\right).\\n\\\\end{eqnarray*}\\n\\n Here \\\\(a_{ij}\\\\), \\\\(b_i\\\\), and \\\\(c_i\\\\) are known coefficients that identify which particular Runge-Kutta scheme you want to use, and \\\\(\\\\Delta t=t_{n+1}-t_n\\\\) is the time step used. Different time stepping methods of the Runge-Kutta class differ in the number of stages \\\\(s\\\\) and the values they use for the coefficients \\\\(a_{ij}\\\\), \\\\(b_i\\\\), and \\\\(c_i\\\\) but are otherwise easy to implement since one can look up tabulated values for these coefficients. (These tables are often called Butcher tableaus.)\\nAt the time of the writing of this tutorial, the methods implemented in deal.II can be divided in three categories: \\n\\nExplicit Runge-Kutta; in order for a method to be explicit, it is necessary that in the formula above defining \\\\(k_i\\\\), \\\\(k_i\\\\) does not appear on the right hand side. In other words, these methods have to satisfy \\\\(a_{ii}=0, i=1,\\\\ldots,s\\\\). \\n\\nEmbedded (or adaptive) Runge-Kutta; we will discuss their properties below. \\n\\nImplicit Runge-Kutta; this class of methods require the solution of a possibly nonlinear system the stages \\\\(k_i\\\\) above, i.e., they have \\\\(a_{ii}\\\\neq 0\\\\) for at least one of the stages \\\\(i=1,\\\\ldots,s\\\\). \\n\\nMany well known time stepping schemes that one does not typically associate with the names Runge or Kutta can in fact be written in a way so that they, too, can be expressed in these categories. They oftentimes represent the lowest-order members of these families; one example is the simple explicit Euler method.\\nExplicit Runge-Kutta methods\\nThese methods, only require a function to evaluate \\\\(M^{-1}f(t,y)\\\\) but not (as implicit methods) to solve an equation that involves \\\\(f(t,y)\\\\) for \\\\(y\\\\). As all explicit time stepping methods, they become unstable when the time step chosen is too large.\\nWell known methods in this class include forward Euler, third order Runge-Kutta, and fourth order Runge-Kutta (often abbreviated as RK4).\\nEmbedded Runge-Kutta methods\\nThese methods use both a lower and a higher order method to estimate the error and decide if the time step needs to be shortened or can be increased. The term \\\"embedded\\\" refers to the fact that the lower-order method does not require additional evaluates of the function \\\\(M^{-1}f(\\\\cdot,\\\\cdot)\\\\) but reuses data that has to be computed for the high order method anyway. It is, in other words, essentially free, and we get the error estimate as a side product of using the higher order method.\\nThis class of methods include Heun-Euler, Bogacki-Shampine, Dormand-Prince (ode45 in Matlab and often abbreviated as RK45 to indicate that the lower and higher order methods used here are 4th and 5th order Runge-Kutta methods, respectively), Fehlberg, and Cash-Karp.\\nAt the time of the writing, only embedded explicit methods have been implemented.\\nImplicit Runge-Kutta methods\\nImplicit methods require the solution of (possibly nonlinear) systems of the form \\\\(\\\\alpha y = f(t,y)\\\\) for \\\\(y\\\\) in each (sub-)timestep. Internally, this is done using a Newton-type method and, consequently, they require that the user provide functions that can evaluate \\\\(M^{-1}f(t,y)\\\\) and \\\\(\\\\left(I-\\\\tau M^{-1} \\\\frac{\\\\partial f}{\\\\partial y}\\\\right)^{-1}\\\\) or equivalently \\\\(\\\\left(M - \\\\tau \\\\frac{\\\\partial f}{\\\\partial y}\\\\right)^{-1} M\\\\).\\nThe particular form of this operator results from the fact that each Newton step requires the solution of an equation of the form    \\n\\\\begin{align*}\\n  \\\\left(M - \\\\tau \\\\frac{\\\\partial f}{\\\\partial y}\\\\right) \\\\Delta y\\n  = -M h(t,y)\\n\\\\end{align*}\\n\\n for some (given) \\\\(h(t,y)\\\\). Implicit methods are always stable, regardless of the time step size, but too large time steps of course affect the accuracy of the solution, even if the numerical solution remains stable and bounded.\\nMethods in this class include backward Euler, implicit midpoint, Crank-Nicolson, and the two stage SDIRK method (short for \\\"singly diagonally\\nimplicit Runge-Kutta\\\", a term coined to indicate that the diagonal elements \\\\(a_{ii}\\\\) defining the time stepping method are all equal; this property allows for the Newton matrix \\\\(I-\\\\tau M^{-1}\\\\frac{\\\\partial f}{\\\\partial y}\\\\) to be re-used between stages because \\\\(\\\\tau\\\\) is the same every time).\\nSpatially discrete formulation\\nBy expanding the solution of our model problem as always using shape functions \\\\(\\\\psi_j\\\\) and writing   \\n\\\\begin{eqnarray*}\\n\\\\phi_h(x,t) = \\\\sum_j U_j(t) \\\\psi_j(x),\\n\\\\end{eqnarray*}\\n\\n we immediately get the spatially discretized version of the diffusion equation as    \\n\\\\begin{eqnarray*}\\n  M \\\\frac{dU(t)}{dt}\\n  = -{\\\\cal D} U(t) - {\\\\cal A} U(t) + {\\\\cal S}(t)\\n\\\\end{eqnarray*}\\n\\n where      \\n\\\\begin{eqnarray*}\\n  M_{ij}  &=& (\\\\psi_i,\\\\psi_j), \\\\\\\\\\n  {\\\\cal D}_{ij}  &=& (D\\\\nabla\\\\psi_i,\\\\nabla\\\\psi_j)_\\\\Omega, \\\\\\\\\\n  {\\\\cal A}_{ij}  &=& (\\\\Sigma_a\\\\psi_i,\\\\psi_j)_\\\\Omega, \\\\\\\\\\n  {\\\\cal S}_{i}(t)  &=& (\\\\psi_i,S(x,t))_\\\\Omega.\\n\\\\end{eqnarray*}\\n\\n See also step-24 and step-26 to understand how we arrive here. Boundary terms are not necessary due to the chosen boundary conditions for the current problem. To use the Runge-Kutta methods, we recast this as follows:   \\n\\\\begin{eqnarray*}\\nf(y) = -{\\\\cal D}y - {\\\\cal A}y + {\\\\cal S}.\\n\\\\end{eqnarray*}\\n\\n In the code, we will need to be able to evaluate this function \\\\(f(U)\\\\) along with its derivative,   \\n\\\\begin{eqnarray*}\\n\\\\frac{\\\\partial f}{\\\\partial y} = -{\\\\cal D} - {\\\\cal A}.\\n\\\\end{eqnarray*}\\n\\nNotes on the testcase\\nTo simplify the problem, the domain is two dimensional and the mesh is uniformly refined (there is no need to adapt the mesh since we use quadratic finite elements and the exact solution is quadratic). Going from a two dimensional domain to a three dimensional domain is not very challenging. However if you intend to solve more complex problems where the mesh must be adapted (as is done, for example, in step-26), then it is important to remember the following issues:\\n\\n\\nYou will need to project the solution to the new mesh when the mesh is changed. Of course, the mesh used should be the same from the beginning to the end of each time step, a question that arises because Runge-Kutta methods use multiple evaluations of the equations within each time step. \\n\\nYou will need to update the mass matrix and its inverse every time the mesh is changed. \\n\\nThe techniques for these steps are readily available by looking at step-26.\\n The commented program\\n Include files\\nThe first task as usual is to include the functionality of these well-known deal.II library files and some C++ header files.\\n\\u00a0 #include <deal.II/base/discrete_time.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_out.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 #include <deal.II/lac/sparse_direct.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 \\n\\u00a0 #include <fstream>\\n\\u00a0 #include <iostream>\\n\\u00a0 #include <cmath>\\n\\u00a0 #include <map>\\n\\u00a0 \\nThis is the only include file that is new: It includes all the Runge-Kutta methods.\\n\\u00a0 #include <deal.II/base/time_stepping.h>\\n\\u00a0 \\n\\u00a0 \\nThe next step is like in all previous tutorial programs: We put everything into a namespace of its own and then import the deal.II classes and functions into it.\\n\\u00a0 namespace Step52\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n The Diffusion class\\nThe next piece is the declaration of the main class. Most of the functions in this class are not new and have been explained in previous tutorials. The only interesting functions are evaluate_diffusion() and id_minus_tau_J_inverse(). evaluate_diffusion() evaluates the diffusion equation, \\\\(M^{-1}(f(t,y))\\\\), at a given time and a given \\\\(y\\\\). id_minus_tau_J_inverse() evaluates  \\\\(\\\\left(I-\\\\tau\\n   M^{-1} \\\\frac{\\\\partial f(t,y)}{\\\\partial y}\\\\right)^{-1}\\\\) or equivalently \\\\(\\\\left(M-\\\\tau \\\\frac{\\\\partial f}{\\\\partial y}\\\\right)^{-1} M\\\\) at a given time, for a given \\\\(\\\\tau\\\\) and \\\\(y\\\\). This function is needed when an implicit method is used.\\n\\u00a0   class Diffusion\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     Diffusion();\\n\\u00a0 \\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void setup_system();\\n\\u00a0 \\n\\u00a0     void assemble_system();\\n\\u00a0 \\n\\u00a0     double get_source(const double time, const Point<2> &point) const;\\n\\u00a0 \\n\\u00a0     Vector<double> evaluate_diffusion(const double          time,\\n\\u00a0                                       const Vector<double> &y) const;\\n\\u00a0 \\n\\u00a0     Vector<double> id_minus_tau_J_inverse(const double          time,\\n\\u00a0                                           const double          tau,\\n\\u00a0                                           const Vector<double> &y);\\n\\u00a0 \\n\\u00a0     void output_results(const double                     time,\\n\\u00a0                         const unsigned int               time_step,\\n\\u00a0                         TimeStepping::runge_kutta_method method) const;\\n\\u00a0 \\nPointDefinition point.h:111\\nVectorDefinition vector.h:120\\nTimeStepping::runge_kutta_methodrunge_kutta_methodDefinition time_stepping.h:60\\nThe next three functions are the drivers for the explicit methods, the implicit methods, and the embedded explicit methods respectively. The driver function for embedded explicit methods returns the number of steps executed given that it only takes the number of time steps passed as an argument as a hint, but internally computed the optimal time step itself.\\n\\u00a0     void explicit_method(const TimeStepping::runge_kutta_method method,\\n\\u00a0                          const unsigned int                     n_time_steps,\\n\\u00a0                          const double                           initial_time,\\n\\u00a0                          const double                           final_time);\\n\\u00a0 \\n\\u00a0     void implicit_method(const TimeStepping::runge_kutta_method method,\\n\\u00a0                          const unsigned int                     n_time_steps,\\n\\u00a0                          const double                           initial_time,\\n\\u00a0                          const double                           final_time);\\n\\u00a0 \\n\\u00a0     unsigned int\\n\\u00a0     embedded_explicit_method(const TimeStepping::runge_kutta_method method,\\n\\u00a0                              const unsigned int n_time_steps,\\n\\u00a0                              const double       initial_time,\\n\\u00a0                              const double       final_time);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     const unsigned int fe_degree;\\n\\u00a0 \\n\\u00a0     const double diffusion_coefficient;\\n\\u00a0     const double absorption_cross_section;\\n\\u00a0 \\n\\u00a0     Triangulation<2> triangulation;\\n\\u00a0 \\n\\u00a0     const FE_Q<2> fe;\\n\\u00a0 \\n\\u00a0     DoFHandler<2> dof_handler;\\n\\u00a0 \\n\\u00a0     AffineConstraints<double> constraint_matrix;\\n\\u00a0 \\n\\u00a0     SparsityPattern sparsity_pattern;\\n\\u00a0 \\n\\u00a0     SparseMatrix<double> system_matrix;\\n\\u00a0     SparseMatrix<double> mass_matrix;\\n\\u00a0     SparseMatrix<double> mass_minus_tau_Jacobian;\\n\\u00a0 \\n\\u00a0     SparseDirectUMFPACK inverse_mass_matrix;\\n\\u00a0 \\n\\u00a0     Vector<double> solution;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nDoFHandlerDefinition dof_handler.h:317\\nFE_QDefinition fe_q.h:554\\nSparseDirectUMFPACKDefinition sparse_direct.h:92\\nSparseMatrixDefinition sparse_matrix.h:520\\nSparsityPatternDefinition sparsity_pattern.h:343\\nTriangulationDefinition tria.h:1323\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\nWe choose quadratic finite elements and we initialize the parameters.\\n\\u00a0   Diffusion::Diffusion()\\n\\u00a0     : fe_degree(2)\\n\\u00a0     , diffusion_coefficient(1. / 30.)\\n\\u00a0     , absorption_cross_section(1.)\\n\\u00a0     , fe(fe_degree)\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n Diffusion::setup_system\\nNow, we create the constraint matrix and the sparsity pattern. Then, we initialize the matrices and the solution vector.\\n\\u00a0   void Diffusion::setup_system()\\n\\u00a0   {\\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0 \\n\\u00a0     VectorTools::interpolate_boundary_values(dof_handler,\\n\\u00a0                                              1,\\n\\u00a0                                              Functions::ZeroFunction<2>(),\\n\\u00a0                                              constraint_matrix);\\n\\u00a0     constraint_matrix.close();\\n\\u00a0 \\n\\u00a0     DynamicSparsityPattern dsp(dof_handler.n_dofs());\\n\\u00a0     DoFTools::make_sparsity_pattern(dof_handler, dsp, constraint_matrix);\\n\\u00a0     sparsity_pattern.copy_from(dsp);\\n\\u00a0 \\n\\u00a0     system_matrix.reinit(sparsity_pattern);\\n\\u00a0     mass_matrix.reinit(sparsity_pattern);\\n\\u00a0     mass_minus_tau_Jacobian.reinit(sparsity_pattern);\\n\\u00a0     solution.reinit(dof_handler.n_dofs());\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nFunctions::ZeroFunctionDefinition function.h:510\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nVectorTools::interpolate_boundary_valuesvoid interpolate_boundary_values(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const std::map< types::boundary_id, const Function< spacedim, number > * > &function_map, std::map< types::global_dof_index, number > &boundary_values, const ComponentMask &component_mask={})\\n Diffusion::assemble_system\\nIn this function, we compute  \\\\(-\\\\int D \\\\nabla b_i \\\\cdot \\\\nabla b_j\\n   d\\\\boldsymbol{r} - \\\\int \\\\Sigma_a b_i b_j d\\\\boldsymbol{r}\\\\) and the mass matrix \\\\(\\\\int b_i b_j d\\\\boldsymbol{r}\\\\). The mass matrix is then inverted using a direct solver; the inverse_mass_matrix variable will then store the inverse of the mass matrix so that \\\\(M^{-1}\\\\) can be applied to a vector using the vmult() function of that object. (Internally, UMFPACK does not really store the inverse of the matrix, but its LU factors; applying the inverse matrix is then equivalent to doing one forward and one backward solves with these two factors, which has the same complexity as applying an explicit inverse of the matrix).\\n\\u00a0   void Diffusion::assemble_system()\\n\\u00a0   {\\n\\u00a0     system_matrix = 0.;\\n\\u00a0     mass_matrix   = 0.;\\n\\u00a0 \\n\\u00a0     const QGauss<2> quadrature_formula(fe_degree + 1);\\n\\u00a0 \\n\\u00a0     FEValues<2> fe_values(fe,\\n\\u00a0                           quadrature_formula,\\n\\u00a0                           update_values | update_gradients | update_JxW_values);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n\\u00a0     const unsigned int n_q_points    = quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0     FullMatrix<double> cell_mass_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         cell_matrix      = 0.;\\n\\u00a0         cell_mass_matrix = 0.;\\n\\u00a0 \\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0         for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n\\u00a0           for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0             for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0               {\\n\\u00a0                 cell_matrix(i, j) +=\\n\\u00a0                   ((-diffusion_coefficient *                // (-D\\n\\u00a0                       fe_values.shape_grad(i, q_point) *    //  * grad phi_i\\n\\u00a0                       fe_values.shape_grad(j, q_point)      //  * grad phi_j\\n\\u00a0                     - absorption_cross_section *            //  -Sigma\\n\\u00a0                         fe_values.shape_value(i, q_point) * //  * phi_i\\n\\u00a0                         fe_values.shape_value(j, q_point))  //  * phi_j)\\n\\u00a0                    * fe_values.JxW(q_point));               // * dx\\n\\u00a0                 cell_mass_matrix(i, j) += fe_values.shape_value(i, q_point) *\\n\\u00a0                                           fe_values.shape_value(j, q_point) *\\n\\u00a0                                           fe_values.JxW(q_point);\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0 \\n\\u00a0         constraint_matrix.distribute_local_to_global(cell_matrix,\\n\\u00a0                                                      local_dof_indices,\\n\\u00a0                                                      system_matrix);\\n\\u00a0         constraint_matrix.distribute_local_to_global(cell_mass_matrix,\\n\\u00a0                                                      local_dof_indices,\\n\\u00a0                                                      mass_matrix);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     inverse_mass_matrix.initialize(mass_matrix);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFEValuesDefinition fe_values.h:63\\nFullMatrixDefinition full_matrix.h:79\\nQGaussDefinition quadrature_lib.h:40\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\n Diffusion::get_source\\nIn this function, the source term of the equation for a given time and a given point is computed.\\n\\u00a0   double Diffusion::get_source(const double time, const Point<2> &point) const\\n\\u00a0   {\\n\\u00a0     const double intensity = 10.;\\n\\u00a0     const double frequency = numbers::PI / 10.;\\n\\u00a0     const double b         = 5.;\\n\\u00a0     const double x         = point[0];\\n\\u00a0 \\n\\u00a0     return intensity *\\n\\u00a0            (frequency * std::cos(frequency * time) * (b * x - x * x) +\\n\\u00a0             std::sin(frequency * time) *\\n\\u00a0               (absorption_cross_section * (b * x - x * x) +\\n\\u00a0                2. * diffusion_coefficient));\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nnumbers::PIstatic constexpr double PIDefinition numbers.h:259\\nstd::cos::VectorizedArray< Number, width > cos(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6609\\nstd::sin::VectorizedArray< Number, width > sin(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6589\\n Diffusion::evaluate_diffusion\\nNext, we evaluate the weak form of the diffusion equation at a given time \\\\(t\\\\) and for a given vector \\\\(y\\\\). In other words, as outlined in the introduction, we evaluate  \\\\(M^{-1}(-{\\\\cal D}y - {\\\\cal A}y + {\\\\cal\\n   S})\\\\). For this, we have to apply the matrix \\\\(-{\\\\cal D} - {\\\\cal A}\\\\) (previously computed and stored in the variable system_matrix) to \\\\(y\\\\) and then add the source term which we integrate as we usually do. (Integrating up the solution could be done using VectorTools::create_right_hand_side() if you wanted to save a few lines of code, or wanted to take advantage of doing the integration in parallel.) The result is then multiplied by \\\\(M^{-1}\\\\).\\n\\u00a0   Vector<double> Diffusion::evaluate_diffusion(const double          time,\\n\\u00a0                                                const Vector<double> &y) const\\n\\u00a0   {\\n\\u00a0     Vector<double> tmp(dof_handler.n_dofs());\\n\\u00a0     tmp = 0.;\\n\\u00a0     system_matrix.vmult(tmp, y);\\n\\u00a0 \\n\\u00a0     const QGauss<2> quadrature_formula(fe_degree + 1);\\n\\u00a0 \\n\\u00a0     FEValues<2> fe_values(fe,\\n\\u00a0                           quadrature_formula,\\n\\u00a0                           update_values | update_quadrature_points |\\n\\u00a0                             update_JxW_values);\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n\\u00a0     const unsigned int n_q_points    = quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     Vector<double> cell_source(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         cell_source = 0.;\\n\\u00a0 \\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0         for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n\\u00a0           {\\n\\u00a0             const double source =\\n\\u00a0               get_source(time, fe_values.quadrature_point(q_point));\\n\\u00a0             for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0               cell_source(i) += fe_values.shape_value(i, q_point) * // phi_i(x)\\n\\u00a0                                 source *                            // * S(x)\\n\\u00a0                                 fe_values.JxW(q_point);             // * dx\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0 \\n\\u00a0         constraint_matrix.distribute_local_to_global(cell_source,\\n\\u00a0                                                      local_dof_indices,\\n\\u00a0                                                      tmp);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     Vector<double> value(dof_handler.n_dofs());\\n\\u00a0     inverse_mass_matrix.vmult(value, tmp);\\n\\u00a0 \\n\\u00a0     return value;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\ninternal::EvaluatorQuantity::value@ value\\n Diffusion::id_minus_tau_J_inverse\\nWe compute \\\\(\\\\left(M-\\\\tau \\\\frac{\\\\partial f}{\\\\partial y}\\\\right)^{-1} M\\\\). This is done in several steps:\\ncompute \\\\(M-\\\\tau \\\\frac{\\\\partial f}{\\\\partial y}\\\\)\\ninvert the matrix to get  \\\\(\\\\left(M-\\\\tau \\\\frac{\\\\partial f}\\n   {\\\\partial y}\\\\right)^{-1}\\\\)\\ncompute \\\\(tmp=My\\\\)\\ncompute  \\\\(z=\\\\left(M-\\\\tau \\\\frac{\\\\partial f}{\\\\partial y}\\\\right)^{-1} tmp =\\n   \\\\left(M-\\\\tau \\\\frac{\\\\partial f}{\\\\partial y}\\\\right)^{-1} My\\\\)\\nreturn z.\\n\\n\\u00a0   Vector<double> Diffusion::id_minus_tau_J_inverse(const double /*time*/,\\n\\u00a0                                                    const double          tau,\\n\\u00a0                                                    const Vector<double> &y)\\n\\u00a0   {\\n\\u00a0     SparseDirectUMFPACK inverse_mass_minus_tau_Jacobian;\\n\\u00a0 \\n\\u00a0     mass_minus_tau_Jacobian.copy_from(mass_matrix);\\n\\u00a0     mass_minus_tau_Jacobian.add(-tau, system_matrix);\\n\\u00a0 \\n\\u00a0     inverse_mass_minus_tau_Jacobian.initialize(mass_minus_tau_Jacobian);\\n\\u00a0 \\n\\u00a0     Vector<double> tmp(dof_handler.n_dofs());\\n\\u00a0     mass_matrix.vmult(tmp, y);\\n\\u00a0 \\n\\u00a0     Vector<double> result(y);\\n\\u00a0     inverse_mass_minus_tau_Jacobian.vmult(result, tmp);\\n\\u00a0 \\n\\u00a0     return result;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nSparseDirectUMFPACK::initializevoid initialize(const SparsityPattern &sparsity_pattern)Definition sparse_direct.cc:67\\n Diffusion::output_results\\nThe following function then outputs the solution in vtu files indexed by the number of the time step and the name of the time stepping method. Of course, the (exact) result should really be the same for all time stepping method, but the output here at least allows us to compare them.\\n\\u00a0   void Diffusion::output_results(const double                     time,\\n\\u00a0                                  const unsigned int               time_step,\\n\\u00a0                                  TimeStepping::runge_kutta_method method) const\\n\\u00a0   {\\n\\u00a0     std::string method_name;\\n\\u00a0 \\n\\u00a0     switch (method)\\n\\u00a0       {\\n\\u00a0         case TimeStepping::FORWARD_EULER:\\n\\u00a0           {\\n\\u00a0             method_name = \\\"forward_euler\\\";\\n\\u00a0             break;\\n\\u00a0           }\\n\\u00a0         case TimeStepping::RK_THIRD_ORDER:\\n\\u00a0           {\\n\\u00a0             method_name = \\\"rk3\\\";\\n\\u00a0             break;\\n\\u00a0           }\\n\\u00a0         case TimeStepping::RK_CLASSIC_FOURTH_ORDER:\\n\\u00a0           {\\n\\u00a0             method_name = \\\"rk4\\\";\\n\\u00a0             break;\\n\\u00a0           }\\n\\u00a0         case TimeStepping::BACKWARD_EULER:\\n\\u00a0           {\\n\\u00a0             method_name = \\\"backward_euler\\\";\\n\\u00a0             break;\\n\\u00a0           }\\n\\u00a0         case TimeStepping::IMPLICIT_MIDPOINT:\\n\\u00a0           {\\n\\u00a0             method_name = \\\"implicit_midpoint\\\";\\n\\u00a0             break;\\n\\u00a0           }\\n\\u00a0         case TimeStepping::SDIRK_TWO_STAGES:\\n\\u00a0           {\\n\\u00a0             method_name = \\\"sdirk\\\";\\n\\u00a0             break;\\n\\u00a0           }\\n\\u00a0         case TimeStepping::HEUN_EULER:\\n\\u00a0           {\\n\\u00a0             method_name = \\\"heun_euler\\\";\\n\\u00a0             break;\\n\\u00a0           }\\n\\u00a0         case TimeStepping::BOGACKI_SHAMPINE:\\n\\u00a0           {\\n\\u00a0             method_name = \\\"bogacki_shampine\\\";\\n\\u00a0             break;\\n\\u00a0           }\\n\\u00a0         case TimeStepping::DOPRI:\\n\\u00a0           {\\n\\u00a0             method_name = \\\"dopri\\\";\\n\\u00a0             break;\\n\\u00a0           }\\n\\u00a0         case TimeStepping::FEHLBERG:\\n\\u00a0           {\\n\\u00a0             method_name = \\\"fehlberg\\\";\\n\\u00a0             break;\\n\\u00a0           }\\n\\u00a0         case TimeStepping::CASH_KARP:\\n\\u00a0           {\\n\\u00a0             method_name = \\\"cash_karp\\\";\\n\\u00a0             break;\\n\\u00a0           }\\n\\u00a0         default:\\n\\u00a0           {\\n\\u00a0             break;\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     DataOut<2> data_out;\\n\\u00a0 \\n\\u00a0     data_out.attach_dof_handler(dof_handler);\\n\\u00a0     data_out.add_data_vector(solution, \\\"solution\\\");\\n\\u00a0 \\n\\u00a0     data_out.build_patches();\\n\\u00a0 \\n\\u00a0     data_out.set_flags(DataOutBase::VtkFlags(time, time_step));\\n\\u00a0 \\n\\u00a0     const std::string filename = \\\"solution_\\\" + method_name + \\\"-\\\" +\\n\\u00a0                                  Utilities::int_to_string(time_step, 3) +\\n\\u00a0                                  \\\".vtu\\\";\\n\\u00a0     std::ofstream output(filename);\\n\\u00a0     data_out.write_vtu(output);\\n\\u00a0 \\n\\u00a0     static std::vector<std::pair<double, std::string>> times_and_names;\\n\\u00a0 \\n\\u00a0     static std::string method_name_prev = \\\"\\\";\\n\\u00a0     static std::string pvd_filename;\\n\\u00a0     if (method_name_prev != method_name)\\n\\u00a0       {\\n\\u00a0         times_and_names.clear();\\n\\u00a0         method_name_prev = method_name;\\n\\u00a0         pvd_filename     = \\\"solution_\\\" + method_name + \\\".pvd\\\";\\n\\u00a0       }\\n\\u00a0     times_and_names.emplace_back(time, filename);\\n\\u00a0     std::ofstream pvd_output(pvd_filename);\\n\\u00a0     DataOutBase::write_pvd_record(pvd_output, times_and_names);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nDataOutBase::write_pvd_recordvoid write_pvd_record(std::ostream &out, const std::vector< std::pair< double, std::string > > &times_and_names)Definition data_out_base.cc:6256\\nTimeStepping::FORWARD_EULER@ FORWARD_EULERDefinition time_stepping.h:64\\nTimeStepping::BOGACKI_SHAMPINE@ BOGACKI_SHAMPINEDefinition time_stepping.h:125\\nTimeStepping::SDIRK_TWO_STAGES@ SDIRK_TWO_STAGESDefinition time_stepping.h:117\\nTimeStepping::RK_CLASSIC_FOURTH_ORDER@ RK_CLASSIC_FOURTH_ORDERDefinition time_stepping.h:78\\nTimeStepping::HEUN_EULER@ HEUN_EULERDefinition time_stepping.h:121\\nTimeStepping::IMPLICIT_MIDPOINT@ IMPLICIT_MIDPOINTDefinition time_stepping.h:108\\nTimeStepping::FEHLBERG@ FEHLBERGDefinition time_stepping.h:134\\nTimeStepping::CASH_KARP@ CASH_KARPDefinition time_stepping.h:138\\nTimeStepping::RK_THIRD_ORDER@ RK_THIRD_ORDERDefinition time_stepping.h:68\\nTimeStepping::DOPRI@ DOPRIDefinition time_stepping.h:130\\nTimeStepping::BACKWARD_EULER@ BACKWARD_EULERDefinition time_stepping.h:104\\nUtilities::int_to_stringstd::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)Definition utilities.cc:470\\nDataOutBase::VtkFlagsDefinition data_out_base.h:1127\\n Diffusion::explicit_method\\nThis function is the driver for all the explicit methods. At the top it initializes the time stepping and the solution (by setting it to zero and then ensuring that boundary value and hanging node constraints are respected; of course, with the mesh we use here, hanging node constraints are not in fact an issue). It then calls evolve_one_time_step which performs one time step. Time is stored and incremented through a DiscreteTime object.\\nFor explicit methods, evolve_one_time_step needs to evaluate \\\\(M^{-1}(f(t,y))\\\\), i.e, it needs evaluate_diffusion. Because evaluate_diffusion is a member function, it needs to be bound to this. After each evolution step, we again apply the correct boundary values and hanging node constraints.\\nFinally, the solution is output every 10 time steps.\\n\\u00a0   void Diffusion::explicit_method(const TimeStepping::runge_kutta_method method,\\n\\u00a0                                   const unsigned int n_time_steps,\\n\\u00a0                                   const double       initial_time,\\n\\u00a0                                   const double       final_time)\\n\\u00a0   {\\n\\u00a0     const double time_step =\\n\\u00a0       (final_time - initial_time) / static_cast<double>(n_time_steps);\\n\\u00a0 \\n\\u00a0     solution = 0.;\\n\\u00a0     constraint_matrix.distribute(solution);\\n\\u00a0 \\n\\u00a0     TimeStepping::ExplicitRungeKutta<Vector<double>> explicit_runge_kutta(\\n\\u00a0       method);\\n\\u00a0     output_results(initial_time, 0, method);\\n\\u00a0     DiscreteTime time(initial_time, final_time, time_step);\\n\\u00a0     while (time.is_at_end() == false)\\n\\u00a0       {\\n\\u00a0         explicit_runge_kutta.evolve_one_time_step(\\n\\u00a0           [this](const double time, const Vector<double> &y) {\\n\\u00a0             return this->evaluate_diffusion(time, y);\\n\\u00a0           },\\n\\u00a0           time.get_current_time(),\\n\\u00a0           time.get_next_step_size(),\\n\\u00a0           solution);\\n\\u00a0         time.advance_time();\\n\\u00a0 \\n\\u00a0         constraint_matrix.distribute(solution);\\n\\u00a0 \\n\\u00a0         if (time.get_step_number() % 10 == 0)\\n\\u00a0           output_results(time.get_current_time(),\\n\\u00a0                          time.get_step_number(),\\n\\u00a0                          method);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nDiscreteTimeDefinition discrete_time.h:233\\nTimeStepping::ExplicitRungeKuttaDefinition time_stepping.h:307\\n Diffusion::implicit_method\\nThis function is equivalent to explicit_method but for implicit methods. When using implicit methods, we need to evaluate \\\\(M^{-1}(f(t,y))\\\\) and  \\\\(\\\\left(I-\\\\tau M^{-1} \\\\frac{\\\\partial f(t,y)}{\\\\partial\\n   y}\\\\right)^{-1}\\\\) for which we use the two member functions previously introduced.\\n\\u00a0   void Diffusion::implicit_method(const TimeStepping::runge_kutta_method method,\\n\\u00a0                                   const unsigned int n_time_steps,\\n\\u00a0                                   const double       initial_time,\\n\\u00a0                                   const double       final_time)\\n\\u00a0   {\\n\\u00a0     const double time_step =\\n\\u00a0       (final_time - initial_time) / static_cast<double>(n_time_steps);\\n\\u00a0 \\n\\u00a0     solution = 0.;\\n\\u00a0     constraint_matrix.distribute(solution);\\n\\u00a0 \\n\\u00a0     TimeStepping::ImplicitRungeKutta<Vector<double>> implicit_runge_kutta(\\n\\u00a0       method);\\n\\u00a0     output_results(initial_time, 0, method);\\n\\u00a0     DiscreteTime time(initial_time, final_time, time_step);\\n\\u00a0     while (time.is_at_end() == false)\\n\\u00a0       {\\n\\u00a0         implicit_runge_kutta.evolve_one_time_step(\\n\\u00a0           [this](const double time, const Vector<double> &y) {\\n\\u00a0             return this->evaluate_diffusion(time, y);\\n\\u00a0           },\\n\\u00a0           [this](const double time, const double tau, const Vector<double> &y) {\\n\\u00a0             return this->id_minus_tau_J_inverse(time, tau, y);\\n\\u00a0           },\\n\\u00a0           time.get_current_time(),\\n\\u00a0           time.get_next_step_size(),\\n\\u00a0           solution);\\n\\u00a0         time.advance_time();\\n\\u00a0 \\n\\u00a0         constraint_matrix.distribute(solution);\\n\\u00a0 \\n\\u00a0         if (time.get_step_number() % 10 == 0)\\n\\u00a0           output_results(time.get_current_time(),\\n\\u00a0                          time.get_step_number(),\\n\\u00a0                          method);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nTimeStepping::ImplicitRungeKuttaDefinition time_stepping.h:530\\n Diffusion::embedded_explicit_method\\nThis function is the driver for the embedded explicit methods. It requires more parameters:\\ncoarsen_param: factor multiplying the current time step when the error is below the threshold.\\nrefine_param: factor multiplying the current time step when the error is above the threshold.\\nmin_delta: smallest time step acceptable.\\nmax_delta: largest time step acceptable.\\nrefine_tol: threshold above which the time step is refined.\\ncoarsen_tol: threshold below which the time step is coarsen.\\n\\nEmbedded methods use a guessed time step. If the error using this time step is too large, the time step will be reduced. If the error is below the threshold, a larger time step will be tried for the next time step. delta_t_guess is the guessed time step produced by the embedded method. In summary, time step size is potentially modified in three ways:\\nReducing or increasing time step size within TimeStepping::EmbeddedExplicitRungeKutta::evolve_one_time_step().\\nUsing the calculated delta_t_guess.\\nAutomatically adjusting the step size of the last time step to ensure simulation ends precisely at final_time. This adjustment is handled inside the DiscreteTime instance.\\n\\n\\u00a0   unsigned int Diffusion::embedded_explicit_method(\\n\\u00a0     const TimeStepping::runge_kutta_method method,\\n\\u00a0     const unsigned int                     n_time_steps,\\n\\u00a0     const double                           initial_time,\\n\\u00a0     const double                           final_time)\\n\\u00a0   {\\n\\u00a0     const double time_step =\\n\\u00a0       (final_time - initial_time) / static_cast<double>(n_time_steps);\\n\\u00a0     const double coarsen_param = 1.2;\\n\\u00a0     const double refine_param  = 0.8;\\n\\u00a0     const double min_delta     = 1e-8;\\n\\u00a0     const double max_delta     = 10 * time_step;\\n\\u00a0     const double refine_tol    = 1e-1;\\n\\u00a0     const double coarsen_tol   = 1e-5;\\n\\u00a0 \\n\\u00a0     solution = 0.;\\n\\u00a0     constraint_matrix.distribute(solution);\\n\\u00a0 \\n\\u00a0     TimeStepping::EmbeddedExplicitRungeKutta<Vector<double>>\\n\\u00a0       embedded_explicit_runge_kutta(method,\\n\\u00a0                                     coarsen_param,\\n\\u00a0                                     refine_param,\\n\\u00a0                                     min_delta,\\n\\u00a0                                     max_delta,\\n\\u00a0                                     refine_tol,\\n\\u00a0                                     coarsen_tol);\\n\\u00a0     output_results(initial_time, 0, method);\\n\\u00a0     DiscreteTime time(initial_time, final_time, time_step);\\n\\u00a0     while (time.is_at_end() == false)\\n\\u00a0       {\\n\\u00a0         const double new_time =\\n\\u00a0           embedded_explicit_runge_kutta.evolve_one_time_step(\\n\\u00a0             [this](const double time, const Vector<double> &y) {\\n\\u00a0               return this->evaluate_diffusion(time, y);\\n\\u00a0             },\\n\\u00a0             time.get_current_time(),\\n\\u00a0             time.get_next_step_size(),\\n\\u00a0             solution);\\n\\u00a0         time.set_next_step_size(new_time - time.get_current_time());\\n\\u00a0         time.advance_time();\\n\\u00a0 \\n\\u00a0         constraint_matrix.distribute(solution);\\n\\u00a0 \\n\\u00a0         if (time.get_step_number() % 10 == 0)\\n\\u00a0           output_results(time.get_current_time(),\\n\\u00a0                          time.get_step_number(),\\n\\u00a0                          method);\\n\\u00a0 \\n\\u00a0         time.set_desired_next_step_size(\\n\\u00a0           embedded_explicit_runge_kutta.get_status().delta_t_guess);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     return time.get_step_number();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nTimeStepping::EmbeddedExplicitRungeKuttaDefinition time_stepping.h:670\\n Diffusion::run\\nThe following is the main function of the program. At the top, we create the grid (a \\\\([0,5]\\\\times [0,5]\\\\) square) and refine it four times to get a mesh that has 16 by 16 cells, for a total of 256. We then set the boundary indicator to 1 for those parts of the boundary where \\\\(x=0\\\\) and \\\\(x=5\\\\).\\n\\u00a0   void Diffusion::run()\\n\\u00a0   {\\n\\u00a0     GridGenerator::hyper_cube(triangulation, 0., 5.);\\n\\u00a0     triangulation.refine_global(4);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : triangulation.active_cell_iterators())\\n\\u00a0       for (const auto &face : cell->face_iterators())\\n\\u00a0         if (face->at_boundary())\\n\\u00a0           {\\n\\u00a0             if ((face->center()[0] == 0.) || (face->center()[0] == 5.))\\n\\u00a0               face->set_boundary_id(1);\\n\\u00a0             else\\n\\u00a0               face->set_boundary_id(0);\\n\\u00a0           }\\n\\u00a0 \\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\ncenterPoint< 3 > centerDefinition data_out_base.cc:267\\nGridGenerator::hyper_cubevoid hyper_cube(Triangulation< dim, spacedim > &tria, const double left=0., const double right=1., const bool colorize=false)\\nNext, we set up the linear systems and fill them with content so that they can be used throughout the time stepping process:\\n\\u00a0     setup_system();\\n\\u00a0 \\n\\u00a0     assemble_system();\\n\\u00a0 \\nFinally, we solve the diffusion problem using several of the Runge-Kutta methods implemented in namespace TimeStepping, each time outputting the error at the end time. (As explained in the introduction, since the exact solution is zero at the final time, the error equals the numerical solution and can be computed by just taking the \\\\(l_2\\\\) norm of the solution vector.)\\n\\u00a0     unsigned int       n_steps      = 0;\\n\\u00a0     const unsigned int n_time_steps = 200;\\n\\u00a0     const double       initial_time = 0.;\\n\\u00a0     const double       final_time   = 10.;\\n\\u00a0 \\n\\u00a0     std::cout << \\\"Explicit methods:\\\" << std::endl;\\n\\u00a0     explicit_method(TimeStepping::FORWARD_EULER,\\n\\u00a0                     n_time_steps,\\n\\u00a0                     initial_time,\\n\\u00a0                     final_time);\\n\\u00a0     std::cout << \\\"   Forward Euler:            error=\\\" << solution.l2_norm()\\n\\u00a0               << std::endl;\\n\\u00a0 \\n\\u00a0     explicit_method(TimeStepping::RK_THIRD_ORDER,\\n\\u00a0                     n_time_steps,\\n\\u00a0                     initial_time,\\n\\u00a0                     final_time);\\n\\u00a0     std::cout << \\\"   Third order Runge-Kutta:  error=\\\" << solution.l2_norm()\\n\\u00a0               << std::endl;\\n\\u00a0 \\n\\u00a0     explicit_method(TimeStepping::RK_CLASSIC_FOURTH_ORDER,\\n\\u00a0                     n_time_steps,\\n\\u00a0                     initial_time,\\n\\u00a0                     final_time);\\n\\u00a0     std::cout << \\\"   Fourth order Runge-Kutta: error=\\\" << solution.l2_norm()\\n\\u00a0               << std::endl;\\n\\u00a0     std::cout << std::endl;\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     std::cout << \\\"Implicit methods:\\\" << std::endl;\\n\\u00a0     implicit_method(TimeStepping::BACKWARD_EULER,\\n\\u00a0                     n_time_steps,\\n\\u00a0                     initial_time,\\n\\u00a0                     final_time);\\n\\u00a0     std::cout << \\\"   Backward Euler:           error=\\\" << solution.l2_norm()\\n\\u00a0               << std::endl;\\n\\u00a0 \\n\\u00a0     implicit_method(TimeStepping::IMPLICIT_MIDPOINT,\\n\\u00a0                     n_time_steps,\\n\\u00a0                     initial_time,\\n\\u00a0                     final_time);\\n\\u00a0     std::cout << \\\"   Implicit Midpoint:        error=\\\" << solution.l2_norm()\\n\\u00a0               << std::endl;\\n\\u00a0 \\n\\u00a0     implicit_method(TimeStepping::CRANK_NICOLSON,\\n\\u00a0                     n_time_steps,\\n\\u00a0                     initial_time,\\n\\u00a0                     final_time);\\n\\u00a0     std::cout << \\\"   Crank-Nicolson:           error=\\\" << solution.l2_norm()\\n\\u00a0               << std::endl;\\n\\u00a0 \\n\\u00a0     implicit_method(TimeStepping::SDIRK_TWO_STAGES,\\n\\u00a0                     n_time_steps,\\n\\u00a0                     initial_time,\\n\\u00a0                     final_time);\\n\\u00a0     std::cout << \\\"   SDIRK:                    error=\\\" << solution.l2_norm()\\n\\u00a0               << std::endl;\\n\\u00a0     std::cout << std::endl;\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     std::cout << \\\"Embedded explicit methods:\\\" << std::endl;\\n\\u00a0     n_steps = embedded_explicit_method(TimeStepping::HEUN_EULER,\\n\\u00a0                                        n_time_steps,\\n\\u00a0                                        initial_time,\\n\\u00a0                                        final_time);\\n\\u00a0     std::cout << \\\"   Heun-Euler:               error=\\\" << solution.l2_norm()\\n\\u00a0               << std::endl;\\n\\u00a0     std::cout << \\\"                   steps performed=\\\" << n_steps << std::endl;\\n\\u00a0 \\n\\u00a0     n_steps = embedded_explicit_method(TimeStepping::BOGACKI_SHAMPINE,\\n\\u00a0                                        n_time_steps,\\n\\u00a0                                        initial_time,\\n\\u00a0                                        final_time);\\n\\u00a0     std::cout << \\\"   Bogacki-Shampine:         error=\\\" << solution.l2_norm()\\n\\u00a0               << std::endl;\\n\\u00a0     std::cout << \\\"                   steps performed=\\\" << n_steps << std::endl;\\n\\u00a0 \\n\\u00a0     n_steps = embedded_explicit_method(TimeStepping::DOPRI,\\n\\u00a0                                        n_time_steps,\\n\\u00a0                                        initial_time,\\n\\u00a0                                        final_time);\\n\\u00a0     std::cout << \\\"   Dopri:                    error=\\\" << solution.l2_norm()\\n\\u00a0               << std::endl;\\n\\u00a0     std::cout << \\\"                   steps performed=\\\" << n_steps << std::endl;\\n\\u00a0 \\n\\u00a0     n_steps = embedded_explicit_method(TimeStepping::FEHLBERG,\\n\\u00a0                                        n_time_steps,\\n\\u00a0                                        initial_time,\\n\\u00a0                                        final_time);\\n\\u00a0     std::cout << \\\"   Fehlberg:                 error=\\\" << solution.l2_norm()\\n\\u00a0               << std::endl;\\n\\u00a0     std::cout << \\\"                   steps performed=\\\" << n_steps << std::endl;\\n\\u00a0 \\n\\u00a0     n_steps = embedded_explicit_method(TimeStepping::CASH_KARP,\\n\\u00a0                                        n_time_steps,\\n\\u00a0                                        initial_time,\\n\\u00a0                                        final_time);\\n\\u00a0     std::cout << \\\"   Cash-Karp:                error=\\\" << solution.l2_norm()\\n\\u00a0               << std::endl;\\n\\u00a0     std::cout << \\\"                   steps performed=\\\" << n_steps << std::endl;\\n\\u00a0   }\\n\\u00a0 } // namespace Step52\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nTimeStepping::CRANK_NICOLSON@ CRANK_NICOLSONDefinition time_stepping.h:112\\n The main() function\\nThe following main function is similar to previous examples and need not be commented on.\\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       Step52::Diffusion diffusion;\\n\\u00a0       diffusion.run();\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nThe point of this program is less to show particular results, but instead to show how it is done. This we have already demonstrated simply by discussing the code above. Consequently, the output the program yields is relatively sparse and consists only of the console output and the solutions given in VTU format for visualization.\\nThe console output contains both errors and, for some of the methods, the number of steps they performed: Explicit methods:\\n   Forward Euler:            error=1.00883\\n   Third order Runge-Kutta:  error=0.000227982\\n   Fourth order Runge-Kutta: error=1.90541e-06\\n \\nImplicit methods:\\n   Backward Euler:           error=1.03428\\n   Implicit Midpoint:        error=0.00862702\\n   Crank-Nicolson:           error=0.00862675\\n   SDIRK:                    error=0.0042349\\n \\nEmbedded explicit methods:\\n   Heun-Euler:               error=0.0073012\\n                   steps performed=284\\n   Bogacki-Shampine:         error=0.000408407\\n                   steps performed=181\\n   Dopri:                    error=0.000836695\\n                   steps performed=120\\n   Fehlberg:                 error=0.00248922\\n                   steps performed=106\\n   Cash-Karp:                error=0.0787735\\n                   steps performed=106\\nAs expected the higher order methods give (much) more accurate solutions. We also see that the (rather inaccurate) Heun-Euler method increased the number of time steps in order to satisfy the tolerance. On the other hand, the other embedded methods used a lot less time steps than what was prescribed.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2014 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Authors: Damien Lebrun-Grandie, Bruno Turcksin, 2014\\n */\\n \\n \\n#include <deal.II/base/discrete_time.h>\\n#include <deal.II/base/function.h>\\n#include <deal.II/base/quadrature_lib.h>\\n \\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_out.h>\\n \\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_values.h>\\n \\n#include <deal.II/lac/affine_constraints.h>\\n#include <deal.II/lac/sparse_direct.h>\\n \\n#include <deal.II/numerics/vector_tools.h>\\n#include <deal.II/numerics/data_out.h>\\n \\n#include <fstream>\\n#include <iostream>\\n#include <cmath>\\n#include <map>\\n \\n#include <deal.II/base/time_stepping.h>\\n \\n \\nnamespace Step52\\n{\\n using namespace dealii;\\n \\n \\n class Diffusion\\n  {\\n public:\\n    Diffusion();\\n \\n void run();\\n \\n private:\\n void setup_system();\\n \\n void assemble_system();\\n \\n double get_source(const double time, const Point<2> &point) const;\\n \\n Vector<double> evaluate_diffusion(const double          time,\\n const Vector<double> &y) const;\\n \\n Vector<double> id_minus_tau_J_inverse(const double          time,\\n const double          tau,\\n const Vector<double> &y);\\n \\n void output_results(const double                     time,\\n const unsigned int               time_step,\\n TimeStepping::runge_kutta_method method) const;\\n \\n void explicit_method(const TimeStepping::runge_kutta_method method,\\n const unsigned int                     n_time_steps,\\n const double                           initial_time,\\n const double                           final_time);\\n \\n void implicit_method(const TimeStepping::runge_kutta_method method,\\n const unsigned int                     n_time_steps,\\n const double                           initial_time,\\n const double                           final_time);\\n \\n unsigned int\\n    embedded_explicit_method(const TimeStepping::runge_kutta_method method,\\n const unsigned int n_time_steps,\\n const double       initial_time,\\n const double       final_time);\\n \\n \\n const unsigned int fe_degree;\\n \\n const double diffusion_coefficient;\\n const double absorption_cross_section;\\n \\n Triangulation<2> triangulation;\\n \\n const FE_Q<2> fe;\\n \\n DoFHandler<2> dof_handler;\\n \\n AffineConstraints<double> constraint_matrix;\\n \\n SparsityPattern sparsity_pattern;\\n \\n SparseMatrix<double> system_matrix;\\n SparseMatrix<double> mass_matrix;\\n SparseMatrix<double> mass_minus_tau_Jacobian;\\n \\n SparseDirectUMFPACK inverse_mass_matrix;\\n \\n Vector<double> solution;\\n  };\\n \\n \\n \\n  Diffusion::Diffusion()\\n    : fe_degree(2)\\n    , diffusion_coefficient(1. / 30.)\\n    , absorption_cross_section(1.)\\n    , fe(fe_degree)\\n    , dof_handler(triangulation)\\n  {}\\n \\n \\n \\n void Diffusion::setup_system()\\n  {\\n    dof_handler.distribute_dofs(fe);\\n \\n VectorTools::interpolate_boundary_values(dof_handler,\\n                                             1,\\n Functions::ZeroFunction<2>(),\\n                                             constraint_matrix);\\n    constraint_matrix.close();\\n \\n DynamicSparsityPattern dsp(dof_handler.n_dofs());\\n DoFTools::make_sparsity_pattern(dof_handler, dsp, constraint_matrix);\\n    sparsity_pattern.copy_from(dsp);\\n \\n    system_matrix.reinit(sparsity_pattern);\\n mass_matrix.reinit(sparsity_pattern);\\n    mass_minus_tau_Jacobian.reinit(sparsity_pattern);\\n    solution.reinit(dof_handler.n_dofs());\\n  }\\n \\n \\n \\n void Diffusion::assemble_system()\\n  {\\n    system_matrix = 0.;\\n mass_matrix   = 0.;\\n \\n const QGauss<2> quadrature_formula(fe_degree + 1);\\n \\n FEValues<2> fe_values(fe,\\n                          quadrature_formula,\\n update_values | update_gradients | update_JxW_values);\\n \\n \\n const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n const unsigned int n_q_points    = quadrature_formula.size();\\n \\n FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n FullMatrix<double> cell_mass_matrix(dofs_per_cell, dofs_per_cell);\\n \\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n cell_matrix      = 0.;\\n        cell_mass_matrix = 0.;\\n \\n        fe_values.reinit(cell);\\n \\n for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n              {\\n cell_matrix(i, j) +=\\n                  ((-diffusion_coefficient *                // (-D\\n                      fe_values.shape_grad(i, q_point) *    //  * grad phi_i\\n                      fe_values.shape_grad(j, q_point)      //  * grad phi_j\\n                    - absorption_cross_section *            //  -Sigma\\n                        fe_values.shape_value(i, q_point) * //  * phi_i\\n                        fe_values.shape_value(j, q_point))  //  * phi_j)\\n                   * fe_values.JxW(q_point));               // * dx\\n                cell_mass_matrix(i, j) += fe_values.shape_value(i, q_point) *\\n                                          fe_values.shape_value(j, q_point) *\\n                                          fe_values.JxW(q_point);\\n              }\\n \\n        cell->get_dof_indices(local_dof_indices);\\n \\n        constraint_matrix.distribute_local_to_global(cell_matrix,\\n                                                     local_dof_indices,\\n                                                     system_matrix);\\n        constraint_matrix.distribute_local_to_global(cell_mass_matrix,\\n                                                     local_dof_indices,\\n                                                     mass_matrix);\\n      }\\n \\n    inverse_mass_matrix.initialize(mass_matrix);\\n  }\\n \\n \\n \\n double Diffusion::get_source(const double time, const Point<2> &point) const\\n {\\n const double intensity = 10.;\\n const double frequency = numbers::PI / 10.;\\n const double b         = 5.;\\n const double x         = point[0];\\n \\n return intensity *\\n           (frequency * std::cos(frequency * time) * (b * x - x * x) +\\n std::sin(frequency * time) *\\n              (absorption_cross_section * (b * x - x * x) +\\n               2. * diffusion_coefficient));\\n  }\\n \\n \\n \\n Vector<double> Diffusion::evaluate_diffusion(const double          time,\\n const Vector<double> &y) const\\n {\\n Vector<double> tmp(dof_handler.n_dofs());\\n    tmp = 0.;\\n    system_matrix.vmult(tmp, y);\\n \\n const QGauss<2> quadrature_formula(fe_degree + 1);\\n \\n FEValues<2> fe_values(fe,\\n                          quadrature_formula,\\n update_values | update_quadrature_points |\\n update_JxW_values);\\n \\n \\n const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n const unsigned int n_q_points    = quadrature_formula.size();\\n \\n Vector<double> cell_source(dofs_per_cell);\\n \\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n        cell_source = 0.;\\n \\n        fe_values.reinit(cell);\\n \\n for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n          {\\n const double source =\\n              get_source(time, fe_values.quadrature_point(q_point));\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n              cell_source(i) += fe_values.shape_value(i, q_point) * // phi_i(x)\\n                                source *                            // * S(x)\\n                                fe_values.JxW(q_point);             // * dx\\n          }\\n \\n        cell->get_dof_indices(local_dof_indices);\\n \\n        constraint_matrix.distribute_local_to_global(cell_source,\\n                                                     local_dof_indices,\\n                                                     tmp);\\n      }\\n \\n Vector<double> value(dof_handler.n_dofs());\\n    inverse_mass_matrix.vmult(value, tmp);\\n \\n return value;\\n  }\\n \\n \\n Vector<double> Diffusion::id_minus_tau_J_inverse(const double /*time*/,\\n const double          tau,\\n const Vector<double> &y)\\n  {\\n SparseDirectUMFPACK inverse_mass_minus_tau_Jacobian;\\n \\n    mass_minus_tau_Jacobian.copy_from(mass_matrix);\\n    mass_minus_tau_Jacobian.add(-tau, system_matrix);\\n \\n    inverse_mass_minus_tau_Jacobian.initialize(mass_minus_tau_Jacobian);\\n \\n Vector<double> tmp(dof_handler.n_dofs());\\n mass_matrix.vmult(tmp, y);\\n \\n Vector<double> result(y);\\n    inverse_mass_minus_tau_Jacobian.vmult(result, tmp);\\n \\n return result;\\n  }\\n \\n \\n \\n void Diffusion::output_results(const double                     time,\\n const unsigned int               time_step,\\n TimeStepping::runge_kutta_method method) const\\n {\\n    std::string method_name;\\n \\n switch (method)\\n      {\\n case TimeStepping::FORWARD_EULER:\\n          {\\n            method_name = \\\"forward_euler\\\";\\n break;\\n          }\\n case TimeStepping::RK_THIRD_ORDER:\\n          {\\n            method_name = \\\"rk3\\\";\\n break;\\n          }\\n case TimeStepping::RK_CLASSIC_FOURTH_ORDER:\\n          {\\n            method_name = \\\"rk4\\\";\\n break;\\n          }\\n case TimeStepping::BACKWARD_EULER:\\n          {\\n            method_name = \\\"backward_euler\\\";\\n break;\\n          }\\n case TimeStepping::IMPLICIT_MIDPOINT:\\n          {\\n            method_name = \\\"implicit_midpoint\\\";\\n break;\\n          }\\n case TimeStepping::SDIRK_TWO_STAGES:\\n          {\\n            method_name = \\\"sdirk\\\";\\n break;\\n          }\\n case TimeStepping::HEUN_EULER:\\n          {\\n            method_name = \\\"heun_euler\\\";\\n break;\\n          }\\n case TimeStepping::BOGACKI_SHAMPINE:\\n          {\\n            method_name = \\\"bogacki_shampine\\\";\\n break;\\n          }\\n case TimeStepping::DOPRI:\\n          {\\n            method_name = \\\"dopri\\\";\\n break;\\n          }\\n case TimeStepping::FEHLBERG:\\n          {\\n            method_name = \\\"fehlberg\\\";\\n break;\\n          }\\n case TimeStepping::CASH_KARP:\\n          {\\n            method_name = \\\"cash_karp\\\";\\n break;\\n          }\\n default:\\n          {\\n break;\\n          }\\n      }\\n \\n DataOut<2> data_out;\\n \\n    data_out.attach_dof_handler(dof_handler);\\n    data_out.add_data_vector(solution, \\\"solution\\\");\\n \\n    data_out.build_patches();\\n \\n    data_out.set_flags(DataOutBase::VtkFlags(time, time_step));\\n \\n const std::string filename = \\\"solution_\\\" + method_name + \\\"-\\\" +\\n Utilities::int_to_string(time_step, 3) +\\n \\\".vtu\\\";\\n    std::ofstream output(filename);\\n    data_out.write_vtu(output);\\n \\n static std::vector<std::pair<double, std::string>> times_and_names;\\n \\n static std::string method_name_prev = \\\"\\\";\\n static std::string pvd_filename;\\n if (method_name_prev != method_name)\\n      {\\n        times_and_names.clear();\\n        method_name_prev = method_name;\\n        pvd_filename     = \\\"solution_\\\" + method_name + \\\".pvd\\\";\\n      }\\n    times_and_names.emplace_back(time, filename);\\n    std::ofstream pvd_output(pvd_filename);\\n DataOutBase::write_pvd_record(pvd_output, times_and_names);\\n  }\\n \\n \\n void Diffusion::explicit_method(const TimeStepping::runge_kutta_method method,\\n const unsigned int n_time_steps,\\n const double       initial_time,\\n const double       final_time)\\n  {\\n const double time_step =\\n      (final_time - initial_time) / static_cast<double>(n_time_steps);\\n \\n    solution = 0.;\\n    constraint_matrix.distribute(solution);\\n \\n TimeStepping::ExplicitRungeKutta<Vector<double>> explicit_runge_kutta(\\n      method);\\n    output_results(initial_time, 0, method);\\n DiscreteTime time(initial_time, final_time, time_step);\\n while (time.is_at_end() == false)\\n      {\\n        explicit_runge_kutta.evolve_one_time_step(\\n          [this](const double time, const Vector<double> &y) {\\n return this->evaluate_diffusion(time, y);\\n          },\\n          time.get_current_time(),\\n          time.get_next_step_size(),\\n          solution);\\n        time.advance_time();\\n \\n        constraint_matrix.distribute(solution);\\n \\n if (time.get_step_number() % 10 == 0)\\n          output_results(time.get_current_time(),\\n                         time.get_step_number(),\\n                         method);\\n      }\\n  }\\n \\n \\n \\n void Diffusion::implicit_method(const TimeStepping::runge_kutta_method method,\\n const unsigned int n_time_steps,\\n const double       initial_time,\\n const double       final_time)\\n  {\\n const double time_step =\\n      (final_time - initial_time) / static_cast<double>(n_time_steps);\\n \\n    solution = 0.;\\n    constraint_matrix.distribute(solution);\\n \\n TimeStepping::ImplicitRungeKutta<Vector<double>> implicit_runge_kutta(\\n      method);\\n    output_results(initial_time, 0, method);\\n DiscreteTime time(initial_time, final_time, time_step);\\n while (time.is_at_end() == false)\\n      {\\n        implicit_runge_kutta.evolve_one_time_step(\\n          [this](const double time, const Vector<double> &y) {\\n return this->evaluate_diffusion(time, y);\\n          },\\n          [this](const double time, const double tau, const Vector<double> &y) {\\n return this->id_minus_tau_J_inverse(time, tau, y);\\n          },\\n          time.get_current_time(),\\n          time.get_next_step_size(),\\n          solution);\\n        time.advance_time();\\n \\n        constraint_matrix.distribute(solution);\\n \\n if (time.get_step_number() % 10 == 0)\\n          output_results(time.get_current_time(),\\n                         time.get_step_number(),\\n                         method);\\n      }\\n  }\\n \\n \\n \\n unsigned int Diffusion::embedded_explicit_method(\\n const TimeStepping::runge_kutta_method method,\\n const unsigned int                     n_time_steps,\\n const double                           initial_time,\\n const double                           final_time)\\n  {\\n const double time_step =\\n      (final_time - initial_time) / static_cast<double>(n_time_steps);\\n const double coarsen_param = 1.2;\\n const double refine_param  = 0.8;\\n const double min_delta     = 1e-8;\\n const double max_delta     = 10 * time_step;\\n const double refine_tol    = 1e-1;\\n const double coarsen_tol   = 1e-5;\\n \\n    solution = 0.;\\n    constraint_matrix.distribute(solution);\\n \\n TimeStepping::EmbeddedExplicitRungeKutta<Vector<double>>\\n      embedded_explicit_runge_kutta(method,\\n                                    coarsen_param,\\n                                    refine_param,\\n                                    min_delta,\\n                                    max_delta,\\n                                    refine_tol,\\n                                    coarsen_tol);\\n    output_results(initial_time, 0, method);\\n DiscreteTime time(initial_time, final_time, time_step);\\n while (time.is_at_end() == false)\\n      {\\n const double new_time =\\n          embedded_explicit_runge_kutta.evolve_one_time_step(\\n            [this](const double time, const Vector<double> &y) {\\n return this->evaluate_diffusion(time, y);\\n            },\\n            time.get_current_time(),\\n            time.get_next_step_size(),\\n            solution);\\n        time.set_next_step_size(new_time - time.get_current_time());\\n        time.advance_time();\\n \\n        constraint_matrix.distribute(solution);\\n \\n if (time.get_step_number() % 10 == 0)\\n          output_results(time.get_current_time(),\\n                         time.get_step_number(),\\n                         method);\\n \\n        time.set_desired_next_step_size(\\n          embedded_explicit_runge_kutta.get_status().delta_t_guess);\\n      }\\n \\n return time.get_step_number();\\n  }\\n \\n \\n \\n void Diffusion::run()\\n  {\\n GridGenerator::hyper_cube(triangulation, 0., 5.);\\n triangulation.refine_global(4);\\n \\n for (const auto &cell : triangulation.active_cell_iterators())\\n      for (const auto &face : cell->face_iterators())\\n        if (face->at_boundary())\\n          {\\n if ((face->center()[0] == 0.) || (face->center()[0] == 5.))\\n              face->set_boundary_id(1);\\n else\\n              face->set_boundary_id(0);\\n          }\\n \\n    setup_system();\\n \\n    assemble_system();\\n \\n unsigned int       n_steps      = 0;\\n const unsigned int n_time_steps = 200;\\n const double       initial_time = 0.;\\n const double       final_time   = 10.;\\n \\n    std::cout << \\\"Explicit methods:\\\" << std::endl;\\n    explicit_method(TimeStepping::FORWARD_EULER,\\n                    n_time_steps,\\n                    initial_time,\\n                    final_time);\\n    std::cout << \\\"   Forward Euler:            error=\\\" << solution.l2_norm()\\n              << std::endl;\\n \\n    explicit_method(TimeStepping::RK_THIRD_ORDER,\\n                    n_time_steps,\\n                    initial_time,\\n                    final_time);\\n    std::cout << \\\"   Third order Runge-Kutta:  error=\\\" << solution.l2_norm()\\n              << std::endl;\\n \\n    explicit_method(TimeStepping::RK_CLASSIC_FOURTH_ORDER,\\n                    n_time_steps,\\n                    initial_time,\\n                    final_time);\\n    std::cout << \\\"   Fourth order Runge-Kutta: error=\\\" << solution.l2_norm()\\n              << std::endl;\\n    std::cout << std::endl;\\n \\n \\n    std::cout << \\\"Implicit methods:\\\" << std::endl;\\n    implicit_method(TimeStepping::BACKWARD_EULER,\\n                    n_time_steps,\\n                    initial_time,\\n                    final_time);\\n    std::cout << \\\"   Backward Euler:           error=\\\" << solution.l2_norm()\\n              << std::endl;\\n \\n    implicit_method(TimeStepping::IMPLICIT_MIDPOINT,\\n                    n_time_steps,\\n                    initial_time,\\n                    final_time);\\n    std::cout << \\\"   Implicit Midpoint:        error=\\\" << solution.l2_norm()\\n              << std::endl;\\n \\n    implicit_method(TimeStepping::CRANK_NICOLSON,\\n                    n_time_steps,\\n                    initial_time,\\n                    final_time);\\n    std::cout << \\\"   Crank-Nicolson:           error=\\\" << solution.l2_norm()\\n              << std::endl;\\n \\n    implicit_method(TimeStepping::SDIRK_TWO_STAGES,\\n                    n_time_steps,\\n                    initial_time,\\n                    final_time);\\n    std::cout << \\\"   SDIRK:                    error=\\\" << solution.l2_norm()\\n              << std::endl;\\n    std::cout << std::endl;\\n \\n \\n    std::cout << \\\"Embedded explicit methods:\\\" << std::endl;\\n    n_steps = embedded_explicit_method(TimeStepping::HEUN_EULER,\\n                                       n_time_steps,\\n                                       initial_time,\\n                                       final_time);\\n    std::cout << \\\"   Heun-Euler:               error=\\\" << solution.l2_norm()\\n              << std::endl;\\n    std::cout << \\\"                   steps performed=\\\" << n_steps << std::endl;\\n \\n    n_steps = embedded_explicit_method(TimeStepping::BOGACKI_SHAMPINE,\\n                                       n_time_steps,\\n                                       initial_time,\\n                                       final_time);\\n    std::cout << \\\"   Bogacki-Shampine:         error=\\\" << solution.l2_norm()\\n              << std::endl;\\n    std::cout << \\\"                   steps performed=\\\" << n_steps << std::endl;\\n \\n    n_steps = embedded_explicit_method(TimeStepping::DOPRI,\\n                                       n_time_steps,\\n                                       initial_time,\\n                                       final_time);\\n    std::cout << \\\"   Dopri:                    error=\\\" << solution.l2_norm()\\n              << std::endl;\\n    std::cout << \\\"                   steps performed=\\\" << n_steps << std::endl;\\n \\n    n_steps = embedded_explicit_method(TimeStepping::FEHLBERG,\\n                                       n_time_steps,\\n                                       initial_time,\\n                                       final_time);\\n    std::cout << \\\"   Fehlberg:                 error=\\\" << solution.l2_norm()\\n              << std::endl;\\n    std::cout << \\\"                   steps performed=\\\" << n_steps << std::endl;\\n \\n    n_steps = embedded_explicit_method(TimeStepping::CASH_KARP,\\n                                       n_time_steps,\\n                                       initial_time,\\n                                       final_time);\\n    std::cout << \\\"   Cash-Karp:                error=\\\" << solution.l2_norm()\\n              << std::endl;\\n    std::cout << \\\"                   steps performed=\\\" << n_steps << std::endl;\\n  }\\n} // namespace Step52\\n \\n \\n \\nint main()\\n{\\n try\\n    {\\n      Step52::Diffusion diffusion;\\n      diffusion.run();\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    };\\n \\n return 0;\\n}\\naffine_constraints.h\\nDataOutInterface::write_vtuvoid write_vtu(std::ostream &out) constDefinition data_out_base.cc:7692\\nDataOutInterface::set_flagsvoid set_flags(const FlagType &flags)Definition data_out_base.cc:8863\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nSparseDirectUMFPACK::vmultvoid vmult(Vector< double > &dst, const Vector< double > &src) constDefinition sparse_direct.cc:795\\ndiscrete_time.h\\ndof_handler.h\\ndof_tools.h\\nfe_values.h\\nfe_q.h\\nfunction.h\\ntria.h\\ngrid_generator.h\\ngrid_out.h\\nAlgorithms::Events::new_timeconst Event new_timeDefinition event.cc:67\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\nLocalIntegrators::L2::mass_matrixvoid mass_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const double factor=1.)Definition l2.h:57\\nOpenCASCADE::pointPoint< spacedim > point(const gp_Pnt &p, const double tolerance=1e-10)Definition utilities.cc:191\\nPhysics::Elasticity::Kinematics::eSymmetricTensor< 2, dim, Number > e(const Tensor< 2, dim, Number > &F)\\nPhysics::Elasticity::Kinematics::bSymmetricTensor< 2, dim, Number > b(const Tensor< 2, dim, Number > &F)\\ndata_out.h\\nquadrature_lib.h\\nsparse_direct.h\\ntime_stepping.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"