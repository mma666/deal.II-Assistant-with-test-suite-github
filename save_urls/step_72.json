"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_72.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-72 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-72 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-72 tutorial program\\n\\n\\nThis tutorial depends on step-71, step-15.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nMotivation\\n Computing the Jacobian from the residual \\n Computing the Jacobian and the residual from the energy functional \\n\\n The commented program\\n\\nInclude files\\nThe MinimalSurfaceProblemParameters class\\nThe MinimalSurfaceProblem class template\\nBoundary condition\\nThe MinimalSurfaceProblem class implementation\\n\\nMinimalSurfaceProblem::MinimalSurfaceProblem\\nMinimalSurfaceProblem::setup_system\\nAssembling the linear system\\n\\nManual assembly\\nAssembly via differentiation of the residual vector\\nAssembly via differentiation of the energy functional\\n\\nMinimalSurfaceProblem::solve\\nMinimalSurfaceProblem::refine_mesh\\nMinimalSurfaceProblem::compute_residual\\nMinimalSurfaceProblem::determine_step_length\\nMinimalSurfaceProblem::output_results\\nMinimalSurfaceProblem::run\\nThe main function\\n\\n\\n\\n Results\\n\\n Possibilities for extensions \\n\\n The plain program\\n   \\n\\n\\nThis program was contributed by Jean-Paul Pelteret and Wolfgang Bangerth.\\nWolfgang Bangerth's work is partially supported by National Science Foundation grants OCI-1148116, OAC-1835673, DMS-1821210, and EAR-1925595; and by the Computational Infrastructure in Geodynamics initiative (CIG), through the National Science Foundation under Award No. EAR-1550901 and The University of California-Davis. \\nIntroduction\\nMotivation\\nThis program solves the same problem as step-15, that is, it solves for the minimal surface equation \\n\\\\begin{align*}\\n    F(u) \\\\dealcoloneq -\\\\nabla \\\\cdot \\\\left( \\\\frac{1}{\\\\sqrt{1+|\\\\nabla u|^{2}}}\\\\nabla u \\\\right) &= 0 \\\\qquad\\n    \\\\qquad &&\\\\textrm{in} ~ \\\\Omega\\n    \\\\\\\\\\n    u&=g \\\\qquad\\\\qquad &&\\\\textrm{on} ~ \\\\partial \\\\Omega.\\n  \\\\end{align*}\\n\\nAmong the issues we had identified there (see the Possibilities for extensions section) was that when wanting to use a Newton iteration, we needed to compute the derivative of the residual of the equation with regard to the solution \\\\(u\\\\) (here, because the right hand side is zero, the residual is simply the left hand side). For the equation we have here, this is cumbersome but not impossible \\u2013 but one can easily imagine much more complicated equations where just implementing the residual itself correctly is a challenge, let alone doing so for the derivative necessary to compute the Jacobian matrix. We will address this issue in this program: Using the automatic differentiation techniques discussed in great detail in step-71, we will come up with a way how we only have to implement the residual and get the Jacobian for free.\\nIn fact, we can even go one step further. While in step-15 we have just taken the equation as a given, the minimal surface equation is actually the product of minimizing an energy. Specifically, the minimal surface equations are the Euler-Lagrange equations that correspond to minimizing the energy   \\n\\\\[\\n    E(u) = \\\\int_\\\\Omega \\\\Psi \\\\left( u \\\\right)\\n  \\\\]\\n\\n where the energy density is given by   \\n\\\\[\\n    \\\\Psi \\\\left( u \\\\right) = \\\\sqrt{1+|\\\\nabla u|^{2}}.\\n  \\\\]\\n\\n This is the same as saying that we seek to find the stationary point of the variation of the energy functional        \\n\\\\[\\n    \\\\min\\\\limits_{u} E \\\\left( u \\\\right)\\n      \\\\quad \\\\rightarrow \\\\quad\\n      \\\\delta E \\\\left( u, \\\\varphi \\\\right) \\\\dealcoloneq\\n      \\\\left(\\\\varphi, F(u)\\\\right) = 0\\n      \\\\qquad\\n      \\\\forall \\\\varphi,\\n  \\\\]\\n\\n as this is where the equilibrium solution to the boundary value problem lies.\\nThe key point then is that, maybe, we don't even need to implement the residual, but that implementing the simpler energy density \\\\(\\\\Psi(u)\\\\) might actually be enough.\\nOur goal then is this: When using a Newton iteration, we need to repeatedly solve the linear partial differential equation   \\n\\\\begin{align*}\\n    F'(u^{n},\\\\delta u^{n}) &=- F(u^{n})\\n  \\\\end{align*}\\n\\n so that we can compute the update   \\n\\\\begin{align*}\\n    u^{n+1}&=u^{n}+\\\\alpha^n \\\\delta u^{n}\\n  \\\\end{align*}\\n\\n with the solution \\\\(\\\\delta u^{n}\\\\) of the Newton step. As discussed in step-15, we can compute the derivative \\\\(F'(u,\\\\delta u)\\\\) by hand and obtain         \\n\\\\[\\n  F'(u,\\\\delta u)\\n  =\\n  - \\\\nabla \\\\cdot \\\\left( \\\\frac{1}{\\\\left(1+|\\\\nabla u|^{2}\\\\right)^{\\\\frac{1}{2}}}\\\\nabla\\n  \\\\delta u \\\\right) +\\n  \\\\nabla \\\\cdot \\\\left( \\\\frac{\\\\nabla u \\\\cdot\\n  \\\\nabla \\\\delta u}{\\\\left(1+|\\\\nabla u|^{2}\\\\right)^{\\\\frac{3}{2}}} \\\\nabla u\\n  \\\\right).\\n  \\\\]\\n\\nSo here then is what this program is about: It is about techniques that can help us with computing \\\\(F'(u,\\\\delta u)\\\\) without having to implement it explicitly, either by providing an implementation of \\\\(F(u)\\\\) or an implementation of \\\\(E(u)\\\\). More precisely, we will implement three different approaches and compare them in terms of run-time but also \\u2013 maybe more importantly \\u2013 how much human effort it takes to implement them:\\nThe method used in step-15 to form the Jacobian matrix.\\nComputing the Jacobian matrix from an implementation of the residual \\\\(F(u)\\\\), using automatic differentiation.\\nComputing both the residual and Jacobian matrix from an implementation of the energy functional \\\\(E(u)\\\\), also using automatic differentiation.\\n\\nFor the first of these methods, there are no conceptual changes compared to step-15.\\nComputing the Jacobian from the residual \\nFor the second method, let us outline how we will approach the issue using automatic differentiation to compute the linearization of the residual vector. To this end, let us change notation for a moment and denote by \\\\(F(U)\\\\) not the residual of the differential equation, but in fact the residual vector \\u2013 i.e., the discrete residual. We do so because that is what we actually do when we discretize the problem on a given mesh: We solve the problem \\\\(F(U)=0\\\\) where \\\\(U\\\\) is the vector of unknowns.\\nMore precisely, the \\\\(i\\\\)th component of the residual is given by     \\n\\\\[\\n  F(U)_i \\\\dealcoloneq\\n  \\\\int\\\\limits_{\\\\Omega}\\\\nabla \\\\varphi_i \\\\cdot \\\\left[ \\\\frac{1}{\\\\sqrt{1+|\\\\nabla\\n  u|^{2}}} \\\\nabla u \\\\right] \\\\, dV ,\\n\\\\]\\n\\n where \\\\(u(\\\\mathbf x)=\\\\sum_j U_j \\\\varphi_j(\\\\mathbf x)\\\\). Given this, the contribution for cell \\\\(K\\\\) is     \\n\\\\[\\n  F(U)_i^K \\\\dealcoloneq\\n  \\\\int\\\\limits_K\\\\nabla \\\\varphi_i \\\\cdot \\\\left[ \\\\frac{1}{\\\\sqrt{1+|\\\\nabla\\n  u|^{2}}} \\\\nabla u \\\\right] \\\\, dV ,\\n\\\\]\\n\\n Its first order Taylor expansion is given as      \\n\\\\[\\n  F(U + \\\\delta U)_i^K\\n  \\\\approx F(U)_i^K\\n  + \\\\sum_{j}^{n_{\\\\textrm{dofs}}} \\\\left[ \\\\frac{\\\\partial F(U)_i^K}{\\\\partial\\n  U_j} \\\\delta U_j \\\\right],\\n\\\\]\\n\\n and consequently we can compute the contribution of cell \\\\(K\\\\) to the Jacobian matrix \\\\(J\\\\) as \\\\(J(U)_{ij}^K = \\\\frac{\\\\partial F(U)_i^K}{\\\\partial U_j}\\\\). The important point here is that on cell \\\\(K\\\\), we can express      \\n\\\\[\\n  F(U)_i^K \\\\dealcoloneq\\n  \\\\int\\\\limits_K\\\\nabla \\\\varphi_i \\\\cdot \\\\left[ \\\\frac{1}{\\\\sqrt{1+\\\\left|\\n  \\\\sum_{j'}^{n_\\\\textrm{dofs}} U_{j'} \\\\nabla \\\\varphi_{j'}\\\\right|^{2}}}\\n  \\\\left(\\\\sum_{j''}^{n_\\\\textrm{dofs}} U_{j''} \\\\nabla \\\\varphi_{j''}\\\\right)\\\\right] \\\\, dV.\\n\\\\]\\n\\n For clarity, we have used \\\\(j'\\\\) and \\\\(j''\\\\) as counting indices to make clear that they are distinct from each other and from \\\\(j\\\\) above. Because in this formula, \\\\(F(U)\\\\) only depends on the coefficients \\\\(U_j\\\\), we can compute the derivative \\\\(J(U)_{ij}^K\\\\) as a matrix via automatic differentiation of \\\\(F(U)_i^K\\\\). By the same argument as we always use, it is clear that \\\\(F(U)^K\\\\) does not actually depend on all unknowns \\\\(U_j\\\\), but only on those unknowns for which \\\\(j\\\\) is a shape function that lives on cell \\\\(K\\\\), and so in practice, we restrict \\\\(F(U)^K\\\\) and \\\\(J(U)^K\\\\) to that part of the vector and matrix that corresponds to the local DoF indices, and then distribute from the local cell \\\\(K\\\\) to the global objects.\\nUsing all of these realizations, the approach will then be to implement \\\\(F(U)^K\\\\) in the program and let the automatic differentiation machinery compute the derivatives \\\\(J(U)^K\\\\) from that.\\nComputing the Jacobian and the residual from the energy functional \\nFor the final implementation of the assembly process, we will move a level higher than the residual: our entire linear system will be determined directly from the energy functional that governs the physics of this boundary value problem. We can take advantage of the fact that we can calculate the total energy in the domain directly from the local contributions, i.e.,    \\n\\\\[\\n  E \\\\left( U \\\\right) \\\\dealcoloneq \\\\int\\\\limits_{\\\\Omega} \\\\Psi \\\\left( u\\n  \\\\right) \\\\, dV .\\n\\\\]\\n\\n In the discrete setting, this means that on each finite element we have      \\n\\\\[\\n   E \\\\left( U \\\\right)^K\\n    \\\\dealcoloneq \\\\int\\\\limits_{K} \\\\Psi \\\\left( u \\\\right) \\\\, dV\\n    \\\\approx \\\\sum\\\\limits_{q}^{n_{\\\\textrm{q-points}}} \\\\Psi \\\\left( u \\\\left(\\n    \\\\mathbf{x}_{q} \\\\right) \\\\right) \\\\underbrace{\\\\vert J_{q} \\\\vert \\\\times W_{q}}_{\\\\text{JxW(q)}} .\\n\\\\]\\n\\n If we implement the cell energy, which depends on the field solution, we can compute its first (discrete) variation    \\n\\\\[\\n  F(U)^K_i\\n    = \\\\frac{\\\\partial E(U)^K}{\\\\partial U_i}\\n\\\\]\\n\\n and, thereafter, its second (discrete) variation    \\n\\\\[\\n  J(U)^K_{ij}\\n    = \\\\frac{\\\\partial^{2}  E(U)^K}{\\\\partial U_i \\\\partial U_j}.\\n\\\\]\\n\\n So, from the cell contribution to the total energy function, we may expect to have the approximate residual and tangent contributions generated for us as long as we can provide an implementation of the local energy \\\\(E(U)^K\\\\). Again, due to the design of the automatic differentiation variables used in this tutorial, in practice these approximations for the contributions to the residual vector and tangent matrix are actually accurate to machine precision.\\n The commented program\\nThe majority of this tutorial is an exact replica of step-15. So, in the interest of brevity and maintaining a focus on the changes implemented here, we will only document what's new and simply indicate which sections of code are a repetition of what has come before.\\n Include files\\nThere are a few new header files that have been included in this tutorial. The first is the one that provides the declaration of the ParameterAcceptor class.\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/base/parameter_acceptor.h>\\n\\u00a0 #include <deal.II/base/timer.h>\\n\\u00a0 #include <deal.II/base/utilities.h>\\n\\u00a0 \\nThis is the second, which is an all-inclusive header that will allow us to incorporate the automatic differentiation (AD) functionality within this code.\\n\\u00a0 #include <deal.II/differentiation/ad.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/solver_cg.h>\\n\\u00a0 #include <deal.II/lac/precondition.h>\\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_refinement.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 #include <deal.II/fe/fe_values_extractors.h>\\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 \\nAnd the next three provide some multi-threading capability using the generic MeshWorker::mesh_loop() framework.\\n\\u00a0 #include <deal.II/meshworker/copy_data.h>\\n\\u00a0 #include <deal.II/meshworker/mesh_loop.h>\\n\\u00a0 #include <deal.II/meshworker/scratch_data.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/error_estimator.h>\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 #include <fstream>\\n\\u00a0 #include <iostream>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/solution_transfer.h>\\n\\u00a0 \\nWe then open a namespace for this program and import everything from the dealii namespace into it, as in previous programs:\\n\\u00a0 namespace Step72\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n The MinimalSurfaceProblemParameters class\\nIn this tutorial we will implement three different approaches for assembling the linear system. One mirrors the hand implementation originally provided in step-15, while the other two use the Sacado automatic differentiation library that is provided as a part of the Trilinos framework.\\nTo facilitate switching between the three implementations, we have this really basic parameters class that has only two options that are configurable.\\n\\u00a0   class MinimalSurfaceProblemParameters : public ParameterAcceptor\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     MinimalSurfaceProblemParameters();\\n\\u00a0 \\nParameterAcceptorDefinition parameter_acceptor.h:359\\nSelection for the formulation and corresponding AD framework to be used:\\nformulation = 0 : Unassisted implementation (full hand linearization).\\nformulation = 1 : Automated linearization of the finite element residual.\\nformulation = 2 : Automated computation of finite element residual and linearization using a variational formulation.\\n\\n\\u00a0     unsigned int formulation = 0;\\n\\u00a0 \\nThe maximum acceptable tolerance for the linear system residual. We will see that the assembly time becomes appreciable once we use the AD framework, so we have increased the tolerance selected in step-15 by one order of magnitude. This way, the computations do not take too long to complete.\\n\\u00a0     double tolerance = 1e-2;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   MinimalSurfaceProblemParameters::MinimalSurfaceProblemParameters()\\n\\u00a0     : ParameterAcceptor(\\\"Minimal Surface Problem/\\\")\\n\\u00a0   {\\n\\u00a0     add_parameter(\\n\\u00a0       \\\"Formulation\\\", formulation, \\\"\\\", this->prm, Patterns::Integer(0, 2));\\n\\u00a0     add_parameter(\\\"Tolerance\\\", tolerance, \\\"\\\", this->prm, Patterns::Double(0.0));\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nPatterns::DoubleDefinition patterns.h:291\\nPatterns::IntegerDefinition patterns.h:188\\n The MinimalSurfaceProblem class template\\nThe class template is essentially the same as in step-15. The only functional changes to the class are that:\\nthe run() function now takes in two arguments: one to choose which assembly approach is to be adopted, and one for the tolerance for the permissible final residual is, and\\nthere are now three different assembly functions that implement the three methods of assembling the linear system. We'll provide details on these later on.\\n\\n\\u00a0   template <int dim>\\n\\u00a0   class MinimalSurfaceProblem\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     MinimalSurfaceProblem();\\n\\u00a0 \\n\\u00a0     void run(const int formulation, const double tolerance);\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void   setup_system();\\n\\u00a0     void   assemble_system_unassisted();\\n\\u00a0     void   assemble_system_with_residual_linearization();\\n\\u00a0     void   assemble_system_using_energy_functional();\\n\\u00a0     void   solve();\\n\\u00a0     void   refine_mesh();\\n\\u00a0     double compute_residual(const double alpha) const;\\n\\u00a0     double determine_step_length() const;\\n\\u00a0     void   output_results(const unsigned int refinement_cycle) const;\\n\\u00a0 \\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0 \\n\\u00a0     DoFHandler<dim>   dof_handler;\\n\\u00a0     const FE_Q<dim>   fe;\\n\\u00a0     const QGauss<dim> quadrature_formula;\\n\\u00a0 \\n\\u00a0     AffineConstraints<double> nonzero_constraints;\\n\\u00a0     AffineConstraints<double> zero_constraints;\\n\\u00a0 \\n\\u00a0     SparsityPattern      sparsity_pattern;\\n\\u00a0     SparseMatrix<double> system_matrix;\\n\\u00a0 \\n\\u00a0     Vector<double> current_solution;\\n\\u00a0     Vector<double> newton_update;\\n\\u00a0     Vector<double> system_rhs;\\n\\u00a0   };\\n\\u00a0 \\nAffineConstraintsDefinition affine_constraints.h:507\\nDoFHandlerDefinition dof_handler.h:317\\nFE_QDefinition fe_q.h:554\\nQGaussDefinition quadrature_lib.h:40\\nSparseMatrixDefinition sparse_matrix.h:520\\nSparsityPatternDefinition sparsity_pattern.h:343\\nTriangulationDefinition tria.h:1323\\nVectorDefinition vector.h:120\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\n Boundary condition\\nThere are no changes to the boundary conditions applied to the problem.\\n\\u00a0   template <int dim>\\n\\u00a0   class BoundaryValues : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component = 0) const override;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   double BoundaryValues<dim>::value(const Point<dim> &p,\\n\\u00a0                                     const unsigned int /*component*/) const\\n\\u00a0   {\\n\\u00a0     return std::sin(2 * numbers::PI * (p[0] + p[1]));\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nFunctionDefinition function.h:152\\nFunction::valuevirtual RangeNumberType value(const Point< dim > &p, const unsigned int component=0) const\\nPointDefinition point.h:111\\nnumbers::PIstatic constexpr double PIDefinition numbers.h:259\\nstd::sin::VectorizedArray< Number, width > sin(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6589\\n The MinimalSurfaceProblem class implementation\\n MinimalSurfaceProblem::MinimalSurfaceProblem\\nThere have been no changes made to the class constructor.\\n\\u00a0   template <int dim>\\n\\u00a0   MinimalSurfaceProblem<dim>::MinimalSurfaceProblem()\\n\\u00a0     : dof_handler(triangulation)\\n\\u00a0     , fe(2)\\n\\u00a0     , quadrature_formula(fe.degree + 1)\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n MinimalSurfaceProblem::setup_system\\nThere have been no changes made to the function that sets up the class data structures, namely the DoFHandler, the hanging node constraints applied to the problem, and the linear system.\\n\\u00a0   template <int dim>\\n\\u00a0   void MinimalSurfaceProblem<dim>::setup_system()\\n\\u00a0   {\\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0     current_solution.reinit(dof_handler.n_dofs());\\n\\u00a0     newton_update.reinit(dof_handler.n_dofs());\\n\\u00a0     system_rhs.reinit(dof_handler.n_dofs());\\n\\u00a0 \\n\\u00a0     zero_constraints.clear();\\n\\u00a0     VectorTools::interpolate_boundary_values(dof_handler,\\n\\u00a0                                              0,\\n\\u00a0                                              Functions::ZeroFunction<dim>(),\\n\\u00a0                                              zero_constraints);\\n\\u00a0     DoFTools::make_hanging_node_constraints(dof_handler, zero_constraints);\\n\\u00a0     zero_constraints.close();\\n\\u00a0 \\n\\u00a0     nonzero_constraints.clear();\\n\\u00a0     VectorTools::interpolate_boundary_values(dof_handler,\\n\\u00a0                                              0,\\n\\u00a0                                              BoundaryValues<dim>(),\\n\\u00a0                                              nonzero_constraints);\\n\\u00a0     nonzero_constraints.close();\\n\\u00a0 \\n\\u00a0     DynamicSparsityPattern dsp(dof_handler.n_dofs());\\n\\u00a0     DoFTools::make_sparsity_pattern(dof_handler, dsp, zero_constraints);\\n\\u00a0 \\n\\u00a0     sparsity_pattern.copy_from(dsp);\\n\\u00a0     system_matrix.reinit(sparsity_pattern);\\n\\u00a0   }\\n\\u00a0 \\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nFunctions::ZeroFunctionDefinition function.h:510\\nDoFTools::make_hanging_node_constraintsvoid make_hanging_node_constraints(const DoFHandler< dim, spacedim > &dof_handler, AffineConstraints< number > &constraints)Definition dof_tools_constraints.cc:3073\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nVectorTools::interpolate_boundary_valuesvoid interpolate_boundary_values(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const std::map< types::boundary_id, const Function< spacedim, number > * > &function_map, std::map< types::global_dof_index, number > &boundary_values, const ComponentMask &component_mask={})\\n Assembling the linear system\\n Manual assembly\\nThe assembly functions are the interesting contributions to this tutorial. The assemble_system_unassisted() method implements exactly the same assembly function as is detailed in step-15, but in this instance we use the MeshWorker::mesh_loop() function to multithread the assembly process. The reason for doing this is quite simple: When using automatic differentiation, we know that there is to be some additional computational overhead incurred. In order to mitigate this performance loss, we'd like to take advantage of as many (easily available) computational resources as possible. The MeshWorker::mesh_loop() concept makes this a relatively straightforward task. At the same time, for the purposes of fair comparison, we need to do the same to the implementation that uses no assistance when computing the residual or its linearization. (The MeshWorker::mesh_loop() function is first discussed in step-12 and step-16, if you'd like to read up on it.)\\nThe steps required to implement the multithreading are the same between the three functions, so we'll use the assemble_system_unassisted() function as an opportunity to focus on the multithreading itself.\\n\\u00a0   template <int dim>\\n\\u00a0   void MinimalSurfaceProblem<dim>::assemble_system_unassisted()\\n\\u00a0   {\\n\\u00a0     system_matrix = 0;\\n\\u00a0     system_rhs    = 0;\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n\\u00a0 \\nThe MeshWorker::mesh_loop() expects that we provide two exemplar data structures. The first, ScratchData, is to store all large data that is to be reused between threads. The CopyData will hold the contributions to the linear system that come from each cell. These independent matrix-vector pairs must be accumulated into the global linear system sequentially. Since we don't need anything on top of what the MeshWorker::ScratchData and MeshWorker::CopyData classes already provide, we use these exact class definitions for our problem. Note that we only require a single instance of a local matrix, local right-hand side vector, and cell degree of freedom index vector \\u2013 the MeshWorker::CopyData therefore has 1 for all three of its template arguments.\\n\\u00a0     using ScratchData = MeshWorker::ScratchData<dim>;\\n\\u00a0     using CopyData    = MeshWorker::CopyData<1, 1, 1>;\\n\\u00a0 \\nMeshWorker::ScratchDataDefinition scratch_data.h:210\\nMeshWorker::CopyDataDefinition copy_data.h:54\\nWe also need to know what type of iterator we'll be working with during assembly. For simplicity, we just ask the compiler to work this out for us using the decltype() specifier, knowing that we'll be iterating over active cells owned by the dof_handler.\\n\\u00a0     using CellIteratorType = decltype(dof_handler.begin_active());\\n\\u00a0 \\nHere we initialize the exemplar data structures. Since we know that we need to compute the shape function gradients, weighted Jacobian, and the position of the quadrate points in real space, we pass these flags into the class constructor.\\n\\u00a0     const ScratchData sample_scratch_data(fe,\\n\\u00a0                                           quadrature_formula,\\n\\u00a0                                           update_gradients |\\n\\u00a0                                             update_quadrature_points |\\n\\u00a0                                             update_JxW_values);\\n\\u00a0     const CopyData    sample_copy_data(dofs_per_cell);\\n\\u00a0 \\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nNow we define a lambda function that will perform the assembly on a single cell. The three arguments are those that will be expected by MeshWorker::mesh_loop(), due to the arguments that we'll pass to that final call. We also capture the this pointer, which means that we'll have access to \\\"this\\\" (i.e., the current MinimalSurfaceProblem<dim>) class instance, and its private member data (since the lambda function is defined within a MinimalSurfaceProblem<dim> method).\\nAt the top of the function, we initialize the data structures that are dependent on the cell for which the work is being performed. Observe that the reinitialization call actually returns an instance to an FEValues object that is initialized and stored within (and, therefore, reused by) the scratch_data object.\\nSimilarly, we get aliases to the local matrix, local RHS vector, and local cell DoF indices from the copy_data instance that MeshWorker::mesh_loop() provides. We then initialize the cell DoF indices, knowing that the local matrix and vector are already correctly sized.\\n\\u00a0     const auto cell_worker = [this](const CellIteratorType &cell,\\n\\u00a0                                     ScratchData            &scratch_data,\\n\\u00a0                                     CopyData               &copy_data) {\\n\\u00a0       const auto &fe_values = scratch_data.reinit(cell);\\n\\u00a0 \\n\\u00a0       FullMatrix<double>                   &cell_matrix = copy_data.matrices[0];\\n\\u00a0       Vector<double>                       &cell_rhs    = copy_data.vectors[0];\\n\\u00a0       std::vector<types::global_dof_index> &local_dof_indices =\\n\\u00a0         copy_data.local_dof_indices[0];\\n\\u00a0       cell->get_dof_indices(local_dof_indices);\\n\\u00a0 \\nFullMatrixDefinition full_matrix.h:79\\nFor Newton's method, we require the gradient of the solution at the point about which the problem is being linearized.\\nOnce we have that, we can perform assembly for this cell in the usual way. One minor difference to step-15 is that we've used the (rather convenient) range-based loops to iterate over all quadrature points and degrees-of-freedom.\\n\\u00a0       std::vector<Tensor<1, dim>> old_solution_gradients(\\n\\u00a0         fe_values.n_quadrature_points);\\n\\u00a0       fe_values.get_function_gradients(current_solution,\\n\\u00a0                                        old_solution_gradients);\\n\\u00a0 \\n\\u00a0       for (const unsigned int q : fe_values.quadrature_point_indices())\\n\\u00a0         {\\n\\u00a0           const double coeff =\\n\\u00a0             1.0 / std::sqrt(1.0 + old_solution_gradients[q] *\\n\\u00a0                                     old_solution_gradients[q]);\\n\\u00a0 \\n\\u00a0           for (const unsigned int i : fe_values.dof_indices())\\n\\u00a0             {\\n\\u00a0               for (const unsigned int j : fe_values.dof_indices())\\n\\u00a0                 cell_matrix(i, j) +=\\n\\u00a0                   (((fe_values.shape_grad(i, q)      // ((\\\\nabla \\\\phi_i\\n\\u00a0                      * coeff                         //   * a_n\\n\\u00a0                      * fe_values.shape_grad(j, q))   //   * \\\\nabla \\\\phi_j)\\n\\u00a0                     -                                //  -\\n\\u00a0                     (fe_values.shape_grad(i, q)      //  (\\\\nabla \\\\phi_i\\n\\u00a0                      * coeff * coeff * coeff         //   * a_n^3\\n\\u00a0                      * (fe_values.shape_grad(j, q)   //   * (\\\\nabla \\\\phi_j\\n\\u00a0                         * old_solution_gradients[q]) //      * \\\\nabla u_n)\\n\\u00a0                      * old_solution_gradients[q]))   //   * \\\\nabla u_n)))\\n\\u00a0                    * fe_values.JxW(q));              // * dx\\n\\u00a0 \\n\\u00a0               cell_rhs(i) -= (fe_values.shape_grad(i, q)  // \\\\nabla \\\\phi_i\\n\\u00a0                               * coeff                     // * a_n\\n\\u00a0                               * old_solution_gradients[q] // * \\\\nabla u_n\\n\\u00a0                               * fe_values.JxW(q));        // * dx\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0     };\\n\\u00a0 \\nint\\nstdSTL namespace.\\nThe second lambda function that MeshWorker::mesh_loop() requires is one that performs the task of accumulating the local contributions in the global linear system. That is precisely what this one does, and the details of the implementation have been seen before. The primary point to recognize is that the local contributions are stored in the copy_data instance that is passed into this function. This copy_data has been filled with data during some call to the cell_worker.\\n\\u00a0     const auto copier = [this](const CopyData &copy_data) {\\n\\u00a0       const FullMatrix<double> &cell_matrix = copy_data.matrices[0];\\n\\u00a0       const Vector<double>     &cell_rhs    = copy_data.vectors[0];\\n\\u00a0       const std::vector<types::global_dof_index> &local_dof_indices =\\n\\u00a0         copy_data.local_dof_indices[0];\\n\\u00a0 \\n\\u00a0       zero_constraints.distribute_local_to_global(\\n\\u00a0         cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);\\n\\u00a0     };\\n\\u00a0 \\nWe have all of the required functions definitions in place, so now we call the MeshWorker::mesh_loop() to perform the actual assembly. We pass a flag as the last parameter which states that we only want to perform the assembly on the cells. Internally, MeshWorker::mesh_loop() then distributes the available work to different threads, making efficient use of the multiple cores almost all of today's processors have to offer.\\n\\u00a0     MeshWorker::mesh_loop(dof_handler.active_cell_iterators(),\\n\\u00a0                           cell_worker,\\n\\u00a0                           copier,\\n\\u00a0                           sample_scratch_data,\\n\\u00a0                           sample_copy_data,\\n\\u00a0                           MeshWorker::assemble_own_cells);\\n\\u00a0   }\\n\\u00a0 \\nMeshWorker::mesh_loopvoid mesh_loop(const CellIteratorType &begin, const CellIteratorType &end, const CellWorkerFunctionType &cell_worker, const CopierType &copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const AssembleFlags flags=assemble_own_cells, const BoundaryWorkerFunctionType &boundary_worker=BoundaryWorkerFunctionType(), const FaceWorkerFunctionType &face_worker=FaceWorkerFunctionType(), const unsigned int queue_length=2 *MultithreadInfo::n_threads(), const unsigned int chunk_size=8)Definition mesh_loop.h:281\\nMeshWorker::assemble_own_cells@ assemble_own_cellsDefinition assemble_flags.h:49\\n Assembly via differentiation of the residual vector\\nAs outlined in the introduction, what we need to do for this second approach is implement the local contributions \\\\(F(U)^K\\\\) from cell \\\\(K\\\\) to the residual vector, and then let the AD machinery deal with how to compute the derivatives \\\\(J(U)_{ij}^K=\\\\frac{\\\\partial F(U)^K_i}{\\\\partial U_j}\\\\) from it.\\nFor the following, recall that     \\n\\\\[\\n   F(U)_i^K \\\\dealcoloneq\\n   \\\\int\\\\limits_K\\\\nabla \\\\varphi_i \\\\cdot \\\\left[ \\\\frac{1}{\\\\sqrt{1+|\\\\nabla\\n   u|^{2}}} \\\\nabla u \\\\right] \\\\, dV ,\\n   \\\\]\\n\\n where \\\\(u(\\\\mathbf x)=\\\\sum_j U_j \\\\varphi_j(\\\\mathbf x)\\\\).\\nLet us see how this is implemented in practice:\\n\\u00a0   template <int dim>\\n\\u00a0   void MinimalSurfaceProblem<dim>::assemble_system_with_residual_linearization()\\n\\u00a0   {\\n\\u00a0     system_matrix = 0;\\n\\u00a0     system_rhs    = 0;\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n\\u00a0 \\n\\u00a0     using ScratchData      = MeshWorker::ScratchData<dim>;\\n\\u00a0     using CopyData         = MeshWorker::CopyData<1, 1, 1>;\\n\\u00a0     using CellIteratorType = decltype(dof_handler.begin_active());\\n\\u00a0 \\n\\u00a0     const ScratchData sample_scratch_data(fe,\\n\\u00a0                                           quadrature_formula,\\n\\u00a0                                           update_gradients |\\n\\u00a0                                             update_quadrature_points |\\n\\u00a0                                             update_JxW_values);\\n\\u00a0     const CopyData    sample_copy_data(dofs_per_cell);\\n\\u00a0 \\nWe'll define up front the AD data structures that we'll be using, utilizing the techniques shown in step-71. In this case, we choose the helper class that will automatically compute the linearization of the finite element residual using Sacado forward automatic differentiation types. These number types can be used to compute first derivatives only. This is exactly what we want, because we know that we'll only be linearizing the residual, which means that we only need to compute first-order derivatives. The return values from the calculations are to be of type double.\\nWe also need an extractor to retrieve some data related to the field solution to the problem.\\n\\u00a0     using ADHelper = Differentiation::AD::ResidualLinearization<\\n\\u00a0       Differentiation::AD::NumberTypes::sacado_dfad,\\n\\u00a0       double>;\\n\\u00a0     using ADNumberType = typename ADHelper::ad_type;\\n\\u00a0 \\n\\u00a0     const FEValuesExtractors::Scalar u_fe(0);\\n\\u00a0 \\nDifferentiation::AD::ResidualLinearizationDefinition ad_helpers.h:1529\\nDifferentiation::AD::NumberTypes::sacado_dfad@ sacado_dfad\\nFEValuesExtractors::ScalarDefinition fe_values_extractors.h:95\\nWith this, let us define the lambda function that will be used to compute the cell contributions to the Jacobian matrix and the right hand side:\\n\\u00a0     const auto cell_worker = [&u_fe, this](const CellIteratorType &cell,\\n\\u00a0                                            ScratchData            &scratch_data,\\n\\u00a0                                            CopyData               &copy_data) {\\n\\u00a0       const auto        &fe_values     = scratch_data.reinit(cell);\\n\\u00a0       const unsigned int dofs_per_cell = fe_values.get_fe().n_dofs_per_cell();\\n\\u00a0 \\n\\u00a0       FullMatrix<double>                   &cell_matrix = copy_data.matrices[0];\\n\\u00a0       Vector<double>                       &cell_rhs    = copy_data.vectors[0];\\n\\u00a0       std::vector<types::global_dof_index> &local_dof_indices =\\n\\u00a0         copy_data.local_dof_indices[0];\\n\\u00a0       cell->get_dof_indices(local_dof_indices);\\n\\u00a0 \\nWe'll now create and initialize an instance of the AD helper class. To do this, we need to specify how many independent variables and dependent variables there are. The independent variables will be the number of local degrees of freedom that our solution vector has, i.e., the number \\\\(j\\\\) in the per-element representation of the discretized solution vector \\\\(u (\\\\mathbf{x})|_K = \\\\sum\\\\limits_{j} U^K_i \\\\varphi_j(\\\\mathbf{x})\\\\) that indicates how many solution coefficients are associated with each finite element. In deal.II, this equals FiniteElement::dofs_per_cell. The number of dependent variables will be the number of entries in the local residual vector that we will be forming. In this particular problem (like many others that employ the standard Galerkin method) the number of local solution coefficients matches the number of local residual equations.\\n\\u00a0       const unsigned int n_independent_variables = local_dof_indices.size();\\n\\u00a0       const unsigned int n_dependent_variables   = dofs_per_cell;\\n\\u00a0       ADHelper ad_helper(n_independent_variables, n_dependent_variables);\\n\\u00a0 \\nNext we inform the helper of the values of the solution, i.e., the actual values for \\\\(U_j\\\\) about which we wish to linearize. As this is done on each element individually, we have to extract the solution coefficients from the global solution vector. In other words, we define all of those coefficients \\\\(U_j\\\\) where \\\\(j\\\\) is a local degree of freedom as the independent variables that enter the computation of the vector \\\\(F(U)^{K}\\\\) (the dependent function).\\nThen we get the complete set of degree of freedom values as represented by auto-differentiable numbers. The operations performed with these variables are tracked by the AD library from this point until the object goes out of scope. So it is precisely these variables with respect to which we will compute derivatives of the residual entries.\\n\\u00a0       ad_helper.register_dof_values(current_solution, local_dof_indices);\\n\\u00a0 \\n\\u00a0       const std::vector<ADNumberType> &dof_values_ad =\\n\\u00a0         ad_helper.get_sensitive_dof_values();\\n\\u00a0 \\nThen we do some problem specific tasks, the first being to compute all values, (spatial) gradients, and the like based on \\\"sensitive\\\" AD degree of freedom values. In this instance we are retrieving the solution gradients at each quadrature point. Observe that the solution gradients are now sensitive to the values of the degrees of freedom as they use the ADNumberType as the scalar type and the dof_values_ad vector provides the local DoF values.\\n\\u00a0       std::vector<Tensor<1, dim, ADNumberType>> old_solution_gradients(\\n\\u00a0         fe_values.n_quadrature_points);\\n\\u00a0       fe_values[u_fe].get_function_gradients_from_local_dof_values(\\n\\u00a0         dof_values_ad, old_solution_gradients);\\n\\u00a0 \\nThe next variable that we declare will store the cell residual vector contributions. This is rather self-explanatory, save for one very important detail: Note that each entry in the vector is hand-initialized with a value of zero. This is a highly recommended practice, as some AD libraries appear not to safely initialize the internal data structures of these number types. Not doing so could lead to some very hard to understand or detect bugs (appreciate that the author of this program mentions this out of, generally bad, experience). So out of an abundance of caution it's worthwhile zeroing the initial value explicitly. After that, apart from a sign change the residual assembly looks much the same as we saw for the cell RHS vector before: We loop over all quadrature points, ensure that the coefficient now encodes its dependence on the (sensitive) finite element DoF values by using the correct ADNumberType, and finally we assemble the components of the residual vector. For complete clarity, the finite element shape functions (and their gradients, etc.) as well as the \\\"JxW\\\" values remain scalar valued, but the coeff and the old_solution_gradients at each quadrature point are computed in terms of the independent variables.\\n\\u00a0       std::vector<ADNumberType> residual_ad(n_dependent_variables,\\n\\u00a0                                             ADNumberType(0.0));\\n\\u00a0       for (const unsigned int q : fe_values.quadrature_point_indices())\\n\\u00a0         {\\n\\u00a0           const ADNumberType coeff =\\n\\u00a0             1.0 / std::sqrt(1.0 + old_solution_gradients[q] *\\n\\u00a0                                     old_solution_gradients[q]);\\n\\u00a0 \\n\\u00a0           for (const unsigned int i : fe_values.dof_indices())\\n\\u00a0             {\\n\\u00a0               residual_ad[i] += (fe_values.shape_grad(i, q)   // \\\\nabla \\\\phi_i\\n\\u00a0                                  * coeff                      // * a_n\\n\\u00a0                                  * old_solution_gradients[q]) // * \\\\nabla u_n\\n\\u00a0                                 * fe_values.JxW(q);           // * dx\\n\\u00a0             }\\n\\u00a0         }\\n\\u00a0 \\nOnce we have the full cell residual vector computed, we can register it with the helper class.\\nThereafter, we compute the residual values (basically, extracting the real values from what we already computed) and their Jacobian (the linearization of each residual component with respect to all cell DoFs) at the evaluation point. For the purposes of assembly into the global linear system, we have to respect the sign difference between the residual and the RHS contribution: For Newton's method, the right hand side vector needs to be equal to the negative residual vector.\\n\\u00a0       ad_helper.register_residual_vector(residual_ad);\\n\\u00a0 \\n\\u00a0       ad_helper.compute_residual(cell_rhs);\\n\\u00a0       cell_rhs *= -1.0;\\n\\u00a0 \\n\\u00a0       ad_helper.compute_linearization(cell_matrix);\\n\\u00a0     };\\n\\u00a0 \\nThe remainder of the function equals what we had previously:\\n\\u00a0     const auto copier = [this](const CopyData &copy_data) {\\n\\u00a0       const FullMatrix<double> &cell_matrix = copy_data.matrices[0];\\n\\u00a0       const Vector<double>     &cell_rhs    = copy_data.vectors[0];\\n\\u00a0       const std::vector<types::global_dof_index> &local_dof_indices =\\n\\u00a0         copy_data.local_dof_indices[0];\\n\\u00a0 \\n\\u00a0       zero_constraints.distribute_local_to_global(\\n\\u00a0         cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     MeshWorker::mesh_loop(dof_handler.active_cell_iterators(),\\n\\u00a0                           cell_worker,\\n\\u00a0                           copier,\\n\\u00a0                           sample_scratch_data,\\n\\u00a0                           sample_copy_data,\\n\\u00a0                           MeshWorker::assemble_own_cells);\\n\\u00a0   }\\n\\u00a0 \\n Assembly via differentiation of the energy functional\\nIn this third approach, we compute residual and Jacobian as first and second derivatives of the local energy functional       \\n\\\\[\\n   E\\\\left( U \\\\right)^K\\n   \\\\dealcoloneq \\\\int\\\\limits_{K} \\\\Psi \\\\left( u \\\\right) \\\\, dV\\n   \\\\approx \\\\sum\\\\limits_{q}^{n_{\\\\textrm{q-points}}} \\\\Psi \\\\left( u \\\\left(\\n   \\\\mathbf{X}_{q} \\\\right) \\\\right) \\\\underbrace{\\\\vert J_{q} \\\\vert \\\\times\\n   W_{q}}_{\\\\text{JxW(q)}}\\n   \\\\]\\n\\n with the energy density given by   \\n\\\\[\\n   \\\\Psi \\\\left( u \\\\right) = \\\\sqrt{1+|\\\\nabla u|^{2}} .\\n   \\\\]\\n\\nLet us again see how this is done:\\n\\u00a0   template <int dim>\\n\\u00a0   void MinimalSurfaceProblem<dim>::assemble_system_using_energy_functional()\\n\\u00a0   {\\n\\u00a0     system_matrix = 0;\\n\\u00a0     system_rhs    = 0;\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n\\u00a0 \\n\\u00a0     using ScratchData      = MeshWorker::ScratchData<dim>;\\n\\u00a0     using CopyData         = MeshWorker::CopyData<1, 1, 1>;\\n\\u00a0     using CellIteratorType = decltype(dof_handler.begin_active());\\n\\u00a0 \\n\\u00a0     const ScratchData sample_scratch_data(fe,\\n\\u00a0                                           quadrature_formula,\\n\\u00a0                                           update_gradients |\\n\\u00a0                                             update_quadrature_points |\\n\\u00a0                                             update_JxW_values);\\n\\u00a0     const CopyData    sample_copy_data(dofs_per_cell);\\n\\u00a0 \\nIn this implementation of the assembly process, we choose the helper class that will automatically compute both the residual and its linearization from the cell contribution to an energy functional using nested Sacado forward automatic differentiation types. The selected number types can be used to compute both first and second derivatives. We require this, as the residual defined as the sensitivity of the potential energy with respect to the DoF values (i.e. its gradient). We'll then need to linearize the residual, implying that second derivatives of the potential energy must be computed. You might want to compare this with the definition of ADHelper used int previous function, where we used Differentiation::AD::ResidualLinearization<Differentiation::AD::NumberTypes::sacado_dfad,double>.\\n\\u00a0     using ADHelper = Differentiation::AD::EnergyFunctional<\\n\\u00a0       Differentiation::AD::NumberTypes::sacado_dfad_dfad,\\n\\u00a0       double>;\\n\\u00a0     using ADNumberType = typename ADHelper::ad_type;\\n\\u00a0 \\n\\u00a0     const FEValuesExtractors::Scalar u_fe(0);\\n\\u00a0 \\nDifferentiation::AD::EnergyFunctionalDefinition ad_helpers.h:1217\\nDifferentiation::AD::NumberTypes::sacado_dfad_dfad@ sacado_dfad_dfad\\nLet us then again define the lambda function that does the integration on a cell.\\nTo initialize an instance of the helper class, we now only require that the number of independent variables (that is, the number of degrees of freedom associated with the element solution vector) are known up front. This is because the second-derivative matrix that results from an energy functional is necessarily square (and also, incidentally, symmetric).\\n\\u00a0     const auto cell_worker = [&u_fe, this](const CellIteratorType &cell,\\n\\u00a0                                            ScratchData            &scratch_data,\\n\\u00a0                                            CopyData               &copy_data) {\\n\\u00a0       const auto &fe_values = scratch_data.reinit(cell);\\n\\u00a0 \\n\\u00a0       FullMatrix<double>                   &cell_matrix = copy_data.matrices[0];\\n\\u00a0       Vector<double>                       &cell_rhs    = copy_data.vectors[0];\\n\\u00a0       std::vector<types::global_dof_index> &local_dof_indices =\\n\\u00a0         copy_data.local_dof_indices[0];\\n\\u00a0       cell->get_dof_indices(local_dof_indices);\\n\\u00a0 \\n\\u00a0       const unsigned int n_independent_variables = local_dof_indices.size();\\n\\u00a0       ADHelper           ad_helper(n_independent_variables);\\n\\u00a0 \\nVector::sizevirtual size_type size() const override\\nOnce more, we register all cell DoFs values with the helper, followed by extracting the \\\"sensitive\\\" variant of these values that are to be used in subsequent operations that must be differentiated \\u2013 one of those being the calculation of the solution gradients.\\n\\u00a0       ad_helper.register_dof_values(current_solution, local_dof_indices);\\n\\u00a0 \\n\\u00a0       const std::vector<ADNumberType> &dof_values_ad =\\n\\u00a0         ad_helper.get_sensitive_dof_values();\\n\\u00a0 \\n\\u00a0       std::vector<Tensor<1, dim, ADNumberType>> old_solution_gradients(\\n\\u00a0         fe_values.n_quadrature_points);\\n\\u00a0       fe_values[u_fe].get_function_gradients_from_local_dof_values(\\n\\u00a0         dof_values_ad, old_solution_gradients);\\n\\u00a0 \\nWe next create a variable that stores the cell total energy. Once more we emphasize that we explicitly zero-initialize this value, thereby ensuring the integrity of the data for this starting value.\\nThe aim for our approach is then to compute the cell total energy, which is the sum of the internal (due to right hand side functions, typically linear in \\\\(U\\\\)) and external energies. In this particular case, we have no external energies (e.g., from source terms or Neumann boundary conditions), so we'll focus on the internal energy part.\\nIn fact, computing \\\\(E(U)^K\\\\) is almost trivial, requiring only the following lines:\\n\\u00a0       ADNumberType energy_ad = ADNumberType(0.0);\\n\\u00a0       for (const unsigned int q : fe_values.quadrature_point_indices())\\n\\u00a0         {\\n\\u00a0           const ADNumberType psi = std::sqrt(1.0 + old_solution_gradients[q] *\\n\\u00a0                                                      old_solution_gradients[q]);\\n\\u00a0 \\n\\u00a0           energy_ad += psi * fe_values.JxW(q);\\n\\u00a0         }\\n\\u00a0 \\nAfter we've computed the total energy on this cell, we'll register it with the helper. Based on that, we may now compute the desired quantities, namely the residual values and their Jacobian at the evaluation point. As before, the Newton right hand side needs to be the negative of the residual:\\n\\u00a0       ad_helper.register_energy_functional(energy_ad);\\n\\u00a0 \\n\\u00a0       ad_helper.compute_residual(cell_rhs);\\n\\u00a0       cell_rhs *= -1.0;\\n\\u00a0 \\n\\u00a0       ad_helper.compute_linearization(cell_matrix);\\n\\u00a0     };\\n\\u00a0 \\nAs in the previous two functions, the remainder of the function is as before:\\n\\u00a0     const auto copier = [this](const CopyData &copy_data) {\\n\\u00a0       const FullMatrix<double> &cell_matrix = copy_data.matrices[0];\\n\\u00a0       const Vector<double>     &cell_rhs    = copy_data.vectors[0];\\n\\u00a0       const std::vector<types::global_dof_index> &local_dof_indices =\\n\\u00a0         copy_data.local_dof_indices[0];\\n\\u00a0 \\n\\u00a0       zero_constraints.distribute_local_to_global(\\n\\u00a0         cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);\\n\\u00a0     };\\n\\u00a0 \\n\\u00a0     MeshWorker::mesh_loop(dof_handler.active_cell_iterators(),\\n\\u00a0                           cell_worker,\\n\\u00a0                           copier,\\n\\u00a0                           sample_scratch_data,\\n\\u00a0                           sample_copy_data,\\n\\u00a0                           MeshWorker::assemble_own_cells);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n MinimalSurfaceProblem::solve\\nThe solve function is the same as is used in step-15.\\n\\u00a0   template <int dim>\\n\\u00a0   void MinimalSurfaceProblem<dim>::solve()\\n\\u00a0   {\\n\\u00a0     SolverControl            solver_control(system_rhs.size(),\\n\\u00a0                                  system_rhs.l2_norm() * 1e-6);\\n\\u00a0     SolverCG<Vector<double>> solver(solver_control);\\n\\u00a0 \\n\\u00a0     PreconditionSSOR<SparseMatrix<double>> preconditioner;\\n\\u00a0     preconditioner.initialize(system_matrix, 1.2);\\n\\u00a0 \\n\\u00a0     solver.solve(system_matrix, newton_update, system_rhs, preconditioner);\\n\\u00a0 \\n\\u00a0     zero_constraints.distribute(newton_update);\\n\\u00a0 \\n\\u00a0     const double alpha = determine_step_length();\\n\\u00a0     current_solution.add(alpha, newton_update);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nPreconditionSSORDefinition precondition.h:1778\\nPreconditionSSOR::initializevoid initialize(const MatrixType &A, const AdditionalData &parameters=AdditionalData())\\nSolverCGDefinition solver_cg.h:179\\nSolverControlDefinition solver_control.h:67\\n MinimalSurfaceProblem::refine_mesh\\nNothing has changed since step-15 with respect to the mesh refinement procedure and transfer of the solution between adapted meshes.\\n\\u00a0   template <int dim>\\n\\u00a0   void MinimalSurfaceProblem<dim>::refine_mesh()\\n\\u00a0   {\\n\\u00a0     Vector<float> estimated_error_per_cell(triangulation.n_active_cells());\\n\\u00a0 \\n\\u00a0     KellyErrorEstimator<dim>::estimate(\\n\\u00a0       dof_handler,\\n\\u00a0       QGauss<dim - 1>(fe.degree + 1),\\n\\u00a0       std::map<types::boundary_id, const Function<dim> *>(),\\n\\u00a0       current_solution,\\n\\u00a0       estimated_error_per_cell);\\n\\u00a0 \\n\\u00a0     GridRefinement::refine_and_coarsen_fixed_number(triangulation,\\n\\u00a0                                                     estimated_error_per_cell,\\n\\u00a0                                                     0.3,\\n\\u00a0                                                     0.03);\\n\\u00a0 \\n\\u00a0     triangulation.prepare_coarsening_and_refinement();\\n\\u00a0 \\n\\u00a0     SolutionTransfer<dim> solution_transfer(dof_handler);\\n\\u00a0     const Vector<double>  coarse_solution = current_solution;\\n\\u00a0     solution_transfer.prepare_for_coarsening_and_refinement(coarse_solution);\\n\\u00a0 \\n\\u00a0     triangulation.execute_coarsening_and_refinement();\\n\\u00a0 \\n\\u00a0     setup_system();\\n\\u00a0 \\n\\u00a0     solution_transfer.interpolate(coarse_solution, current_solution);\\n\\u00a0     nonzero_constraints.distribute(current_solution);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nKellyErrorEstimator::estimatestatic void estimate(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const Quadrature< dim - 1 > &quadrature, const std::map< types::boundary_id, const Function< spacedim, Number > * > &neumann_bc, const ReadVector< Number > &solution, Vector< float > &error, const ComponentMask &component_mask={}, const Function< spacedim > *coefficients=nullptr, const unsigned int n_threads=numbers::invalid_unsigned_int, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id, const types::material_id material_id=numbers::invalid_material_id, const Strategy strategy=cell_diameter_over_24)\\nSolutionTransferDefinition solution_transfer.h:337\\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nparallel::distributed::Triangulation::execute_coarsening_and_refinementvirtual void execute_coarsening_and_refinement() overrideDefinition tria.cc:3320\\nparallel::distributed::Triangulation::prepare_coarsening_and_refinementvirtual bool prepare_coarsening_and_refinement() overrideDefinition tria.cc:2805\\nunsigned int\\nGridRefinement::refine_and_coarsen_fixed_numbervoid refine_and_coarsen_fixed_number(Triangulation< dim, spacedim > &triangulation, const Vector< Number > &criteria, const double top_fraction_of_cells, const double bottom_fraction_of_cells, const unsigned int max_n_cells=std::numeric_limits< unsigned int >::max())Definition grid_refinement.cc:318\\n MinimalSurfaceProblem::compute_residual\\n... as does the function used to compute the residual during the solution iteration procedure. One could replace this by differentiation of the energy functional if one really wanted, but for simplicity we here simply copy what we already had in step-15.\\n\\u00a0   template <int dim>\\n\\u00a0   double MinimalSurfaceProblem<dim>::compute_residual(const double alpha) const\\n\\u00a0   {\\n\\u00a0     Vector<double> residual(dof_handler.n_dofs());\\n\\u00a0 \\n\\u00a0     Vector<double> evaluation_point(dof_handler.n_dofs());\\n\\u00a0     evaluation_point = current_solution;\\n\\u00a0     evaluation_point.add(alpha, newton_update);\\n\\u00a0 \\n\\u00a0     FEValues<dim> fe_values(fe,\\n\\u00a0                             quadrature_formula,\\n\\u00a0                             update_gradients | update_quadrature_points |\\n\\u00a0                               update_JxW_values);\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n\\u00a0     const unsigned int n_q_points    = quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     Vector<double>              cell_residual(dofs_per_cell);\\n\\u00a0     std::vector<Tensor<1, dim>> gradients(n_q_points);\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         cell_residual = 0;\\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0         fe_values.get_function_gradients(evaluation_point, gradients);\\n\\u00a0 \\n\\u00a0         for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0           {\\n\\u00a0             const double coeff =\\n\\u00a0               1.0 / std::sqrt(1.0 + gradients[q] * gradients[q]);\\n\\u00a0 \\n\\u00a0             for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0               cell_residual(i) -= (fe_values.shape_grad(i, q) // \\\\nabla \\\\phi_i\\n\\u00a0                                    * coeff                    // * a_n\\n\\u00a0                                    * gradients[q]             // * \\\\nabla u_n\\n\\u00a0                                    * fe_values.JxW(q));       // * dx\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0         zero_constraints.distribute_local_to_global(cell_residual,\\n\\u00a0                                                     local_dof_indices,\\n\\u00a0                                                     residual);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     return residual.l2_norm();\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFEValuesDefinition fe_values.h:63\\nstd::sqrt::VectorizedArray< Number, width > sqrt(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6869\\n MinimalSurfaceProblem::determine_step_length\\nThe choice of step length (or, under-relaxation factor) for the nonlinear iterations procedure remains fixed at the value chosen and discussed in step-15.\\n\\u00a0   template <int dim>\\n\\u00a0   double MinimalSurfaceProblem<dim>::determine_step_length() const\\n\\u00a0   {\\n\\u00a0     return 0.1;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n MinimalSurfaceProblem::output_results\\nThis last function to be called from run() outputs the current solution (and the Newton update) in graphical form as a VTU file. It is entirely the same as what has been used in previous tutorials.\\n\\u00a0   template <int dim>\\n\\u00a0   void MinimalSurfaceProblem<dim>::output_results(\\n\\u00a0     const unsigned int refinement_cycle) const\\n\\u00a0   {\\n\\u00a0     DataOut<dim> data_out;\\n\\u00a0 \\n\\u00a0     data_out.attach_dof_handler(dof_handler);\\n\\u00a0     data_out.add_data_vector(current_solution, \\\"solution\\\");\\n\\u00a0     data_out.add_data_vector(newton_update, \\\"update\\\");\\n\\u00a0     data_out.build_patches();\\n\\u00a0 \\n\\u00a0     const std::string filename =\\n\\u00a0       \\\"solution-\\\" + Utilities::int_to_string(refinement_cycle, 2) + \\\".vtu\\\";\\n\\u00a0     std::ofstream output(filename);\\n\\u00a0     data_out.write_vtu(output);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nUtilities::int_to_stringstd::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)Definition utilities.cc:470\\n MinimalSurfaceProblem::run\\nIn the run function, most remains the same as was first implemented in step-15. The only observable changes are that we can now choose (via the parameter file) what the final acceptable tolerance for the system residual is, and that we can choose which method of assembly we wish to utilize. To make the second choice clear, we output to the console some message which indicates the selection. Since we're interested in comparing the time taken to assemble for each of the three methods, we've also added a timer that keeps a track of how much time is spent during assembly. We also track the time taken to solve the linear system, so that we can contrast those numbers to the part of the code which would normally take the longest time to execute.\\n\\u00a0   template <int dim>\\n\\u00a0   void MinimalSurfaceProblem<dim>::run(const int    formulation,\\n\\u00a0                                        const double tolerance)\\n\\u00a0   {\\n\\u00a0     std::cout << \\\"******** Assembly approach ********\\\" << std::endl;\\n\\u00a0     const std::array<std::string, 3> method_descriptions = {\\n\\u00a0       {\\\"Unassisted implementation (full hand linearization).\\\",\\n\\u00a0        \\\"Automated linearization of the finite element residual.\\\",\\n\\u00a0        \\\"Automated computation of finite element residual and linearization using a variational formulation.\\\"}};\\n\\u00a0     AssertIndexRange(formulation, method_descriptions.size());\\n\\u00a0     std::cout << method_descriptions[formulation] << std::endl << std::endl;\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     TimerOutput timer(std::cout, TimerOutput::summary, TimerOutput::wall_times);\\n\\u00a0 \\n\\u00a0     GridGenerator::hyper_ball(triangulation);\\n\\u00a0     triangulation.refine_global(2);\\n\\u00a0 \\n\\u00a0     setup_system();\\n\\u00a0     nonzero_constraints.distribute(current_solution);\\n\\u00a0 \\n\\u00a0     double       last_residual_norm = std::numeric_limits<double>::max();\\n\\u00a0     unsigned int refinement_cycle   = 0;\\n\\u00a0     do\\n\\u00a0       {\\n\\u00a0         std::cout << \\\"Mesh refinement step \\\" << refinement_cycle << std::endl;\\n\\u00a0 \\n\\u00a0         if (refinement_cycle != 0)\\n\\u00a0           refine_mesh();\\n\\u00a0 \\n\\u00a0         std::cout << \\\"  Initial residual: \\\" << compute_residual(0) << std::endl;\\n\\u00a0 \\n\\u00a0         for (unsigned int inner_iteration = 0; inner_iteration < 5;\\n\\u00a0              ++inner_iteration)\\n\\u00a0           {\\n\\u00a0             {\\n\\u00a0               TimerOutput::Scope t(timer, \\\"Assemble\\\");\\n\\u00a0 \\n\\u00a0               if (formulation == 0)\\n\\u00a0                 assemble_system_unassisted();\\n\\u00a0               else if (formulation == 1)\\n\\u00a0                 assemble_system_with_residual_linearization();\\n\\u00a0               else if (formulation == 2)\\n\\u00a0                 assemble_system_using_energy_functional();\\n\\u00a0               else\\n\\u00a0                 AssertThrow(false, ExcNotImplemented());\\n\\u00a0             }\\n\\u00a0 \\n\\u00a0             last_residual_norm = system_rhs.l2_norm();\\n\\u00a0 \\n\\u00a0             {\\n\\u00a0               TimerOutput::Scope t(timer, \\\"Solve\\\");\\n\\u00a0               solve();\\n\\u00a0             }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0             std::cout << \\\"  Residual: \\\" << compute_residual(0) << std::endl;\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         output_results(refinement_cycle);\\n\\u00a0 \\n\\u00a0         ++refinement_cycle;\\n\\u00a0         std::cout << std::endl;\\n\\u00a0       }\\n\\u00a0     while (last_residual_norm > tolerance);\\n\\u00a0   }\\n\\u00a0 } // namespace Step72\\n\\u00a0 \\nTimerOutput::ScopeDefinition timer.h:557\\nTimerOutputDefinition timer.h:549\\nTimerOutput::wall_times@ wall_timesDefinition timer.h:651\\nTimerOutput::summary@ summaryDefinition timer.h:607\\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nAssertIndexRange#define AssertIndexRange(index, range)Definition exceptions.h:2053\\nAssertThrow#define AssertThrow(cond, exc)Definition exceptions.h:1739\\nGridGenerator::hyper_ballvoid hyper_ball(Triangulation< dim > &tria, const Point< dim > &center=Point< dim >(), const double radius=1., const bool attach_spherical_manifold_on_boundary_cells=false)\\n The main function\\nFinally the main function. This follows the scheme of most other main functions, with two obvious exceptions:\\nWe call Utilities::MPI::MPI_InitFinalize in order to set up (via a hidden default parameter) the number of threads using the execution of multithreaded tasks.\\nWe also have a few lines dedicates to reading in or initializing the user-defined parameters that will be considered during the execution of the program.\\n\\n\\u00a0 int main(int argc, char *argv[])\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       using namespace Step72;\\n\\u00a0 \\n\\u00a0       Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv);\\n\\u00a0 \\n\\u00a0       std::string prm_file;\\n\\u00a0       if (argc > 1)\\n\\u00a0         prm_file = argv[1];\\n\\u00a0       else\\n\\u00a0         prm_file = \\\"parameters.prm\\\";\\n\\u00a0 \\n\\u00a0       const MinimalSurfaceProblemParameters parameters;\\n\\u00a0       ParameterAcceptor::initialize(prm_file);\\n\\u00a0 \\n\\u00a0       MinimalSurfaceProblem<2> minimal_surface_problem_2d;\\n\\u00a0       minimal_surface_problem_2d.run(parameters.formulation,\\n\\u00a0                                      parameters.tolerance);\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0 \\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   return 0;\\n\\u00a0 }\\nParameterAcceptor::initializestatic void initialize(const std::string &filename=\\\"\\\", const std::string &output_filename=\\\"\\\", const ParameterHandler::OutputStyle output_style_for_output_filename=ParameterHandler::Short, ParameterHandler &prm=ParameterAcceptor::prm, const ParameterHandler::OutputStyle output_style_for_filename=ParameterHandler::DefaultStyle)Definition parameter_acceptor.cc:80\\nUtilities::MPI::MPI_InitFinalizeDefinition mpi.h:1081\\n Results\\nSince there was no change to the physics of the problem that has first been analyzed in step-15, there is nothing to report about that. The only outwardly noticeable difference between them is that, by default, this program will only run 9 mesh refinement steps (as opposed to step-15, which executes 11 refinements). This will be observable in the simulation status that appears between the header text that prints which assembly method is being used, and the final timings. (All timings reported below were obtained in release mode.)\\nMesh refinement step 0\\n  Initial residual: 1.53143\\n  Residual: 1.08746\\n  Residual: 0.966748\\n  Residual: 0.859602\\n  Residual: 0.766462\\n  Residual: 0.685475\\n \\n...\\n \\nMesh refinement step 9\\n  Initial residual: 0.00924594\\n  Residual: 0.00831928\\n  Residual: 0.0074859\\n  Residual: 0.0067363\\n  Residual: 0.00606197\\n  Residual: 0.00545529\\nSo what is interesting for us to compare is how long the assembly process takes for the three different implementations, and to put that into some greater context. Below is the output for the hand linearization (as computed on a circa 2012 four core, eight thread laptop \\u2013 but we're only really interested in the relative time between the different implementations):          Assembly approach ********\\nUnassisted implementation (full hand linearization).\\n \\n...\\n \\n+---------------------------------------------+------------+------------+\\n| Total wallclock time elapsed since start    |      35.1s |            |\\n|                                             |            |            |\\n| Section                         | no. calls |  wall time | % of total |\\n+---------------------------------+-----------+------------+------------+\\n| Assemble                        |        50 |      1.56s |       4.5% |\\n| Solve                           |        50 |      30.8s |        88% |\\n+---------------------------------+-----------+------------+------------+\\n And for the implementation that linearizes the residual in an automated manner using the Sacado dynamic forward AD number type:          Assembly approach ********\\nAutomated linearization of the finite element residual.\\n \\n...\\n \\n+---------------------------------------------+------------+------------+\\n| Total wallclock time elapsed since start    |      40.1s |            |\\n|                                             |            |            |\\n| Section                         | no. calls |  wall time | % of total |\\n+---------------------------------+-----------+------------+------------+\\n| Assemble                        |        50 |       8.8s |        22% |\\n| Solve                           |        50 |      28.6s |        71% |\\n+---------------------------------+-----------+------------+------------+\\n And, lastly, for the implementation that computes both the residual and its linearization directly from an energy functional (using nested Sacado dynamic forward AD numbers):          Assembly approach ********\\nAutomated computation of finite element residual and linearization using a variational formulation.\\n \\n...\\n \\n+---------------------------------------------+------------+------------+\\n| Total wallclock time elapsed since start    |      48.8s |            |\\n|                                             |            |            |\\n| Section                         | no. calls |  wall time | % of total |\\n+---------------------------------+-----------+------------+------------+\\n| Assemble                        |        50 |      16.7s |        34% |\\n| Solve                           |        50 |      29.3s |        60% |\\n+---------------------------------+-----------+------------+------------+\\nIt's evident that the more work that is passed off to the automatic differentiation framework to perform, the more time is spent during the assembly process. Accumulated over all refinement steps, using one level of automatic differentiation resulted in \\\\(5.65 \\\\times\\\\) more computational time being spent in the assembly stage when compared to unassisted assembly, while assembling the discrete linear system took \\\\(10.7 \\\\times\\\\) longer when deriving directly from the energy functional. Unsurprisingly, the overall time spent solving the linear system remained unchanged. This means that the proportion of time spent in the solve phase to the assembly phase shifted significantly as the number of times automated differentiation was performed at the finite element level. For many, this might mean that leveraging higher-order differentiation (at the finite element level) in production code leads to an unacceptable overhead, but it may still be useful during the prototyping phase. A good compromise between the two may, therefore, be the automated linearization of the finite element residual, which offers a lot of convenience at a measurable, but perhaps not unacceptable, cost. Alternatively, one could consider not re-building the Newton matrix in every step \\u2013 a topic that is explored in substantial depth in step-77.\\nOf course, in practice the actual overhead is very much dependent on the problem being evaluated (e.g., how many components there are in the solution, what the nature of the function being differentiated is, etc.). So the exact results presented here should be interpreted within the context of this scalar problem alone, and when it comes to other problems, some preliminary investigation by the user is certainly warranted.\\nPossibilities for extensions \\nLike step-71, there are a few items related to automatic differentiation that could be evaluated further:\\nThe use of other AD frameworks should be investigated, with the outlook that alternative implementations may provide performance benefits.\\nIt is also worth evaluating AD number types other than those that have been hard-coded into this tutorial. With regard to twice differentiable types employed at the finite-element level, mixed differentiation modes (\\\"RAD-FAD\\\") should in principle be more computationally efficient than the single mode (\\\"FAD-FAD\\\") types employed here. The reason that the RAD-FAD type was not selected by default is that, at the time of writing, there remain some bugs in its implementation within the Sacado library that lead to memory leaks. This is documented in the Automatic and symbolic differentiation topic.\\nIt might be the case that using reduced precision types (i.e., float) as the scalar types for the AD numbers could render a reduction in computational expense during assembly. Using float as the data type for the matrix and the residual is not unreasonable, given that the Newton update is only meant to get us closer to the solution, but not actually to the solution; as a consequence, it makes sense to consider using reduced-precision data types for computing these updates, and then accumulating these updates in a solution vector that uses the full double precision accuracy.\\nOne further method of possibly reducing resources during assembly is to frame the AD implementations as a constitutive model. This would be similar to the approach adopted in step-71, and pushes the starting point for the automatic differentiation one level higher up the chain of computations. This, in turn, means that less operations are tracked by the AD library, thereby reducing the cost of differentiating (even though one would perform the differentiation at each cell quadrature point).\\nstep-77 is yet another variation of step-15 that addresses a very different part of the problem: Line search and whether it is necessary to re-build the Newton matrix in every nonlinear iteration. Given that the results above show that using automatic differentiation comes at a cost, the techniques in step-77 have the potential to offset these costs to some degree. It would therefore be quite interesting to combine the current program with the techniques in step-77. For production codes, this would certainly be the way to go.\\n\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2021 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Authors: Jean-Paul Pelteret,\\n *          Wolfgang Bangerth, Colorado State University, 2021.\\n * Based on @ref step_15 \\\"step-15\\\", authored by Sven Wetterauer, University of Heidelberg, 2012\\n */\\n \\n \\n \\n \\n \\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/function.h>\\n#include <deal.II/base/parameter_acceptor.h>\\n#include <deal.II/base/timer.h>\\n#include <deal.II/base/utilities.h>\\n \\n#include <deal.II/differentiation/ad.h>\\n \\n#include <deal.II/lac/vector.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/precondition.h>\\n#include <deal.II/lac/affine_constraints.h>\\n \\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_refinement.h>\\n \\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/fe/fe_values.h>\\n#include <deal.II/fe/fe_values_extractors.h>\\n#include <deal.II/fe/fe_q.h>\\n \\n#include <deal.II/meshworker/copy_data.h>\\n#include <deal.II/meshworker/mesh_loop.h>\\n#include <deal.II/meshworker/scratch_data.h>\\n \\n#include <deal.II/numerics/vector_tools.h>\\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/error_estimator.h>\\n \\n \\n#include <fstream>\\n#include <iostream>\\n \\n#include <deal.II/numerics/solution_transfer.h>\\n \\nnamespace Step72\\n{\\n using namespace dealii;\\n \\n \\n class MinimalSurfaceProblemParameters : public ParameterAcceptor\\n  {\\n public:\\n    MinimalSurfaceProblemParameters();\\n \\n unsigned int formulation = 0;\\n \\n double tolerance = 1e-2;\\n  };\\n \\n \\n  MinimalSurfaceProblemParameters::MinimalSurfaceProblemParameters()\\n    : ParameterAcceptor(\\\"Minimal Surface Problem/\\\")\\n  {\\n    add_parameter(\\n \\\"Formulation\\\", formulation, \\\"\\\", this->prm, Patterns::Integer(0, 2));\\n    add_parameter(\\\"Tolerance\\\", tolerance, \\\"\\\", this->prm, Patterns::Double(0.0));\\n  }\\n \\n \\n \\n \\n \\n template <int dim>\\n class MinimalSurfaceProblem\\n  {\\n public:\\n    MinimalSurfaceProblem();\\n \\n void run(const int formulation, const double tolerance);\\n \\n private:\\n void   setup_system();\\n void   assemble_system_unassisted();\\n void   assemble_system_with_residual_linearization();\\n void   assemble_system_using_energy_functional();\\n void   solve();\\n void   refine_mesh();\\n double compute_residual(const double alpha) const;\\n double determine_step_length() const;\\n void   output_results(const unsigned int refinement_cycle) const;\\n \\n Triangulation<dim> triangulation;\\n \\n DoFHandler<dim>   dof_handler;\\n const FE_Q<dim>   fe;\\n const QGauss<dim> quadrature_formula;\\n \\n AffineConstraints<double> nonzero_constraints;\\n AffineConstraints<double> zero_constraints;\\n \\n SparsityPattern      sparsity_pattern;\\n SparseMatrix<double> system_matrix;\\n \\n Vector<double> current_solution;\\n Vector<double> newton_update;\\n Vector<double> system_rhs;\\n  };\\n \\n \\n template <int dim>\\n class BoundaryValues : public Function<dim>\\n  {\\n public:\\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n  };\\n \\n \\n template <int dim>\\n double BoundaryValues<dim>::value(const Point<dim> &p,\\n const unsigned int /*component*/) const\\n {\\n return std::sin(2 * numbers::PI * (p[0] + p[1]));\\n  }\\n \\n \\n \\n \\n template <int dim>\\n  MinimalSurfaceProblem<dim>::MinimalSurfaceProblem()\\n    : dof_handler(triangulation)\\n    , fe(2)\\n    , quadrature_formula(fe.degree + 1)\\n  {}\\n \\n \\n \\n template <int dim>\\n void MinimalSurfaceProblem<dim>::setup_system()\\n  {\\n    dof_handler.distribute_dofs(fe);\\n    current_solution.reinit(dof_handler.n_dofs());\\n    newton_update.reinit(dof_handler.n_dofs());\\n    system_rhs.reinit(dof_handler.n_dofs());\\n \\n    zero_constraints.clear();\\n VectorTools::interpolate_boundary_values(dof_handler,\\n                                             0,\\n Functions::ZeroFunction<dim>(),\\n                                             zero_constraints);\\n DoFTools::make_hanging_node_constraints(dof_handler, zero_constraints);\\n    zero_constraints.close();\\n \\n    nonzero_constraints.clear();\\n VectorTools::interpolate_boundary_values(dof_handler,\\n                                             0,\\n                                             BoundaryValues<dim>(),\\n                                             nonzero_constraints);\\n    nonzero_constraints.close();\\n \\n DynamicSparsityPattern dsp(dof_handler.n_dofs());\\n DoFTools::make_sparsity_pattern(dof_handler, dsp, zero_constraints);\\n \\n    sparsity_pattern.copy_from(dsp);\\n    system_matrix.reinit(sparsity_pattern);\\n  }\\n \\n \\n \\n template <int dim>\\n void MinimalSurfaceProblem<dim>::assemble_system_unassisted()\\n  {\\n    system_matrix = 0;\\n    system_rhs    = 0;\\n \\n const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n \\n using ScratchData = MeshWorker::ScratchData<dim>;\\n using CopyData    = MeshWorker::CopyData<1, 1, 1>;\\n \\n using CellIteratorType = decltype(dof_handler.begin_active());\\n \\n const ScratchData sample_scratch_data(fe,\\n                                          quadrature_formula,\\n update_gradients |\\n update_quadrature_points |\\n update_JxW_values);\\n const CopyData    sample_copy_data(dofs_per_cell);\\n \\n const auto cell_worker = [this](const CellIteratorType &cell,\\n                                    ScratchData            &scratch_data,\\n                                    CopyData               &copy_data) {\\n const auto &fe_values = scratch_data.reinit(cell);\\n \\n FullMatrix<double>                   &cell_matrix = copy_data.matrices[0];\\n Vector<double>                       &cell_rhs    = copy_data.vectors[0];\\n      std::vector<types::global_dof_index> &local_dof_indices =\\n        copy_data.local_dof_indices[0];\\n      cell->get_dof_indices(local_dof_indices);\\n \\n      std::vector<Tensor<1, dim>> old_solution_gradients(\\n        fe_values.n_quadrature_points);\\n      fe_values.get_function_gradients(current_solution,\\n                                       old_solution_gradients);\\n \\n for (const unsigned int q : fe_values.quadrature_point_indices())\\n        {\\n const double coeff =\\n            1.0 / std::sqrt(1.0 + old_solution_gradients[q] *\\n                                    old_solution_gradients[q]);\\n \\n for (const unsigned int i : fe_values.dof_indices())\\n            {\\n for (const unsigned int j : fe_values.dof_indices())\\n cell_matrix(i, j) +=\\n                  (((fe_values.shape_grad(i, q)      // ((\\\\nabla \\\\phi_i\\n                     * coeff                         //   * a_n\\n                     * fe_values.shape_grad(j, q))   //   * \\\\nabla \\\\phi_j)\\n                    -                                //  -\\n                    (fe_values.shape_grad(i, q)      //  (\\\\nabla \\\\phi_i\\n                     * coeff * coeff * coeff         //   * a_n^3\\n                     * (fe_values.shape_grad(j, q)   //   * (\\\\nabla \\\\phi_j\\n                        * old_solution_gradients[q]) //      * \\\\nabla u_n)\\n                     * old_solution_gradients[q]))   //   * \\\\nabla u_n)))\\n                   * fe_values.JxW(q));              // * dx\\n \\n              cell_rhs(i) -= (fe_values.shape_grad(i, q)  // \\\\nabla \\\\phi_i\\n                              * coeff                     // * a_n\\n                              * old_solution_gradients[q] // * \\\\nabla u_n\\n                              * fe_values.JxW(q));        // * dx\\n            }\\n        }\\n    };\\n \\n const auto copier = [this](const CopyData &copy_data) {\\n const FullMatrix<double> &cell_matrix = copy_data.matrices[0];\\n const Vector<double>     &cell_rhs    = copy_data.vectors[0];\\n const std::vector<types::global_dof_index> &local_dof_indices =\\n        copy_data.local_dof_indices[0];\\n \\n      zero_constraints.distribute_local_to_global(\\n        cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);\\n    };\\n \\n MeshWorker::mesh_loop(dof_handler.active_cell_iterators(),\\n                          cell_worker,\\n                          copier,\\n                          sample_scratch_data,\\n                          sample_copy_data,\\n MeshWorker::assemble_own_cells);\\n  }\\n \\n \\n template <int dim>\\n void MinimalSurfaceProblem<dim>::assemble_system_with_residual_linearization()\\n  {\\n    system_matrix = 0;\\n    system_rhs    = 0;\\n \\n const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n \\n using ScratchData      = MeshWorker::ScratchData<dim>;\\n using CopyData         = MeshWorker::CopyData<1, 1, 1>;\\n using CellIteratorType = decltype(dof_handler.begin_active());\\n \\n const ScratchData sample_scratch_data(fe,\\n                                          quadrature_formula,\\n update_gradients |\\n update_quadrature_points |\\n update_JxW_values);\\n const CopyData    sample_copy_data(dofs_per_cell);\\n \\n using ADHelper = Differentiation::AD::ResidualLinearization<\\n Differentiation::AD::NumberTypes::sacado_dfad,\\n double>;\\n using ADNumberType = typename ADHelper::ad_type;\\n \\n const FEValuesExtractors::Scalar u_fe(0);\\n \\n const auto cell_worker = [&u_fe, this](const CellIteratorType &cell,\\n                                           ScratchData            &scratch_data,\\n                                           CopyData               &copy_data) {\\n const auto        &fe_values     = scratch_data.reinit(cell);\\n const unsigned int dofs_per_cell = fe_values.get_fe().n_dofs_per_cell();\\n \\n FullMatrix<double>                   &cell_matrix = copy_data.matrices[0];\\n Vector<double>                       &cell_rhs    = copy_data.vectors[0];\\n      std::vector<types::global_dof_index> &local_dof_indices =\\n        copy_data.local_dof_indices[0];\\n      cell->get_dof_indices(local_dof_indices);\\n \\n const unsigned int n_independent_variables = local_dof_indices.size();\\n const unsigned int n_dependent_variables   = dofs_per_cell;\\n      ADHelper ad_helper(n_independent_variables, n_dependent_variables);\\n \\n      ad_helper.register_dof_values(current_solution, local_dof_indices);\\n \\n const std::vector<ADNumberType> &dof_values_ad =\\n        ad_helper.get_sensitive_dof_values();\\n \\n      std::vector<Tensor<1, dim, ADNumberType>> old_solution_gradients(\\n        fe_values.n_quadrature_points);\\n      fe_values[u_fe].get_function_gradients_from_local_dof_values(\\n        dof_values_ad, old_solution_gradients);\\n \\n      std::vector<ADNumberType> residual_ad(n_dependent_variables,\\n                                            ADNumberType(0.0));\\n for (const unsigned int q : fe_values.quadrature_point_indices())\\n        {\\n const ADNumberType coeff =\\n            1.0 / std::sqrt(1.0 + old_solution_gradients[q] *\\n                                    old_solution_gradients[q]);\\n \\n for (const unsigned int i : fe_values.dof_indices())\\n            {\\n              residual_ad[i] += (fe_values.shape_grad(i, q)   // \\\\nabla \\\\phi_i\\n                                 * coeff                      // * a_n\\n                                 * old_solution_gradients[q]) // * \\\\nabla u_n\\n                                * fe_values.JxW(q);           // * dx\\n            }\\n        }\\n \\n      ad_helper.register_residual_vector(residual_ad);\\n \\n      ad_helper.compute_residual(cell_rhs);\\n      cell_rhs *= -1.0;\\n \\n      ad_helper.compute_linearization(cell_matrix);\\n    };\\n \\n const auto copier = [this](const CopyData &copy_data) {\\n const FullMatrix<double> &cell_matrix = copy_data.matrices[0];\\n const Vector<double>     &cell_rhs    = copy_data.vectors[0];\\n const std::vector<types::global_dof_index> &local_dof_indices =\\n        copy_data.local_dof_indices[0];\\n \\n      zero_constraints.distribute_local_to_global(\\n        cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);\\n    };\\n \\n MeshWorker::mesh_loop(dof_handler.active_cell_iterators(),\\n                          cell_worker,\\n                          copier,\\n                          sample_scratch_data,\\n                          sample_copy_data,\\n MeshWorker::assemble_own_cells);\\n  }\\n \\n \\n template <int dim>\\n void MinimalSurfaceProblem<dim>::assemble_system_using_energy_functional()\\n  {\\n    system_matrix = 0;\\n    system_rhs    = 0;\\n \\n const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n \\n using ScratchData      = MeshWorker::ScratchData<dim>;\\n using CopyData         = MeshWorker::CopyData<1, 1, 1>;\\n using CellIteratorType = decltype(dof_handler.begin_active());\\n \\n const ScratchData sample_scratch_data(fe,\\n                                          quadrature_formula,\\n update_gradients |\\n update_quadrature_points |\\n update_JxW_values);\\n const CopyData    sample_copy_data(dofs_per_cell);\\n \\n using ADHelper = Differentiation::AD::EnergyFunctional<\\n Differentiation::AD::NumberTypes::sacado_dfad_dfad,\\n double>;\\n using ADNumberType = typename ADHelper::ad_type;\\n \\n const FEValuesExtractors::Scalar u_fe(0);\\n \\n const auto cell_worker = [&u_fe, this](const CellIteratorType &cell,\\n                                           ScratchData            &scratch_data,\\n                                           CopyData               &copy_data) {\\n const auto &fe_values = scratch_data.reinit(cell);\\n \\n FullMatrix<double>                   &cell_matrix = copy_data.matrices[0];\\n Vector<double>                       &cell_rhs    = copy_data.vectors[0];\\n      std::vector<types::global_dof_index> &local_dof_indices =\\n        copy_data.local_dof_indices[0];\\n      cell->get_dof_indices(local_dof_indices);\\n \\n const unsigned int n_independent_variables = local_dof_indices.size();\\n      ADHelper           ad_helper(n_independent_variables);\\n \\n      ad_helper.register_dof_values(current_solution, local_dof_indices);\\n \\n const std::vector<ADNumberType> &dof_values_ad =\\n        ad_helper.get_sensitive_dof_values();\\n \\n      std::vector<Tensor<1, dim, ADNumberType>> old_solution_gradients(\\n        fe_values.n_quadrature_points);\\n      fe_values[u_fe].get_function_gradients_from_local_dof_values(\\n        dof_values_ad, old_solution_gradients);\\n \\n      ADNumberType energy_ad = ADNumberType(0.0);\\n for (const unsigned int q : fe_values.quadrature_point_indices())\\n        {\\n const ADNumberType psi = std::sqrt(1.0 + old_solution_gradients[q] *\\n                                                     old_solution_gradients[q]);\\n \\n          energy_ad += psi * fe_values.JxW(q);\\n        }\\n \\n      ad_helper.register_energy_functional(energy_ad);\\n \\n      ad_helper.compute_residual(cell_rhs);\\n      cell_rhs *= -1.0;\\n \\n      ad_helper.compute_linearization(cell_matrix);\\n    };\\n \\n const auto copier = [this](const CopyData &copy_data) {\\n const FullMatrix<double> &cell_matrix = copy_data.matrices[0];\\n const Vector<double>     &cell_rhs    = copy_data.vectors[0];\\n const std::vector<types::global_dof_index> &local_dof_indices =\\n        copy_data.local_dof_indices[0];\\n \\n      zero_constraints.distribute_local_to_global(\\n        cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);\\n    };\\n \\n MeshWorker::mesh_loop(dof_handler.active_cell_iterators(),\\n                          cell_worker,\\n                          copier,\\n                          sample_scratch_data,\\n                          sample_copy_data,\\n MeshWorker::assemble_own_cells);\\n  }\\n \\n \\n \\n template <int dim>\\n void MinimalSurfaceProblem<dim>::solve()\\n  {\\n SolverControl            solver_control(system_rhs.size(),\\n                                 system_rhs.l2_norm() * 1e-6);\\n SolverCG<Vector<double>> solver(solver_control);\\n \\n PreconditionSSOR<SparseMatrix<double>> preconditioner;\\n    preconditioner.initialize(system_matrix, 1.2);\\n \\n    solver.solve(system_matrix, newton_update, system_rhs, preconditioner);\\n \\n    zero_constraints.distribute(newton_update);\\n \\n const double alpha = determine_step_length();\\n    current_solution.add(alpha, newton_update);\\n  }\\n \\n \\n \\n template <int dim>\\n void MinimalSurfaceProblem<dim>::refine_mesh()\\n  {\\n Vector<float> estimated_error_per_cell(triangulation.n_active_cells());\\n \\n KellyErrorEstimator<dim>::estimate(\\n      dof_handler,\\n QGauss<dim - 1>(fe.degree + 1),\\n      std::map<types::boundary_id, const Function<dim> *>(),\\n      current_solution,\\n      estimated_error_per_cell);\\n \\n GridRefinement::refine_and_coarsen_fixed_number(triangulation,\\n                                                    estimated_error_per_cell,\\n                                                    0.3,\\n                                                    0.03);\\n \\n triangulation.prepare_coarsening_and_refinement();\\n \\n SolutionTransfer<dim> solution_transfer(dof_handler);\\n const Vector<double>  coarse_solution = current_solution;\\n    solution_transfer.prepare_for_coarsening_and_refinement(coarse_solution);\\n \\n triangulation.execute_coarsening_and_refinement();\\n \\n    setup_system();\\n \\n    solution_transfer.interpolate(coarse_solution, current_solution);\\n    nonzero_constraints.distribute(current_solution);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n double MinimalSurfaceProblem<dim>::compute_residual(const double alpha) const\\n {\\n Vector<double> residual(dof_handler.n_dofs());\\n \\n Vector<double> evaluation_point(dof_handler.n_dofs());\\n    evaluation_point = current_solution;\\n    evaluation_point.add(alpha, newton_update);\\n \\n FEValues<dim> fe_values(fe,\\n                            quadrature_formula,\\n update_gradients | update_quadrature_points |\\n update_JxW_values);\\n \\n const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n const unsigned int n_q_points    = quadrature_formula.size();\\n \\n Vector<double> cell_residual(dofs_per_cell);\\n    std::vector<Tensor<1, dim>> gradients(n_q_points);\\n \\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n cell_residual = 0;\\n        fe_values.reinit(cell);\\n \\n        fe_values.get_function_gradients(evaluation_point, gradients);\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n          {\\n const double coeff =\\n              1.0 / std::sqrt(1.0 + gradients[q] * gradients[q]);\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n cell_residual(i) -= (fe_values.shape_grad(i, q) // \\\\nabla \\\\phi_i\\n                                   * coeff                    // * a_n\\n                                   * gradients[q]             // * \\\\nabla u_n\\n                                   * fe_values.JxW(q));       // * dx\\n          }\\n \\n        cell->get_dof_indices(local_dof_indices);\\n        zero_constraints.distribute_local_to_global(cell_residual,\\n                                                    local_dof_indices,\\n                                                    residual);\\n      }\\n \\n return residual.l2_norm();\\n  }\\n \\n \\n \\n \\n template <int dim>\\n double MinimalSurfaceProblem<dim>::determine_step_length() const\\n {\\n return 0.1;\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void MinimalSurfaceProblem<dim>::output_results(\\n const unsigned int refinement_cycle) const\\n {\\n DataOut<dim> data_out;\\n \\n    data_out.attach_dof_handler(dof_handler);\\n    data_out.add_data_vector(current_solution, \\\"solution\\\");\\n    data_out.add_data_vector(newton_update, \\\"update\\\");\\n    data_out.build_patches();\\n \\n const std::string filename =\\n \\\"solution-\\\" + Utilities::int_to_string(refinement_cycle, 2) + \\\".vtu\\\";\\n    std::ofstream output(filename);\\n    data_out.write_vtu(output);\\n  }\\n \\n \\n \\n template <int dim>\\n void MinimalSurfaceProblem<dim>::run(const int    formulation,\\n const double tolerance)\\n  {\\n    std::cout << \\\"******** Assembly approach ********\\\" << std::endl;\\n const std::array<std::string, 3> method_descriptions = {\\n      {\\\"Unassisted implementation (full hand linearization).\\\",\\n \\\"Automated linearization of the finite element residual.\\\",\\n \\\"Automated computation of finite element residual and linearization using a variational formulation.\\\"}};\\n AssertIndexRange(formulation, method_descriptions.size());\\n    std::cout << method_descriptions[formulation] << std::endl << std::endl;\\n \\n \\n TimerOutput timer(std::cout, TimerOutput::summary, TimerOutput::wall_times);\\n \\n GridGenerator::hyper_ball(triangulation);\\n triangulation.refine_global(2);\\n \\n    setup_system();\\n    nonzero_constraints.distribute(current_solution);\\n \\n double       last_residual_norm = std::numeric_limits<double>::max();\\n unsigned int refinement_cycle   = 0;\\n do\\n      {\\n        std::cout << \\\"Mesh refinement step \\\" << refinement_cycle << std::endl;\\n \\n if (refinement_cycle != 0)\\n          refine_mesh();\\n \\n        std::cout << \\\"  Initial residual: \\\" << compute_residual(0) << std::endl;\\n \\n for (unsigned int inner_iteration = 0; inner_iteration < 5;\\n             ++inner_iteration)\\n          {\\n            {\\n TimerOutput::Scope t(timer, \\\"Assemble\\\");\\n \\n if (formulation == 0)\\n                assemble_system_unassisted();\\n else if (formulation == 1)\\n                assemble_system_with_residual_linearization();\\n else if (formulation == 2)\\n                assemble_system_using_energy_functional();\\n else\\n AssertThrow(false, ExcNotImplemented());\\n            }\\n \\n            last_residual_norm = system_rhs.l2_norm();\\n \\n            {\\n TimerOutput::Scope t(timer, \\\"Solve\\\");\\n              solve();\\n            }\\n \\n \\n            std::cout << \\\"  Residual: \\\" << compute_residual(0) << std::endl;\\n          }\\n \\n        output_results(refinement_cycle);\\n \\n        ++refinement_cycle;\\n        std::cout << std::endl;\\n      }\\n while (last_residual_norm > tolerance);\\n  }\\n} // namespace Step72\\n \\n \\nint main(int argc, char *argv[])\\n{\\n try\\n    {\\n using namespace Step72;\\n \\n Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv);\\n \\n      std::string prm_file;\\n if (argc > 1)\\n        prm_file = argv[1];\\n else\\n        prm_file = \\\"parameters.prm\\\";\\n \\n const MinimalSurfaceProblemParameters parameters;\\n ParameterAcceptor::initialize(prm_file);\\n \\n      MinimalSurfaceProblem<2> minimal_surface_problem_2d;\\n      minimal_surface_problem_2d.run(parameters.formulation,\\n                                     parameters.tolerance);\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n \\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n return 0;\\n}\\nad.h\\naffine_constraints.h\\nDataOutInterface::write_vtuvoid write_vtu(std::ostream &out) constDefinition data_out_base.cc:7692\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\ncopy_data.h\\ndof_handler.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nerror_estimator.h\\nfe_values.h\\nfe_q.h\\nfe_values_extractors.h\\nfull_matrix.h\\nfunction.h\\ngrid_refinement.h\\ntria.h\\ngrid_generator.h\\nutilities.h\\nmesh_loop.h\\nEvaluationFlags::gradients@ gradientsDefinition evaluation_flags.h:54\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\nLocalIntegrators::Advection::cell_residualvoid cell_residual(Vector< double > &result, const FEValuesBase< dim > &fe, const std::vector< Tensor< 1, dim > > &input, const ArrayView< const std::vector< double > > &velocity, double factor=1.)Definition advection.h:130\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\ndata_out.h\\nsolution_transfer.h\\nparameter_acceptor.h\\nprecondition.h\\nquadrature_lib.h\\nscratch_data.h\\nsolver_cg.h\\nsparse_matrix.h\\ntimer.h\\nvector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"