"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_38.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-38 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-38 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-38 tutorial program\\n\\n\\nThis tutorial depends on step-34.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\nTestcase\\nImplementation\\n\\n The commented program\\n\\nInclude files\\nThe LaplaceBeltramiProblem class template\\nEquation data\\nImplementation of the LaplaceBeltramiProblem class\\n\\nLaplaceBeltramiProblem::make_grid_and_dofs\\nLaplaceBeltramiProblem::assemble_system\\nLaplaceBeltramiProblem::solve\\nLaplaceBeltramiProblem::output_result\\nLaplaceBeltramiProblem::compute_error\\nLaplaceBeltramiProblem::run\\n\\nThe main() function\\n\\n\\n Results\\n\\nPossibilities for extensions\\n\\n The plain program\\n   \\n\\n\\nThis program was contributed by Andrea Bonito and M. Sebastian Pauletti, with editing and writing by Wolfgang Bangerth. \\n This material is based upon work supported by the National Science Foundation under Grant No. DMS-0914977. Any opinions, findings and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation (NSF). \\n\\nIntroduction\\nIn this example, we show how to solve a partial differential equation (PDE) on a codimension one surface \\\\(\\\\Gamma \\\\subset \\\\mathbb R^3\\\\) made of quadrilaterals, i.e. on a surface in 3d or a line in 2d. We focus on the following elliptic second order PDE    \\n\\\\begin{align*}\\n-\\\\Delta_\\\\Gamma u &= f \\\\qquad \\\\text{on } \\\\qquad \\\\Gamma,\\\\\\\\\\nu  &= g \\\\qquad \\\\text{on} \\\\qquad \\\\partial \\\\Gamma,\\n\\\\end{align*}\\n\\n which generalized the Laplace equation we have previously solved in several of the early tutorial programs. Our implementation is based on step-4. step-34 also solves problems on lower dimensional surfaces; however, there we only consider integral equations that do not involve derivatives on the solution variable, while here we actually have to investigate what it means to take derivatives of a function only defined on a (possibly curved) surface.\\nIn order to define the above operator, we start by introducing some notations. Let \\\\(\\\\mathbf x_S:\\\\hat S \\\\rightarrow S\\\\) be a parameterization of a surface \\\\(S\\\\) from a reference element \\\\(\\\\hat S \\\\subset \\\\mathbb R^2\\\\), i.e. each point \\\\(\\\\hat{\\\\mathbf x}\\\\in\\\\hat S\\\\) induces a point  \\\\({\\\\mathbf\\n  x}_S(\\\\hat{\\\\mathbf x}) \\\\in S\\\\). Then let   \\n\\\\[\\nG_S\\\\dealcoloneq (D \\\\mathbf{x}_S)^T \\\\ D \\\\mathbf{x}_S\\n\\\\]\\n\\n denotes the corresponding first fundamental form, where  \\\\(D\\n\\\\mathbf{x}_S=\\\\left(\\\\frac{\\\\partial x_{S,i}(\\\\hat{\\\\mathbf x})}{\\\\partial \\\\hat x_j}\\\\right)_{ij}\\\\) is the derivative (Jacobian) of the mapping. In the following, \\\\(S\\\\) will be either the entire surface \\\\(\\\\Gamma\\\\) or, more convenient for the finite element method, any face  \\\\(S \\\\in\\n{\\\\mathbb T}\\\\), where \\\\({\\\\mathbb T}\\\\) is a partition (triangulation) of \\\\(\\\\Gamma\\\\) constituted of quadrilaterals. We are now in position to define the tangential gradient of a function  \\\\(v : S \\\\rightarrow \\\\mathbb\\nR\\\\) by   \\n\\\\[\\n(\\\\nabla_S v)\\\\circ \\\\mathbf x_S \\\\dealcoloneq  D \\\\mathbf x_S \\\\ G_S^{-1} \\\\ \\\\nabla (v \\\\circ \\\\mathbf x_S).\\n\\\\]\\n\\n The surface Laplacian (also called the Laplace-Beltrami operator) is then defined as \\\\(\\\\Delta_S \\\\dealcoloneq \\\\nabla_S \\\\cdot \\\\nabla_S\\\\). Note that an alternate way to compute the surface gradient on smooth surfaces \\\\(\\\\Gamma\\\\) is   \\n\\\\[\\n\\\\nabla_S v = \\\\nabla \\\\tilde v - \\\\mathbf n (\\\\mathbf n \\\\cdot \\\\nabla \\\\tilde v),\\n\\\\]\\n\\n where \\\\(\\\\tilde v\\\\) is a \\\"smooth\\\" extension of \\\\(v\\\\) in a tubular neighborhood of \\\\(\\\\Gamma\\\\) and \\\\(\\\\mathbf n\\\\) is the normal of \\\\(\\\\Gamma\\\\). Since \\\\(\\\\Delta_S = \\\\nabla_S \\\\cdot \\\\nabla_S\\\\), we deduce   \\n\\\\[\\n\\\\Delta_S v = \\\\Delta \\\\tilde v - \\\\mathbf n^T \\\\ D^2 \\\\tilde v \\\\ \\\\mathbf n - (\\\\mathbf n \\\\cdot \\\\nabla \\\\tilde v) (\\\\nabla \\\\cdot \\\\mathbf n - \\\\mathbf n^T \\\\ D \\\\mathbf n \\\\ \\\\mathbf n ).\\n\\\\]\\n\\n Worth mentioning, the term \\\\(\\\\nabla \\\\cdot \\\\mathbf n - \\\\mathbf n \\\\ D \\\\mathbf n \\\\ \\\\mathbf n\\\\) appearing in the above expression is the total curvature of the surface (sum of principal curvatures).\\nAs usual, we are only interested in weak solutions for which we can use \\\\(C^0\\\\) finite elements (rather than requiring \\\\(C^1\\\\) continuity as for strong solutions). We therefore resort to the weak formulation    \\n\\\\[\\n\\\\int_\\\\Gamma \\\\nabla_\\\\Gamma u \\\\cdot\\n\\\\nabla_\\\\Gamma v = \\\\int_\\\\Gamma f \\\\ v  \\\\qquad \\\\forall v \\\\in H^1_0(\\\\Gamma)\\n\\\\]\\n\\n and take advantage of the partition \\\\({\\\\mathbb T}\\\\) to further write    \\n\\\\[\\n\\\\sum_{K\\\\in  {\\\\mathbb T}}\\\\int_K \\\\nabla_{K} u \\\\cdot \\\\nabla_{K} v = \\\\sum_{K\\\\in\\n  {\\\\mathbb T}} \\\\int_K f \\\\ v  \\\\qquad \\\\forall v \\\\in H^1_0(\\\\Gamma).\\n\\\\]\\n\\n Moreover, each integral in the above expression is computed in the reference element \\\\(\\\\hat K \\\\dealcoloneq [0,1]^2\\\\) so that           \\n\\\\begin{align*}\\n\\\\int_{K} \\\\nabla_{K} u \\\\cdot \\\\nabla_{K} v\\n&=\\n\\\\int_{\\\\hat K} \\\\nabla (u \\\\circ \\\\mathbf x_K)^T G_K^{-1} (D \\\\mathbf\\n  x_K)^T D \\\\mathbf x_K G_K^{-1} \\\\nabla (v \\\\circ \\\\mathbf x_K) \\\\sqrt{\\\\det\\n    (G_K)}\\n\\\\\\\\\\n&=\\n\\\\int_{\\\\hat K} \\\\nabla (u \\\\circ \\\\mathbf x_K)^T G_K^{-1} \\\\nabla (v \\\\circ \\\\mathbf x_K) \\\\sqrt{\\\\det\\n    (G_K)}\\n\\\\end{align*}\\n\\n and     \\n\\\\[\\n\\\\int_{K} f \\\\ v = \\\\int_{\\\\hat K} (f \\\\circ \\\\mathbf x_K) (v \\\\circ \\\\mathbf\\nx_K)  \\\\sqrt{\\\\det\\n    (G_K)}.\\n\\\\]\\n\\n Finally, we use a quadrature formula defined by points  \\\\(\\\\{p_l\\\\}_{l=1}^N\\\\subset\\n\\\\hat K\\\\) and weights \\\\(\\\\{w_l\\\\}_{l=1}^N \\\\subset \\\\mathbb R^+_*\\\\) to evaluate the above integrals and obtain    \\n\\\\[\\\\int_{K} \\\\nabla_{K} u \\\\cdot \\\\nabla_{K} v \\\\approx \\\\sum_{l=1}^N\\n (\\\\nabla (u \\\\circ \\\\mathbf x_K)(p_l))^T G^{-1}(p_l)  \\\\nabla (v \\\\circ \\\\mathbf x_K)\\n(p_l) \\\\sqrt{\\\\det (G(p_l))} \\\\ w_l\\n\\\\]\\n\\n and   \\n\\\\[\\n\\\\int_{K} f \\\\ v \\\\approx \\\\sum_{l=1}^N (f \\\\circ \\\\mathbf x_K)(p_l) \\\\ (v \\\\circ \\\\mathbf x_K)(p_l) \\\\sqrt{\\\\det (G(p_l))} \\\\ w_l.\\n\\\\]\\n\\nFortunately, deal.II has already all the tools to compute the above expressions. In fact, they barely differ from the ways in which we solve the usual Laplacian, only requiring the surface coordinate mapping to be provided in the constructor of the FEValues class. The surface description given, in the codimension one case, the two routines we need are the following:\\nFEValues::shape_grad(i,l), which returns \\\\(D \\\\mathbf x_K(p_l) G^{-1}(p_l)D(\\\\varphi_i \\\\circ \\\\mathbf x_K)\\\\)\\nFEValues::JxW(l), which returns \\\\(\\\\sqrt{\\\\det (G(p_l))} \\\\ w_l\\\\). This provides exactly the terms we need for our computations.\\n\\nOn a more general note, details for the finite element approximation on surfaces can be found for instance in [Dziuk, in Partial differential equations and calculus of variations 1357, Lecture Notes in Math., 1988], [Demlow, SIAM J. Numer. Anal. 47(2), 2009] and [Bonito, Nochetto, and Pauletti, SIAM J. Numer. Anal. 48(5), 2010].\\nTestcase\\nIn general when you want to test numerically the accuracy and/or order of convergence of an algorithm you need to provide an exact solution. The usual trick is to pick a function that we want to be the solution, then apply the differential operator to it that defines a forcing term for the right hand side. This is what we do in this example. In the current case, the form of the domain is obviously also essential.\\nWe produce one test case for a 2d problem and another one for 3d:\\n\\n\\nIn 2d, let's choose as domain a half circle. On this domain, we choose the function \\\\(u(\\\\mathbf x)=-2x_1x_2\\\\) as the solution. To compute the right hand side, we have to compute the surface Laplacian of the solution function. There are (at least) two ways to do that. The first one is to project away the normal derivative as described above using the natural extension of \\\\(u(\\\\mathbf x)\\\\) (still denoted by \\\\(u\\\\)) over \\\\(\\\\mathbb R^d\\\\), i.e. to compute   \\n\\\\[\\n    -\\\\Delta_\\\\Gamma u =  \\\\Delta u - \\\\mathbf n^T \\\\ D^2 u \\\\ \\\\mathbf n - (\\\\mathbf n \\\\cdot \\\\nabla u)\\\\ \\\\kappa,\\n  \\\\]\\n\\n where \\\\(\\\\kappa\\\\) is the total curvature of \\\\(\\\\Gamma\\\\). Since we are on the unit circle, \\\\(\\\\mathbf n=\\\\mathbf x\\\\) and \\\\(\\\\kappa = 1\\\\) so that   \\n\\\\[\\n    -\\\\Delta_\\\\Gamma u = -8 x_1x_2.\\n  \\\\]\\n\\nA somewhat simpler way, at least for the current case of a curve in two-dimensional space, is to note that we can map the interval  \\\\(t \\\\in\\n  [0,\\\\pi]\\\\) onto the domain \\\\(\\\\Omega\\\\) using the transformation \\\\(\\\\mathbf x(t)= \\\\left(\\\\begin{array}{c} \\\\cos t \\\\\\\\ \\\\sin t \\\\end{array}\\\\right)\\\\). At position \\\\(\\\\mathbf x=\\\\mathbf x(t)\\\\), the value of the solution is then \\\\(u(\\\\mathbf x(t)) = -2\\\\cos t \\\\sin t\\\\). Taking into account that the transformation is length preserving, i.e. a segment of length \\\\(dt\\\\) is mapped onto a piece of curve of exactly the same length, the tangential Laplacian then satisfies          \\n\\\\begin{align*}\\n    \\\\Delta_\\\\Gamma u\\n    &= \\\\frac{d^2}{dt^2}(-2\\\\cos t \\\\sin t)\\n    = -2 \\\\frac{d}{dt}(-\\\\sin^2 t + \\\\cos^2 t)\\n    = -2 (-2 \\\\sin t \\\\cos t - 2 \\\\cos t \\\\sin t)\\n    \\\\\\\\\\n    &= 8 \\\\sin t \\\\cos t\\n    \\\\\\\\\\n    &= 8 x_1x_2,\\n  \\\\end{align*}\\n\\n which is of course the same result as we had above.  \\n\\n\\nIn 3d, the domain is again half of the surface of the unit ball, i.e. a half sphere or dome. We choose \\\\(u(\\\\mathbf x)=-2\\\\sin(\\\\pi x_1)\\\\cos(\\\\pi x_2)e^{x_3}\\\\) as the solution. We can compute the right hand side of the equation, \\\\(f=-\\\\Delta_\\\\Gamma u\\\\), in the same way as the method above (with \\\\(\\\\kappa = 2\\\\)), yielding an awkward and lengthy expression. You can find the full expression in the source code.  \\n\\nIn the program, we will also compute the \\\\(H^1\\\\) seminorm error of the solution. Since the solution function and its numerical approximation are only defined on the manifold, the obvious definition of this error functional is   \\\\(| e |_{H^1(\\\\Gamma)}\\n  = | \\\\nabla_\\\\Gamma e |_{L_2(\\\\Gamma)}\\n  = \\\\left( \\\\int_\\\\Gamma | \\\\nabla_\\\\Gamma (u-u_h) |^2 \\\\right)^{1/2}\\\\). This requires us to provide the tangential gradient \\\\(\\\\nabla_\\\\Gamma u\\\\) to the function VectorTools::integrate_difference (first introduced in step-7), which we will do by implementing the function Solution::gradient in the program below.\\nImplementation\\nIf you've read through step-4 and understand the discussion above of how solution and right hand side correspond to each other, you will be immediately familiar with this program as well. In fact, there are only two things that are of significance:\\n\\nThe way we generate the mesh that triangulates the computational domain.\\nThe way we use Mapping objects to describe that the domain on which we solve the partial differential equation is not planar but in fact curved.\\n\\nMapping objects were already introduced in step-10 and step-11 and as explained there, there is usually not a whole lot you have to know about how they work as long as you have a working description of how the boundary looks. In essence, we will simply declare an appropriate object of type MappingQ that will automatically obtain the boundary description from the Triangulation. The mapping object will then be passed to the appropriate functions, and we will get a boundary description for half circles or half spheres that is predefined in the library.\\nThe rest of the program follows closely step-4 and, as far as computing the error, step-7. Some aspects of this program, in particular the use of two template arguments on the classes Triangulation, DoFHandler, and similar, are already described in detail in step-34; you may wish to read through this tutorial program as well.\\n The commented program\\n Include files\\nIf you've read through step-4 and step-7, you will recognize that we have used all of the following include files there already. Consequently, we will not explain their meaning here again.\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/vector.h>\\n\\u00a0 #include <deal.II/lac/solver_control.h>\\n\\u00a0 #include <deal.II/lac/solver_cg.h>\\n\\u00a0 #include <deal.II/lac/precondition.h>\\n\\u00a0 #include <deal.II/lac/sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/manifold_lib.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 #include <deal.II/fe/mapping_q.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 #include <deal.II/numerics/matrix_tools.h>\\n\\u00a0 \\n\\u00a0 #include <fstream>\\n\\u00a0 #include <iostream>\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 namespace Step38\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\n The LaplaceBeltramiProblem class template\\nThis class is almost exactly similar to the LaplaceProblem class in step-4.\\nThe essential differences are these:\\n\\nThe template parameter now denotes the dimensionality of the embedding space, which is no longer the same as the dimensionality of the domain and the triangulation on which we compute. We indicate this by calling the parameter spacedim, and introducing a constant dim equal to the dimensionality of the domain \\u2013 here equal to spacedim-1.\\nAll member variables that have geometric aspects now need to know about both their own dimensionality as well as that of the embedding space. Consequently, we need to specify both of their template parameters one for the dimension of the mesh dim, and the other for the dimension of the embedding space, spacedim. This is exactly what we did in step-34, take a look there for a deeper explanation.\\nWe need an object that describes which kind of mapping to use from the reference cell to the cells that the triangulation is composed of. The classes derived from the Mapping base class do exactly this. Throughout most of deal.II, if you don't do anything at all, the library assumes that you want an object of kind MappingQ1 that uses a (bi-, tri-)linear mapping. In many cases, this is quite sufficient, which is why the use of these objects is mostly optional: for example, if you have a polygonal two-dimensional domain in two-dimensional space, a bilinear mapping of the reference cell to the cells of the triangulation yields an exact representation of the domain. If you have a curved domain, one may want to use a higher order mapping for those cells that lie at the boundary of the domain \\u2013 this is what we did in step-11, for example. However, here we have a curved domain, not just a curved boundary, and while we can approximate it with bilinearly mapped cells, it is really only prudent to use a higher order mapping for all cells. Consequently, this class has a member variable of type MappingQ; we will choose the polynomial degree of the mapping equal to the polynomial degree of the finite element used in the computations to ensure optimal approximation, though this iso-parametricity is not required.\\n\\n\\u00a0   template <int spacedim>\\n\\u00a0   class LaplaceBeltramiProblem\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     LaplaceBeltramiProblem(const unsigned degree = 2);\\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     static constexpr unsigned int dim = spacedim - 1;\\n\\u00a0 \\n\\u00a0     void make_grid_and_dofs();\\n\\u00a0     void assemble_system();\\n\\u00a0     void solve();\\n\\u00a0     void output_results() const;\\n\\u00a0     void compute_error() const;\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     Triangulation<dim, spacedim> triangulation;\\n\\u00a0     const FE_Q<dim, spacedim>    fe;\\n\\u00a0     DoFHandler<dim, spacedim>    dof_handler;\\n\\u00a0     MappingQ<dim, spacedim>      mapping;\\n\\u00a0 \\n\\u00a0     SparsityPattern      sparsity_pattern;\\n\\u00a0     SparseMatrix<double> system_matrix;\\n\\u00a0 \\n\\u00a0     Vector<double> solution;\\n\\u00a0     Vector<double> system_rhs;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\nDoFHandlerDefinition dof_handler.h:317\\nFE_QDefinition fe_q.h:554\\nMappingQDefinition mapping_q.h:110\\nSparseMatrixDefinition sparse_matrix.h:520\\nSparsityPatternDefinition sparsity_pattern.h:343\\nTriangulationDefinition tria.h:1323\\nVectorDefinition vector.h:120\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\n Equation data\\nNext, let us define the classes that describe the exact solution and the right hand sides of the problem. This is in analogy to step-4 and step-7 where we also defined such objects. Given the discussion in the introduction, the actual formulas should be self-explanatory. A point of interest may be how we define the value and gradient functions for the 2d and 3d cases separately, using explicit specializations of the general template. An alternative to doing it this way might have been to define the general template and have a switch statement (or a sequence of ifs) for each possible value of the spatial dimension.\\n\\u00a0   template <int dim>\\n\\u00a0   class Solution : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component = 0) const override;\\n\\u00a0 \\n\\u00a0     virtual Tensor<1, dim>\\n\\u00a0     gradient(const Point<dim>  &p,\\n\\u00a0              const unsigned int component = 0) const override;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <>\\n\\u00a0   double Solution<2>::value(const Point<2> &p, const unsigned int) const\\n\\u00a0   {\\n\\u00a0     return (-2. * p[0] * p[1]);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <>\\n\\u00a0   Tensor<1, 2> Solution<2>::gradient(const Point<2> &p,\\n\\u00a0                                      const unsigned int) const\\n\\u00a0   {\\n\\u00a0     Tensor<1, 2> return_value;\\n\\u00a0     return_value[0] = -2. * p[1] * (1 - 2. * p[0] * p[0]);\\n\\u00a0     return_value[1] = -2. * p[0] * (1 - 2. * p[1] * p[1]);\\n\\u00a0 \\n\\u00a0     return return_value;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <>\\n\\u00a0   double Solution<3>::value(const Point<3> &p, const unsigned int) const\\n\\u00a0   {\\n\\u00a0     return (std::sin(numbers::PI * p[0]) * std::cos(numbers::PI * p[1]) *\\n\\u00a0             exp(p[2]));\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <>\\n\\u00a0   Tensor<1, 3> Solution<3>::gradient(const Point<3> &p,\\n\\u00a0                                      const unsigned int) const\\n\\u00a0   {\\n\\u00a0     using numbers::PI;\\n\\u00a0 \\n\\u00a0     Tensor<1, 3> return_value;\\n\\u00a0 \\n\\u00a0     return_value[0] = PI * cos(PI * p[0]) * cos(PI * p[1]) * exp(p[2]);\\n\\u00a0     return_value[1] = -PI * sin(PI * p[0]) * sin(PI * p[1]) * exp(p[2]);\\n\\u00a0     return_value[2] = sin(PI * p[0]) * cos(PI * p[1]) * exp(p[2]);\\n\\u00a0 \\n\\u00a0     return return_value;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   class RightHandSide : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component = 0) const override;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0   template <>\\n\\u00a0   double RightHandSide<2>::value(const Point<2> &p,\\n\\u00a0                                  const unsigned int /*component*/) const\\n\\u00a0   {\\n\\u00a0     return (-8. * p[0] * p[1]);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <>\\n\\u00a0   double RightHandSide<3>::value(const Point<3> &p,\\n\\u00a0                                  const unsigned int /*component*/) const\\n\\u00a0   {\\n\\u00a0     using numbers::PI;\\n\\u00a0 \\n\\u00a0     Tensor<2, 3> hessian;\\n\\u00a0 \\n\\u00a0     hessian[0][0] = -PI * PI * sin(PI * p[0]) * cos(PI * p[1]) * exp(p[2]);\\n\\u00a0     hessian[1][1] = -PI * PI * sin(PI * p[0]) * cos(PI * p[1]) * exp(p[2]);\\n\\u00a0     hessian[2][2] = sin(PI * p[0]) * cos(PI * p[1]) * exp(p[2]);\\n\\u00a0 \\n\\u00a0     hessian[0][1] = -PI * PI * cos(PI * p[0]) * sin(PI * p[1]) * exp(p[2]);\\n\\u00a0     hessian[1][0] = -PI * PI * cos(PI * p[0]) * sin(PI * p[1]) * exp(p[2]);\\n\\u00a0 \\n\\u00a0     hessian[0][2] = PI * cos(PI * p[0]) * cos(PI * p[1]) * exp(p[2]);\\n\\u00a0     hessian[2][0] = PI * cos(PI * p[0]) * cos(PI * p[1]) * exp(p[2]);\\n\\u00a0 \\n\\u00a0     hessian[1][2] = -PI * sin(PI * p[0]) * sin(PI * p[1]) * exp(p[2]);\\n\\u00a0     hessian[2][1] = -PI * sin(PI * p[0]) * sin(PI * p[1]) * exp(p[2]);\\n\\u00a0 \\n\\u00a0     Tensor<1, 3> gradient;\\n\\u00a0     gradient[0] = PI * cos(PI * p[0]) * cos(PI * p[1]) * exp(p[2]);\\n\\u00a0     gradient[1] = -PI * sin(PI * p[0]) * sin(PI * p[1]) * exp(p[2]);\\n\\u00a0     gradient[2] = sin(PI * p[0]) * cos(PI * p[1]) * exp(p[2]);\\n\\u00a0 \\n\\u00a0     Point<3> normal = p;\\n\\u00a0     normal /= p.norm();\\n\\u00a0 \\n\\u00a0     return (-trace(hessian) + 2 * (gradient * normal) +\\n\\u00a0             (hessian * normal) * normal);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nFunctionDefinition function.h:152\\nFunction::gradientvirtual Tensor< 1, dim, RangeNumberType > gradient(const Point< dim > &p, const unsigned int component=0) const\\nFunction::valuevirtual RangeNumberType value(const Point< dim > &p, const unsigned int component=0) const\\nPointDefinition point.h:111\\nTensorDefinition tensor.h:471\\nTensor::normnumbers::NumberTraits< Number >::real_type norm() const\\ninternal::EvaluatorQuantity::hessian@ hessian\\ninternal::EvaluatorQuantity::gradient@ gradient\\nnumbers::PIstatic constexpr double PIDefinition numbers.h:259\\nstd::exp::VectorizedArray< Number, width > exp(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6829\\nstd::cos::VectorizedArray< Number, width > cos(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6609\\nstd::sin::VectorizedArray< Number, width > sin(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6589\\ntraceDEAL_II_HOST constexpr Number trace(const SymmetricTensor< 2, dim2, Number > &)\\n Implementation of the LaplaceBeltramiProblem class\\nThe rest of the program is actually quite unspectacular if you know step-4. Our first step is to define the constructor, setting the polynomial degree of the finite element and mapping, and associating the DoF handler to the triangulation:\\n\\u00a0   template <int spacedim>\\n\\u00a0   LaplaceBeltramiProblem<spacedim>::LaplaceBeltramiProblem(\\n\\u00a0     const unsigned degree)\\n\\u00a0     : fe(degree)\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0     , mapping(degree)\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n LaplaceBeltramiProblem::make_grid_and_dofs\\nThe next step is to create the mesh, distribute degrees of freedom, and set up the various variables that describe the linear system. All of these steps are standard with the exception of how to create a mesh that describes a surface. We could generate a mesh for the domain we are interested in, generate a triangulation using a mesh generator, and read it in using the GridIn class. Or, as we do here, we generate the mesh using the facilities in the GridGenerator namespace.\\nIn particular, what we're going to do is this (enclosed between the set of braces below): we generate a spacedim dimensional mesh for the half disk (in 2d) or half ball (in 3d), using the GridGenerator::half_hyper_ball function. This function sets the boundary indicators of all faces on the outside of the boundary to zero for the ones located on the perimeter of the disk/ball, and one on the straight part that splits the full disk/ball into two halves. The next step is the main point: The GridGenerator::extract_boundary_mesh function creates a mesh that consists of those cells that are the faces of the previous mesh, i.e. it describes the surface cells of the original (volume) mesh. However, we do not want all faces: only those on the perimeter of the disk or ball which carry boundary indicator zero; we can select these cells using a set of boundary indicators that we pass to GridGenerator::extract_boundary_mesh.\\nThere is one point that needs to be mentioned. In order to refine a surface mesh appropriately if the manifold is curved (similarly to refining the faces of cells that are adjacent to a curved boundary), the triangulation has to have an object attached to it that describes where new vertices should be located. If you don't attach such a boundary object, they will be located halfway between existing vertices; this is appropriate if you have a domain with straight boundaries (e.g. a polygon) but not when, as here, the manifold has curvature. So for things to work properly, we need to attach a manifold object to our (surface) triangulation, in much the same way as we've already done in 1d for the boundary. We create such an object and attach it to the triangulation.\\nThe final step in creating the mesh is to refine it a number of times. The rest of the function is the same as in previous tutorial programs.\\n\\u00a0   template <int spacedim>\\n\\u00a0   void LaplaceBeltramiProblem<spacedim>::make_grid_and_dofs()\\n\\u00a0   {\\n\\u00a0     {\\n\\u00a0       Triangulation<spacedim> volume_mesh;\\n\\u00a0       GridGenerator::half_hyper_ball(volume_mesh);\\n\\u00a0 \\n\\u00a0       const std::set<types::boundary_id> boundary_ids = {0};\\n\\u00a0 \\n\\u00a0       GridGenerator::extract_boundary_mesh(volume_mesh,\\n\\u00a0                                            triangulation,\\n\\u00a0                                            boundary_ids);\\n\\u00a0     }\\n\\u00a0     triangulation.set_all_manifold_ids(0);\\n\\u00a0     triangulation.set_manifold(0, SphericalManifold<dim, spacedim>());\\n\\u00a0 \\n\\u00a0     triangulation.refine_global(4);\\n\\u00a0 \\n\\u00a0     std::cout << \\\"Surface mesh has \\\" << triangulation.n_active_cells()\\n\\u00a0               << \\\" cells.\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0 \\n\\u00a0     std::cout << \\\"Surface mesh has \\\" << dof_handler.n_dofs()\\n\\u00a0               << \\\" degrees of freedom.\\\" << std::endl;\\n\\u00a0 \\n\\u00a0     DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());\\n\\u00a0     DoFTools::make_sparsity_pattern(dof_handler, dsp);\\n\\u00a0     sparsity_pattern.copy_from(dsp);\\n\\u00a0 \\n\\u00a0     system_matrix.reinit(sparsity_pattern);\\n\\u00a0 \\n\\u00a0     solution.reinit(dof_handler.n_dofs());\\n\\u00a0     system_rhs.reinit(dof_handler.n_dofs());\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nSphericalManifoldDefinition manifold_lib.h:263\\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\nTriangulation::set_manifoldvoid set_manifold(const types::manifold_id number, const Manifold< dim, spacedim > &manifold_object)\\nTriangulation::set_all_manifold_idsvoid set_all_manifold_ids(const types::manifold_id number)\\nGridGenerator::extract_boundary_meshreturn_type extract_boundary_mesh(const MeshType< dim, spacedim > &volume_mesh, MeshType< dim - 1, spacedim > &surface_mesh, const std::set< types::boundary_id > &boundary_ids=std::set< types::boundary_id >())\\nGridGenerator::half_hyper_ballvoid half_hyper_ball(Triangulation< dim > &tria, const Point< dim > &center=Point< dim >(), const double radius=1.)\\n LaplaceBeltramiProblem::assemble_system\\nThe following is the central function of this program, assembling the matrix that corresponds to the surface Laplacian (Laplace-Beltrami operator). Maybe surprisingly, it actually looks exactly the same as for the regular Laplace operator discussed in, for example, step-4. The key is that the FEValues::shape_grad() function does the magic: It returns the surface gradient \\\\(\\\\nabla_K \\\\phi_i(x_q)\\\\) of the \\\\(i\\\\)th shape function at the \\\\(q\\\\)th quadrature point. The rest then does not need any changes either:\\n\\u00a0   template <int spacedim>\\n\\u00a0   void LaplaceBeltramiProblem<spacedim>::assemble_system()\\n\\u00a0   {\\n\\u00a0     system_matrix = 0;\\n\\u00a0     system_rhs    = 0;\\n\\u00a0 \\n\\u00a0     const QGauss<dim>       quadrature_formula(2 * fe.degree);\\n\\u00a0     FEValues<dim, spacedim> fe_values(mapping,\\n\\u00a0                                       fe,\\n\\u00a0                                       quadrature_formula,\\n\\u00a0                                       update_values | update_gradients |\\n\\u00a0                                         update_quadrature_points |\\n\\u00a0                                         update_JxW_values);\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n\\u00a0     const unsigned int n_q_points    = quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0     Vector<double>     cell_rhs(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     std::vector<double>                  rhs_values(n_q_points);\\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     RightHandSide<spacedim> rhs;\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         cell_matrix = 0;\\n\\u00a0         cell_rhs    = 0;\\n\\u00a0 \\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0 \\n\\u00a0         rhs.value_list(fe_values.get_quadrature_points(), rhs_values);\\n\\u00a0 \\n\\u00a0         for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0           for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0             for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n\\u00a0               cell_matrix(i, j) += fe_values.shape_grad(i, q_point) *\\n\\u00a0                                    fe_values.shape_grad(j, q_point) *\\n\\u00a0                                    fe_values.JxW(q_point);\\n\\u00a0 \\n\\u00a0         for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0           for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n\\u00a0             cell_rhs(i) += fe_values.shape_value(i, q_point) *\\n\\u00a0                            rhs_values[q_point] * fe_values.JxW(q_point);\\n\\u00a0 \\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0         for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0           {\\n\\u00a0             for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0               system_matrix.add(local_dof_indices[i],\\n\\u00a0                                 local_dof_indices[j],\\n\\u00a0                                 cell_matrix(i, j));\\n\\u00a0 \\n\\u00a0             system_rhs(local_dof_indices[i]) += cell_rhs(i);\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     std::map<types::global_dof_index, double> boundary_values;\\n\\u00a0     VectorTools::interpolate_boundary_values(\\n\\u00a0       mapping, dof_handler, 0, Solution<spacedim>(), boundary_values);\\n\\u00a0 \\n\\u00a0     MatrixTools::apply_boundary_values(\\n\\u00a0       boundary_values, system_matrix, solution, system_rhs, false);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nFEValuesDefinition fe_values.h:63\\nFullMatrixDefinition full_matrix.h:79\\nQGaussDefinition quadrature_lib.h:40\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nMatrixTools::apply_boundary_valuesvoid apply_boundary_values(const std::map< types::global_dof_index, number > &boundary_values, SparseMatrix< number > &matrix, Vector< number > &solution, Vector< number > &right_hand_side, const bool eliminate_columns=true)Definition matrix_tools.cc:75\\nVectorTools::interpolate_boundary_valuesvoid interpolate_boundary_values(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const std::map< types::boundary_id, const Function< spacedim, number > * > &function_map, std::map< types::global_dof_index, number > &boundary_values, const ComponentMask &component_mask={})\\n LaplaceBeltramiProblem::solve\\nThe next function is the one that solves the linear system. Here, too, no changes are necessary:\\n\\u00a0   template <int spacedim>\\n\\u00a0   void LaplaceBeltramiProblem<spacedim>::solve()\\n\\u00a0   {\\n\\u00a0     SolverControl solver_control(solution.size(), 1e-7 * system_rhs.l2_norm());\\n\\u00a0     SolverCG<Vector<double>> cg(solver_control);\\n\\u00a0 \\n\\u00a0     PreconditionSSOR<SparseMatrix<double>> preconditioner;\\n\\u00a0     preconditioner.initialize(system_matrix, 1.2);\\n\\u00a0 \\n\\u00a0     cg.solve(system_matrix, solution, system_rhs, preconditioner);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nPreconditionSSORDefinition precondition.h:1778\\nPreconditionSSOR::initializevoid initialize(const MatrixType &A, const AdditionalData &parameters=AdditionalData())\\nSolverCGDefinition solver_cg.h:179\\nSolverControlDefinition solver_control.h:67\\n LaplaceBeltramiProblem::output_result\\nThis is the function that generates graphical output from the solution. Most of it is boilerplate code, but there are two points worth pointing out:\\n\\nThe DataOut::add_data_vector() function can take two kinds of vectors: Either vectors that have one value per degree of freedom defined by the DoFHandler object previously attached via DataOut::attach_dof_handler(); and vectors that have one value for each cell of the triangulation, for example to output estimated errors for each cell. Typically, the DataOut class knows to tell these two kinds of vectors apart: there are almost always more degrees of freedom than cells, so we can differentiate by the two kinds looking at the length of a vector. We could do the same here, but only because we got lucky: we use a half sphere. If we had used the whole sphere as domain and \\\\(Q_1\\\\) elements, we would have the same number of cells as vertices and consequently the two kinds of vectors would have the same number of elements. To avoid the resulting confusion, we have to tell the DataOut::add_data_vector() function which kind of vector we have: DoF data. This is what the third argument to the function does.\\nThe DataOut::build_patches() function can generate output that subdivides each cell so that visualization programs can resolve curved manifolds or higher polynomial degree shape functions better. We here subdivide each element in each coordinate direction as many times as the polynomial degree of the finite element in use.\\n\\n\\u00a0   template <int spacedim>\\n\\u00a0   void LaplaceBeltramiProblem<spacedim>::output_results() const\\n\\u00a0   {\\n\\u00a0     DataOut<dim, spacedim> data_out;\\n\\u00a0     data_out.attach_dof_handler(dof_handler);\\n\\u00a0     data_out.add_data_vector(solution,\\n\\u00a0                              \\\"solution\\\",\\n\\u00a0                              DataOut<dim, spacedim>::type_dof_data);\\n\\u00a0     data_out.build_patches(mapping, mapping.get_degree());\\n\\u00a0 \\n\\u00a0     const std::string filename =\\n\\u00a0       \\\"solution-\\\" + std::to_string(spacedim) + \\\"d.vtk\\\";\\n\\u00a0     std::ofstream output(filename);\\n\\u00a0     data_out.write_vtk(output);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\n LaplaceBeltramiProblem::compute_error\\nThis is the last piece of functionality: we want to compute the error in the numerical solution. It is a verbatim copy of the code previously shown and discussed in step-7. As mentioned in the introduction, the Solution class provides the (tangential) gradient of the solution. To avoid evaluating the error only a superconvergence points, we choose a quadrature rule of sufficiently high order.\\n\\u00a0   template <int spacedim>\\n\\u00a0   void LaplaceBeltramiProblem<spacedim>::compute_error() const\\n\\u00a0   {\\n\\u00a0     Vector<float> difference_per_cell(triangulation.n_active_cells());\\n\\u00a0     VectorTools::integrate_difference(mapping,\\n\\u00a0                                       dof_handler,\\n\\u00a0                                       solution,\\n\\u00a0                                       Solution<spacedim>(),\\n\\u00a0                                       difference_per_cell,\\n\\u00a0                                       QGauss<dim>(2 * fe.degree + 1),\\n\\u00a0                                       VectorTools::H1_norm);\\n\\u00a0 \\n\\u00a0     double h1_error = VectorTools::compute_global_error(triangulation,\\n\\u00a0                                                         difference_per_cell,\\n\\u00a0                                                         VectorTools::H1_norm);\\n\\u00a0     std::cout << \\\"H1 error = \\\" << h1_error << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nVectorTools::compute_global_errordouble compute_global_error(const Triangulation< dim, spacedim > &tria, const InVector &cellwise_error, const NormType &norm, const double exponent=2.)\\nVectorTools::H1_norm@ H1_normDefinition vector_tools_common.h:203\\nVectorTools::integrate_differencevoid integrate_difference(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const ReadVector< Number > &fe_function, const Function< spacedim, Number > &exact_solution, OutVector &difference, const Quadrature< dim > &q, const NormType &norm, const Function< spacedim, double > *weight=nullptr, const double exponent=2.)\\n LaplaceBeltramiProblem::run\\nThe last function provides the top-level logic. Its contents are self-explanatory:\\n\\u00a0   template <int spacedim>\\n\\u00a0   void LaplaceBeltramiProblem<spacedim>::run()\\n\\u00a0   {\\n\\u00a0     make_grid_and_dofs();\\n\\u00a0     assemble_system();\\n\\u00a0     solve();\\n\\u00a0     output_results();\\n\\u00a0     compute_error();\\n\\u00a0   }\\n\\u00a0 } // namespace Step38\\n\\u00a0 \\n\\u00a0 \\n The main() function\\nThe remainder of the program is taken up by the main() function. It follows exactly the general layout first introduced in step-6 and used in all following tutorial programs:\\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       using namespace Step38;\\n\\u00a0 \\n\\u00a0       LaplaceBeltramiProblem<3> laplace_beltrami;\\n\\u00a0       laplace_beltrami.run();\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nWhen you run the program, the following output should be printed on screen:\\nSurface mesh has 1280 cells.\\nSurface mesh has 5185 degrees of freedom.\\nH1 error = 0.0217136\\nBy playing around with the number of global refinements in the LaplaceBeltrami::make_grid_and_dofs function you increase or decrease mesh refinement. For example, doing one more refinement and only running the 3d surface problem yields the following output:\\nSurface mesh has 5120 cells.\\nSurface mesh has 20609 degrees of freedom.\\nH1 error = 0.00543481\\nThis is what we expect: make the mesh size smaller by a factor of two and the error goes down by a factor of four (remember that we use bi-quadratic elements). The full sequence of errors from one to five refinements looks like this, neatly following the theoretically predicted pattern: 0.339438\\n0.0864385\\n0.0217136\\n0.00543481\\n0.00135913\\nFinally, the program produces graphical output that we can visualize. Here is a plot of the results:\\n\\nThe program also works for 1d curves in 2d, not just 2d surfaces in 3d. You can test this by changing the template argument in main() like so: LaplaceBeltramiProblem<2> laplace_beltrami;\\n The domain is a curve in 2d, and we can visualize the solution by using the third dimension (and color) to denote the value of the function \\\\(u(x)\\\\). This then looks like so (the white curve is the domain, the colored curve is the solution extruded into the third dimension, clearly showing the change in sign as the curve moves from one quadrant of the domain into the adjacent one):\\n\\n Possibilities for extensions\\nComputing on surfaces only becomes interesting if the surface is more interesting than just a half sphere. To achieve this, deal.II can read meshes that describe surfaces through the usual GridIn class. Or, in case you have an analytic description, a simple mesh can sometimes be stretched and bent into a shape we are interested in.\\nLet us consider a relatively simple example: we take the half sphere we used before, we stretch it by a factor of 10 in the z-direction, and then we jumble the x- and y-coordinates a bit. Let's show the computational domain and the solution first before we go into details of the implementation below:\\n\\n\\nThe way to produce such a mesh is by using the GridTools::transform() function. It needs a way to transform each individual mesh point to a different position. Let us here use the following, rather simple function (remember: stretch in one direction, jumble in the other two):\\ntemplate <int spacedim>\\nPoint<spacedim> warp(const Point<spacedim> &p)\\n{\\n Point<spacedim> q = p;\\n  q[spacedim-1] *= 10;\\n \\n if (spacedim >= 2)\\n    q[0] += 2*std::sin(q[spacedim-1]);\\n if (spacedim >= 3)\\n    q[1] += 2*std::cos(q[spacedim-1]);\\n \\n return q;\\n}\\nIf we followed the LaplaceBeltrami::make_grid_and_dofs function, we would extract the half spherical surface mesh as before, warp it into the shape we want, and refine as often as necessary. This is not quite as simple as we'd like here, though: refining requires that we have an appropriate manifold object attached to the triangulation that describes where new vertices of the mesh should be located upon refinement. I'm sure it's possible to describe this manifold in a not-too-complicated way by simply undoing the transformation above (yielding the spherical surface again), finding the location of a new point on the sphere, and then re-warping the result. But I'm a lazy person, and since doing this is not really the point here, let's just make our lives a bit easier: we'll extract the half sphere, refine it as often as necessary, get rid of the object that describes the manifold since we now no longer need it, and then finally warp the mesh. With the function above, this would look as follows:\\ntemplate <int spacedim>\\nvoid LaplaceBeltrami<spacedim>::make_grid_and_dofs()\\n{\\n  {\\n Triangulation<spacedim> volume_mesh;\\n GridGenerator::half_hyper_ball(volume_mesh);\\n \\n    volume_mesh.refine_global(4);\\n \\n const std::set<types::boundary_id> boundary_ids = {0};\\n \\n GridGenerator::extract_boundary_mesh(volume_mesh, triangulation,\\n                                         boundary_ids);\\n GridTools::transform(&warp<spacedim>, triangulation);       /* ** */\\n    std::ofstream x(\\\"x\\\"), y(\\\"y\\\");\\n GridOut().write_gnuplot(volume_mesh, x);\\n GridOut().write_gnuplot(triangulation, y);\\n  }\\n \\n  std::cout << \\\"Surface mesh has \\\" << triangulation.n_active_cells()\\n            << \\\" cells.\\\"\\n            << std::endl;\\n  ...\\n}\\nGridOutDefinition grid_out.h:993\\nGridOut::write_gnuplotvoid write_gnuplot(const Triangulation< dim, spacedim > &tria, std::ostream &out, const Mapping< dim, spacedim > *mapping=nullptr) constDefinition grid_out.cc:4608\\nGridTools::transformvoid transform(const Transformation &transformation, Triangulation< dim, spacedim > &triangulation)\\nNote that the only essential addition is the line marked with asterisks. It is worth pointing out one other thing here, though: because we detach the manifold description from the surface mesh, whenever we use a mapping object in the rest of the program, it has no curves boundary description to go on any more. Rather, it will have to use the implicit, FlatManifold class that is used on all parts of the domain not explicitly assigned a different manifold object. Consequently, whether we use MappingQ(2), MappingQ(15) or MappingQ1, each cell of our mesh will be mapped using a bilinear approximation.\\nAll these drawbacks aside, the resulting pictures are still pretty. The only other differences to what's in step-38 is that we changed the right hand side to \\\\(f(\\\\mathbf x)=\\\\sin x_3\\\\) and the boundary values (through the Solution class) to \\\\(u(\\\\mathbf x)|_{\\\\partial\\\\Omega}=\\\\cos x_3\\\\). Of course, we now no longer know the exact solution, so the computation of the error at the end of LaplaceBeltrami::run will yield a meaningless number.\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2010 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n *\\n * Authors: Andrea Bonito, Sebastian Pauletti.\\n */\\n \\n \\n \\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/function.h>\\n \\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/vector.h>\\n#include <deal.II/lac/solver_control.h>\\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/precondition.h>\\n#include <deal.II/lac/sparse_matrix.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n \\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/manifold_lib.h>\\n#include <deal.II/grid/grid_generator.h>\\n \\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_values.h>\\n#include <deal.II/fe/mapping_q.h>\\n \\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/vector_tools.h>\\n#include <deal.II/numerics/matrix_tools.h>\\n \\n#include <fstream>\\n#include <iostream>\\n \\n \\nnamespace Step38\\n{\\n using namespace dealii;\\n \\n \\n \\n template <int spacedim>\\n class LaplaceBeltramiProblem\\n  {\\n public:\\n    LaplaceBeltramiProblem(const unsigned degree = 2);\\n void run();\\n \\n private:\\n static constexpr unsigned int dim = spacedim - 1;\\n \\n void make_grid_and_dofs();\\n void assemble_system();\\n void solve();\\n void output_results() const;\\n void compute_error() const;\\n \\n \\n Triangulation<dim, spacedim> triangulation;\\n const FE_Q<dim, spacedim>    fe;\\n DoFHandler<dim, spacedim>    dof_handler;\\n MappingQ<dim, spacedim>      mapping;\\n \\n SparsityPattern      sparsity_pattern;\\n SparseMatrix<double> system_matrix;\\n \\n Vector<double> solution;\\n Vector<double> system_rhs;\\n  };\\n \\n \\n \\n template <int dim>\\n class Solution : public Function<dim>\\n  {\\n public:\\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n \\n virtual Tensor<1, dim>\\n    gradient(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n  };\\n \\n \\n template <>\\n double Solution<2>::value(const Point<2> &p, const unsigned int) const\\n {\\n return (-2. * p[0] * p[1]);\\n  }\\n \\n \\n template <>\\n Tensor<1, 2> Solution<2>::gradient(const Point<2> &p,\\n const unsigned int) const\\n {\\n Tensor<1, 2> return_value;\\n    return_value[0] = -2. * p[1] * (1 - 2. * p[0] * p[0]);\\n    return_value[1] = -2. * p[0] * (1 - 2. * p[1] * p[1]);\\n \\n return return_value;\\n  }\\n \\n \\n template <>\\n double Solution<3>::value(const Point<3> &p, const unsigned int) const\\n {\\n return (std::sin(numbers::PI * p[0]) * std::cos(numbers::PI * p[1]) *\\n exp(p[2]));\\n  }\\n \\n \\n template <>\\n Tensor<1, 3> Solution<3>::gradient(const Point<3> &p,\\n const unsigned int) const\\n {\\n using numbers::PI;\\n \\n Tensor<1, 3> return_value;\\n \\n    return_value[0] = PI * cos(PI * p[0]) * cos(PI * p[1]) * exp(p[2]);\\n    return_value[1] = -PI * sin(PI * p[0]) * sin(PI * p[1]) * exp(p[2]);\\n    return_value[2] = sin(PI * p[0]) * cos(PI * p[1]) * exp(p[2]);\\n \\n return return_value;\\n  }\\n \\n \\n \\n template <int dim>\\n class RightHandSide : public Function<dim>\\n  {\\n public:\\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n  };\\n \\n template <>\\n double RightHandSide<2>::value(const Point<2> &p,\\n const unsigned int /*component*/) const\\n {\\n return (-8. * p[0] * p[1]);\\n  }\\n \\n \\n template <>\\n double RightHandSide<3>::value(const Point<3> &p,\\n const unsigned int /*component*/) const\\n {\\n using numbers::PI;\\n \\n Tensor<2, 3> hessian;\\n \\n hessian[0][0] = -PI * PI * sin(PI * p[0]) * cos(PI * p[1]) * exp(p[2]);\\n hessian[1][1] = -PI * PI * sin(PI * p[0]) * cos(PI * p[1]) * exp(p[2]);\\n hessian[2][2] = sin(PI * p[0]) * cos(PI * p[1]) * exp(p[2]);\\n \\n hessian[0][1] = -PI * PI * cos(PI * p[0]) * sin(PI * p[1]) * exp(p[2]);\\n hessian[1][0] = -PI * PI * cos(PI * p[0]) * sin(PI * p[1]) * exp(p[2]);\\n \\n hessian[0][2] = PI * cos(PI * p[0]) * cos(PI * p[1]) * exp(p[2]);\\n hessian[2][0] = PI * cos(PI * p[0]) * cos(PI * p[1]) * exp(p[2]);\\n \\n hessian[1][2] = -PI * sin(PI * p[0]) * sin(PI * p[1]) * exp(p[2]);\\n hessian[2][1] = -PI * sin(PI * p[0]) * sin(PI * p[1]) * exp(p[2]);\\n \\n Tensor<1, 3> gradient;\\n gradient[0] = PI * cos(PI * p[0]) * cos(PI * p[1]) * exp(p[2]);\\n gradient[1] = -PI * sin(PI * p[0]) * sin(PI * p[1]) * exp(p[2]);\\n gradient[2] = sin(PI * p[0]) * cos(PI * p[1]) * exp(p[2]);\\n \\n Point<3> normal = p;\\n    normal /= p.norm();\\n \\n return (-trace(hessian) + 2 * (gradient * normal) +\\n            (hessian * normal) * normal);\\n  }\\n \\n \\n \\n template <int spacedim>\\n  LaplaceBeltramiProblem<spacedim>::LaplaceBeltramiProblem(\\n const unsigned degree)\\n    : fe(degree)\\n    , dof_handler(triangulation)\\n    , mapping(degree)\\n  {}\\n \\n \\n \\n template <int spacedim>\\n void LaplaceBeltramiProblem<spacedim>::make_grid_and_dofs()\\n  {\\n    {\\n Triangulation<spacedim> volume_mesh;\\n GridGenerator::half_hyper_ball(volume_mesh);\\n \\n const std::set<types::boundary_id> boundary_ids = {0};\\n \\n GridGenerator::extract_boundary_mesh(volume_mesh,\\n triangulation,\\n                                           boundary_ids);\\n    }\\n triangulation.set_all_manifold_ids(0);\\n triangulation.set_manifold(0, SphericalManifold<dim, spacedim>());\\n \\n triangulation.refine_global(4);\\n \\n    std::cout << \\\"Surface mesh has \\\" << triangulation.n_active_cells()\\n              << \\\" cells.\\\" << std::endl;\\n \\n    dof_handler.distribute_dofs(fe);\\n \\n    std::cout << \\\"Surface mesh has \\\" << dof_handler.n_dofs()\\n              << \\\" degrees of freedom.\\\" << std::endl;\\n \\n DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());\\n DoFTools::make_sparsity_pattern(dof_handler, dsp);\\n    sparsity_pattern.copy_from(dsp);\\n \\n    system_matrix.reinit(sparsity_pattern);\\n \\n    solution.reinit(dof_handler.n_dofs());\\n    system_rhs.reinit(dof_handler.n_dofs());\\n  }\\n \\n \\n \\n template <int spacedim>\\n void LaplaceBeltramiProblem<spacedim>::assemble_system()\\n  {\\n    system_matrix = 0;\\n    system_rhs    = 0;\\n \\n const QGauss<dim>       quadrature_formula(2 * fe.degree);\\n FEValues<dim, spacedim> fe_values(mapping,\\n                                      fe,\\n                                      quadrature_formula,\\n update_values | update_gradients |\\n update_quadrature_points |\\n update_JxW_values);\\n \\n const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n const unsigned int n_q_points    = quadrature_formula.size();\\n \\n FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n Vector<double>     cell_rhs(dofs_per_cell);\\n \\n    std::vector<double>                  rhs_values(n_q_points);\\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n    RightHandSide<spacedim> rhs;\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n cell_matrix = 0;\\n        cell_rhs    = 0;\\n \\n        fe_values.reinit(cell);\\n \\n        rhs.value_list(fe_values.get_quadrature_points(), rhs_values);\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n cell_matrix(i, j) += fe_values.shape_grad(i, q_point) *\\n                                   fe_values.shape_grad(j, q_point) *\\n                                   fe_values.JxW(q_point);\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\\n            cell_rhs(i) += fe_values.shape_value(i, q_point) *\\n                           rhs_values[q_point] * fe_values.JxW(q_point);\\n \\n        cell->get_dof_indices(local_dof_indices);\\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n          {\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n              system_matrix.add(local_dof_indices[i],\\n                                local_dof_indices[j],\\n cell_matrix(i, j));\\n \\n            system_rhs(local_dof_indices[i]) += cell_rhs(i);\\n          }\\n      }\\n \\n    std::map<types::global_dof_index, double> boundary_values;\\n VectorTools::interpolate_boundary_values(\\n      mapping, dof_handler, 0, Solution<spacedim>(), boundary_values);\\n \\n MatrixTools::apply_boundary_values(\\n      boundary_values, system_matrix, solution, system_rhs, false);\\n  }\\n \\n \\n \\n \\n template <int spacedim>\\n void LaplaceBeltramiProblem<spacedim>::solve()\\n  {\\n SolverControl solver_control(solution.size(), 1e-7 * system_rhs.l2_norm());\\n SolverCG<Vector<double>> cg(solver_control);\\n \\n PreconditionSSOR<SparseMatrix<double>> preconditioner;\\n    preconditioner.initialize(system_matrix, 1.2);\\n \\n    cg.solve(system_matrix, solution, system_rhs, preconditioner);\\n  }\\n \\n \\n \\n \\n template <int spacedim>\\n void LaplaceBeltramiProblem<spacedim>::output_results() const\\n {\\n DataOut<dim, spacedim> data_out;\\n    data_out.attach_dof_handler(dof_handler);\\n    data_out.add_data_vector(solution,\\n \\\"solution\\\",\\n DataOut<dim, spacedim>::type_dof_data);\\n    data_out.build_patches(mapping, mapping.get_degree());\\n \\n const std::string filename =\\n \\\"solution-\\\" + std::to_string(spacedim) + \\\"d.vtk\\\";\\n    std::ofstream output(filename);\\n    data_out.write_vtk(output);\\n  }\\n \\n \\n \\n \\n template <int spacedim>\\n void LaplaceBeltramiProblem<spacedim>::compute_error() const\\n {\\n Vector<float> difference_per_cell(triangulation.n_active_cells());\\n VectorTools::integrate_difference(mapping,\\n                                      dof_handler,\\n                                      solution,\\n                                      Solution<spacedim>(),\\n                                      difference_per_cell,\\n QGauss<dim>(2 * fe.degree + 1),\\n VectorTools::H1_norm);\\n \\n double h1_error = VectorTools::compute_global_error(triangulation,\\n                                                        difference_per_cell,\\n VectorTools::H1_norm);\\n    std::cout << \\\"H1 error = \\\" << h1_error << std::endl;\\n  }\\n \\n \\n \\n \\n template <int spacedim>\\n void LaplaceBeltramiProblem<spacedim>::run()\\n  {\\n    make_grid_and_dofs();\\n    assemble_system();\\n    solve();\\n    output_results();\\n    compute_error();\\n  }\\n} // namespace Step38\\n \\n \\n \\nint main()\\n{\\n try\\n    {\\n using namespace Step38;\\n \\n      LaplaceBeltramiProblem<3> laplace_beltrami;\\n      laplace_beltrami.run();\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n \\n return 0;\\n}\\nDataOutInterface::write_vtkvoid write_vtk(std::ostream &out) constDefinition data_out_base.cc:7681\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\ndof_handler.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nfe_values.h\\nfe_q.h\\nfull_matrix.h\\nfunction.h\\nmanifold_lib.h\\ntria.h\\ngrid_generator.h\\nmapping_q.h\\nmatrix_tools.h\\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\ninternal::EvaluatorQuantity::value@ value\\ndata_out.h\\nprecondition.h\\nquadrature_lib.h\\nsolver_cg.h\\nsolver_control.h\\nsparse_matrix.h\\nvector.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"