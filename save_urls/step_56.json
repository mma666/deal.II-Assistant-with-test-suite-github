"[{\"lc\": 1, \"type\": \"constructor\", \"id\": [\"langchain\", \"schema\", \"document\", \"Document\"], \"kwargs\": {\"metadata\": {\"source\": \"https://dealii.org/current/doxygen/deal.II/step_56.html\", \"content_type\": \"text/html\", \"title\": \"The deal.II Library: The step-56 tutorial program\", \"language\": \"en-US\"}, \"page_content\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\nThe deal.II Library: The step-56 tutorial program\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u00a0Reference documentation for deal.II version 9.6.0\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\\(\\\\newcommand{\\\\dealvcentcolon}{\\\\mathrel{\\\\mathop{:}}}\\\\)\\n\\\\(\\\\newcommand{\\\\dealcoloneq}{\\\\dealvcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}\\\\)\\n\\\\(\\\\newcommand{\\\\jump}[1]{\\\\left[\\\\!\\\\left[ #1 \\\\right]\\\\!\\\\right]}\\\\)\\n\\\\(\\\\newcommand{\\\\average}[1]{\\\\left\\\\{\\\\!\\\\left\\\\{ #1 \\\\right\\\\}\\\\!\\\\right\\\\}}\\\\)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nLoading...\\nSearching...\\nNo Matches\\n\\n\\n\\n\\n\\n\\n\\nThe step-56 tutorial program\\n\\n\\nThis tutorial depends on step-16, step-22.\\n\\n\\nTable of contents\\n\\n\\n Introduction\\n\\n Stokes Problem \\n Linear Solver and Preconditioning Issues \\n Reference Solution \\n Computing Errors \\n DoF Handlers \\n Differences from the Step 22 tutorial \\n\\n The commented program\\n\\nInclude files\\nFunctions for Solution and Righthand side\\nASPECT BlockSchurPreconditioner\\nThe StokesProblem class\\n\\nStokesProblem::setup_dofs\\nStokesProblem::assemble_system\\nStokesProblem::assemble_multigrid\\nStokesProblem::solve\\nStokesProblem::process_solution\\nStokesProblem::output_results\\nStokesProblem::run\\n\\nThe main function\\n\\n\\n Results\\n\\n Errors \\n Timing Results \\n Possibilities for extensions \\n\\n Check higher order discretizations \\n Compare with cheap preconditioner \\n\\n\\n The plain program\\n   \\nThis program was contributed by Ryan Grove and Timo Heister.\\nThis material is based upon work partially supported by National Science Foundation grant DMS1522191 and the Computational Infrastructure in Geodynamics initiative (CIG), through the National Science Foundation under Award No. EAR-0949446 and The University of California-Davis.\\nThe authors would like to thank the Isaac Newton Institute for Mathematical Sciences, Cambridge, for support and hospitality during the programme Melt in the Mantle where work on this tutorial was undertaken. This work was supported by EPSRC grant no EP/K032208/1. \\nNoteIf you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation:   \\n Introduction\\nStokes Problem \\nThe purpose of this tutorial is to create an efficient linear solver for the Stokes equation and compare it to alternative approaches. Here, we will use FGMRES with geometric multigrid as a preconditioner velocity block, and we will show in the results section that this is a fundamentally better approach than the linear solvers used in step-22 (including the scheme described in \\\"Possible Extensions\\\"). Fundamentally, this is because only with multigrid it is possible to get \\\\(O(n)\\\\) solve time, where \\\\(n\\\\) is the number of unknowns of the linear system. Using the Timer class, we collect some statistics to compare setup times, solve times, and number of iterations. We also compute errors to make sure that what we have implemented is correct.\\nLet \\\\(u \\\\in H_0^1 = \\\\{ u \\\\in H^1(\\\\Omega), u|_{\\\\partial \\\\Omega} = 0 \\\\}\\\\) and  \\\\(p \\\\in L_*^2 = \\\\{ p \\\\in L^2(\\\\Omega), \\\\int_\\\\Omega p = 0\\n\\\\}\\\\). The Stokes equations read as follows in non-dimensionalized form:\\n\\n\\\\begin{eqnarray*}\\n - 2 \\\\text{div} \\\\frac {1}{2} \\\\left[ (\\\\nabla \\\\textbf{u})\\n + (\\\\nabla \\\\textbf{u})^T\\\\right] + \\\\nabla p & =& f \\\\\\\\\\n - \\\\nabla \\\\cdot u &=& 0\\n\\\\end{eqnarray*}\\n\\nNote that we are using the deformation tensor instead of \\\\(\\\\Delta u\\\\) (a detailed description of the difference between the two can be found in step-22, but in summary, the deformation tensor is more physical as well as more expensive).\\nLinear Solver and Preconditioning Issues \\nThe weak form of the discrete equations naturally leads to the following linear system for the nodal values of the velocity and pressure fields:     \\n\\\\begin{eqnarray*}\\n\\\\left(\\\\begin{array}{cc} A & B^T \\\\\\\\ B & 0\\n\\\\end{array}\\\\right) \\\\left(\\\\begin{array}{c} U \\\\\\\\ P \\\\end{array}\\\\right) =\\n\\\\left(\\\\begin{array}{c} F \\\\\\\\ 0 \\\\end{array}\\\\right).\\n\\\\end{eqnarray*}\\n\\nOur goal is to compare several solution approaches. While step-22 solves the linear system using a \\\"Schur complement approach\\\" in two separate steps, we instead attack the block system at once using FMGRES with an efficient preconditioner, in the spirit of the approach outlined in the \\\"Results\\\" section of step-22. The idea is as follows: if we find a block preconditioner \\\\(P\\\\) such that the matrix\\n\\n\\\\begin{eqnarray*}\\n\\\\left(\\\\begin{array}{cc} A & B^T \\\\\\\\ B & 0 \\\\end{array}\\\\right) P^{-1}\\n\\\\end{eqnarray*}\\n\\nis simple, then an iterative solver with that preconditioner will converge in a few iterations. Notice that we are doing right preconditioning here. Using the Schur complement \\\\(S=BA^{-1}B^T\\\\), we find that\\n\\n\\\\begin{eqnarray*}\\nP^{-1} = \\\\left(\\\\begin{array}{cc} A & B^T \\\\\\\\ 0 &\\n S \\\\end{array}\\\\right)^{-1}\\n\\\\end{eqnarray*}\\n\\nis a good choice. Let \\\\(\\\\widetilde{A^{-1}}\\\\) be an approximation of \\\\(A^{-1}\\\\) and \\\\(\\\\widetilde{S^{-1}}\\\\) of \\\\(S^{-1}\\\\), we see          \\n\\\\begin{eqnarray*}\\nP^{-1} =\\n\\\\left(\\\\begin{array}{cc} A^{-1} & 0 \\\\\\\\ 0 & I \\\\end{array}\\\\right)\\n\\\\left(\\\\begin{array}{cc} I & B^T \\\\\\\\ 0 & -I \\\\end{array}\\\\right)\\n\\\\left(\\\\begin{array}{cc} I & 0 \\\\\\\\ 0 & S^{-1} \\\\end{array}\\\\right)\\n\\\\approx\\n\\\\left(\\\\begin{array}{cc} \\\\widetilde{A^{-1}} & 0 \\\\\\\\ 0 & I \\\\end{array}\\\\right)\\n\\\\left(\\\\begin{array}{cc} I & B^T \\\\\\\\ 0 & -I \\\\end{array}\\\\right)\\n\\\\left(\\\\begin{array}{cc} I & 0 \\\\\\\\ 0 & \\\\widetilde{S^{-1}} \\\\end{array}\\\\right).\\n  \\\\end{eqnarray*}\\n\\nSince \\\\(P\\\\) is aimed to be a preconditioner only, we shall use the approximations on the right in the equation above.\\nAs discussed in step-22,  \\\\(-M_p^{-1}=:\\\\widetilde{S^{-1}} \\\\approx\\nS^{-1}\\\\), where \\\\(M_p\\\\) is the pressure mass matrix and is solved approximately by using CG with ILU as a preconditioner, and \\\\(\\\\widetilde{A^{-1}}\\\\) is obtained by one of multiple methods: solving a linear system with CG and ILU as preconditioner, just using one application of an ILU, solving a linear system with CG and GMG (Geometric Multigrid as described in step-16) as a preconditioner, or just performing a single V-cycle of GMG.\\nAs a comparison, instead of FGMRES, we also use the direct solver UMFPACK on the whole system to compare our results with. If you want to use a direct solver (like UMFPACK), the system needs to be invertible. To avoid the one dimensional null space given by the constant pressures, we fix the first pressure unknown to zero. This is not necessary for the iterative solvers.\\nReference Solution \\nThe test problem is a \\\"Manufactured Solution\\\" (see step-7 for details), and we choose  \\\\(u=(u_1,u_2,u_3)=(2\\\\sin (\\\\pi x), - \\\\pi y \\\\cos\\n(\\\\pi x),- \\\\pi z \\\\cos (\\\\pi x))\\\\) and  \\\\(p = \\\\sin (\\\\pi x)\\\\cos (\\\\pi y)\\\\sin\\n(\\\\pi z)\\\\). We apply Dirichlet boundary conditions for the velocity on the whole boundary of the domain \\\\(\\\\Omega=[0,1]\\\\times[0,1]\\\\times[0,1]\\\\). To enforce the boundary conditions we can just use our reference solution.\\nIf you look up in the deal.II manual what is needed to create a class derived from Function<dim>, you will find that this class has numerous virtual functions, including Function::value(), Function::vector_value(), Function::value_list(), etc., all of which can be overloaded. Different parts of deal.II will require different ones of these particular functions. This can be confusing at first, but luckily the only thing you actually have to implement is value(). The other virtual functions in the Function class have default implementations inside that will call your implementation of value by default.\\nNotice that our reference solution fulfills \\\\(\\\\nabla \\\\cdot u = 0\\\\). In addition, the pressure is chosen to have a mean value of zero. For the \\\"Method of Manufactured Solutions\\\" of step-7, we need to find  \\\\(\\\\bf\\nf\\\\) such that:\\n\\n\\\\begin{align*}\\n{\\\\bf f} =   - 2 \\\\text{div} \\\\frac {1}{2} \\\\left[ (\\\\nabla \\\\textbf{u}) + (\\\\nabla \\\\textbf{u})^T\\\\right] + \\\\nabla p.\\n\\\\end{align*}\\n\\nUsing the reference solution above, we obtain:\\n\\n\\\\begin{eqnarray*}\\n{\\\\bf f} &=& (2 \\\\pi^2 \\\\sin (\\\\pi x),- \\\\pi^3 y \\\\cos(\\\\pi\\nx),- \\\\pi^3 z \\\\cos(\\\\pi x))\\\\\\\\ & & + (\\\\pi \\\\cos(\\\\pi x) \\\\cos(\\\\pi y)\\n\\\\sin(\\\\pi z) ,- \\\\pi \\\\sin(\\\\pi y) \\\\sin(\\\\pi x) \\\\sin(\\\\pi z), \\\\pi \\\\cos(\\\\pi\\nz) \\\\sin(\\\\pi x) \\\\cos(\\\\pi y)) \\\\end{eqnarray*}\\n\\nComputing Errors \\nBecause we do not enforce the mean pressure to be zero for our numerical solution in the linear system, we need to post process the solution after solving. To do this we use the VectorTools::compute_mean_value() function to compute the mean value of the pressure to subtract it from the pressure.\\nDoF Handlers \\nThe way we implement geometric multigrid here only executes it on the velocity variables (i.e., the \\\\(A\\\\) matrix described above) but not the pressure. One could implement this in different ways, including one in which one considers all coarse grid operations as acting on  \\\\(2\\\\times\\n2\\\\) block systems where we only consider the top left block. Alternatively, we can implement things by really only considering a linear system on the velocity part of the overall finite element discretization. The latter is the way we want to use here.\\nTo implement this, one would need to be able to ask questions such as \\\"May I have just part of a DoFHandler?\\\". This is not possible at the time when this program was written, so in order to answer this request for our needs, we simply create a separate, second DoFHandler for just the velocities. We then build linear systems for the multigrid preconditioner based on only this second DoFHandler, and simply transfer the first block of (overall) vectors into corresponding vectors for the entire second DoFHandler. To make this work, we have to assure that the order in which the (velocity) degrees of freedom are ordered in the two DoFHandler objects is the same. This is in fact the case by first distributing degrees of freedom on both, and then using the same sequence of DoFRenumbering operations on both.\\nDifferences from the Step 22 tutorial \\nThe main difference between step-56 and step-22 is that we use block solvers instead of the Schur Complement approach used in step-22. Details of this approach can be found under the \\\"Block Schur\\ncomplement preconditioner\\\" subsection of the \\\"Possible Extensions\\\" section of step-22. For the preconditioner of the velocity block, we borrow a class from ASPECT called BlockSchurPreconditioner that has the option to solve for the inverse of \\\\(A\\\\) or just apply one preconditioner sweep for it instead, which provides us with an expensive and cheap approach, respectively.\\n The commented program\\n Include files\\n\\u00a0 #include <deal.II/base/quadrature_lib.h>\\n\\u00a0 #include <deal.II/base/function.h>\\n\\u00a0 #include <deal.II/base/utilities.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/block_vector.h>\\n\\u00a0 #include <deal.II/lac/full_matrix.h>\\n\\u00a0 #include <deal.II/lac/block_sparse_matrix.h>\\n\\u00a0 #include <deal.II/lac/block_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/solver_cg.h>\\n\\u00a0 #include <deal.II/lac/precondition.h>\\n\\u00a0 #include <deal.II/lac/affine_constraints.h>\\n\\u00a0 #include <deal.II/lac/dynamic_sparsity_pattern.h>\\n\\u00a0 #include <deal.II/lac/solver_gmres.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/grid/tria.h>\\n\\u00a0 #include <deal.II/grid/grid_generator.h>\\n\\u00a0 #include <deal.II/grid/grid_tools.h>\\n\\u00a0 #include <deal.II/grid/grid_refinement.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/dofs/dof_handler.h>\\n\\u00a0 #include <deal.II/dofs/dof_renumbering.h>\\n\\u00a0 #include <deal.II/dofs/dof_tools.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/fe/fe_q.h>\\n\\u00a0 #include <deal.II/fe/fe_system.h>\\n\\u00a0 #include <deal.II/fe/fe_values.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/numerics/vector_tools.h>\\n\\u00a0 #include <deal.II/numerics/data_out.h>\\n\\u00a0 #include <deal.II/numerics/error_estimator.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/sparse_direct.h>\\n\\u00a0 \\n\\u00a0 #include <deal.II/lac/sparse_ilu.h>\\n\\u00a0 #include <deal.II/grid/grid_out.h>\\n\\u00a0 \\nWe need to include the following file to do timings:\\n\\u00a0 #include <deal.II/base/timer.h>\\n\\u00a0 \\nThis includes the files necessary for us to use geometric Multigrid\\n\\u00a0 #include <deal.II/multigrid/multigrid.h>\\n\\u00a0 #include <deal.II/multigrid/mg_transfer.h>\\n\\u00a0 #include <deal.II/multigrid/mg_tools.h>\\n\\u00a0 #include <deal.II/multigrid/mg_coarse.h>\\n\\u00a0 #include <deal.II/multigrid/mg_smoother.h>\\n\\u00a0 #include <deal.II/multigrid/mg_matrix.h>\\n\\u00a0 \\n\\u00a0 #include <iostream>\\n\\u00a0 #include <fstream>\\n\\u00a0 \\n\\u00a0 namespace Step56\\n\\u00a0 {\\n\\u00a0   using namespace dealii;\\n\\u00a0 \\ndealiiDefinition namespace_dealii.h:25\\nIn order to make it easy to switch between the different solvers that are being used, we declare an enum that can be passed as an argument to the constructor of the main class.\\n\\u00a0   enum class SolverType\\n\\u00a0   {\\n\\u00a0     FGMRES_ILU,\\n\\u00a0     FGMRES_GMG,\\n\\u00a0     UMFPACK\\n\\u00a0   };\\n\\u00a0 \\n Functions for Solution and Righthand side\\nThe class Solution is used to define the boundary conditions and to compute errors of the numerical solution. Note that we need to define the values and gradients in order to compute L2 and H1 errors. Here we decided to separate the implementations for 2d and 3d using template specialization.\\nNote that the first dim components are the velocity components and the last is the pressure.\\n\\u00a0   template <int dim>\\n\\u00a0   class Solution : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     Solution()\\n\\u00a0       : Function<dim>(dim + 1)\\n\\u00a0     {}\\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component = 0) const override;\\n\\u00a0     virtual Tensor<1, dim>\\n\\u00a0     gradient(const Point<dim>  &p,\\n\\u00a0              const unsigned int component = 0) const override;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0   template <>\\n\\u00a0   double Solution<2>::value(const Point<2>    &p,\\n\\u00a0                             const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     Assert(component <= 2 + 1, ExcIndexRange(component, 0, 2 + 1));\\n\\u00a0 \\n\\u00a0     using numbers::PI;\\n\\u00a0     const double x = p[0];\\n\\u00a0     const double y = p[1];\\n\\u00a0 \\n\\u00a0     if (component == 0)\\n\\u00a0       return sin(PI * x);\\n\\u00a0     if (component == 1)\\n\\u00a0       return -PI * y * cos(PI * x);\\n\\u00a0     if (component == 2)\\n\\u00a0       return sin(PI * x) * cos(PI * y);\\n\\u00a0 \\n\\u00a0     return 0;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <>\\n\\u00a0   double Solution<3>::value(const Point<3>    &p,\\n\\u00a0                             const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     Assert(component <= 3 + 1, ExcIndexRange(component, 0, 3 + 1));\\n\\u00a0 \\n\\u00a0     using numbers::PI;\\n\\u00a0     const double x = p[0];\\n\\u00a0     const double y = p[1];\\n\\u00a0     const double z = p[2];\\n\\u00a0 \\n\\u00a0     if (component == 0)\\n\\u00a0       return 2.0 * sin(PI * x);\\n\\u00a0     if (component == 1)\\n\\u00a0       return -PI * y * cos(PI * x);\\n\\u00a0     if (component == 2)\\n\\u00a0       return -PI * z * cos(PI * x);\\n\\u00a0     if (component == 3)\\n\\u00a0       return sin(PI * x) * cos(PI * y) * sin(PI * z);\\n\\u00a0 \\n\\u00a0     return 0;\\n\\u00a0   }\\n\\u00a0 \\nFunctionDefinition function.h:152\\nFunction::gradientvirtual Tensor< 1, dim, RangeNumberType > gradient(const Point< dim > &p, const unsigned int component=0) const\\nFunction::valuevirtual RangeNumberType value(const Point< dim > &p, const unsigned int component=0) const\\nPointDefinition point.h:111\\nTensorDefinition tensor.h:471\\nAssert#define Assert(cond, exc)Definition exceptions.h:1638\\nnumbers::PIstatic constexpr double PIDefinition numbers.h:259\\nstd::cos::VectorizedArray< Number, width > cos(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6609\\nstd::sin::VectorizedArray< Number, width > sin(const ::VectorizedArray< Number, width > &)Definition vectorization.h:6589\\nNote that for the gradient we need to return a Tensor<1,dim>\\n\\u00a0   template <>\\n\\u00a0   Tensor<1, 2> Solution<2>::gradient(const Point<2>    &p,\\n\\u00a0                                      const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     Assert(component <= 2, ExcIndexRange(component, 0, 2 + 1));\\n\\u00a0 \\n\\u00a0     using numbers::PI;\\n\\u00a0     const double x = p[0];\\n\\u00a0     const double y = p[1];\\n\\u00a0 \\n\\u00a0     Tensor<1, 2> return_value;\\n\\u00a0     if (component == 0)\\n\\u00a0       {\\n\\u00a0         return_value[0] = PI * cos(PI * x);\\n\\u00a0         return_value[1] = 0.0;\\n\\u00a0       }\\n\\u00a0     else if (component == 1)\\n\\u00a0       {\\n\\u00a0         return_value[0] = y * PI * PI * sin(PI * x);\\n\\u00a0         return_value[1] = -PI * cos(PI * x);\\n\\u00a0       }\\n\\u00a0     else if (component == 2)\\n\\u00a0       {\\n\\u00a0         return_value[0] = PI * cos(PI * x) * cos(PI * y);\\n\\u00a0         return_value[1] = -PI * sin(PI * x) * sin(PI * y);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     return return_value;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <>\\n\\u00a0   Tensor<1, 3> Solution<3>::gradient(const Point<3>    &p,\\n\\u00a0                                      const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     Assert(component <= 3, ExcIndexRange(component, 0, 3 + 1));\\n\\u00a0 \\n\\u00a0     using numbers::PI;\\n\\u00a0     const double x = p[0];\\n\\u00a0     const double y = p[1];\\n\\u00a0     const double z = p[2];\\n\\u00a0 \\n\\u00a0     Tensor<1, 3> return_value;\\n\\u00a0     if (component == 0)\\n\\u00a0       {\\n\\u00a0         return_value[0] = 2 * PI * cos(PI * x);\\n\\u00a0         return_value[1] = 0.0;\\n\\u00a0         return_value[2] = 0.0;\\n\\u00a0       }\\n\\u00a0     else if (component == 1)\\n\\u00a0       {\\n\\u00a0         return_value[0] = y * PI * PI * sin(PI * x);\\n\\u00a0         return_value[1] = -PI * cos(PI * x);\\n\\u00a0         return_value[2] = 0.0;\\n\\u00a0       }\\n\\u00a0     else if (component == 2)\\n\\u00a0       {\\n\\u00a0         return_value[0] = z * PI * PI * sin(PI * x);\\n\\u00a0         return_value[1] = 0.0;\\n\\u00a0         return_value[2] = -PI * cos(PI * x);\\n\\u00a0       }\\n\\u00a0     else if (component == 3)\\n\\u00a0       {\\n\\u00a0         return_value[0] = PI * cos(PI * x) * cos(PI * y) * sin(PI * z);\\n\\u00a0         return_value[1] = -PI * sin(PI * x) * sin(PI * y) * sin(PI * z);\\n\\u00a0         return_value[2] = PI * sin(PI * x) * cos(PI * y) * cos(PI * z);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     return return_value;\\n\\u00a0   }\\n\\u00a0 \\nImplementation of \\\\(f\\\\). See the introduction for more information.\\n\\u00a0   template <int dim>\\n\\u00a0   class RightHandSide : public Function<dim>\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     RightHandSide()\\n\\u00a0       : Function<dim>(dim + 1)\\n\\u00a0     {}\\n\\u00a0 \\n\\u00a0     virtual double value(const Point<dim>  &p,\\n\\u00a0                          const unsigned int component = 0) const override;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0   template <>\\n\\u00a0   double RightHandSide<2>::value(const Point<2>    &p,\\n\\u00a0                                  const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     Assert(component <= 2, ExcIndexRange(component, 0, 2 + 1));\\n\\u00a0 \\n\\u00a0     using numbers::PI;\\n\\u00a0     const double x = p[0];\\n\\u00a0     const double y = p[1];\\n\\u00a0     if (component == 0)\\n\\u00a0       return PI * PI * sin(PI * x) + PI * cos(PI * x) * cos(PI * y);\\n\\u00a0     if (component == 1)\\n\\u00a0       return -PI * PI * PI * y * cos(PI * x) - PI * sin(PI * y) * sin(PI * x);\\n\\u00a0     if (component == 2)\\n\\u00a0       return 0;\\n\\u00a0 \\n\\u00a0     return 0;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0   template <>\\n\\u00a0   double RightHandSide<3>::value(const Point<3>    &p,\\n\\u00a0                                  const unsigned int component) const\\n\\u00a0   {\\n\\u00a0     Assert(component <= 3, ExcIndexRange(component, 0, 3 + 1));\\n\\u00a0 \\n\\u00a0     using numbers::PI;\\n\\u00a0     const double x = p[0];\\n\\u00a0     const double y = p[1];\\n\\u00a0     const double z = p[2];\\n\\u00a0     if (component == 0)\\n\\u00a0       return 2 * PI * PI * sin(PI * x) +\\n\\u00a0              PI * cos(PI * x) * cos(PI * y) * sin(PI * z);\\n\\u00a0     if (component == 1)\\n\\u00a0       return -PI * PI * PI * y * cos(PI * x) +\\n\\u00a0              PI * (-1) * sin(PI * y) * sin(PI * x) * sin(PI * z);\\n\\u00a0     if (component == 2)\\n\\u00a0       return -PI * PI * PI * z * cos(PI * x) +\\n\\u00a0              PI * cos(PI * z) * sin(PI * x) * cos(PI * y);\\n\\u00a0     if (component == 3)\\n\\u00a0       return 0;\\n\\u00a0 \\n\\u00a0     return 0;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n ASPECT BlockSchurPreconditioner\\nIn the following, we will implement a preconditioner that expands on the ideas discussed in the Results section of step-22. Specifically, we\\nuse an upper block-triangular preconditioner because we want to use right preconditioning.\\noptionally allow using an inner solver for the velocity block instead of a single preconditioner application.\\ndo not use InverseMatrix but explicitly call SolverCG. This approach is also used in the ASPECT code (see https://aspect.geodynamics.org) that solves the Stokes equations in the context of simulating convection in the earth mantle, and which has been used to solve problems on many thousands of processors.\\n\\nThe bool flag do_solve_A in the constructor allows us to either apply the preconditioner for the velocity block once or use an inner iterative solver for a more accurate approximation instead.\\nNotice how we keep track of the sum of the inner iterations (preconditioner applications).\\n\\u00a0   template <class PreconditionerAType, class PreconditionerSType>\\n\\u00a0   class BlockSchurPreconditioner : public Subscriptor\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     BlockSchurPreconditioner(\\n\\u00a0       const BlockSparseMatrix<double> &system_matrix,\\n\\u00a0       const SparseMatrix<double>      &schur_complement_matrix,\\n\\u00a0       const PreconditionerAType       &preconditioner_A,\\n\\u00a0       const PreconditionerSType       &preconditioner_S,\\n\\u00a0       const bool                       do_solve_A);\\n\\u00a0 \\n\\u00a0     void vmult(BlockVector<double> &dst, const BlockVector<double> &src) const;\\n\\u00a0 \\n\\u00a0     mutable unsigned int n_iterations_A;\\n\\u00a0     mutable unsigned int n_iterations_S;\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     const BlockSparseMatrix<double> &system_matrix;\\n\\u00a0     const SparseMatrix<double>      &schur_complement_matrix;\\n\\u00a0     const PreconditionerAType       &preconditioner_A;\\n\\u00a0     const PreconditionerSType       &preconditioner_S;\\n\\u00a0 \\n\\u00a0     const bool do_solve_A;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0   template <class PreconditionerAType, class PreconditionerSType>\\n\\u00a0   BlockSchurPreconditioner<PreconditionerAType, PreconditionerSType>::\\n\\u00a0     BlockSchurPreconditioner(\\n\\u00a0       const BlockSparseMatrix<double> &system_matrix,\\n\\u00a0       const SparseMatrix<double>      &schur_complement_matrix,\\n\\u00a0       const PreconditionerAType       &preconditioner_A,\\n\\u00a0       const PreconditionerSType       &preconditioner_S,\\n\\u00a0       const bool                       do_solve_A)\\n\\u00a0     : n_iterations_A(0)\\n\\u00a0     , n_iterations_S(0)\\n\\u00a0     , system_matrix(system_matrix)\\n\\u00a0     , schur_complement_matrix(schur_complement_matrix)\\n\\u00a0     , preconditioner_A(preconditioner_A)\\n\\u00a0     , preconditioner_S(preconditioner_S)\\n\\u00a0     , do_solve_A(do_solve_A)\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <class PreconditionerAType, class PreconditionerSType>\\n\\u00a0   void\\n\\u00a0   BlockSchurPreconditioner<PreconditionerAType, PreconditionerSType>::vmult(\\n\\u00a0     BlockVector<double>       &dst,\\n\\u00a0     const BlockVector<double> &src) const\\n\\u00a0   {\\n\\u00a0     Vector<double> utmp(src.block(0));\\n\\u00a0 \\nBlockSparseMatrixDefinition block_sparse_matrix.h:50\\nBlockVectorDefinition block_vector.h:71\\nSparseMatrixDefinition sparse_matrix.h:520\\nSubscriptorDefinition subscriptor.h:60\\nVectorDefinition vector.h:120\\nFirst solve with the approximation for S\\n\\u00a0     {\\n\\u00a0       SolverControl solver_control(1000, 1e-6 * src.block(1).l2_norm());\\n\\u00a0       SolverCG<Vector<double>> cg(solver_control);\\n\\u00a0 \\n\\u00a0       dst.block(1) = 0.0;\\n\\u00a0       cg.solve(schur_complement_matrix,\\n\\u00a0                dst.block(1),\\n\\u00a0                src.block(1),\\n\\u00a0                preconditioner_S);\\n\\u00a0 \\n\\u00a0       n_iterations_S += solver_control.last_step();\\n\\u00a0       dst.block(1) *= -1.0;\\n\\u00a0     }\\n\\u00a0 \\nSolverCGDefinition solver_cg.h:179\\nSolverControlDefinition solver_control.h:67\\nSecond, apply the top right block (B^T)\\n\\u00a0     {\\n\\u00a0       system_matrix.block(0, 1).vmult(utmp, dst.block(1));\\n\\u00a0       utmp *= -1.0;\\n\\u00a0       utmp += src.block(0);\\n\\u00a0     }\\n\\u00a0 \\nFinally, either solve with the top left block or just apply one preconditioner sweep\\n\\u00a0     if (do_solve_A == true)\\n\\u00a0       {\\n\\u00a0         SolverControl            solver_control(10000, utmp.l2_norm() * 1e-4);\\n\\u00a0         SolverCG<Vector<double>> cg(solver_control);\\n\\u00a0 \\n\\u00a0         dst.block(0) = 0.0;\\n\\u00a0         cg.solve(system_matrix.block(0, 0),\\n\\u00a0                  dst.block(0),\\n\\u00a0                  utmp,\\n\\u00a0                  preconditioner_A);\\n\\u00a0 \\n\\u00a0         n_iterations_A += solver_control.last_step();\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       {\\n\\u00a0         preconditioner_A.vmult(dst.block(0), utmp);\\n\\u00a0         n_iterations_A += 1;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\n The StokesProblem class\\nThis is the main class of the problem.\\n\\u00a0   template <int dim>\\n\\u00a0   class StokesProblem\\n\\u00a0   {\\n\\u00a0   public:\\n\\u00a0     StokesProblem(const unsigned int pressure_degree,\\n\\u00a0                   const SolverType   solver_type);\\n\\u00a0     void run();\\n\\u00a0 \\n\\u00a0   private:\\n\\u00a0     void setup_dofs();\\n\\u00a0     void assemble_system();\\n\\u00a0     void assemble_multigrid();\\n\\u00a0     void solve();\\n\\u00a0     void compute_errors();\\n\\u00a0     void output_results(const unsigned int refinement_cycle) const;\\n\\u00a0 \\n\\u00a0     const unsigned int pressure_degree;\\n\\u00a0     const SolverType   solver_type;\\n\\u00a0 \\n\\u00a0     Triangulation<dim> triangulation;\\n\\u00a0     const FESystem<dim> velocity_fe;\\n\\u00a0     const FESystem<dim> fe;\\n\\u00a0     DoFHandler<dim>     dof_handler;\\n\\u00a0     DoFHandler<dim>     velocity_dof_handler;\\n\\u00a0 \\n\\u00a0     AffineConstraints<double> constraints;\\n\\u00a0 \\n\\u00a0     BlockSparsityPattern      sparsity_pattern;\\n\\u00a0     BlockSparseMatrix<double> system_matrix;\\n\\u00a0     SparseMatrix<double>      pressure_mass_matrix;\\n\\u00a0 \\n\\u00a0     BlockVector<double> solution;\\n\\u00a0     BlockVector<double> system_rhs;\\n\\u00a0 \\n\\u00a0     MGLevelObject<SparsityPattern>      mg_sparsity_patterns;\\n\\u00a0     MGLevelObject<SparseMatrix<double>> mg_matrices;\\n\\u00a0     MGLevelObject<SparseMatrix<double>> mg_interface_matrices;\\n\\u00a0     MGConstrainedDoFs                   mg_constrained_dofs;\\n\\u00a0 \\n\\u00a0     TimerOutput computing_timer;\\n\\u00a0   };\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\n\\u00a0   template <int dim>\\n\\u00a0   StokesProblem<dim>::StokesProblem(const unsigned int pressure_degree,\\n\\u00a0                                     const SolverType   solver_type)\\n\\u00a0 \\n\\u00a0     : pressure_degree(pressure_degree)\\n\\u00a0     , solver_type(solver_type)\\n\\u00a0     , triangulation(Triangulation<dim>::maximum_smoothing)\\n\\u00a0     ,\\nAffineConstraintsDefinition affine_constraints.h:507\\nBlockSparsityPatternDefinition block_sparsity_pattern.h:437\\nDoFHandlerDefinition dof_handler.h:317\\nFESystemDefinition fe_system.h:208\\nMGConstrainedDoFsDefinition mg_constrained_dofs.h:45\\nMGLevelObjectDefinition mg_level_object.h:49\\nTimerOutputDefinition timer.h:549\\nTriangulationDefinition tria.h:1323\\ntriangulationconst ::parallel::distributed::Triangulation< dim, spacedim > * triangulationDefinition p4est_wrappers.cc:68\\nFinite element for the velocity only:\\n\\u00a0     velocity_fe(FE_Q<dim>(pressure_degree + 1) ^ dim)\\n\\u00a0     ,\\nFE_QDefinition fe_q.h:554\\nFinite element for the whole system:\\n\\u00a0     fe(velocity_fe, FE_Q<dim>(pressure_degree))\\n\\u00a0     , dof_handler(triangulation)\\n\\u00a0     , velocity_dof_handler(triangulation)\\n\\u00a0     , computing_timer(std::cout, TimerOutput::never, TimerOutput::wall_times)\\n\\u00a0   {}\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nTimerOutput::wall_times@ wall_timesDefinition timer.h:651\\nTimerOutput::never@ neverDefinition timer.h:615\\n StokesProblem::setup_dofs\\nThis function sets up the DoFHandler, matrices, vectors, and Multigrid structures (if needed).\\n\\u00a0   template <int dim>\\n\\u00a0   void StokesProblem<dim>::setup_dofs()\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope scope(computing_timer, \\\"Setup\\\");\\n\\u00a0 \\n\\u00a0     system_matrix.clear();\\n\\u00a0     pressure_mass_matrix.clear();\\n\\u00a0 \\nTimerOutput::ScopeDefinition timer.h:557\\nThe main DoFHandler only needs active DoFs, so we are not calling distribute_mg_dofs() here\\n\\u00a0     dof_handler.distribute_dofs(fe);\\n\\u00a0 \\nThis block structure separates the dim velocity components from the pressure component (used for reordering). Note that we have 2 instead of dim+1 blocks like in step-22, because our FESystem is nested and the dim velocity components appear as one block.\\n\\u00a0     std::vector<unsigned int> block_component(2);\\n\\u00a0     block_component[0] = 0;\\n\\u00a0     block_component[1] = 1;\\n\\u00a0 \\nVelocities start at component 0:\\n\\u00a0     const FEValuesExtractors::Vector velocities(0);\\n\\u00a0 \\nFEValuesExtractors::VectorDefinition fe_values_extractors.h:150\\nILU behaves better if we apply a reordering to reduce fillin. There is no advantage in doing this for the other solvers.\\n\\u00a0     if (solver_type == SolverType::FGMRES_ILU)\\n\\u00a0       {\\n\\u00a0         TimerOutput::Scope ilu_specific(computing_timer, \\\"(ILU specific)\\\");\\n\\u00a0         DoFRenumbering::Cuthill_McKee(dof_handler);\\n\\u00a0       }\\n\\u00a0 \\nDoFRenumbering::Cuthill_McKeevoid Cuthill_McKee(DoFHandler< dim, spacedim > &dof_handler, const bool reversed_numbering=false, const bool use_constraints=false, const std::vector< types::global_dof_index > &starting_indices=std::vector< types::global_dof_index >())Definition dof_renumbering.cc:366\\nThis ensures that all velocities DoFs are enumerated before the pressure unknowns. This allows us to use blocks for vectors and matrices and allows us to get the same DoF numbering for dof_handler and velocity_dof_handler.\\n\\u00a0     DoFRenumbering::block_wise(dof_handler);\\n\\u00a0 \\n\\u00a0     if (solver_type == SolverType::FGMRES_GMG)\\n\\u00a0       {\\n\\u00a0         TimerOutput::Scope multigrid_specific(computing_timer,\\n\\u00a0                                               \\\"(Multigrid specific)\\\");\\n\\u00a0         TimerOutput::Scope setup_multigrid(computing_timer,\\n\\u00a0                                            \\\"Setup - Multigrid\\\");\\n\\u00a0 \\nDoFRenumbering::block_wisevoid block_wise(DoFHandler< dim, spacedim > &dof_handler)Definition dof_renumbering.cc:997\\nThis distributes the active dofs and multigrid dofs for the velocity space in a separate DoFHandler as described in the introduction.\\n\\u00a0         velocity_dof_handler.distribute_dofs(velocity_fe);\\n\\u00a0         velocity_dof_handler.distribute_mg_dofs();\\n\\u00a0 \\nThe following block of code initializes the MGConstrainedDofs (using the boundary conditions for the velocity), and the sparsity patterns and matrices for each level. The resize() function of MGLevelObject<T> will destroy all existing contained objects.\\n\\u00a0         const std::set<types::boundary_id> zero_boundary_ids = {0};\\n\\u00a0 \\n\\u00a0         mg_constrained_dofs.clear();\\n\\u00a0         mg_constrained_dofs.initialize(velocity_dof_handler);\\n\\u00a0         mg_constrained_dofs.make_zero_boundary_constraints(velocity_dof_handler,\\n\\u00a0                                                            zero_boundary_ids);\\n\\u00a0         const unsigned int n_levels = triangulation.n_levels();\\n\\u00a0 \\n\\u00a0         mg_interface_matrices.resize(0, n_levels - 1);\\n\\u00a0         mg_matrices.resize(0, n_levels - 1);\\n\\u00a0         mg_sparsity_patterns.resize(0, n_levels - 1);\\n\\u00a0 \\n\\u00a0         for (unsigned int level = 0; level < n_levels; ++level)\\n\\u00a0           {\\n\\u00a0             DynamicSparsityPattern csp(velocity_dof_handler.n_dofs(level),\\n\\u00a0                                        velocity_dof_handler.n_dofs(level));\\n\\u00a0             MGTools::make_sparsity_pattern(velocity_dof_handler, csp, level);\\n\\u00a0             mg_sparsity_patterns[level].copy_from(csp);\\n\\u00a0 \\n\\u00a0             mg_matrices[level].reinit(mg_sparsity_patterns[level]);\\n\\u00a0             mg_interface_matrices[level].reinit(mg_sparsity_patterns[level]);\\n\\u00a0           }\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     const std::vector<types::global_dof_index> dofs_per_block =\\n\\u00a0       DoFTools::count_dofs_per_fe_block(dof_handler, block_component);\\n\\u00a0     const unsigned int n_u = dofs_per_block[0];\\n\\u00a0     const unsigned int n_p = dofs_per_block[1];\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       constraints.clear();\\nDynamicSparsityPatternDefinition dynamic_sparsity_pattern.h:322\\nTriangulation::n_levelsunsigned int n_levels() const\\nlevelunsigned int levelDefinition grid_out.cc:4626\\nDoFTools::count_dofs_per_fe_blockstd::vector< types::global_dof_index > count_dofs_per_fe_block(const DoFHandler< dim, spacedim > &dof, const std::vector< unsigned int > &target_block=std::vector< unsigned int >())Definition dof_tools.cc:2104\\nMGTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity, const unsigned int level, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true)Definition mg_tools.cc:575\\nThe following makes use of a component mask for interpolation of the boundary values for the velocity only, which is further explained in the vector valued dealii step-20 tutorial.\\n\\u00a0       DoFTools::make_hanging_node_constraints(dof_handler, constraints);\\n\\u00a0       VectorTools::interpolate_boundary_values(dof_handler,\\n\\u00a0                                                0,\\n\\u00a0                                                Solution<dim>(),\\n\\u00a0                                                constraints,\\n\\u00a0                                                fe.component_mask(velocities));\\n\\u00a0 \\nDoFTools::make_hanging_node_constraintsvoid make_hanging_node_constraints(const DoFHandler< dim, spacedim > &dof_handler, AffineConstraints< number > &constraints)Definition dof_tools_constraints.cc:3073\\nVectorTools::interpolate_boundary_valuesvoid interpolate_boundary_values(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const std::map< types::boundary_id, const Function< spacedim, number > * > &function_map, std::map< types::global_dof_index, number > &boundary_values, const ComponentMask &component_mask={})\\nAs discussed in the introduction, we need to fix one degree of freedom of the pressure variable to ensure solvability of the problem. We do this here by marking the first pressure dof, which has index n_u as a constrained dof.\\n\\u00a0       if (solver_type == SolverType::UMFPACK)\\n\\u00a0         constraints.constrain_dof_to_zero(n_u);\\n\\u00a0 \\n\\u00a0       constraints.close();\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0     std::cout << \\\"\\\\tNumber of active cells: \\\" << triangulation.n_active_cells()\\n\\u00a0               << std::endl\\n\\u00a0               << \\\"\\\\tNumber of degrees of freedom: \\\" << dof_handler.n_dofs()\\n\\u00a0               << \\\" (\\\" << n_u << '+' << n_p << ')' << std::endl;\\n\\u00a0 \\n\\u00a0     {\\n\\u00a0       BlockDynamicSparsityPattern csp(dofs_per_block, dofs_per_block);\\n\\u00a0       DoFTools::make_sparsity_pattern(dof_handler, csp, constraints, false);\\n\\u00a0       sparsity_pattern.copy_from(csp);\\n\\u00a0     }\\n\\u00a0     system_matrix.reinit(sparsity_pattern);\\n\\u00a0 \\n\\u00a0     solution.reinit(dofs_per_block);\\n\\u00a0     system_rhs.reinit(dofs_per_block);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nBlockDynamicSparsityPatternDefinition block_sparsity_pattern.h:549\\nTriangulation::n_active_cellsunsigned int n_active_cells() const\\nDoFTools::make_sparsity_patternvoid make_sparsity_pattern(const DoFHandler< dim, spacedim > &dof_handler, SparsityPatternBase &sparsity_pattern, const AffineConstraints< number > &constraints={}, const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)Definition dof_tools_sparsity.cc:56\\n StokesProblem::assemble_system\\nIn this function, the system matrix is assembled. We assemble the pressure mass matrix in the (1,1) block (if needed) and move it out of this location at the end of this function.\\n\\u00a0   template <int dim>\\n\\u00a0   void StokesProblem<dim>::assemble_system()\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope assemble(computing_timer, \\\"Assemble\\\");\\n\\u00a0     system_matrix = 0;\\n\\u00a0     system_rhs    = 0;\\n\\u00a0 \\nIf true, we will assemble the pressure mass matrix in the (1,1) block:\\n\\u00a0     const bool assemble_pressure_mass_matrix =\\n\\u00a0       (solver_type == SolverType::UMFPACK) ? false : true;\\n\\u00a0 \\n\\u00a0     const QGauss<dim> quadrature_formula(pressure_degree + 2);\\n\\u00a0 \\n\\u00a0     FEValues<dim> fe_values(fe,\\n\\u00a0                             quadrature_formula,\\n\\u00a0                             update_values | update_quadrature_points |\\n\\u00a0                               update_JxW_values | update_gradients);\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n\\u00a0 \\n\\u00a0     const unsigned int n_q_points = quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0     Vector<double>     local_rhs(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     const RightHandSide<dim>    right_hand_side;\\n\\u00a0     std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim + 1));\\n\\u00a0 \\n\\u00a0     const FEValuesExtractors::Vector velocities(0);\\n\\u00a0     const FEValuesExtractors::Scalar pressure(dim);\\n\\u00a0 \\n\\u00a0     std::vector<SymmetricTensor<2, dim>> symgrad_phi_u(dofs_per_cell);\\n\\u00a0     std::vector<double>                  div_phi_u(dofs_per_cell);\\n\\u00a0     std::vector<double>                  phi_p(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     for (const auto &cell : dof_handler.active_cell_iterators())\\n\\u00a0       {\\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0         local_matrix = 0;\\n\\u00a0         local_rhs    = 0;\\n\\u00a0 \\n\\u00a0         right_hand_side.vector_value_list(fe_values.get_quadrature_points(),\\n\\u00a0                                           rhs_values);\\n\\u00a0 \\n\\u00a0         for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0           {\\n\\u00a0             for (unsigned int k = 0; k < dofs_per_cell; ++k)\\n\\u00a0               {\\n\\u00a0                 symgrad_phi_u[k] =\\n\\u00a0                   fe_values[velocities].symmetric_gradient(k, q);\\n\\u00a0                 div_phi_u[k] = fe_values[velocities].divergence(k, q);\\n\\u00a0                 phi_p[k]     = fe_values[pressure].value(k, q);\\n\\u00a0               }\\n\\u00a0 \\n\\u00a0             for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0               {\\n\\u00a0                 for (unsigned int j = 0; j <= i; ++j)\\n\\u00a0                   {\\n\\u00a0                     local_matrix(i, j) +=\\n\\u00a0                       (2 * (symgrad_phi_u[i] * symgrad_phi_u[j]) -\\n\\u00a0                        div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j] +\\n\\u00a0                        (assemble_pressure_mass_matrix ? phi_p[i] * phi_p[j] :\\n\\u00a0                                                         0)) *\\n\\u00a0                       fe_values.JxW(q);\\n\\u00a0                   }\\n\\u00a0 \\n\\u00a0                 const unsigned int component_i =\\n\\u00a0                   fe.system_to_component_index(i).first;\\n\\u00a0                 local_rhs(i) += fe_values.shape_value(i, q) *\\n\\u00a0                                 rhs_values[q](component_i) * fe_values.JxW(q);\\n\\u00a0               }\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0           for (unsigned int j = i + 1; j < dofs_per_cell; ++j)\\n\\u00a0             local_matrix(i, j) = local_matrix(j, i);\\n\\u00a0 \\n\\u00a0         cell->get_dof_indices(local_dof_indices);\\n\\u00a0         constraints.distribute_local_to_global(local_matrix,\\n\\u00a0                                                local_rhs,\\n\\u00a0                                                local_dof_indices,\\n\\u00a0                                                system_matrix,\\n\\u00a0                                                system_rhs);\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     if (solver_type != SolverType::UMFPACK)\\n\\u00a0       {\\n\\u00a0         pressure_mass_matrix.reinit(sparsity_pattern.block(1, 1));\\n\\u00a0         pressure_mass_matrix.copy_from(system_matrix.block(1, 1));\\n\\u00a0         system_matrix.block(1, 1) = 0;\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\nFEValuesDefinition fe_values.h:63\\nFullMatrixDefinition full_matrix.h:79\\nQGaussDefinition quadrature_lib.h:40\\nupdate_values@ update_valuesShape function values.Definition fe_update_flags.h:75\\nupdate_JxW_values@ update_JxW_valuesTransformed quadrature weights.Definition fe_update_flags.h:134\\nupdate_gradients@ update_gradientsShape function gradients.Definition fe_update_flags.h:81\\nupdate_quadrature_points@ update_quadrature_pointsTransformed quadrature points.Definition fe_update_flags.h:127\\nFEValuesExtractors::ScalarDefinition fe_values_extractors.h:95\\n StokesProblem::assemble_multigrid\\nHere, like in step-16, we have a function that assembles the level and interface matrices necessary for the multigrid preconditioner.\\n\\u00a0   template <int dim>\\n\\u00a0   void StokesProblem<dim>::assemble_multigrid()\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope multigrid_specific(computing_timer,\\n\\u00a0                                           \\\"(Multigrid specific)\\\");\\n\\u00a0     TimerOutput::Scope assemble_multigrid(computing_timer,\\n\\u00a0                                           \\\"Assemble Multigrid\\\");\\n\\u00a0 \\n\\u00a0     mg_matrices = 0.;\\n\\u00a0 \\n\\u00a0     const QGauss<dim> quadrature_formula(pressure_degree + 2);\\n\\u00a0 \\n\\u00a0     FEValues<dim> fe_values(velocity_fe,\\n\\u00a0                             quadrature_formula,\\n\\u00a0                             update_values | update_quadrature_points |\\n\\u00a0                               update_JxW_values | update_gradients);\\n\\u00a0 \\n\\u00a0     const unsigned int dofs_per_cell = velocity_fe.n_dofs_per_cell();\\n\\u00a0     const unsigned int n_q_points    = quadrature_formula.size();\\n\\u00a0 \\n\\u00a0     FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n\\u00a0 \\n\\u00a0     std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     const FEValuesExtractors::Vector velocities(0);\\n\\u00a0 \\n\\u00a0     std::vector<SymmetricTensor<2, dim>> symgrad_phi_u(dofs_per_cell);\\n\\u00a0 \\n\\u00a0     std::vector<AffineConstraints<double>> boundary_constraints(\\n\\u00a0       triangulation.n_levels());\\n\\u00a0     std::vector<AffineConstraints<double>> boundary_interface_constraints(\\n\\u00a0       triangulation.n_levels());\\n\\u00a0     for (unsigned int level = 0; level < triangulation.n_levels(); ++level)\\n\\u00a0       {\\n\\u00a0         for (const types::global_dof_index dof_index :\\n\\u00a0              mg_constrained_dofs.get_refinement_edge_indices(level))\\n\\u00a0           boundary_constraints[level].constrain_dof_to_zero(dof_index);\\n\\u00a0         for (const types::global_dof_index dof_index :\\n\\u00a0              mg_constrained_dofs.get_boundary_indices(level))\\n\\u00a0           boundary_constraints[level].constrain_dof_to_zero(dof_index);\\n\\u00a0         boundary_constraints[level].close();\\n\\u00a0 \\n\\u00a0         const IndexSet idx =\\n\\u00a0           mg_constrained_dofs.get_refinement_edge_indices(level) &\\n\\u00a0           mg_constrained_dofs.get_boundary_indices(level);\\n\\u00a0 \\n\\u00a0         for (const types::global_dof_index dof_index : idx)\\n\\u00a0           boundary_interface_constraints[level].add_constraint(dof_index,\\n\\u00a0                                                                {},\\n\\u00a0                                                                0.);\\n\\u00a0         boundary_interface_constraints[level].close();\\n\\u00a0       }\\n\\u00a0 \\nIndexSetDefinition index_set.h:70\\nunsigned int\\nThis iterator goes over all cells (not just active)\\n\\u00a0     for (const auto &cell : velocity_dof_handler.cell_iterators())\\n\\u00a0       {\\n\\u00a0         fe_values.reinit(cell);\\n\\u00a0         cell_matrix = 0;\\n\\u00a0 \\n\\u00a0         for (unsigned int q = 0; q < n_q_points; ++q)\\n\\u00a0           {\\n\\u00a0             for (unsigned int k = 0; k < dofs_per_cell; ++k)\\n\\u00a0               symgrad_phi_u[k] = fe_values[velocities].symmetric_gradient(k, q);\\n\\u00a0 \\n\\u00a0             for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0               for (unsigned int j = 0; j <= i; ++j)\\n\\u00a0                 {\\n\\u00a0                   cell_matrix(i, j) +=\\n\\u00a0                     (symgrad_phi_u[i] * symgrad_phi_u[j]) * fe_values.JxW(q);\\n\\u00a0                 }\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0           for (unsigned int j = i + 1; j < dofs_per_cell; ++j)\\n\\u00a0             cell_matrix(i, j) = cell_matrix(j, i);\\n\\u00a0 \\n\\u00a0         cell->get_mg_dof_indices(local_dof_indices);\\n\\u00a0 \\n\\u00a0         boundary_constraints[cell->level()].distribute_local_to_global(\\n\\u00a0           cell_matrix, local_dof_indices, mg_matrices[cell->level()]);\\n\\u00a0 \\n\\u00a0         for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n\\u00a0           for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n\\u00a0             if (!mg_constrained_dofs.at_refinement_edge(cell->level(),\\n\\u00a0                                                         local_dof_indices[i]) ||\\n\\u00a0                 mg_constrained_dofs.at_refinement_edge(cell->level(),\\n\\u00a0                                                        local_dof_indices[j]))\\n\\u00a0               cell_matrix(i, j) = 0;\\n\\u00a0 \\n\\u00a0         boundary_interface_constraints[cell->level()]\\n\\u00a0           .distribute_local_to_global(cell_matrix,\\n\\u00a0                                       local_dof_indices,\\n\\u00a0                                       mg_interface_matrices[cell->level()]);\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 \\nLocalIntegrators::Advection::cell_matrixvoid cell_matrix(FullMatrix< double > &M, const FEValuesBase< dim > &fe, const FEValuesBase< dim > &fetest, const ArrayView< const std::vector< double > > &velocity, const double factor=1.)Definition advection.h:74\\n StokesProblem::solve\\nThis function sets up things differently based on if you want to use ILU or GMG as a preconditioner. Both methods share the same solver (FGMRES) but require a different preconditioner to be initialized. Here we time not only the entire solve function, but we separately time the setup of the preconditioner as well as the solve itself.\\n\\u00a0   template <int dim>\\n\\u00a0   void StokesProblem<dim>::solve()\\n\\u00a0   {\\n\\u00a0     TimerOutput::Scope solve(computing_timer, \\\"Solve\\\");\\n\\u00a0     constraints.set_zero(solution);\\n\\u00a0 \\n\\u00a0     if (solver_type == SolverType::UMFPACK)\\n\\u00a0       {\\n\\u00a0         computing_timer.enter_subsection(\\\"(UMFPACK specific)\\\");\\n\\u00a0         computing_timer.enter_subsection(\\\"Solve - Initialize\\\");\\n\\u00a0 \\n\\u00a0         SparseDirectUMFPACK A_direct;\\n\\u00a0         A_direct.initialize(system_matrix);\\n\\u00a0 \\n\\u00a0         computing_timer.leave_subsection();\\n\\u00a0         computing_timer.leave_subsection();\\n\\u00a0 \\n\\u00a0         {\\n\\u00a0           TimerOutput::Scope solve_backslash(computing_timer,\\n\\u00a0                                              \\\"Solve - Backslash\\\");\\n\\u00a0           A_direct.vmult(solution, system_rhs);\\n\\u00a0         }\\n\\u00a0 \\n\\u00a0         constraints.distribute(solution);\\n\\u00a0         return;\\n\\u00a0       }\\n\\u00a0 \\nSparseDirectUMFPACKDefinition sparse_direct.h:92\\nSparseDirectUMFPACK::initializevoid initialize(const SparsityPattern &sparsity_pattern)Definition sparse_direct.cc:67\\nHere we must make sure to solve for the residual with \\\"good enough\\\" accuracy\\n\\u00a0     SolverControl solver_control(system_matrix.m(),\\n\\u00a0                                  1e-10 * system_rhs.l2_norm());\\n\\u00a0     unsigned int  n_iterations_A;\\n\\u00a0     unsigned int  n_iterations_S;\\n\\u00a0 \\nThis is used to pass whether or not we want to solve for A inside the preconditioner. One could change this to false to see if there is still convergence and if so does the program then run faster or slower\\n\\u00a0     const bool use_expensive = true;\\n\\u00a0 \\n\\u00a0     SolverFGMRES<BlockVector<double>> solver(solver_control);\\n\\u00a0 \\n\\u00a0     if (solver_type == SolverType::FGMRES_ILU)\\n\\u00a0       {\\n\\u00a0         computing_timer.enter_subsection(\\\"(ILU specific)\\\");\\n\\u00a0         computing_timer.enter_subsection(\\\"Solve - Set-up Preconditioner\\\");\\n\\u00a0 \\n\\u00a0         std::cout << \\\"   Computing preconditioner...\\\" << std::endl\\n\\u00a0                   << std::flush;\\n\\u00a0 \\n\\u00a0         SparseILU<double> A_preconditioner;\\n\\u00a0         A_preconditioner.initialize(system_matrix.block(0, 0));\\n\\u00a0 \\n\\u00a0         SparseILU<double> S_preconditioner;\\n\\u00a0         S_preconditioner.initialize(pressure_mass_matrix);\\n\\u00a0 \\n\\u00a0         const BlockSchurPreconditioner<SparseILU<double>, SparseILU<double>>\\n\\u00a0           preconditioner(system_matrix,\\n\\u00a0                          pressure_mass_matrix,\\n\\u00a0                          A_preconditioner,\\n\\u00a0                          S_preconditioner,\\n\\u00a0                          use_expensive);\\n\\u00a0 \\n\\u00a0         computing_timer.leave_subsection();\\n\\u00a0         computing_timer.leave_subsection();\\n\\u00a0 \\n\\u00a0         {\\n\\u00a0           TimerOutput::Scope solve_fmgres(computing_timer, \\\"Solve - FGMRES\\\");\\n\\u00a0 \\n\\u00a0           solver.solve(system_matrix, solution, system_rhs, preconditioner);\\n\\u00a0           n_iterations_A = preconditioner.n_iterations_A;\\n\\u00a0           n_iterations_S = preconditioner.n_iterations_S;\\n\\u00a0         }\\n\\u00a0       }\\n\\u00a0     else\\n\\u00a0       {\\n\\u00a0         computing_timer.enter_subsection(\\\"(Multigrid specific)\\\");\\n\\u00a0         computing_timer.enter_subsection(\\\"Solve - Set-up Preconditioner\\\");\\n\\u00a0 \\nSolverFGMRESDefinition solver_gmres.h:648\\nSparseILUDefinition sparse_ilu.h:60\\nSparseILU::initializevoid initialize(const SparseMatrix< somenumber > &matrix, const AdditionalData &parameters=AdditionalData())\\nTransfer operators between levels\\n\\u00a0         MGTransferPrebuilt<Vector<double>> mg_transfer(mg_constrained_dofs);\\n\\u00a0         mg_transfer.build(velocity_dof_handler);\\n\\u00a0 \\nMGTransferPrebuiltDefinition mg_transfer.h:628\\nSetup coarse grid solver\\n\\u00a0         FullMatrix<double> coarse_matrix;\\n\\u00a0         coarse_matrix.copy_from(mg_matrices[0]);\\n\\u00a0         MGCoarseGridHouseholder<double, Vector<double>> coarse_grid_solver;\\n\\u00a0         coarse_grid_solver.initialize(coarse_matrix);\\n\\u00a0 \\n\\u00a0         using Smoother = PreconditionSOR<SparseMatrix<double>>;\\n\\u00a0         mg::SmootherRelaxation<Smoother, Vector<double>> mg_smoother;\\n\\u00a0         mg_smoother.initialize(mg_matrices);\\n\\u00a0         mg_smoother.set_steps(2);\\n\\u00a0 \\nFullMatrix::copy_fromvoid copy_from(const MatrixType &)\\nMGCoarseGridHouseholderDefinition mg_coarse.h:177\\nMGCoarseGridHouseholder::initializevoid initialize(const FullMatrix< number > &A)\\nPreconditionSORDefinition precondition.h:1726\\nmg::SmootherRelaxationDefinition mg_smoother.h:186\\nmg::SmootherRelaxation::initializevoid initialize(const MGLevelObject< MatrixType2 > &matrices, const typename RelaxationType::AdditionalData &additional_data=typename RelaxationType::AdditionalData())\\nMultigrid, when used as a preconditioner for CG, needs to be a symmetric operator, so the smoother must be symmetric\\n\\u00a0         mg_smoother.set_symmetric(true);\\n\\u00a0 \\n\\u00a0         mg::Matrix<Vector<double>> mg_matrix(mg_matrices);\\n\\u00a0         mg::Matrix<Vector<double>> mg_interface_up(mg_interface_matrices);\\n\\u00a0         mg::Matrix<Vector<double>> mg_interface_down(mg_interface_matrices);\\n\\u00a0 \\nmg::MatrixDefinition mg_matrix.h:46\\nNow, we are ready to set up the V-cycle operator and the multilevel preconditioner.\\n\\u00a0         Multigrid<Vector<double>> mg(\\n\\u00a0           mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);\\n\\u00a0         mg.set_edge_matrices(mg_interface_down, mg_interface_up);\\n\\u00a0 \\n\\u00a0         PreconditionMG<dim, Vector<double>, MGTransferPrebuilt<Vector<double>>>\\n\\u00a0           A_Multigrid(velocity_dof_handler, mg, mg_transfer);\\n\\u00a0 \\n\\u00a0         SparseILU<double> S_preconditioner;\\n\\u00a0         S_preconditioner.initialize(pressure_mass_matrix,\\n\\u00a0                                     SparseILU<double>::AdditionalData());\\n\\u00a0 \\n\\u00a0         const BlockSchurPreconditioner<\\n\\u00a0           PreconditionMG<dim,\\n\\u00a0                          Vector<double>,\\n\\u00a0                          MGTransferPrebuilt<Vector<double>>>,\\n\\u00a0           SparseILU<double>>\\n\\u00a0           preconditioner(system_matrix,\\n\\u00a0                          pressure_mass_matrix,\\n\\u00a0                          A_Multigrid,\\n\\u00a0                          S_preconditioner,\\n\\u00a0                          use_expensive);\\n\\u00a0 \\n\\u00a0         computing_timer.leave_subsection();\\n\\u00a0         computing_timer.leave_subsection();\\n\\u00a0 \\n\\u00a0         {\\n\\u00a0           TimerOutput::Scope solve_fmgres(computing_timer, \\\"Solve - FGMRES\\\");\\n\\u00a0           solver.solve(system_matrix, solution, system_rhs, preconditioner);\\n\\u00a0           n_iterations_A = preconditioner.n_iterations_A;\\n\\u00a0           n_iterations_S = preconditioner.n_iterations_S;\\n\\u00a0         }\\n\\u00a0       }\\n\\u00a0 \\n\\u00a0     constraints.distribute(solution);\\n\\u00a0 \\n\\u00a0     std::cout\\n\\u00a0       << std::endl\\n\\u00a0       << \\\"\\\\tNumber of FGMRES iterations: \\\" << solver_control.last_step()\\n\\u00a0       << std::endl\\n\\u00a0       << \\\"\\\\tTotal number of iterations used for approximation of A inverse: \\\"\\n\\u00a0       << n_iterations_A << std::endl\\n\\u00a0       << \\\"\\\\tTotal number of iterations used for approximation of S inverse: \\\"\\n\\u00a0       << n_iterations_S << std::endl\\n\\u00a0       << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nMultigridDefinition multigrid.h:163\\nPreconditionMGDefinition multigrid.h:501\\nSparseILU::AdditionalDatatypename SparseLUDecomposition< number >::AdditionalData AdditionalDataDefinition sparse_ilu.h:79\\nmgDefinition mg.h:81\\n StokesProblem::process_solution\\nThis function computes the L2 and H1 errors of the solution. For this, we need to make sure the pressure has mean zero.\\n\\u00a0   template <int dim>\\n\\u00a0   void StokesProblem<dim>::compute_errors()\\n\\u00a0   {\\nCompute the mean pressure \\\\(\\\\frac{1}{\\\\Omega} \\\\int_{\\\\Omega} p(x) dx \\\\) and then subtract it from each pressure coefficient. This will result in a pressure with mean value zero. Here we make use of the fact that the pressure is component \\\\(dim\\\\) and that the finite element space is nodal.\\n\\u00a0     const double mean_pressure = VectorTools::compute_mean_value(\\n\\u00a0       dof_handler, QGauss<dim>(pressure_degree + 2), solution, dim);\\n\\u00a0     solution.block(1).add(-mean_pressure);\\n\\u00a0     std::cout << \\\"   Note: The mean value was adjusted by \\\" << -mean_pressure\\n\\u00a0               << std::endl;\\n\\u00a0 \\n\\u00a0     const ComponentSelectFunction<dim> pressure_mask(dim, dim + 1);\\n\\u00a0     const ComponentSelectFunction<dim> velocity_mask(std::make_pair(0, dim),\\n\\u00a0                                                      dim + 1);\\n\\u00a0 \\n\\u00a0     Vector<float> difference_per_cell(triangulation.n_active_cells());\\n\\u00a0     VectorTools::integrate_difference(dof_handler,\\n\\u00a0                                       solution,\\n\\u00a0                                       Solution<dim>(),\\n\\u00a0                                       difference_per_cell,\\n\\u00a0                                       QGauss<dim>(pressure_degree + 2),\\n\\u00a0                                       VectorTools::L2_norm,\\n\\u00a0                                       &velocity_mask);\\n\\u00a0 \\n\\u00a0     const double Velocity_L2_error =\\n\\u00a0       VectorTools::compute_global_error(triangulation,\\n\\u00a0                                         difference_per_cell,\\n\\u00a0                                         VectorTools::L2_norm);\\n\\u00a0 \\n\\u00a0     VectorTools::integrate_difference(dof_handler,\\n\\u00a0                                       solution,\\n\\u00a0                                       Solution<dim>(),\\n\\u00a0                                       difference_per_cell,\\n\\u00a0                                       QGauss<dim>(pressure_degree + 2),\\n\\u00a0                                       VectorTools::L2_norm,\\n\\u00a0                                       &pressure_mask);\\n\\u00a0 \\n\\u00a0     const double Pressure_L2_error =\\n\\u00a0       VectorTools::compute_global_error(triangulation,\\n\\u00a0                                         difference_per_cell,\\n\\u00a0                                         VectorTools::L2_norm);\\n\\u00a0 \\n\\u00a0     VectorTools::integrate_difference(dof_handler,\\n\\u00a0                                       solution,\\n\\u00a0                                       Solution<dim>(),\\n\\u00a0                                       difference_per_cell,\\n\\u00a0                                       QGauss<dim>(pressure_degree + 2),\\n\\u00a0                                       VectorTools::H1_norm,\\n\\u00a0                                       &velocity_mask);\\n\\u00a0 \\n\\u00a0     const double Velocity_H1_error =\\n\\u00a0       VectorTools::compute_global_error(triangulation,\\n\\u00a0                                         difference_per_cell,\\n\\u00a0                                         VectorTools::H1_norm);\\n\\u00a0 \\n\\u00a0     std::cout << std::endl\\n\\u00a0               << \\\"   Velocity L2 Error: \\\" << Velocity_L2_error << std::endl\\n\\u00a0               << \\\"   Pressure L2 Error: \\\" << Pressure_L2_error << std::endl\\n\\u00a0               << \\\"   Velocity H1 Error: \\\" << Velocity_H1_error << std::endl;\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\nComponentSelectFunctionDefinition function.h:582\\nVectorTools::compute_global_errordouble compute_global_error(const Triangulation< dim, spacedim > &tria, const InVector &cellwise_error, const NormType &norm, const double exponent=2.)\\nVectorTools::H1_norm@ H1_normDefinition vector_tools_common.h:203\\nVectorTools::L2_norm@ L2_normDefinition vector_tools_common.h:112\\nVectorTools::integrate_differencevoid integrate_difference(const Mapping< dim, spacedim > &mapping, const DoFHandler< dim, spacedim > &dof, const ReadVector< Number > &fe_function, const Function< spacedim, Number > &exact_solution, OutVector &difference, const Quadrature< dim > &q, const NormType &norm, const Function< spacedim, double > *weight=nullptr, const double exponent=2.)\\nVectorTools::compute_mean_valueNumber compute_mean_value(const hp::MappingCollection< dim, spacedim > &mapping_collection, const DoFHandler< dim, spacedim > &dof, const hp::QCollection< dim > &q_collection, const ReadVector< Number > &v, const unsigned int component)\\n StokesProblem::output_results\\nThis function generates graphical output like it is done in step-22.\\n\\u00a0   template <int dim>\\n\\u00a0   void\\n\\u00a0   StokesProblem<dim>::output_results(const unsigned int refinement_cycle) const\\n\\u00a0   {\\n\\u00a0     std::vector<std::string> solution_names(dim, \\\"velocity\\\");\\n\\u00a0     solution_names.emplace_back(\\\"pressure\\\");\\n\\u00a0 \\n\\u00a0     std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n\\u00a0       data_component_interpretation(\\n\\u00a0         dim, DataComponentInterpretation::component_is_part_of_vector);\\n\\u00a0     data_component_interpretation.push_back(\\n\\u00a0       DataComponentInterpretation::component_is_scalar);\\n\\u00a0 \\n\\u00a0     DataOut<dim> data_out;\\n\\u00a0     data_out.attach_dof_handler(dof_handler);\\n\\u00a0     data_out.add_data_vector(solution,\\n\\u00a0                              solution_names,\\n\\u00a0                              DataOut<dim>::type_dof_data,\\n\\u00a0                              data_component_interpretation);\\n\\u00a0     data_out.build_patches();\\n\\u00a0 \\n\\u00a0     std::ofstream output(\\n\\u00a0       \\\"solution-\\\" + Utilities::int_to_string(refinement_cycle, 2) + \\\".vtk\\\");\\n\\u00a0     data_out.write_vtk(output);\\n\\u00a0   }\\n\\u00a0 \\n\\u00a0 \\n\\u00a0 \\nDataOut_DoFData::attach_dof_handlervoid attach_dof_handler(const DoFHandler< dim, spacedim > &)\\nDataOutDefinition data_out.h:147\\nDataComponentInterpretation::component_is_scalar@ component_is_scalarDefinition data_component_interpretation.h:52\\nDataComponentInterpretation::component_is_part_of_vector@ component_is_part_of_vectorDefinition data_component_interpretation.h:58\\nUtilities::int_to_stringstd::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)Definition utilities.cc:470\\n StokesProblem::run\\nThe last step in the Stokes class is, as usual, the function that generates the initial grid and calls the other functions in the respective order.\\n\\u00a0   template <int dim>\\n\\u00a0   void StokesProblem<dim>::run()\\n\\u00a0   {\\n\\u00a0     GridGenerator::hyper_cube(triangulation);\\n\\u00a0     triangulation.refine_global(6 - dim);\\n\\u00a0 \\n\\u00a0     if (solver_type == SolverType::FGMRES_ILU)\\n\\u00a0       std::cout << \\\"Now running with ILU\\\" << std::endl;\\n\\u00a0     else if (solver_type == SolverType::FGMRES_GMG)\\n\\u00a0       std::cout << \\\"Now running with Multigrid\\\" << std::endl;\\n\\u00a0     else\\n\\u00a0       std::cout << \\\"Now running with UMFPACK\\\" << std::endl;\\n\\u00a0 \\n\\u00a0 \\n\\u00a0     for (unsigned int refinement_cycle = 0; refinement_cycle < 3;\\n\\u00a0          ++refinement_cycle)\\n\\u00a0       {\\n\\u00a0         std::cout << \\\"Refinement cycle \\\" << refinement_cycle << std::endl;\\n\\u00a0 \\n\\u00a0         if (refinement_cycle > 0)\\n\\u00a0           triangulation.refine_global(1);\\n\\u00a0 \\n\\u00a0         std::cout << \\\"   Set-up...\\\" << std::endl;\\n\\u00a0         setup_dofs();\\n\\u00a0 \\n\\u00a0         std::cout << \\\"   Assembling...\\\" << std::endl;\\n\\u00a0         assemble_system();\\n\\u00a0 \\n\\u00a0         if (solver_type == SolverType::FGMRES_GMG)\\n\\u00a0           {\\n\\u00a0             std::cout << \\\"   Assembling Multigrid...\\\" << std::endl;\\n\\u00a0 \\n\\u00a0             assemble_multigrid();\\n\\u00a0           }\\n\\u00a0 \\n\\u00a0         std::cout << \\\"   Solving...\\\" << std::flush;\\n\\u00a0         solve();\\n\\u00a0 \\n\\u00a0         compute_errors();\\n\\u00a0 \\n\\u00a0         output_results(refinement_cycle);\\n\\u00a0 \\n\\u00a0         Utilities::System::MemoryStats mem;\\n\\u00a0         Utilities::System::get_memory_stats(mem);\\n\\u00a0         std::cout << \\\"   VM Peak: \\\" << mem.VmPeak << std::endl;\\n\\u00a0 \\n\\u00a0         computing_timer.print_summary();\\n\\u00a0         computing_timer.reset();\\n\\u00a0       }\\n\\u00a0   }\\n\\u00a0 } // namespace Step56\\n\\u00a0 \\nTriangulation::refine_globalvoid refine_global(const unsigned int times=1)\\nGridGenerator::hyper_cubevoid hyper_cube(Triangulation< dim, spacedim > &tria, const double left=0., const double right=1., const bool colorize=false)\\nUtilities::System::get_memory_statsvoid get_memory_stats(MemoryStats &stats)Definition utilities.cc:964\\nUtilities::System::MemoryStatsDefinition utilities.h:864\\n The main function\\n\\u00a0 int main()\\n\\u00a0 {\\n\\u00a0   try\\n\\u00a0     {\\n\\u00a0       using namespace Step56;\\n\\u00a0 \\n\\u00a0       const int degree = 1;\\n\\u00a0       const int dim    = 3;\\noptions for SolverType: UMFPACK FGMRES_ILU FGMRES_GMG\\n\\u00a0       StokesProblem<dim> flow_problem(degree, SolverType::FGMRES_GMG);\\n\\u00a0 \\n\\u00a0       flow_problem.run();\\n\\u00a0     }\\n\\u00a0   catch (std::exception &exc)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Exception on processing: \\\" << std::endl\\n\\u00a0                 << exc.what() << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0 \\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0   catch (...)\\n\\u00a0     {\\n\\u00a0       std::cerr << std::endl\\n\\u00a0                 << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       std::cerr << \\\"Unknown exception!\\\" << std::endl\\n\\u00a0                 << \\\"Aborting!\\\" << std::endl\\n\\u00a0                 << \\\"----------------------------------------------------\\\"\\n\\u00a0                 << std::endl;\\n\\u00a0       return 1;\\n\\u00a0     }\\n\\u00a0 \\n\\u00a0   return 0;\\n\\u00a0 }\\n Results\\nErrors \\nWe first run the code and confirm that the finite element solution converges with the correct rates as predicted by the error analysis of mixed finite element problems. Given sufficiently smooth exact solutions \\\\(u\\\\) and \\\\(p\\\\), the errors of the Taylor-Hood element \\\\(Q_k \\\\times Q_{k-1}\\\\) should be\\n\\n\\\\[\\n\\\\| u -u_h \\\\|_0 + h ( \\\\| u- u_h\\\\|_1 + \\\\|p - p_h \\\\|_0)\\n\\\\leq C h^{k+1} ( \\\\|u \\\\|_{k+1} + \\\\| p \\\\|_k )\\n\\\\]\\n\\nsee for example Ern/Guermond \\\"Theory and Practice of Finite Elements\\\", Section 4.2.5 p195. This is indeed what we observe, using the \\\\(Q_2 \\\\times Q_1\\\\) element as an example (this is what is done in the code, but is easily changed in main()):\\n\\n\\n\\u00a0 L2 Velocity Reduction L2 Pressure Reduction H1 Velocity Reduction  \\n\\n3D, 3 global refinements 0.000670888 - 0.0036533 - 0.0414704 -  \\n\\n3D, 4 global refinements 8.38E-005 8.0 0.00088494 4.1 0.0103781 4.0  \\n\\n3D, 5 global refinements 1.05E-005 8.0 0.000220253 4.0 0.00259519 4.0   \\n\\nTiming Results \\nLet us compare the direct solver approach using UMFPACK to the two methods in which we choose \\\\(\\\\widetilde {A^{-1}}=A^{-1}\\\\) and \\\\(\\\\widetilde{S^{-1}}=S^{-1}\\\\) by solving linear systems with \\\\(A,S\\\\) using CG. The preconditioner for CG is then either ILU or GMG. The following table summarizes solver iterations, timings, and virtual memory (VM) peak usage:\\n\\n\\nGeneral GMG ILU UMFPACK  \\n\\nTimings Timings Iterations Timings Iterations Timings \\n\\nCycle DoFs Setup Assembly Setup Solve Outer Inner (A) Inner (S) VM Peak Setup Solve Outer Inner (A) Inner (S) VM Peak Setup Solve VM Peak  \\n\\n0 15468 0.1s 0.3s 0.3s 1.3s 21 67 22 4805 0.3s 0.6s 21 180 22 4783 2.65s 2.8s 5054  \\n\\n1 112724 1.0s 2.4s 2.6s 14s 21 67 22 5441 2.8s 15.8s 21 320 22 5125 236s 237s 11288  \\n\\n2 859812 9.0s 20s 20s 101s 20 65 21 10641 27s 268s 21 592 22 8307 - - -  \\n\\nAs can be seen from the table:\\n\\nUMFPACK uses large amounts of memory, especially in 3d. Also, UMFPACK timings do not scale favorably with problem size.\\nBecause we are using inner solvers for \\\\(A\\\\) and \\\\(S\\\\), ILU and GMG require the same number of outer iterations.\\nThe number of (inner) iterations for \\\\(A\\\\) increases for ILU with refinement, leading to worse than linear scaling in solve time. In contrast, the number of inner iterations for \\\\(A\\\\) stays constant with GMG leading to nearly perfect scaling in solve time.\\nGMG needs slightly more memory than ILU to store the level and interface matrices.\\n\\nPossibilities for extensions \\nCheck higher order discretizations \\nExperiment with higher order stable FE pairs and check that you observe the correct convergence rates.\\nCompare with cheap preconditioner \\nThe introduction also outlined another option to precondition the overall system, namely one in which we do not choose  \\\\(\\\\widetilde\\n{A^{-1}}=A^{-1}\\\\) as in the table above, but in which \\\\(\\\\widetilde{A^{-1}}\\\\) is only a single preconditioner application with GMG or ILU, respectively.\\nThis is in fact implemented in the code: Currently, the boolean use_expensive in solve() is set to true. The option mentioned above is obtained by setting it to false.\\nWhat you will find is that the number of FGMRES iterations stays constant under refinement if you use GMG this way. This means that the Multigrid is optimal and independent of \\\\(h\\\\).\\n The plain program\\n/* ------------------------------------------------------------------------\\n *\\n * SPDX-License-Identifier: LGPL-2.1-or-later\\n * Copyright (C) 2016 - 2024 by the deal.II authors\\n *\\n * This file is part of the deal.II library.\\n *\\n * Part of the source code is dual licensed under Apache-2.0 WITH\\n * LLVM-exception OR LGPL-2.1-or-later. Detailed license information\\n * governing the source code and code contributions can be found in\\n * LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.\\n *\\n * ------------------------------------------------------------------------\\n \\n * Authors: Ryan Grove, Clemson University\\n *          Timo Heister, Clemson University\\n */\\n \\n \\n#include <deal.II/base/quadrature_lib.h>\\n#include <deal.II/base/function.h>\\n#include <deal.II/base/utilities.h>\\n \\n#include <deal.II/lac/block_vector.h>\\n#include <deal.II/lac/full_matrix.h>\\n#include <deal.II/lac/block_sparse_matrix.h>\\n#include <deal.II/lac/block_sparsity_pattern.h>\\n#include <deal.II/lac/solver_cg.h>\\n#include <deal.II/lac/precondition.h>\\n#include <deal.II/lac/affine_constraints.h>\\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\\n#include <deal.II/lac/solver_gmres.h>\\n \\n#include <deal.II/grid/tria.h>\\n#include <deal.II/grid/grid_generator.h>\\n#include <deal.II/grid/grid_tools.h>\\n#include <deal.II/grid/grid_refinement.h>\\n \\n#include <deal.II/dofs/dof_handler.h>\\n#include <deal.II/dofs/dof_renumbering.h>\\n#include <deal.II/dofs/dof_tools.h>\\n \\n#include <deal.II/fe/fe_q.h>\\n#include <deal.II/fe/fe_system.h>\\n#include <deal.II/fe/fe_values.h>\\n \\n#include <deal.II/numerics/vector_tools.h>\\n#include <deal.II/numerics/data_out.h>\\n#include <deal.II/numerics/error_estimator.h>\\n \\n#include <deal.II/lac/sparse_direct.h>\\n \\n#include <deal.II/lac/sparse_ilu.h>\\n#include <deal.II/grid/grid_out.h>\\n \\n#include <deal.II/base/timer.h>\\n \\n#include <deal.II/multigrid/multigrid.h>\\n#include <deal.II/multigrid/mg_transfer.h>\\n#include <deal.II/multigrid/mg_tools.h>\\n#include <deal.II/multigrid/mg_coarse.h>\\n#include <deal.II/multigrid/mg_smoother.h>\\n#include <deal.II/multigrid/mg_matrix.h>\\n \\n#include <iostream>\\n#include <fstream>\\n \\nnamespace Step56\\n{\\n using namespace dealii;\\n \\n enum class SolverType\\n  {\\n    FGMRES_ILU,\\n    FGMRES_GMG,\\n    UMFPACK\\n  };\\n \\n template <int dim>\\n class Solution : public Function<dim>\\n  {\\n public:\\n    Solution()\\n      : Function<dim>(dim + 1)\\n    {}\\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n virtual Tensor<1, dim>\\n gradient(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n  };\\n \\n template <>\\n double Solution<2>::value(const Point<2>    &p,\\n const unsigned int component) const\\n {\\n Assert(component <= 2 + 1, ExcIndexRange(component, 0, 2 + 1));\\n \\n using numbers::PI;\\n const double x = p[0];\\n const double y = p[1];\\n \\n if (component == 0)\\n return sin(PI * x);\\n if (component == 1)\\n return -PI * y * cos(PI * x);\\n if (component == 2)\\n return sin(PI * x) * cos(PI * y);\\n \\n return 0;\\n  }\\n \\n template <>\\n double Solution<3>::value(const Point<3>    &p,\\n const unsigned int component) const\\n {\\n Assert(component <= 3 + 1, ExcIndexRange(component, 0, 3 + 1));\\n \\n using numbers::PI;\\n const double x = p[0];\\n const double y = p[1];\\n const double z = p[2];\\n \\n if (component == 0)\\n return 2.0 * sin(PI * x);\\n if (component == 1)\\n return -PI * y * cos(PI * x);\\n if (component == 2)\\n return -PI * z * cos(PI * x);\\n if (component == 3)\\n return sin(PI * x) * cos(PI * y) * sin(PI * z);\\n \\n return 0;\\n  }\\n \\n template <>\\n Tensor<1, 2> Solution<2>::gradient(const Point<2>    &p,\\n const unsigned int component) const\\n {\\n Assert(component <= 2, ExcIndexRange(component, 0, 2 + 1));\\n \\n using numbers::PI;\\n const double x = p[0];\\n const double y = p[1];\\n \\n Tensor<1, 2> return_value;\\n if (component == 0)\\n      {\\n        return_value[0] = PI * cos(PI * x);\\n        return_value[1] = 0.0;\\n      }\\n else if (component == 1)\\n      {\\n        return_value[0] = y * PI * PI * sin(PI * x);\\n        return_value[1] = -PI * cos(PI * x);\\n      }\\n else if (component == 2)\\n      {\\n        return_value[0] = PI * cos(PI * x) * cos(PI * y);\\n        return_value[1] = -PI * sin(PI * x) * sin(PI * y);\\n      }\\n \\n return return_value;\\n  }\\n \\n template <>\\n Tensor<1, 3> Solution<3>::gradient(const Point<3>    &p,\\n const unsigned int component) const\\n {\\n Assert(component <= 3, ExcIndexRange(component, 0, 3 + 1));\\n \\n using numbers::PI;\\n const double x = p[0];\\n const double y = p[1];\\n const double z = p[2];\\n \\n Tensor<1, 3> return_value;\\n if (component == 0)\\n      {\\n        return_value[0] = 2 * PI * cos(PI * x);\\n        return_value[1] = 0.0;\\n        return_value[2] = 0.0;\\n      }\\n else if (component == 1)\\n      {\\n        return_value[0] = y * PI * PI * sin(PI * x);\\n        return_value[1] = -PI * cos(PI * x);\\n        return_value[2] = 0.0;\\n      }\\n else if (component == 2)\\n      {\\n        return_value[0] = z * PI * PI * sin(PI * x);\\n        return_value[1] = 0.0;\\n        return_value[2] = -PI * cos(PI * x);\\n      }\\n else if (component == 3)\\n      {\\n        return_value[0] = PI * cos(PI * x) * cos(PI * y) * sin(PI * z);\\n        return_value[1] = -PI * sin(PI * x) * sin(PI * y) * sin(PI * z);\\n        return_value[2] = PI * sin(PI * x) * cos(PI * y) * cos(PI * z);\\n      }\\n \\n return return_value;\\n  }\\n \\n template <int dim>\\n class RightHandSide : public Function<dim>\\n  {\\n public:\\n    RightHandSide()\\n      : Function<dim>(dim + 1)\\n    {}\\n \\n virtual double value(const Point<dim>  &p,\\n const unsigned int component = 0) const override;\\n  };\\n \\n template <>\\n double RightHandSide<2>::value(const Point<2>    &p,\\n const unsigned int component) const\\n {\\n Assert(component <= 2, ExcIndexRange(component, 0, 2 + 1));\\n \\n using numbers::PI;\\n const double x = p[0];\\n const double y = p[1];\\n if (component == 0)\\n return PI * PI * sin(PI * x) + PI * cos(PI * x) * cos(PI * y);\\n if (component == 1)\\n return -PI * PI * PI * y * cos(PI * x) - PI * sin(PI * y) * sin(PI * x);\\n if (component == 2)\\n return 0;\\n \\n return 0;\\n  }\\n \\n template <>\\n double RightHandSide<3>::value(const Point<3>    &p,\\n const unsigned int component) const\\n {\\n Assert(component <= 3, ExcIndexRange(component, 0, 3 + 1));\\n \\n using numbers::PI;\\n const double x = p[0];\\n const double y = p[1];\\n const double z = p[2];\\n if (component == 0)\\n return 2 * PI * PI * sin(PI * x) +\\n             PI * cos(PI * x) * cos(PI * y) * sin(PI * z);\\n if (component == 1)\\n return -PI * PI * PI * y * cos(PI * x) +\\n             PI * (-1) * sin(PI * y) * sin(PI * x) * sin(PI * z);\\n if (component == 2)\\n return -PI * PI * PI * z * cos(PI * x) +\\n             PI * cos(PI * z) * sin(PI * x) * cos(PI * y);\\n if (component == 3)\\n return 0;\\n \\n return 0;\\n  }\\n \\n \\n \\n \\n template <class PreconditionerAType, class PreconditionerSType>\\n class BlockSchurPreconditioner : public Subscriptor\\n  {\\n public:\\n    BlockSchurPreconditioner(\\n const BlockSparseMatrix<double> &system_matrix,\\n const SparseMatrix<double>      &schur_complement_matrix,\\n const PreconditionerAType       &preconditioner_A,\\n const PreconditionerSType       &preconditioner_S,\\n const bool                       do_solve_A);\\n \\n void vmult(BlockVector<double> &dst, const BlockVector<double> &src) const;\\n \\n mutable unsigned int n_iterations_A;\\n mutable unsigned int n_iterations_S;\\n \\n private:\\n const BlockSparseMatrix<double> &system_matrix;\\n const SparseMatrix<double>      &schur_complement_matrix;\\n const PreconditionerAType       &preconditioner_A;\\n const PreconditionerSType       &preconditioner_S;\\n \\n const bool do_solve_A;\\n  };\\n \\n template <class PreconditionerAType, class PreconditionerSType>\\n  BlockSchurPreconditioner<PreconditionerAType, PreconditionerSType>::\\n    BlockSchurPreconditioner(\\n const BlockSparseMatrix<double> &system_matrix,\\n const SparseMatrix<double>      &schur_complement_matrix,\\n const PreconditionerAType       &preconditioner_A,\\n const PreconditionerSType       &preconditioner_S,\\n const bool                       do_solve_A)\\n    : n_iterations_A(0)\\n    , n_iterations_S(0)\\n    , system_matrix(system_matrix)\\n    , schur_complement_matrix(schur_complement_matrix)\\n    , preconditioner_A(preconditioner_A)\\n    , preconditioner_S(preconditioner_S)\\n    , do_solve_A(do_solve_A)\\n  {}\\n \\n \\n \\n template <class PreconditionerAType, class PreconditionerSType>\\n void\\n  BlockSchurPreconditioner<PreconditionerAType, PreconditionerSType>::vmult(\\n BlockVector<double>       &dst,\\n const BlockVector<double> &src) const\\n {\\n Vector<double> utmp(src.block(0));\\n \\n    {\\n SolverControl solver_control(1000, 1e-6 * src.block(1).l2_norm());\\n SolverCG<Vector<double>> cg(solver_control);\\n \\n      dst.block(1) = 0.0;\\n      cg.solve(schur_complement_matrix,\\n               dst.block(1),\\n               src.block(1),\\n               preconditioner_S);\\n \\n      n_iterations_S += solver_control.last_step();\\n      dst.block(1) *= -1.0;\\n    }\\n \\n    {\\n      system_matrix.block(0, 1).vmult(utmp, dst.block(1));\\n      utmp *= -1.0;\\n      utmp += src.block(0);\\n    }\\n \\n if (do_solve_A == true)\\n      {\\n SolverControl            solver_control(10000, utmp.l2_norm() * 1e-4);\\n SolverCG<Vector<double>> cg(solver_control);\\n \\n        dst.block(0) = 0.0;\\n        cg.solve(system_matrix.block(0, 0),\\n                 dst.block(0),\\n                 utmp,\\n                 preconditioner_A);\\n \\n        n_iterations_A += solver_control.last_step();\\n      }\\n else\\n      {\\n        preconditioner_A.vmult(dst.block(0), utmp);\\n        n_iterations_A += 1;\\n      }\\n  }\\n \\n template <int dim>\\n class StokesProblem\\n  {\\n public:\\n    StokesProblem(const unsigned int pressure_degree,\\n const SolverType   solver_type);\\n void run();\\n \\n private:\\n void setup_dofs();\\n void assemble_system();\\n void assemble_multigrid();\\n void solve();\\n void compute_errors();\\n void output_results(const unsigned int refinement_cycle) const;\\n \\n const unsigned int pressure_degree;\\n const SolverType   solver_type;\\n \\n Triangulation<dim> triangulation;\\n const FESystem<dim> velocity_fe;\\n const FESystem<dim> fe;\\n DoFHandler<dim>     dof_handler;\\n DoFHandler<dim>     velocity_dof_handler;\\n \\n AffineConstraints<double> constraints;\\n \\n BlockSparsityPattern      sparsity_pattern;\\n BlockSparseMatrix<double> system_matrix;\\n SparseMatrix<double>      pressure_mass_matrix;\\n \\n BlockVector<double> solution;\\n BlockVector<double> system_rhs;\\n \\n MGLevelObject<SparsityPattern>      mg_sparsity_patterns;\\n MGLevelObject<SparseMatrix<double>> mg_matrices;\\n MGLevelObject<SparseMatrix<double>> mg_interface_matrices;\\n MGConstrainedDoFs                   mg_constrained_dofs;\\n \\n TimerOutput computing_timer;\\n  };\\n \\n \\n \\n template <int dim>\\n  StokesProblem<dim>::StokesProblem(const unsigned int pressure_degree,\\n const SolverType   solver_type)\\n \\n    : pressure_degree(pressure_degree)\\n    , solver_type(solver_type)\\n    , triangulation(Triangulation<dim>::maximum_smoothing)\\n    ,\\n    velocity_fe(FE_Q<dim>(pressure_degree + 1) ^ dim)\\n    ,\\n    fe(velocity_fe, FE_Q<dim>(pressure_degree))\\n    , dof_handler(triangulation)\\n    , velocity_dof_handler(triangulation)\\n    , computing_timer(std::cout, TimerOutput::never, TimerOutput::wall_times)\\n  {}\\n \\n \\n \\n \\n template <int dim>\\n void StokesProblem<dim>::setup_dofs()\\n  {\\n TimerOutput::Scope scope(computing_timer, \\\"Setup\\\");\\n \\n    system_matrix.clear();\\n    pressure_mass_matrix.clear();\\n \\n    dof_handler.distribute_dofs(fe);\\n \\n    std::vector<unsigned int> block_component(2);\\n    block_component[0] = 0;\\n    block_component[1] = 1;\\n \\n const FEValuesExtractors::Vector velocities(0);\\n \\n if (solver_type == SolverType::FGMRES_ILU)\\n      {\\n TimerOutput::Scope ilu_specific(computing_timer, \\\"(ILU specific)\\\");\\n DoFRenumbering::Cuthill_McKee(dof_handler);\\n      }\\n \\n DoFRenumbering::block_wise(dof_handler);\\n \\n if (solver_type == SolverType::FGMRES_GMG)\\n      {\\n TimerOutput::Scope multigrid_specific(computing_timer,\\n \\\"(Multigrid specific)\\\");\\n TimerOutput::Scope setup_multigrid(computing_timer,\\n \\\"Setup - Multigrid\\\");\\n \\n        velocity_dof_handler.distribute_dofs(velocity_fe);\\n        velocity_dof_handler.distribute_mg_dofs();\\n \\n const std::set<types::boundary_id> zero_boundary_ids = {0};\\n \\n        mg_constrained_dofs.clear();\\n        mg_constrained_dofs.initialize(velocity_dof_handler);\\n        mg_constrained_dofs.make_zero_boundary_constraints(velocity_dof_handler,\\n                                                           zero_boundary_ids);\\n const unsigned int n_levels = triangulation.n_levels();\\n \\n        mg_interface_matrices.resize(0, n_levels - 1);\\n        mg_matrices.resize(0, n_levels - 1);\\n        mg_sparsity_patterns.resize(0, n_levels - 1);\\n \\n for (unsigned int level = 0; level < n_levels; ++level)\\n          {\\n DynamicSparsityPattern csp(velocity_dof_handler.n_dofs(level),\\n                                       velocity_dof_handler.n_dofs(level));\\n MGTools::make_sparsity_pattern(velocity_dof_handler, csp, level);\\n            mg_sparsity_patterns[level].copy_from(csp);\\n \\n            mg_matrices[level].reinit(mg_sparsity_patterns[level]);\\n            mg_interface_matrices[level].reinit(mg_sparsity_patterns[level]);\\n          }\\n      }\\n \\n const std::vector<types::global_dof_index> dofs_per_block =\\n DoFTools::count_dofs_per_fe_block(dof_handler, block_component);\\n const unsigned int n_u = dofs_per_block[0];\\n const unsigned int n_p = dofs_per_block[1];\\n \\n    {\\n      constraints.clear();\\n DoFTools::make_hanging_node_constraints(dof_handler, constraints);\\n VectorTools::interpolate_boundary_values(dof_handler,\\n                                               0,\\n                                               Solution<dim>(),\\n                                               constraints,\\n                                               fe.component_mask(velocities));\\n \\n if (solver_type == SolverType::UMFPACK)\\n        constraints.constrain_dof_to_zero(n_u);\\n \\n      constraints.close();\\n    }\\n \\n    std::cout << \\\"\\\\tNumber of active cells: \\\" << triangulation.n_active_cells()\\n              << std::endl\\n              << \\\"\\\\tNumber of degrees of freedom: \\\" << dof_handler.n_dofs()\\n              << \\\" (\\\" << n_u << '+' << n_p << ')' << std::endl;\\n \\n    {\\n BlockDynamicSparsityPattern csp(dofs_per_block, dofs_per_block);\\n DoFTools::make_sparsity_pattern(dof_handler, csp, constraints, false);\\n      sparsity_pattern.copy_from(csp);\\n    }\\n    system_matrix.reinit(sparsity_pattern);\\n \\n    solution.reinit(dofs_per_block);\\n    system_rhs.reinit(dofs_per_block);\\n  }\\n \\n \\n \\n template <int dim>\\n void StokesProblem<dim>::assemble_system()\\n  {\\n TimerOutput::Scope assemble(computing_timer, \\\"Assemble\\\");\\n    system_matrix = 0;\\n    system_rhs    = 0;\\n \\n const bool assemble_pressure_mass_matrix =\\n      (solver_type == SolverType::UMFPACK) ? false : true;\\n \\n const QGauss<dim> quadrature_formula(pressure_degree + 2);\\n \\n FEValues<dim> fe_values(fe,\\n                            quadrature_formula,\\n update_values | update_quadrature_points |\\n update_JxW_values | update_gradients);\\n \\n const unsigned int dofs_per_cell = fe.n_dofs_per_cell();\\n \\n const unsigned int n_q_points = quadrature_formula.size();\\n \\n FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);\\n Vector<double>     local_rhs(dofs_per_cell);\\n \\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n const RightHandSide<dim>    right_hand_side;\\n    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim + 1));\\n \\n const FEValuesExtractors::Vector velocities(0);\\n const FEValuesExtractors::Scalar pressure(dim);\\n \\n    std::vector<SymmetricTensor<2, dim>> symgrad_phi_u(dofs_per_cell);\\n    std::vector<double>                  div_phi_u(dofs_per_cell);\\n    std::vector<double>                  phi_p(dofs_per_cell);\\n \\n for (const auto &cell : dof_handler.active_cell_iterators())\\n      {\\n        fe_values.reinit(cell);\\n        local_matrix = 0;\\n        local_rhs    = 0;\\n \\n        right_hand_side.vector_value_list(fe_values.get_quadrature_points(),\\n                                          rhs_values);\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n          {\\n for (unsigned int k = 0; k < dofs_per_cell; ++k)\\n              {\\n                symgrad_phi_u[k] =\\n                  fe_values[velocities].symmetric_gradient(k, q);\\n                div_phi_u[k] = fe_values[velocities].divergence(k, q);\\n                phi_p[k]     = fe_values[pressure].value(k, q);\\n              }\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n              {\\n for (unsigned int j = 0; j <= i; ++j)\\n                  {\\n                    local_matrix(i, j) +=\\n                      (2 * (symgrad_phi_u[i] * symgrad_phi_u[j]) -\\n                       div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j] +\\n                       (assemble_pressure_mass_matrix ? phi_p[i] * phi_p[j] :\\n                                                        0)) *\\n                      fe_values.JxW(q);\\n                  }\\n \\n const unsigned int component_i =\\n                  fe.system_to_component_index(i).first;\\n                local_rhs(i) += fe_values.shape_value(i, q) *\\n                                rhs_values[q](component_i) * fe_values.JxW(q);\\n              }\\n          }\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int j = i + 1; j < dofs_per_cell; ++j)\\n            local_matrix(i, j) = local_matrix(j, i);\\n \\n        cell->get_dof_indices(local_dof_indices);\\n        constraints.distribute_local_to_global(local_matrix,\\n                                               local_rhs,\\n                                               local_dof_indices,\\n                                               system_matrix,\\n                                               system_rhs);\\n      }\\n \\n if (solver_type != SolverType::UMFPACK)\\n      {\\n        pressure_mass_matrix.reinit(sparsity_pattern.block(1, 1));\\n        pressure_mass_matrix.copy_from(system_matrix.block(1, 1));\\n        system_matrix.block(1, 1) = 0;\\n      }\\n  }\\n \\n \\n template <int dim>\\n void StokesProblem<dim>::assemble_multigrid()\\n  {\\n TimerOutput::Scope multigrid_specific(computing_timer,\\n \\\"(Multigrid specific)\\\");\\n TimerOutput::Scope assemble_multigrid(computing_timer,\\n \\\"Assemble Multigrid\\\");\\n \\n    mg_matrices = 0.;\\n \\n const QGauss<dim> quadrature_formula(pressure_degree + 2);\\n \\n FEValues<dim> fe_values(velocity_fe,\\n                            quadrature_formula,\\n update_values | update_quadrature_points |\\n update_JxW_values | update_gradients);\\n \\n const unsigned int dofs_per_cell = velocity_fe.n_dofs_per_cell();\\n const unsigned int n_q_points    = quadrature_formula.size();\\n \\n FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);\\n \\n    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);\\n \\n const FEValuesExtractors::Vector velocities(0);\\n \\n    std::vector<SymmetricTensor<2, dim>> symgrad_phi_u(dofs_per_cell);\\n \\n    std::vector<AffineConstraints<double>> boundary_constraints(\\n triangulation.n_levels());\\n    std::vector<AffineConstraints<double>> boundary_interface_constraints(\\n triangulation.n_levels());\\n for (unsigned int level = 0; level < triangulation.n_levels(); ++level)\\n      {\\n for (const types::global_dof_index dof_index :\\n             mg_constrained_dofs.get_refinement_edge_indices(level))\\n          boundary_constraints[level].constrain_dof_to_zero(dof_index);\\n for (const types::global_dof_index dof_index :\\n             mg_constrained_dofs.get_boundary_indices(level))\\n          boundary_constraints[level].constrain_dof_to_zero(dof_index);\\n        boundary_constraints[level].close();\\n \\n const IndexSet idx =\\n          mg_constrained_dofs.get_refinement_edge_indices(level) &\\n          mg_constrained_dofs.get_boundary_indices(level);\\n \\n for (const types::global_dof_index dof_index : idx)\\n          boundary_interface_constraints[level].add_constraint(dof_index,\\n                                                               {},\\n                                                               0.);\\n        boundary_interface_constraints[level].close();\\n      }\\n \\n for (const auto &cell : velocity_dof_handler.cell_iterators())\\n      {\\n        fe_values.reinit(cell);\\n cell_matrix = 0;\\n \\n for (unsigned int q = 0; q < n_q_points; ++q)\\n          {\\n for (unsigned int k = 0; k < dofs_per_cell; ++k)\\n              symgrad_phi_u[k] = fe_values[velocities].symmetric_gradient(k, q);\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int j = 0; j <= i; ++j)\\n                {\\n cell_matrix(i, j) +=\\n                    (symgrad_phi_u[i] * symgrad_phi_u[j]) * fe_values.JxW(q);\\n                }\\n          }\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int j = i + 1; j < dofs_per_cell; ++j)\\n cell_matrix(i, j) = cell_matrix(j, i);\\n \\n        cell->get_mg_dof_indices(local_dof_indices);\\n \\n        boundary_constraints[cell->level()].distribute_local_to_global(\\n          cell_matrix, local_dof_indices, mg_matrices[cell->level()]);\\n \\n for (unsigned int i = 0; i < dofs_per_cell; ++i)\\n for (unsigned int j = 0; j < dofs_per_cell; ++j)\\n if (!mg_constrained_dofs.at_refinement_edge(cell->level(),\\n                                                        local_dof_indices[i]) ||\\n                mg_constrained_dofs.at_refinement_edge(cell->level(),\\n                                                       local_dof_indices[j]))\\n cell_matrix(i, j) = 0;\\n \\n        boundary_interface_constraints[cell->level()]\\n          .distribute_local_to_global(cell_matrix,\\n                                      local_dof_indices,\\n                                      mg_interface_matrices[cell->level()]);\\n      }\\n  }\\n \\n \\n template <int dim>\\n void StokesProblem<dim>::solve()\\n  {\\n TimerOutput::Scope solve(computing_timer, \\\"Solve\\\");\\n    constraints.set_zero(solution);\\n \\n if (solver_type == SolverType::UMFPACK)\\n      {\\n        computing_timer.enter_subsection(\\\"(UMFPACK specific)\\\");\\n        computing_timer.enter_subsection(\\\"Solve - Initialize\\\");\\n \\n SparseDirectUMFPACK A_direct;\\n        A_direct.initialize(system_matrix);\\n \\n        computing_timer.leave_subsection();\\n        computing_timer.leave_subsection();\\n \\n        {\\n TimerOutput::Scope solve_backslash(computing_timer,\\n \\\"Solve - Backslash\\\");\\n          A_direct.vmult(solution, system_rhs);\\n        }\\n \\n        constraints.distribute(solution);\\n return;\\n      }\\n \\n SolverControl solver_control(system_matrix.m(),\\n                                 1e-10 * system_rhs.l2_norm());\\n unsigned int  n_iterations_A;\\n unsigned int  n_iterations_S;\\n \\n const bool use_expensive = true;\\n \\n SolverFGMRES<BlockVector<double>> solver(solver_control);\\n \\n if (solver_type == SolverType::FGMRES_ILU)\\n      {\\n        computing_timer.enter_subsection(\\\"(ILU specific)\\\");\\n        computing_timer.enter_subsection(\\\"Solve - Set-up Preconditioner\\\");\\n \\n        std::cout << \\\"   Computing preconditioner...\\\" << std::endl\\n                  << std::flush;\\n \\n SparseILU<double> A_preconditioner;\\n        A_preconditioner.initialize(system_matrix.block(0, 0));\\n \\n SparseILU<double> S_preconditioner;\\n        S_preconditioner.initialize(pressure_mass_matrix);\\n \\n const BlockSchurPreconditioner<SparseILU<double>, SparseILU<double>>\\n          preconditioner(system_matrix,\\n                         pressure_mass_matrix,\\n                         A_preconditioner,\\n                         S_preconditioner,\\n                         use_expensive);\\n \\n        computing_timer.leave_subsection();\\n        computing_timer.leave_subsection();\\n \\n        {\\n TimerOutput::Scope solve_fmgres(computing_timer, \\\"Solve - FGMRES\\\");\\n \\n          solver.solve(system_matrix, solution, system_rhs, preconditioner);\\n          n_iterations_A = preconditioner.n_iterations_A;\\n          n_iterations_S = preconditioner.n_iterations_S;\\n        }\\n      }\\n else\\n      {\\n        computing_timer.enter_subsection(\\\"(Multigrid specific)\\\");\\n        computing_timer.enter_subsection(\\\"Solve - Set-up Preconditioner\\\");\\n \\n MGTransferPrebuilt<Vector<double>> mg_transfer(mg_constrained_dofs);\\n        mg_transfer.build(velocity_dof_handler);\\n \\n FullMatrix<double> coarse_matrix;\\n        coarse_matrix.copy_from(mg_matrices[0]);\\n MGCoarseGridHouseholder<double, Vector<double>> coarse_grid_solver;\\n        coarse_grid_solver.initialize(coarse_matrix);\\n \\n using Smoother = PreconditionSOR<SparseMatrix<double>>;\\n mg::SmootherRelaxation<Smoother, Vector<double>> mg_smoother;\\n        mg_smoother.initialize(mg_matrices);\\n        mg_smoother.set_steps(2);\\n \\n        mg_smoother.set_symmetric(true);\\n \\n mg::Matrix<Vector<double>> mg_matrix(mg_matrices);\\n mg::Matrix<Vector<double>> mg_interface_up(mg_interface_matrices);\\n mg::Matrix<Vector<double>> mg_interface_down(mg_interface_matrices);\\n \\n Multigrid<Vector<double>> mg(\\n          mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);\\n mg.set_edge_matrices(mg_interface_down, mg_interface_up);\\n \\n PreconditionMG<dim, Vector<double>, MGTransferPrebuilt<Vector<double>>>\\n          A_Multigrid(velocity_dof_handler, mg, mg_transfer);\\n \\n SparseILU<double> S_preconditioner;\\n        S_preconditioner.initialize(pressure_mass_matrix,\\n SparseILU<double>::AdditionalData());\\n \\n const BlockSchurPreconditioner<\\n PreconditionMG<dim,\\n Vector<double>,\\n MGTransferPrebuilt<Vector<double>>>,\\n SparseILU<double>>\\n          preconditioner(system_matrix,\\n                         pressure_mass_matrix,\\n                         A_Multigrid,\\n                         S_preconditioner,\\n                         use_expensive);\\n \\n        computing_timer.leave_subsection();\\n        computing_timer.leave_subsection();\\n \\n        {\\n TimerOutput::Scope solve_fmgres(computing_timer, \\\"Solve - FGMRES\\\");\\n          solver.solve(system_matrix, solution, system_rhs, preconditioner);\\n          n_iterations_A = preconditioner.n_iterations_A;\\n          n_iterations_S = preconditioner.n_iterations_S;\\n        }\\n      }\\n \\n    constraints.distribute(solution);\\n \\n    std::cout\\n      << std::endl\\n      << \\\"\\\\tNumber of FGMRES iterations: \\\" << solver_control.last_step()\\n      << std::endl\\n      << \\\"\\\\tTotal number of iterations used for approximation of A inverse: \\\"\\n      << n_iterations_A << std::endl\\n      << \\\"\\\\tTotal number of iterations used for approximation of S inverse: \\\"\\n      << n_iterations_S << std::endl\\n      << std::endl;\\n  }\\n \\n \\n \\n template <int dim>\\n void StokesProblem<dim>::compute_errors()\\n  {\\n const double mean_pressure = VectorTools::compute_mean_value(\\n      dof_handler, QGauss<dim>(pressure_degree + 2), solution, dim);\\n    solution.block(1).add(-mean_pressure);\\n    std::cout << \\\"   Note: The mean value was adjusted by \\\" << -mean_pressure\\n              << std::endl;\\n \\n const ComponentSelectFunction<dim> pressure_mask(dim, dim + 1);\\n const ComponentSelectFunction<dim> velocity_mask(std::make_pair(0, dim),\\n                                                     dim + 1);\\n \\n Vector<float> difference_per_cell(triangulation.n_active_cells());\\n VectorTools::integrate_difference(dof_handler,\\n                                      solution,\\n                                      Solution<dim>(),\\n                                      difference_per_cell,\\n QGauss<dim>(pressure_degree + 2),\\n VectorTools::L2_norm,\\n                                      &velocity_mask);\\n \\n const double Velocity_L2_error =\\n VectorTools::compute_global_error(triangulation,\\n                                        difference_per_cell,\\n VectorTools::L2_norm);\\n \\n VectorTools::integrate_difference(dof_handler,\\n                                      solution,\\n                                      Solution<dim>(),\\n                                      difference_per_cell,\\n QGauss<dim>(pressure_degree + 2),\\n VectorTools::L2_norm,\\n                                      &pressure_mask);\\n \\n const double Pressure_L2_error =\\n VectorTools::compute_global_error(triangulation,\\n                                        difference_per_cell,\\n VectorTools::L2_norm);\\n \\n VectorTools::integrate_difference(dof_handler,\\n                                      solution,\\n                                      Solution<dim>(),\\n                                      difference_per_cell,\\n QGauss<dim>(pressure_degree + 2),\\n VectorTools::H1_norm,\\n                                      &velocity_mask);\\n \\n const double Velocity_H1_error =\\n VectorTools::compute_global_error(triangulation,\\n                                        difference_per_cell,\\n VectorTools::H1_norm);\\n \\n    std::cout << std::endl\\n              << \\\"   Velocity L2 Error: \\\" << Velocity_L2_error << std::endl\\n              << \\\"   Pressure L2 Error: \\\" << Pressure_L2_error << std::endl\\n              << \\\"   Velocity H1 Error: \\\" << Velocity_H1_error << std::endl;\\n  }\\n \\n \\n \\n template <int dim>\\n void\\n  StokesProblem<dim>::output_results(const unsigned int refinement_cycle) const\\n {\\n    std::vector<std::string> solution_names(dim, \\\"velocity\\\");\\n    solution_names.emplace_back(\\\"pressure\\\");\\n \\n    std::vector<DataComponentInterpretation::DataComponentInterpretation>\\n      data_component_interpretation(\\n        dim, DataComponentInterpretation::component_is_part_of_vector);\\n    data_component_interpretation.push_back(\\n DataComponentInterpretation::component_is_scalar);\\n \\n DataOut<dim> data_out;\\n    data_out.attach_dof_handler(dof_handler);\\n    data_out.add_data_vector(solution,\\n                             solution_names,\\n DataOut<dim>::type_dof_data,\\n                             data_component_interpretation);\\n    data_out.build_patches();\\n \\n    std::ofstream output(\\n \\\"solution-\\\" + Utilities::int_to_string(refinement_cycle, 2) + \\\".vtk\\\");\\n    data_out.write_vtk(output);\\n  }\\n \\n \\n \\n \\n template <int dim>\\n void StokesProblem<dim>::run()\\n  {\\n GridGenerator::hyper_cube(triangulation);\\n triangulation.refine_global(6 - dim);\\n \\n if (solver_type == SolverType::FGMRES_ILU)\\n      std::cout << \\\"Now running with ILU\\\" << std::endl;\\n else if (solver_type == SolverType::FGMRES_GMG)\\n      std::cout << \\\"Now running with Multigrid\\\" << std::endl;\\n else\\n      std::cout << \\\"Now running with UMFPACK\\\" << std::endl;\\n \\n \\n for (unsigned int refinement_cycle = 0; refinement_cycle < 3;\\n         ++refinement_cycle)\\n      {\\n        std::cout << \\\"Refinement cycle \\\" << refinement_cycle << std::endl;\\n \\n if (refinement_cycle > 0)\\n triangulation.refine_global(1);\\n \\n        std::cout << \\\"   Set-up...\\\" << std::endl;\\n        setup_dofs();\\n \\n        std::cout << \\\"   Assembling...\\\" << std::endl;\\n        assemble_system();\\n \\n if (solver_type == SolverType::FGMRES_GMG)\\n          {\\n            std::cout << \\\"   Assembling Multigrid...\\\" << std::endl;\\n \\n            assemble_multigrid();\\n          }\\n \\n        std::cout << \\\"   Solving...\\\" << std::flush;\\n        solve();\\n \\n        compute_errors();\\n \\n        output_results(refinement_cycle);\\n \\n Utilities::System::MemoryStats mem;\\n Utilities::System::get_memory_stats(mem);\\n        std::cout << \\\"   VM Peak: \\\" << mem.VmPeak << std::endl;\\n \\n        computing_timer.print_summary();\\n        computing_timer.reset();\\n      }\\n  }\\n} // namespace Step56\\n \\nint main()\\n{\\n try\\n    {\\n using namespace Step56;\\n \\n const int degree = 1;\\n const int dim    = 3;\\n      StokesProblem<dim> flow_problem(degree, SolverType::FGMRES_GMG);\\n \\n      flow_problem.run();\\n    }\\n catch (std::exception &exc)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Exception on processing: \\\" << std::endl\\n                << exc.what() << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n \\n return 1;\\n    }\\n catch (...)\\n    {\\n      std::cerr << std::endl\\n                << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n      std::cerr << \\\"Unknown exception!\\\" << std::endl\\n                << \\\"Aborting!\\\" << std::endl\\n                << \\\"----------------------------------------------------\\\"\\n                << std::endl;\\n return 1;\\n    }\\n \\n return 0;\\n}\\naffine_constraints.h\\nblock_sparse_matrix.h\\nblock_sparsity_pattern.h\\nblock_vector.h\\nBlockVectorBase::blockBlockType & block(const unsigned int i)\\nDataOutInterface::write_vtkvoid write_vtk(std::ostream &out) constDefinition data_out_base.cc:7681\\nDataOut_DoFData::add_data_vectorvoid add_data_vector(const VectorType &data, const std::vector< std::string > &names, const DataVectorType type=type_automatic, const std::vector< DataComponentInterpretation::DataComponentInterpretation > &data_component_interpretation={})Definition data_out_dof_data.h:1069\\nDataOut::build_patchesvirtual void build_patches(const unsigned int n_subdivisions=0)Definition data_out.cc:1062\\nMGSmoother::set_stepsvoid set_steps(const unsigned int)\\nMGSmoother::set_symmetricvoid set_symmetric(const bool)\\nSparseDirectUMFPACK::vmultvoid vmult(Vector< double > &dst, const Vector< double > &src) constDefinition sparse_direct.cc:795\\ndof_handler.h\\ndof_renumbering.h\\ndof_tools.h\\ndynamic_sparsity_pattern.h\\nerror_estimator.h\\nfe_values.h\\nfe_q.h\\nfe_system.h\\nfull_matrix.h\\nfunction.h\\ngrid_refinement.h\\ntria.h\\ngrid_generator.h\\ngrid_out.h\\ngrid_tools.h\\nutilities.h\\nmg_coarse.h\\nmg_matrix.h\\nmg_smoother.h\\nmg_tools.h\\nmg_transfer.h\\nmultigrid.h\\nWorkStream::internal::tbb_no_coloring::runvoid run(const Iterator &begin, const std_cxx20::type_identity_t< Iterator > &end, Worker worker, Copier copier, const ScratchData &sample_scratch_data, const CopyData &sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)Definition work_stream.h:471\\ninternal::assemblevoid assemble(const MeshWorker::DoFInfoBox< dim, DOFINFO > &dinfo, A *assembler)Definition loop.h:70\\ninternal::EvaluatorQuantity::value@ value\\ninternal::EvaluatorQuantity::gradient@ gradient\\nstdSTL namespace.\\ndata_out.h\\nprecondition.h\\nquadrature_lib.h\\nsolver_cg.h\\nsolver_gmres.h\\nsparse_direct.h\\nsparse_ilu.h\\nUtilities::System::MemoryStats::VmPeakunsigned long int VmPeakDefinition utilities.h:868\\ntimer.h\\nvector_tools.h\\n \\n\\n\\n\\n\\nGenerated by\\u00a0 1.11.0\\n\\n\\n\\n\\n\", \"type\": \"Document\"}}]"